- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Key Management with KMS and CloudHSM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encryption is like turning our message into a secret code so that only the intended
    recipient can understand it. Imagine that we have a message that we do not want
    anyone else to read. The message, in its original form, is called **plain text**
    . After we encode it, it becomes **cipher text** , which looks like gibberish
    to anyone who does not know how to decode it. Converting the plain text into cipher
    text is called **encryption** , and converting the cipher text back into plain
    text is called **decryption** . To carry out encryption and decryption, we use
    a set of mathematical rules known as an **encryption algorithm** . Examples of
    encryption algorithms include **Rivest-Shamir-Adleman** ( **RSA** ), **Advanced
    Encryption Standard** ( **AES** ), **Data Encryption Standard** ( **DES** ), **Triple
    Data Encryption Standard** ( **3DES** ), **Blowfish** , **Twofish** , **Elliptic
    Curve Cryptography** ( **ECC** ), **International Data Encryption Algorithm**
    ( **IDEA** ), and **Pretty Good** **Privacy** ( **PGP** ).
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be wondering, if encryption algorithms are public knowledge, what’s
    to prevent anyone from decrypting the data? The answer lies in the use of **encryption
    keys** – unique strings of characters that safeguard data when used alongside
    the algorithm. There are two primary types of encryptions: **symmetric** and **asymmetric**
    . Symmetric encryption employs the same key for both encryption and decryption,
    necessitating that this key be kept confidential between the parties involved.
    Asymmetric encryption, in contrast, utilizes a key pair – one key for encryption
    and the other for decryption. For instance, a public key, which can be openly
    shared, can be used for encryption, and a private key, which is strictly guarded
    by the intended recipient, can be used for decryption. Thus, the privacy of encrypted
    data remains protected, even with the widespread knowledge of the algorithm, due
    to the confidential nature of the encryption keys.'
  prefs: []
  type: TYPE_NORMAL
- en: AWS **Key Management Service** ( **KMS** ) is the primary service within the
    AWS cloud that helps us create and manage encryption keys and is the primary focus
    of this chapter. KMS supports both symmetric and asymmetric encryption keys. Based
    on ownership, we can categorize KMS keys as **customer-managed keys** , **AWS-managed
    keys** , and **AWS-owned keys** . With customer-managed keys, we create and manage
    keys. With AWS-managed keys, AWS creates a key in our account for a particular
    service, such as S3, EBS, and so on, and manages the key for us. AWS also has
    another key type called AWS-owned keys that AWS creates and manages for use cases
    such as default encryption for services such as S3. With both customer-managed
    and AWS-managed keys, we have visibility into various keys and their usage through
    CloudTrail logs. However, with AWS-owned keys, we do not have any visibility.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to work with AWS **CloudHSM** . CloudHSM
    is another service within AWS that allows us to manage encryption keys but uses
    dedicated HSMs for enhanced security. KMS makes use of shared **hardware security**
    **modules** ( **HSMs** ).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating keys in KMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating keys with external key material (BYOK)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating keys in KMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granting permissions programmatically with grants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using key policies with conditional keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing customer-managed keys across accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, initializing, and activating a CloudHSM cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the recipes in this chapter, we need to ensure we have the
    following requirements in place:'
  prefs: []
  type: TYPE_NORMAL
- en: We need an active AWS account to complete the recipes in this chapter. We can
    use an account that is part of AWS Organizations or a standalone account. I will
    be using the **awsseccb-sandbox-1** account that we created in the *Multi-account
    management with AWS Organizations* recipe in [*Chapter 1*](B21384_01.xhtml#_idTextAnchor020)
    . However, I won’t be utilizing any AWS Organizations features, meaning you can
    follow these steps with a standalone account too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For administrative actions, we need a user who has **AdministratorAccess** permission
    to the AWS account we are working with. This can be an **IAM Identity Center user**
    or an IAM user. I will be using the IAM Identity Center user **awsseccbadmin1**
    we created in the *User management and SSO with IAM Identity Center* recipe in
    [*Chapter 1*](B21384_01.xhtml#_idTextAnchor020) . However, I won’t be utilizing
    any IAM Identity Center features, meaning you can follow these steps with an IAM
    user, too, if the user has **AdministratorAccess** permission within the account.
    You can create an IAM user by following the *Setting up IAM, account aliases,
    and billing alerts* recipe in [*Chapter 1*](B21384_01.xhtml#_idTextAnchor020)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of encryption, including symmetric keys, asymmetric keys, and
    **public key infrastructure** ( **PKI** ) will help you understand the recipes
    within this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this book are available at [https://github.com/PacktPublishing/AWS-Security-Cookbook-Second-Edition](https://github.com/PacktPublishing/AWS-Security-Cookbook-Second-Edition)
    . The code files for this chapter are available at [https://github.com/PacktPublishing/AWS-Security-Cookbook-Second-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/AWS-Security-Cookbook-Second-Edition/tree/main/Chapter03)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Creating keys in KMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a customer-managed KMS key with the key type
    set to **symmetric key** . A symmetric key is the most common key that we will
    create with KMS. It is also worth noting that KMS keys, which are the primary
    resources within KMS, were once known as **customer master keys** ( **CMKs** ).
    This renaming helps avoid confusion with the term customer-managed keys, which
    could also be abbreviated as CMKs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need the following to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: A working AWS account ( **awsseccb-sandbox-1** ) and a user ( **awsseccbadmin1**
    ), as described in the *Technical* *requirements* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two users or roles. These could be IAM users or roles, including those corresponding
    to IAM Identity Center users. I will be using the **awsseccb_admin1** user as
    the **key administrator** . Key administrators can administer the key through
    the KMS API. I will use another user, **awsseccb_user1** , as the **key user**
    . Key users can use the customer-managed key to encrypt and decrypt data. We can
    even use the same user as both a key administrator and a key user. I will also
    explain how we can use a role corresponding to an IAM Identity Center user as
    a key administrator or key user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create a customer-managed key in KMS from the console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS Management Console and go to **Key** **Management Service**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Customer-managed keys** from the left sidebar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create key** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Configure key** step, as shown in the following figure, select **Symmetric**
    for **Key type** , and choose **Encrypt and decrypt** for **Key usage** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Configuring Key type and Key usage](image/B21384_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Configuring Key type and Key usage
  prefs: []
  type: TYPE_NORMAL
- en: 'Expand **Advanced options** and verify that **Key material origin** is set
    to **KMS - recommended** and **Regionality** is set to **Single-region key** ,
    as shown in the following figure. Then, click **Next** to proceed to the **Add**
    **labels** steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Advanced options](image/B21384_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Advanced options
  prefs: []
  type: TYPE_NORMAL
- en: In the **Add labels** step, enter **seccb-dev-encryption** for **Alias** and
    **Dev Encryption Key for the Sec CB project** for **Description** . Optionally,
    add tags by clicking on the **Add tag** button. Click **Next** to proceed to the
    **Define key administrative** **permissions** step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Define key administrative permissions** step, select **Key administrators**
    , who are the IAM users and roles who can administer this key through the KMS
    API. I have selected **awsseccb_admin1** . However, as we can see, if we are using
    an IAM Identity Center user, we can select a role corresponding to the combination
    of that IAM Identity Center user and a **permission set** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Defining key administrative permissions](image/B21384_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Defining key administrative permissions
  prefs: []
  type: TYPE_NORMAL
- en: For **Key deletion** , check **Allow key administrators to delete this key**
    . Click **Next** to proceed to the **Define key usage** **permissions** step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regarding the **Define key usage permissions** step, select **Key users** ,
    who are IAM users and roles who can use the customer-managed key to encrypt and
    decrypt data. In the same step, we can optionally add **Other AWS accounts** that
    can use this key. I have selected the **awsseccb_user1** user. Similar to *Step
    7* , if we are using an IAM Identity Center user, we can select a role corresponding
    to the combination of that IAM Identity Center user and a permission set. Click
    **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Review **Key configuration** , **Alias and description** , **Tags** , and **Key
    policy** in JSON format. Click **Finish** to create the key. We should see a message
    stating that the key has been created, as well as details of the key ID, as shown
    in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Key creation success message](image/B21384_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Key creation success message
  prefs: []
  type: TYPE_NORMAL
- en: The key policy that’s generated by AWS is kept within the code files for reference
    as **generated-key-policy.json** .
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we created a KMS key. We will go through some important concepts
    related to KMS keys in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating encryption keys within AWS KMS involves a straightforward process.
    First, we need an active AWS account with an IAM or IAM Identity Center user with
    administrative privileges to create and manage keys. We should have the **kms:CreateKey**
    permission to create new KMS keys. To add tags, we need **kms:TagResource** permission.
    We used a user with **AdministratorAccess** for this recipe and hence had both
    of these permissions.
  prefs: []
  type: TYPE_NORMAL
- en: While configuring the key, we selected the symmetric KMS key option for general
    encryption and decryption purposes, as shown in *Figure 3* *.1* . In the **Advanced
    options** section, we selected the **key material** origin as KMS, which is the
    recommended option. In the world of cryptography, key material refers to the string
    of bits that are used in a cryptographic algorithm and is the core element that
    encrypts and decrypts our data. Each AWS KMS key is associated with a key material,
    as referenced in its metadata. By default, AWS is responsible for creating the
    key material using FIPS-validated hardware security modules, and it never leaves
    AWS KMS unencrypted. The sole exception lies in the public keys of asymmetric
    key pairs, which can be exported for outside use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key material’s origin is a specific attribute of a KMS key in AWS KMS,
    which indicates the source from which its key material is derived. The key material
    origin values for a KMS key can be one of the following, as we saw in *Figure
    3* *.2* :'
  prefs: []
  type: TYPE_NORMAL
- en: '**KMS - recommended** is the default and most recommended. If we select this
    option, AWS handles the creation and management of the key material.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External (Import key material)** is for people who prefer to import their
    own key material. This requires us to manage and secure this material.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With **AWS CloudHSM key store** , AWS KMS creates the key material in our AWS
    CloudHSM cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External key store** is used when the key material is in an external key
    manager outside AWS. This is specific to KMS keys in an external key store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we saw in *Figure 3* *.3* , we can assign IAM users or roles as key administrators.
    Key administrators are the IAM users and roles who can administer this key through
    the KMS API. We also chose the option to allow key administrators to delete the
    key. Similarly, we can assign IAM users or roles as key users. Key users are IAM
    users and roles that can use the customer-managed key to encrypt and decrypt data.
  prefs: []
  type: TYPE_NORMAL
- en: A KMS key policy is a JSON document that specifies who can access the key and
    under what conditions. Along with the key, AWS will create a default key policy
    and assign required permissions for the key administrators and key users we select.
    If we explore the generated key policy, we should be able to see the **kms:Create***
    , **kms:Describe*** , **kms:Enable*** , **kms:List*** , **kms:Put*** , **kms:Update***
    , **kms:Revoke*** , **kms:Disable*** , **kms:Get*** , **kms:Delete*** , **kms:TagResource**
    , **kms:UntagResource** , **kms:ScheduleKeyDeletion** , and **kms:CancelKeyDeletion**
    permissions for key administators. For key users, we should see the **kms:Encrypt**
    , **kms:Decrypt** , **kms:ReEncrypt*** , **kms:GenerateDataKey*** , and **kms:DescribeKey**
    permissions. These permissions should also give us an idea about the operations
    we can perform within KMS.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a key using the standard options available within
    KMS. We can configure these options based on our requirements. For example, in
    this recipe, we chose the option to allow key administrators to delete the key.
    Based on our security requirements, we may unselect this option to not allow key
    administrators to delete the key.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Play around with all the options available within KMS and get familiar with
    them. This will help you decide on what options to choose when you are faced with
    a scenario at work, in an exam, or in an interview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly go through some important points about the AWS KMS service:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a symmetric key in this recipe. AWS KMS also has support for asymmetric
    keys. AWS KMS allows you to create and manage asymmetric key pairs for encryption
    and signing, facilitating scenarios that require PKI, such as encrypting data
    so that only the private key holder can decrypt it, or signing data for sender
    verification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS KMS keys can encrypt data up to 4 KB in size and hence are generally used
    to encrypt other keys, such as **data keys** . These data keys are then used to
    encrypt the actual data. These data keys are not created and managed within the
    AWS KMS service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KMS is a region-specific service and, hence, the keys managed by KMS are region-specific.
    Therefore, to use KMS keys, the respective services should also be in the same
    region. For example, to use the key that we created for encrypting S3 data, the
    S3 bucket needs to be in the same region.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KMS supports a feature called **multi-region keys** , which allows data to be
    decrypted in a region different from the one where it was encrypted. It is important
    to note that these keys are not currently global. Instead, there is a primary
    key that is replicated to replica keys in other regions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user with S3 administrator permissions will not have permission to view a
    file encrypted using KMS key encryption unless they are a key user for the key
    being used to encrypt that file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key administrators do not have permission to encrypt or decrypt data using those
    keys. Key administrators, however, can modify the key policy to add themselves
    as key users. This is where the audit and logging services become important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS KMS integrates with AWS CloudTrail to provide logs of all key usage to help
    meet compliance and regulatory requirements. This integration allows users to
    track when and who used KMS keys for encryption and decryption, providing an audit
    trail that can be crucial for forensic analysis and compliance audits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We cannot directly delete a key. A key administrator can disable and/or schedule
    a key for deletion. At the time of writing, the administrator can specify a waiting
    period between 7 and 30 days inclusive while scheduling a key deletion. With multi-region
    keys, we need to first delete the replica keys; only then can we delete the primary
    key. Therefore, the minimum number of days to delete a multi-region key is 14
    days: 7 days for deleting the replica keys and 7 days for deleting the primary
    key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a key has been disabled, we cannot decrypt any data that is encrypted with
    that key until we enable that key again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a key has been deleted, we cannot decrypt any data encrypted with that
    key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A good understanding of encryption can help you better understand the AWS KMS
    service. You can learn about encryption here: [https://www.secdops.com/blog/getting-started-with-encryption](https://www.secdops.com/blog/getting-started-with-encryption)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS KMS is a service with a lot of features. You can start reading more about
    KMS and its features here: [https://www.cloudericks.com/blog/getting-started-with-aws-key-management-service-kms](https://www.cloudericks.com/blog/getting-started-with-aws-key-management-service-kms)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating keys with external key material (BYOK)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create keys within AWS KMS, AWS creates and manages the key material
    for that key. We can also create keys using our own key material that has been
    created outside of AWS. In this recipe, we will learn how to import a key material
    into AWS KMS. Using external key material for our keys is called **Bring Your
    Own Key** ( **BYOK** ) and is useful for organizations that have strict compliance
    or policy requirements that mandate the use of keys they control. This key should
    be a 256-bit symmetric key. Asymmetric keys are not supported for BYOK.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need the following to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: A working AWS account, **awsseccb-sandbox-1** , and a user, **awsseccbadmin1**
    , as described in the *Technical* *requirements* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latest OpenSSL setup on our local machine. If it’s not already installed,
    go to the OpenSSL website at [https://www.openssl.org](https://www.openssl.org)
    , download the latest version of OpenSSL, and set it up locally while following
    the instructions. Run the **openssl version** command to make sure OpenSSL is
    installed with the latest version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re a macOS user, you might encounter an important compatibility issue:
    macOS defaults to using LibreSSL with the **openssl** command, not OpenSSL. To
    ensure you’re using the correct version of OpenSSL, you may need to install it
    via Homebrew and invoke it directly while specifying the full path or even adjust
    your system’s **PATH** settings. A simple step-by-step guide on how to do this
    is provided in the following blog post: [https://www.secdops.com/blog/using-openssl-alongside-the-default-libressl-on-macos](https://www.secdops.com/blog/using-openssl-alongside-the-default-libressl-on-macos)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we have set up and can run the **openssl version** command correctly,
    let’s proceed to use it to create external key material.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by creating our key from AWS KMS by setting the key material origin
    to **External** . Then, we will download the key import wrapper from the AWS KMS
    service, generate the key on our local machine, and wrap it with the import wrapper.
    Finally, we will upload our wrapped key material with the import wrapper to finish
    key creation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a key configuration for an external key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create a key configuration for an external key as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS Management Console and go to **Key** **Management Service**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Customer-managed keys** from the left sidebar and click **Create
    key** at the top right of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Configure key** step, for **Key type** , select **Symmetric** , and
    for **Key usage** , select **Encrypt** **and decrypt** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the **Advanced options** menu and select **External (Import Key material)**
    . Then, check the checkbox to agree that you understand the security and durability
    implications while using an external key. For **Regionality** , select **Single-region
    key** . Click **Next** to proceed to the **Add** **labels** step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Add labels** step, set **Alias** to **seccb-dev-external-key** and
    **Description** to **External Key for the Dev env** . Optionally, add tags by
    clicking on the **Add tag** button. Click **Next** to proceed to the **Define
    key administrative** **permissions** step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Define key administrative permissions** step, select **Key administrators**
    , who are the IAM users and roles who can administer this key through the KMS
    API. I have selected the **awsseccb_admin1** user, as shown in *Figure 3* *.3*
    . If you’re using an IAM Identity Center user, you can select a role corresponding
    to the combination of that IAM Identity Center user and a permission set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Key deletion** , check **Allow key administrators to delete this key**
    . Click **Next** to proceed to the **Define key usage** **permissions** step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regarding the **Define key usage permissions** step, select **Key users** –
    that is, IAM users and roles who can use the customer-managed key to encrypt and
    decrypt data. In the same step, optionally, you can add **Other AWS accounts**
    that can use this key. I have selected the **awsseccb_user1** user. If you’re
    using an IAM Identity Center user, you can select a role corresponding to the
    combination of that IAM Identity Center user and a permission set. Click **Next**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review **Key configuration** , **Alias and description** , **Tags** , and **Key
    policy** in JSON format. Click **Finish** to create the key. The key will be created,
    as shown in *Figure 3* *.4* . You should also see the **Download wrapping public
    key and import token** step now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regarding the **Download wrapping public key and import token** step, under
    the **Configuration** section, for **Select wrapping key spec** , select **RSA_4096
    - recommended** , and for **Select wrapping algorithm** , select **RSAES_OAEP_SHA_256**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Download wrapping public key and import token](image/B21384_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Download wrapping public key and import token
  prefs: []
  type: TYPE_NORMAL
- en: Click **Download wrapping public key and import token** to download the token
    on your desktop. Then, click **Next** to reach the **Upload your wrapped key material**
    page. Keep the downloaded import parameters file for the steps we will follow
    shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section we created a key configuration. In the next section, we will
    generate our key material and then return to this screen and click **Next** to
    go to the **Upload your wrapped key material** step. If we check the **Customer
    managed keys** page, we should see that **Status** is now set to **Pending import**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Generating key material using OpenSSL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assuming we have set up OpenSSL as mentioned in the *Getting ready* section,
    we can follow these steps to generate key material and encrypt it using the wrapping
    key provided by AWS KMS in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are using a symmetric key, we can use the following command to generate
    256 bytes of random data and save it to a file named **MyExternalKeyMaterial.bin**
    . This will serve as our key material:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate a file called **ExternalKeyMaterialPlaintext.bin** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Execute the following command from the same folder while providing the name
    of our wrapping key for the **inkey** parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate a file called **ExternalKeyMaterialEncrypted.bin** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With that, we’ve generated the key material. In the next section, we will upload
    this key material to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with key creation from the Management Console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can upload our key material in the AWS Management Console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the **Upload your wrapped key material** step’s page in the console.
    This is where we stopped in the *Creating a key configuration for an external*
    *key* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we are not on the **Upload your wrapped key material** step’s page, we can
    go to **Key Management Service** via the dashboard, click **Customer-managed keys**
    from the left sidebar, and then click on the hyperlink under **Aliases** for the
    key for which we downloaded the wrapping key. Go to the **Key material** tab and
    click **Import key material** . Then, click **Next** to go to the **Upload your
    wrapped key material** step’s page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Upload your wrapped key material** step’s page, click **Choose file**
    under **Wrapped key material** and select the **ExternalKeyMaterialEncrypted.bin**
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Choose file** under **Import token** and select the import token we
    downloaded from KMS in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the **Key material expires - optional** option unchecked and click **Upload
    key material** . We should see a message that the key has been uploaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key is now ready for use. If we check the **Customer managed keys** page,
    we should see that **Status** has changed from **Pending import** to **Enabled**
    .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created an AWS KMS key by setting the key material origin
    to **External** . After that, we selected one of the allowed encryption schemes
    for the key wrapper and downloaded the key wrapper. This key wrapper is the public
    key that is used to encrypt and securely upload our key material to the AWS KMS
    service. An import token from the AWS KMS service was also downloaded, along with
    the key wrapper. The import token is used to make sure the key that’s uploaded
    is the right one for the key that we downloaded for the wrapper token.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we used **SHA_256** to wrap our external key material before
    uploading it. We may also use **SHA_1** , but it is less secure. If we are using
    SHA-1, we can generate the encrypted external key material, **ExternalKeyMaterialEncrypted.bin**
    , with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s quickly go through some more details regarding importing keys into AWS
    KMS:'
  prefs: []
  type: TYPE_NORMAL
- en: When we import our key material, we are responsible for generating the key material
    with randomness, as per our security requirements. We are also responsible for
    the durability of the key material.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With imported key material, we can set an expiration date for the key material
    and also manually delete it. We can make the key available again in the future
    by importing the key material into the KMS key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot delete the key material for a KMS key with AWS key material. We can,
    however, schedule the deletion of that KMS key with 7-30 days’ notice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a KMS key has been deleted, any data that’s been encrypted by it cannot
    be decrypted. This is true for both KMS keys with AWS key material and KMS keys
    with imported key material.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key material imported into a KMS key is permanently associated with that KMS
    key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can reimport the key material. However, we cannot import a different key
    material again for that KMS key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ciphertext encrypted with a KMS key with an external key material cannot be
    decrypted by another KMS key, even if we use the same key material.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A KMS key with an imported key material must be deleted before we can reimport
    the key material again into another KMS Key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can reimport the key material into an existing KMS key if the key material
    is deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of region-wide failures that affect KMS keys, AWS won’t automatically
    restore any imported key material. In such scenarios, we need to have a copy of
    our key material to reimport it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can read more about external keys and BYOK in the following blog post:
    [https://www.cloudericks.com/blog/aws-kms-with-external-key-material-the-byok-solution](https://www.cloudericks.com/blog/aws-kms-with-external-key-material-the-byok-solution)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Rotating keys in KMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key rotation** refers to the process of changing the encryption key that’s
    used to secure our data. This practice is crucial for minimizing risk in case
    a key is compromised. AWS supports automatic and manual key rotation for customer-managed
    keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Rotating keys regularly is a best practice that needs to be followed while using
    keys. Key rotation may also be a requirement based on regulatory rules or corporate
    policies. These rules and policies may also provide guidelines on the key rotation
    frequencies. We will look at the different cases of key rotation in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need the following to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: A working AWS account, **awsseccb-sandbox-1** , and a user, **awsseccbadmin1**
    , as described in the *Technical* *requirements* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A customer-managed KMS key with AWS key material. I will be using the key with
    the **seccb-dev-encryption** alias that we created in the *Creating keys in* *KMS*
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can specify automatic key rotation every year (365 days) for customer-managed
    KMS keys with AWS key material as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS Management Console and go to **Key** **Management Service**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Customer-managed keys** on the navigation pane to list all the keys
    we have created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Aliases** or **Key ID** property of our customer-managed key
    for which we need to do the rotation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Key rotation** tab and click **Edit** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For **Key rotation** , select **Enable** and set **Rotation period (in days)**
    with a value of **365** , as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Automatic key rotation](image/B21384_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Automatic key rotation
  prefs: []
  type: TYPE_NORMAL
- en: Click **Save** . We will get a notification that the operation was successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we’ve learned how to enable automatic key rotation. We will learn
    more about key rotation in the subsequent sections of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS-managed keys are automatically rotated every year. Previously, it was every
    3 years. For customer-managed keys, AWS supports both automatic and manual key
    rotation. With automatic rotation, only the backing key of a KMS key is rotated.
    This means that the KMS key ID, ARN, region, policies, permissions, and other
    properties remain the same. Therefore, we do not need to change applications or
    aliases that use this KMS key.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we selected the option to automatically rotate our KMS key every
    year. AWS will now rotate the key every year but keep a copy of the old backing
    key to decrypt any data that was encrypted with the old backing key. AWS keeps
    the older backing keys until we delete them.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s quickly go through some of the important points related to AWS KMS key
    rotation:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic key rotation every year (365 days) is only supported for KMS keys
    with AWS key materials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can do a manual key rotation for KMS keys with AWS key material if we want
    a different duration for the key rotation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With automatic key rotation, only the KMS key is rotated, not the data keys
    encrypted with it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With automatic key rotation, new encryptions are made using the new backing
    key. However, data encrypted using an older backing key is decrypted using that
    old key. For this purpose, AWS keeps all backing keys available until we delete
    the KMS key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With automatic key rotation, even if we disable key rotation, old backing keys
    will still be available to decrypt data that was encrypted using that key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With automatic key rotation, if you disable rotation and re-enable it again,
    it will continue with the old key rotation schedule if the backing key is less
    than a year old. If the backing key is older than 365 days, it is rotated immediately
    and then rotated again every 365 days.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With automatic key rotation, key rotation will not happen if a key is pending
    deletion. If deletion is canceled, it will continue with the old key rotation
    schedule if the backing key is less than a year old. If the backing key is older
    than 365 days, it is rotated immediately and then rotated again every 365 days.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic key rotation is not supported for custom key stores backed by AWS
    CloudHSM clusters. For such KMS keys, the value of the **Origin** field is **AWS_CloudHSM**
    . In this case, we need to manually rotate keys and change any encrypted data
    or aliases to use the new key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For AWS-managed keys, we cannot change the rotation frequency, which is currently
    1 year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic key rotation can be monitored using the KMS key rotation event in
    EventBridge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the AWS KMS API to enable and disable automatic key rotation. It
    is good practice to use aliases to refer to KMS keys when we do manual key rotation.
    We can update the alias so that it points to the new target KMS key instead of
    the old one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even with manual rotation, AWS KMS can identify the right backing key that was
    used for encryption and use it for decryption, so long as we keep the older KMS
    keys available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can update aliases using the **update-alias** subcommand of the AWS KMS API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can read more about AWS KMS key rotation, including manual key rotation,
    at [https://www.cloudericks.com/blog/understanding-aws-kms-key-rotation](https://www.cloudericks.com/blog/understanding-aws-kms-key-rotation)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Granting permissions programmatically with grants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**KMS grants** can be used to give temporary granular permissions to AWS KMS
    API operations such as encrypting, decrypting, and describing keys, and more.
    We can use grants to provide access to a user in their account or even another
    account. In this recipe, we will grant access to a user so that they can encrypt
    and decrypt files using AWS KMS.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need the following to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A working AWS account with two users: a user with **AdministratorAccess** permission
    and a user with no permissions. The CLI profiles should be configured for these
    users. I will be calling these users and their CLI profiles **Adminuserprofile**
    and **testusernopermission** , respectively, following the recipes in [*Chapter
    1*](B21384_01.xhtml#_idTextAnchor020) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A KMS key. We can create one by following previous recipes in this chapter.
    Alternatively, use the following command to create a KMS key from the AWS CLI:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will provide an output similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Creating a key using the CLI](image/B21384_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Creating a key using the CLI
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding, we have to check whether our test user has any permissions
    by running the following command. Ensure you replace my **key-id** with your **key-id**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get an error message similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Response to the user permission check](image/B21384_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Response to the user permission check
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding command, we can specify the key ID alone (as we did), the complete
    key ARN, or an alias (if one is available).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how to use grants so that we can give permissions programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can grant encrypt permission to **testuser** and then use it to encrypt
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the user’s ARN from the IAM dashboard or prepare one based on the
    preceding format. We can also use the **aws iam get-user** command to get the
    user’s ARN from the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command will return a response similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Response for the get-user command](image/B21384_03_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Response for the get-user command
  prefs: []
  type: TYPE_NORMAL
- en: 'Grant **Encrypt** permission to **testuser** using the **create-grant** subcommand
    by providing the user’s ARN:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should get a response similar to the one shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Response for the create-grant subcommand](image/B21384_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Response for the create-grant subcommand
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypt data with **testuser** using the **encrypt** subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, we should get a successful response, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Response for the encrypt command after getting the permission](image/B21384_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Response for the encrypt command after getting the permission
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the grants for the key using the **list-grants** subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return a response similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Response for the list-grant command](image/B21384_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Response for the list-grant command
  prefs: []
  type: TYPE_NORMAL
- en: 'Revoke the grant with the **revoke-grant** subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can verify that the grant has been revoked by trying to encrypt it using
    **testuser** and by running the **list-grants** subcommand. Run the **encrypt**
    command, similar to *Step 2* of this recipe. We should now get an error message
    similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Response for the encrypt command after revoking the permission](image/B21384_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Response for the encrypt command after revoking the permission
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the **list-grant** subcommand, similar to *Step 3* of this recipe. We should
    now get a response similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Response for the list-grant command after revoking all the
    grants](image/B21384_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Response for the list-grant command after revoking all the grants
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can grant permission for other operations.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we granted permission to a user using the **create-grant** subcommand
    of the **aws kms** CLI command. We verified that the user could not perform encryption
    before granting permission. We verified that the user could perform encryption
    after granting permission.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we revoked the grant using the **revoke-grant** subcommand of the **aws
    kms** CLI command. We also used other subcommands, such as **list-grants** to
    list the grants for a particular key ID and **encrypt** to encrypt the plain text.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we granted permission to only one operation. We can grant permission
    to multiple operations, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s quickly go through some important concepts related to granting and revoking
    permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: The supported grant operations are **Encrypt** , **Decrypt** , **GenerateDataKey**
    , **GenerateDataKeyWithoutPlaintext** , **ReEncryptFrom** , **ReEncryptTo** ,
    **CreateGrant** , **RetireGrant** , and **DescribeKey** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the **encrypt** subcommand of the AWS KMS API to convert plain text
    into ciphertext with the help of a key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the **decrypt** subcommand of AWS KMS API to convert ciphertext into
    plain text with the help of the same key that was used for encryption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the **re-encrypt** subcommand of the AWS KMS API to decrypt and re-encrypt
    data on the server side with a new CMK without exposing the plain text on the
    client side. This subcommand can also be used to change the encryption context
    of a ciphertext.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption context is an optional additional set of key-value pairs that form
    an additional authentication check. The same encryption context that is used for
    encryption needs to be used for decryption and re-encryption. Since the encryption
    context is not a secret, it will appear in plain text within AWS CloudTrail logs,
    making it useful for monitoring and auditing cryptographic operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grants are an alternative to key policies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the same account, we can use the key ID or key ARN with the **create-grant**
    subcommand. For users in other accounts, the ARN needs to be specified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **create-grant** subcommand has a constraints parameter that accepts an
    encryption context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we create grants, the permissions may not be reflected immediately due
    to the eventual consistency model followed by AWS. By using the grant tokens that
    are received from the **create-grant** subcommand in further requests, we can
    avoid any delays due to eventual consistency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **list-grants** subcommand is used to list all the grants for a key and
    provides the additional **starting-token** , **page-size** , and **max-items**
    parameters for paginating the result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The AWS CLI pagination parameters, **starting-token** , **page-size** , and
    **max-items** , have the following functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **max-items** parameter states the maximum number of items that need to
    be returned by the API.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are more results from the API calls than specified by **max-items**
    , then **NextToken** is provided in the response, which needs to be passed as
    **starting-token** in the next request.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **page-size** parameter specifies the maximum number of elements to retrieve
    in a single API call. For example, if **page-size** is **10** and **max-items**
    is **100** , 10 API calls will be made in the background and then 100 items will
    be returned.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **revoke-grant** subcommand can be run by the root user of the account that
    created it, **RetiringPrincipal** of the grant, or **GranteePrincipal** if they’ve
    been given the grant for the **RetireGrant** operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS documentation recommends that, when cleaning up, we retire a grant when
    we’re done using it using the **retire-grant** subcommand. However, we should
    revoke a grant using the **revoke-grant** subcommand when we intend to actively
    deny operations that depend on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **list-retirable-grants** subcommand can be used to list all grants with
    the specified **RetiringPrincipal** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **list-retirable-grants** subcommand provides the **limit** and **maker**
    parameters to limit the retriable grants that need to be returned. Here, **limit**
    is the maximum number of items that need to be returned, while **marker** is the
    value of **NextMarker** that is returned with the previous request when more items
    than what’s specified by the limit parameter need to be returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the basics of grants in AWS KMS, refer to this blog post: [https://www.cloudericks.
    com/blog/understanding-grants-in-aws-kms](https://www.cloudericks.com/blog/understanding-grants-in-aws-kms)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Using key policies with conditional keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use **key policies** , especially with
    conditions. Resource-based policies for KMS keys are called key policies. When
    managing access to KMS resources, we can use key policies alone, or we can use
    IAM policies and grants along with key policies. Unlike other resource-based policies
    such as bucket policies, which are not mandatory, key policies are mandatory to
    manage and use keys. When a key is created, a default key policy is created by
    AWS, as we saw in the *Creating keys in* *KMS* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need the following to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: A working AWS account, **awsseccb-sandbox-1** , and a user, **awsseccbadmin1**
    , as described in the *Technical* *requirements* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An S3 bucket created in the **us-east-1** region. I will use a bucket called
    **awssecuritykmsbucket** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can demonstrate the use of key policies with condition keys as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a key with the default configuration from the console, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Key Management Service (KMS)** in the Management Console.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Customer-managed keys** from the left sidebar and click **Create key**
    .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Configure key** pane, under **Key type** , select **Symmetric** . Then,
    under **Key usage** , select **Encrypt and decrypt** . Click **Next** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide **Alias** and **Description** values, leave the other selections as-is,
    and click **Next** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, do not add any **Key administrators** . Instead, simply
    click **Next** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Define key usage permissions** pane, do not add any **Key users** either.
    Simply click **Next** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we should see the policy, as shown in the following figure.
    Review and click **Finish** :'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.15 – The key policy for review](image/B21384_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – The key policy for review
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add this KMS key as the encryption key for an S3 bucket in the same
    region as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Properties** tab of our S3 bucket.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to **Default encryption** and click **Edit** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Default encryption** pane, under **Encryption type** , select **Server-side
    encryption with AWS Key Management Service** **keys (SSE-KMS)** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **AWS KMS key** , enter the ARN of the key that we created.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Bucket Key** , select **Disable** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Save changes** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Adding an encryption key for an S3 bucket](image/B21384_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Adding an encryption key for an S3 bucket
  prefs: []
  type: TYPE_NORMAL
- en: 'Upload a file to S3 and verify that encryption and decryption are working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload a file into the S3 bucket.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on that file and click **Open** . We should be able to view the file’s
    contents.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Viewing the content of the S3 bucket](image/B21384_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Viewing the content of the S3 bucket
  prefs: []
  type: TYPE_NORMAL
- en: 'Deny key usages from the S3 service by adding a key policy statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to **Key Management Service** in the Management Console.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Customer-managed keys** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the key we need to modify.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Key** **policy** tab.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Switch to** **policy view** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Edit** , add the following key policy statement with proper commas,
    and click **Save changes** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go back to the same file we opened in *Step 3* and click **Open** to open the
    file. We won’t be able to view the file now and will get the following error.
    This has happened because S3 doesn’t have permission to use the key to perform
    decryption:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Error while trying to view the content of the S3 bucket after
    encryption](image/B21384_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Error while trying to view the content of the S3 bucket after
    encryption
  prefs: []
  type: TYPE_NORMAL
- en: If we try to run the URL directly on a browser without clicking **Open** from
    the S3 console, the file won’t be displayed with or without the key condition
    policy since we’re using SSE-KMS encryption.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a key with default permissions and tried encrypting
    and decrypting files in the S3 bucket with that key. We were able to successfully
    encrypt and decrypt. Then, we added an explicit **Deny** for the S3 service using
    the **kms:ViaService** condition key and tried decrypting the same file again.
    This time, we weren’t able to decrypt.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in *Step 1* of this recipe, the default key policy gives full permission
    to the owner account’s root user and enables the IAM policies that are required
    to access the KMS key. It also allows key administrators to administrate the KMS
    key and key users to use the KMS key. Also, we need to specify the region for
    the S3 service while using it within the **ViaService** API. I used **us-east-1**
    since my bucket is present in **us-east-1** .
  prefs: []
  type: TYPE_NORMAL
- en: 'In our key policy JSON, we used the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Effect** : Specifies whether to allow or deny permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Principal** : Specifies who gets the permissions. Allowed values include
    AWS accounts (root), IAM users, IAM roles, and supported AWS services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action** : Specifies the operations (for example, **kms:Encrypt** ) to allow
    or deny.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource** : Specifies the resource to apply the policy. We specified *****
    to denote all the resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Condition** : Used to specify any condition for the key policy to take effect.
    This is an optional element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also specify an optional **Sid** parameter. **Sid** stands for **statement
    identifier** and can contain a string value that describes our policy.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s quickly go through some important concepts about using key policies:'
  prefs: []
  type: TYPE_NORMAL
- en: To manage access to KMS resources, we can use key policies alone, or we can
    use IAM policies and grants along with key policies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow access to KMS keys, we always need to use key policies, either alone
    or along with IAM policies or grants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary resource within KMS is the KMS key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A KMS key’s ARN has the following form: **arn:aws:kms:<region>:<accountID>:key/<key
    ID>** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some KMS operations also allow the use of an alias as a resource. An alias
    ARN has the following form: **arn:aws:kms:<region>:<account** **ID>:alias/<alias
    name>** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any user, including the root user, can access the KMS key, but only if the key
    policy allows it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default key policy when a KMS key is created from the Management Console
    gives full permission to the owner’s account root user and also enables IAM policies
    that are required to access the KMS key. It will also allow key administrators
    to administrate the KMS key and key users to use the KMS key. The default key
    policy when a KMS key is created programmatically gives full permission to the
    owner’s account root user. It also enables IAM policies that are required to access
    the KMS key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we add key administrators or key users, they are added to the policy document
    statement with the required permissions. We saw the complete list of permissions
    for both key administrators and key users in the *Creating keys in* *KMS* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS has added a wildcard to some of the default permissions, such as **kms:Create***
    , **kms:Describe*** , and others, so that if AWS creates a new action that starts
    with the same prefix, the administrators or users will get those permissions automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS provides global condition keys, as well as service-specific keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The global condition keys include **aws:PrincipalTag** , **aws:PrincipalType**
    , **aws:RequestTag** , **aws:SourceIp** , **aws:SourceVpc** , **aws:SourceVpce**
    , **aws:TagKeys** , **aws:TokenIssueTime** , **aws:userid** , and **aws:username**
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS KMS condition keys include **kms:BypassPolicyLockoutSafetyCheck** ,
    **kms:CallerAccount** , **kms:EncryptionContext** , **kms:EncryptionContextKeys**
    , **kms:ExpirationModel** , **kms:GrantConstraintType** , **kms:GrantIsForAWSResource**
    , **kms:GrantOperations** , **kms:GranteePrincipal** , **kms:KeyOrigin** , **kms:ReEncryptOnSameKey**
    , **kms:RetiringPrincipal** , **kms:ValidTo** , **kms:ViaService** , **kms:WrappingAlgorithm**
    , and **kms:WrappingKeySpec** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can read more about AWS KMS key policies here: [https://www.cloudericks.
    com/blog/understanding-key-policies-in-aws-kms](https://www.cloudericks.com/blog/understanding-key-policies-in-aws-kms)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read about the differences between key policies and grants here: [https://www.cloudericks.com/blog/understanding-aws-kms-key-policies-vs-grants](https://www.cloudericks.com/blog/understanding-aws-kms-key-policies-vs-grants)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read more about AWS KMS condition keys here: [https://www.cloudericks.com/blog/understanding-aws-kms-condition-keys](https://www.cloudericks.com/blog/understanding-aws-kms-condition-keys)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read more about policies and permissions within AWS here: [https://www.cloudericks.com/blog/demystifying-aws-policies-and-permissions](https://www.cloudericks.com/blog/demystifying-aws-policies-and-permissions)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing customer-managed keys across accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use a KMS key from one account in another
    account.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need the following to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Two working AWS accounts. I will be using the accounts we created in *Chapter
    1* , with the account ID of the first account being **135301570106** and the account
    ID of the second account being **380701114427** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user from account 2 with **AdministratorAccess** permission. This could be
    an IAM user or an IAM Identity Center user. The CLI profile should be configured
    for this user. I will be calling the CLI profile **Adminuserprofile** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another user without administrator permissions in account 2. The CLI profile
    should be configured for this user. I will be calling this user and its CLI profile
    **Testuserprofile** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we will create a new KMS key in the first account. After that, we will
    provide permission to use it from the second account. Finally, we will test the
    first account from the second account using that KMS key.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a key and giving permission to the other account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will create a key in account 1 with key usage permission
    to account 2. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the AWS Management Console and go to **Key** **Management Service**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Customer managed keys** from the left sidebar and click on **Create
    key** at the top right of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Configure key** pane, for **Key type** , select **Symmetric** , and
    for **Key usage** , select **Encrypt and decrypt** . Then, click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Add labels** pane, provide **Alias** and **Description** values. Click
    **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Define key administrative permissions** screen, we can add any **Key
    administrators** if we want to and select the checkbox for **Allow key administrators
    to delete this key** . Click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the **Define key usage permissions** screen, scroll down to the **Other
    AWS accounts** section and click **Add another AWS account** , as shown in the
    following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.19 – The Other AWS accounts section](image/B21384_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – The Other AWS accounts section
  prefs: []
  type: TYPE_NORMAL
- en: Enter the account ID of the second AWS account and click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Adding other AWS accounts](image/B21384_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – Adding other AWS accounts
  prefs: []
  type: TYPE_NORMAL
- en: On the **Review** screen, review the **Key policy** details and click **Finish**
    . The statement that’s been added to the key policy is available within the code
    files as **key-policy-sharing-keys.json** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we get a success message that the key has been created, click **View key**
    to see the details of the key. The ARN for my newly created key is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this section, we created a key in account 1 and gave permission to account
    2. In the next section, we will use this key in account 2.
  prefs: []
  type: TYPE_NORMAL
- en: Using the key as an administrator user from account 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let’s try using the key as a user with administrator permission from account
    2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Encrypt the data with the profile of an administrator user from account 2 from
    the CLI using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Response after running the encrypt command for the admin user](image/B21384_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – Response after running the encrypt command for the admin user
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will use the key as a non-admin user from account 2.
  prefs: []
  type: TYPE_NORMAL
- en: Using the key as a non-admin user from account 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before proceeding, we can verify that the non-admin user doesn’t have access
    to encrypt the data in account 1 by running the command shown in *Step 1* of the
    previous section while using the non-admin user profile. Now, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the KMS key as a non-admin user, the root or the admin user of account
    2 has to delegate the permission to the non-admin user. To do so, they must follow
    these steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **IAM** dashboard of account 2.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Policies** on the left pane.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create policy** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **JSON** tab.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following policy. Make sure you update the **Sid** value and the
    **Resource** parameters to reflect your resource details:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click **Next** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Review and create** pane, for **Policy details** , provide **Name**
    and **Description** detail for our policy.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Create policy** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’re using an IAM user, assign this policy directly to that IAM user or
    a group that the user is part of. If you have an IAM Identity Center user, you
    can assign this policy using a custom permission set, as we saw in the *Creating
    customer-managed policies in IAM Identity Center* recipe of *Chapter 2* .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Encrypt the data with the profile of a non-administrator user from account
    2 from the CLI using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should see the following response:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Response after running the encrypt command for the non-admin
    user](image/B21384_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – Response after running the encrypt command for the non-admin user
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we created a new KMS key. We can also edit an existing KMS key
    and add another account’s details.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a KMS key in account 1 with permissions for account
    2. After that, we successfully encrypted data on the other account with an administrator
    user’s profile from CLI. To encrypt using a non-administrator user, the administrator
    user of account 2 needs to delegate permissions to the user or role that needs
    access. We did this through an IAM policy.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the policy document’s structure, refer to the *Using key
    policies with conditional* *keys* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we tried encrypting data from the AWS CLI. Even though delegating
    key permissions across accounts is supported for most integrated services, such
    as S3 and EC2, their support for selecting the key automatically from the console
    may not be supported. Check out each service’s documentation for more details.
    If there is a limitation from the Management Console, then we will need to do
    this through the API by specifying the ARN of the key.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve explored many features of AWS KMS within this chapter. There are many
    applications and integrations for KMS within the AWS cloud, such as S3 encryption,
    EBS encryption, and more. Including all of those applications and integrations
    would require a book dedicated to KMS. You may explore more applications and integrations
    of KMS within the AWS cloud at [https://www.cloudericks.com/blog/applications-of-aws-kms-within-aws-cloud](https://www.cloudericks.com/blog/applications-of-aws-kms-within-aws-cloud)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Creating, initializing, and activating a CloudHSM cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create an AWS CloudHSM cluster. CloudHSM is a dedicated
    **hardware security module** ( **HSM** ) on the AWS cloud that we can use to generate
    and use encryption keys. AWS KMS, on the other hand, uses shared HSM. CloudHSM
    is ideal for scenarios demanding the highest level of isolation and control.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need the following to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: A working AWS account, **awsseccb-sandbox-1** , and a user, **awsseccbadmin1**
    , as described in the *Technical* *requirements* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowledge of VPCs and EC2. If you are new to EC2 or want to refresh the concepts,
    you may first practice the recipes in [*Chapter 5*](B21384_05.xhtml#_idTextAnchor169)
    , and then come back to this recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: AWS CloudHSM typically incurs higher costs compared to AWS KMS, and it does
    not offer a free tier option. For those utilizing CloudHSM for educational or
    learning purposes, it is crucial to promptly delete the resources you’ve created
    once you’ve completed the relevant recipes. This proactive step helps prevent
    any unexpected charges.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we need to create a cluster, initialize it, and then activate it from
    an EC2 instance within the same VPC as the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CloudHSM cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will create a CloudHSM cluster using the default VPCs,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **CloudHSM** service in the Management Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Create cluster** . If we can’t see the **Create cluster** option,
    we can click on **Clusters** from the left sidebar and then click on **Create
    cluster** in the right pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **VPC** , select the VPC that we want to use or select the default VPC.
    This cannot be changed later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You may also create a custom VPC with private and public subnets and use them
    instead of the default VPCs that we’re using in this chapter, especially if you’re
    configuring CloudHSM for production. We will be covering VPCs in depth in [*Chapter
    5*](B21384_05.xhtml#_idTextAnchor169) .
  prefs: []
  type: TYPE_NORMAL
- en: Select subnets in at least two Availability Zones based on AWS’s recommendations.
    I have chosen three for this recipe in **us-east-1a** , **us-east-1b** , and **us-east-1c**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down and, under **Cluster source** , select the **Create a new cluster**
    option. Click **Next** to proceed to the **Back-up retention** step. We also have
    a **Restore cluster from existing** **backup** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Back-up retention** step, under the **Backup retention** screen, for
    **Backup retention period (in days)** , based on your requirements, enter a period
    between 7 to 379 days. I have entered **7** . Click **Next** to proceed to the
    **Add** **tags** step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Add tags** step, optionally add tags to categorize our clusters. Then,
    click **Next** to proceed to the **Review** step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the details on the **Review** screen, including **VPC** , **Availability
    Zone(s)** , **Days to expire under Back-up retention policy** , and **Tags** .
    We’ll also see a warning stating that we cannot change VPC or subnets after cluster
    creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the review, click **Create cluster** . We should immediately see a message
    stating that the cluster is being created and that its state is **Creation in
    progress** . It may take a few minutes for cluster creation to complete. If the
    cluster creation operation is successful, we should see a screen with a success
    message and the state will be **Uninitialised** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we created a CloudHSM cluster. Next, we need to initialize
    and activate the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the cluster and creating our first HSM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can initialize our cluster and create our first HSM by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select our cluster and click on **Initialize** from the **Actions** dropdown.
    Assuming we haven’t created any HSM yet, this will take us to the creation wizard
    for our first HSM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create HSM in the cluster** step, select one of the Availability Zones
    we selected while creating the cluster and click **Create** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'HSM creation can take some time. Once this process is successful, we should
    be taken to the **Download certificate signing request** step and see a success
    message, similar to the one shown in the following figure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.23 – Download certificate signing request](image/B21384_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 – Download certificate signing request
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Cluster CSR** button to download the **certificate signing request**
    ( **CSR** ). Optionally, as shown in *Figure 3* *.23* , we can verify the identity
    and authenticity of the cluster’s HSM by following the *There’s more...* section
    and the *See also* section of this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Next** to proceed to the **Upload** **certificates** step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Generate a private key by running the **openssl** command on your local machine,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When prompted, enter and re-enter a passphrase in 4 to 1,023 characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As this is for testing and development purposes, we can create a self-signed
    certificate using our private key by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Answer the prompt questions while providing values similar to the ones shown
    in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Generating a self-signed certificate](image/B21384_03_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.24 – Generating a self-signed certificate
  prefs: []
  type: TYPE_NORMAL
- en: 'Sign the cluster CSR using the OpenSSL command syntax that’s available from
    the AWS documentation. Remember to mention the exact name of the **csr** file
    you downloaded from the AWS Management Console and run it from the same folder
    where it is present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should create a file named **cluster-2i67czpb6yy_ClusterCsr.crt** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Go back to the **Upload certificates** screen from *Step 5* of this section
    and upload the signed cluster certificate and signing certificate ( issuing certificate):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Upload certificates](image/B21384_03_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.25 – Upload certificates
  prefs: []
  type: TYPE_NORMAL
- en: Click **Upload and initialise** . We should immediately see a message that cluster
    initialization is now in progress. Once the initialization is done, we should
    get a message stating that we must set the cluster password before we can use
    the cluster. We need to do this from an EC2 instance that’s been launched in the
    same VPC as our CloudHSM cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Clusters** on the left sidebar and verify that our cluster’s **State**
    is set to **Initialised** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need to go inside our cluster and copy the **ENI IP address** value
    of our HSM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we initialized the cluster and created our first HSM. In the
    next section, we will launch an EC2 client instance into the same VPC as our cluster
    and activate the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will launch an EC2 client instance for our HSM from the
    AWS Management Console and activate the cluster. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to launch an EC2 client instance and set up the following options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Amazon Linux 2023** under **Operating system** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **t2.micro** under **Instance type** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **Create new key pair** link to create a new key pair and save the private
    key securely. I have named it **ec2forhsm.pem** .
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Network settings** , select the same VPC as our cluster, which is the
    default VPC in my case. The **Auto-assign public IP** option should be set to
    **Enable** . In the **Firewall (security groups)** subsection, select **Select
    an existing security group** , and for **Common security groups** , choose the
    default security group and the security group of our HSM.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the security group to add an inbound rule for SSH (port range 22) for the
    IP of the system we are connecting from by selecting the **My** **IP** option.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the self-signed certificate, **customerCA.crt** , into the EC2 machine.
    On Mac or Linux, we can use the **scp** command to do this, as follows. Remember
    to use your EC2 **Public IPv4 DNS** value instead of mine, which is **ec2-user@ec2-54-172-128-95.compute-1.amazonaws.com**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SSH into the EC2 instance. The exact command or steps may differ between operating
    systems. On Mac or Linux, we can use the following command. If you face any issues
    with the permission key permissions, you can run the **chmod 400 ec2forhsm.pem**
    command to resolve this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the operating system by running the **sudo yum** **update** command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command to get the latest CloudHSM client RPM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to install the CloudHSM client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the **ENI IP address** value of our HSM to the configuration. We took note
    of it in *Step 12* of the previous section, *Initializing the cluster and creating
    our first HSM* . Remember to replace my IP with your IP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the self-signed certificate, **customerCA.crt** , into **/opt/cloudhsm/etc/**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the CloudHSM CLI in interactive mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the **cluster activate** command to set the initial admin password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.26 – Activate CloudHSM cluster](image/B21384_03_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.26 – Activate CloudHSM cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **user list** command to verify that the user list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.27 – List Users in cluster](image/B21384_03_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.27 – List Users in cluster
  prefs: []
  type: TYPE_NORMAL
- en: We can quit the utility using the **quit** command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to our cluster within the console and verify that we can’t see a display
    message stating that the cluster can’t be used until the password is updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we activated our HSML cluster. HSM clusters don’t fall under
    the free tier. Therefore, if you created this cluster for development or testing
    purposes, remember to delete the HSM and the cluster to avoid incurring unexpected
    charges.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created a CloudHSM cluster, initialized it, and then created
    our first HSM within it. I used the default VPC for convenience. For practical
    use cases, you should install HSM into a private subnet within a custom VPC. We
    will look at VPCs in detail in [*Chapter 5*](B21384_05.xhtml#_idTextAnchor169)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Before initializing the cluster, we need to download a CSR and sign it. We
    used a self-signed certificate while following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a private key using OpenSSL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the private key to create a self-signed signing certificate ( issuing certificate).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the self-signed signing certificate (issuing certificate) to sign the CSR
    we downloaded from the AWS Management Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, upload both our signed CSR certificate and the self-signed issuing
    certificate to AWS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For practical use cases, a certificate authority such as Verisign should sign
    it to create a signed certificate. For development and testing purposes, we can
    use a self-signed certificate to sign it using OpenSSL, as we saw in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: First, we logged in to the system as a user with the PRECO role, which is a
    temporary user role that exists on the first HSM in our cluster. After we changed
    the default password for this user, we observed that its type changed from PRECO
    to CO. A user of the AU type was also present.
  prefs: []
  type: TYPE_NORMAL
- en: 'With CloudHSM, we have four main user types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Precrypto** **Officer** ( **PRECO** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crypto** **Officer** ( **CO** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Crypto** **User** ( **CU** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Appliance** **User** ( **AU** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PRECO is a user role that is created by AWS that we can use until we update
    the password. Once updated, the user’s type is changed to CO. We can create more
    users with the CO role. The first CO user is referred to as the primary PCO. A
    CO is responsible for managing users. A CU is responsible for managing keys, including
    creating, deleting, sharing, importing, and exporting them. A CU is also responsible
    for cryptographic operations such as encryption, decryption, signing, verifying,
    and more. Finally, an AU is a limited permission user that is generally used by
    AWS for cloning and synchronization activities.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can verify the HSM’s identity using the certificates that we can download
    from AWS. At the time of writing, six certificates can be downloaded from CloudHSM
    and verified: Cluster CSR, HSM certificate, AWS hardware certificate, Manufacturer
    hardware certificate, AWS root certificate, and Manufacturer root certificate.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can read more about CloudHSM here: [https://www.cloudericks.com/blog/getting-started-with-cloud-hsm](https://www.cloudericks.com/blog/getting-started-with-cloud-hsm)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can learn more about the similarities and differences between CloudHSM
    and KMS here: [https://www.cloudericks.com/blog/aws-cloudhsm-vs-aws-kms](https://www.cloudericks.com/blog/aws-cloudhsm-vs-aws-kms)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
