<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Efficient Discovery"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Efficient Discovery</h1></div></div></div><p>Content discovery and information gathering are typically the first steps when attacking an application. The goal is to figure out as much as possible about the application in the quickest manner possible. Time is a luxury we don't have and we must make the most of our limited resources.</p><p>Efficiency can also help us to remain a bit quieter when attacking applications. Smart wordlists will reduce the number of requests we make to the server and return results faster. This isn't a silver bullet, but it's a good place to start.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The different types of penetration testing engagements</li><li class="listitem" style="list-style-type: disc">Target mapping with various network and web scanners</li><li class="listitem" style="list-style-type: disc">Efficient brute-forcing techniques</li><li class="listitem" style="list-style-type: disc">Polyglot payloads</li></ul></div><div class="section" title="Types of assessments"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Types of assessments</h1></div></div></div><p>Depending <a id="id46" class="indexterm"/>on the agreement with the client prior to the engagement, you may have some of the information required, a lot of information, or no information whatsoever. <span class="strong"><strong>White-box</strong></span> testing<a id="id47" class="indexterm"/> allows for a thorough examination of the application. In this case, the attackers have essentially the same access as the developer. They not only have authenticated access to the application, but also its source code, any design documents, and anything else they'll need.</p><p>White-box testing is typically conducted by internal teams and it is fairly time-consuming. A tester is provided with any information they require to fully assess the application or infrastructure. The benefit of providing testers with this level of knowledge is that they will be able to look at every bit of an application and check for vulnerabilities. This is a luxury that external attackers do not have, but it does make efficient use of limited time and resources during an engagement.</p><p>
<span class="strong"><strong>Gray-box</strong></span> scenarios<a id="id48" class="indexterm"/> are more <a id="id49" class="indexterm"/>common, as they provide just enough information to let the testers get right into probing the application. A client may provide credentials and a bit of information on the design of the infrastructure or application, but not much more. The idea here is that the client assumes that a malicious actor already has a certain level of access or knowledge, and the client needs to understand how much more damage can be done.</p><p>Finally, <span class="strong"><strong>black-box</strong></span> testing<a id="id50" class="indexterm"/> will simulate an attack from the perspective of an outsider without any knowledge of the application or infrastructure. Companies that expose applications to the internet are subjected to constant attack by external threats. While it is important to remember that not all malicious actors are external, as disgruntled employees can cause just as much damage, malicious black-box type attacks are fairly common and can be very damaging.</p><p>The following is a breakdown of the <a id="id51" class="indexterm"/>three common types<a id="id52" class="indexterm"/> of application penetration tests:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>White-box</p>
</th><th style="text-align: left" valign="bottom">
<p>Gray-box</p>
</th><th style="text-align: left" valign="bottom">
<p>Black-box</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Attacker has access to all information required.</p>
</td><td style="text-align: left" valign="top">
<p>Some <a id="id53" class="indexterm"/>information is available.</p>
</td><td style="text-align: left" valign="top">
<p>Zero knowledge.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Testing with the highest privilege, that is, with developer knowledge.</p>
</td><td style="text-align: left" valign="top">
<p>Testing from the perspective of a threat that already has a certain level of access or knowledge.</p>
</td><td style="text-align: left" valign="top">
<p>Testing <a id="id54" class="indexterm"/>from the perspective of an external threat.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Typical information available includes the following:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User accounts</li><li class="listitem" style="list-style-type: disc">Source code</li><li class="listitem" style="list-style-type: disc">Infrastructure design documents</li><li class="listitem" style="list-style-type: disc">Directory listing</li></ul></div>
</td><td style="text-align: left" valign="top">
<p>Provides the attacker with some information:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User accounts</li><li class="listitem" style="list-style-type: disc">High-level documentation<p>The attacker will usually not have access to the source code, or other sensitive information</p></li></ul></div>
</td><td style="text-align: left" valign="top">
<p>No information is provided up-front and the attacker must gather<a id="id55" class="indexterm"/> everything they need through <span class="strong"><strong>open-source intelligence</strong></span> (<span class="strong"><strong>OSINT</strong></span>) or vulnerabilities that lead to information leakage.</p>
</td></tr></tbody></table></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note004"/>Note</h3><p>For the remainder of this book, we will approach our targets from a more gray-box perspective, simulating the typical engagement.</p></div></div></div></div>
<div class="section" title="Target mapping"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Target mapping</h1></div></div></div><p>The<a id="id56" class="indexterm"/> traditional <code class="literal">nmap</code> of the entire port range, with service discovery, is always a good place to start when gathering information on a target. <span class="strong"><strong>Nmap</strong></span> is <a id="id57" class="indexterm"/>the network scanning tool of choice and has been for many years. It is still very powerful and very relevant. It is available on most platforms, including Kali, BlackArch, and even Windows.</p><p>
<span class="strong"><strong>Metasploit Framework</strong></span> (<span class="strong"><strong>MSF</strong></span>) is a penetration<a id="id58" class="indexterm"/> testing framework commonly used by security professionals. Besides being a fantastic collection of easy-to-deliver exploits, it can also help to organize engagements. For target mapping specifically, you can leverage the workspace feature and neatly store your Nmap scan results in a database.</p><p>If the Kali Linux instance is fresh or Metasploit was recently installed, the database may need a kick to get it going.</p><p>In the Kali console prompt, start the <span class="strong"><strong>PostgreSQL</strong></span> service using the <code class="literal">service</code> command. If successful, there should be no message returned:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~# service postgresql start</strong></span>
<span class="strong"><strong>root@kali:~#</strong></span>
</pre></div><p>Metasploit can then be started using the <code class="literal">msfconsole</code> command, which will drop us into a sub-prompt, prefixed with <code class="literal">msf</code> instead of the traditional bash prompt:</p><div class="informalexample"><pre class="programlisting">root@kali:~#<span class="strong"><strong> msfconsole</strong></span>
[...]
msf &gt;<span class="strong"><strong> db_status</strong></span>
[*] postgresql selected, no connection
msf &gt;</pre></div><p>The preceding<a id="id59" class="indexterm"/> series of commands will start the PostgreSQL database service, which Metasploit uses for storage. The Metasploit console is launched and we can check the database status using MSF's <code class="literal">db_status</code> command.</p><p>We can use the <code class="literal">exit</code> command to return to the bash terminal:</p><div class="informalexample"><pre class="programlisting">msf &gt;<span class="strong"><strong> exit</strong></span>
root@kali:~#</pre></div><p>We can now use the Metasploit <code class="literal">msfdb</code> command to help us initialize (<code class="literal">init</code>) the database:</p><div class="informalexample"><pre class="programlisting">root@kali:~#<span class="strong"><strong> msfdb init</strong></span>
Creating database user 'msf'
Enter password for new role:
Enter it again:
Creating databases 'msf' and 'msf_test'
Creating configuration file in <span class="strong"><strong>/usr/share/metasploit-framework/config/database.yml</strong></span>
Creating initial database schema
root@kali:~#</pre></div><p>The <code class="literal">msfdb</code> command creates all of the necessary configuration files for Metasploit to be able to connect to the database. Once again, we can start the Metasploit console using the <code class="literal">msfconsole</code> command in the Linux prompt:</p><div class="informalexample"><pre class="programlisting">root@kali:~#<span class="strong"><strong> msfconsole</strong></span>
[...]
msf &gt; </pre></div><p>The YML database configuration file, created with the <code class="literal">msfdb init</code> command, can be passed to the <code class="literal">db_connect</code> Metasploit console command as with the <code class="literal">-y</code> switch:</p><div class="informalexample"><pre class="programlisting">msf &gt;<span class="strong"><strong> db_connect -y /usr/share/metasploit-framework/config/database.yml</strong></span>
[*] Rebuilding the module cache in the background...
msf &gt; db_status
[*] postgresql connected to msf
msf &gt; </pre></div><p>We can now<a id="id60" class="indexterm"/> create a workspace for the target application, which will help us to organize results from various MSF modules, scans, or exploits:</p><div class="informalexample"><pre class="programlisting">msf &gt; workspace -a<span class="strong"><strong> target1</strong></span>
[*] Added workspace: target1
msf &gt; workspace
  default
<span class="strong"><strong>* target1</strong></span>
</pre></div><p>The <code class="literal">workspace</code> command without any parameters will list the available workspaces, marking the active one with an asterisk. At this point, we can start an Nmap scan from within MSF. The <code class="literal">db_nmap</code> MSF command is a wrapper for the Nmap scanning tool. The difference is that the results of the scan are parsed and stored inside the Metasploit database for easy browsing.</p><p>MSF's <code class="literal">db_nmap</code> takes the same switches as the normal <code class="literal">nmap</code>. In the following example, we are scanning for common ports and interrogating running services.</p><p>The target for this scan is an internal host, <code class="literal">10.0.5.198</code>. We are instructing Nmap to perform a service scan (<code class="literal">-sV</code>) without pinging hosts (<code class="literal">-Pn</code>), and using verbose output (<code class="literal">-v</code>):</p><div class="informalexample"><pre class="programlisting">msf &gt;<span class="strong"><strong> db_nmap -sV -Pn -v 10.0.5.198</strong></span>
[...]
[*] Nmap: Scanning 10.0.5.198 [1000 ports]
[*] Nmap: Discovered open port 3389/tcp on 10.0.5.198
[*] Nmap: Discovered open port 5357/tcp on 10.0.5.198
[*] Nmap: Completed SYN Stealth Scan at 19:50, 12.05s elapsed (1000 total ports)
[*] Nmap: Initiating Service scan at 19:50
[...]</pre></div><p>Once the scan completes, the results can be queried and filtered using the <code class="literal">services</code> command. For example, we can look for all HTTP services discovered by using the <code class="literal">-s</code> switch:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>msf &gt; services -s http</strong></span>
<span class="strong"><strong>Services</strong></span>
<span class="strong"><strong>========</strong></span>
<span class="strong"><strong>host        port  proto  name  state  info</strong></span>
<span class="strong"><strong>----        ----  -----  ----  -----  ----</strong></span>
<span class="strong"><strong>10.0.5.198  5357  tcp    http  open   Microsoft HTTPAPI httpd 2.0 SSDP/UPnP</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Take note of the scope provided by the client. Some will specifically constrain application testing to one port, or sometimes even only one subdomain or URL. The scoping call is where the client should be urged not to limit the attack surface available to the tester.</p></div></div><div class="section" title="Masscan"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Masscan</h2></div></div></div><p>Nmap is fully featured, with a ton<a id="id61" class="indexterm"/> of options and capabilities, but there is one problem: speed. For<a id="id62" class="indexterm"/> large network segments, Nmap can be very slow and sometimes can fail altogether. It's not unusual for clients to request a penetration test on a huge IP space with little time allotted for the mapping and scanning phase.</p><p>The claim to fame of <span class="strong"><strong>masscan</strong></span> is that it can scan the internet IP space in about six minutes. This is an impressive feat and it is certainly one of the fastest port scanners out there.</p><p>During an engagement, we may wish to target web applications first and <code class="literal">masscan</code> can quickly return all open web ports with just a couple of switches.</p><p>The familiar <code class="literal">-p</code> switch can be used to specify a series, or range, of ports to look for. The <code class="literal">--banners</code> switch will attempt to retrieve some information about any open ports that are discovered. For larger IP spaces, where time is of the essence, we can use the <code class="literal">--rate</code> switch to specify a large packet per second number, such as a million or more:</p><div class="mediaobject"><img src="graphics/B09238_02_01.jpg" alt="Masscan"/><div class="caption"><p>Figure 2.1: A masscan of the 10.0.0.0/8 network</p></div></div><p>We can see that the preceding <a id="id63" class="indexterm"/>scan was cancelled early with the <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> interrupt, and masscan saved its progress in a <code class="literal">paused.conf</code> file, allowing us to resume the scan at a later time. To pick up <a id="id64" class="indexterm"/>where we left off, we can use the <code class="literal">--resume</code> switch, passing the <code class="literal">paused.conf</code> file as the parameter:</p><div class="mediaobject"><img src="graphics/B09238_02_02.jpg" alt="Masscan"/><div class="caption"><p>Figure 2.2: Resuming a masscan session</p></div></div><p>Masscan's results can then be fed into either Nmap for further processing, or a web scanner for more in-depth vulnerability discovery.</p></div><div class="section" title="WhatWeb"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>WhatWeb</h2></div></div></div><p>Once we've identified <a id="id65" class="indexterm"/>one or more web applications in the target environment with <a id="id66" class="indexterm"/>masscan or Nmap, we can start digging a bit deeper. <span class="strong"><strong>WhatWeb</strong></span> is a simple, yet effective, tool that can look at a particular web application and identity what technologies have been used to develop and run it. It has more than 1,000 plugins, which can passively identify everything from what <span class="strong"><strong>content management system</strong></span> (<span class="strong"><strong>CMS</strong></span>) is running on the application, to what version of <span class="strong"><strong>Apache</strong></span> or <span class="strong"><strong>NGINX</strong></span> is powering the whole thing.</p><p>The following diagram shows a more aggressive (<code class="literal">-a 3</code>) scan of <code class="literal">bittherapy.net</code> with WhatWeb. The <code class="literal">sed</code> command shown will format the output to something a bit easier to read:</p><div class="mediaobject"><img src="graphics/B09238_02_03.jpg" alt="WhatWeb"/><div class="caption"><p>Figure 2.3: Running WhatWeb and filtering the results</p></div></div><p>A level-3 aggression scan will perform several more requests to help to improve the accuracy of results.</p><p>WhatWeb is<a id="id67" class="indexterm"/> available on Kali Linux and most other penetration testing distributions. It can also be downloaded from <a class="ulink" href="https://github.com/urbanadventurer/WhatWeb">https://github.com/urbanadventurer/WhatWeb</a>.</p></div><div class="section" title="Nikto"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Nikto</h2></div></div></div><p>
<span class="strong"><strong>Nikto</strong></span> provides <a id="id68" class="indexterm"/>value during the<a id="id69" class="indexterm"/> initial phases of the engagement. It is fairly non-intrusive and with its built-in plugins, it can provide quick insight into the application. It also offers some more aggressive scanning features that may yield success on older applications or infrastructure.</p><p>If the engagement does not require the attackers to be particularly stealthy, it doesn't hurt to run through the noisier <a id="id70" class="indexterm"/>Nikto options as well. Nikto can guess subdomains, report on unusual headers, and check the <code class="literal">robots.txt</code> file for interesting information:</p><div class="mediaobject"><img src="graphics/B09238_02_04.jpg" alt="Nikto"/><div class="caption"><p>Figure 2.4: A standard scan of the example.com domain</p></div></div><p>Nikto outputs information on the HTTPS certificate, the server banner, any security-related HTTP headers that may be missing, and any other information that may be of interest. It also noticed that the server banner had changed between requests, indicating that a WAF may be configured to protect the application.</p><p>Nikto can be <a id="id71" class="indexterm"/>downloaded from <a class="ulink" href="https://github.com/sullo/nikto">https://github.com/sullo/nikto</a>. It is also available in most penetration testing-focused Linux distributions, such as Kali or BlackArch.</p></div><div class="section" title="CMS scanners"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>CMS scanners</h2></div></div></div><p>When the target<a id="id72" class="indexterm"/> is using a <a id="id73" class="indexterm"/>CMS, such<a id="id74" class="indexterm"/> as <span class="strong"><strong>Joomla</strong></span>, <span class="strong"><strong>Drupal</strong></span>, or <span class="strong"><strong>WordPress</strong></span>, running an automated<a id="id75" class="indexterm"/> vulnerability<a id="id76" class="indexterm"/> testing tool should be your next step.</p><p>WordPress is a popular CMS because it provides plugins for almost any type of site, making it very customizable and widely-adopted, but also complex, with a large attack surface. There are tons of vulnerable plugins, and users typically don't upgrade them frequently.</p><p>During a test, <a id="id77" class="indexterm"/>you may find a remotely exploitable vulnerability in one of the plugins <a id="id78" class="indexterm"/>that provides a shell, but more often than not, WordPress is a treasure trove of information. Usernames can be enumerated, passwords are often weak and easily brute-forced, or directory indexing may be enabled. The WordPress content folder sometimes also contains sensitive documents uploaded "temporarily" by the administrator. In later chapters, we will see how an improperly configured WordPress instance can be leveraged to attack the application server and move laterally through the network.</p><p>WordPress is not alone in this space. Joomla and Drupal are also very popular and sport many of the same vulnerabilities and configuration issues that are seen in WordPress installations.</p><p>There are a few scanners available for free that aim to test for low-hanging fruit in these CMSs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>WPScan</strong></span> (<a class="ulink" href="https://wpscan.org/">https://wpscan.org/</a>): A powerful tool <a id="id79" class="indexterm"/>aimed at testing<a id="id80" class="indexterm"/> WordPress installations</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>JoomScan</strong></span> (<a class="ulink" href="https://github.com/rezasp/joomscan">https://github.com/rezasp/joomscan</a>): As the name implies, a <a id="id81" class="indexterm"/>CMS scanner<a id="id82" class="indexterm"/> specializing in Joomla testing</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>droopescan</strong></span> (<a class="ulink" href="https://github.com/droope/droopescan">https://github.com/droope/droopescan</a>): A Drupal-specific <a id="id83" class="indexterm"/>scanner with<a id="id84" class="indexterm"/> some support for Joomla</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>CMSmap</strong></span> (<a class="ulink" href="https://github.com/Dionach/CMSmap">https://github.com/Dionach/CMSmap</a>): A more generic scanner and brute-forcer <a id="id85" class="indexterm"/>supporting WordPress, Joomla, and <a id="id86" class="indexterm"/>Drupal</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Before proceeding with a WordPress scan, make sure that it is hosted inside the engagement scope. Some CMS implementations will host the core site locally, but the plugins or content directories <a id="id87" class="indexterm"/>are on a separate <span class="strong"><strong>content delivery network</strong></span> (<span class="strong"><strong>CDN</strong></span>). These CDN hosts may be subject to a penetration testing notification form before they can be included in the test.</p></div></div><p>We will cover CMS assessment tools, such as WPScan, in more detail in later chapters.</p></div></div>
<div class="section" title="Efficient brute-forcing"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Efficient brute-forcing</h1></div></div></div><p>A brute-force attack typically<a id="id88" class="indexterm"/> involves a barrage of requests, or guesses, to gain access or reveal information that may be otherwise hidden. We may brute-force a login form on an administrative panel in order to look for commonly used passwords or usernames. We may also brute-force a web application's root directory looking for common misconfiguration and misplaced sensitive files.</p><p>Many successful engagements were made so by weak credentials or application misconfiguration. Brute-forcing can help to reveal information that may have been obscured, or can grant access to a database because the developer forgot to change the default credentials.</p><p>There are obvious challenges to brute-forcing. Primarily, it is time-consuming and can be very noisy. Brute-forcing a web service, for example, with the infamous <code class="literal">rockyou.txt</code> wordlist will no doubt wake up your friendly neighborhood <span class="strong"><strong>security operations center</strong></span> (<span class="strong"><strong>SOC</strong></span>) analyst <a id="id89" class="indexterm"/>and may put an end to your activities early. The <code class="literal">rockyou.txt</code> list has over 14 million entries and could eventually result in a successful credential guess, but it may be better to limit the flood of traffic to the target with a smaller, more efficient list.</p><p>One of the better collections of common keywords, credentials, directories, payloads, and even webshells is<a id="id90" class="indexterm"/> the <span class="strong"><strong>SecLists</strong></span> repository: <a class="ulink" href="https://github.com/danielmiessler/SecLists">https://github.com/danielmiessler/SecLists</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>An alternative, or supplement, to SecLists is <span class="strong"><strong>FuzzDB</strong></span>. It is a similar collection of files containing various payloads that can help with brute-forcing, and it can also be downloaded from the<a id="id91" class="indexterm"/> GitHub repository at <a class="ulink" href="https://github.com/fuzzdb-project/fuzzdb">https://github.com/fuzzdb-project/fuzzdb</a>.</p></div></div><p>Grabbing the latest copy of SecLists is easy using <code class="literal">git</code>, a popular version control system tool. We can pull down the repository using the <code class="literal">git clone</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools# git clone https://github.com/danielmiessler/SecLists</strong></span>
</pre></div><p>SecLists<a id="id92" class="indexterm"/> contains an ever-evolving database of compiled wordlists that can be used in discovery scans, brute-force attacks, and much more:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>SecList Wordlist</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Discovery</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Web content, DNS, and common Nmap ports</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Fuzzing</code>
</p>
</td><td style="text-align: left" valign="top">
<p>FuzzDB, Brutelogic, Polyglot payloads, and more</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">IOCs</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Malware-related indicators of compromise</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Miscellaneous</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Various wordlists that may have obscure uses</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Passwords</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Large numbers of wordlists for common passwords, split into top-N files</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Pattern-Matching</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Wordlists for use when "grepping" for interesting information</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Payloads</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Webshells for common languages, Windows Netcat, and an EICAR test file</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Usernames</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Lists of common names and login IDs</p>
</td></tr></tbody></table></div><p>The security community is a frequent contributor to SecLists, and it is good practice to pull the latest changes from GitHub before starting an engagement.</p><p>Hopefully, target mapping has already provided a few key pieces of information that can help you to brute-force more efficiently. While Nikto and Nmap may not always find a quick and easy remote code execution vulnerability, they do return data that can be useful when deciding what wordlist to use for discovery.</p><p>Useful information can include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The webserver software: Apache, NGINX, or IIS</li><li class="listitem" style="list-style-type: disc">Server-side development language: ASP.NET, PHP, or Java</li><li class="listitem" style="list-style-type: disc">Underlying operating system: Linux, Windows, or embedded</li><li class="listitem" style="list-style-type: disc"><code class="literal">robots.txt</code></li><li class="listitem" style="list-style-type: disc">Interesting response headers</li><li class="listitem" style="list-style-type: disc">WAF detection: <span class="emphasis"><em>F5</em></span> or Akamai</li></ul></div><p>You can make assumptions about the application based on the very simple information shown in the preceding list. For example, an IIS web server is more likely to have an application developed in ASP.NET as opposed to PHP. While PHP is still available on Windows (via XAMPP), it is not as commonly encountered in production environments. In contrast, while there are Active Server Pages (ASP) processors <a id="id93" class="indexterm"/>on Linux systems, PHP or Node.js are much more common these days. While brute-forcing for files, you can take this into account when attaching the extension to the payload: <code class="literal">.asp</code> and <code class="literal">.aspx</code> for Windows targets, and <code class="literal">.php</code> for Linux targets is a good start.</p><p>The <code class="literal">robots.txt</code> file is generally interesting, as it can provide "hidden" directories or files, and can be a good starting point when brute-forcing for directories or files. The <code class="literal">robots.txt</code> file essentially provides instructions for legitimate crawler bots on what they're allowed to index and what they should ignore. This is a convenient way to implement this protocol, but it has the implication that this file must be readable by anonymous users, including yourself.</p><p>A sample <code class="literal">robots.txt</code> file will look something like this:</p><div class="informalexample"><pre class="programlisting">User-agent: *
Disallow: /cgi-bin/
Disallow: /test/
Disallow: /~admin/</pre></div><p>Google's crawlers will ignore the subdirectories, but you cannot. This is valuable information for the upcoming scans.</p><div class="section" title="Content discovery"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Content discovery</h2></div></div></div><p>We have <a id="id94" class="indexterm"/>already mentioned two tools that are very useful for initial discovery scans: <span class="strong"><strong>OWASP ZAP</strong></span> and <span class="strong"><strong>Burp Suite</strong></span>. Burp's Intruder module is throttled in the free version but can <a id="id95" class="indexterm"/>still be useful for quick checks. Both of these attack proxies are available in Kali Linux and can be easily downloaded for other distributions. There are other command-line alternatives, such<a id="id96" class="indexterm"/> as <span class="strong"><strong>Gobuster</strong></span>, which can be used to automate the process a bit more.</p><div class="section" title="Burp Suite"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Burp Suite</h3></div></div></div><p>As mentioned, Burp Suite<a id="id97" class="indexterm"/> comes bundled with the Intruder module, which allows us<a id="id98" class="indexterm"/> to easily perform content discovery. We can leverage it to look for hidden directories and files, and even guess credentials. It supports payload processing and encoding, which enables us to customize our scanning to better interface with the target application.</p><p>In the Intruder module, you can leverage the same wordlists provided by SecLists and can even combine multiple lists into one attack. This is a powerful module with lots of features, including, but not limited to, the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cluster bomb attack, which is well suited for multiple payloads, such as usernames and passwords, which we will showcase later</li><li class="listitem" style="list-style-type: disc">Payload processing for <a id="id99" class="indexterm"/>highly customized attacks</li><li class="listitem" style="list-style-type: disc">Attack throttling and variable <a id="id100" class="indexterm"/>delays for low and slow attacks</li><li class="listitem" style="list-style-type: disc">…and much more!</li></ul></div><p>We will cover these and others in later chapters.</p><div class="mediaobject"><img src="graphics/B09238_02_05.jpg" alt="Burp Suite"/><div class="caption"><p>Figure 2.5: The Burp Suite Intruder module Payloads screen</p></div></div><p>The free version of Burp Suite is readily available in Kali Linux but, as we've noted in the preceding chapter, it is a bit limited. There are some restrictions in the Intruder module, notably the time-throttling of attack connections. For large payload counts, this may become a hindrance.</p><p>The professional version of Burp Suite is highly recommended for those who test applications regularly. Burp Suite is also valuable when reverse engineering applications or protocols. It is quite common for modern applications or malware to communicate with external servers via HTTP. Intercepting, modifying, and replaying this traffic can be valuable.</p></div><div class="section" title="OWASP ZAP"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>OWASP ZAP</h3></div></div></div><p>The free alternative to <a id="id101" class="indexterm"/>Burp Suite is ZAP, a <a id="id102" class="indexterm"/>powerful tool in its own right, and it provides some of the discovery capabilities of Burp Suite.</p><p>The ZAP equivalent for Burp's Intruder is<a id="id103" class="indexterm"/> the <span class="strong"><strong>Fuzzer</strong></span> module, and it has similar functionality, as show in the following figure:</p><div class="mediaobject"><img src="graphics/B09238_02_06.jpg" alt="OWASP ZAP"/><div class="caption"><p>Figure 2.6: OWASP ZAP's Fuzzer module configuration. As ZAP is open-source, there are no usage restrictions. If the goal is to perform a quick content discovery scan or credential brute-force, it may be a better alternative to the free version of Burp Suite.</p></div></div></div><div class="section" title="Gobuster"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Gobuster</h3></div></div></div><p>Gobuster is an efficient command-line utility for<a id="id104" class="indexterm"/> content discovery. Gobuster does not come preinstalled on Kali Linux, but it is available on GitHub. As its name implies, Gobuster was written in the Go language and will require the golang compiler to be installed before it can be used for an attack.</p><p>The steps to configure Gobuster are fairly easy on Kali Linux. We can start by issuing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~# apt-get install golang</strong></span>
</pre></div><p>The preceding command will globally install the Go compiler. This is required to build the latest version of Gobuster.</p><p>Next, you need to make sure that the <code class="literal">GOPATH</code> and <code class="literal">GOBIN</code> environment variables are set properly. We will point <code class="literal">GOPATH</code> to a <code class="literal">go</code> directory in our home path and set <code class="literal">GOBIN</code> to the newly defined <code class="literal">GOPATH</code> value:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~# export GOPATH=~/go</strong></span>
<span class="strong"><strong>root@kali:~# export GOBIN=$GOPATH</strong></span>
</pre></div><p>We can now pull the latest <a id="id105" class="indexterm"/>version of Gobuster from GitHub using the <code class="literal">git clone</code> command:</p><div class="informalexample"><pre class="programlisting">root@kali:~/tools# git clone https://github.com/OJ/gobuster
Cloning into 'gobuster'...
[...]</pre></div><p>We can then get dependencies, and compile the Gobuster application. The <code class="literal">go get</code> and <code class="literal">go build</code> commands will generate the Gobuster binary in the local directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools/gobuster# go get &amp;&amp; go build</strong></span>
</pre></div><p>If the commands <a id="id106" class="indexterm"/>don't produce output, the tool was compiled and is ready for use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools/gobuster# ./gobuster </strong></span>
<span class="strong"><strong>Gobuster v1.3                OJ Reeves (@TheColonial)</strong></span>
<span class="strong"><strong>=====================================================</strong></span>
<span class="strong"><strong>[!] WordList (-w): Must be specified</strong></span>
<span class="strong"><strong>[!] Url/Domain (-u): Must be specified</strong></span>
<span class="strong"><strong>=====================================================</strong></span>
<span class="strong"><strong>root@kali:~/tools/gobuster# </strong></span>
</pre></div><p>Gobuster has many useful features, including attacking through a proxy (such as a local Burp Suite instance), outputting to a file for further processing, or even brute-forcing subdirectories for a target domain.</p><p>The following figure shows Gobuster performing a discovery scan on the <code class="literal">http://10.0.5.181</code> using a common web content file from the SecLists repository:</p><div class="mediaobject"><img src="graphics/B09238_02_07.jpg" alt="Gobuster"/><div class="caption"><p>Figure 2.7: Sample Gobuster running on the 10.0.5.181 server</p></div></div><p>A command-line URL discovery tool may prove useful on systems where we cannot run a full-blown <span class="strong"><strong>graphical user interface</strong></span> (<span class="strong"><strong>GUI</strong></span>) application, such as Burp or ZAP.</p></div></div><div class="section" title="Persistent content discovery"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Persistent content discovery</h2></div></div></div><p>The results of a particular<a id="id107" class="indexterm"/> scan can reveal interesting directories, but they're not<a id="id108" class="indexterm"/> always accessible, and directory indexing is increasingly rare in applications. Thankfully, by using content discovery scans we can look into directories for other misconfigured sensitive information. Consider a scenario where the application hosted on <code class="literal">http://10.0.5.181/</code> contains a particular directory that may be password protected. A common misconfiguration in applications is to protect the parent directory but incorrectly assume all subdirectories are also protected. This leads developers to drop more sensitive directories in the parent and leave them be.</p><p>Earlier inspection of the <code class="literal">robots.txt</code> file revealed a few interesting directories:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Disallow: /cgi-bin/</strong></span>
<span class="strong"><strong>Disallow: /test/</strong></span>
<span class="strong"><strong>Disallow: /~admin/</strong></span>
</pre></div><p>The <code class="literal">admin</code> directory catches the eye, but attempting to access <code class="literal">/~admin/</code> returns an HTTP <code class="literal">403</code> Forbidden error:</p><div class="mediaobject"><img src="graphics/B09238_02_08.jpg" alt="Persistent content discovery"/><div class="caption"><p>Figure 2.8: Access to the directory is forbidden</p></div></div><p>This may be <a id="id109" class="indexterm"/>discouraging, but we can't stop here. The target directory is too<a id="id110" class="indexterm"/> attractive to give up now. Using OWASP ZAP, we can start a new Fuzzer activity on this directory and see if we can find anything of interest that is not protected.</p><p>Make sure that the cursor is placed at the end of the URL in the left-most pane. Click the <span class="strong"><strong>Add</strong></span> button next to <span class="strong"><strong>Fuzz Locations</strong></span> in the right-most pane:</p><div class="mediaobject"><img src="graphics/B09238_02_09.jpg" alt="Persistent content discovery"/><div class="caption"><p>Figure 2.9: Fuzzer configuration, adding Fuzz Locations</p></div></div><p>On the next screen, we can add<a id="id111" class="indexterm"/> a new payload to feed the <span class="strong"><strong>Fuzzer</strong></span>. We will<a id="id112" class="indexterm"/> select the <code class="literal">raft-small-files.txt</code> wordlist from the SecLists repository:</p><div class="mediaobject"><img src="graphics/B09238_02_10.jpg" alt="Persistent content discovery"/><div class="caption"><p>Figure 2.10: Fuzzer configuration – the Add Payload screen</p></div></div><p>Since we want to <a id="id113" class="indexterm"/>treat the <code class="literal">/~admin</code> URI as a directory and look for files<a id="id114" class="indexterm"/> within, we will have to use a string processor for the selected payload. This will be a simple <span class="strong"><strong>Prefix String</strong></span> processor, which will prepend a forward-slash to each entry in our list.</p><div class="mediaobject"><img src="graphics/B09238_02_11.jpg" alt="Persistent content discovery"/><div class="caption"><p>Figure 2.11: Fuzzer configuration – the Add Processor screen</p></div></div><p>The Fuzzer task may take<a id="id115" class="indexterm"/> a while to complete, and it will produce<a id="id116" class="indexterm"/> lots of <code class="literal">403</code> or <code class="literal">404</code> errors. In this case, we were able to locate a somewhat hidden administration file.</p><div class="mediaobject"><img src="graphics/B09238_02_12.jpg" alt="Persistent content discovery"/><div class="caption"><p>Figure 2.12: The completed Fuzzer scan shows an accessible hidden file</p></div></div><p>The HTTP <code class="literal">200</code> response indicates that we have access to this file, even though the parent directory <code class="literal">/~admin/</code> was inaccessible. It appears we have access to the <code class="literal">admin.html</code> file contained within the enticing <code class="literal">admin</code> directory.</p><p>Application security is <a id="id117" class="indexterm"/>hard to implement correctly, and it is even harder to maintain that initial security baseline as the application ages and evolves, and staff rotate. Access is granted and not removed; files are added with broken permissions; and underlying operating systems and<a id="id118" class="indexterm"/> frameworks become outdated, and remotely exploitable.</p><p>When running initial content discovery scans, it is important to remember not to stop at the first error message we see. Access control deficiencies are very common, and we could uncover various unprotected subdirectories or files if we are persistent.</p></div><div class="section" title="Payload processing"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Payload processing</h2></div></div></div><p>Burp Suite's Intruder module<a id="id119" class="indexterm"/> is a powerful ally to an attacker when targeting web applications. Earlier<a id="id120" class="indexterm"/> discovery scans have identified the<a id="id121" class="indexterm"/> secretive, but enticing, <code class="literal">/~admin/</code> directory. A subsequent scan of the directory itself uncovered an unprotected <code class="literal">admin.html</code> file.</p><p>Before we proceed, we will switch to the Burp Suite attack proxy and configure the <span class="strong"><strong>Target Scope</strong></span> to the <code class="literal">vuln.app.local</code> domain:</p><div class="mediaobject"><img src="graphics/B09238_02_13.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.13: The Burp Suite Target Scope configuration screen</p></div></div><p>The <span class="strong"><strong>Target Scope</strong></span> allows us to define hosts, ports, or URLs that are to be included in the scope of the attack. This helps to filter out traffic that may not be related to our target. With Burp Suite configured <a id="id122" class="indexterm"/>as our attack proxy, we can visit the<a id="id123" class="indexterm"/> hidden <code class="literal">admin.html</code> URL and record the traffic in our proxy's history:</p><div class="mediaobject"><img src="graphics/B09238_02_14.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.14: Accessing the hidden file through the browser succeeds</p></div></div><p>Following the <span class="strong"><strong>Server Connectivity Test</strong></span> link, we are greeted with a basic authentication realm <span class="strong"><strong>Admin Tools</strong></span>, as shown here:</p><div class="mediaobject"><img src="graphics/B09238_02_15.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.15: Authentication popup when attempting to follow the link</p></div></div><p>Our pentester reflexes <a id="id124" class="indexterm"/>kick in and we automatically type in the<a id="id125" class="indexterm"/> unfortunately common <code class="literal">admin/admin</code> credentials, but with no luck this time.</p><p>Since all of the interactions with the target are being recorded by the Burp proxy, we can simply pass the failed request on to the Intruder module, as shown in the following figure. Intruder will let us attack the basic authentication mechanism with little effort:</p><div class="mediaobject"><img src="graphics/B09238_02_16.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.16: The HTTP history screen</p></div></div><p>In the Intruder module, the<a id="id126" class="indexterm"/> defaults are good for the most part—we just <a id="id127" class="indexterm"/>have to select the Base64-encoded credentials portion of the <code class="literal">Authorization</code> header and click the <span class="strong"><strong>Add</strong></span> button on the right-hand side. This will identify this position in the HTTP request as the payload location.</p><p>The following shows the payload position selected in the <code class="literal">Authorization</code> header:</p><div class="mediaobject"><img src="graphics/B09238_02_17.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.17: Specifying a payload position in the Authorization header</p></div></div><p>In the <span class="strong"><strong>Payloads</strong></span> tab, we will select the <span class="strong"><strong>Custom iterator</strong></span> payload type from the dropdown, as seen in the following figure:</p><div class="mediaobject"><img src="graphics/B09238_02_18.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.18: Configuring the Payload type</p></div></div><p>The <code class="literal">Authorization</code> header contains <a id="id128" class="indexterm"/>the Base64-encoded plaintext values of the <a id="id129" class="indexterm"/>colon-separated username and password. To brute-force the application effectively, the payload will have to be in the same format. We will need to submit a payload that follows the same format that the <code class="literal">Authorization</code> header expects. For each brute-force request that the attack proxy will make, the payload will have to be the username and password separated by a colon, and wrapped by Base64 encoding: <code class="literal">base64([user_payload]:[password_payload])</code>.</p><p>We can grab the already captured value in the <code class="literal">Authorization</code> header and pass it to Burp Suite's Decoder module. Decoder allows us <a id="id130" class="indexterm"/>to quickly process strings to and from various encoding schemes, such as Base64, URL encoding, GZip, and others.</p><p>This figure shows how we can leverage Decoder to convert the value <code class="literal">YWRtaW46YWRtaW4=</code> from Base64 using the <span class="strong"><strong>Decode as...</strong></span> dropdown. The result is listed in the bottom pane as <code class="literal">admin:admin</code>:</p><div class="mediaobject"><img src="graphics/B09238_02_19.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.19: The Burp Decoder screen</p></div></div><p>Back in the Intruder module, for payload position 1, we will once again use a small wordlist from the SecLists <code class="literal">Usernames</code> collection called <code class="literal">top-usernames-shortlist.txt</code>. Our goal is <a id="id131" class="indexterm"/>to find low-hanging fruit, while minimizing the <a id="id132" class="indexterm"/>flood of requests that will hit the application. Using a short list of common high-value usernames is a good first step.</p><p>This figure shows that the list was loaded in payload position 1 using the <span class="strong"><strong>Load...</strong></span> button in the <span class="strong"><strong>Payload Options</strong></span>:</p><div class="mediaobject"><img src="graphics/B09238_02_20.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.20: Payload position 1 configuration screen</p></div></div><p>The separator for <a id="id133" class="indexterm"/>position 1 should be colon (<code class="literal">:</code>). For payload position 2, you<a id="id134" class="indexterm"/> can use the <code class="literal">500-worst-passwords.txt</code> list from the SecLists passwords directory.</p><p>The following figure shows payload position 2 containing the loaded <code class="literal">500-worst-passwords.txt</code> contents:</p><div class="mediaobject"><img src="graphics/B09238_02_21.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.21: Payload position 2 configuration screen</p></div></div><p>The separator for <a id="id135" class="indexterm"/>position 2 should be left blank.</p><p>At this point, each request sent to the application will contain an <code class="literal">Authorization</code> header in the following format:</p><div class="informalexample"><pre class="programlisting">Authorization: Basic admin:admin
Authorization: Basic admin:test
[...]
Authorization: Basic root:secret
Authorization: Basic root:password</pre></div><p>To complete the payload, we also <a id="id136" class="indexterm"/>have to instruct Intruder to Base64-encode the payload before sending it over the wire. We can use a payload processor to force Base64 encoding for every request.</p><p>In the <span class="strong"><strong>Payloads</strong></span> tab, under <span class="strong"><strong>Payload Processing</strong></span>, click <span class="strong"><strong>Add</strong></span> and select the <span class="strong"><strong>Base64-encode</strong></span> processor from the <span class="strong"><strong>Encode</strong></span> category. We will also disable automatic URL encoding, as it may break the <code class="literal">Authorization</code> header.</p><p>The following URL shows the enabled <span class="strong"><strong>Base64-encode</strong></span> processor:</p><div class="mediaobject"><img src="graphics/B09238_02_22.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.22: Payload processing rule – Base64-encode</p></div></div><p>Once the <a id="id137" class="indexterm"/>payload has been configured, we can begin the brute-force using the <span class="strong"><strong>Start Attack</strong></span> button in the top-right corner of the <span class="strong"><strong>Intruder</strong></span> module, as shown in the <a id="id138" class="indexterm"/>following figure:</p><div class="mediaobject"><img src="graphics/B09238_02_23.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.23: Starting the attack</p></div></div><p>As with the content discovery scan, this credential brute-force will generate a fair amount of HTTP <code class="literal">401</code> errors. If we're lucky, at least one will be successful, as seen in the figure that follows:</p><div class="mediaobject"><img src="graphics/B09238_02_24.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.24: Attack results screen</p></div></div><p>Now, because<a id="id139" class="indexterm"/> every request in the Intruder attack is recorded, we can inspect each one or sort all of them by column to better illustrate the results of the attack. In the preceding example, we can clearly see that the successful authentication request<a id="id140" class="indexterm"/> returned an HTTP status code of <code class="literal">200</code>, while the majority of the other requests returned an expected <code class="literal">401</code>. The status code is not the only way to determine success at a quick glance, however. A deviation in the content length of the response may be a good indicator that we are on the right track.</p><p>Now that we have a payload that has successfully gained access to the Admin Tools authentication realm, we can run it through the Decoder module to see the plaintext credentials.</p><p>This figure shows the Decoder module revealing the guessed credentials:</p><div class="mediaobject"><img src="graphics/B09238_02_25.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.25: Burp Suite Decoder</p></div></div><p>Credential brute-forcing is<a id="id141" class="indexterm"/> just one of the many uses for Intruder. You can get creative with custom payloads and payload processing.</p><p>Consider a scenario where the <code class="literal">vuln.app.local</code> application generates PDF files with sensitive information and stores them in an unprotected directory called <code class="literal">/pdf/</code>. The filenames appear to be the MD5 digest <a id="id142" class="indexterm"/>of the date the file was generated, but the application will not generate a PDF file every day. You could try and guess each day manually, but that's not ideal. You can even spend some time whipping up a Python script that can automate this task. The better alternative is to leverage Burp Suite to do this easily with a few clicks. This has the added benefit of recording the attack responses in one window for easy inspection.</p><p>Once again, we can send a previously recorded request to the target <code class="literal">/pdf/</code> folder directly to the Intruder module.</p><p>This figure shows that the PDF's name, minus the extension, is identified as the payload position using the <span class="strong"><strong>Add</strong></span> button:</p><div class="mediaobject"><img src="graphics/B09238_02_26.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.26: Intruder Payload Positions configuration screen</p></div></div><p>The following figure<a id="id143" class="indexterm"/> shows the <span class="strong"><strong>Dates</strong></span> payload type <a id="id144" class="indexterm"/>options available in Intruder:</p><div class="mediaobject"><img src="graphics/B09238_02_27.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.27: Intruder's Payloads screen</p></div></div><p>In this attack, you will<a id="id145" class="indexterm"/> use the <span class="strong"><strong>Dates</strong></span> payload type with the proper <a id="id146" class="indexterm"/>date format, going back a couple of years. The payload processor will be the MD5 hash generator, which will generate a hash of each date and return the equivalent string. This is similar to our <span class="strong"><strong>Base64-encode</strong></span> processor from the previous attack.</p><p>Once again, the payload options have been configured and we can start the attack.</p><p>The following figure shows a few requests with the <code class="literal">200</code> HTTP status code and a large length indicating a PDF file is available for download:</p><div class="mediaobject"><img src="graphics/B09238_02_28.jpg" alt="Payload processing"/><div class="caption"><p>Figure 2.28: Intruder attack Results screen</p></div></div><p>Intruder will<a id="id147" class="indexterm"/> generate the payload list based on our specified date <a id="id148" class="indexterm"/>format and calculate the hash of the string, before sending it to the application, all with a few clicks. In no time, we have discovered at least three improperly protected, potentially sensitive documents that are available anonymously.</p></div></div>
<div class="section" title="Polyglot payloads"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Polyglot payloads</h1></div></div></div><p>A polyglot payload<a id="id149" class="indexterm"/> is defined as a piece of code that can be executed in multiple contexts in the application. These types of payloads are popular with attackers because they can quickly test an application's input controls for any weaknesses, with minimal noise. </p><p>In a complex application, user input can travel through many checkpoints—from the URL through a filter, into a database, and back out to a decoder, before being displayed to the user, as illustrated in the following figure:</p><div class="mediaobject"><img src="graphics/B09238_02_29.jpg" alt="Polyglot payloads"/><div class="caption"><p>Figure 2.29: Typical data flow from user to application</p></div></div><p>Any one of the steps along the way can alter or block the payload, which may make it more difficult to confirm the existence of a vulnerability in the application. A polyglot payload will attempt to exploit an injection vulnerability by combining multiple methods for executing code in the same stream. This attempts to exploit weaknesses in the application payload filtering, increasing the chance that at least one portion of the code will be missed and will execute successfully. This is made possible by the fact that JavaScript is a very forgiving<a id="id150" class="indexterm"/> language. Browsers have always been an easy barrier of entry for developers, and JavaScript is rooted in a similar philosophy.</p><p>The OWASP <span class="strong"><strong>cross-site scripting</strong></span> (<span class="strong"><strong>XSS</strong></span>) Filter Evasion Cheat Sheet<a id="id151" class="indexterm"/> contains examples of polyglot payloads, which can also evade some application filters: <a class="ulink" href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet</a>.</p><p>A good example of a strong polyglot payload can be found on GitHub from researcher Ahmed Elsobky:</p><div class="informalexample"><pre class="programlisting">jaVasCript:/*-/*'/*\'/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e</pre></div><p>At first glance, this appears rather messy, but every character has a purpose. This payload was designed to execute JavaScript in a variety of contexts, whether the code is reflected inside an HTML tag or right in the middle of another piece of JavaScript. The browser's HTML and JavaScript parsers are extremely accommodating. They are case-insensitive, error-friendly, and they don't care much about indenting, line endings, or spacing. Escaped or encoded characters are sometimes converted back to their original form and injected into the page. JavaScript in particular does its very best to execute whatever code is passed to it. A<a id="id152" class="indexterm"/> good polyglot payload will take advantage of all of this, and seek to evade some filtering as well.</p><p>The first thing a sharp eye will notice is that most of the keywords, such as <code class="literal">textarea</code>, <code class="literal">javascript</code>, and <code class="literal">onload,</code> are randomly capitalized:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>jaVasCript</strong></span>:/*-/*'/*\'/*'/*"/**/(/* */<span class="strong"><strong>oNcliCk</strong></span>=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/<span class="strong"><strong>teXtarEa</strong></span>/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/<span class="strong"><strong>oNloAd</strong></span>=alert()//&gt;\x3e</pre></div><p>This may seem like a futile attempt to evade application firewall input filters, but you'd be surprised how many are poorly designed. Consider the following <span class="strong"><strong>regular expression</strong></span> (<span class="strong"><strong>regex</strong></span>) input filter:</p><div class="informalexample"><pre class="programlisting">s/onclick=[a-z]+\(.+\)//<span class="strong"><strong>g</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>A regex is a piece of text defining a search pattern. Some WAFs may use regex to try and find potentially dangerous strings inside HTTP requests.</p></div></div><p>This will effectively prevent JavaScript code from being injected via the <code class="literal">onclick</code> event, but with one glaring flaw: it doesn't take into account case-sensitivity. Regular expressions have many modifiers, such as the <code class="literal">g</code> in the preceding example, and by default most engines require the <code class="literal">i</code> modifier to ignore case, or else they will not match and the filter is vulnerable to bypass.</p><p>The following figure shows Regex101's visualization of the preceding regex applied to a sample test string. We can see that only two of the four payloads tested matched the expression, while all four would execute JavaScript code:</p><div class="mediaobject"><img src="graphics/B09238_02_30.jpg" alt="Polyglot payloads"/><div class="caption"><p>Figure 2.30: Regex filter visualization</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>When assessing an application's regex-based input filter, Regex101 is a great place to test it against several payloads at once. Regex101 is <a id="id153" class="indexterm"/>an online tool available for free at <a class="ulink" href="https://regex101.com">https://regex101.com</a>.</p></div></div><p>Many times, developers <a id="id154" class="indexterm"/>work under unrealistic time constraints. When a penetration testing report highlights a particular input sanitization issue, developers are pressured to turn in a security fix that was quickly written, insufficiently tested, and remediates only part of the problem. It is often too time-consuming and expensive to implement a potentially application-breaking framework to handle input filtering, and shortcuts are taken at security's expense.</p><p>The Elsobky payload also aims to exploit being passed through an engine that processes hex-encoded values escaped with a backslash. JavaScript and Python, for example, will process two alphanumeric characters preceded by <code class="literal">\x</code> as one byte. This could bypass certain in-line XSS filters that perform primitive string compare checks:</p><div class="informalexample"><pre class="programlisting">jaVasCript:/*-/*'/*\'/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\<span class="strong"><strong>x3c</strong></span>sVg/&lt;sVg/oNloAd=alert()//&gt;\<span class="strong"><strong>x3e</strong></span>
</pre></div><p>It is possible that the payload may be stripped of most of the other keywords, but when the filter reaches <code class="literal">\x3c</code> and <code class="literal">\x3e</code>, it interprets them as benign strings of four characters. The application may parse the string and inadvertently return the one-byte equivalent of the escaped hexadecimal characters <code class="literal">&lt;</code> and <code class="literal">&gt;</code> respectively. The result is an <code class="literal">&lt;svg&gt;</code> HTML element that executes arbitrary JavaScript via the <code class="literal">onload</code> event.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>
<span class="strong"><strong>Scalable Vector Graphics</strong></span> (<span class="strong"><strong>SVG</strong></span>) is an<a id="id155" class="indexterm"/> element on a page that can be used to draw complex graphics on the screen without binary data. SVG is used in XSS attacks mainly because it provides an <code class="literal">onload</code> property, which will execute arbitrary JavaScript code when the element is rendered by the browser.</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>More examples of the power of this particular polyglot are on Elsobky's GitHub page: <a class="ulink" href="https://github.com/0xSobky">https://github.com/0xSobky</a>.</p></div></div><p>A powerful polyglot payload is able to execute some code in a variety of injection scenarios. The Elsobky payload can also be useful when reflected in the server HTTP response:</p><div class="informalexample"><pre class="programlisting">jaVasCript:/*-/*'/*\'/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e</pre></div><p>The URL encoded characters <code class="literal">%0d</code> and <code class="literal">%0a</code> represent newline and carriage return. These characters are largely ignored by HTML and JavaScript parsers, but they are significant in the HTTP request or response header.</p><p>If the target application fails to filter user input properly, in some cases it may take the arbitrary value and add it as part of the HTTP response. For example, in an attempt to set a "Remember me" cookie, the application reflects the payload unfiltered in the HTTP response headers, which results in XSS in the user's browser:</p><div class="informalexample"><pre class="programlisting">GET /save.php?remember=username HTTP/1.1
Host: www.cb2.com
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101 Firefox/45.0
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
[...]
HTTP/1.1 200 OK
Cache-Control: private
Content-Type: text/html; charset=utf-8
Server: nginx/1.8.1
Set-Cookie: remember_me=username
Connection: close
Username saved!</pre></div><p>If we pass in the <a id="id156" class="indexterm"/>polyglot as the username to remember, the HTTP response headers are altered and the body will contain attacker-controlled data as follows:</p><div class="informalexample"><pre class="programlisting">GET /save.php?remember=<span class="strong"><strong>jaVasCript%3A%2F*-%2F*%60%2F*%60%2F*'%2F*%22%2F**%2F(%2F*%20*%2FoNcliCk%3Dalert()%20)%2F%2F%0D%0A%0d%0a%2F%2F%3C%2FstYle%2F%3C%2FtitLe%2F%3C%2FteXtarEa%2F%3C%2FscRipt%2F--!%3E%3CsVg%2F%3CsVg%2FoNloAd%3Dalert()%2F%2F%3E%3E</strong></span> HTTP/1.1
Host: www.cb2.com
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101 Firefox/45.0
Content-Type: application/x-www-form-urlencoded; charset=UTF-8</pre></div><p>The server responds with the following:</p><div class="informalexample"><pre class="programlisting">HTTP/1.1 200 OK
Cache-Control: private
Content-Type: text/html; charset=utf-8
Server: nginx/1.8.1
Set-Cookie: remember_me=<span class="strong"><strong>jaVasCript</strong></span>:/*-/*'/*\'/*'/*"/**/(/* */<span class="strong"><strong>oNcliCk=alert()</strong></span> )//

<span class="strong"><strong>//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e</strong></span>
Connection: close
Username saved!</pre></div><p>The response is a bit mangled, but we do have code execution. The URL encoded carriage return characters <code class="literal">%0D%0A%0d%0a</code> are interpreted as part of the HTTP response. In the HTTP protocol, two sets of carriage returns and line feeds indicate the end of the header, and anything that follows this will be rendered by the browser as part of the page.</p><div class="section" title="Same payload, different context"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Same payload, different context</h2></div></div></div><p>There are many other contexts<a id="id157" class="indexterm"/> in which this polyglot can successfully execute code.</p><p>If the polyglot payload is reflected inside the <code class="literal">value</code> property of the username input, the browser's interpretation of the code clearly shows a broken input field and a malicious <code class="literal">&lt;svg&gt;</code> element. The HTML code before the payload is processed looks like this:</p><div class="informalexample"><pre class="programlisting">&lt;input type="text" name="username" value="[payload]"&gt;</pre></div><p>This figure shows how the <a id="id158" class="indexterm"/>browser views the HTML code after the payload has been processed:</p><div class="mediaobject"><img src="graphics/B09238_02_31.jpg" alt="Same payload, different context"/><div class="caption"><p>Figure 2.31: Reflected XSS payload</p></div></div><p>The polyglot will also execute code if reflected inside an HTML comment, such as <code class="literal">&lt;!-- Comment! [payload] --&gt;</code>.</p><p>The payload contains the end of comment indicator <code class="literal">--&gt;</code>, which leaves the rest of the text to be interpreted by the browser as HTML code. Once again, the <code class="literal">&lt;svg&gt;</code> element's <code class="literal">onload</code> property will execute our arbitrary code.</p><p>This figure shows how the browser views the HTML code after the payload has been processed:</p><div class="mediaobject"><img src="graphics/B09238_02_32.jpg" alt="Same payload, different context"/><div class="caption"><p>Figure 2.32: Reflected XSS payload</p></div></div><p>Our polyglot is also useful if reflected inside some code setting up a regex object, such as <code class="literal">var expression = /[payload]/gi</code>.</p><p>We can test this behavior inside the browser console with the preceding sample code:</p><div class="mediaobject"><img src="graphics/B09238_02_33.jpg" alt="Same payload, different context"/><div class="caption"><p>Figure 2.33: Polyglot visualization</p></div></div><p>We can see that strategically placed comment indicators, such as <code class="literal">/*</code>, <code class="literal">*/</code>, and <code class="literal">//</code>, will cause the browser to ignore the majority of the payload, resulting in valid JavaScript.</p><p>It's subtle, but the code execution happens here:</p><div class="informalexample"><pre class="programlisting">(/* */oNcliCk=alert()
)</pre></div><p>The multi-line comments are<a id="id159" class="indexterm"/> ignored, and JavaScript will execute anything between the parenthesis. In this context, <code class="literal">oNcliCk</code> does not represent a mouse event binder, but instead it is used to store the return of the <code class="literal">alert()</code> function, which results in arbitrary code execution.</p></div><div class="section" title="Code obfuscation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Code obfuscation</h2></div></div></div><p>Not all application<a id="id160" class="indexterm"/> firewalls strip input of malicious strings and let the rest go through. Some inline solutions will drop the connection outright, usually in the form of a <code class="literal">403</code> or <code class="literal">500</code> HTTP response. In such cases, it may be difficult to determine which part of the payload is considered safe and which triggered the block.</p><p>By design, inline firewalls have to be fairly fast and they cannot introduce significant delay when processing incoming data. The result is usually simple logic when attempting to detect <span class="strong"><strong>SQL injection</strong></span> (<span class="strong"><strong>SQLi</strong></span>) or XSS attacks. Random<a id="id161" class="indexterm"/> capitalization may not fool these filters, but you can safely assume that they do not render on the fly every requested HTML page, let alone execute JavaScript to look for malicious behavior. More often than not, inline application firewalls will look for certain keywords and label the input as potentially malicious. For example, <code class="literal">alert()</code> may trigger the block, while <code class="literal">alert</code> by itself would produce too many false-positives.</p><p>To increase the chances <a id="id162" class="indexterm"/>of success and lower the noise, we can change the way the <code class="literal">alert()</code> function is called in seemingly unlimited ways — all thanks to JavaScript. We can test this in the browser console by inspecting the native <code class="literal">alert()</code> function. The <code class="literal">window</code> object will hold a reference to it and we can confirm this by calling the function without parentheses. The console will indicate that this is a built-in function with <code class="literal">[native code]</code> displayed as its body. This means that this is not a custom user-defined function and it is defined by the browser core.</p><p>In JavaScript, we have multiple ways of accessing properties of an object, including function references such as <code class="literal">alert</code>.</p><p>This figure shows how we can access the same function directly or using array notation, with an <code class="literal">"alert"</code> string inside square brackets:</p><div class="mediaobject"><img src="graphics/B09238_02_34.jpg" alt="Code obfuscation"/><div class="caption"><p>Figure 2.34: Different ways to access the alert() function</p></div></div><p>To bypass rudimentary filters, which may drop suspicious strings, such as <code class="literal">alert</code>(<code class="literal">1</code>), we can leverage some simple encoding.</p><p>Using JavaScript's <code class="literal">parseInt</code> function, we can get the integer representation of any string, using a custom base. In this case, we can get the base 30 representation of the <code class="literal">"alert"</code> string. To convert the resulting integer back to its string equivalent, we can leverage the built-in <code class="literal">toString()</code> method while passing the integer base as the first parameter:</p><div class="mediaobject"><img src="graphics/B09238_02_35.jpg" alt="Code obfuscation"/><div class="caption"><p>Figure 2.35: The "alert" string encoding and decoding</p></div></div><p>Now that we know <code class="literal">8680439..toString(30)</code> is the equivalent of string <code class="literal">"alert"</code>, we can use the <code class="literal">window</code> object and<a id="id163" class="indexterm"/> array notation to access the native code for the <code class="literal">alert()</code> function.</p><p>This figure shows how we can call the <code class="literal">alert()</code> function using the obfuscated string:</p><div class="mediaobject"><img src="graphics/B09238_02_36.jpg" alt="Code obfuscation"/><div class="caption"><p>Figure 2.36: Executing alert() with an encoded string</p></div></div><p>We can follow the same process to obfuscate a call to the <code class="literal">console.log()</code> function. Much like most available native functions, <code class="literal">console</code> is accessible through the <code class="literal">window</code> object as well.</p><p>The following figure shows how we can encode the strings <code class="literal">console</code> and <code class="literal">log</code>, and utilize the same array notation to access properties and subproperties until we reach the native code for <code class="literal">console.log()</code>:</p><div class="mediaobject"><img src="graphics/B09238_02_37.jpg" alt="Code obfuscation"/><div class="caption"><p>Figure 2.37: Encoding the entire console.log command</p></div></div><p>For the traditional strongly-typed language developer, this convention looks alien. As we've already seen, JavaScript <a id="id164" class="indexterm"/>engines are very forgiving and enable a variety of ways to execute code. In the preceding examples, we are decoding the base 30 integer representation of our function and passing it as a key to the <code class="literal">window</code> object.</p><p>After some modification, the Elsobky payload could be made a bit more stealthy with obfuscation. It could look something like the following:</p><div class="informalexample"><pre class="programlisting">jaVasCript:/*-/*'/*\'/*'/*"/**/(/* */oNcliCk=<span class="strong"><strong>top[8680439..toString(30)]()</strong></span> )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=top[8680439..toString(30)]()//&gt;\x3e</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>The <code class="literal">top</code> keyword is a synonym for window and can be used to reference anything you need from the <code class="literal">window</code> object.</p></div></div><p>With just a minor change, the polyglot payload is still effective and is now more likely to bypass rudimentary inline filters that may attempt to filter or block the discovery attempts.</p><p>Brutelogic offers a great list of XSS payloads with many other ways to execute code unconventionally at <code class="literal">https</code>
<code class="literal">://brutelogic.com.br/blog/cheat-sheet/</code>.</p></div></div>
<div class="section" title="Resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Resources</h1></div></div></div><p>Consult the following resources for more information on penetration testing tools<a id="id165" class="indexterm"/> and techniques:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Metasploit</strong></span>: <a class="ulink" href="https://www.metasploit.com/">https://www.metasploit.com/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>WPScan</strong></span>: <a class="ulink" href="https://wpscan.org/">https://wpscan.org/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>CMSmap</strong></span>: <a class="ulink" href="https://github.com/Dionach/CMSmap">https://github.com/Dionach/CMSmap</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Recon-NG</strong></span> (<span class="strong"><strong>available in Kali Linux or via the Bitbucket repository</strong></span>): <a class="ulink" href="https://bitbucket.org/LaNMaSteR53/recon-ng">https://bitbucket.org/LaNMaSteR53/recon-ng</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>OWASP XSS Filter Evasion Cheat Sheet</strong></span>: <a class="ulink" href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Elsobky's GitHub page</strong></span>: <a class="ulink" href="https://github.com/0xSobky">https://github.com/0xSobky</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Brutelogic cheat sheet</strong></span>: <a class="ulink" href="https://brutelogic.com.br/blog/cheat-sheet/">https://brutelogic.com.br/blog/cheat-sheet/</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SecLists repository</strong></span>: <a class="ulink" href="https://github.com/danielmiessler/SecLists">https://github.com/danielmiessler/SecLists</a></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FuzzDB</strong></span>: <a class="ulink" href="https://github.com/fuzzdb-project/fuzzdb">https://github.com/fuzzdb-project/fuzzdb</a></li></ul></div></div>
<div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Exercises</h1></div></div></div><p>Complete the following exercises:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a copy of the SecLists and FuzzDB repositories in your tools folder and study the available wordlists</li><li class="listitem">Download and compile Gobuster</li></ol></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, we looked at improving your efficiency for gathering information on a target, and covered several ways to do this. If stealth is paramount during an engagement, efficient content discovery can also reduce the chance that the blue team will notice the attack.</p><p>Time-tested tools, such as Nmap and Nikto, can give us a head start, while WPScan and CMSmap can hammer away at complex CMS that are frequently misconfigured and seldom updated. For larger networks, masscan can quickly identify interesting ports, such as those related to web applications, allowing for more specialized tools, such as WhatWeb and WPScan, to do their job faster.</p><p>Web content and vulnerability discovery scans with Burp or ZAP can be improved with proper wordlists from repositories, such as SecLists and FuzzDB. These collections of known and interesting URLs, usernames, passwords, and fuzzing payloads can greatly improve scan success and efficiency.</p><p>In the next chapter, we will look at how we can leverage low-hanging fruit to compromise web applications.</p></div></body></html>