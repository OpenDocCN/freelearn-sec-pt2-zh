- en: Chapter 2. Efficient Discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Content discovery and information gathering are typically the first steps when
    attacking an application. The goal is to figure out as much as possible about
    the application in the quickest manner possible. Time is a luxury we don't have
    and we must make the most of our limited resources.
  prefs: []
  type: TYPE_NORMAL
- en: Efficiency can also help us to remain a bit quieter when attacking applications.
    Smart wordlists will reduce the number of requests we make to the server and return results
    faster. This isn't a silver bullet, but it's a good place to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The different types of penetration testing engagements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target mapping with various network and web scanners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient brute-forcing techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polyglot payloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of assessments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the agreement with the client prior to the engagement, you may
    have some of the information required, a lot of information, or no information
    whatsoever. **White-box** testing allows for a thorough examination of the application.
    In this case, the attackers have essentially the same access as the developer.
    They not only have authenticated access to the application, but also its source
    code, any design documents, and anything else they'll need.
  prefs: []
  type: TYPE_NORMAL
- en: White-box testing is typically conducted by internal teams and it is fairly
    time-consuming. A tester is provided with any information they require to fully
    assess the application or infrastructure. The benefit of providing testers with
    this level of knowledge is that they will be able to look at every bit of an application
    and check for vulnerabilities. This is a luxury that external attackers do not
    have, but it does make efficient use of limited time and resources during an engagement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Gray-box** scenarios are more common, as they provide just enough information
    to let the testers get right into probing the application. A client may provide
    credentials and a bit of information on the design of the infrastructure or application,
    but not much more. The idea here is that the client assumes that a malicious actor
    already has a certain level of access or knowledge, and the client needs to understand
    how much more damage can be done.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, **black-box** testing will simulate an attack from the perspective
    of an outsider without any knowledge of the application or infrastructure. Companies
    that expose applications to the internet are subjected to constant attack by external
    threats. While it is important to remember that not all malicious actors are external,
    as disgruntled employees can cause just as much damage, malicious black-box type
    attacks are fairly common and can be very damaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a breakdown of the three common types of application penetration tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '| White-box | Gray-box | Black-box |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Attacker has access to all information required. | Some information is available.
    | Zero knowledge. |'
  prefs: []
  type: TYPE_TB
- en: '| Testing with the highest privilege, that is, with developer knowledge. |
    Testing from the perspective of a threat that already has a certain level of access
    or knowledge. | Testing from the perspective of an external threat. |'
  prefs: []
  type: TYPE_TB
- en: '| Typical information available includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: User accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure design documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directory listing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Provides the attacker with some information:'
  prefs: []
  type: TYPE_NORMAL
- en: User accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attacker will usually not have access to the source code, or other sensitive
    information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| No information is provided up-front and the attacker must gather everything
    they need through **open-source intelligence** (**OSINT**) or vulnerabilities
    that lead to information leakage. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the remainder of this book, we will approach our targets from a more gray-box
    perspective, simulating the typical engagement.
  prefs: []
  type: TYPE_NORMAL
- en: Target mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The traditional `nmap` of the entire port range, with service discovery, is
    always a good place to start when gathering information on a target. **Nmap**
    is the network scanning tool of choice and has been for many years. It is still
    very powerful and very relevant. It is available on most platforms, including
    Kali, BlackArch, and even Windows.
  prefs: []
  type: TYPE_NORMAL
- en: '**Metasploit Framework** (**MSF**) is a penetration testing framework commonly
    used by security professionals. Besides being a fantastic collection of easy-to-deliver
    exploits, it can also help to organize engagements. For target mapping specifically,
    you can leverage the workspace feature and neatly store your Nmap scan results
    in a database.'
  prefs: []
  type: TYPE_NORMAL
- en: If the Kali Linux instance is fresh or Metasploit was recently installed, the
    database may need a kick to get it going.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Kali console prompt, start the **PostgreSQL** service using the `service`
    command. If successful, there should be no message returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Metasploit can then be started using the `msfconsole` command, which will drop
    us into a sub-prompt, prefixed with `msf` instead of the traditional bash prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding series of commands will start the PostgreSQL database service,
    which Metasploit uses for storage. The Metasploit console is launched and we can
    check the database status using MSF's `db_status` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `exit` command to return to the bash terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the Metasploit `msfdb` command to help us initialize (`init`)
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `msfdb` command creates all of the necessary configuration files for Metasploit
    to be able to connect to the database. Once again, we can start the Metasploit
    console using the `msfconsole` command in the Linux prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The YML database configuration file, created with the `msfdb init` command,
    can be passed to the `db_connect` Metasploit console command as with the `-y`
    switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a workspace for the target application, which will help us
    to organize results from various MSF modules, scans, or exploits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `workspace` command without any parameters will list the available workspaces,
    marking the active one with an asterisk. At this point, we can start an Nmap scan
    from within MSF. The `db_nmap` MSF command is a wrapper for the Nmap scanning
    tool. The difference is that the results of the scan are parsed and stored inside the
    Metasploit database for easy browsing.
  prefs: []
  type: TYPE_NORMAL
- en: MSF's `db_nmap` takes the same switches as the normal `nmap`. In the following
    example, we are scanning for common ports and interrogating running services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The target for this scan is an internal host, `10.0.5.198`. We are instructing
    Nmap to perform a service scan (`-sV`) without pinging hosts (`-Pn`), and using
    verbose output (`-v`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the scan completes, the results can be queried and filtered using the
    `services` command. For example, we can look for all HTTP services discovered
    by using the `-s` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take note of the scope provided by the client. Some will specifically constrain
    application testing to one port, or sometimes even only one subdomain or URL.
    The scoping call is where the client should be urged not to limit the attack surface
    available to the tester.
  prefs: []
  type: TYPE_NORMAL
- en: Masscan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nmap is fully featured, with a ton of options and capabilities, but there is
    one problem: speed. For large network segments, Nmap can be very slow and sometimes
    can fail altogether. It''s not unusual for clients to request a penetration test
    on a huge IP space with little time allotted for the mapping and scanning phase.'
  prefs: []
  type: TYPE_NORMAL
- en: The claim to fame of **masscan** is that it can scan the internet IP space in
    about six minutes. This is an impressive feat and it is certainly one of the fastest
    port scanners out there.
  prefs: []
  type: TYPE_NORMAL
- en: During an engagement, we may wish to target web applications first and `masscan`
    can quickly return all open web ports with just a couple of switches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The familiar `-p` switch can be used to specify a series, or range, of ports
    to look for. The `--banners` switch will attempt to retrieve some information
    about any open ports that are discovered. For larger IP spaces, where time is
    of the essence, we can use the `--rate` switch to specify a large packet per second
    number, such as a million or more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Masscan](graphics/B09238_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: A masscan of the 10.0.0.0/8 network'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the preceding scan was cancelled early with the *Ctrl* + *C*
    interrupt, and masscan saved its progress in a `paused.conf` file, allowing us
    to resume the scan at a later time. To pick up where we left off, we can use the
    `--resume` switch, passing the `paused.conf` file as the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Masscan](graphics/B09238_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Resuming a masscan session'
  prefs: []
  type: TYPE_NORMAL
- en: Masscan's results can then be fed into either Nmap for further processing, or
    a web scanner for more in-depth vulnerability discovery.
  prefs: []
  type: TYPE_NORMAL
- en: WhatWeb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we've identified one or more web applications in the target environment
    with masscan or Nmap, we can start digging a bit deeper. **WhatWeb** is a simple,
    yet effective, tool that can look at a particular web application and identity
    what technologies have been used to develop and run it. It has more than 1,000
    plugins, which can passively identify everything from what **content management
    system** (**CMS**) is running on the application, to what version of **Apache**
    or **NGINX** is powering the whole thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a more aggressive (`-a 3`) scan of `bittherapy.net`
    with WhatWeb. The `sed` command shown will format the output to something a bit
    easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WhatWeb](graphics/B09238_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Running WhatWeb and filtering the results'
  prefs: []
  type: TYPE_NORMAL
- en: A level-3 aggression scan will perform several more requests to help to improve
    the accuracy of results.
  prefs: []
  type: TYPE_NORMAL
- en: WhatWeb is available on Kali Linux and most other penetration testing distributions.
    It can also be downloaded from [https://github.com/urbanadventurer/WhatWeb](https://github.com/urbanadventurer/WhatWeb).
  prefs: []
  type: TYPE_NORMAL
- en: Nikto
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Nikto** provides value during the initial phases of the engagement. It is
    fairly non-intrusive and with its built-in plugins, it can provide quick insight
    into the application. It also offers some more aggressive scanning features that
    may yield success on older applications or infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the engagement does not require the attackers to be particularly stealthy,
    it doesn''t hurt to run through the noisier Nikto options as well. Nikto can guess
    subdomains, report on unusual headers, and check the `robots.txt` file for interesting
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nikto](graphics/B09238_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: A standard scan of the example.com domain'
  prefs: []
  type: TYPE_NORMAL
- en: Nikto outputs information on the HTTPS certificate, the server banner, any security-related
    HTTP headers that may be missing, and any other information that may be of interest.
    It also noticed that the server banner had changed between requests, indicating
    that a WAF may be configured to protect the application.
  prefs: []
  type: TYPE_NORMAL
- en: Nikto can be downloaded from [https://github.com/sullo/nikto](https://github.com/sullo/nikto).
    It is also available in most penetration testing-focused Linux distributions,
    such as Kali or BlackArch.
  prefs: []
  type: TYPE_NORMAL
- en: CMS scanners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the target is using a CMS, such as **Joomla**, **Drupal**, or **WordPress**,
    running an automated vulnerability testing tool should be your next step.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress is a popular CMS because it provides plugins for almost any type of site,
    making it very customizable and widely-adopted, but also complex, with a large
    attack surface. There are tons of vulnerable plugins, and users typically don't
    upgrade them frequently.
  prefs: []
  type: TYPE_NORMAL
- en: During a test, you may find a remotely exploitable vulnerability in one of the
    plugins that provides a shell, but more often than not, WordPress is a treasure
    trove of information. Usernames can be enumerated, passwords are often weak and easily
    brute-forced, or directory indexing may be enabled. The WordPress content folder
    sometimes also contains sensitive documents uploaded "temporarily" by the administrator.
    In later chapters, we will see how an improperly configured WordPress instance
    can be leveraged to attack the application server and move laterally through the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress is not alone in this space. Joomla and Drupal are also very popular
    and sport many of the same vulnerabilities and configuration issues that are seen
    in WordPress installations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few scanners available for free that aim to test for low-hanging
    fruit in these CMSs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WPScan** ([https://wpscan.org/](https://wpscan.org/)): A powerful tool aimed
    at testing WordPress installations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JoomScan** ([https://github.com/rezasp/joomscan](https://github.com/rezasp/joomscan)):
    As the name implies, a CMS scanner specializing in Joomla testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**droopescan** ([https://github.com/droope/droopescan](https://github.com/droope/droopescan)):
    A Drupal-specific scanner with some support for Joomla'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMSmap** ([https://github.com/Dionach/CMSmap](https://github.com/Dionach/CMSmap)):
    A more generic scanner and brute-forcer supporting WordPress, Joomla, and Drupal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before proceeding with a WordPress scan, make sure that it is hosted inside
    the engagement scope. Some CMS implementations will host the core site locally,
    but the plugins or content directories are on a separate **content delivery network**
    (**CDN**). These CDN hosts may be subject to a penetration testing notification
    form before they can be included in the test.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover CMS assessment tools, such as WPScan, in more detail in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient brute-forcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A brute-force attack typically involves a barrage of requests, or guesses, to
    gain access or reveal information that may be otherwise hidden. We may brute-force
    a login form on an administrative panel in order to look for commonly used passwords
    or usernames. We may also brute-force a web application's root directory looking
    for common misconfiguration and misplaced sensitive files.
  prefs: []
  type: TYPE_NORMAL
- en: Many successful engagements were made so by weak credentials or application
    misconfiguration. Brute-forcing can help to reveal information that may have been
    obscured, or can grant access to a database because the developer forgot to change
    the default credentials.
  prefs: []
  type: TYPE_NORMAL
- en: There are obvious challenges to brute-forcing. Primarily, it is time-consuming
    and can be very noisy. Brute-forcing a web service, for example, with the infamous
    `rockyou.txt` wordlist will no doubt wake up your friendly neighborhood **security
    operations center** (**SOC**) analyst and may put an end to your activities early.
    The `rockyou.txt` list has over 14 million entries and could eventually result
    in a successful credential guess, but it may be better to limit the flood of traffic
    to the target with a smaller, more efficient list.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the better collections of common keywords, credentials, directories,
    payloads, and even webshells is the **SecLists** repository: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative, or supplement, to SecLists is **FuzzDB**. It is a similar collection
    of files containing various payloads that can help with brute-forcing, and it
    can also be downloaded from the GitHub repository at [https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb).
  prefs: []
  type: TYPE_NORMAL
- en: 'Grabbing the latest copy of SecLists is easy using `git`, a popular version
    control system tool. We can pull down the repository using the `git clone` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'SecLists contains an ever-evolving database of compiled wordlists that can
    be used in discovery scans, brute-force attacks, and much more:'
  prefs: []
  type: TYPE_NORMAL
- en: '| SecList Wordlist | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Discovery` | Web content, DNS, and common Nmap ports |'
  prefs: []
  type: TYPE_TB
- en: '| `Fuzzing` | FuzzDB, Brutelogic, Polyglot payloads, and more |'
  prefs: []
  type: TYPE_TB
- en: '| `IOCs` | Malware-related indicators of compromise |'
  prefs: []
  type: TYPE_TB
- en: '| `Miscellaneous` | Various wordlists that may have obscure uses |'
  prefs: []
  type: TYPE_TB
- en: '| `Passwords` | Large numbers of wordlists for common passwords, split into
    top-N files |'
  prefs: []
  type: TYPE_TB
- en: '| `Pattern-Matching` | Wordlists for use when "grepping" for interesting information
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Payloads` | Webshells for common languages, Windows Netcat, and an EICAR
    test file |'
  prefs: []
  type: TYPE_TB
- en: '| `Usernames` | Lists of common names and login IDs |'
  prefs: []
  type: TYPE_TB
- en: The security community is a frequent contributor to SecLists, and it is good
    practice to pull the latest changes from GitHub before starting an engagement.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, target mapping has already provided a few key pieces of information
    that can help you to brute-force more efficiently. While Nikto and Nmap may not
    always find a quick and easy remote code execution vulnerability, they do return
    data that can be useful when deciding what wordlist to use for discovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful information can include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The webserver software: Apache, NGINX, or IIS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Server-side development language: ASP.NET, PHP, or Java'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Underlying operating system: Linux, Windows, or embedded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`robots.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interesting response headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WAF detection: *F5* or Akamai'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can make assumptions about the application based on the very simple information
    shown in the preceding list. For example, an IIS web server is more likely to
    have an application developed in ASP.NET as opposed to PHP. While PHP is still
    available on Windows (via XAMPP), it is not as commonly encountered in production
    environments. In contrast, while there are Active Server Pages (ASP) processors
    on Linux systems, PHP or Node.js are much more common these days. While brute-forcing
    for files, you can take this into account when attaching the extension to the
    payload: `.asp` and `.aspx` for Windows targets, and `.php` for Linux targets
    is a good start.'
  prefs: []
  type: TYPE_NORMAL
- en: The `robots.txt` file is generally interesting, as it can provide "hidden" directories
    or files, and can be a good starting point when brute-forcing for directories
    or files. The `robots.txt` file essentially provides instructions for legitimate
    crawler bots on what they're allowed to index and what they should ignore. This
    is a convenient way to implement this protocol, but it has the implication that
    this file must be readable by anonymous users, including yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample `robots.txt` file will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Google's crawlers will ignore the subdirectories, but you cannot. This is valuable
    information for the upcoming scans.
  prefs: []
  type: TYPE_NORMAL
- en: Content discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already mentioned two tools that are very useful for initial discovery
    scans: **OWASP ZAP** and **Burp Suite**. Burp''s Intruder module is throttled
    in the free version but can still be useful for quick checks. Both of these attack
    proxies are available in Kali Linux and can be easily downloaded for other distributions.
    There are other command-line alternatives, such as **Gobuster**, which can be
    used to automate the process a bit more.'
  prefs: []
  type: TYPE_NORMAL
- en: Burp Suite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned, Burp Suite comes bundled with the Intruder module, which allows
    us to easily perform content discovery. We can leverage it to look for hidden
    directories and files, and even guess credentials. It supports payload processing
    and encoding, which enables us to customize our scanning to better interface with
    the target application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Intruder module, you can leverage the same wordlists provided by SecLists
    and can even combine multiple lists into one attack. This is a powerful module
    with lots of features, including, but not limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Cluster bomb attack, which is well suited for multiple payloads, such as usernames
    and passwords, which we will showcase later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Payload processing for highly customized attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attack throttling and variable delays for low and slow attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: …and much more!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover these and others in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '![Burp Suite](graphics/B09238_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: The Burp Suite Intruder module Payloads screen'
  prefs: []
  type: TYPE_NORMAL
- en: The free version of Burp Suite is readily available in Kali Linux but, as we've
    noted in the preceding chapter, it is a bit limited. There are some restrictions
    in the Intruder module, notably the time-throttling of attack connections. For
    large payload counts, this may become a hindrance.
  prefs: []
  type: TYPE_NORMAL
- en: The professional version of Burp Suite is highly recommended for those who test
    applications regularly. Burp Suite is also valuable when reverse engineering applications
    or protocols. It is quite common for modern applications or malware to communicate
    with external servers via HTTP. Intercepting, modifying, and replaying this traffic
    can be valuable.
  prefs: []
  type: TYPE_NORMAL
- en: OWASP ZAP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The free alternative to Burp Suite is ZAP, a powerful tool in its own right,
    and it provides some of the discovery capabilities of Burp Suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ZAP equivalent for Burp''s Intruder is the **Fuzzer** module, and it has
    similar functionality, as show in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![OWASP ZAP](graphics/B09238_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: OWASP ZAP''s Fuzzer module configuration. As ZAP is open-source,
    there are no usage restrictions. If the goal is to perform a quick content discovery
    scan or credential brute-force, it may be a better alternative to the free version
    of Burp Suite.'
  prefs: []
  type: TYPE_NORMAL
- en: Gobuster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gobuster is an efficient command-line utility for content discovery. Gobuster
    does not come preinstalled on Kali Linux, but it is available on GitHub. As its
    name implies, Gobuster was written in the Go language and will require the golang
    compiler to be installed before it can be used for an attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to configure Gobuster are fairly easy on Kali Linux. We can start
    by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will globally install the Go compiler. This is required
    to build the latest version of Gobuster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to make sure that the `GOPATH` and `GOBIN` environment variables
    are set properly. We will point `GOPATH` to a `go` directory in our home path
    and set `GOBIN` to the newly defined `GOPATH` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now pull the latest version of Gobuster from GitHub using the `git clone`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then get dependencies, and compile the Gobuster application. The `go
    get` and `go build` commands will generate the Gobuster binary in the local directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the commands don''t produce output, the tool was compiled and is ready for
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Gobuster has many useful features, including attacking through a proxy (such
    as a local Burp Suite instance), outputting to a file for further processing,
    or even brute-forcing subdirectories for a target domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows Gobuster performing a discovery scan on the `http://10.0.5.181`
    using a common web content file from the SecLists repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Gobuster](graphics/B09238_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Sample Gobuster running on the 10.0.5.181 server'
  prefs: []
  type: TYPE_NORMAL
- en: A command-line URL discovery tool may prove useful on systems where we cannot
    run a full-blown **graphical user interface** (**GUI**) application, such as Burp
    or ZAP.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent content discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The results of a particular scan can reveal interesting directories, but they're
    not always accessible, and directory indexing is increasingly rare in applications.
    Thankfully, by using content discovery scans we can look into directories for
    other misconfigured sensitive information. Consider a scenario where the application
    hosted on `http://10.0.5.181/` contains a particular directory that may be password
    protected. A common misconfiguration in applications is to protect the parent
    directory but incorrectly assume all subdirectories are also protected. This leads
    developers to drop more sensitive directories in the parent and leave them be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier inspection of the `robots.txt` file revealed a few interesting directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `admin` directory catches the eye, but attempting to access `/~admin/`
    returns an HTTP `403` Forbidden error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Persistent content discovery](graphics/B09238_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Access to the directory is forbidden'
  prefs: []
  type: TYPE_NORMAL
- en: This may be discouraging, but we can't stop here. The target directory is too
    attractive to give up now. Using OWASP ZAP, we can start a new Fuzzer activity
    on this directory and see if we can find anything of interest that is not protected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that the cursor is placed at the end of the URL in the left-most
    pane. Click the **Add** button next to **Fuzz Locations** in the right-most pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Persistent content discovery](graphics/B09238_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Fuzzer configuration, adding Fuzz Locations'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, we can add a new payload to feed the **Fuzzer**. We will
    select the `raft-small-files.txt` wordlist from the SecLists repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Persistent content discovery](graphics/B09238_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Fuzzer configuration – the Add Payload screen'
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to treat the `/~admin` URI as a directory and look for files within,
    we will have to use a string processor for the selected payload. This will be
    a simple **Prefix String** processor, which will prepend a forward-slash to each
    entry in our list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Persistent content discovery](graphics/B09238_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Fuzzer configuration – the Add Processor screen'
  prefs: []
  type: TYPE_NORMAL
- en: The Fuzzer task may take a while to complete, and it will produce lots of `403`
    or `404` errors. In this case, we were able to locate a somewhat hidden administration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Persistent content discovery](graphics/B09238_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: The completed Fuzzer scan shows an accessible hidden file'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP `200` response indicates that we have access to this file, even though
    the parent directory `/~admin/` was inaccessible. It appears we have access to
    the `admin.html` file contained within the enticing `admin` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Application security is hard to implement correctly, and it is even harder to
    maintain that initial security baseline as the application ages and evolves, and
    staff rotate. Access is granted and not removed; files are added with broken permissions;
    and underlying operating systems and frameworks become outdated, and remotely
    exploitable.
  prefs: []
  type: TYPE_NORMAL
- en: When running initial content discovery scans, it is important to remember not
    to stop at the first error message we see. Access control deficiencies are very
    common, and we could uncover various unprotected subdirectories or files if we
    are persistent.
  prefs: []
  type: TYPE_NORMAL
- en: Payload processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Burp Suite's Intruder module is a powerful ally to an attacker when targeting
    web applications. Earlier discovery scans have identified the secretive, but enticing,
    `/~admin/` directory. A subsequent scan of the directory itself uncovered an unprotected
    `admin.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed, we will switch to the Burp Suite attack proxy and configure
    the **Target Scope** to the `vuln.app.local` domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: The Burp Suite Target Scope configuration screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Target Scope** allows us to define hosts, ports, or URLs that are to
    be included in the scope of the attack. This helps to filter out traffic that
    may not be related to our target. With Burp Suite configured as our attack proxy,
    we can visit the hidden `admin.html` URL and record the traffic in our proxy''s
    history:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.14: Accessing the hidden file through the browser succeeds'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the **Server Connectivity Test** link, we are greeted with a basic
    authentication realm **Admin Tools**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.15: Authentication popup when attempting to follow the link'
  prefs: []
  type: TYPE_NORMAL
- en: Our pentester reflexes kick in and we automatically type in the unfortunately
    common `admin/admin` credentials, but with no luck this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all of the interactions with the target are being recorded by the Burp
    proxy, we can simply pass the failed request on to the Intruder module, as shown
    in the following figure. Intruder will let us attack the basic authentication
    mechanism with little effort:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.16: The HTTP history screen'
  prefs: []
  type: TYPE_NORMAL
- en: In the Intruder module, the defaults are good for the most part—we just have
    to select the Base64-encoded credentials portion of the `Authorization` header
    and click the **Add** button on the right-hand side. This will identify this position
    in the HTTP request as the payload location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows the payload position selected in the `Authorization` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.17: Specifying a payload position in the Authorization header'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Payloads** tab, we will select the **Custom iterator** payload type
    from the dropdown, as seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.18: Configuring the Payload type'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Authorization` header contains the Base64-encoded plaintext values of
    the colon-separated username and password. To brute-force the application effectively,
    the payload will have to be in the same format. We will need to submit a payload
    that follows the same format that the `Authorization` header expects. For each
    brute-force request that the attack proxy will make, the payload will have to
    be the username and password separated by a colon, and wrapped by Base64 encoding:
    `base64([user_payload]:[password_payload])`.'
  prefs: []
  type: TYPE_NORMAL
- en: We can grab the already captured value in the `Authorization` header and pass
    it to Burp Suite's Decoder module. Decoder allows us to quickly process strings
    to and from various encoding schemes, such as Base64, URL encoding, GZip, and
    others.
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows how we can leverage Decoder to convert the value `YWRtaW46YWRtaW4=`
    from Base64 using the **Decode as...** dropdown. The result is listed in the bottom
    pane as `admin:admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.19: The Burp Decoder screen'
  prefs: []
  type: TYPE_NORMAL
- en: Back in the Intruder module, for payload position 1, we will once again use
    a small wordlist from the SecLists `Usernames` collection called `top-usernames-shortlist.txt`.
    Our goal is to find low-hanging fruit, while minimizing the flood of requests
    that will hit the application. Using a short list of common high-value usernames
    is a good first step.
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows that the list was loaded in payload position 1 using the
    **Load...** button in the **Payload Options**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.20: Payload position 1 configuration screen'
  prefs: []
  type: TYPE_NORMAL
- en: The separator for position 1 should be colon (`:`). For payload position 2,
    you can use the `500-worst-passwords.txt` list from the SecLists passwords directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows payload position 2 containing the loaded `500-worst-passwords.txt`
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.21: Payload position 2 configuration screen'
  prefs: []
  type: TYPE_NORMAL
- en: The separator for position 2 should be left blank.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, each request sent to the application will contain an `Authorization`
    header in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To complete the payload, we also have to instruct Intruder to Base64-encode
    the payload before sending it over the wire. We can use a payload processor to
    force Base64 encoding for every request.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Payloads** tab, under **Payload Processing**, click **Add** and select
    the **Base64-encode** processor from the **Encode** category. We will also disable
    automatic URL encoding, as it may break the `Authorization` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following URL shows the enabled **Base64-encode** processor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.22: Payload processing rule – Base64-encode'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the payload has been configured, we can begin the brute-force using the
    **Start Attack** button in the top-right corner of the **Intruder** module, as
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.23: Starting the attack'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the content discovery scan, this credential brute-force will generate
    a fair amount of HTTP `401` errors. If we''re lucky, at least one will be successful,
    as seen in the figure that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.24: Attack results screen'
  prefs: []
  type: TYPE_NORMAL
- en: Now, because every request in the Intruder attack is recorded, we can inspect
    each one or sort all of them by column to better illustrate the results of the
    attack. In the preceding example, we can clearly see that the successful authentication
    request returned an HTTP status code of `200`, while the majority of the other
    requests returned an expected `401`. The status code is not the only way to determine
    success at a quick glance, however. A deviation in the content length of the response
    may be a good indicator that we are on the right track.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a payload that has successfully gained access to the Admin
    Tools authentication realm, we can run it through the Decoder module to see the
    plaintext credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows the Decoder module revealing the guessed credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.25: Burp Suite Decoder'
  prefs: []
  type: TYPE_NORMAL
- en: Credential brute-forcing is just one of the many uses for Intruder. You can
    get creative with custom payloads and payload processing.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a scenario where the `vuln.app.local` application generates PDF files
    with sensitive information and stores them in an unprotected directory called
    `/pdf/`. The filenames appear to be the MD5 digest of the date the file was generated,
    but the application will not generate a PDF file every day. You could try and
    guess each day manually, but that's not ideal. You can even spend some time whipping
    up a Python script that can automate this task. The better alternative is to leverage
    Burp Suite to do this easily with a few clicks. This has the added benefit of
    recording the attack responses in one window for easy inspection.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we can send a previously recorded request to the target `/pdf/`
    folder directly to the Intruder module.
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows that the PDF''s name, minus the extension, is identified
    as the payload position using the **Add** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.26: Intruder Payload Positions configuration screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the **Dates** payload type options available in
    Intruder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.27: Intruder''s Payloads screen'
  prefs: []
  type: TYPE_NORMAL
- en: In this attack, you will use the **Dates** payload type with the proper date
    format, going back a couple of years. The payload processor will be the MD5 hash
    generator, which will generate a hash of each date and return the equivalent string. This
    is similar to our **Base64-encode** processor from the previous attack.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the payload options have been configured and we can start the attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows a few requests with the `200` HTTP status code and
    a large length indicating a PDF file is available for download:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Payload processing](graphics/B09238_02_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.28: Intruder attack Results screen'
  prefs: []
  type: TYPE_NORMAL
- en: Intruder will generate the payload list based on our specified date format and
    calculate the hash of the string, before sending it to the application, all with
    a few clicks. In no time, we have discovered at least three improperly protected,
    potentially sensitive documents that are available anonymously.
  prefs: []
  type: TYPE_NORMAL
- en: Polyglot payloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A polyglot payload is defined as a piece of code that can be executed in multiple
    contexts in the application. These types of payloads are popular with attackers
    because they can quickly test an application's input controls for any weaknesses,
    with minimal noise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a complex application, user input can travel through many checkpoints—from
    the URL through a filter, into a database, and back out to a decoder, before being
    displayed to the user, as illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polyglot payloads](graphics/B09238_02_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.29: Typical data flow from user to application'
  prefs: []
  type: TYPE_NORMAL
- en: Any one of the steps along the way can alter or block the payload, which may
    make it more difficult to confirm the existence of a vulnerability in the application.
    A polyglot payload will attempt to exploit an injection vulnerability by combining
    multiple methods for executing code in the same stream. This attempts to exploit
    weaknesses in the application payload filtering, increasing the chance that at
    least one portion of the code will be missed and will execute successfully. This
    is made possible by the fact that JavaScript is a very forgiving language. Browsers
    have always been an easy barrier of entry for developers, and JavaScript is rooted
    in a similar philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OWASP **cross-site scripting** (**XSS**) Filter Evasion Cheat Sheet contains
    examples of polyglot payloads, which can also evade some application filters:
    [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example of a strong polyglot payload can be found on GitHub from researcher
    Ahmed Elsobky:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, this appears rather messy, but every character has a purpose.
    This payload was designed to execute JavaScript in a variety of contexts, whether
    the code is reflected inside an HTML tag or right in the middle of another piece
    of JavaScript. The browser's HTML and JavaScript parsers are extremely accommodating.
    They are case-insensitive, error-friendly, and they don't care much about indenting,
    line endings, or spacing. Escaped or encoded characters are sometimes converted
    back to their original form and injected into the page. JavaScript in particular
    does its very best to execute whatever code is passed to it. A good polyglot payload
    will take advantage of all of this, and seek to evade some filtering as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing a sharp eye will notice is that most of the keywords, such
    as `textarea`, `javascript`, and `onload,` are randomly capitalized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This may seem like a futile attempt to evade application firewall input filters,
    but you''d be surprised how many are poorly designed. Consider the following **regular
    expression** (**regex**) input filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A regex is a piece of text defining a search pattern. Some WAFs may use regex
    to try and find potentially dangerous strings inside HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will effectively prevent JavaScript code from being injected via the `onclick`
    event, but with one glaring flaw: it doesn''t take into account case-sensitivity.
    Regular expressions have many modifiers, such as the `g` in the preceding example,
    and by default most engines require the `i` modifier to ignore case, or else they
    will not match and the filter is vulnerable to bypass.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows Regex101''s visualization of the preceding regex
    applied to a sample test string. We can see that only two of the four payloads
    tested matched the expression, while all four would execute JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Polyglot payloads](graphics/B09238_02_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.30: Regex filter visualization'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When assessing an application's regex-based input filter, Regex101 is a great
    place to test it against several payloads at once. Regex101 is an online tool
    available for free at [https://regex101.com](https://regex101.com).
  prefs: []
  type: TYPE_NORMAL
- en: Many times, developers work under unrealistic time constraints. When a penetration
    testing report highlights a particular input sanitization issue, developers are
    pressured to turn in a security fix that was quickly written, insufficiently tested,
    and remediates only part of the problem. It is often too time-consuming and expensive
    to implement a potentially application-breaking framework to handle input filtering,
    and shortcuts are taken at security's expense.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Elsobky payload also aims to exploit being passed through an engine that
    processes hex-encoded values escaped with a backslash. JavaScript and Python,
    for example, will process two alphanumeric characters preceded by `\x` as one
    byte. This could bypass certain in-line XSS filters that perform primitive string
    compare checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It is possible that the payload may be stripped of most of the other keywords,
    but when the filter reaches `\x3c` and `\x3e`, it interprets them as benign strings
    of four characters. The application may parse the string and inadvertently return
    the one-byte equivalent of the escaped hexadecimal characters `<` and `>` respectively.
    The result is an `<svg>` HTML element that executes arbitrary JavaScript via the
    `onload` event.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Scalable Vector Graphics** (**SVG**) is an element on a page that can be
    used to draw complex graphics on the screen without binary data. SVG is used in
    XSS attacks mainly because it provides an `onload` property, which will execute
    arbitrary JavaScript code when the element is rendered by the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More examples of the power of this particular polyglot are on Elsobky''s GitHub
    page: [https://github.com/0xSobky](https://github.com/0xSobky).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A powerful polyglot payload is able to execute some code in a variety of injection
    scenarios. The Elsobky payload can also be useful when reflected in the server
    HTTP response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The URL encoded characters `%0d` and `%0a` represent newline and carriage return.
    These characters are largely ignored by HTML and JavaScript parsers, but they
    are significant in the HTTP request or response header.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the target application fails to filter user input properly, in some cases
    it may take the arbitrary value and add it as part of the HTTP response. For example,
    in an attempt to set a "Remember me" cookie, the application reflects the payload
    unfiltered in the HTTP response headers, which results in XSS in the user''s browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass in the polyglot as the username to remember, the HTTP response headers
    are altered and the body will contain attacker-controlled data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The server responds with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The response is a bit mangled, but we do have code execution. The URL encoded carriage
    return characters `%0D%0A%0d%0a` are interpreted as part of the HTTP response.
    In the HTTP protocol, two sets of carriage returns and line feeds indicate the
    end of the header, and anything that follows this will be rendered by the browser
    as part of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Same payload, different context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many other contexts in which this polyglot can successfully execute
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the polyglot payload is reflected inside the `value` property of the username
    input, the browser''s interpretation of the code clearly shows a broken input
    field and a malicious `<svg>` element. The HTML code before the payload is processed
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This figure shows how the browser views the HTML code after the payload has
    been processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Same payload, different context](graphics/B09238_02_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.31: Reflected XSS payload'
  prefs: []
  type: TYPE_NORMAL
- en: The polyglot will also execute code if reflected inside an HTML comment, such
    as `<!-- Comment! [payload] -->`.
  prefs: []
  type: TYPE_NORMAL
- en: The payload contains the end of comment indicator `-->`, which leaves the rest
    of the text to be interpreted by the browser as HTML code. Once again, the `<svg>`
    element's `onload` property will execute our arbitrary code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows how the browser views the HTML code after the payload has
    been processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Same payload, different context](graphics/B09238_02_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.32: Reflected XSS payload'
  prefs: []
  type: TYPE_NORMAL
- en: Our polyglot is also useful if reflected inside some code setting up a regex
    object, such as `var expression = /[payload]/gi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this behavior inside the browser console with the preceding sample
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Same payload, different context](graphics/B09238_02_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.33: Polyglot visualization'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that strategically placed comment indicators, such as `/*`, `*/`,
    and `//`, will cause the browser to ignore the majority of the payload, resulting
    in valid JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s subtle, but the code execution happens here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The multi-line comments are ignored, and JavaScript will execute anything between
    the parenthesis. In this context, `oNcliCk` does not represent a mouse event binder,
    but instead it is used to store the return of the `alert()` function, which results
    in arbitrary code execution.
  prefs: []
  type: TYPE_NORMAL
- en: Code obfuscation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not all application firewalls strip input of malicious strings and let the rest
    go through. Some inline solutions will drop the connection outright, usually in
    the form of a `403` or `500` HTTP response. In such cases, it may be difficult
    to determine which part of the payload is considered safe and which triggered
    the block.
  prefs: []
  type: TYPE_NORMAL
- en: By design, inline firewalls have to be fairly fast and they cannot introduce
    significant delay when processing incoming data. The result is usually simple
    logic when attempting to detect **SQL injection** (**SQLi**) or XSS attacks. Random
    capitalization may not fool these filters, but you can safely assume that they
    do not render on the fly every requested HTML page, let alone execute JavaScript
    to look for malicious behavior. More often than not, inline application firewalls
    will look for certain keywords and label the input as potentially malicious. For
    example, `alert()` may trigger the block, while `alert` by itself would produce
    too many false-positives.
  prefs: []
  type: TYPE_NORMAL
- en: To increase the chances of success and lower the noise, we can change the way
    the `alert()` function is called in seemingly unlimited ways — all thanks to JavaScript.
    We can test this in the browser console by inspecting the native `alert()` function.
    The `window` object will hold a reference to it and we can confirm this by calling
    the function without parentheses. The console will indicate that this is a built-in
    function with `[native code]` displayed as its body. This means that this is not
    a custom user-defined function and it is defined by the browser core.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, we have multiple ways of accessing properties of an object, including
    function references such as `alert`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows how we can access the same function directly or using array
    notation, with an `"alert"` string inside square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code obfuscation](graphics/B09238_02_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.34: Different ways to access the alert() function'
  prefs: []
  type: TYPE_NORMAL
- en: To bypass rudimentary filters, which may drop suspicious strings, such as `alert`(`1`),
    we can leverage some simple encoding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using JavaScript''s `parseInt` function, we can get the integer representation
    of any string, using a custom base. In this case, we can get the base 30 representation
    of the `"alert"` string. To convert the resulting integer back to its string equivalent,
    we can leverage the built-in `toString()` method while passing the integer base
    as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code obfuscation](graphics/B09238_02_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.35: The "alert" string encoding and decoding'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know `8680439..toString(30)` is the equivalent of string `"alert"`,
    we can use the `window` object and array notation to access the native code for
    the `alert()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure shows how we can call the `alert()` function using the obfuscated
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code obfuscation](graphics/B09238_02_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.36: Executing alert() with an encoded string'
  prefs: []
  type: TYPE_NORMAL
- en: We can follow the same process to obfuscate a call to the `console.log()` function.
    Much like most available native functions, `console` is accessible through the
    `window` object as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows how we can encode the strings `console` and `log`,
    and utilize the same array notation to access properties and subproperties until
    we reach the native code for `console.log()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code obfuscation](graphics/B09238_02_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.37: Encoding the entire console.log command'
  prefs: []
  type: TYPE_NORMAL
- en: For the traditional strongly-typed language developer, this convention looks
    alien. As we've already seen, JavaScript engines are very forgiving and enable
    a variety of ways to execute code. In the preceding examples, we are decoding
    the base 30 integer representation of our function and passing it as a key to
    the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'After some modification, the Elsobky payload could be made a bit more stealthy
    with obfuscation. It could look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `top` keyword is a synonym for window and can be used to reference anything
    you need from the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: With just a minor change, the polyglot payload is still effective and is now
    more likely to bypass rudimentary inline filters that may attempt to filter or
    block the discovery attempts.
  prefs: []
  type: TYPE_NORMAL
- en: Brutelogic offers a great list of XSS payloads with many other ways to execute
    code unconventionally at `https` `://brutelogic.com.br/blog/cheat-sheet/`.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consult the following resources for more information on penetration testing
    tools and techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Metasploit**: [https://www.metasploit.com/](https://www.metasploit.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WPScan**: [https://wpscan.org/](https://wpscan.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CMSmap**: [https://github.com/Dionach/CMSmap](https://github.com/Dionach/CMSmap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recon-NG** (**available in Kali Linux or via the Bitbucket repository**):
    [https://bitbucket.org/LaNMaSteR53/recon-ng](https://bitbucket.org/LaNMaSteR53/recon-ng)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OWASP XSS Filter Evasion Cheat Sheet**: [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elsobky''s GitHub page**: [https://github.com/0xSobky](https://github.com/0xSobky)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Brutelogic cheat sheet**: [https://brutelogic.com.br/blog/cheat-sheet/](https://brutelogic.com.br/blog/cheat-sheet/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SecLists repository**: [https://github.com/danielmiessler/SecLists](https://github.com/danielmiessler/SecLists)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FuzzDB**: [https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Complete the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a copy of the SecLists and FuzzDB repositories in your tools folder and
    study the available wordlists
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and compile Gobuster
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at improving your efficiency for gathering information
    on a target, and covered several ways to do this. If stealth is paramount during
    an engagement, efficient content discovery can also reduce the chance that the
    blue team will notice the attack.
  prefs: []
  type: TYPE_NORMAL
- en: Time-tested tools, such as Nmap and Nikto, can give us a head start, while WPScan
    and CMSmap can hammer away at complex CMS that are frequently misconfigured and
    seldom updated. For larger networks, masscan can quickly identify interesting
    ports, such as those related to web applications, allowing for more specialized
    tools, such as WhatWeb and WPScan, to do their job faster.
  prefs: []
  type: TYPE_NORMAL
- en: Web content and vulnerability discovery scans with Burp or ZAP can be improved
    with proper wordlists from repositories, such as SecLists and FuzzDB. These collections
    of known and interesting URLs, usernames, passwords, and fuzzing payloads can
    greatly improve scan success and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how we can leverage low-hanging fruit to
    compromise web applications.
  prefs: []
  type: TYPE_NORMAL
