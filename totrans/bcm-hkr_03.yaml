- en: Chapter 3. Low-Hanging Fruit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often the case that clients will approach security professionals with
    a request to perform an application penetration test. In many engagements, there
    is not a lot of information given to the tester, if any at all, prompting a black-box
    approach to testing. This can make testing more difficult, especially when open-source
    intelligence isn't of much help or the interface is not intuitive, or user friendly,
    which is sometimes the case with an API.
  prefs: []
  type: TYPE_NORMAL
- en: In the scenario presented in this chapter, we are faced with this exact problem,
    which is commonly encountered in the wild. Instead of deep diving into the inner
    workings of the API and attempting to reverse engineer its functionality without
    much prior knowledge, we can start by looking for low-hanging fruit. We hope that
    if we take the road less travelled by the security team, we can eventually reach
    the open back window and bypass the four-foot thick steel door protecting the
    entrance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Assessing the application server's security posture for alternate routes to compromise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute-force attacks on services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging vulnerabilities in adjacent services to compromise the target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network assessment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen in previous chapters that Metasploit's workspace feature can be very
    useful. In the following engagement, we will make use of it as well. First, we
    have to launch the console from the terminal using the `msfconsole` command. Once
    Metasploit has finished loading, it will drop us into the familiar `msf >` prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As with all engagements involving Metasploit, we start by creating a workspace
    specifically for the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For this scenario, our target is a black-box API application provided by E Corp.
    The target host will be `api.ecorp.local`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we hammer away at the web interface and try to exploit some obscure vulnerability,
    let's take a step back and see what other services are exposed on the API's server.
    The hope here is that while the API itself may have been closely scrutinized by
    developers, who may have taken security seriously during the development life
    cycle, mistakes may have been made when deploying the server itself. There are
    many aspects of system hardening that simply cannot be controlled within the source
    code repository. This is especially true when the server housing the target application
    is a shared resource. This increases the likelihood that the system security policy
    will loosen up over time as different teams with different requirements interact
    with it. There could be some development instance with less stringent controls
    running on a non-standard port, or a forgotten and vulnerable application that
    can give us (as an attacker) the required access, and we can easily compromise
    the target.
  prefs: []
  type: TYPE_NORMAL
- en: As always, Nmap is our network recon tool of choice and coupled with Metasploit's
    workspace, it becomes even more powerful. The Metasploit console wrapper command
    for Nmap is the `db_nmap` command. The Nmap switches that we will use for discovering
    open ports, and querying services for more information, are detailed in the following
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-sV` will instruct Nmap to perform a version scan of any identified services,
    and the `-A` will provide us with some host fingerprinting, attempting to detect
    the operating system. The `-T4` option is used to tell Nmap to be more aggressive
    when scanning the network. This improves scanning speed at the risk of being detected
    by intrusion detection systems. A lower number, such as `-T1`, will make scanning
    a bit more paranoid, and while it may take longer to complete, it could let us
    fly under the radar for a bit longer. The `-Pn` switch will prevent Nmap from
    performing a ping of the target. Pinging our target is not really required unless
    we scan a wide range of addresses and we''re only looking for hosts that are online.
    Finally, `-p1-` (lowercase) is a short form for `-p1-65535`, instructing Nmap
    to scan all possible ports on the target. The unnamed parameter is our target,
    `api.ecorp.local`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''ve wrapped the Nmap scan using the Metasploit `db_nmap` command,
    the results are automatically parsed and written to our workspace''s database.
    Once the scan is complete, we can review the entries in the database by issuing
    the `services` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It appears that the MySQL instance is reachable, so gaining access to this would
    be very valuable. Nmap detected this as a **MariaDB** service, which is the community-developed
    fork for the MySQL software. If we're very lucky, this instance is outdated, with
    some easily exploitable vulnerability that will give us instant access. To figure
    this out, we can use the database software version number and run it by a list
    of public **Common Vulnerabilities and Exposures** (**CVEs**), and hopefully find
    some exploitable code in the wild for our service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of going at the application head on, over port `80`, we hope to attack
    it via the exposed MySQL (MariaDB) services, as this attack path figure shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network assessment](graphics/B09238_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: An alternate path to compromise'
  prefs: []
  type: TYPE_NORMAL
- en: Looking for a way in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the Nmap scan did not return a specific version, we can quickly issue
    a detailed version probe for the MySQL service, using a couple of Metasploit commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load the aptly named `mysql_version` auxiliary scanner module. The
    `use` command, followed by the path to the module `auxiliary/scanner/mysql/mysql_version`,
    will load the module in the current session. We can view more information on the
    `mysql_version` module by issuing the `show info` command, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking for a way in](graphics/B09238_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: mysql_version module information'
  prefs: []
  type: TYPE_NORMAL
- en: The `Basic options:` will list the variables we will need to update in order
    for the module to execute properly. The `RHOSTS`, `RPORT`, and `THREADS` parameters
    are required for this particular scanner. `RHOSTS`, or remote hosts, and `RPORT`,
    or remote port, should be self-explanatory. The `THREADS` option can be increased
    to a higher number to increase scan speed, but since we are only targeting one
    remote host, `api.ecorp.local`, we don't need more than one scanning thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the module loaded, we can set the required `RHOSTS` variable to the appropriate
    target. Since the target was already scanned by `db_nmap`, and the results are
    in the `ecorp` workspace, we can use the `services` command to set the `RHOSTS`
    variable automatically to all MySQL servers found, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `services` command accepts a few switches to better filter and action the
    results. The `-R` option in the services command set the current module's `RHOSTS`
    variable to the values returned by the query. In this scenario, you could have
    just as easily typed in the host manually, but with broader sweeps, this particular
    switch will be very handy.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to query the services in the workspace. For example, in
    the preceding command-line input, we used the `-s` option, which filters all hosts
    running MySQL as an identified service.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we know that we will be attacking the same host with other Metasploit modules,
    it''s a good idea to set the global `RHOSTS` variable to the same value. This
    will ensure that the `RHOSTS` value is automatically populated when switching
    modules. We can accomplish this by using the `setg` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left to do now is to run the `mysql_version` module and hopefully
    get back some useful information, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking for a way in](graphics/B09238_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: mysql_version running on the target RHOSTS'
  prefs: []
  type: TYPE_NORMAL
- en: It appears that the module was able to identify the MySQL server version successfully.
    This will prove useful when looking for known vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we issue another `services` query, you will notice that the info field for
    the `mysql` service has changed to the results of the `mysql_version` scan, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Where our Nmap scan fell short in identifying the version number, Metasploit
    succeeded and automatically changed the database to reflect this. After reviewing
    the public CVEs for MySQL, however, it doesn't appear that this instance has any
    unauthenticated vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the Kali Linux terminal, we can use the `mysql` client command to attempt
    to authenticate as `root` (`-u`) to the `api.ecorp.local` host (`-h`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note the lack of space between the `-u` and `-h` switches and their respective
    values. A quick check for an empty `root` password fails, but it proves that the
    MySQL server is accepting connections from remote addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Credential guessing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we were unable to uncover a working remote exploit for the MySQL instance,
    the next step is to attempt a credentialed brute-force attack against the default
    MySQL `root` user. We will use one of our curated commonly used password dictionaries
    and hope this instance was not properly secured during deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Metasploit''s help, we can start a MySQL login password guessing attack
    fairly easily. We will use the `mysql_login` auxiliary scanner module, as seen
    in the following screenshot. This module has some additional available options
    for tuning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Credential guessing](graphics/B09238_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: The mysql_login auxiliary scanner module'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing, we will set the following values to make the scan a bit
    more efficient and reduce some noise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Increasing the `THREADS` count will help you to get through the scan more quickly,
    although it can be more noticeable. More threads means more connections to the
    service. If this particular host is not very resilient, we may crash it, thereby
    alerting the defenders. If our goal is to be quieter, we can use only one thread
    but the scan will take much longer. The `VERBOSE` variable should be set to `false`,
    as you will be testing lots of passwords and the console output can get messy.
    An added bonus to non-verbose output is that it improves the scan time significantly,
    since Metasploit does not have to output something to the screen after every attempt.
    Finally, with `STOP_ON_SUCCESS` set to `true`, we will stop the attack if we have
    a successful login.
  prefs: []
  type: TYPE_NORMAL
- en: 'The target `USERNAME` will be `root`, as it is common for MySQL installations
    have this user enabled by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For the wordlist, `PASS_FILE` will be set to the `SecLists` `10-million-password-list-top-500.txt`
    collection as follows. This is 500 of the most popular passwords from a larger
    10 million password list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a good place to start. There are other top variations of the 10 million
    password list file, and if this one fails to produce a valid login, we can try
    the top 1,000, 10,000, or other wordlists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like every other module in Metasploit, the `run` command will begin execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few minutes, we receive some good news:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It appears that we have found a valid login for the MySQL instance running on
    the same machine as our target application. This may or may not be the database
    in use by the API itself. We will take a closer look and see if we can find a
    way to spawn a shell, and fully compromise the E Corp API server, and by extension
    our target as well.
  prefs: []
  type: TYPE_NORMAL
- en: We can connect directly from our Kali Linux instance using the `mysql` command
    once more. The `-u` switch will specify the username and the `-p` switch will
    let us pass the newly discovered password. There's no space between the switches
    and their values. If we omit a value for `-p`, the client will prompt us for a
    password.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a successful connection to the database service
    and the listing of the available databases using the `show databases;` SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Credential guessing](graphics/B09238_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: Successfully authenticated connection to the target database'
  prefs: []
  type: TYPE_NORMAL
- en: Once connected, we've queried for the available databases, but there doesn't
    appear to be anything related to the API on this server. It's possible that the
    API is configured to use a different SQL database, and we've stumbled upon a development
    instance without much interesting data.
  prefs: []
  type: TYPE_NORMAL
- en: Given that we are the database administrator, `root`, we should be able to do
    lots of interesting things, including writing arbitrary data to the disk. If we
    can do this, it means that we can potentially achieve remote code execution.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a Metasploit module (surprise, surprise) that can deliver executables
    and initiate a reverse shell using known credentials. For Windows machines, `exploit/windows/mysql/mysql_payload`
    can upload a Meterpreter shell and execute it, although there are some drawbacks.
    A standard Metasploit payload will likely be picked up by **antivirus** (**AV**)
    software and alert the defenders to your activities. Bypassing AVs is possible
    with a **fully undetectable** (**FUD**) Metasploit payload, but for the scenario
    in this chapter, we will go with a simpler, less risky option.
  prefs: []
  type: TYPE_NORMAL
- en: While MySQL is able to write files to disk using SQL query statements, it is
    actually a bit more complicated to execute binaries. We can't easily write binary
    data to disk, but we can write application source code. The simplest way to achieve
    code execution is to write some PHP code inside the application directory that
    will let us execute shell commands through the application URL. With PHP's help,
    the web shell will accept commands through an HTTP `GET` request and pass them
    to the system shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s find out where we are on the disk, so that we can write the payload
    to the appropriate web application directory. The `SHOW VARIABLES` SQL query lets
    us see configuration data and the `WHERE` clause limits the output to directory
    information only, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks like a XAMPP installation and based on open-source documentation,
    the main website code should be located in `c:\xampp\htdocs\`. You can confirm
    this by a quick `curl` test. A typical XAMPP installation comes with a subdirectory
    in the `htdocs` folder called `xampp`. Among other things, it houses a `.version`
    file, which contains what you would expect, the XAMPP version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Back to the MySQL command-line interface, and we can try to write to that directory
    using MySQL's `SELECT INTO OUTFILE` query. If we can put a PHP file somewhere
    inside `htdocs`, we should be able to call it from a web browser or `curl`, and
    we will have code execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SELECT` statement template we will use for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s plug in some test values and see if we can write to the target directory,
    and more importantly, if the application web server will process our PHP code
    correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ECorpAppTest11251` flag is added as a comment, in case we are unable to
    clean up this shell after the test is complete, and have to report it to the client's
    blue team. It can also help the blue team to identify files that may have been
    missed as part of the incident response exercise. This is not always required,
    but it is good practice, especially with high-risk artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is good: the query was successful. We can check to see if the PHP interpreter
    works in this directory, and if the file is successfully executed, by calling
    it from the browser, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Credential guessing](graphics/B09238_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: The PHP code executing successfully'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we need to get shell access to the server, so that we can execute
    arbitrary commands and not just output PHP configuration data. Modifying the previous
    `SELECT INTO OUTFILE` payload will produce a rudimentary PHP shell. PHP has a
    built-in function that conveniently executes arbitrary shell commands. This is
    true for all server-side web programming languages: Python, Perl, ASP, Ruby, and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: If we pass data from the `GET` request into the PHP built-in `system()` function,
    we can execute arbitrary commands on the server itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows our web shell source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Credential guessing](graphics/B09238_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: Web shell source code'
  prefs: []
  type: TYPE_NORMAL
- en: The code is fairly straightforward. The `if` statement will check the MD5 hash
    value of the incoming `password` parameter matches `4fe7aa8a3013d07e292e5218c3db4944`.
    If there's a match, the command string in the `cmd` `GET` parameter will be passed
    to the PHP `system()` function, which will execute it as a system command, giving
    us shell access.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MD5 value we''re looking for is the hash value of `ECorpAppTest11251`,
    as confirmed by the `md5sum` Linux command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To easily write the shell code to the disk using MySQL''s `SELECT INTO OUTFILE`
    statement, we can compress it down to one line. Thankfully, PHP is not very concerned
    with carriage returns, as long as the code is properly segregated by semicolons
    and curly braces. We can compress our web shell into the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we plug it into our `SELECT INTO OUTFILE` template, we should be able to
    write it to disk in the `xampp` subdirectory, which is accessible from the web:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the shell in action by executing the `tasklist` system command and
    passing the `ECorpAppTest11251` value as the password, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Credential guessing](graphics/B09238_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: A process listing on the application server'
  prefs: []
  type: TYPE_NORMAL
- en: That was easy. We now have arbitrary code execution on the application server.
    We can retrieve the target source code, find the database, dump passwords, backdoor
    the application, and much, much more.
  prefs: []
  type: TYPE_NORMAL
- en: A better way to shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have achieved the goal of executing code on the server and have effectively
    compromised the application (and more!), you may have an incentive to dig a bit
    deeper. Moreover, the web shell created so far is fairly dumb and it is difficult
    to execute commands in succession. If this test lasts for several days, or even
    weeks, it could be a burden. It is a bit clunky and difficult to work with as
    well. You may need to transfer files, upgrade to an interactive shell, navigate
    the filesystem, and so forth. For this and for many other reasons, you should
    upgrade to a more functional feature-full shell. This is where **Weevely** comes
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Weevely is a weaponized web shell installed on Kali Linux by default. It is
    very easy to use. It generates an obfuscated, password-protected PHP shell that
    can replace our earlier `system()` shell example. Weevely features some useful
    functionality that goes above and beyond the traditional system pass-through shell,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A familiar terminal interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network pivots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File upload and download
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse and direct TCP shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meterpreter support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we need to generate a new shell by issuing the `weevely generate` command.
    The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Weevely will generate a password-protected, obfuscated PHP web shell in the
    specified path on our Kali machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To serve up the newly-generated web shell quickly, we can spawn a temporary
    web server on our Kali Linux instance using a one-line command. Python comes bundled
    with a `SimpleHTTPServer` module that can be called from the terminal to serve
    files over HTTP. There's no need to mess around with the Apache or NGINX settings.
    By default, the `SimpleHTTPServer` module serves the current directory contents
    to the web.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same directory as the Weevely-generated file `shell.php` (`/var/www/html`),
    we can execute python with the `-m` switch to load the `SimpleHTTPServer` module.
    The last parameter is the port on which the web server will listen, in this case
    port `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The hard part is over. Now we just have to get `shell.php` onto the target server
    using the existing shell `xampp.php`. There are a couple of ways to do this. On
    Linux servers, `wget` is almost always available and simple to use. For Windows,
    you can leverage either the built-in `bitsadmin.exe` or a sexier `powershell.exe`
    one-liner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can leverage `curl` and the following template to execute PowerShell commands
    on the remote host and effectively download a more advanced Weevely shell. You
    just have to plugin the appropriate values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The command to execute, in this case, will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In order to execute the PowerShell file downloader quietly and successfully,
    a few switches are required. The `-w` switch sets the window style to `hidden`.
    This prevents any unwanted pop-ups from appearing during execution. The `-nop`
    and `-noni` switches will disable profile loading and user interactivity respectively,
    providing a bit more stealth while executing the downloader.
  prefs: []
  type: TYPE_NORMAL
- en: The `-c` switch takes an arbitrary PowerShell script block to execute. For our
    purposes, we will create a new `Net.Webclient` object and call its `DownloadFile`
    method with the source and destination as the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PowerShell one-liner example will grab the Weevely shell contents from
    the `SimpleHTTPServer` and drop them into the appropriate `htdocs` directory on
    the application server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Curl has a `--data-urlencode` option, which will, you guessed it, URL encode
    our command so that it passes through HTTP without causing any problems. The `-G`
    switch ensures that the encoded data is passed via a `GET` request.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that the PowerShell command is spawned in a separate process,
    the simple PHP shell `xampp.php` will not be able to return any success or failure
    messages. We can verify success by attempting to connect to the shell using the
    Weevely client.
  prefs: []
  type: TYPE_NORMAL
- en: Although it would be unusual nowadays, it is possible that PowerShell is disabled
    or unavailable on the target Windows system. In this case, using `bitsadmin.exe`
    to download payloads works just fine. Plugging in the right values, we can grab
    our Weevely shell and put it in the `htdocs` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bitsadmin` command template we will use is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with the PowerShell downloader, you expand the variables in your command
    and plug them into the `curl` template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the `bitsadmin` output clearly states, the binary is deprecated. While it
    is still available in all Windows versions to date, this may not be the case going
    forward. However, enterprises are somewhat slow to adopt new versions of Windows,
    so you can probably rely on this tool for several years to come.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Weevely client should now be able to connect to the `test.php` shell on
    the remote host. The syntax to do this is self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can issue commands in the Weevely shell that will be passed directly to
    the compromised host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step after getting the Weevely shell would be to remove the system
    passthrough web shell `xampp.php` artifact, created earlier as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we are free to move around the server and gather any information
    that could be used in later stages of an attack. We have full control of the server,
    and can run even better reverse shells, such as Meterpreter, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the compromised server is segregated from the rest of the network, we
    still have access to the application code. We can backdoor it in order to gather
    network credentials from authenticated users and subsequently attack the corporate
    network. It really depends on the scope of the engagement.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As noted, once an engagement is complete, we have to make sure that we clean
    up any artifacts that may leave the client exposed. During this attack, we created
    three files that could be used to attack the client. Although it is unlikely that
    anyone would be able to use our Weevely shell, it is wise to remove anything left
    behind. The `phpinfo.php` test file that we've created should also be deleted.
    While it doesn't provide any kind of remote access, it does display information
    that could be used in an attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way that we queried the MySQL variables to find out where the application
    resides on disk, an attacker could use the `phpinfo()` output to improve the success
    of a local file inclusion attack, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once we remove the `test.php` shell, the Weevely client loses connectivity,
    displaying the `404` error message in the preceding code block.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good idea to finalize the report before destroying any persistence into
    the network.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consult the following resources for more information on penetration testing
    tools and techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mitre provides a handy website with all the CVEs available: [http://cve.mitre.org/](http://cve.mitre.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Weevely documentation and bleeding edge-code is available on GitHub: [https://github.com](https://github.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've continued to showcase how difficult it is to get security
    right all of the time. Unfortunately, this has been, and always will be, a reality
    for most companies. As professional attackers, however, we thrive on this.
  prefs: []
  type: TYPE_NORMAL
- en: In our scenario, we did not tackle the application head on, spending countless
    hours interacting with the API and looking for a way to compromise it. Instead,
    we assumed that the bulk of the security-hardening effort was spent on the application
    itself, and we banked on the fact that, understandably, securing a server or development
    environment, and keeping it secure, is a difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the application development lifecycle tends to focus developers and administrators
    on the application code itself, while auxiliary systems controls are neglected.
    The operating system is not patched, the firewall is wide open, and development
    database instances expose the application to a slew of simple, yet effective,
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at alternate ways to compromise the target application.
    By scanning the application server with Nmap, we found an exposed database service
    that was configured with an easily guessable password. With access to the adjacent
    service, we were able to execute code on the server and ultimately access the
    target application and more.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at advanced brute-forcing techniques and how
    to fly under the radar during engagements where stealth is key.
  prefs: []
  type: TYPE_NORMAL
