<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Advanced Brute-forcing"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Advanced Brute-forcing</h1></div></div></div><p>Certain engagements require a bit more stealth and the noisiest part of the engagement is usually the brute-force scans. Whether we are looking for valid credentials on a particular login form or scanning for interesting URLs, lots of connections to the target in a short period of time can alert defenders to our activities, and the test could be over before it really begins.</p><p>Most penetration testing engagements are "smash and grab" operations. These types of assessments are usually more time-restricted, and throttling our connections for the sake of stealth during a brute-force attack can hinder progress. For engagements that may require a bit more finesse, the traditional penetration testing approach to brute-forcing and dictionary attacks may be too aggressive and could sound the alarm for the blue team. If the goal is to stay under the radar for the duration of the engagement, it may be best to employ more subtle ways to guess passwords or to look for unprotected web content using SecLists dictionaries.</p><p>In this chapter, we will look at the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Password spraying</strong></span> attacks</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Metadata harvesting</strong></span> and <span class="strong"><strong>public site scraping</strong></span></li><li class="listitem" style="list-style-type: disc">Using <span class="strong"><strong>Tor</strong></span> to evade <span class="strong"><strong>intrusion detection systems</strong></span> (<span class="strong"><strong>IDS</strong></span>)</li><li class="listitem" style="list-style-type: disc">Using <span class="strong"><strong>Amazon Web Services</strong></span> (<span class="strong"><strong>AWS</strong></span>) to evade IDS</li></ul></div><div class="section" title="Password spraying"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Password spraying</h1></div></div></div><p>A <a id="id191" class="indexterm"/>common issue that comes up with brute-forcing for account credentials is that the backend authentication system may simply lockout the target account after too many invalid attempts are made in a short period of time. Microsoft's <span class="strong"><strong>Active Directory</strong></span> (<span class="strong"><strong>AD</strong></span>) has <a id="id192" class="indexterm"/>default policies set on all its users that do just that. The typical policy is stringent enough that it would make attacking a single account with a large password list very time-consuming for most attackers, with little hope for a return on investment. Applications that integrate authentication with AD will be subject to these policies and traditional brute-force attacks may cause account lockouts, potentially firing alerts on the defender side, and certainly raising some red flags with the locked-out user.</p><p>A clever <a id="id193" class="indexterm"/>way to get around some of these lockout controls, while also increasing your chances of success, is referred to as a reverse brute-force attack or password spraying. The idea is simple and it is based on the fact that as attackers, we usually only need one set of credentials to compromise an application or the environment that hosts it. Instead of focusing the brute-force attack on just one user and risk locking them out, we'd target multiple known valid users with a smaller, more targeted password list. As long as we keep the attempts per account below the lockout policy, we should successfully avoid triggering alerts. Password spraying is not only useful when attempting to gain access to the organization VPN web application or to <span class="strong"><strong>Outlook Web Access</strong></span> (<span class="strong"><strong>OWA</strong></span>), but can<a id="id194" class="indexterm"/> also be used with any other application login system. Although lockout policies are almost certainly in effect for applications integrating with AD, they may also be present in other applications with standalone authentication mechanisms.</p><p>In order to properly spray for credentials, we need a large list of legitimate usernames, in the form of email addresses or the familiar <code class="literal">DOMAIN\ID</code> format. Farming legitimate users or account names is easier than it may sound. Without a SQL or <span class="strong"><strong>Lightweight Directory Access Protocol</strong></span> <span class="strong"><strong>(LDAP)</strong></span> injection dump, the first place to<a id="id195" class="indexterm"/> look should be on the target company's public websites. There are usually plenty of hints as to how the company structures account names or user IDs. Email addresses commonly used in applications integrating with AD are in the <code class="literal">ldap@company.com</code> format and can be mined from their <span class="strong"><strong>Contact Us</strong></span>, <span class="strong"><strong>About</strong></span>, or <span class="strong"><strong>Team</strong></span> pages. Some account information can also be found in the source code, usually in JavaScript libraries, HTML, or CSS for publicly facing web applications.</p><p>The following is a sample JavaScript library containing useful information when constructing a list of accounts to use when performing a password spraying attack:</p><div class="informalexample"><pre class="programlisting">/**
* slapit.js
*
* @requires jQuery, Slappy
*
* @updated <span class="strong"><strong>klibby@corp</strong></span> on 12/12/2015
*/

(function(){
  var obj = $('.target');
  /* @todo <span class="strong"><strong>dmurphy@corp</strong></span>: migrate to Slappy2 library */
  var slap = new Slappy(obj, {
    slide: false,
    speed: 300
  });
  slap.swipe();
)();</pre></div><p>The preceding<a id="id196" class="indexterm"/> code not only gives us at least two accounts to target in our spray, but also hints at how user account names are structured. If we look through the contact information on the <span class="strong"><strong>Meet the Executive Team</strong></span> page, we can make educated guesses as to what these employees' account names could be.</p><p>Common formats for usernames, especially for LDAP-based authentication, are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">FirstName.LastName</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">[First Initial]LastName</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">LastName[First Initial]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">FirstNameLastName</code></li></ul></div><p>Any contact emails listed on the public site we can add to our list of potential users to target for a spraying attack. Chances are good that these also correspond to their login credentials. If, for example, we farm a ton of company emails in the <code class="literal">david.lightman@antihacker.com</code> format and we know nothing else, we could build a user list containing the following entries:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">david.lightman</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">dlightman</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">lightmand</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">davidl</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">davidlightman</code></li></ul></div><p>Some organizations have also made the decision to limit their employees' account names to eight characters or less as a general company-wide policy. This simplifies account provisioning for those legacy systems that do not support long account names. Common employee names, such as John Smith, in larger organizations can also cause conflicts, and this is usually resolved by appending a number to the account name.</p><p>For these reasons, we should also add a few variations of the following to the list:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">dlightma</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">dlightm2</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">dlightm3</code></li></ul></div><p>We should also be <a id="id197" class="indexterm"/>cognizant of how many failed attempts at authentication we are willing to make. While we will avoid account lockout by password spraying 10 username variations with one password, we will also generate at least nine failed authentication attempts, if only one of those names is valid. If we are targeting 300 employees with 10 variations each, that's a fairly high authentication failure rate, which may trigger IDS and alert defenders to our activities.</p><div class="section" title="LinkedIn scraping"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec23"/>LinkedIn scraping</h2></div></div></div><p>LinkedIn is also a great source <a id="id198" class="indexterm"/>for employee names that we can use to build an effective list of account <a id="id199" class="indexterm"/>names. A little <span class="strong"><strong>Google hacking</strong></span> can list all the public LinkedIn profiles for people who have indicated publicly that they work at our target company. Google hacking<a id="id200" class="indexterm"/> refers to the art of using search terms in a query to return interesting information that the search giant has indexed over the years. For example, if we wish to target Yahoo!, we can focus our Google search query to return a filtered list of employee names using the <code class="literal">site</code> and <code class="literal">inurl</code> query modifiers:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>site:</strong></span>linkedin.com <span class="strong"><strong>inurl:</strong></span>"/pub/" <span class="strong"><strong>-inurl:</strong></span>"/dir/" "at <span class="strong"><strong>[Target Company]</strong></span>"</pre></div><p>Modifiers and their parameters are separated by a colon (<code class="literal">:</code>) and can also be prefixed with a minus (<code class="literal">-</code>) sign to indicate whether the value should be included or excluded from the results. The <code class="literal">inurl</code> modifier can instruct Google to return only search results that contain a particular string in the URL that was indexed. Conversely, the <code class="literal">-inurl</code> modifier will exclude results that contain the specific string in their URL. We can also wrap search terms in quotations to indicate that we want results that match the exact string.</p><p>In our example, we are looking for indexed LinkedIn profiles that contain <code class="literal">/pub/</code> in the URL and <code class="literal">"at Yahoo"</code> somewhere in the body. Using the inverse (<code class="literal">-</code>) <code class="literal">inurl</code> modifier, we are also excluding URLs that contain <code class="literal">/dir/</code> to ensure results contain employee profiles and not directories. The search is also limited to the <code class="literal">linkedin.com</code> domain using the site modifier. The results should contain text that suggests the user is working "at company."</p><div class="mediaobject"><img src="graphics/B09238_04_01.jpg" alt="LinkedIn scraping"/><div class="caption"><p>Figure 4.1: Google hacking example</p></div></div><p>The employee names returned by <a id="id201" class="indexterm"/>the search query can be scraped and stored in a text file, <code class="literal">linkedin.txt</code>, for processing in the <code class="literal">First[space]Last</code> format. For our<a id="id202" class="indexterm"/> password spraying attack, we will need to convert the <code class="literal">First Last</code> entries in the text file to potential account names. We can accomplish this quickly with a little bit of Python code.</p><p>First, we will need to open the <code class="literal">linkedin.txt</code> file in read mode (<code class="literal">r</code>) and store a pointer to it in the <code class="literal">fp</code> variable, as shown:</p><div class="informalexample"><pre class="programlisting">with open("<span class="strong"><strong>linkedin.txt</strong></span>", '<span class="strong"><strong>r</strong></span>') as <span class="strong"><strong>fp</strong></span>:</pre></div><p>We can use a <code class="literal">for</code> loop to iterate the contents of <code class="literal">fp</code> using the <code class="literal">iter</code> function. This will allow us to iterate over each line in the text file, storing the respective value in the <code class="literal">name</code> variable for every loop:</p><div class="informalexample"><pre class="programlisting">  for <span class="strong"><strong>name</strong></span> in iter(<span class="strong"><strong>fp</strong></span>):</pre></div><p>Next, for each line, presumably containing a space delimited first and last name entry, we can <code class="literal">split()</code> the two by a whitespace (<code class="literal">' '</code>) using the following one-liner:</p><div class="informalexample"><pre class="programlisting">    <span class="emphasis"><em>first, last</em></span> = name.strip().lower().<span class="emphasis"><em>split(' ')</em></span></pre></div><p>The variables <code class="literal">first</code> and <code class="literal">last</code> will contain the values you'd expect, in lowercase and cleaned up of any extra spaces after chaining <code class="literal">strip()</code> and <code class="literal">lower()</code> function calls.</p><p>Next, we can output a potential <a id="id203" class="indexterm"/>username using the formatting rules we established earlier. Using<a id="id204" class="indexterm"/> the <code class="literal">print</code> statement and a combination of <code class="literal">first</code> and <code class="literal">last</code> variables, we can easily display these to the screen:</p><div class="informalexample"><pre class="programlisting">    print first + "." + last <span class="strong"><strong># david.lightman</strong></span>
    print first + last       <span class="strong"><strong># davidlightman</strong></span>
</pre></div><p>Finally, we will also print a combination of the first initial and last name, as well as less than the maximum eight-character versions of each employee name:</p><div class="informalexample"><pre class="programlisting">    fl = first[0] + last
    lf = last + first[0]
    print fl <span class="strong"><strong># dlightman</strong></span>
    print lf <span class="strong"><strong># lightmand</strong></span>

    print fl[:8]       <span class="strong"><strong># dlightma</strong></span>
    print fl[:7] + "2" <span class="strong"><strong># dlightm2</strong></span>
    print fl[:7] + "3" <span class="strong"><strong># dlightm2</strong></span>
    print lf[:8]       <span class="strong"><strong># davidlig</strong></span>
    print lf[:7] + "2" <span class="strong"><strong># davidli2</strong></span>
    print lf[:7] + "3" <span class="strong"><strong># davidli3</strong></span>
</pre></div><p>We will save the resulting script in a file called <code class="literal">name2account.py</code>, which should look like this:</p><div class="informalexample"><pre class="programlisting">with open("<span class="strong"><strong>linkedin.txt</strong></span>", "r") as fp:

  for name in iter(fp):
    <span class="strong"><strong>first</strong></span>, <span class="strong"><strong>last</strong></span> = name.strip().lower().split(" ")
    print first + "." + last <span class="strong"><strong># david.lightman</strong></span>
    print first + last       <span class="strong"><strong># davidlightman</strong></span>

    fl = first[0] + last
    lf = last + first[0]
    print fl <span class="strong"><strong># dlightman</strong></span>
    print lf <span class="strong"><strong># lightmand</strong></span>

    print fl[:8]       <span class="strong"><strong># dlightma</strong></span>
    print fl[:7] + "2" <span class="strong"><strong># dlightm2</strong></span>
    print fl[:7] + "3" <span class="strong"><strong># dlightm2</strong></span>
    print lf[:8]       <span class="strong"><strong># davidlig</strong></span>
    print lf[:7] + "2" <span class="strong"><strong># davidli2</strong></span>
    print lf[:7] + "3" <span class="strong"><strong># davidli3</strong></span>
</pre></div><p>All that's left to do is run the <a id="id205" class="indexterm"/>script and <a id="id206" class="indexterm"/>observe the output, as the following figure shows:</p><div class="mediaobject"><img src="graphics/B09238_04_02.jpg" alt="LinkedIn scraping"/><div class="caption"><p>Figure 4.2: Running the account name generator</p></div></div><p>To use this output in an attack, we can redirect it to another text file, to be later imported in Burp or ZAP, by using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools# python name2account.py &gt; target</strong></span>
<span class="strong"><strong>_accounts.txt</strong></span>
</pre></div></div><div class="section" title="Metadata"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Metadata</h2></div></div></div><p>It's also possible to gather valid usernames by <a id="id207" class="indexterm"/>analyzing our list of users, by looking at what is already available on the internet. Publicly indexed documents are a good source for user IDs, as they often contain valuable metadata information, either in the contents or somewhere in the file header. When documents are created by company employees, Microsoft Office and Adobe PDF, among many other types of document-authoring software, by default will save the name of the currently logged-on user as the file author in the metadata. These documents don't have to be top secret; they can be flyers and marketing material. It could be public data meant to be shared with the world and we can make use of the automatically populated metadata for our password spraying attacks.</p><p>
<span class="strong"><strong>Fingerprinting Organizations with Collected Archives</strong></span> (<span class="strong"><strong>FOCA</strong></span>) is a <a id="id208" class="indexterm"/>great tool from <span class="strong"><strong>ElevenPaths</strong></span> that scrapes search engine results for<a id="id209" class="indexterm"/> indexed documents, such as PDF, Excel, or Word files. These files typically store valuable information in their metadata; usually the AD ID responsible for authoring the file. </p><p>It may not always be the domain username (it could be an email address), but this is still valuable information to us when we build our target account list.</p><p>With FOCA, we can quickly launch a search for all publicly available documents for our target and one-click analyze their metadata.</p><p>You'll notice that the query is similar to the LinkedIn scraping we used earlier. This is because FOCA will use search engine hacking under the hood and leverage not only Google, but also Bing and other information directories.</p><p>In the following example, we are looking for publicly available documents from <code class="literal">vancouver.ca</code> and analyzing their metadata. FOCA will download each PDF, parse the header, and store any users it finds in the left column under Metadata Summary.</p><div class="mediaobject"><img src="graphics/B09238_04_03.jpg" alt="Metadata"/><div class="caption"><p>Figure 4.3: FOCA displaying publicly indexed documents</p></div></div><p>This valuable username <a id="id210" class="indexterm"/>data can be exported to a file to be used in a password spraying attack. Not only do we have valid accounts in these public documents, but they also hint at how the company structures its usernames. We can combine this knowledge with a LinkedIn scrape and build better target account lists, while minimizing authentication failures.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>FOCA is available from <a id="id211" class="indexterm"/>ElevenPaths on <a class="ulink" href="https://www.elevenpaths.com/labstools/foca/index.html">https://www.elevenpaths.com/labstools/foca/index.html</a> or on GitHub at <a class="ulink" href="https://github.com/ElevenPaths/FOCA">https://github.com/ElevenPaths/FOCA</a>.</p></div></div></div><div class="section" title="The cluster bomb"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec25"/>The cluster bomb</h2></div></div></div><p>In order to conduct a<a id="id212" class="indexterm"/> password spraying attack, we need an easy way to feed our target the user list, as well as a small, but specific, password list. We also want the option to throttle each attempt, if needed, to avoid detection.</p><p>Burp Suite's Intruder module has several payload delivery options, and among them is the cluster bomb attack type, allowing us to specify multiple positions in our HTTP request in which we can insert our payloads. Intruder will submit a request for each possible combination, which is ideal for password spraying attacks.</p><p>The password list will be much more focused, and instead of throwing the massive <code class="literal">rockyou.txt</code> dictionary at each of the usernames, we will compose a shorter list of a more commonly used set of values.</p><p>When users forget their <a id="id213" class="indexterm"/>passwords, they call in tech support and request a password reset. Usually, instead of an elaborate reset procedure, support will reset the password to something simple to read over the phone, so the employee can login and resume working quickly. A common password scheme is <code class="literal">[Current Season][Current Year]</code>. Something like <code class="literal">Fall2017</code> is easy to communicate over the phone and will satisfy most password complexity policies. At times, a special character may be sprinkled in there as well: <code class="literal">Fall@2017</code> or <code class="literal">Fall2017!</code>.</p><p>This isn't really an issue if the user logs in and resets their password immediately. AD has an option for tech support that requires the user to change their password after the first successful login. Unfortunately, legacy systems and complex authentication schemes do not always support password reset on first login, forcing organizations to require users to do this manually. While the majority of users will reset their password immediately, some won't and we usually only need just one user to slip up.</p><p>A sample set of passwords to try could look like this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Fall2017</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Fall17</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Fall2017!</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Fall@2017</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Summer2017</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Summer17</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Summer2017!</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Summer@2017</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Spring2017</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Spring17</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Spring2017!</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Spring@2017</code></li></ul></div><p>We can also be smart about how we construct this list. If we know anything about the password requirements of the application, we may choose to eliminate passwords that don't fit. Perhaps the target company is headquartered in a region where use of the word <code class="literal">autumn</code> is more common than <code class="literal">fall</code>, in which case we adjust accordingly.</p><p>It's important to consider the account lockout as well. Our Intruder attack will generate as many authentication requests per user as there are passwords in the list, meaning there is a possibility we could lockout accounts. The cluster bomb Intruder attack type will try the first password in the list for each username until it reaches the end, and it will start again at the top. It will then try the second password for each username, then the third, and so on until it exhausts the password list. If we don't throttle the requests per username, we can risk locking out the account and alerting defenders.</p><p>Once we have a password and <a id="id214" class="indexterm"/>username list, we can start the password spraying attack by leveraging the Intruder module. For the sake of this scenario, we will be targeting an application available on <code class="literal">target.org.local</code> on port <code class="literal">80</code>, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/B09238_04_04.jpg" alt="The cluster bomb"/><div class="caption"><p>Figure 4.4: Specifying the attack target in Intruder</p></div></div><p>The request we will send will be a <code class="literal">POST</code> to the <code class="literal">/login</code> page. We can specify the request body and payload positions under the Intruder <span class="strong"><strong>Positions</strong></span> tab. Highlighting the dummy values for <code class="literal">username</code> and <code class="literal">password</code>, we can click the <span class="strong"><strong>Add</strong></span> button on the right side to denote a payload position, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B09238_04_05.jpg" alt="The cluster bomb"/><div class="caption"><p>Figure 4.5: Defining the payload positions</p></div></div><p>We've also <a id="id215" class="indexterm"/>selected the <span class="strong"><strong>Cluster bomb</strong></span> attack type, as mentioned previously.</p><p>Next up, we have to load our payloads, more specifically, the username and password lists we compiled earlier. Payload set 1 will be our username list, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B09238_04_06.jpg" alt="The cluster bomb"/><div class="caption"><p>Figure 4.6: Loading the usernames into payload set 1</p></div></div><p>Our second payload set will be the <a id="id216" class="indexterm"/>passwords to be tested for each username. Once again, this is not where we'd load <code class="literal">rockyou.txt</code> and let it rip. In a password spraying attack, we target a large list of known-good user IDs, with only a few very common passwords. We want to avoid locking out and triggering alerts.</p><p>The following figure shows a sample small payload set 2:</p><div class="mediaobject"><img src="graphics/B09238_04_07.jpg" alt="The cluster bomb"/><div class="caption"><p>Figure 4.7: Loading the passwords into payload set 2</p></div></div><p>The preceding configuration will make four password guess attempts per user, hopefully keeping our attack under the radar and avoiding any lockouts. The more users we can feed this attack to, the better the chance we will find a user who has forgotten to change their password.</p><p>Burp Suite Professional <a id="id217" class="indexterm"/>provides some options for performing a low and slow attack, and they can be set in the <span class="strong"><strong>Options</strong></span> tab. While the free edition of Burp Suite does not allow multiple threads or throttling, OWASP ZAP offers similar attack types, with the ability to throttle and increase thread count.</p><p>After loading our target users list and specifying a few passwords, we can spray the application by clicking <span class="strong"><strong>Start attack</strong></span>. The following figure shows the Intruder attack window and all of the requests made during the password spraying attack:</p><div class="mediaobject"><img src="graphics/B09238_04_08.jpg" alt="The cluster bomb"/><div class="caption"><p>Figure 4.8: Password spraying attack running</p></div></div></div></div></div>
<div class="section" title="Behind seven proxies"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Behind seven proxies</h1></div></div></div><p>These days, it is fairly common for more mature companies to implement IDS, <span class="strong"><strong>intrusion prevention systems</strong></span> (<span class="strong"><strong>IPS</strong></span>), and <span class="strong"><strong>security information and event management</strong></span> (<span class="strong"><strong>SIEM</strong></span>) with alerting for when they detect <a id="id218" class="indexterm"/>abuse against a particular <a id="id219" class="indexterm"/>application. When an unknown IP is performing too many operations in a short time on a protected application, IDS or IPS may take action against the source. If we are conducting a password spraying attack, we may avoid lockouts but we're still hammering the server from one source: our machine.</p><p>A good way to evade these types of detection systems is to distribute the connection requests from the attacker machine over many IPs, which is commonly done by malicious actors through networks of compromised hosts. With the advent of cloud computing and computing time becoming increasingly cheap, even free in some cases, we don't have to stray outside of the law and build a botnet. The <span class="strong"><strong>Tor network</strong></span>
<a id="id220" class="indexterm"/> is also a free and effective way to change the public IP during an attack.</p><div class="section" title="Torify"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Torify</h2></div></div></div><p>The <span class="strong"><strong>Tor Project</strong></span> was started<a id="id221" class="indexterm"/> to provide a way for users to browse the internet anonymously. It is by far the best way to anonymize traffic and best of all, it's free. Tor is a network of independently operated nodes interconnected to form a network through which packets can be routed.</p><p>The following graphic shows how a user, Alice, can connect to Bob through a randomly generated path or circuit, through the Tor network:</p><div class="mediaobject"><img src="graphics/B09238_04_09.jpg" alt="Torify"/><div class="caption"><p>Figure 4.9: The Tor network traffic flow (source: https://www.torproject.org/)</p></div></div><p>Instead of connecting directly to the destination, the client connection from Alice to Bob will be routed through a randomly chosen set of nodes in the Tor network. Each packet is encrypted and every node can only decrypt enough information to route it to the next hop along the path. The exit node is the final node in the chain, which will make the connection to the intended destination on behalf of the client. When the packet arrives at Bob's machine, the request will look like it's coming from the exit node and not Alice's public IP.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>More information on Tor can be found on the official site: <a class="ulink" href="https://www.torproject.org">https://www.torproject.org</a>.</p></div></div><p>While Tor is important <a id="id222" class="indexterm"/>for anonymity, we're not really concerned with staying completely anonymous. We can, however, leverage the randomly chosen exit nodes to mask our public IP when attacking an application.</p><p>Tor packages are available on most Linux distributions. On Kali, it can be installed using the package manager. The <code class="literal">apt-get</code> command shown in the following code will install Tor, as well as a useful application called <span class="strong"><strong>torsocks</strong></span>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~# apt-get install tor torsocks</strong></span>
</pre></div><p>Torsocks is a nice tool that can "torify" applications and even provide an interactive shell that automatically routes all traffic through an active Tor tunnel. This will allow us to force applications that don't natively support routing through Tor to use the anonymous network.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>Torsocks<a id="id223" class="indexterm"/> can be found on the Tor Project Git repository: <a class="ulink" href="https://gitweb.torproject.org/torsocks.git">https://gitweb.torproject.org/torsocks.git</a>.</p></div></div><p>There isn't much that we need to change in the Tor default configuration; we can just go ahead and launch it from the Kali prompt, using the <code class="literal">tor</code> binary, as show in the following code block:</p><div class="informalexample"><pre class="programlisting">root@kali:~#<span class="strong"><strong> tor</strong></span>
[notice] Tor 0.3.1.9
[notice] Read configuration file "/etc/tor/torrc".
[notice] Opening Socks listener on 127.0.0.1:9050
[notice] Parsing GEOIP IPv4 file /usr/share/tor/geoip.
[notice] Parsing GEOIP IPv6 file /usr/share/tor/geoip6.
[warn] You are running Tor as root. You don't need to, and you probably shouldn't.
[notice] Bootstrapped 0%: Starting
[notice] Starting with guard context "default"
[notice] Bootstrapped 80%: Connecting to the Tor network
[notice] Bootstrapped 85%: Finishing handshake with first hop
[notice] Bootstrapped 90%: Establishing a Tor circuit
<span class="strong"><strong>[notice] Tor has successfully opened a circuit. Looks like client functionality is working.</strong></span>
[notice] Bootstrapped 100%: Done</pre></div><p>Once the Tor client has initialized and a tunnel (circuit) has been selected, a SOCKS proxy server is launched on the localhost, listening on port <code class="literal">9050</code>. To force our attack traffic through the Tor network and mask our external IP, we can configure Burp Suite to use the newly spawned proxy for all outgoing connections. Any other programs that do not support SOCKS can be "torified" using either ProxyChains or the previously installed torsocks utility.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>ProxyChains<a id="id224" class="indexterm"/> is available on all penetration testing distros and on <a class="ulink" href="http://proxychains.sourceforge.net/">http://proxychains.sourceforge.net/</a>.</p></div></div><p>In Burp Suite, under the <span class="strong"><strong>Project options</strong></span> tab, we can select the <span class="strong"><strong>Override user options</strong></span> check to enable the SOCKS <a id="id225" class="indexterm"/>configuration fields. The values for SOCKS proxy and port will be <code class="literal">localhost</code> and <code class="literal">9050</code> respectively, and it's a good idea to make DNS lookups through the proxy as well.</p><div class="mediaobject"><img src="graphics/B09238_04_10.jpg" alt="Torify"/><div class="caption"><p>Figure 4.10: Configuring the upstream SOCKS proxy in Burp</p></div></div><p>We can <a id="id226" class="indexterm"/>perform a test request, using <a id="id227" class="indexterm"/>the Repeater module, to <code class="literal">ipinfo.io</code> and it should show a randomly selected Tor exit node as our external IP.</p><p>The following figure shows the response to our torified request to <code class="literal">ipinfo.io</code>:</p><div class="mediaobject"><img src="graphics/B09238_04_11.jpg" alt="Torify"/><div class="caption"><p>Figure 4.11: Repeater response showing a Tor exit node as our effective IP</p></div></div><p>While the Tor client does<a id="id228" class="indexterm"/> refresh the circuit periodically, it may not be quick enough for a brute-force attack, where rotating IPs is needed for evasion. We don't want to throttle our connection so much that the scan does not finish before the engagement is over.</p><p>The Tor proxy can be forced to update the current circuit with a <span class="strong"><strong>process hang up signal</strong></span> (<span class="strong"><strong>SIGHUP</strong></span>). Using the <code class="literal">killall</code> or <code class="literal">kill</code> Linux commands, we can issue a <code class="literal">HUP</code> signal to the Tor application and force the process to rotate our exit node.</p><p>First, we can drop into a <a id="id229" class="indexterm"/>torsocks shell to hook all <code class="literal">curl</code> requests and forward them through the Tor network. The <code class="literal">torsocks</code> command can be called using the <code class="literal">--shell</code> parameter, as shown:</p><div class="informalexample"><pre class="programlisting">root@kali:~# torsocks --shell
/usr/bin/torsocks:<span class="strong"><strong> New torified shell coming right up...</strong></span>
root@kali:~#</pre></div><p>Subsequent network requests from applications spawned from the torsocks shell should be forwarded through Tor. To see the SIGHUP in action, we can use <code class="literal">curl</code> requests to an online service, which returns our current public IP, <code class="literal">ipinfo.io</code>:</p><div class="informalexample"><pre class="programlisting">root@kali:~#<span class="strong"><strong> curl ipinfo.io</strong></span>
{
<span class="strong"><strong>  "ip": "46.165.230.5",</strong></span>
  "hostname": "tor-exit.dhalgren.org",
  "country": "DE"
}
root@kali:~#<span class="strong"><strong> killall -HUP tor</strong></span>
root@kali:~#<span class="strong"><strong> curl ipinfo.io</strong></span>
{
<span class="strong"><strong>  "ip": "176.10.104.240",</strong></span>
  "hostname": "tor1e1.digitale-gesellschaft.ch",
  "country": "CH"
}
root@kali:~#<span class="strong"><strong> killall -HUP tor</strong></span>
root@kali:~#<span class="strong"><strong> curl ipinfo.io</strong></span>
{
<span class="strong"><strong>  "ip": "195.22.126.147",</strong></span>
  "country": "PL"
}
root@kali:~#<span class="strong"><strong> killall -HUP tor</strong></span>
root@kali:~#<span class="strong"><strong> curl ipinfo.io</strong></span>
{
<span class="strong"><strong>  "ip": "104.218.63.74",</strong></span>
  "hostname": "tor-exit.salyut-4.vsif.ca",
  "country": "CA"
}
root@kali:~#</pre></div><p>Each request to the IP service returned a new Tor exit node. We can also crudely automate sending the HUP signal using the <code class="literal">watch</code> command in a separate terminal. The <code class="literal">-n</code> option specifies how often to execute the <code class="literal">killall</code> command. In this case, Tor will be issued a SIGHUP every <code class="literal">10</code> seconds, effectively rotating our external IP at the same time:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~# watch -n10 killall -HUP tor</strong></span>
</pre></div><p>If our plan is to attempt a <a id="id230" class="indexterm"/>password spraying attack against the <code class="literal">c2.spider.ml</code> application, for example, we can configure Burp Suite to use a cluster bomb Intruder configuration along with a list of common usernames and passwords. Meanwhile, in the background, the <code class="literal">watch</code> command is refreshing the Tor circuit every 10 seconds. We will throttle the Burp requests to one request every 10 seconds, which will ensure each password guess attempt will come from a different IP, improving our stealth. It should be noted that Burp's free edition does not support throttling. The same functionality can be accomplished using OWASP ZAP, with <code class="literal">watch</code> running in the background cycling the Tor circuit.</p><p>The following figure shows the <code class="literal">watch</code> command running the <code class="literal">killall</code> command on the Tor application every 10 seconds, while Burp's Intruder module performs a password guessing attack:</p><div class="mediaobject"><img src="graphics/B09238_04_12.jpg" alt="Torify"/><div class="caption"><p>Figure 4.12: Running a password guessing attack with a constantly changing exit IP</p></div></div><p>As expected, the <code class="literal">c2.spider.ml</code> application <a id="id231" class="indexterm"/>server log shows the attack coming in every 10 seconds from a new exit node IP.</p><p>The following shows a sample PHP webserver listing each HTTP request, the time, and the originating IP:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:/var/www# php -S 0.0.0.0:80
Listening on http://0.0.0.0:80
Press Ctrl-C to quit.
[20:21:23]<span class="strong"><strong> 163.172.101.137:58806 </strong></span>[200]: /?user=root&amp;password=123456
[20:21:33]<span class="strong"><strong> 144.217.161.119:58910 </strong></span>[200]: /?user=info&amp;password=123456
[20:21:45]<span class="strong"><strong> 96.64.149.101:44818 </strong></span>[200]: /?user=guest&amp;password=123456
[20:21:53]<span class="strong"><strong> 216.218.222.14:16630 </strong></span>[200]: /?user=test&amp;password=123456
[20:22:08]<span class="strong"><strong> 185.220.101.29:44148 </strong></span>[200]: /?user=admin&amp;password=123456
[...]
[20:24:52]<span class="strong"><strong> 89.234.157.254:42775 </strong></span>[200]: /?user=test&amp;password=123456789
[20:25:03]<span class="strong"><strong> 87.118.122.30:42856 </strong></span>[200]: /?user=admin&amp;password=123456789</pre></div><p>The low and slow nature of the attack, coupled with an ever-changing source IP, makes it more difficult for defenders to differentiate our attack traffic from legitimate traffic. It's not impossible to design effective rules that find brute-force attacks coming from many IPs in many regions, but it is fairly difficult to do without generating false positives.</p><p>There are a couple of <a id="id232" class="indexterm"/>issues with conducting attacks through the Tor network. The routing protocol is inherently slower than a more direct connection. This is because Tor adds several layers of encryption to each transmission, and each transmission is forwarded through three Tor nodes on top of the normal routing that internet communication requires. This process improves anonymity but also increases communication delay significantly. The lag is noticeable for normal web browsing, but this is a tolerable trade-off. For large volume scans, it may not be the ideal transport.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>It should also be noted that Tor is used heavily in regions of the world where privacy is of utmost importance. Conducting large volume attacks through Tor is discouraged, as it can lead to unnecessary network slowdowns and can impact legitimate users. Low and slow attacks shouldn't cause any problems. Some red-team engagements may even require testing from the Tor network to verify related IDS/IPS rules are working as intended, but caution should be taken when launching attacks through a limited-resource public medium.</p></div></div><p>The other problem with Tor is that the exit nodes are public. Firewalls, IDS, IPS, and even host-based controls can be configured to outright block any connection from known Tor nodes. While there are legitimate users on Tor, it also has a long history of being used for illegal activity; the risk of annoying a small number of potential customers by disallowing Tor connections is generally acceptable by organizations.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>A list of active Tor exit nodes<a id="id233" class="indexterm"/> can be found here: <a class="ulink" href="https://check.torproject.org/cgi-bin/TorBulkExitList.py">https://check.torproject.org/cgi-bin/TorBulkExitList.py</a>.</p></div></div></div><div class="section" title="Proxy cannon"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Proxy cannon</h2></div></div></div><p>An alternative to using Tor for diversifying our attack IPs is to simply use the cloud. There are countless <span class="strong"><strong>Infrastructure as a Service</strong></span> (<span class="strong"><strong>IaaS</strong></span>) providers, each with a large IP space available for free to <a id="id234" class="indexterm"/>VM instances. VMs are cheap and sometimes free as well, so routing our traffic through them should be fairly cost effective.</p><p>Amazon, Microsoft, and Google all have an easy-to-use API for automating the management of VM instances. If we can spawn a new VM with a new external IP periodically, we can route our traffic to the target application through it and mask our true origin. This should make it much more difficult for automated systems to detect and alert on our activities.</p><p>Cue <span class="strong"><strong>ProxyCannon</strong></span>, a great tool <a id="id235" class="indexterm"/>that does all the heavy lifting of talking to Amazon's AWS API, creating and destroying VM instances, rotating external IPs, and routing our traffic through them.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>ProxyCannon was developed<a id="id236" class="indexterm"/> by Shellntel and is available on GitHub: <a class="ulink" href="https://github.com/Shellntel/scripts/blob/master/proxyCannon.py">https://github.com/Shellntel/scripts/blob/master/proxyCannon.py</a>.</p></div></div><p>ProxyCannon requires <code class="literal">boto</code>, a Python library that provides API access to Amazon's AWS. We can use Python's <code class="literal">pip</code> command to install the required dependency:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools# pip install -U boto</strong></span>
<span class="strong"><strong>Collecting boto</strong></span>
<span class="strong"><strong>  Downloading boto-2.48.0-py2.py3-none-any.whl (1.4MB)</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>Installing collected packages: boto</strong></span>
<span class="strong"><strong>Successfully installed boto-2.48.0</strong></span>
</pre></div><p>The ProxyCannon tool should now be ready to use with the <code class="literal">-h</code> option showing all of the available options:</p><div class="informalexample"><pre class="programlisting">root@kali:~/tools#<span class="strong"><strong> python proxyCannon.py -h</strong></span>
usage: proxyCannon.py [-h] [-id [IMAGE_ID]] [-t [IMAGE_TYPE]]
                [--region [REGION]] [-r] [-v] [--name [NAME]]
                [-i [INTERFACE]] [-l]
                num_of_instances
</pre></div><div class="mediaobject"><img src="graphics/B09238_04_15.jpg" alt="Proxy cannon"/></div><p>By default, ProxyCannon creates <code class="literal">t2.nano</code> virtual instances in AWS, which should be free for a limited time with new accounts. They have very little resources but are typically enough for most attacks. To change the type of instance, we can supply the <code class="literal">-t</code> switch. The default region is <code class="literal">us-east-1</code> and can be adjusted using the <code class="literal">--region</code> switch.</p><p>ProxyCannon will <a id="id237" class="indexterm"/>create as many instances as specified in the <code class="literal">num_of_instances</code> and using the <code class="literal">-r</code> switch, it will rotate them regularly. The <code class="literal">-l</code> switch is also useful to keep track of what public IPs ProxyCannon is using over the course of the execution. This is useful for reporting purposes: the blue team may need a list of all the IPs used in the attack.</p><p>In order for the tool to be able to communicate with our AWS account and to manage instances automatically, we have to create API access keys in the AWS console. The interface is fairly straightforward and can be accessed in the account <span class="strong"><strong>Security Credentials</strong></span> page.</p><p>The access key ID and the secret keys are randomly generated and should be stored securely. Once the engagement is over, you should delete the keys in the AWS console.</p><div class="mediaobject"><img src="graphics/B09238_04_13.jpg" alt="Proxy cannon"/><div class="caption"><p>Figure 4.13: Generating a new AWS API access key</p></div></div><p>We can start <a id="id238" class="indexterm"/>ProxyCannon using the <code class="literal">-r</code> and <code class="literal">-l</code> switches, and specify that we want <code class="literal">3</code> instances running at the same time.</p><div class="informalexample"><pre class="programlisting">root@kali:~/tools# python proxyCannon.py -r -l 3
What is the AWS Access Key Id:<span class="strong"><strong> d2hhdCBhcmUgeW91IGRvaW5n</strong></span>
What is the AWS Secret Access Key: <span class="strong"><strong>dW5mb3J0dW5hdGVseSB0aGlzIGlzIG5vdCB0aGUgcmVhbCBrZXku</strong></span>
[...]</pre></div><p>Upon first run, ProxyCannon will ask you for these values and store them in the <code class="literal">~/.boto</code> file.</p><div class="informalexample"><pre class="programlisting">root@kali:~/tools#<span class="strong"><strong> cat ~/.boto</strong></span>
[default]
aws_access_key_id = d2hhdCBhcmUgeW91IGRvaW5n
aws_secret_access_key = dW5mb3J0dW5hdGVseSB0aGlzIGlzIG5vdCB0aGUgcmVhbCBrZXku</pre></div><p>As you can see, these are stored in plaintext, so make sure this file is properly protected. Amazon recommends that these keys are rotated frequently. It's probably a good idea to create new ones for each engagement and delete them from AWS as soon as they're not required anymore.</p><p>ProxyCannon will connect to Amazon EC2, setup the SSH keys, adjust the security groups, and start the VM instances. This process may take a couple of minutes to complete.</p><div class="informalexample"><pre class="programlisting">[*] Connecting to Amazon's EC2...
[*] Generating ssh keypairs...
[*] Generating Amazon Security Group...
<span class="strong"><strong>[~] Starting 3 instances, please give about 4 minutes for them to fully boot</strong></span>
[====================] 100%</pre></div><p>ProxyCannon will overwrite the current system <code class="literal">iptables</code> configuration to properly route all traffic through whatever instance is chosen:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[*] Provisioning Hosts.....</strong></span>
<span class="strong"><strong>[*] Saving existing iptables state</strong></span>
<span class="strong"><strong>[*] Building new iptables...</strong></span>
<span class="strong"><strong>[*] Done!</strong></span>

<span class="strong"><strong>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</strong></span>
<span class="strong"><strong>+ Leave this terminal open and start another to run your commands.+</strong></span>
<span class="strong"><strong>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</strong></span>

<span class="strong"><strong>[~] Press ctrl + c to terminate the script gracefully.</strong></span>
<span class="strong"><strong>[...]</strong></span>
</pre></div><p>As promised, ProxyCannon <a id="id239" class="indexterm"/>will periodically rotate our effective external IP using SSH tunnels and by modifying the routing table. All of this is done automatically, in the background, while Burp Suite or ZAP runs the password spraying attack.</p><p>The following is the periodic output from ProxyCannon showing the IPs being rotated:</p><div class="informalexample"><pre class="programlisting">[*] Rotating IPs.
[*] Replaced <span class="strong"><strong>107.21.177.36 </strong></span>with<span class="strong"><strong> 34.207.187.254 </strong></span>on tun0
[*] Replaced<span class="strong"><strong> 34.234.91.233 </strong></span>with<span class="strong"><strong> 52.91.91.157 </strong></span>on tun1
[*] Replaced<span class="strong"><strong> 34.202.237.230 </strong></span>with<span class="strong"><strong> 34.228.167.195 </strong></span>on tun2
[*] Replaced<span class="strong"><strong> 34.207.187.254 </strong></span>with<span class="strong"><strong> 34.228.158.208 </strong></span>on tun0
[*] Replaced<span class="strong"><strong> 52.91.91.157 </strong></span>with<span class="strong"><strong> 54.198.223.114 </strong></span>on tun1</pre></div><p>On the AWS console, we can see the started <code class="literal">t2.nano</code> instances and their public IPs:</p><div class="mediaobject"><img src="graphics/B09238_04_14.jpg" alt="Proxy cannon"/><div class="caption"><p>Figure 4.14: AWS instances created to route our traffic through</p></div></div><p>As with our Tor example earlier, we can test ProxyCannon by repeating a <code class="literal">curl</code> request to our target application using the <code class="literal">watch</code> command. We don't need to drop in a shell similar to torsocks because ProxyCannon modifies the local system routing to help us change our external IP.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~# watch -n30 curl http://c2.spider.ml</strong></span>
</pre></div><p>On the target <a id="id240" class="indexterm"/>application side, <code class="literal">c2.spider.ml</code>, the server log, shows connection attempts from various IPs belonging to the Amazon address space:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>52.91.91.157 </strong></span>- - [13:01:16] "GET / HTTP/1.1" 200 -
<span class="strong"><strong>52.91.91.157 </strong></span>- - [13:01:22] "GET / HTTP/1.1" 200 -
<span class="strong"><strong>34.228.158.208 </strong></span>- - [13:01:43] "GET / HTTP/1.1" 200 -
<span class="strong"><strong>34.228.158.208 </strong></span>- - [13:01:48] "GET / HTTP/1.1" 200 -
<span class="strong"><strong>54.198.223.114 </strong></span>- - [13:06:34] "GET / HTTP/1.1" 200 -
<span class="strong"><strong>54.198.223.114 </strong></span>- - [13:06:39] "GET / HTTP/1.1" 200 -</pre></div><p>It should be noted that there is a lower limit to how often we can rotate the IPs on Amazon or any cloud provider for that matter. It takes a while for instances to boot and IP addresses to be reserved, associated, and become active. ProxyCannon has a hardcoded value of about 90 seconds to ensure the effective IP actually changes.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we looked at a couple of techniques for staying under the radar while conducting brute-force attacks during an engagement. Low and slow attacks, with frequently rotating IPs, is a great way to guess passwords or look for interesting URLs. If we can combine this with a password spray, we can increase the chance of success while evading intrusion detection, or prevention systems and firewalls. We've also looked at scraping metadata from LinkedIn and Google to build effective user and password lists.</p><p>These deviations from the normal brute-force attack make an attack difficult to defend against, requiring the blue team to have properly tuned alerts, with low false-positive rates and, frankly, lots of resources dedicated to monitoring the detection systems. As attackers, we know that the blue team is more often than not stretched far too thin to enable rules that produce large amounts of false positives but that can also catch our attempts. Generally speaking, unless the target organization has a very mature security program with lots of funding, these types of attacks are easy to pull off and frequently successful.</p><p>In the next chapter, we will delve into exploiting vulnerabilities in how applications handle files and file paths from untrusted sources.</p></div></body></html>