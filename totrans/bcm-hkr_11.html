<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Attacking APIs"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Attacking APIs</h1></div></div></div><p>So far, we've looked at attacking a traditional application — one with a user interface and a login panel, and maybe a dashboard of some sort. Modern applications tend to implement a decoupled infrastructure and, unlike traditional applications, they are split into smaller applications or <span class="strong"><strong>microservices,</strong></span> all working<a id="id554" class="indexterm"/> together to provide functionality for the user. <span class="strong"><strong>Application programming interfaces</strong></span> (<span class="strong"><strong>APIs</strong></span>) are not<a id="id555" class="indexterm"/> a new concept. The term API is used for anything from the Windows library of code, which allows our user-land code to interact with the operating system kernel, to the service exposed on the web that powers our note-taking apps. Obviously, we will not be focusing on the <span class="strong"><strong>Windows API</strong></span> (<span class="strong"><strong>WinAPI</strong></span>), but we<a id="id556" class="indexterm"/> will look at the web applications that power seemingly everything on the internet. When I speak of APIs in this chapter, I am referring to web services specifically.</p><p>Microservices are a relatively new concept adopted by application developers, moving away from typical monolithic application design to a more decoupled approach. The idea is to split components into their own instances and access them via a common language, usually over the network, and more specifically, the HTTP protocol. This does wonders for development and agility, as it allows code to be pushed asynchronously to each component. Developers can focus on a specific component without fear of breaking anything else, so long as the interface to this component adheres to an agreed standard.</p><p>It's not all rainbows with this type of approach, however. New security challenges are introduced with this model. Decoupled services mean a larger attack surface with multiple instances, be they virtual machines or Docker containers. More components usually equate to a greater chance of misconfiguration, which can, of course, be taken advantage of by us.</p><p>Authentication and authorization enforcement between components is a new problem to solve as well. If my monolithic application has every component built in, I don't really need to worry about securely communicating with the authentication module, as it resides on the same server, and sometimes in the same process. If my authentication module was decoupled and it is now an HTTP web service running in the cloud, I have to consider the network communication between my user interface and the authentication module instance in the cloud. How does the API authenticate my user interface? How can the two components securely negotiate an authentication response so that the user is allowed access to the other components?</p><p>Decoupling has other interesting effects on security as well. Suppose an API is developed to handle data for a Windows application. The API will accept an HTTP verb (<code class="literal">GET</code>, <code class="literal">PUT</code>, and so on) and respond with either JSON or XML. The Windows-native application reads the response and displays an error message returned in the JSON object. A Windows popup containing arbitrary strings is not inherently dangerous to display. There's no need to escape dangerous HTML code in the API response because the <code class="literal">MessageBox()</code> function of <code class="literal">user32.dll</code> does not do any kind of rendering of the string it displays. Now suppose that same API is suddenly integrated with a brand-new web application. Unescaped HTML data in the JSON response could be problematic.</p><p>By the end of the chapter, you will be comfortable with:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The different types of web API architecture</li><li class="listitem" style="list-style-type: disc">How APIs handle authentication</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>JSON Web Tokens</strong></span> (<span class="strong"><strong>JWTs</strong></span>)</li><li class="listitem" style="list-style-type: disc">Automating API attacks</li></ul></div><div class="section" title="API communication protocols"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec61"/>API communication protocols</h1></div></div></div><p>At<a id="id557" class="indexterm"/> their core, web APIs are simple HTTP client-server environments. A request comes in over HTTP and a response goes out. To standardize things a bit more, a couple of protocols have been developed, and many APIs follow one or the other to process requests. This is by no means an exhaustive list, but it is likely what you'll encounter in the wild:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Representational State Transfer</strong></span> (<span class="strong"><strong>REST</strong></span>)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Simple Object Access Protocol</strong></span> (<span class="strong"><strong>SOAP</strong></span>)</li></ul></div><p>There are certainly other types of protocols that APIs can use, but while their protocols differ, the majority of the same security challenges remain. The most popular protocols are RESTful APIs, followed by SOAP APIs.</p><div class="section" title="SOAP"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec50"/>SOAP</h2></div></div></div><p>SOAP <a id="id558" class="indexterm"/>was developed <a id="id559" class="indexterm"/>by Microsoft because <span class="strong"><strong>Distributed Component Object Model</strong></span> (<span class="strong"><strong>DCOM</strong></span>) is a binary protocol, which makes communication <a id="id560" class="indexterm"/>over the internet a bit more complicated. SOAP leverages XML instead, a more structured and human-readable language, to exchange messages between the client and the server.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note65"/>Note</h3><p>SOAP <a id="id561" class="indexterm"/>is standardized and is available for review in its entirety at <a class="ulink" href="https://www.w3.org/TR/soap12/">https://www.w3.org/TR/soap12/</a>.</p></div></div><p>A typical SOAP request to an API host looks like this:</p><div class="informalexample"><pre class="programlisting">POST /<span class="strong"><strong>UserData</strong></span> HTTP/1.1
Host: internal.api
Content-Type: application/soap+xml; charset=utf-8

&lt;?xml version="1.0"?&gt;

&lt;soap:Envelope  soap:encodingStyle="http://www.w3.org/2003/05/soap-encoding"&gt;

&lt;soap:Body &gt;
  &lt;m:GetUserRequest&gt;
    &lt;m:Name&gt;<span class="strong"><strong>Administrator</strong></span>&lt;/m:Name&gt;
  &lt;/m:GetUserRequest&gt;
&lt;/soap:Body&gt;

&lt;/soap:Envelope&gt;</pre></div><p>The response from the server, as you would expect, is also XML-formatted:</p><div class="informalexample"><pre class="programlisting">HTTP/1.1 200 OK
Content-Type: application/soap+xml; charset=utf-8

&lt;?xml version="1.0"?&gt;

&lt;soap:Envelope  soap:encodingStyle="http://www.w3.org/2003/05/soap-encoding"&gt;

&lt;soap:Body &gt;
  &lt;m:GetUserResponse&gt;
    <span class="strong"><strong>&lt;m:FullName&gt;Dade Murphy&lt;/m:FullName&gt;</strong></span>
    <span class="strong"><strong>&lt;m:Email&gt;dmurphy@webapp.internal&lt;/m:Email&gt;</strong></span>
    <span class="strong"><strong>&lt;m:IsAdmin&gt;True&lt;/m:IsAdmin&gt;</strong></span>
  &lt;/m:GetUserResponse&gt;
&lt;/soap:Body&gt;
&lt;/soap:Envelope&gt;</pre></div><p>There is a lot of <a id="id562" class="indexterm"/>overhead just to get user details. SOAP requires a <a id="id563" class="indexterm"/>header defining the XML version, the envelope specification, a body, and finally, the parameters. The response has similar structure requirements.</p><p>While SOAP is bloated by today's standards, its design is time-tested and has been around for a long time. As attackers, we are not concerned with performance or network bandwidth utilization. We just need to know all the possible injection points and understand how authentication is performed.</p><p>While the <code class="literal">Envelope</code>, <code class="literal">Body</code>, and <code class="literal">Header</code> tags are standardized, the contents of the body can vary depending on the request type, the application, and the web service implementation itself. The <code class="literal">GetUserRequest</code> action and its <code class="literal">Name</code> parameter are specific to the <code class="literal">/UserData</code> endpoint. To look for potential vulnerabilities, we need to know all the possible endpoints and their respective actions or parameters. How can we grab this information in a black-box scenario?</p><p>The SOAP XML structure for requests and responses is typically defined in a <span class="strong"><strong>Web Services Description Language</strong></span> (<span class="strong"><strong>WSDL</strong></span>) file. For <a id="id564" class="indexterm"/>public APIs, this is commonly available by querying the API itself directly and attaching <code class="literal">?wsdl</code> to the specific endpoint URL. If properly configured, the web service will respond with a large XML file with every possible action and parameter for that endpoint:</p><div class="mediaobject"><img src="graphics/B09238_11_01.jpg" alt="SOAP"/><div class="caption"><p>Figure 11.1: WSDL response for a public API</p></div></div><p>This file is <a id="id565" class="indexterm"/>extremely useful in an engagement but is not always available. In <a id="id566" class="indexterm"/>situations where the WSDL is not downloadable, it's best to reach out to the client and simply ask for the definitions or a list of sample requests. It's also possible that the client will refuse and want to test the API from an external threat's point of view.</p><p>The last resort is, obviously, just observing the web, mobile, or native applications interacting with the API, capturing the HTTP traffic in Burp, and replaying it through the Intruder or Scanner modules. This is certainly not ideal, as vulnerable parameters or actions may never be called under normal application operation. When the scope allows, it's always best to get the WSDL straight from the developer.</p></div><div class="section" title="REST"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec51"/>REST</h2></div></div></div><p>REST is<a id="id567" class="indexterm"/> the dominant architectural style you will likely encounter in modern applications. It is simple to implement and easy to read, and therefore widely adopted by developers. While <a id="id568" class="indexterm"/>not as mature as SOAP, it does provide a simple way to achieve decoupled design with microservices.</p><p>Much like SOAP, RESTful APIs operate over HTTP and they make heavy use of the protocol verbs, including but not limited to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GET</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">POST</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">PUT</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">DELETE</code></li></ul></div><p>If we wish to query information about a user, a RESTful API may implement a <code class="literal">GET</code> verb with a <code class="literal">/users</code> endpoint. The query would then be submitted via the URL parameters:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>GET /users?name=admin HTTP/1.1</strong></span>
Host: api.ecorp.local:8081
<span class="strong"><strong>Content-Type: application/json</strong></span>
<span class="strong"><strong>Accept: application/json</strong></span>
<span class="strong"><strong>Authorization: Bearer b2YgYmFkIG5ld3M</strong></span>
Cache-Control: no-cache</pre></div><p>Of note in the request are the <code class="literal">Content-Type</code>, <code class="literal">Accept</code>, and <code class="literal">Authorization</code> headers. The <code class="literal">Content-Type</code> header specifies in what format the incoming data is to be processed by the API. The <code class="literal">Accept</code> header specifies what format the client will accept in the response from the server. The typical APIs will support JSON or XML, or sometimes both. Finally, the <code class="literal">Authorization</code> header specifies a bearer token and will be required for endpoints that enforce authentication. This allows the server to identify which user is making the request and whether they are authorized to do so.</p><p>Some custom APIs might employ custom headers for authentication and authorization purposes, such as <code class="literal">X-Auth-Token</code>, but the principle is the same. Once we know how authentication and authorization tokens are passed between the client and the server, we can start looking for weaknesses.</p><p>The server response to our earlier request is predictably simple and easy to read:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>HTTP/1.0 200 OK</strong></span>
Server: WSGIServer/0.1 Python/2.7.11
Content-Type: text/json

{"user": {"name": "<span class="strong"><strong>admin</strong></span>", "id": 1, "fullname": "Dade Murphy"}}</pre></div><p>A <code class="literal">200</code> HTTP response indicates that it was successful, our token was valid, and we now have a JSON object with all the details concerning the admin user.</p><p>RESTful APIs<a id="id569" class="indexterm"/> typically use JSON for requests and responses, but there is no hard standard and <a id="id570" class="indexterm"/>developers may choose to use a custom XML protocol or even raw binary. This is unusual, as microservices interoperability and maintenance becomes difficult, but it is not unheard of.</p></div></div></div>
<div class="section" title="API authentication"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec62"/>API authentication</h1></div></div></div><p>Decoupling brings <a id="id571" class="indexterm"/>about a few more challenges when it comes to authentication and authorization. It's not uncommon to have an API that does not require authentication, but the chances are some web services you'll encounter will require their clients to authenticate in one way or another.</p><p>So, how do we achieve authentication with APIs? This process is not that different from a typical application. At its core, authentication requires that you provide something you know and, optionally, something you have, which corresponds to a record in the API's database. If that something you know and something you have is a secret and only the holder of this information, presumably, has access to it, the API can be reasonably sure that the client providing this information is given access. The API now only needs to track this particular client, since HTTP is stateless.</p><p>Traditional web applications will accept authentication data (something you know, along with a username and password combination) and may require a second factor (something you have, a one-time password, an SMS number, or a mobile push notification). Once the application has verified you, it will issue a session ID, which your browser will pass for subsequent authentication requests via cookies.</p><p>APIs are similar in that they require some sort of secret key or token to be passed back with each request that requires authentication. This token is usually generated by the API and given to the user after successfully authenticating via other means. While a typical web application will almost always use the <code class="literal">Cookie</code> header to track the session, APIs have a few options.</p><div class="section" title="Basic authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec52"/>Basic authentication</h2></div></div></div><p>Yes, this is also common<a id="id572" class="indexterm"/> in web applications but is generally not used in <a id="id573" class="indexterm"/>modern applications, due to security concerns. Basic authentication will pass the username and password in cleartext via the <code class="literal">Authorization</code> header:</p><div class="informalexample"><pre class="programlisting">GET /users?name=admin HTTP/1.1
Host: api.ecorp.local:8081
Content-Type: application/json
Accept: application/json
<span class="strong"><strong>Authorization: Basic YWRtaW46c2VjcmV0</strong></span>
Cache-Control: no-cache</pre></div><p>The obvious issues with this are that the credentials are flying over the wire in cleartext and attackers only need to capture one request to compromise the user. Session IDs and tokens will still provide attackers with access, but they can expire and can be blacklisted.</p><p>Basic authentication should be sent over HTTPS, since the user credentials are sent in plaintext over the wire. Modern APIs tend to avoid this type of authentication because credentials can be cached by proxies, can be intercepted using <span class="strong"><strong>man-in-the-middle</strong></span> (<span class="strong"><strong>MITM</strong></span>) attacks, or can be extracted from memory dumps. If the API uses LDAP to authenticate users to an Active Directory domain, it's not a good idea to have the user domain credentials flying over the wire with every API request.</p></div><div class="section" title="API keys"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec53"/>API keys</h2></div></div></div><p>A more common<a id="id574" class="indexterm"/> way to authenticate is by supplying a key or token with our API request. The key is unique to the account with access to the web service and should be kept secret, much like a password. Unlike a password, however, it is not (usually) generated by the user and thus is less likely to be reused in other applications. There's no industry standard on how to pass this value to APIs, although <span class="strong"><strong>Open Authorization</strong></span> (<span class="strong"><strong>OAuth</strong></span>) and SOAP <a id="id575" class="indexterm"/>have some requirements defined by the protocol. Custom headers, the <code class="literal">Cookie</code> header, and even through a <code class="literal">GET</code> parameter are some of the common ways tokens or keys are sent along with the request.</p><p>Using a <code class="literal">GET</code> URL parameter to pass the key is generally a bad idea because this value can be cached by browsers, proxies, and web server log files:</p><div class="informalexample"><pre class="programlisting">GET /users?name=admin&amp;<span class="strong"><strong>api_key=aG93IGFib3V0IGEgbmljZSBnYW1lIG9mIGNoZXNz</strong></span> HTTP/1.1
Host: api.ecorp.local:8081
Content-Type: application/json
Accept: application/json
Cache-Control: no-cache</pre></div><p>Another option is using a custom header to send the API key with the request. This is a slightly better alternative but still requires secrecy through HTTPS to prevent MITM attacks from <a id="id576" class="indexterm"/>capturing this value:</p><div class="informalexample"><pre class="programlisting">GET /users?name=admin HTTP/1.1
Host: api.ecorp.local:8081
Content-Type: application/json
Accept: application/json
<span class="strong"><strong>X-Auth-Token: aG93IGFib3V0IGEgbmljZSBnYW1lIG9mIGNoZXNz</strong></span>
Cache-Control: no-cache</pre></div></div><div class="section" title="Bearer authentication"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec54"/>Bearer authentication</h2></div></div></div><p>Similar to keys, bearer<a id="id577" class="indexterm"/> tokens are secret values that are usually passed via the <code class="literal">Authorization</code> HTTP header as well, but instead of using the <code class="literal">Basic</code> type, we use<a id="id578" class="indexterm"/> the <code class="literal">Bearer</code> type. For REST APIs, as long as the client and server agree on how to exchange this token, there is no standard defining this process and therefore you may see slight variations of this in the wild:</p><div class="informalexample"><pre class="programlisting">GET /users?name=admin HTTP/1.1
Host: api.ecorp.local:8081
Content-Type: application/json
Accept: application/json
<span class="strong"><strong>Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjEiLCJ1c2VyIjoiYWRtaW4iLCJpc19hZG1pbiI6dHJ1ZSwidHMiOjEwNDUwNzc1MH0.TstDSAEDcXFE2Q5SJMWWKIsXV3_krfE4EshejZXnnZw</strong></span>
Cache-Control: no-cache</pre></div><p>The preceding bearer token is an example of a JWT. It's a bit longer than a traditional opaque token, but it has some advantages.</p></div><div class="section" title="JWTs"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec55"/>JWTs</h2></div></div></div><p>JWTs are a <a id="id579" class="indexterm"/>relatively new authentication mechanism that is gaining market share with web services. They are a compact, self-contained method of passing information securely between two parties.</p><p>JWTs are versatile and easy to implement in authentication protocols. SOAP and OAuth can both easily implement JWT as the bearer.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note66"/>Note</h3><p>OAuth information can be found at <a class="ulink" href="https://oauth.net/2/">https://oauth.net/2/</a>.</p></div></div><p>JWTs are essentially claims that have been signed using either <span class="strong"><strong>hash-based message authentication code</strong></span> (<span class="strong"><strong>HMAC</strong></span>) and a secret <a id="id580" class="indexterm"/>key, or with an RSA key pair. HMAC is an algorithm that can be<a id="id581" class="indexterm"/> used to verify both the data integrity and the authentication of a message, which works well for JWTs. JWTs are a combination of a <code class="literal">base64url</code> encoded header, payload, and the corresponding signature:</p><div class="informalexample"><pre class="programlisting">base64url(<span class="strong"><strong>header</strong></span>) . base64url(<span class="strong"><strong>payload</strong></span>) . base64url(<span class="strong"><strong>signature</strong></span>)</pre></div><p>The header of the token will specify the algorithm used for signing and the payload will be the claim (for example, I am user1 and I am an administrator), while the third chunk will be the signature itself.</p><p>If we inspect the preceding bearer token, we can see the make-up of a typical JWT. There are three chunks of information separated by a period, encoded using URL-safe Base64.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note67"/>Note</h3><p>URL-safe Base64-encoded uses the same alphabet as traditional Base64, with the exception of replacing the characters <code class="literal">+</code> with <code class="literal">-</code> and <code class="literal">/</code> with <code class="literal">_</code>.</p></div></div><div class="informalexample"><pre class="programlisting">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.
eyJpZCI6IjEiLCJ1c2VyIjoiYWRtaW4iLCJpc19hZG1pbiI6dHJ1ZSwidHMiOjEwNDUwNzc1MH0
.
TstDSAEDcXFE2Q5SJMWWKIsXV3_krfE4EshejZXnnZw</pre></div><p>The first chunk is the header, describing the algorithm used for signing. In this case, HMAC with SHA-256. The type is defined as a JWT.</p><p>We can use JavaScript's <code class="literal">atob()</code> function in the browser console to decode the chunk to readable text:</p><div class="informalexample"><pre class="programlisting">&gt; atob('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9')
"{"alg":"<span class="strong"><strong>HS256</strong></span>","typ":"<span class="strong"><strong>JWT</strong></span>"}"</pre></div><p>The second chunk, or payload, is usually arbitrary data that makes a particular claim, also known as the payload. In this case, it tells the server that I am an administrative user called <code class="literal">admin</code>, with the user ID <code class="literal">1</code>, and a timestamp of <code class="literal">104507750</code>. Timestamps are a good idea, as they can prevent replay attacks.</p><div class="informalexample"><pre class="programlisting">&gt; atob('eyJpZCI6IjEiLCJ1c2VyIjoiYWRtaW4iLCJpc19hZG1pbiI6dHJ1ZSwidHMiOjEwNDUwNzc1MH0')
"{"id":"<span class="strong"><strong>1</strong></span>","user":"<span class="strong"><strong>admin</strong></span>","is_admin":<span class="strong"><strong>true</strong></span>,"ts":<span class="strong"><strong>104507750</strong></span>}"</pre></div><p>The final piece is a <code class="literal">base64url</code> encoded 32-byte SHA-256 HMAC signature.</p><p>When the API server receives this three-piece token, it will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Parse the header to determine the algorithm: HMAC SHA-256 in this case</li><li class="listitem" style="list-style-type: disc">Calculate the HMAC SHA-256 value of the <code class="literal">base64url</code> encoded first two chunks concatenated by a period:<div class="informalexample"><pre class="programlisting">HMAC-SHA256(base64url(header) + "." + base64url(payload), <span class="strong"><strong>"secret_key"</strong></span>)</pre></div></li><li class="listitem" style="list-style-type: disc">If the signature validates, consider the payload as valid as well</li></ul></div><div class="section" title="JWT quirks"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec11"/>JWT quirks</h3></div></div></div><p>While this<a id="id582" class="indexterm"/> process is currently cryptographically safe, there are a few ways we can play with this token to try to fool poor API implementations.</p><p>First of all, while the header and the payload are signed, we can actually modify them. The token data is within our control. The only portion we don't know is the secret key. If we modify the payload, the signature will fail and we expect the server to reject our request.</p><p>Remember, though, that the header chunk is parsed before the signature is verified. This is because the header contains instructions on how the API will verify the message. This means we could potentially change this data and break something in the implementation.</p><p>What's interesting about JWT is that<a id="id583" class="indexterm"/> the <span class="strong"><strong>Request for Comments</strong></span> (<span class="strong"><strong>RFC</strong></span>) specifies a supported signature algorithm called "none", which can be used by an implementation to assume that the token was validated by other means:</p><div class="mediaobject"><img src="graphics/B09238_11_02.jpg" alt="JWT quirks"/><div class="caption"><p>Figure 11.2: The RFC mention of an unsecured JWT using the "none" algorithm</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note68"/>Note</h3><p>The full JWT RFC is available<a id="id584" class="indexterm"/> here: <a class="ulink" href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a>.</p></div></div><p>Some JWT <a id="id585" class="indexterm"/>libraries will follow the standard and support this particular algorithm as well. So, what happens when we use the "none" algorithm with our preceding payload?</p><p>Our token would look like this, with no signature appended after the last period:</p><div class="informalexample"><pre class="programlisting">eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0
.
eyJpZCI6IjEiLCJ1c2VyIjoiYWRtaW4iLCJpc19hZG1pbiI6dHJ1ZSwidHMiOjEwNDUwNzc1MH0
.
[blank]</pre></div><p>The token will be verified and deemed valid if the server-side library adheres to the JWT RFC. We can test this modified token using the Burp Suite <span class="strong"><strong>JSON Web Tokens</strong></span> extension, which can be downloaded from the BApp Store:</p><div class="mediaobject"><img src="graphics/B09238_11_03.jpg" alt="JWT quirks"/><div class="caption"><p>Figure 11.3: JWT Burp extension</p></div></div><p>We can enter the <a id="id586" class="indexterm"/>JWT value in the first field and supply a dummy key. Since we are no longer using the keyed HMAC, this value will be ignored. The extension should confirm that the signature and JWT token are valid:</p><div class="mediaobject"><img src="graphics/B09238_11_04.jpg" alt="JWT quirks"/><div class="caption"><p>Figure 11.4: JWT with no signature deemed valid</p></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note69"/>Note</h3><p>More information on this type of attack can be<a id="id587" class="indexterm"/> found on Auth0: <a class="ulink" href="https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/">https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/</a>.</p></div></div><p>This simple attack could<a id="id588" class="indexterm"/> be devastating in an API that uses a library with an insecure JWT implementation. The ability to forge authentication tickets could be very useful to us as attackers.</p></div></div><div class="section" title="Burp JWT support"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec56"/>Burp JWT support</h2></div></div></div><p>Manually <a id="id589" class="indexterm"/>splitting the header, payload, and signature pieces is a bit tedious and we'd like to automate this process. If we are targeting the JWT implementation on the server, we may also want to modify some of the parameters. This can be tedious, especially if we have to recalculate the signature every time.</p><p>The <span class="strong"><strong>JWT4B</strong></span> extension was created to check requests for JWT data, parse it, and verify the signature, all in the Burp Suite user proxy.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note70"/>Note</h3><p>JWT4B<a id="id590" class="indexterm"/> is available for download on GitHub at <a class="ulink" href="https://github.com/mvetsch/JWT4B">https://github.com/mvetsch/JWT4B</a>.</p></div></div><p>Once we have downloaded the JWT4B JAR file to disk, we can load it manually into Burp. In the <span class="strong"><strong>Extender</strong></span> tab, under <span class="strong"><strong>Extensions,</strong></span> click the <span class="strong"><strong>Add</strong></span> button:</p><div class="mediaobject"><img src="graphics/B09238_11_05.jpg" alt="Burp JWT support"/><div class="caption"><p>Figure 11.5: The Burp Extensions tab</p></div></div><p>In the <span class="strong"><strong>Load Burp Extension</strong></span> popup window, we can tell Burp to load the JWT4B JAR file from the location on disk:</p><div class="mediaobject"><img src="graphics/B09238_11_06.jpg" alt="Burp JWT support"/><div class="caption"><p>Figure 11.6: Loading the JWT4B JAR extension file</p></div></div><p>JWT4B <a id="id591" class="indexterm"/>will allow us to intercept requests with authorization headers containing a JWT, replace the payload, and re-sign with either the same key (if we have it) or a random key, or even change the algorithm:</p><div class="mediaobject"><img src="graphics/B09238_11_07.jpg" alt="Burp JWT support"/><div class="caption"><p>Figure 11.7: Modifying JWTs on the fly</p></div></div><p>JWT4B makes attacking JWT implementations much simpler, as it can do some of the heavy-lifting for us.</p></div></div>
<div class="section" title="Postman"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec63"/>Postman</h1></div></div></div><p>When <a id="id592" class="indexterm"/>testing a typical web application, we first configure the system proxy to point to Burp Suite. Now, all of our requests can be inspected as we walk through the app. It's easy to launch attacks because these requests are built for us by the user interface that Burp can see over the wire. During normal operation, users enter data in a search field, for example, and the application constructs the <code class="literal">GET</code> or <code class="literal">POST</code> request with all the appropriate parameters, before sending it over the wire. All of these valid requests are now available for replay, modification, and scanning through the attack proxy. The discovery process is much simpler when there is a user interface to drive traffic generation.</p><p>If there is no user interface component and all we have is an API endpoint, and some documentation to work with, it is very tedious to build a series of <code class="literal">curl</code> requests and manually parse the responses. If authentication is required for interaction, requesting tokens would be a nightmare for complex web services.</p><p>
<span class="strong"><strong>Postman</strong></span> is a<a id="id593" class="indexterm"/> fantastic tool that we can use to build a collection of requests to the target API and make testing a breeze. This is especially true if there is cooperation from the client and the developers. To use testing time more efficiently, clients can provide us with a collection of already-generated requests, which can greatly speed up the application testing process.</p><p>Our engagements are usually time-sensitive and building attack payloads for a RESTful API is extremely time-consuming, even with documentation. A tool such as Postman supports <span class="strong"><strong>Collections</strong></span>, which are essentially a sequence of fully customizable API tests. Developers or other testers can create these collections, which include requests for every possible endpoint, with every possible parameter. They can even automate capturing the data, such as authentication tokens, and automatically insert it into subsequent requests. Postman makes testing APIs easy; developers love it and so do we.</p><p>As attackers, we can grab a fully decked-out collection from the client and just run it in our own environment. We can see exactly how the API is supposed to behave, as the developers intended it to. Postman also conveniently supports upstream proxies, so we can push all the properly formatted requests from the <span class="strong"><strong>Collection Runner</strong></span> through Burp and quickly start our attack through Burp's Intruder, Scanner, and Repeater modules.</p><p>There is a free version of Postman that supports up to 1000 calls per month, but if you find yourself testing more and more APIs, the Pro and Enterprise versions may be a good investment.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note71"/>Note</h3><p>Postman is available <a id="id594" class="indexterm"/>in Free, Pro, and Enterprise versions at <a class="ulink" href="https://www.getpostman.com/">https://www.getpostman.com/</a>.</p><p>For demonstration purposes, in this chapter, we will be using the vulnerable-API Docker application available from Matt Valdes at <a class="ulink" href="https://github.com/mattvaldes/vulnerable-api">https://github.com/mattvaldes/vulnerable-api</a>. In our demo, the API is running on <code class="literal">http://api.ecorp.local:8081/</code>.</p></div></div><p>With Docker installed, the vulnerable API can be downloaded and executed with the <code class="literal">docker run</code> command from the Linux terminal. We can also specify the port to expose in the container using the <code class="literal">-p</code> switch. Finally, the <code class="literal">--name</code> parameter will instruct Docker to go fetch the <code class="literal">mkam/vulnerable-api-demo</code> container:</p><div class="informalexample"><pre class="programlisting">root@kali:~# docker run -p 8081:8081 --name api mkam/vulnerable-api-demo
CRIT Supervisor running as root (no user in config file)
WARN Included extra file "/etc/supervisor/conf.d/vAPI.conf" during parsing
INFO RPC interface 'supervisor' initialized
CRIT Server 'unix_http_server' running without any HTTP authentication checking
INFO daemonizing the supervisord process
INFO supervisord started with pid 10
system type 0x794c7630 for '/var/log/supervisor/supervisord.log'. please report this to bug-coreutils@gnu.org. reverting to polling
INFO spawned: 'vAPI' with pid 12
INFO success: vAPI entered RUNNING state, process has stayed up for &gt; than 1 seconds (startsecs)</pre></div><p>To test functionality, we can use <code class="literal">curl</code> to perform a <code class="literal">GET</code> request on the root URL for the Docker API we've just launched:</p><div class="informalexample"><pre class="programlisting">root@kali:~# curl http://api.ecorp.local:8081/
{
  "response": {
    "Application": "vulnerable-api",
    "Status": "running"
  }
}</pre></div><div class="section" title="Installation"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec57"/>Installation</h2></div></div></div><p>There are Linux, Mac, and<a id="id595" class="indexterm"/> Windows versions of the Postman client. For simplicity's sake, we will use the Linux client on our attack machine, Kali. Installation is fairly straightforward on Windows and Mac, but on Linux you may need a couple of dependencies to get going.</p><p>The Postman client is an Electron application, making it fairly portable, but it does require <code class="literal">libgconf</code>, available in the Kali repositories. We can install this dependency using the <code class="literal">apt-get install</code> command from the terminal, as follows:</p><div class="informalexample"><pre class="programlisting">root@kali:~/tools# apt-get install libgconf-2-4
Reading package lists... Done
Building dependency tree       
[...]</pre></div><p>To grab the latest compiled Postman build, we can <code class="literal">wget</code> the gzipped tarball from its Linux x64 repository, available at <a class="ulink" href="https://dl.pstmn.io/download/latest/linux64">https://dl.pstmn.io/download/latest/linux64</a>. The <code class="literal">wget</code> command will save the file to <code class="literal">postman.tar.gz</code> in the local directory:</p><div class="informalexample"><pre class="programlisting">root@kali:~/tools# wget https://dl.pstmn.io/download/latest/linux64 -O postman.tar.gz
[...]
HTTP request sent, awaiting response... 200 OK
Length: 78707727 (75M) [application/gzip]
Saving to: 'postman.tar.gz'
[...]</pre></div><p>We will extract the contents to disk in our <code class="literal">tools</code> directory using the <code class="literal">tar zxvf</code> command, as shown:</p><div class="informalexample"><pre class="programlisting">root@kali:~/tools# tar zxvf postman.tar.gz
Postman/
Postman/snapshot_blob.bin
[...]</pre></div><p>With dependencies installed, Postman can be launched by calling the precompiled <code class="literal">Postman</code> binary. This is, predictably, located in the <code class="literal">Postman/</code> directory we've just extracted from the tarball:</p><div class="informalexample"><pre class="programlisting">root@kali:~/tools# ~/tools/Postman/Postman</pre></div><div class="mediaobject"><img src="graphics/B09238_11_08.jpg" alt="Installation"/><div class="caption"><p>Figure 11.8: Postman client running on Linux</p></div></div><p>To play around with basic functionality, we can create a new request and the default workspace opens.</p><p>The user interface is fairly self-explanatory for the most part. We can enter an API URL, change the HTTP verb, pass in custom headers, and even build a valid authorization with a couple of clicks.</p><p>As a test, we can issue<a id="id596" class="indexterm"/> the same request we made with <code class="literal">curl</code> earlier. The response will appear in the <span class="strong"><strong>Body</strong></span> tab, shown in the following screenshot, with the option to beautify the contents. Postman can automatically parse and format the response as XML, HTML, JSON, or plaintext. This is a welcome feature when the response is a massive blob of data:</p><div class="mediaobject"><img src="graphics/B09238_11_09.jpg" alt="Installation"/><div class="caption"><p>Figure 11.9: Sample Postman request to the API</p></div></div><p>One of Postman's strengths<a id="id597" class="indexterm"/> comes in its ability to record all of the requests we've made in the left-hand <span class="strong"><strong>History</strong></span> pane. This allows us, API developers or <span class="strong"><strong>Quality Assurance</strong></span> (<span class="strong"><strong>QA</strong></span>) analysts, to save requests and responses in Collections.</p><p>Collections can be exported by developers and imported by us during an engagement. This saves us a ton of time building our own queries and we can jump straight into looking for security vulnerabilities.</p></div><div class="section" title="Upstream proxy"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec58"/>Upstream proxy</h2></div></div></div><p>Postman also supports routing <a id="id598" class="indexterm"/>requests through either the system proxy or a custom server. The wise choice is Burp or OWASP ZAP. Once we import and run a collection, every request will be captured, and ready to be inspected and replayed.</p><p>Under <span class="strong"><strong>File</strong></span> and <span class="strong"><strong>SETTINGS</strong></span>, there is a <span class="strong"><strong>Proxy</strong></span> tab, which should let us point to the local Burp proxy, <code class="literal">127.0.0.1</code> on port <code class="literal">8080</code> by default:</p><div class="mediaobject"><img src="graphics/B09238_11_10.jpg" alt="Upstream proxy"/><div class="caption"><p>Figure 11.10: Postman upstream proxy configuration</p></div></div><p>All of our subsequent requests in <a id="id599" class="indexterm"/>Postman will show up in Burp's proxy HTTP history as well:</p><div class="mediaobject"><img src="graphics/B09238_11_11.jpg" alt="Upstream proxy"/><div class="caption"><p>Figure 11.11: Burp showing Postman-generated requests</p></div></div></div><div class="section" title="The environment"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec59"/>The environment</h2></div></div></div><p>In order to build effective <a id="id600" class="indexterm"/>collections, we should create a new Postman environment for each target API. Postman environments allow us to store data in variables that will prove useful for activities, such as passing authorization tokens between requests within a collection. To create a new environment, we can use the <span class="strong"><strong>Create New</strong></span> tab in the top-left corner:</p><div class="mediaobject"><img src="graphics/B09238_11_12.jpg" alt="The environment"/><div class="caption"><p>Figure 11.12: Creating a new environment in Postman</p></div></div><p>In the popup window, enter a <a id="id601" class="indexterm"/>meaningful name and click <span class="strong"><strong>Add</strong></span> to create the new empty environment:</p><div class="mediaobject"><img src="graphics/B09238_11_13.jpg" alt="The environment"/><div class="caption"><p>Figure 11.13: Adding a new Postman environment</p></div></div><p>Requests can now be <a id="id602" class="indexterm"/>associated with our ECorp API environment. Collections can also be run in specific environments, allowing the creation and passing of variables between requests.</p><p>The following figure shows a simple <code class="literal">GET</code> request queued to run in the ECorp API environment:</p><div class="mediaobject"><img src="graphics/B09238_11_14.jpg" alt="The environment"/><div class="caption"><p>Figure 11.14: Specifying an environment for a request</p></div></div></div><div class="section" title="Collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec60"/>Collections</h2></div></div></div><p>As we said earlier, a <a id="id603" class="indexterm"/>collection is<a id="id604" class="indexterm"/> simply a list of API requests in a particular sequence. They can be exported to JSON and imported into any Postman client, making them really portable.</p><p>To showcase the power of Postman collections, we will create one for our vulnerable API instance, <code class="literal">api.ecorp.local,</code> running on port <code class="literal">8081</code>.</p><p>If we look at the documentation for Matt Valdes' vulnerable API, we notice that most interactions require an authorization token passed via a custom <code class="literal">X-Auth-Token</code> HTTP header. While most RESTful APIs try to use the <code class="literal">Authorization</code> header for tokens, custom headers are not all that uncommon. This is why highly customizable tools such as Burp and Postman are ideal for security testing, as we can automate much of the work even when we encounter deviations from the norm.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note72"/>Note</h3><p>The documentation can be found in the <code class="literal">README.md</code> for <a class="ulink" href="https://github.com/mattvaldes/vulnerable-api">https://github.com/mattvaldes/vulnerable-api</a>.</p></div></div><p>The documentation states that we can get a new token if we send a <code class="literal">POST</code> to <code class="literal">/tokens</code> with the body containing JSON-formatted authentication data. The default credentials are <code class="literal">user1</code> with <code class="literal">pass1</code>. Our authentication request <code class="literal">POST</code> body should look like the following:</p><div class="informalexample"><pre class="programlisting">{
  "auth": {
    "passwordCredentials": {
       "username": "<span class="strong"><strong>user1</strong></span>",
        "password": "<span class="strong"><strong>pass1</strong></span>"
    }
  }
}</pre></div><p>The API will respond with another JSON-formatted object containing the token needed for subsequent authenticated requests:</p><div class="informalexample"><pre class="programlisting">{
  "access": {
    "token": {
      "expires": "<span class="strong"><strong>[Expiration Date]</strong></span>",
      "id": "<span class="strong"><strong>[Token]</strong></span>"
    },
    "user": {
      "id": 1,
      "name": "user1"
    }
  }
}</pre></div><p>We can then pass the <code class="literal">id</code> value to the <code class="literal">/user/1</code> endpoint via the <code class="literal">X-Auth-Token</code> header and the request should succeed:</p><div class="mediaobject"><img src="graphics/B09238_11_15.jpg" alt="Collections"/><div class="caption"><p>Figure 11.15: Successful authenticated request to the vulnerable API</p></div></div><p>Now that we have a sequence <a id="id605" class="indexterm"/>of requests, we want to create a collection and automate some of this testing.</p><p>Once again, from the <span class="strong"><strong>Create New</strong></span> button in the top-left, select <span class="strong"><strong>Collection</strong></span>:</p><div class="mediaobject"><img src="graphics/B09238_11_16.jpg" alt="Collections"/><div class="caption"><p>Figure 11.16: Creating a new collection</p></div></div><p>In the popup, we <a id="id606" class="indexterm"/>can enter the <a id="id607" class="indexterm"/>name, and a description if needed, before clicking the <span class="strong"><strong>Create</strong></span> button:</p><div class="mediaobject"><img src="graphics/B09238_11_17.jpg" alt="Collections"/><div class="caption"><p>Figure 11.17: Creating a new collection</p></div></div><p>All of the requests we've made are <a id="id608" class="indexterm"/>recorded in the <span class="strong"><strong>History</strong></span> tab in the workspace. We can<a id="id609" class="indexterm"/> highlight the ones we need for the collection and click the <span class="strong"><strong>Save</strong></span> button next to <span class="strong"><strong>Send</strong></span> in the top-right corner:</p><div class="mediaobject"><img src="graphics/B09238_11_18.jpg" alt="Collections"/><div class="caption"><p>Figure 11.18: Saving requests to a collection</p></div></div><p>At the bottom, we should see our new ECorp API collection and we can select it to save our requests:</p><div class="mediaobject"><img src="graphics/B09238_11_19.jpg" alt="Collections"/><div class="caption"><p>Figure 11.19: Selecting the destination collection</p></div></div><p>Repeat this process for <a id="id610" class="indexterm"/>any requests that must go into this collection. When run, we expect our <a id="id611" class="indexterm"/>collection to get a new token in the first request and make a second authenticated request to <code class="literal">/user/1</code> using the newly provided token:</p><div class="mediaobject"><img src="graphics/B09238_11_20.jpg" alt="Collections"/><div class="caption"><p>Figure 11.20: Authenticated Postman request</p></div></div><p>At this point, we can export and import it somewhere else. As it stands, our collection will run, but the token will not be passed through to the second request.</p><p>For this, we need to leverage a Postman feature called <span class="strong"><strong>Tests</strong></span>. Each request can be configured to execute tests and perform an action before continuing. Typically, these can be used to validate that the request was successful. Developers can leverage Tests to make sure the code they just pushed didn't break anything.</p><p>Tests are written in JavaScript, so a<a id="id612" class="indexterm"/> little bit of coding knowledge will go a long way. Thankfully, there are canned tests that we can repurpose for our needs.</p><p>For our <code class="literal">Get Auth Token</code> request in the ECorp API collection, the test needs to inspect the response, parse it as JSON, and extract the token ID. To pass it to another request, we can leverage the ECorp API environment and store the data in a variable we call <code class="literal">auth_token</code>.</p><p>The code to achieve this is fairly straightforward, albeit a bit strange if you're not familiar with JavaScript. Each <code class="literal">pm.test</code> entry is a separate test to be executed in the order listed. If any of the tests fail, the run will alert us:</p><div class="informalexample"><pre class="programlisting">pm.test(<span class="strong"><strong>"Status code is 200"</strong></span>, function () {
    <span class="strong"><strong>pm.response.to.have.status(200)</strong></span>;
});

pm.test<span class="strong"><strong>("Save Auth Token"</strong></span>, function () {
    var data = <span class="strong"><strong>pm.response.json()</strong></span>;
    pm.environment.set(<span class="strong"><strong>"auth_token"</strong></span>, <span class="strong"><strong>data['access']['token']['id']</strong></span>);
});</pre></div><p>The first test simply checks to see whether the HTTP response from the API was <code class="literal">200</code>. Anything else will throw an error during the collection run.</p><p>The second test will parse the response text as JSON and store it in the local <code class="literal">data</code> variable. If you recall the hierarchy of the <code class="literal">/tokens</code> response, we need to access the <code class="literal">id</code> value in the <code class="literal">access.token</code> field using the JavaScript array notation: <code class="literal">data['access']['token']['id']</code>.</p><p>Using the <code class="literal">pm.environment.set</code> function, we store the <code class="literal">id</code> value in the <code class="literal">auth_token</code> environment variable, making it available to other requests.</p><p>Each time this request in this<a id="id613" class="indexterm"/> collection runs, <code class="literal">auth_token</code> will be updated. Environments can be inspected by clicking the "eye" icon next to the name:</p><div class="mediaobject"><img src="graphics/B09238_11_21.jpg" alt="Collections"/><div class="caption"><p>Figure 11.21: Inspecting the Postman environment</p></div></div><p>Our second request to <code class="literal">/user/1</code> requires that we pass this value via the <code class="literal">X-Auth-Token</code> header. To do this, we add a new custom header and, for the value, we pull up a list of existing variables by typing <code class="literal">{{</code> in the <span class="strong"><strong>Value</strong></span> field. Postman will autocomplete existing variables for us:</p><div class="mediaobject"><img src="graphics/B09238_11_22.jpg" alt="Collections"/><div class="caption"><p>Figure 11.22: Using environment variables in requests</p></div></div><p>Clicking <span class="strong"><strong>Send</strong></span>, we can verify<a id="id614" class="indexterm"/> that the authenticated request succeeded:</p><div class="mediaobject"><img src="graphics/B09238_11_23.jpg" alt="Collections"/><div class="caption"><p>Figure 11.23: The authenticated request succeeds</p></div></div></div><div class="section" title="Collection Runner"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec61"/>Collection Runner</h2></div></div></div><p>Collections can be exported and <a id="id615" class="indexterm"/>imported using the familiar JSON format. Importing is a straightforward drag-and-drop operation. Developers and QAs can create these collections the same way we did earlier, export them, and as part of the engagement, send the file to us. This greatly simplifies our job of assessing the API, because the time-consuming work has already been done.</p><p>Once imported, our collection can be executed by the Postman Runner, accessible via the <span class="strong"><strong>Runner</strong></span> button near to the <span class="strong"><strong>New</strong></span> button in the menu:</p><div class="mediaobject"><img src="graphics/B09238_11_24.jpg" alt="Collection Runner"/><div class="caption"><p>Figure 11.24: Opening the Runner component</p></div></div><p>A new <span class="strong"><strong>Collection Runner</strong></span> window opens with all the imported collections. Select the ECorp API collection, the ECorp API environment, and click <span class="strong"><strong>Run ECorp API</strong></span>:</p><div class="mediaobject"><img src="graphics/B09238_11_25.jpg" alt="Collection Runner"/><div class="caption"><p>Figure 11.25: Running the ECorp collection</p></div></div><p>If all goes well, we should see <a id="id616" class="indexterm"/>green across the board, as our tests should have succeeded, meaning the authentication request was successful, the token was extracted, and the user query returned some data:</p><div class="mediaobject"><img src="graphics/B09238_11_26.jpg" alt="Collection Runner"/><div class="caption"><p>Figure 11.26: Successful Postman collection run</p></div></div><p>More importantly, all of the requests<a id="id617" class="indexterm"/> in the collection were passed upstream to our Burp proxy:</p><div class="mediaobject"><img src="graphics/B09238_11_27.jpg" alt="Collection Runner"/><div class="caption"><p>Figure 11.27: Burp-captured Postman collection run</p></div></div><p>From here, we can launch the Burp Scanner, Intruder, and Sequencer modules or replay any request to manipulate the data and look for vulnerabilities, as we normally do with traditional applications.</p></div></div>
<div class="section" title="Attack considerations"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec64"/>Attack considerations</h1></div></div></div><p>Targeting<a id="id618" class="indexterm"/> HTTP-based APIs is really no different than traditional web applications. We have to follow the same basic procedure:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify injection points</li><li class="listitem" style="list-style-type: disc">Send unexpected input and observe how the API behaves</li><li class="listitem" style="list-style-type: disc">Look for the usual suspects: SQLi, XXE, XSS, command injection, LFI, and RFI</li></ul></div><p>We can use all the tips and tricks we already know to find these issues, with some exceptions.</p><p>XSS vulnerabilities in a typical web application are easy to prove. You send the input, the input is reflected to the client as HTML or JavaScript, the browser renders the content, and the code executes.</p><p>With web services, the response is typically not rendered, primarily due to the <code class="literal">Content-Type</code> header set by the response. This is usually JSON or XML, which most browsers will not render as HTML. I say "most" because, unfortunately, some older browsers may still render the content, ignoring the content type stated by the server, and guessing based on the data in the response.</p><p>The following reflected input issue was discovered in the <code class="literal">api.ecorp.local/user/1</code> URL:</p><div class="informalexample"><pre class="programlisting">GET /user/1<span class="strong"><strong>&lt;svg%2fonload=alert(1)&gt;</strong></span> HTTP/1.1
Content-Type: application/json
X-Auth-Token: 3284bb036101252db23d4b119e60f7cc
cache-control: no-cache
Postman-Token: d5fba055-6935-4150-96fb-05c829c62779
User-Agent: PostmanRuntime/7.1.1
Accept: */*
Host: api.ecorp.local:8081
Connection: close</pre></div><p>We pass in the JavaScript payload and observe that the API reflects it back to the client, unescaped:</p><div class="informalexample"><pre class="programlisting">HTTP/1.0 200 OK
Date: Tue, 24 Apr 2018 17:14:03 GMT
Server: WSGIServer/0.1 Python/2.7.11
Content-Length: 80
<span class="strong"><strong>Content-Type: application/json</strong></span>

{"response": {"error": {"message": "user id 1<span class="strong"><strong>&lt;svg/onload=alert(1)&gt;</strong></span> not found"}}}</pre></div><p>Normally, this would be enough to prove the vulnerability exists and users can be targeted using social engineering. However, if you look closely, you'll notice the content type is set to <code class="literal">application/json</code>, and this means that modern browsers will not render the response as HTML, rendering our payload useless.</p><p>With APIs, we <a id="id619" class="indexterm"/>may still have hope. Web services are not typically accessed directly in a decoupled environment. It is possible that this particular API is leveraged by a web application. That error message could eventually find its way into a browser, which may eventually render our payload. What if all errors are logged by the web service and later neatly rendered in a status dashboard that's only visible internally? We would then have JavaScript code execution on any analyst who inspects the state of the API.</p><p>Web application scanners may identify this issue but mark it as informational, and it could be missed. It's important to consider the context around each vulnerability and how the affected service may be used by different clients. Remember out-of-band discovery and exploitation when attacking APIs, as not all vulnerabilities are immediately obvious.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec65"/>Summary</h1></div></div></div><p>In this chapter, we looked at different ways we can make attacking APIs easier. We described the two most common standards for web services, SOAP and REST. We looked at how authentication is handled and what role JWTs play in secure communication. We explored tools and extensions that help make us more efficient.</p><p>We also played around with Postman and the idea of automating discovery, and the testing of API inputs and endpoints.</p><p>APIs may be the latest trend for web and mobile applications, but they're not that different from the usual HTTP application. In fact, as we saw earlier, microservice architecture brings about some new challenges when it comes to authentication, which can be exploited alongside the usual server-side and client-side vulnerabilities. Coming up in the next chapter, we will look at CMSs, and some ways to discover and subvert them for fun and profit.</p></div></body></html>