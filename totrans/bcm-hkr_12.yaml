- en: Chapter 12. Attacking CMS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss attacking CMSs and WordPress in particular.
    It's hard to talk about web applications and not mention WordPress. WordPress
    is so common on the internet that you will likely come across many instances of
    it in your career. After all, almost a third of all websites are running on the
    platform and it is by far the most popular CMS.
  prefs: []
  type: TYPE_NORMAL
- en: There are alternatives to WordPress, including Drupal, Joomla, and other more
    modern applications, such as Ghost. All of these frameworks aim to make content
    publishing on the web easy and hassle free. You don't need to know JavaScript,
    HTML, PHP, or any other technology to get going. CMSs are generally extensible
    through plugins and highly customizable through themes. What sets WordPress apart
    is the sheer volume of installs across the internet. You are far more likely to come
    across a WordPress blog than a Ghost blog, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers love WordPress because the very thing that sets it apart from the
    competition — a massive community — also makes it difficult to secure. The reason
    WordPress has the lion's share of the market is because users don't need technical
    expertise to operate a foodie blog, and therein lies the problem. Those same non-technical
    users are less likely to update plugins or apply core patches, let alone harden
    their WordPress instance, and will not stray from that baseline through the years.
  prefs: []
  type: TYPE_NORMAL
- en: To be fair, auto-update has been added to WordPress as of version 3.7, but that
    is only effective if users actually update to version 3.7\. It should also be
    noted that even with auto-update functionality, for change management's sake,
    some companies may choose to opt out to maintain stability, at the expense of
    security.
  prefs: []
  type: TYPE_NORMAL
- en: Enterprises love WordPress and there are several companies that provide shared
    hosting and management as well. It's also not unusual to have someone in marketing
    set up a rogue instance that the security department is unaware of, and leave
    it running for years.
  prefs: []
  type: TYPE_NORMAL
- en: It's easy to pick on WordPress, but Drupal and Joomla make great targets as
    well. They suffer from the same problems with vulnerable plugins and themes, and
    seldomly updated installations. WordPress is the Goliath and we will focus our
    attention on it, but the attack methodology will translate to any content management
    framework, albeit the tools may differ slightly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the coming pages, we will look at WordPress attacks in depth and by the
    end, you should be comfortable with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing WordPress with various tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up persistence within the WordPress code once you get access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backdooring WordPress to harvest credentials and other interesting data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application assessment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as we''ve done with other applications, when we come across a WordPress
    or CMS instance, we have to do some reconnaissance: look for low-hanging fruit
    and try to understand what we''re up against. There are a few tools to get us
    going and we will look at a common scenario where they can help us to identify
    issues and exploit them.'
  prefs: []
  type: TYPE_NORMAL
- en: WPScan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing attackers reach for when they encounter a WordPress CMS application
    is usually WPScan. It is a well-built and frequently updated tool used to discover
    vulnerabilities and even guess credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'WPScan has many useful features, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Plugin and theme enumeration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passive and active discovery
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Username enumeration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Credential brute-forcing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerability scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A useful feature for assessments is the ability to pass all of its requests
    through a proxy, such as a local Burp Suite instance. This allows us to see the
    attack live and replay some of the payloads. During an engagement, this may be
    useful for recording activities and even passing in a polyglot or two.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using an upstream proxy with WPScan can generate a ton of data in Burp's proxy
    history, especially when performing a credential attack or active scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proxying our scan through Burp gives us some control over the outgoing connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WPScan](graphics/B09238_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Burp capturing WPScan web requests'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default user agent (WPScan vX.X.X) can be changed with the `--user-agent`
    switch or randomized with `--random-agent`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WPScan is available on Kali and most penetration testing distributions. It can
    also be found on [https://wpscan.org/](https://wpscan.org/) or cloned from GitHub:
    [https://github.com/wpscanteam/wpscan](https://github.com/wpscanteam/wpscan).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical engagement begins with a passive scan of the target using the `--url`
    parameter. The following command will launch a default scan on the `cookingwithfire.local`
    test blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, it appears there isn't much we can use for exploitation. There
    is a full-path disclosure vulnerability, which may come in handy if we need to
    find a place to drop a shell, for example. The **denial-of-service** (**DoS**)
    bug is not very interesting, as the majority of clients will not allow this type
    of exploitation, but it may be good to mention in the report as a possible route
    for disruption.
  prefs: []
  type: TYPE_NORMAL
- en: By default, WPScan performs a passive enumeration of plugins. This basically
    means that it will only detect a plugin if it is referenced somewhere on the site.
    If a plugin is disabled or more inconspicuous, we may need to execute an active
    enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Active scans will test whether known plugin files are present in the `wp-content`
    folder and alert on any existing vulnerabilities. This is done by sending a ton
    of URL requests to known paths and if there's a response, WPScan assumes the plugin
    is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify the type of scan we want to conduct, the `--enumerate` (`-e` for
    short) switch accepts several parameters for active detection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`u` – Look for usernames with IDs from 1 to 10'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u[10-20]` – Look for usernames with IDs from 10 to 20: `--enumerate u[15]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p` – Look for popular plugins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vp` – Show me only vulnerable plugins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ap` – Look for all known plugins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tt` – Search for timthumbs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t` – Enumerate popular themes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vt` – Show me only vulnerable themes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`at` – Look for all known themes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also provide multiple `--enumerate` (or `-e`) switches to enumerate
    themes, plugins, and usernames all in one shot. For example, this combination
    of switches will perform a fairly thorough scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go ahead and start an active enumeration of available plugins on our
    target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It appears **Google Document Embedder** was enumerated successfully and there
    are several critical vulnerabilities with proof of concept code publicly available.
  prefs: []
  type: TYPE_NORMAL
- en: The SQLi flaw tagged with `CVE-2014-9173` has a PoC on [https://www.exploit-db.com](https://www.exploit-db.com),
    which on Kali can be queried locally through `searchsploit`. This is a simple
    tool that searches the Kali local directory `/usr/share/exploitdb/`. This folder
    is frequently mirrored to the online database and it's useful in environments
    where maybe the internet is not easily accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can invoke `searchsploit` from the command-line with a search query as the
    first parameter, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![WPScan](graphics/B09238_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: searchsploit results for Google Document Embedder'
  prefs: []
  type: TYPE_NORMAL
- en: '`searchsploit` will list the `Exploit Title` and the associated `Path`, which
    is relative to `/usr/share/exploitdb/` on Kali distributions.'
  prefs: []
  type: TYPE_NORMAL
- en: In the PoC document `/usr/share/exploitdb/exploits/php/webapps/35371.txt`, researcher
    Kacper Szurek identifies the `gpid` URL parameter in the `wp-content/plugins/google-document-embedder/view.php`
    plugin file as the injection point.
  prefs: []
  type: TYPE_NORMAL
- en: sqlmap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to confirm this vulnerability in our target, we can jump to sqlmap,
    the de facto SQLi exploitation tool. sqlmap will help us to quickly generate payloads
    to test for injection in all of the popular **Database Management Systems** (**DBMS**),
    such as MySQL, PostgreSQL, MS SQL, and even Microsoft Access. To launch a new
    sqlmap session, we pass our full target URL via the `-u` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the target URL includes the `GET` query parameters as well, with
    some dummy data. If we don't tell sqlmap to target `gpid`, it will check every
    other parameter for injection as well. It makes for a great SQLi discovery, not
    just exploitation. Thanks to our `searchsploit` query, we know `gpid` is the vulnerable
    parameter and we can focus our attack on it specifically, with the `-p` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After a few minutes, sqlmap detects the backend to be MySQL and we can tell
    it to only check MySQL payloads against our target. This will greatly improve
    our chances of confirming the vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For the remaining tests, sqlmap will confirm the existence of the vulnerability
    and save the state locally. Subsequent attacks on the target will use the identified
    payload as a starting point to inject SQL statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to test this vulnerable plugin in your own WordPress instance, you
    can download version 2.5 of the Google Document Embedder plugin from [https://github.com/wp-plugins/google-document-embedder/tags?after=2.5.1](https://github.com/wp-plugins/google-document-embedder/tags?after=2.5.1).
  prefs: []
  type: TYPE_NORMAL
- en: Droopescan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although not as fully-featured as WPScan, droopescan does support more than
    just WordPress as a scanning target. It is ideal for Drupal instances and it can
    also do some basic scanning for Joomla.
  prefs: []
  type: TYPE_NORMAL
- en: 'Droopescan can be cloned from GitHub and quickly installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once extracted, we can install the dependencies manually using `pip` and passing
    in the `requirements.txt` option to `-r`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Droopescan can also be installed globally using the `setup.py` script and the
    `install` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To assess an application, droopescan can be launched with the `scan drupal`
    options and the target can be specified with the `-u` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This tool is a great start when looking at breaking into a Drupal, WordPress,
    or Joomla instance.
  prefs: []
  type: TYPE_NORMAL
- en: Arachni web scanner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Arachni** is a bit different from the more specialized tools discussed earlier.
    It is a full-featured modular framework with the capability of distributing scans
    through remote agents. When it is properly configured, it can be a powerful first
    step in assessing applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Arachni is free and open-source, and easily installed. It can be controlled
    via an easy-to-use web user interface or via the command-line. The framework can
    also be used to find HTML5 and Document Object Model vulnerabilities, which traditional
    scanners may miss.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Arachni pre-compiled binaries can be found on [http://www.arachni-scanner.com/](http://www.arachni-scanner.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Once extracted to disk, we have to create a user to be able to log onto the
    web interface. The `arachni_web_create_user` helper utility can be found in the
    `bin` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take care to clear your shell history if this is a production installation of Arachni.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web interface is launched using the `arachni_web` script in the same folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The web user interface runs on `http://localhost:9292` by default. Here we can
    initiate a new scan immediately or schedule it for later. We can also create a
    scan profile or interact with a remote agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arachni comes with three scanning profiles by default:'
  prefs: []
  type: TYPE_NORMAL
- en: Default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-Site Scripting (XSS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Default profile performs a variety of checks and looks for interesting files
    and low-hanging fruit. XSS and SQL injection are more focused profiles for the
    two vulnerability types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch a new scan using the web UI, select **New** under **Scans**, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arachni web scanner](graphics/B09238_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Starting a new Arachni scan'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also follow along as the scan is running by looking at the **Scans**
    page. The following figure shows a sample scan running against `jimsblog.local`,
    a WordPress installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arachni web scanner](graphics/B09238_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Arachni scan running'
  prefs: []
  type: TYPE_NORMAL
- en: 'Issues are listed below the scan status as they are found, but a more complete
    report is available once the scan completes. Under the **Issues** section, we
    can see what Arachni has discovered, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arachni web scanner](graphics/B09238_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Issues identified by Arachni'
  prefs: []
  type: TYPE_NORMAL
- en: The SQL injection scan profile in Arachni can also be used in a scan to verify
    the issue we found earlier with WPScan, in the `cookingwithfire.local` blog. This particular
    profile should complete much faster than the default scan.
  prefs: []
  type: TYPE_NORMAL
- en: '![Arachni web scanner](graphics/B09238_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: SQL injection found by Arachni'
  prefs: []
  type: TYPE_NORMAL
- en: The keen eye will notice that Arachni found a time-based blind SQL injection
    where sqlmap was able to confirm the vulnerability using an error-based technique.
    Technically, both techniques can be used to exploit this particular application,
    but the error-based technique is preferred. Time-based injection attacks are inherently
    slow. If Arachni finds a time-based blind SQL injection vulnerability, it may
    be a good idea to aim sqlmap at the same URL and see whether anything more reliable
    can be identified.
  prefs: []
  type: TYPE_NORMAL
- en: Backdooring the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we obtain some access to a CMS instance, such as WordPress, Drupal, or
    Joomla, there are a couple of ways to persist or even escalate privileges horizontally
    or vertically. We can inject malicious PHP code, which will allow us to gain shell
    access at will. Code execution is great, but in some scenarios, we don't necessarily
    need it. There are other ways to exploit the application. Alternatively, we can
    modify the CMS core files to capture credentials in cleartext as users and administrators
    log in.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these techniques require some kind of elevated privilege and that begs
    the question, why bother if we already have this type of access to the website?
    We'll look at a couple of situations where backdooring may help our engagement.
    If we have administrative access to the WordPress instance but no shell access,
    we can leverage the UI to spawn a reverse shell and persist access, should the
    password reset. If we have standard user shell access but not much else, capturing
    credentials in cleartext may be a great way to move laterally or escalate privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When attacking CMS installations, such as WordPress, we may find ourselves with
    administrative credentials in hand. Maybe we successfully enumerated users with
    WPScan and subsequently brute-forced credentials for a privileged user. This is
    more common than you'd expect, especially in environments where WordPress is either
    temporarily stood up for development purposes or just brought up and forgotten.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore this scenario using the `--enumerate u` option for `wpscan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The results show us at least two users that we can target for a login brute-force
    attack. WPScan can brute-force the credentials for a particular account using
    the `--usernames` switch and a wordlist provided by `--passwords`.
  prefs: []
  type: TYPE_NORMAL
- en: For this attack, we will use SecLists' `rockyou-10.txt` wordlist and we'll target
    `mary`. As before, we can invoke `wpscan` with the `--url` parameter, then we
    will specify a username and point the `passwords` parameter to the `rockyou-10.txt`
    file from SecLists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After a short while, the credentials for `mary` are confirmed and we are free
    to login as this user.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in through the WordPress UI, we notice `mary` has elevated access to
    the blog. We can use this account to spawn a reverse shell, which will give us
    access to the underlying operating system.
  prefs: []
  type: TYPE_NORMAL
- en: We can accomplish this easily through either Metasploit or through the administrative
    panel itself. The Metasploit method is a bit noisy and if it fails, it may leave
    behind artifacts that could alert administrators if not cleaned up in time. In
    some situations, stealth is not paramount, however, and this module will work
    just fine.
  prefs: []
  type: TYPE_NORMAL
- en: The Metasploit module `wp_admin_shell_upload` will connect to the WordPress
    site and authenticate with the credentials we've just discovered. It will proceed
    to upload a malicious plugin, which will spawn a reverse Meterpreter shell to
    our attack machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'On our Kali instance, as before, we can launch the Metasploit interface using
    the `msfconsole` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s load the `wp_admin_shell_upload` exploit with the Metasploit `use` command,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There are a few options we need to fill in with the right information before
    we can launch the exploit and hopefully get a shell back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute the `exploit` module using the `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It appears the module ran successfully and spawned a Meterpreter session back
    to our attack machine. Metasploit has dropped in the `meterpreter` prompt and
    now we can issue commands on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: While we do have access, there is a problem with this shell. It does not persist.
    If the server is restarted, the Meterpreter session will drop. If `mary` changes
    their password, we will lose access to the application altogether.
  prefs: []
  type: TYPE_NORMAL
- en: We have to get a bit more creative to maintain our access to the site. Thankfully,
    since it is so customizable, WordPress provides a file editor for plugins and
    themes. If we can modify a theme file and inject reverse shell code, every time
    we call it via the web, we will have access. If the administrator password changes
    tomorrow, we can still get back on.
  prefs: []
  type: TYPE_NORMAL
- en: In the WordPress admin panel, the **Themes** section links to an **Editor**,
    which can be used to modify PHP files belonging to any themes installed. It's
    a good idea to pick a theme that is disabled, in case we modify a file that is
    frequently accessed and users notice something is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Twenty Seventeen is the default WordPress theme and in this installation, it
    is not the primary theme. We can modify the `404.php` page and inject our code
    in there without alerting anyone.
  prefs: []
  type: TYPE_NORMAL
- en: '![Persistence](graphics/B09238_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: WordPress theme file editor'
  prefs: []
  type: TYPE_NORMAL
- en: We can generate a new PHP reverse shell using Metasploit by loading the `payload/php/meterpreter/reverse_tcp
    payload` module. The `LHOST` option should match our local hostname or IP, and
    the `LPORT` will be a local port for Metasploit to listen for incoming reverse
    shells. The target, once exploited, will connect back to us on this port.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Metasploit console, we can load it with the `use` command, as we did
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The payload `php/meterpreter/reverse_tcp` is a Meterpreter stager written in
    PHP and while it's not ideal from a stability standpoint, it does provide us with
    most of the functionality of a typical Meterpreter reverse shell.
  prefs: []
  type: TYPE_NORMAL
- en: When loading a payload within Metasploit, as opposed to generating one with
    the MSFvenom tool, we have the `generate` command available to us. This command
    can show us all the options available for creating a new payload.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For a PHP payload, not many of these switches will have an impact. We can generate
    the raw payload, which would be the PHP code for the stager. We don't have to
    write it to a file; it's typically fairly small and we can copy it straight from
    the terminal output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the `generate` command is a long, minified piece of PHP code,
    which we can further obfuscate by encoding it to Base64 using the `-E` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It really depends on what the injection point allows. We may need to Base64-encode
    the staging PHP code in order to bypass some rudimentary intrusion detection system
    or antivirus agent. If anyone looks at the source, an encoded payload does look
    a bit more suspicious among properly formatted code, so we'd have to really consider
    how stealthy we want to be.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure our code blends in more with the rest of the `404.php` page, we
    can use a source code beautifier like **CyberChef**. Let's take the non-Base64-encoded
    raw PHP code and run it through the CyberChef tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the **Recipe** pane, we can add the **Generic Code Beautify** operation.
    Our raw PHP code will go in the **Input** section. To beautify our code, we simply
    have to click **Bake!** at the bottom of the screen, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Persistence](graphics/B09238_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: CyberChef code beautifier'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CyberChef is a great tool with a ton of features. Code beautification is just
    scratching the surface of what it can do. CyberChef is developed by GCHQ and available
    for free to use online or to download at [https://gchq.github.io/CyberChef](https://gchq.github.io/CyberChef)
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can grab the beautified payload and paste it right into the
    WordPress theme editor. We need to add the code immediately before the `get_header()`
    function is called. This is because `404.php` was meant to be `include()`-d in
    another page that loads the definition for this function. When we call the `404`
    page directly, `get_header()` will not be defined and PHP will throw a fatal error.
    Our shell code will not be executed. We have to be aware of these types of issues
    when we are modifying anything on the target. Ideally, if time permits, we setup
    a similar test environment and check to see how the application handles our modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Meterpreter payload will fit nicely just above the `get_header()` function
    on line 12, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Persistence](graphics/B09238_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: 404.php page editor payload injection location'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the code in this location should prevent any PHP errors from interfering
    with our malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Persistence](graphics/B09238_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: Our malicious payload blending in with the rest of 404.php'
  prefs: []
  type: TYPE_NORMAL
- en: Before we execute the backdoor that we've just injected, we have to make sure
    we have a handler running on our attack machine to grab the incoming connections
    from the victim.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we load the `exploit/multi/handler` module in the Metasploit console
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to specify which payload type the handler should be configured for
    using the `set PAYLOAD` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to make sure the payload options match what we chose when we generated
    the PHP code earlier. Both of these options can also be configured with the `set`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can also configure the handler to accept multiple connections and run in
    the background. New sessions will be created automatically; we wouldn't have to
    run the handler every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExitOnSession` options can be set to `false` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the handler with the `-j` option, which will send it to the
    background, ready for incoming connections from our victim:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The backdoored `404.php` file is located in the `wp-content/themes/twentyseventeen/`
    folder on the target application and can be called directly with `curl`. This
    will execute our backdoor and spawn a new Meterpreter session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cur`l command appears to hang, but a few seconds later, we have shell
    access. We can see the victim establishing a Meterpreter session, which we can
    interact with using the `sessions -i` command, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we can issue commands directly to the target through the Meterpreter
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With shell access, we can attempt to escalate privileges, move laterally, or
    even extract more credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Credential exfiltration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider another scenario where we have exploited a vulnerability in the website,
    granting us shell access to the server. Maybe the WordPress site itself is patched
    and user passwords are complex, but if the WordPress installation is hosted on
    a shared system, it is not uncommon for attackers to gain shell access through
    an unrelated component of the site. Perhaps we managed to upload a web shell or
    even force the web server to spawn a reverse shell back to our machine through
    a command injection flaw. In the earlier scenario, we had guessed the password
    of `mary`, but what if we wanted more? What if the blog owner `msmith` has access
    to other systems?
  prefs: []
  type: TYPE_NORMAL
- en: Password reuse is a problem that likely will not go away anytime soon and there
    is value in grabbing the site administrator's password. The same password could
    work for VPN or OWA, or even the root user on the application server itself.
  prefs: []
  type: TYPE_NORMAL
- en: Most modern web server software, such as Apache2, NGINX, and IIS, runs applications
    with a low-privileged user context and thus a PHP shell would have limited access
    to the underlying server. While the web user can't do much to the server itself,
    it can interact with the site source code, including that of the CMS instance.
    We may look for ways to escalate privilege using a local exploit, but if unsuccessful
    or strapped for time, it may make more sense to backdoor the site code and collect
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous scenario, we have gained shell access through the user `mary`.
    Once inside, we can inspect the `wp-config.php` for potential locations for injection.
    We can see the database credentials that WordPress requires to function properly.
    This could be our first target, since all WordPress credentials are stored there,
    albeit hashed. If we can retrieve these hashed passwords, we may be able to crack
    them offline. Configuration files are common for CMSs and if we have read access
    to the application server, these should be one of the first things we harvest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We could grab these plaintext credentials and connect to the database using
    a MySQL client. We can then proceed to dump the user table and any hashes within.
    In your travels, you will likely come across more hardened MySQL instances, which
    typically will not allow login from just any remote host. The MySQL instance may
    also be firewalled or only listening on `127.0.0.1` and we may not be able to
    connect from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get around these types of restrictions, we''d have to pivot the connection
    through our reverse shell session, which we''ve established earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to add a route in Metasploit that will forward any connections
    through an active Meterpreter session. In this case, we want to connect to the
    MySQL instance listening on the server loopback: `127.0.0.1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Metasploit `route add` command requires we specify a network range and
    a Meterpreter session ID. In our case, we will be targeting only the `127.0.0.1`
    address, therefore a `/32` is in order. We also want to send all our packets through
    session `8`, in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To make use of this route, we need to launch a proxy server within Metasploit,
    which we can use together with ProxyChains to send packets through our Meterpreter
    session.
  prefs: []
  type: TYPE_NORMAL
- en: The `auxiliary/server/socks4a` module will allow us to spawn a SOCKS4 server
    on the attack machine and using the previously added route, any traffic destined
    for `127.0.0.1` will be forwarded through our session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s load the module and set the `SRVHOST` and `SRVPORT` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be able to see our SOCKS server running in the background by executing
    the Metasploit `jobs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the ProxyChains configuration file `/etc/proxychains.conf` should be
    modified to point to our newly spawned SOCKS server, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we use the `proxychains` binary in our Kali terminal to wrap the MySQL
    client connection to the target''s MySQL instance using the credentials from `wp-config.php`,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This WordPress database user will likely have limited access to the server
    as well, but it should be enough for our purposes. We can see the WordPress database
    and we can enumerate its tables and data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to grab the usernames and hashes stored in the `wp_users` table using
    a simple MySQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With the password hash of `msmith` in hand, we can launch John the Ripper on
    our Kali machine in an attempt to crack it. We can save the hash locally and run
    `john` against it, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your password cracking rig and the password complexity, this may
    take a while. It may not even be feasible during a typical engagement and you
    may need an alternative.
  prefs: []
  type: TYPE_NORMAL
- en: A smarter way to get the plaintext credentials is to backdoor the CMS code for
    the login system and to capture the credentials in cleartext as the target user
    (or users) logs in to the application. This particular attack requires that the
    user we have control over can modify WordPress files on disk. Some installations
    will not allow the webserver user to write to the disk as a security precaution,
    but it is not uncommon for administrators to loosen this control during the lifetime
    of the application. This attack is also useful if we have full root access to
    the target server as well. As I mentioned before, there's value in capturing credentials
    in cleartext, especially when the goal is lateral movement or sensitive data access.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function within WordPress that handles authentication is called `wp_signon()`
    and the WordPress Codex describes it in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Credential exfiltration](graphics/B09238_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: WordPress Function Reference for wp_signon'
  prefs: []
  type: TYPE_NORMAL
- en: The `signon` function is defined in the `wp-includes/user.php` WordPress core
    file. There are several lines of code that verify the credentials passed to the
    function from other modules, such as `wp-login.php`.
  prefs: []
  type: TYPE_NORMAL
- en: We want to intercept the cleartext credentials and either exfiltrate them to
    our C2 server or store them somewhere on the website for later retrieval, or both.
    There are, of course, pros and cons to both methods of exfiltration. Sending the
    data over the wire can be picked up as unusual traffic by intrusion detection
    systems or egress proxies, but it ensures we get the credentials as soon as they're
    entered, provided the transmission is not blocked, of course. Storing the data
    locally would not trip up any network monitors but if server administrators look
    closely at the application file system, extra files on the server may raise some
    eyebrows.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `wp_signon` function, credentials are either passed in through the
    `$credentials` variable or for new logins, through the PHP global `$_POST` variable.
    We can JSON-encode this incoming value, Base64-encode the results, and either
    write them to disk or send them over the wire. The double encoding is mostly for
    network transmission simplicity's sake and it also slightly obfuscates the data
    we are exfiltrating.
  prefs: []
  type: TYPE_NORMAL
- en: PHP provides two handy functions we can inject into the `wp_signon` function
    to exfiltrate the WordPress credentials quickly and easily.
  prefs: []
  type: TYPE_NORMAL
- en: '`file_put_contents()` allows us to write to disk, anywhere the web user has
    access to write to. For WordPress specifically, since it allows the upload of
    data, `wp-content/uploads` is usually writeable by the webserver. Other CMSs will
    have similar access to other directories that we can use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: PHP's `file_get_contents()` function allows us to make web requests to our C2
    server and we can pass in the credentials via the URL. We'll be able to see the
    data in the C2 logs. For network exfiltration, we should prepend the function
    with the `@` character, so that PHP suppresses any errors, should there be any
    network issues. If the C2 goes down or is otherwise unreachable, we don't want
    to alert users of a potential security issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that URL exfiltration could introduce noticeable delays in
    the site, which could alert users of a potential compromise. If stealth is paramount,
    it may be better to store the data locally, retrieve it through the web, and delete
    it after the engagement is over.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our credential stealer, we can use either one (or both) of the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To recap, during user login, our backdoor will:'
  prefs: []
  type: TYPE_NORMAL
- en: Grab the cleartext credentials stored in the `$_POST` global
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encode them in JSON and Base64 for easy transmission and obfuscation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store them on disk in the `wp-content/uploads/.index.php.swp` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send them to our C2 via the URL `http://pingback.c2.spider.ml/ping.php`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The backdoor code will be added just before the `wp_signon` function returns.
    This ensures we only capture valid credentials. The `wp_signon` function will
    return well before our code if the credentials supplied are invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to inject our code in the appropriate spot in `wp-includes/user.php`.
    Credentials are checked by `wp_signon` and are considered valid towards the end of
    the function, before the last `return` statement. This is where we need to put our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a user, or two or three users, successfully login, we can see the plaintext
    credentials in the `wp-content/uploads/.index.php.swp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The C2 has also recorded the same credentials in the connection log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we decode the Base64 data, we can see the password of `msmith`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Attempting to crack the hash we grabbed from the database would've likely been
    unsuccessful for `msmith`. Thankfully, we were able to modify the CMS code to
    capture credentials in cleartext, without disrupting the target and its users.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a closer look at attacking CMSs, in particular WordPress.
    While we did pick on WordPress quite heavily, it's important to note that similar
    issues and vulnerabilities can be found in its competitors' software as well.
    Drupal and Joomla usually come up in the CMS conversation and they're no strangers
    to poorly written plugins or badly configured instances.
  prefs: []
  type: TYPE_NORMAL
- en: We were able to assess a target CMS using WPScan and Arachni, and even look
    at options for privilege escalation or lateral movement once some access was obtained.
    We also looked at backdooring code to persist our access and even modifying the
    CMS core source files to exfiltrate cleartext credentials to our C2 server.
  prefs: []
  type: TYPE_NORMAL
