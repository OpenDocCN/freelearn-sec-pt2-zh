["```\n resource \"google_compute_firewall\" \"allow-ssh-from-my-ip\" {  name    = \"allow-ssh-from-my-ip\"\n  network = local.net_02\n  allow {\n    protocol = \"tcp\"\n    ports    = [\"22\"]\n  }source_ranges = [\"${var.my_ip}/32\"]\n}\n```", "```\n    git clone **https://github.com/tfutils/tfenv.git** ~/.tfenv\n    ```", "```\n    mkdir ~/bin\n    ```", "```\n    ls -hF ~/.tfenv/bin/\n    ```", "```\n    terraform*  tfenv*\n    ```", "```\n    ln -s ~/.tfenv/bin/* ~/bin/\n    ```", "```\n    readlink -f ~/bin/*\n    ```", "```\n    /home/cloudshell-user/.tfenv/bin/terraform /home/cloudshell-user/.tfenv/bin/tfenv\n    ```", "```\n    tfenv install 1.3.9\n    ```", "```\n    tfenv use 1.3.9\n    ```", "```\n    terraform --version\n    ```", "```\n    Terraform v1.3.9 on linux_amd64\n    ```", "```\n    mkdir hello_terraform\n    cd hello_terraform\n    ```", "```\n    touch main.tf\n    ```", "```\n    vim main.tf\n    ```", "```\n     resource \"null_resource\" \"hello\" {\n      provisioner \"local-exec\" {\n        command = \"touch hello.txt\"\n      }\n    }\n    ```", "```\n    terraform init\n    ```", "```\n    sudo yum install tree -y\n    ```", "```\n    tree -a\n    ```", "```\n    terraform plan\n    ```", "```\n    Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:\n      + create\n    Terraform will perform the following actions:\n      # null_resource.hello will be created\n      + resource \"null_resource\" \"hello\" {\n          + id = (known after apply)\n        }\n    Plan: 1 to add, 0 to change, 0 to destroy.\n    ```", "```\n    terraform apply\n    ```", "```\n     null_resource.hello: Creating...null_resource.hello: Provisioning with 'local-exec'... null_resource.hello (local-exec): Executing: [\"/bin/sh\" \"-c\" \"touch hello.txt\"]\n    null_resource.hello: Creation complete after 0s [id=2409621687302957875]\n    ```", "```\n    ls\n    ```", "```\n    hello.txt  main.tf  terraform.tfstate\n    ```", "```\n    cat terraform.tfstate\n    ```", "```\n    {\n      \"version\": 4,\n      \"terraform_version\": \"1.3.9\",\n      \"serial\": 1,\n      \"lineage\": \"6e0599fb-00c6-e724-2dd1-e600ea7726a0\",\n      \"outputs\": {},\n      \"resources\": [\n        {\n          \"mode\": \"managed\",\n          \"type\": \"null_resource\",\n          \"name\": \"hello\",\n           ...     }\n      ],\n      \"check_results\": null\n    }\n    ```", "```\n    cd ..\n    ```", "```\n    rm -rf hello_terraform\n    ```", "```\n    resource \"<type>\" \"<name>\" {\n      <argument 01> = <value 01>\n      <argument 02> = <value 02>\n    }\n    ```", "```\n    resource \"azurerm_public_ip\" \"public_ip_03\" {name= \"public-ip-03\"\n      ...   resource_group_name = local.rg_02.nameallocation_method   = \"Dynamic\"\n    }\n    ```", "```\n    provider \"<name>\" {\n      <argument 01> = <value 01>\n      <argument 02> = <value 02>\n    }\n    ```", "```\n    provider \"aws\" {\n      alias  = \"default\"\n      region = \"us-east-1\"\n    }\n    ```", "```\n    data \"<type>\" \"<name>\" {\n      ... }\n    ```", "```\n    data \"aws_ip_ranges\" \"ec2_instance_connect\" {\n      regions  = [\"us-east-1\"]\n      services = [\"EC2_INSTANCE_CONNECT\"]\n    }\n    ```", "```\n    locals {\n      <name 01> = <expression 01>\n      <name 02> = <expression 02>\n    }\n    ```", "```\n    locals {\n      net_01 = google_compute_network.vpc_01.self_linknet_02 = google_compute_network.vpc_02.self_link\n    }\n    ```", "```\n    variable \"<name>\" {\n      type = <type>\n      default = <value>\n    }\n    ```", "```\n    variable \"instance_name\" {\n        type = string\n        default = \"kali\"\n    }\n    ```", "```\n    output \"<name>\" {\n      value = <expression>\n    }\n    ```", "```\n    output \"vm_kali_public_ip\" {\n      value = local.vm_kali.public_ip_address\n    }\n    ```", "```\n    mkdir basics && cd basics\n    ```", "```\n    touch main.tf\n    ```", "```\n    vim main.tf\n    ```", "```\n     terraform {\n      required_providers {\n        aws = {\n          source  = \"hashicorp/aws\"\n          version = \"~> 4.0\"\n        }\n      }\n    }\n    provider \"aws\" {\n      alias  = \"default\"\n      region = \"us-east-1\"\n    }\n    ```", "```\n    data \"aws_canonical_user_id\" \"current\" {}\n    ```", "```\n     locals {\n      user = data.aws_canonical_user_id.current\n      name = local.user.display_name\n    }\n    ```", "```\n     resource \"null_resource\" \"debug\" {\n      provisioner \"local-exec\" {\n        command = \"echo NAME=${local.name}\"\n      }\n    }\n    ```", "```\n    terraform init\n    ```", "```\n    Initializing the backend... Initializing provider plugins... - Finding hashicorp/aws versions matching \"~> 4.0\"... - Finding latest version of hashicorp/null... - Installing hashicorp/null v3.2.1... - Installed hashicorp/null v3.2.1 (signed by HashiCorp)\n    - Installing hashicorp/aws v4.57.0... - Installed hashicorp/aws v4.57.0 (signed by HashiCorp)\n    ```", "```\n    terraform plan\n    ```", "```\n    terraform apply -auto-approve\n    ```", "```\n    Plan: 1 to add, 0 to change, 0 to destroy. null_resource.debug: Creating... null_resource.debug: Provisioning with 'local-exec'... null_resource.debug (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo NAME=john.doe\"]\n    null_resource.debug (local-exec): NAME=john.doe null_resource.debug: Creation complete after 0s [id=6076855428035859265]\n    ```", "```\n    vim main.tf\n    ```", "```\n     command = \"echo NAME=${local.name}\"\n    ```", "```\n    command = \"echo ID=${local.user.id}\"\n    ```", "```\n    terraform fmt\n    ```", "```\n    terraform plan\n    ```", "```\n    No changes. Your infrastructure matches the configuration. Terraform has compared your real infrastructure against your configuration and found no differences, so no changes are needed.\n    ```", "```\n    terraform apply -auto-approve \\\n    -replace=null_resource.debug\n    ```", "```\n    null_resource.debug: Destroying... [id=6076855428035859265]\n    null_resource.debug: Destruction complete after 0s\n    null_resource.debug: Creating... null_resource.debug: Provisioning with 'local-exec'... null_resource.debug (local-exec): Executing: [\"/bin/sh\" \"-c\" \"echo ID=abcdefghabcdefghabcdefghabcdefghabcdefghabcdefgh\"]\n    null_resource.debug (local-exec): ID=abcdefghabcdefghabcdefghabcdefghabcdefghabcdefgh null_resource.debug: Creation complete after 0s [id=9009508010716198837]\n    ```", "```\n    cd ..\n    ```", "```\n    rm -rf basics\n    ```", "```\n    mkdir vulnerable_s3_lab\n    cd vulnerable_s3_lab\n    ```", "```\n    touch main.tf\n    ```", "```\n    vim main.tf\n    ```", "```\n     terraform {\n      required_providers {\n        aws = {\n          source  = \"hashicorp/aws\"\n          version = \"~> 4.0\"\n        }\n      }\n    }\n    provider \"aws\" {\n      alias  = \"default\"\n      region = \"us-east-1\"\n    }\n    ```", "```\n     resource \"aws_s3_bucket\" \"bucket\" {\n      bucket = \"<INSERT BUCKET NAME>\"\n      force_destroy = true\n    }\n    ```", "```\n    terraform init\n    ```", "```\n    terraform plan\n    ```", "```\n    terraform apply -auto-approve\n    ```", "```\n     aws s3 ls | grep <INSERT BUCKET NAME>\n    ```", "```\n    <DATE> <TIME> <INSERT BUCKET NAME>\n    ```", "```\n    vim main.tf\n    ```", "```\n     resource \"aws_s3_bucket_public_access_block\" \"bucket\" {\n      bucket = aws_s3_bucket.bucket.id\n      block_public_acls       = false\n      block_public_policy     = false\n      ignore_public_acls      = false\n      restrict_public_buckets = false\n    }\n    ```", "```\n     resource \"aws_s3_bucket_ownership_controls\" \"bucket\" {\n      bucket = aws_s3_bucket.bucket.id\n      rule {\n        object_ownership = \"ObjectWriter\"\n      }\n    }\n    ```", "```\n     resource \"aws_s3_bucket_website_configuration\" \"bucket\" {\n      bucket = aws_s3_bucket.bucket.bucket\n      index_document {\n        suffix = \"index.html\"\n      }\n    }\n    ```", "```\n     data \"aws_iam_policy_document\" \"policy\" {\n      statement {\n        sid = \"SampleStatement\"\n        principals {\n          type        = \"AWS\"\n          identifiers = [\"*\"]\n        }\n        actions = [\n          \"s3:GetObject\"\n        ]\n        resources = [\n          \"${aws_s3_bucket.bucket.arn}/*\"\n        ]\n      }\n    }\n    ```", "```\n     locals {s3_policy = data.aws_iam_policy_document.policyau_uri = \"http://acs.amazonaws.com/groups/global/AuthenticatedUsers\"\n    }\n    ```", "```\n     resource \"aws_s3_bucket_policy\" \"allow_access_policy\" {\n      bucket = aws_s3_bucket.bucket.id\n      policy = local.s3_policy.json\n    }\n    ```", "```\n     data \"aws_canonical_user_id\" \"current\" {}\n    ```", "```\n     resource \"aws_s3_bucket_acl\" \"bucket_acl\" {\n      bucket = aws_s3_bucket.bucket.id\n      access_control_policy {grant {grantee {\n            id   = data.aws_canonical_user_id.current.id\n            type = \"CanonicalUser\"\n          }permission = \"FULL_CONTROL\" }grant {grantee {\n            type = \"Group\"\n            uri  = local.au_uri\n          }permission = \"READ\" }\n        owner {\n          id = data.aws_canonical_user_id.current.id\n        }\n      }\n    }\n    ```", "```\n    terraform fmt\n    ```", "```\n    terraform plan\n    ```", "```\n    terraform apply -auto-approve\n    ```", "```\n     aws s3api get-bucket-acl --bucket=<INSERT BUCKET NAME>\n    ```", "```\n    touch upload.sh\n    ```", "```\n    chmod +x upload.sh\n    ```", "```\n    vim upload.sh\n    ```", "```\n     mkdir files\n    cd files\n    SOURCE=https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/raw/main/ch03/sample_website.zip wget $SOURCE -O sample_website.zip\n    unzip sample_website.zip\n    rm sample_website.zip\n    aws s3 cp --recursive . s3://$1\n    ```", "```\n    vim main.tf\n    ```", "```\n     resource \"null_resource\" \"s3_upload\" {\n      provisioner \"local-exec\" {\n        command = \"./upload.sh ${aws_s3_bucket.bucket.id}\"\n      }\n    }\n    ```", "```\n    terraform plan\n    ```", "```\n    terraform init\n    ```", "```\n    terraform plan\n    ```", "```\n    terraform apply -auto-approve\n    ```", "```\n     aws s3 ls s3://<INSERT BUCKET NAME>\n    ```", "```\n     aws s3api get-bucket-website --bucket <INSERT BUCKET NAME>\n    ```", "```\n    {\n        \"IndexDocument\": {\n            \"Suffix\": \"index.html\"\n        }\n    }\n    ```", "```\n     http://<BUCKET NAME>.s3-website.<REGION>.amazonaws.com\n    ```", "```\n    terraform destroy\n    ```", "```\n    terraform show terraform.tfstate.backup\n    ```", "```\n    cd ~\n    ```", "```\n    mkdir backend && cd backend\n    ```", "```\n    touch main.tf\n    ```", "```\n    vim main.tf\n    ```", "```\n     terraform {\n      required_providers {\n        aws = {\n          source  = \"hashicorp/aws\"\n          version = \"~> 4.0\"\n        }\n      }\n    }\n    provider \"aws\" {\n      alias  = \"default\"\n      region = \"us-east-1\"\n    }\n    ```", "```\n     resource \"aws_s3_bucket\" \"remote_state\" {\n      bucket = \"<INSERT S3 BACKEND BUCKET NAME>\"\n      lifecycle {\n        prevent_destroy = true\n      }\n    }\n    ```", "```\n     resource \"aws_s3_bucket_versioning\" \"versioning\" {\n      bucket = aws_s3_bucket.remote_state.id\n      versioning_configuration {\n        status = \"Enabled\"\n      }\n    }\n    resource \"aws_s3_bucket_server_side_encryption_configuration\" \"encryption\" {\n      bucket = aws_s3_bucket.remote_state.id\n      rule {\n        apply_server_side_encryption_by_default {\n          sse_algorithm     = \"aws:kms\"\n        }\n      }\n    }\n    ```", "```\n     resource \"aws_dynamodb_table\" \"state_lock\" {\n      hash_key = \"LockID\"\n      name = \"${aws_s3_bucket.remote_state.id}\"\n      attribute {\n        name = \"LockID\"\n        type = \"S\"\n      }\n      billing_mode = \"PAY_PER_REQUEST\"\n    }\n    ```", "```\n    terraform init\n    ```", "```\n    terraform plan\n    ```", "```\n    terraform apply -auto-approve\n    ```", "```\n    cd ~/vulnerable_s3_lab\n    ```", "```\n    vim main.tf\n    ```", "```\n     terraform {\n      required_providers {\n        aws = {\n          source  = \"hashicorp/aws\"\n          version = \"~> 4.0\"\n        }\n      }\n    }\n    ```", "```\n     terraform {\n      required_providers {\n        aws = {\n          source  = \"hashicorp/aws\"\n          version = \"~> 4.0\"\n        }\n      }\n      backend \"s3\" {\n        bucket         = \"<INSERT BUCKET NAME>\"\n        key            = \"terraform/terraform.tfstate\"\n        region         = \"us-east-1\"\n        dynamodb_table = \"<INSERT TABLE NAME>\"\n        encrypt        = true\n      }\n    }\n    ```", "```\n    terraform fmt\n    ```", "```\n    terraform init\n    ```", "```\n    terraform plan\n    ```", "```\n    terraform apply -auto-approve\n    ```", "```\n     aws s3 ls s3://<S3 BACKEND BUCKET NAME> --recursive\n    ```", "```\n    ... terraform/terraform.tfstate\n    ```", "```\n     SELECT * FROM \"<INSERT TABLE NAME>\";\n    ```", "```\n    terraform destroy\n    ```", "```\n    cd ~/vulnerable_s3_lab\n    ```", "```\n    vim upload.sh\n    ```", "```\n     echo \"Sleeping for 60 seconds\"\n    sleep 60\n    ```", "```\n    echo \"Sleeping for 60 seconds\"\n    sleep 60 mkdir files\n    cd files\n    SOURCE=https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/raw/main/ch03/sample_website.zip wget $SOURCE -O sample_website.zip\n    unzip sample_website.zip\n    rm sample_website.zip\n    aws s3 cp --recursive . s3://$1\n    ```", "```\n    cd ~/vulnerable_s3_lab && terraform apply -auto-approve\n    ```", "```\n    cd ~/vulnerable_s3_lab && terraform apply -auto-approve\n    ```", "```\n    exit\n    ```", "```\n    terraform destroy\n    ```"]