- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Succeeding with Infrastructure as Code Tools and Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we manually created our first vulnerable lab environment
    using the **AWS Management Console**. It probably took us about an hour and a
    half to set everything up. After completing the lab setup, it may have taken us
    an additional 30 minutes to test whether everything was (mis)configured as expected.
    What if we wanted to set up 10 lab environments similar to what we prepared in
    *[Chapter 2](B19755_02.xhtml)* for a security training course? *Do we really need
    around 20 hours to set all of these up?* In addition to this, remember that we
    only worked on a small component of an entire cloud penetration testing lab environment!
    Complete lab environments generally have about 5 to 10 times more resources compared
    to what we prepared in *[Chapter 2](B19755_02.xhtml)*. Assuming the complete environment
    is at least five times larger than what we initially prepared, and taking into
    account the need to create and delete the entire environment every time to manage
    costs, it is worth considering whether the manual setup process for these environments
    (which typically takes around 10 hours each) is truly necessary. That said, is
    there a better way to create and manage the cloud infrastructure resources for
    our penetration testing lab environments?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will answer these questions by taking a closer look at
    how **Infrastructure as Code** (**IaC**) solves these challenges and requirements!
    That said, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Diving deeper into IaC tools and strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Terraform in AWS CloudShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting our feet wet with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Terraform configuration language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building our vulnerable lab environment with Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring a Terraform backend with state locking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying the state-locking setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hands-on solutions in this chapter will equip you with the skills and confidence
    needed to convert existing cloud infrastructure resources into IaC configuration
    files. With these configuration files, we should be able to set up multiple penetration
    testing lab environments quickly within minutes using automated tools and services!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start, we must have the following ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Required**: The “target” AWS account used in *[Chapter 2](B19755_02.xhtml)*,
    which will contain the vulnerable environment and resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optional**: A second AWS account (also used in *[Chapter 2](B19755_02.xhtml)*),
    which will serve as the “attacker’s account”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case you skipped *[Chapter 2](B19755_02.xhtml)*, *Preparing Our First Vulnerable
    Cloud Lab Environment*, feel free to create the AWS accounts using the following
    link: [https://aws.amazon.com/free/](https://aws.amazon.com/free/). You may proceed
    with the next steps once the accounts are ready.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter primarily focuses on using Terraform to build a sample vulnerable
    lab environment on AWS. Of course, we need to have our **Microsoft Azure** and
    **Google Cloud Platform** (**GCP**) accounts ready once we reach the hands-on
    portion of the succeeding chapters of this book (*[Chapter 4](B19755_04.xhtml)*
    onward). In the meantime, setting up two AWS accounts should do the trick for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code and other files used for each chapter are available in this
    book’s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud)'
  prefs: []
  type: TYPE_NORMAL
- en: Diving deeper into IaC tools and strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the practical exercises in this chapter, we will first establish
    a clear understanding of IaC in this section and discuss how it can be harnessed
    for building complex penetration testing labs.
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying IaC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IaC is the practice and process of using code to provision and manage infrastructure
    resources. This code works similarly to how a blueprint of a house is used as
    a reference when building the actual house. The cool thing when dealing with IaC
    code is that the actual infrastructure resources are created and configured automatically
    from the code that represents the desired final state of the infrastructure. Behind
    the scenes, the IaC automation tools simply make use of the same set of APIs we
    would use when trying to automate specific processes. The process is illustrated
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Using IaC tools and services to create and manage cloud resources
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.1*, we can see that the same set of configuration files (representing
    the desired state) can be used to generate and configure multiple environments
    with the same set of resources and properties. For example, we can use IaC configuration
    files when provisioning and ensuring the consistency of development, staging,
    and production environments used by developers and engineers.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might be wondering how configuration files are used to generate
    actual cloud infrastructure resources. Let’s start with a configuration file where
    a single resource is defined. This configuration file is then passed as input
    to the IaC tool, which then runs the code specified (an **imperative approach**)
    or, alternatively, “magically” converts the configuration code into actual infrastructure
    resources (a **declarative approach**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts how IaC tools and services manage changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – How IaC tools and services manage changes
  prefs: []
  type: TYPE_NORMAL
- en: '*Assuming that we used the declarative approach to provision the initial set
    of cloud resources, can we modify the configuration code and use the IaC tool
    again to update the existing set of infrastructure resources?* Similar to what
    we have in *Figure 3**.2*, certain IaC tools can manage the changes for us automatically
    and generate an **execution plan** that modifies the infrastructure to reach the
    desired state as specified in the IaC configuration templates. These changes are
    then applied to the existing infrastructure resources.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that IaC tools may either (1) perform in-place modifications
    in the infrastructure or (2) replace the entire infrastructure resources instead.
    This varies depending on the IaC tool, along with the type of change being performed.
    When working on resources deployed inside penetration testing lab environments,
    we generally want to replace the entire thing since old infrastructure resources
    may already be in an unstable or misconfigured state due to previous exploitation
    attempts and activities.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging IaC for penetration testing labs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s talk about why IaC mixes well with the preparation and management
    of penetration testing labs in the cloud. Creating and managing dedicated penetration
    testing lab environments in the cloud can be complex and time-consuming. Utilizing
    IaC can simplify this process and provide numerous benefits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick list of the advantages of using IaC when building penetration
    testing labs in the cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster deployment**: Since the configuration code contains the properties
    and desired state of the resources to be created, we can quickly create and destroy
    various lab resources through an automated process within seconds (to, at most,
    a few minutes). This helps us easily rebuild specific cloud infrastructure resources
    that require a “refresh” after a penetration testing lab activity or experiment
    (since these activities may intentionally or unintentionally leave some services
    or resources in an unstable or misconfigured state).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration**: We can easily share the lab environment configuration and
    setup as code with other engineers. This allows for easier collaboration and discussion
    when troubleshooting security configuration settings of resources deployed inside
    penetration testing lab environments (that is, without having to share your entire
    cloud account).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: If there are multiple vulnerable lab environments set up from
    a single instance of IaC configuration code, we only need to modify the IaC code
    once and apply the changes automatically to these lab environments. We can guarantee
    the repeatability of the infrastructure management process and ensure that the
    resource configuration and versions stay consistent every time we build our penetration
    testing lab environments. It is important to note that the exploitability of certain
    vulnerabilities and misconfigurations depends on the version of the applications
    and resources used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transparency**: Auditing infrastructure configuration mistakes is easier
    since we can check the current configuration using the code representing the infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimized**: Infrastructure cost management is easier since we can have our
    cloud resources turned off (or deleted) when nobody is using the penetration testing
    lab environments. Once the resources need to be created, it only takes a few minutes
    for the resources to be prepared from the infrastructure configuration code available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, IaC enables faster deployment of lab resources through an automated
    process, allowing for quick creation and destruction of resources within seconds
    to a few minutes. Collaboration is simplified as engineers can easily share lab
    environment configurations and setups as code, facilitating troubleshooting of
    security settings without sharing the entire cloud account. Additionally, IaC
    ensures consistency by modifying the code once to apply changes automatically
    to multiple lab environments, guaranteeing repeatability and maintaining consistent
    resource configurations and versions.
  prefs: []
  type: TYPE_NORMAL
- en: With these points in mind, let’s proceed with best practices and strategies
    when using IaC solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing IaC best practices and strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variety of IaC tools have been used by developers and engineers these past
    couple of years to create and manage infrastructure. Some of the most popular
    ones include **Chef**, **Puppet**, **Vagrant**, **(R)?ex**, **SaltStack**, **Pulumi**,
    **Ansible**, **AWS Cloud Development Kit** (**AWS CDK**), **AWS CloudFormation**,
    **GCP Deployment Manager**, and **Azure Resource Manager**. Some of these tools
    (such as AWS CDK, AWS CloudFormation, GCP Deployment Manager, and Azure Resource
    Manager) have been built to automate the creation, configuration, and management
    of resources for specific cloud providers. The rest are cloud-agnostic—that is,
    these tools should work across multiple cloud platforms such as **AWS**, **Microsoft
    Azure**, and **GCP**. From this list, certain tools (such as Ansible, Chef, and
    Puppet) primarily focus on setting up applications and configuring *what’s inside
    a virtual machine*, while others (such as Terraform) primarily focus on deploying
    and provisioning cloud infrastructure resources from code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can use multiple tools at the same time when deploying, provisioning, and
    configuring infrastructure. For example, we can use Terraform along with Ansible
    to automate the deployment of cloud infrastructure resources along with the applications
    running inside virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed with the next section, let’s discuss some strategies we can
    use when using IaC tools and services:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use **version control systems** (for example, Git) to track and manage
    changes to the IaC configuration code used to manage and deploy our penetration
    testing lab environments. In addition to this, we can have a **Continuous Integration/Continuous
    Deployment** (**CI/CD**) pipeline automatically deploy the resources specified
    in the IaC files after changes in the code have been pushed to the code repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can easily modularize and manage the different resource groups used in the
    lab environment by properly separating the code into multiple files. Once the
    components of the penetration testing labs have been modularized, we can easily
    generate different variations of vulnerable lab environments using the modules
    available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost plays a big factor in the design of penetration testing lab environments.
    IaC allows environment or cloud account owners to have cloud resources turned
    off (or non-existent) until they are needed. *Why?* Because IaC tools make it
    easy to create and bring resources back up from configuration files (generally
    within a matter of seconds or minutes). When designing and building penetration
    testing lab environments in the cloud, we also have the option whether we allow
    multiple users to share the same environment or have each user have their own
    dedicated environments (which could be more costly). With IaC, we can easily allow
    the second option to be cost-effective since we can just create and provision
    the infrastructure from a template when the user needs to use it. *What’s the
    disadvantage of the first option?* Since the lab is shared by multiple users,
    a certain user might encounter unexpected issues during the penetration testing
    process since the resources involved may already be misconfigured due to an action
    (or actions) performed by another user. If one of the users decides to refresh
    or rest the box, then any active work another user is doing will be reset as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we should have a solid understanding of what IaC is and how we
    can leverage it to effectively manage penetration testing lab environments. In
    the next section, we’ll have our first look at one of the most popular IaC tools
    used by professionals globally.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Terraform in AWS CloudShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will focus on using **Terraform** to provision and manage
    our cloud infrastructure. Terraform is an open source IaC tool created by **HashiCorp**.
    It’s one of the most powerful and most used IaC tools at the moment. It enables
    users to define and provision infrastructure resources using a high-level configuration
    language. By utilizing a simple, declarative, and intuitive syntax, this IaC tool
    simplifies the process of creating, updating, and versioning infrastructure, which
    provides a powerful way to automate infrastructure management.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how Terraform code looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are simply defining a firewall rule (in GCP) that will allow us to
    initiate SSH connections (via port **22**) from our local machine to resources
    in the specified **Virtual Private Cloud** (**VPC**) network.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Do not worry if the sample Terraform code doesn’t make complete sense at the
    moment! In succeeding chapters of the book, we will dive deeper into how Terraform
    is used to manage penetration testing lab environment resources on cloud platforms
    such as AWS, Azure, and GCP. We will explore the concepts, syntax, and practical
    examples specific to these cloud providers, which will help us gain a clearer
    understanding of Terraform’s usage in real-world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the sample code provided, the Terraform code used to build
    the vulnerable cloud infrastructure is **declarative** and self-documenting. Instead
    of focusing on *how* these infrastructure resources are prepared, we simply just
    need to specify the desired state, and Terraform takes care of the details to
    convert the current state into the desired state. Other tools utilize the **imperative**
    approach in automation, where engineers define the commands in order to reach
    the desired state. The advantage of the imperative approach in automation is the
    ability to have fine-grained control over the sequence of commands and actions
    taken to reach the desired state. This can be useful in complex scenarios that
    require specific scripting or procedural logic. This is in contrast with the **declarative**
    approach, where we just need to specify how the desired state of the infrastructure
    should look. We will primarily use the declarative approach in this book whenever
    we can. If you are just starting out with IaC and automation concepts, starting
    with the declarative approach in Terraform can provide a more intuitive and straightforward
    way to understand and manage infrastructure resources. That said, the declarative
    approach offers a clear and concise representation of the desired state, making
    it easier to learn and work with.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it is possible to use the imperative approach with Terraform using
    **CDK for Terraform** (**CDKTF**). For more information about CDKTF, feel free
    to check out the following link: [https://developer.hashicorp.com/terraform/cdktf](https://developer.hashicorp.com/terraform/cdktf).'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, before we can use Terraform, we have to make sure that it is properly
    installed and set up in our environment! There are different ways to install Terraform.
    One way would be to use **tfenv** (**Terraform version manager**) to help us easily
    work with and manage different Terraform versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next set of steps, we will set up and install Terraform in our AWS CloudShell
    environment using the Terraform version manager:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new browser tab and then navigate to the AWS console. Type **shell**
    in the search bar and then select **CloudShell** from the list of results. Alternatively,
    you may simply locate and click the **CloudShell** button located in the upper-left
    corner of the AWS Management Console (near the region selection drop-down menu).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait for around a minute or two for the AWS CloudShell environment to be ready.
    Given that the CloudShell environment offers a maximum of 1 GB disk space (per
    AWS region), it becomes necessary to monitor disk usage regularly using commands
    such as **df -h** (disk free) and **du -sh** (disk usage). These commands provide
    insights into the amount of disk space utilized and help determine whether we
    are approaching the 1 GB limit. By actively monitoring disk space, we can avoid
    potential storage constraints within the CloudShell environment. For more information,
    feel free to check out the following link: [https://docs.aws.amazon.com/cloudshell/latest/userguide/limits.html](https://docs.aws.amazon.com/cloudshell/latest/userguide/limits.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the AWS CloudShell terminal (after the **$** sign), run the following **git
    clone** command to clone the **tfutils/tfenv** repository to our CloudShell environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a **bin** directory (inside the user home directory) using the **mkdir**
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the **ls** command to list the files stored inside **~/.tfenv/bin/**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield a list of results similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s use the **ln -s** command to create a soft symbolic link for the
    executable files stored inside **~/.tfenv/bin/**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What are soft symbolic links?
  prefs: []
  type: TYPE_NORMAL
- en: '**Soft symbolic links**, also known as **symlinks**, are special files in a
    filesystem that serve as pointers to other files or directories. They reference
    the target by its path and essentially create a shortcut to the target file or
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **readlink** command to verify whether the previous command worked
    as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we used the **readlink** command to obtain the full paths of files in
    the **~/bin** directory by resolving the symbolic links and providing the absolute
    paths of each file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since **~/bin** has already been added to **$PATH**, we should be able to use
    **terraform** and **tfenv** after running the **ln -s** command in the previous
    step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the **tfenv install** command to install a specific version (**1.3.9**)
    of Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By running **tfenv install 1.3.9**, we instruct **tfenv** to download and set
    up Terraform version **1.3.9** on our system. This specific version will be installed
    in a separate directory, keeping it isolated from other installed versions of
    Terraform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the **tfenv use** command to switch to and use version **1.3.9**
    of Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run this command, **tfenv** will configure our system to use Terraform
    version **1.3.9** for any subsequent Terraform commands executed in the current
    shell session or directory. This allows us to work with the features and functionality
    specific to this version.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let’s check whether Terraform has been successfully installed using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This confirms that Terraform version **1.3.9** has been installed and is ready
    for use!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: By the time you read the book, a newer version of Terraform might already be
    available. However, it’s still recommended to use the version used in this chapter
    to avoid any issues with running the hands-on solutions and examples. Simply use
    the **tfenv** command to “time-travel” and use an older version of Terraform if
    needed. This will help make sure that all examples in this chapter will continue
    to work without issues. If a newer version of Terraform is available, you can
    always use the **tfenv** command to install and switch to that version if desired.
    This flexibility allows you to stay up to date with the latest features and improvements.
    However, it’s important to note that using the version specified in the book ensures
    consistency and avoids any potential compatibility issues.
  prefs: []
  type: TYPE_NORMAL
- en: With Terraform set up in our AWS CloudShell environment, let’s proceed to the
    next section!
  prefs: []
  type: TYPE_NORMAL
- en: Getting our feet wet with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will provide a brief overview of the essential Terraform
    workflow and then move on to a “*Hello World*” example to test our setup.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the core Terraform workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It may take most of us around 2-4 weeks to learn a new tool, platform, or framework.
    However, it would probably take us just a few hours (to, at most, a few days)
    to learn Terraform since using it is straightforward and easy. When using Terraform,
    engineers generally follow a process similar to what we have in *Figure 3**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – A common workflow when using Terraform to create and update resources
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the configuration file (or files) ready, we simply run **terraform
    init** to initialize the Terraform environment. The **terraform init** command
    is usually executed when our environment has not been initialized yet or when
    additional files or plugins need to be downloaded. The next step involves using
    **terraform plan** to process the configuration code and generate an execution
    plan for us to review. Note that running the **terraform plan** command is not
    required but *recommended*. Finally, we can use **terraform apply** to implement
    the changes described in the execution plan.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Running **terraform init** and **terraform plan** are generally *safe* commands
    to run since (1) these involve **idempotent** operations and (2) they won’t create/modify
    any infrastructure resources yet. In this context, idempotent means that executing
    these commands multiple times will have the *same* outcome without causing unintended
    side effects. This makes them suitable for safely initializing and planning infrastructure
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: There are other commands we can use to help us perform specific tasks (for example,
    **terraform show**), but other than these three primary commands, one other command
    we need to know would be the **terraform destroy** command. Running this command
    would delete the resources created and managed using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our Terraform setup with a Hello World example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a good idea of how to use Terraform, let’s work on a very
    simple Terraform example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a **hello_terraform** directory using the **mkdir** command. Navigate
    to the directory created using the **cd** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the **touch** command to create an empty **main.tf** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to open the empty **main.tf** file using Vim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Learning how to use a command-line text editor such as Vim may be a bit daunting
    at first. However, you’ll see that Vim is relatively easy and fun to use once
    you get a hang of it!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may type **:set nu** and then press the *Enter* key to show the line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, press *i* to switch to **insert mode** so that we can edit the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The **insert mode** in Vim allows us to type and make changes as we would in
    a regular text editor. In this mode, we can freely add, delete, or modify characters
    without affecting the surrounding text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type or paste the following block of code into our **main.tf** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we declare a **null_resource** resource, which is useful for actions and
    operations that do not involve the creation of resources. In this case, we’re
    using it to run a script or a command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press the *Esc* key to switch to **normal mode**. Type **:wq!**. Press *Enter*
    afterward. This will save the changes made to **main.tf** and then exit Vim as
    well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we described how the insert mode works in Vim. Now, let’s quickly talk
    about the normal mode. The **normal mode** allows us to navigate through text,
    execute commands, and perform various operations on the file. In this mode, specific
    keystrokes (such as **:wq!**) can be used to move the cursor, search for text,
    copy and paste, and perform editing actions such as deleting, replacing, and undoing
    changes. For instance, “**w**” represents the *write* command (which saves changes
    to the file), and “**q**” represents the *quit* command (which exits the editor).
    What’s the exclamation point (**!**) for? “**!**” is simply an optional modifier
    that forces the command to execute, even if there are unsaved changes along with
    other warnings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our **main.tf** file is ready, let’s use the **terraform init** command
    to initialize the Terraform working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To help us have a better idea of what **terraform init** initialized and set
    up for us, let’s install the **tree** utility using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the **tree** utility installed, let’s use the **tree** command to help
    us check and visualize the directories and files in our current directory:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield a tree similar to what we have in *Figure 3**.4*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_03_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.4 – Results after running the tree command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that after running **terraform init**, we suddenly have a **.terraform**
    directory with a tree structure of directories and file(s).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield a set of logs similar to what we have in the following block
    of log messages:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have an **execution plan** that indicates which resources will be created
    (**1**), modified (**0**), or destroyed (**0**) once we run the **terraform apply**
    command in a later step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Terraform’s execution plan is like a blueprint that outlines the steps and actions
    it will execute to achieve the desired infrastructure state (as defined in the
    Terraform configuration code). It is similar to how the SQL **EXPLAIN** command
    provides a detailed breakdown of how a database management system will execute
    a specific query. That said, given that Terraform abstracts what’s happening behind
    the scenes with its declarative syntax, the execution plan serves as a valuable
    mechanism for previewing changes that will be made to the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'With everything ready, let’s use the **terraform apply** command to implement
    the changes specified in the execution plan returned after running **terraform
    plan**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield a set of logs similar to what we have in *Figure 3**.5*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_03_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.5 – Verification step after running the terraform apply command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'During the verification step (that is, when you see an **Enter a value:** message),
    type in **yes** to proceed with the creation of a **hello.txt** file. After pressing
    the *Enter* key, we should get the following set of logs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that our **terraform apply** command succeeded!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Running the **terraform apply** command should execute **touch hello.txt** and
    create an empty **hello.txt** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before celebrating, let’s use the **ls** command to check whether our **hello.txt**
    file got created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s inspect the **terraform.tfstate** file using the **cat** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us a nested JSON structure similar to what we have in the
    following block:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have confirmed that Terraform has stored the information that represents
    the current set of infrastructure resources (managed by Terraform) inside the
    **terraform.tfstate** file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Terraform utilizes the **terraform.tfstate** file to keep track of the current
    state of the infrastructure. This file stores critical information such as resource
    IDs, dependencies, and metadata. Terraform makes use of this file when performing
    diff checks before infrastructure resources are created or modified. Make sure
    *not* to edit or delete the **terraform.tfstate** file in your working directory
    as this can lead to inconsistencies and potential errors in your Terraform workflow.
    In case you’ve accidentally deleted the **terraform.tfstate** file, do not panic
    as there are various ways to recover from this scenario! In addition to this,
    we can utilize **remote state backends** to store our state file securely and
    enable easier collaboration and disaster recovery as well. We will discuss this
    in more detail in the *Configuring a Terraform backend with state locking* section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the user home directory using the **cd** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s delete the **hello_terraform** directory (and everything inside
    it) using the **rm -****rf** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will help free up some space since we only have a total of 1 GB of storage
    available in our CloudShell environment (for each AWS region). Note that it’s
    recommended to run **terraform destroy** first inside the **hello_terraform**
    directory before performing these types of deletion or cleanup steps (as we might
    accidentally delete the state file). Given that the only “infrastructure resource”
    we created is a **.txt** file, there’s no need to run **terraform destroy**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you require a dedicated environment specifically for utilizing Terraform
    in creating and managing infrastructure resources, you can explore **AWS Cloud9**
    and set up a development environment. This environment offers more disk space
    compared to CloudShell (currently at 1 GB only for each AWS region). Additionally,
    Cloud9 enables you to utilize a code editor for writing and modifying code, offering
    enhanced flexibility and convenience. It’s important to note that while AWS CloudShell
    is a free service provided by AWS, AWS Cloud9 may incur additional costs depending
    on your usage. While CloudShell offers a limited disk space of 1 GB, it is available
    at no extra charge. On the other hand, AWS Cloud9 may have associated costs based
    on usage and the instance type selected for the environment. Before opting for
    AWS Cloud9, it is advisable to review the pricing details and ensure that it aligns
    with your requirements and budget.
  prefs: []
  type: TYPE_NORMAL
- en: '*Wasn’t that easy?* When learning Terraform (or any other new tool), it’s a
    good idea to start with simple and small examples similar to what we worked on
    in this section. In the next section, we’ll build on top of this simple example
    and work on a relatively longer Terraform configuration file.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Terraform configuration language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will dive into the core aspects of Terraform’s configuration
    language and then proceed with working with relatively simple configuration code
    to equip us with the foundational knowledge needed to manage IaC with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Demystifying commonly used Terraform configuration blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding how to write and interpret Terraform configuration code is essential
    for effective infrastructure management. This knowledge allows us to customize
    and modify existing infrastructure resources created and managed using Terraform.
    It also enables us to troubleshoot issues more effectively and save time when
    resolving errors and blockers while using the IaC tool.
  prefs: []
  type: TYPE_NORMAL
- en: '*So, where do we start?* For one thing, simple and complex Terraform configuration
    code generally makes use of the same set of elements and building blocks. This
    common foundation allows us to gradually build our understanding by starting with
    simple configurations and gradually progressing toward more complex scenarios.
    By mastering the fundamental elements, we can confidently navigate and interpret
    both simple and complex Terraform configuration code, enabling us to tackle a
    wide range of infrastructure management challenges effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we work on the next hands-on example, let’s have a quick look at some
    of the elements we would generally see in a Terraform configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resources**—These are code blocks used to define how infrastructure resources
    would be provisioned and configured. These blocks have the following structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A resource is configured using one or more arguments, where each argument is
    represented by a key-value pair. Depending on the specific resource being created,
    the arguments could include things such as region, instance type, subnet ID, and
    security groups, among others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s look at a quick example of how to define a resource block for an Azure
    public IP address using Terraform:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we specify various attributes, such as the resource group name obtained
    from a local variable, along with the allocation method set to **"Dynamic"**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Providers**—These are plugins that enable cloud platform and SaaS API interactions.
    These blocks have the following structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Providers can include **cloud service providers** (**CSPs**) such as AWS, Azure,
    and GCP, as well as other third-party providers. Depending on the specific provider
    being used, the arguments could include things such as access keys, region, and
    endpoints, among others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s look at a quick example of how to define a provider:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By configuring this provider with the appropriate region, Terraform will be
    able to interact with AWS services within the specified region for resource provisioning
    and management.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Data sources**—These are elements that allow us to query data at runtime.
    These blocks have the following structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The configuration for the data source depends on the specific data source being
    used and can include things such as queries, filters, and authentication information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s look at a quick example of how to define a data source:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this data block, we can retrieve information about the IP ranges used by
    the AWS EC2 Instance Connect service in the specified region.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Local values**—These are code blocks that allow us to assign and store static
    values for later use. These blocks have the following structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The expressions can be any valid Terraform expression, including other variables
    or functions. Using this code block, we can easily define local variables in our
    Terraform configuration to make our code more readable, maintainable, and reusable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s look at an example of how to define a few local variables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we simply define two local variables (**net_01** and **net_02**) with
    values equal to the **self_link** attribute values of the corresponding **google_compute_network**
    resources.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Input variables**—These are code blocks that allow users to specify dynamic
    values. These blocks have the following structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Variables in Terraform are used to parameterize the configuration, allowing
    code to be reused in different scenarios or environments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s look at a quick example of how to define a variable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This variable can be utilized within the Terraform configuration to dynamically
    customize the instance name based on specific requirements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Output values**—These help return and print values as well as share values
    across modules. These blocks have the following structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Outputs in Terraform are used to define values that are exposed to the user
    after the **terraform apply** operation is complete. The output can then be referenced
    in other parts of the configuration or in other configurations that use the current
    module as a dependency.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s look at a quick example of this in action:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we simply define an output block to retrieve the public IP address of
    a virtual machine (in Azure).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While there are certainly more Terraform elements to consider, the ones we’ve
    discussed should be enough for the time being. As you continue your Terraform
    journey, you can explore additional elements to expand your repertoire for managing
    infrastructure. Building upon the foundation we have established already, these
    elements will further enhance our ability to create various penetration testing
    labs in the cloud using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Working with simple Terraform configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a good idea of which blocks of code to expect in a Terraform
    configuration file, let’s proceed with the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a **basics** directory using the **mkdir** command. Navigate to the
    directory created using the **cd** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the **touch** command to create an empty **main.tf** file inside the **basics**
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to open the empty **main.tf** file using Vim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Type **:set nu** and then press the *Enter* key to show the line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, press *i* to switch to **insert mode** so that we can edit the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have a better idea of how to use Vim. To switch to
    insert mode (assuming we’re currently in normal mode), simply press the *i* key.
    Then, to switch to normal mode, press the *Esc* key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by declaring and configuring the AWS provider by typing (or pasting)
    the following block of code into our **main.tf** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this code block, Terraform is able to locate and use the required AWS provider
    for the specified version and source to provision and manage AWS resources in
    the specified region (**us-east-1**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that Terraform would automatically use the credentials configured in the
    CloudShell environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following code as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This would give us access to the AWS canonical user ID (which is an alphanumeric
    value used when granting access to S3 buckets and objects) of the account used
    to run Terraform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The **AWS canonical user ID** (that is, the “obfuscated form” of the AWS account
    ID) is primarily used for operations related to object-level access control in
    Amazon S3\. When granting access permissions to S3 objects or buckets, this ID
    is used to specify who has the necessary permissions. Note that the AWS canonical
    user ID is different from the AWS account ID, which is a 12-digit number associated
    with each AWS account. For more information, feel free to check the following
    link: [https://docs.aws.amazon.com/AmazonS3/latest/userguide/finding-canonical-user-id.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/finding-canonical-user-id.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also declare a few local variables, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s add the following code, which prints the **display_name** value
    of the canonical user ID of the AWS account we are using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **main.tf** and then exit Vim as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that our **main.tf** file is ready, let’s use the **terraform init** command
    to initialize the Terraform working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield a set of logs similar to what is shown in the following set
    of log messages:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that the relevant files and binaries have been downloaded from
    the Terraform Registry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the **terraform apply** command to implement the changes specified in the
    execution plan returned after running **terraform plan**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that this time, we use the **-auto-approve** flag to skip the verification
    step, similar to what we encountered in the last section. Running the command
    should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*What happened here?* The code simply executed a command that printed the value
    of the **name** local value (that is, the display name of the canonical user).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We can see that when using the **terraform apply -auto-approve** command, the
    **-auto-approve** flag allows for automatic approval and execution of planned
    changes without user confirmation. The **-auto-approve** flag is valuable in non-interactive
    or automated scenarios as it eliminates the need for manual intervention. However,
    it is important to exercise caution when utilizing the **-auto-approve** flag
    as it bypasses confirmation prompts, and changes are immediately applied. Thoroughly
    reviewing Terraform code and changes prior to running **terraform apply** with
    **-auto-approve** is crucial to prevent unintended modifications to infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s perform a minor modification to the **main.tf** file. Run the following
    command again to open the empty **main.tf** file using Vim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may type **:set nu** and then press the *Enter* key to show the line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, press *i* to switch to **insert mode** so that we can edit the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the following line using the arrow keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you’ve located the line in the previous code block, replace it with this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are planning to log and print the ID (instead of the **display_name**
    value) once when we run the **terraform apply** command in a later step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **main.tf** and then exit Vim as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before running the **terraform plan** command, let’s run **terraform fmt**
    to format our Terraform code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are using **terraform fmt** to ensure a consistent coding style across
    all Terraform configuration files. This command scans the Terraform configuration
    files, adjusting indentation, spacing, and line breaks to match the official Terraform
    style guide.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The **terraform fmt** command automatically adjusts the indentation of blocks,
    statements, and expressions to ensure consistent alignment. It typically uses
    two spaces for each level of indentation. In addition to this, the command adds
    or removes spaces to maintain consistent spacing around operators, colons, commas,
    and other elements. For example, it ensures spaces are present before and after
    equals signs in variable assignments. Similarly, it inserts or removes line breaks
    to improve readability by introducing line breaks between resource blocks or variable
    declarations to make the code more visually structured. There are a few more formatting
    tweaks that **terraform fmt** applies, but these should do the trick for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It seems that changes are not detected when provisioner commands have been altered!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, Terraform is supposed to detect changes when altering provisioner commands
    within a resource block. However, in certain cases, modifications to provisioner
    commands may not be recognized as modifications by the IaC tool. Consequently,
    Terraform may not execute the updated provisioner commands, potentially leading
    to inconsistencies in the deployed infrastructure. For more information about
    this topic, feel free to check out the following link: [https://github.com/hashicorp/terraform/issues/14405](https://github.com/hashicorp/terraform/issues/14405).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To force the replacement of the resource(s) created, let’s use the **-replace**
    flag while running the **terraform** **apply** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following set of logs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that the ID value has been logged after running the **terraform**
    **apply** command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*What happened here?* Here, we instructed Terraform to automatically apply
    changes without user confirmation, while specifically replacing the **null_resource.debug**
    resource. The **-replace=null_resource.debug** argument specifically targets the
    **null_resource.debug** resource, indicating that it should be replaced during
    the **apply** operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the user home directory using the **cd** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s delete the **basics** directory (and everything inside it) using
    the **rm -****rf** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will help free up some space since we need to manage the space available
    in our CloudShell environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Great work completing our second Terraform example! At this point, we should
    have the confidence needed to work on more complex Terraform code.
  prefs: []
  type: TYPE_NORMAL
- en: Building our vulnerable lab environment with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous sections of this chapter allowed us to have a better understanding
    of how Terraform works. We worked with relatively simple examples, and it’s about
    time we worked on a relatively more complete and realistic example! That said,
    we will now use Terraform to automatically create and configure the vulnerable
    lab environment we manually prepared in *[Chapter 2](B19755_02.xhtml)*, *Preparing
    Our First Vulnerable Cloud Lab Environment*. By utilizing Terraform, we should
    be able to streamline the process of setting up the vulnerable lab environment
    that we previously prepared manually.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*What happened again in* *[Chapter 2](B19755_02.xhtml)**?* In *[Chapter 2](B19755_02.xhtml)*,
    we manually created an empty S3 bucket through the AWS Management Console and
    configured it for static website hosting. We then modified the access control
    settings of the bucket to allow authenticated AWS users to list and retrieve objects.
    To complete the setup, we uploaded sample files to the S3 bucket.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, this section is composed of four subparts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Creating an S3 bucket* *with Terraform*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Updating the security configuration of the* *S3 bucket*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Uploading files to the* *S3 bucket*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Cleaning up and deleting the* *S3 bucket*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without further ado, let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 4 – Creating an S3 bucket with Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing where we left off in the previous section, let’s create a **basics**
    directory using the **mkdir** command, then proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the directory created using the **cd** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the **touch** command to create an empty **main.tf** file inside the **vulnerable_s3_lab**
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to open the empty **main.tf** file using Vim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may type **:set nu** and then press the *Enter* key to show the line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, press *i* to switch to **insert mode** so that we can edit the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type or paste the following block of code into our **main.tf** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s declare an **aws_s3_bucket** resource by adding the following block
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<INSERT BUCKET NAME>** with a bucket name that is globally
    unique across all AWS users. If you are wondering what **force_destroy** does,
    it simply allows us to delete the S3 bucket along with all objects inside it without
    issues in a later step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For guidelines and rules on how to name S3 buckets, feel free to check out
    the following link: [https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **main.tf** and then exit Vim as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that our **main.tf** file is ready, let’s use the **terraform init** command
    to initialize the Terraform working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield a set of logs similar to what we have in *Figure 3**.6*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_03_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.6 – Logs generated after running the terraform plan command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that the values of some of the properties will only be known
    after the **terraform apply** command is executed (that is, when the resource
    has been created).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Understanding that certain property values are determined only after executing
    the **terraform apply** command is crucial. This dynamic nature of property values
    allows Terraform to accurately reflect the state of resources once they are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **terraform apply** command to implement the changes specified in the
    execution plan returned after running **terraform plan**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should yield a set of logs showing that we’ve successfully created the
    S3 bucket.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to use **terraform show** to check the current configuration settings
    of our S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we celebrate, let’s run the following to verify that our S3 bucket has
    been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure to replace **<INSERT BUCKET NAME>** with the bucket name specified
    in the **main.tf** file (from a previous step in this section). This should yield
    an output with the following format:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the bucket name you specified is **vuln-s3-abcdef-12345**, we should get
    an output with a format similar to **2023-10-01** **12:00:00 vuln-s3-abcdef-12345**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Part 2 of 4 – Updating the security configuration of the S3 bucket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re just getting started! In the following steps, we’ll learn how to update
    the security configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the following command to open the **main.tf** file again using
    Vim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may type **:set nu** and then press the *Enter* key to show the line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, hold the *Shift* key and then press *g* to navigate to the last line.
    Press *o* afterward. This should insert a new line after the current line (along
    with switching to **insert mode**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we’re in insert mode, let’s proceed by adding the following block
    of code to specify the public access block configuration for the S3 bucket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the **block_public_acls**, **block_public_policy**, **ignore_public_acls**,
    and **restrict_public_buckets** attributes are set to **false**. This means that
    the S3 bucket does not block public **access control lists** (**ACLs**) or public
    policies, does not ignore public ACLs, and does not restrict public buckets.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s also add the following to specify ownership controls for the S3 bucket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The ownership controls are set to **ObjectWriter**. This ensures that objects
    in the bucket can only be modified by the **Identity and Access Management** (**IAM**)
    user or role that uploaded them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s configure the S3 bucket for **static website hosting** by adding
    the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s define an **aws_iam_policy_document** data source block as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The policy described in the block of code grants permission to AWS principals
    (that is, *any* AWS account or IAM user) to perform the **s3:GetObject** action
    on objects within an S3 bucket. The **resources** attribute specifies the **Amazon
    Resource Name** (**ARN**) of the S3 bucket, followed by a wildcard character (*****)
    to allow access to all objects within the bucket.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering what a data source block is, it is simply a resource we
    can read data from. It allows us to retrieve information from existing resources
    or external systems. In addition to this, it acts as a *read-only* reference,
    providing valuable data that can be used in our configuration. We’ll see the data
    source block used in the succeeding set of steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also define **s3_policy** and **au_uri** local variables, which we will
    use in the succeeding configuration blocks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define an **aws_s3_bucket_policy** resource using the following block
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s define another data source block, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is the same data source block used in the previous section of this chapter.
    If you can’t remember what this is used for, this data source block will give
    us access to the AWS canonical user ID of the account used to run Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define an **aws_s3_bucket_acl** resource as well to set the S3 bucket’s
    ACL configuration settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code block configures the ACL of an S3 bucket. The **aws_s3_bucket_acl**
    resource sets permissions for two grants: one for a canonical user with **FULL_CONTROL**
    permission, and another for a group with **READ** permission. Here, the **data.aws_canonical_user_id**
    data source returns the canonical user ID for the first grantee. The **local.au_uri**
    local value, on the other hand, returns the URI (referring to an AWS pre-defined
    group called **AuthenticatedUsers**) for the second grantee.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You’ve probably noticed that our **main.tf** file has got longer. It’s important
    to note that we can divide and group the resources across different files. When
    we have multiple **.tf** files in the working directory, Terraform simply concatenates
    these files and proceeds with its usual set of infrastructure management operations.
    We won’t dive deep into the strategies and best practices in this chapter since
    we’ll tackle these in the succeeding chapters of this book as we build a variety
    of penetration testing lab environments in AWS, Azure, and GCP.
  prefs: []
  type: TYPE_NORMAL
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **main.tf** and then exit Vim as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before running the **terraform plan** command, let’s run **terraform fmt**
    to format our Terraform code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we make use of **terraform fmt** to establish a consistent coding style
    across our Terraform configuration files. By analyzing the files, this command
    adjusts indentation, spacing, and line breaks to align with the prescribed Terraform
    style guide.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield an execution plan similar to what we have in *Figure 3**.7*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_03_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.7 – Results after running the terraform plan command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that the execution plan now includes the updates on the security
    configuration settings of our S3 bucket.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With everything ready, let’s run the **terraform** **apply** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you encounter issues running **terraform apply -auto-approve**, feel
    free to rerun the same command as this may solve these issues automatically without
    having to modify the Terraform code. For example, if you encounter an “**Error
    putting S3 policy: AccessDenied: Access Denied**” error message, simply run **terraform
    apply -auto-approve** again. Note that an alternative for resolving issues would
    be to delete the resources first using **terraform destroy -auto-approve** and
    then create the resources again with **terraform** **apply -auto-approve**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s verify whether the ACL configuration for the bucket has been applied
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<INSERT BUCKET NAME>** with the name of your S3 bucket.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After running the command, we should get a JSON response similar to what we
    have in *Figure 3**.8*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_03_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.8 – Results returned after running the aws s3api get-bucket-acl command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that the new ACL configuration settings have been applied to
    our S3 bucket.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Part 3 of 4 – Uploading files to the S3 bucket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s add files to the S3 bucket created previously, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **touch** command to create an empty **upload.sh** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make the **upload.sh script** file executable, run the following command
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to open the empty **upload.sh** file using Vim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Type **:set nu** and then press the *Enter* key to show the line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, press *i* to switch to **insert mode** so that we can edit the **upload.sh**
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we are in insert mode, let’s proceed by adding the following block
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This set of commands simply (1) downloads a ZIP file from a GitHub repository
    containing a sample website and (2) uploads its contents to an Amazon S3 bucket.
    Make sure that the **SOURCE** variable value is correct by removing any extra
    spaces and checking if the download link is working when accessed directly using
    the browser.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is the same set of terminal commands used in *[Chapter 2](B19755_02.xhtml)*,
    *Preparing Our First Vulnerable Cloud Lab Environment*, to upload files to our
    S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **upload.sh** and then exit Vim as
    well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following command to open the **main.tf** file using Vim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Hold the *Shift* key and then press *g* to navigate to the last line. Press
    *o* afterward. This should insert a new line after the current line (along with
    switching to **insert mode**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following block of code after the new line inserted in the previous
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the **provisioner** block specifies that a **local-exec** provisioner
    will be used, and the **command** attribute specifies the shell command to be
    executed, which in this case is a shell script named **upload.sh**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the provisioner code in the preceding block of code can also be placed
    inside the **aws_s3_bucket** resource block or in other resource blocks (with
    a few minor modifications to get it working). For more information on how the
    **local-exec** provisioner works, feel free to check out the following link: [https://developer.hashicorp.com/terraform/language/resources/provisioners/local-exec](https://developer.hashicorp.com/terraform/language/resources/provisioners/local-exec).'
  prefs: []
  type: TYPE_NORMAL
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **main.tf** and then exit Vim as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us an error message similar to what we have in *Figure 3**.9*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_03_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.9 – Inconsistent dependency lock file error
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **Inconsistent dependency lock file** error in Terraform typically occurs
    when there is a mismatch between the dependency lock file and the configuration
    files. This inconsistency can arise due to changes made to the configuration without
    updating the lock file accordingly. That said, to resolve the **Inconsistent dependency
    lock file** error, let’s use the following command again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will sync the lock file with the configuration, resolving any inconsistencies
    and ensuring consistent dependencies for the Terraform deployment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should see the command succeed this time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With everything ready, let’s use the **terraform apply** command to implement
    the changes specified in the execution plan returned after running **terraform
    plan**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should run the commands coded in the **upload.sh** script.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s perform a few quick checks by running the **aws s3 ls** command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should list the objects stored in our S3 bucket.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to replace **<INSERT BUCKET NAME>** with the name of your S3 bucket
    before running the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use the **aws s3api get-bucket-website** command to check the static
    website hosting configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure to replace **<INSERT BUCKET NAME>** with the bucket name specified
    in the **main.tf** file (from a previous step in this section). This should return
    the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This confirms that the static website hosting configuration is properly set
    up for the specified S3 bucket.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s also check whether our static website hosting setup works by navigating
    to the following link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<BUCKET NAME>** with the name of the S3 bucket we created.
    Do not forget to replace **<REGION>** with the region where the S3 bucket was
    created (for example, **us-east-1**) as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If everything went well, we should see a maintenance page similar to what is
    shown in *Figure 3**.10*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Verifying that the static website hosting setup is working
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the vulnerable lab environment similar to what we prepared in
    *[Chapter 2](B19755_02.xhtml)*, *Preparing Our First Vulnerable Cloud Lab Environment*,
    is ready! Feel free to test the security configuration of our lab environment
    by following the steps specified in the *Testing and hacking our first vulnerable
    environment* section of *[Chapter 2](B19755_02.xhtml)* (where we will need the
    second AWS account).
  prefs: []
  type: TYPE_NORMAL
- en: Part 4 of 4 – Cleaning up and deleting the S3 bucket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we end this section, let’s clean up! Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use **terraform destroy** to clean up the resources we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: During the verification step (that is, when you see an **Enter a value:** message),
    type in **yes** to proceed with the deletion of the resources. After the resources
    are deleted, a backup file (**terraform.tfstate.backup**) containing a copy of
    the properties of the state file becomes available in the same directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You may use the **less** or **cat** command to check the properties stored
    in the **terraform.tfstate.backup** file. Alternatively, we can use the **terraform
    show** command on the **terraform.tfstate.backup** file to read its contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield an output similar to what we have in *Figure 3**.11*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_03_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.11 – Output after running terraform show
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In case you are tempted to use **terraform show** to convert a state file into
    a config file (similar to what we code inside the **main.tf** file), it is important
    to note that the output we have in *Figure 3**.11* is not intended for direct
    programmatic consumption (as it is made available primarily for us humans to troubleshoot
    and inspect the state stored inside a file).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you use **terraform show** (without any additional argument(s)), we should
    get an empty response since the resources have been deleted already at this point
    using **terraform destroy**.
  prefs: []
  type: TYPE_NORMAL
- en: Wow! We were able to successfully convert the manual steps from *[Chapter 2](B19755_02.xhtml)*
    into a single configuration file. At this point, if we want to create 10 clones
    of the S3 bucket (with all resources having the same set of properties and configuration
    settings except for the bucket name), we will just need a few minor modifications
    to what we have right now and then use Terraform to automatically create and configure
    the S3 resources for us.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Terraform backend with state locking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore how Terraform remote backends work and understand
    how state locking ensures the integrity and consistency of our infrastructure
    state when managing infrastructure deployments. Then, we will delve into the step-by-step
    process of configuring a remote backend to enable state locking.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Terraform remote backends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until this point, we have used the default **local backend**, which stores
    the state as a local file (that is, the **terraform.tfstate** file). This type
    of setup should be okay when only a single engineer is involved. Once another
    engineer wants to apply configuration changes to the same set of resources with
    Terraform, using a **remote backend** will make more sense since the second engineer
    needs to have access to the existing state file (used by the first engineer).
    In addition to this, we need to make sure that configuration changes to the same
    set of resources are not applied at the same time to prevent **race conditions,**
    which could lead to a corrupted state.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the best practices when using Terraform involves the usage of an external
    remote backend to store and lock the state (similar to what is shown in *Figure
    3**.12*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Local versus remote backend
  prefs: []
  type: TYPE_NORMAL
- en: This allows multiple engineers to work on the same set of resources without
    having to worry about corrupting the setup. Configuring the right backend is critical
    as the Terraform backend dictates how state is loaded, which in turn affects the
    resource creation and modification processes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Carefully selecting and configuring the backend ensures secure collaboration,
    version control, and proper state management throughout the infrastructure life
    cycle. This enhances the reliability and scalability of the Terraform workflow
    for teams working on the same set of resources. For more information, feel free
    to check out the following link: [https://developer.hashicorp.com/terraform/language/settings/backends/configuration](https://developer.hashicorp.com/terraform/language/settings/backends/configuration).'
  prefs: []
  type: TYPE_NORMAL
- en: That said, to address the challenges of collaboration and prevent potential
    conflicts, it is recommended to switch from the default local backend to a remote
    backend in Terraform. By using a remote backend, such as an S3 bucket, multiple
    engineers can securely access and modify the same state file. This facilitates
    coordination and ensures consistency when making configuration changes to shared
    resources. Additionally, utilizing a remote backend helps mitigate the risk of
    race conditions, as it provides a centralized mechanism for managing and locking
    the state, reducing the likelihood of encountering a corrupted state.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Terraform remote backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**State locking** plays a vital role in avoiding conflicts and race conditions.
    By allowing only one user or process to modify the state at any given time, it
    ensures integrity and synchronization across Terraform deployments. This mechanism
    is crucial for maintaining data consistency and preventing unwanted changes during
    collaborative infrastructure management.'
  prefs: []
  type: TYPE_NORMAL
- en: When configuring state locking for a Terraform backend in an AWS cloud environment,
    it is common to use an S3 bucket and a DynamoDB table. The S3 bucket acts as secure
    storage for the Terraform state file, while the DynamoDB table serves as a distributed
    lock mechanism. With state locking, only one Terraform command can hold the lock
    at a time, and others wait until it’s released. This setup ensures consistency
    and prevents conflicts in collaborative or automated Terraform environments. We
    will label the S3 bucket **BACKEND_S3** and the DynamoDB table **BACKEND_TABLE**
    as we will refer to these resources multiple times in this chapter. Note that
    **BACKEND_S3** and **BACKEND_TABLE** are just arbitrary labels we will use in
    this chapter to make it easier for us to refer to the resources we will be creating
    in the succeeding set of steps. That said, these labels are different from the
    actual resource names of the cloud infrastructure resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering what DynamoDB is, it is a fully managed NoSQL database
    service in AWS. In DynamoDB, tables consist of items and attributes. Each item
    represents a distinct piece of data, similar to a row in a traditional database.
    Items are composed of attributes, which are key-value pairs that store the actual
    data. One thing to note is that DynamoDB tables do not require a fixed schema,
    meaning each item can have a different set of attributes. To implement the distributed
    lock mechanism, Terraform utilizes the DynamoDB table by creating a unique item
    or record as a lock indicator. When a Terraform command attempts to acquire a
    lock, it checks whether the designated item exists. If it does not exist, the
    command adds the item to the DynamoDB table, indicating that it has acquired the
    lock. This prevents other Terraform commands from acquiring the lock concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next set of steps, we will upgrade our setup by configuring a Terraform
    backend to store and lock state:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the home directory using the **cd** command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create a **backend** directory using the **mkdir** command. After creating
    the **backend** directory, let’s navigate to the directory using the **cd** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s use the **touch** command to create an empty **main.tf** file inside
    the **backend** directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to open the empty **main.tf** file using Vim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may type **:set nu** and then press the *Enter* key to show the line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, press *i* to switch to **insert mode** so that we can edit the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following block of code to our **main.tf** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s define a *new* **aws_s3_bucket** resource (for the backend). Note
    that this S3 bucket resource is different from the misconfigured S3 bucket used
    in our vulnerable lab environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the **lifecycle** block includes a **prevent_destroy** attribute set to
    **true**, ensuring that the bucket cannot be destroyed accidentally. This means
    that the Terraform state file stored in this bucket is protected from being accidentally
    deleted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to replace **<INSERT S3 BACKEND BUCKET NAME>** with a unique S3 bucket
    name (for example, **tf-remote-backend-abcdef-<random string>**). Note that at
    this point, this bucket should *not* exist yet as we have not executed the **terraform**
    **apply** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add the following block of code to enable **bucket versioning**
    and configure **server-side encryption** for our S3 bucket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, bucket versioning and server-side encryption are used for the S3 bucket,
    which will store the Terraform remote state. Versioning ensures that previous
    versions of the remote state are retained, allowing for easy recovery in the event
    of accidental deletion or corruption. Server-side encryption, on the other hand,
    ensures that sensitive data in the remote state is encrypted at rest to add an
    extra layer of security.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s define an **aws_dynamodb_table** resource using the following block
    of code (using the name of our S3 bucket for the name of our DynamoDB table):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, **billing_mode** is set to **"PAY_PER_REQUEST"**, meaning that (1) we
    only pay for read and write requests to the table, and (2) there are no upfront
    costs or minimum fees.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press the *Esc* key to switch back to normal mode. Type **:wq!** and then press
    *Enter*. This will save the changes made to **main.tf** and then exit Vim as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we should have two **main.tf** files: (1) **~/vulnerable_s3_lab/main.tf**
    and (2) **~/backend/main.tf**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our **~/backend/main.tf** file is ready, let’s use the **terraform
    init** command to initialize the Terraform working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With everything ready, let’s use the **terraform apply** command to implement
    the changes specified in the execution plan returned after running **terraform
    plan**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a few minutes for this step to complete. After successfully running
    the **terraform apply** command, we should have a new S3 bucket and a new DynamoDB
    table. Let’s label these resources **BACKEND_S3** and **BACKEND_TABLE** respectively
    as we will refer to these resources multiple times in this chapter. Note that
    this S3 bucket will be used for the Terraform remote backend and is different
    from the intentionally misconfigured S3 bucket used for the vulnerable lab environment
    (which we will label **VULNERABLE_S3**). With the Terraform remote backend ready,
    we can now proceed with configuring our existing Terraform code to use this remote
    backend. Make sure to take note of the names of the AWS S3 bucket (**BACKEND_S3**)
    and DynamoDB table (**BACKEND_TABLE**) resources created after running the **terraform
    apply** command before proceeding. You may use the **terraform show** command
    to inspect the existing infrastructure resources managed by Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate back to the **vulnerable_s3_lab** directory using the **cd** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to open the **main.tf** file using Vim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, press *i* to switch to **insert mode** so that we can edit the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the following block of code using the arrow keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you’ve located the previous block of code, update it with the following
    block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<INSERT BUCKET NAME>** and **<INSERT TABLE NAME>** with
    the S3 bucket (**BACKEND_S3**) and DynamoDB table (**BACKEND_TABLE**) names respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will specify the resource names of the existing S3 bucket (labeled
    **BACKEND_S3**) and DynamoDB table (labeled **BACKEND_TABLE**) resources created
    in an earlier step for the Terraform remote backend setup. Note that **BACKEND_S3**
    and **BACKEND_TABLE** are just arbitrary labels we’ve used in this chapter to
    make it easier for us to refer to the resources we created in earlier steps. That
    said, these are *not* the resource names that will be used to replace **<INSERT
    BUCKET NAME>** and **<INSERT TABLE NAME>** in the code block. Feel free to run
    the **terraform show** command again inside the **~/backend** directory to get
    the resource names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our **~/vulnerable_s3_lab/main.tf** file has been updated, let’s run
    **terraform fmt** to format our Terraform code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are using **terraform fmt** to ensure a consistent coding style across
    all Terraform configuration files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s use the **terraform init** command to reinitialize the Terraform working
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s run **terraform plan** to preview the changes to be performed by
    Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s use the **terraform** **apply** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create a misconfigured S3 bucket (labeled **VULNERABLE_S3**) for our
    vulnerable lab environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In case you encounter issues running **terraform apply -auto-approve**, feel
    free to rerun the same command as this may solve these issues automatically without
    having to modify the Terraform code. Note that an alternative for resolving issues
    would be to delete the resources first using **terraform destroy -auto-approve**
    and then create the resources again with **terraform** **apply -auto-approve**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we celebrate, let’s verify whether the S3 bucket used for the backend
    (**BACKEND_S3**) has the **terraform.tfstate** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<S3 BACKEND BUCKET NAME>** with the name of the S3 bucket
    (labeled **BACKEND_S3**) used for the Terraform backend specified in our **~/****backend/main.tf**
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After running the **aws s3 ls** command, we should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that we have successfully reconfigured our Terraform code to store
    the state file inside an S3 bucket (instead of the local directory).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, let’s open a new browser tab and navigate to the home page of the AWS
    Management Console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Do not close the browser tab where we are running commands inside the AWS CloudShell
    terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the DynamoDB console by typing **dynamodb** in the search bar and
    then selecting **DynamoDB** from the list of results. In the navigation pane on
    the left side of the DynamoDB console, choose **PartiQL editor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering what **PartiQL** is, it is simply a SQL-compatible query
    language for DynamoDB. With PartiQL, we can query our DynamoDB tables similarly
    to how we would query our SQL database tables. This allows us to leverage our
    existing SQL knowledge and skills when working with DynamoDB, making it easier
    to write and execute complex queries against our NoSQL data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specify the following query in the PartiQL editor (text area):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<INSERT TABLE NAME>** with the name of the DynamoDB table
    (labeled **BACKEND_TABLE**) we created (using Terraform) in an earlier step in
    this section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to run the **terraform show** command again inside the **~/backend**
    directory to get the resource name of the DynamoDB table we labeled **BACKEND_TABLE**.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Run** button to execute the query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our query should return a single item where the **LockID** value is **<BACKEND_S3
    BUCKET NAME>/terraform/terraform.tfstate-md5**. This item should also have a randomly
    generated alphanumeric **Digest** value similar to **51f8a19d543d54b0481f1823b1784896**.
    This **digest** value is a representation of the Terraform state file’s content.
    It is used to detect changes in the state file and ensure consistency during operations
    such as **plan**, **apply**, and **destroy**. When we modify the infrastructure,
    Terraform will make changes to the state file, but the digest itself will not
    change unless the content of the state file has changed. That said, this value
    acts as a checksum or hash of the state file’s content, which allows Terraform
    to determine whether the state file has been modified externally (or whether there
    are concurrent modifications that may result in conflicts).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, navigate back to the CloudShell browser tab and then use the **terraform
    destroy** command to clean up the resources we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: During the verification step (that is, when you see **Enter a value:**), type
    in **yes** to proceed with the deletion of the resources.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The resources deleted in the last step do not include the Terraform backend
    resources (that is, **BACKEND_S3** and **BACKEND_TABLE**) as these resources were
    defined in **~/backend/main.tf**.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not done yet! In the next section, we will verify whether our state-locking
    setup is working.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the state-locking setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verifying the Terraform state-lock setup is crucial to ensure the integrity
    of our infrastructure management process. By verifying the state-lock setup, we
    can confirm that the distributed lock mechanism using S3 and DynamoDB from the
    previous section is functioning correctly. That said, what happens when two users
    attempt to run **terraform apply** almost at the same time? We will see what happens
    in the next set of steps!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This scenario of concurrent **terraform apply** commands highlights the importance
    of state locking to prevent conflicts and ensure data consistency. In this section,
    we will explore how Terraform manages state locks and handles concurrent operations.
    This will help us have a better understanding of the behavior and safeguards implemented
    by Terraform in such situations.
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 4 – Adding a 60-second delay to the upload script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing from where we left off in the previous section, let’s navigate to
    the **vulnerable_s3_lab** directory using the **cd** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to open the **upload.sh** file using Vim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may type **:set nu** and then press the *Enter* key to show the line numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Use the arrow keys to put the cursor before the first character of the first
    line. After that, press *i* to switch to insert mode so that we can edit the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code at the start of the **upload.sh** script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The 2 lines added at the start of the script should make the **upload.sh** script
    run 60 seconds longer. This should give us a few extra seconds to run the commands
    needed to verify whether the state-locking setup is working.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press the *Esc* key to switch to normal mode. Type **:wq!**. Press *Enter* afterward.
    This will save the changes made to **upload.sh** and then exit Vim as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the **cat** command (**cat upload.sh**) to verify our updated **upload.sh**
    file looks similar to what we have in the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we basically have the same **upload.sh** file except that the first 2
    lines have been added to add a 60-second delay when running the script.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Part 2 of 4 – Acquiring the state lock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s split the CloudShell terminal screen vertically. Press the *Ctrl*
    key while pressing *b*. Release both keys and then press *%* (or *Shift* + *5*)
    after about half a second. This should create a vertical split similar to what
    we have in *Figure 3**.13*:![](image/B19755_03_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 3.13 – Vertical split in tmux
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since AWS CloudShell comes pre-installed with **tmux**, we should be able to
    use the **tmux** commands directly without having to install the utility separately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is your first time using **tmux**, do not worry as it may take a few
    tries before getting the key combinations right! Feel free to watch this tutorial
    video for more information on how to use **tmux**: [https://www.youtube.com/watch?v=Yl7NFenTgIo](https://www.youtube.com/watch?v=Yl7NFenTgIo).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s jump to the left pane. Press the *Ctrl* key while pressing *b*. Release
    both keys and then press the *left arrow* key after about half a second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run the following command on the left pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should yield a set of logs similar to the logs generated after running
    the **terraform apply** command in the *Building our vulnerable lab environment
    with Terraform* section of this chapter. You may ignore any **AccessDenied** error
    messages as these can easily be solved by retrying the command in the left pane
    (which we don't need to do at this point).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Running the **terraform apply** command will acquire a state lock to ensure
    that concurrent operations do not modify the infrastructure state simultaneously.
    This lock is essential for maintaining consistency and preventing conflicts in
    collaborative or automated environments. By acquiring the lock before making any
    modifications, we ensure that multiple **terraform apply** commands wait for the
    lock to be released before proceeding. That said, do *not* wait for the **terraform
    apply** command to finish! Proceed to the next set of steps right after running
    the command on the left pane.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 of 4 – Testing our state-lock setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test our state-lock setup, we will run another **terraform apply** command
    while the first **terraform apply** command is still running. That said, let’s
    jump to the right pane. Press the *Ctrl* key while pressing *b*. Release both
    keys and then press the *right arrow* key after about half a second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While the **terraform apply** command is running on the left pane, run the
    following command on the right pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us an error similar to what is shown in *Figure 3**.14*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_03_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 3.14 – Error acquiring the state lock
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This means that we can’t acquire a state lock at the moment while the first
    **terraform apply** command is still running (in the left pane). Once the command
    in the left pane succeeds (or fails due to an error), the state lock will be released.
    *Is this the expected behavior? YES!* By acquiring the state lock in an earlier
    step, we have ensured that only one **terraform apply** command can modify the
    state at a time. This sequential approach guarantees consistency and prevents
    race conditions. Therefore, it is normal for subsequent **terraform apply** commands
    to wait until the initial command completes and releases the state lock before
    proceeding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Of course, there will be cases where the state lock is not released automatically
    (most likely due to an unexpected issue). To resolve this issue, you may use **terraform
    force-unlock -force <ID>** to manually unlock the state. You can find the **ID**
    value in the **Lock Info** section of the error message (similar to what we have
    in *Figure 3**.14*).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In case you missed the timing (that is, the **terraform apply** command in the
    left pane finished executing before you were able to run the **terraform apply**
    command in the right pane), feel free to destroy the created resources by running
    **terraform destroy -auto-approve** inside the **~/vulnerable_s3_lab** directory
    so that you can try repeating the last set of steps. You may also replace the
    60-second delay with a 120-second delay by modifying the **upload.sh** file to
    give you more time to jump between **tmux** panes.
  prefs: []
  type: TYPE_NORMAL
- en: Part 4 of 4 – Cleaning up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our state-lock verification experiment complete, let’s exit the **tmux**
    session on the right pane using the **exit** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should leave us with a single pane (removing the vertical split).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before we end this section, let’s use **terraform destroy** to clean up the
    resources we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: During the verification step (that is, when you see **Enter a value:**), type
    in **yes** to proceed with the deletion of the resources. This will delete the
    resources (primarily the S3 bucket labeled **VULNERABLE_S3**) specified in the
    **main.tf** file inside the **vulnerable_s3_lab** directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to delete the remaining S3 bucket (used as the remote state backend
    we labeled **BACKEND_S3**) along with the DynamoDB table (labeled **BACKEND_TABLE**)
    as well. We will leave this to you as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Wow! That was one productive and action-packed chapter! At this point, we should
    already have a good grasp of how we can utilize Terraform (along with IaC concepts
    and strategies) to create and configure cloud resources. In the succeeding chapters,
    we will dive deeper into how the things we learned in this chapter play a pivotal
    role in building penetration testing labs in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about how IaC can help us automatically prepare,
    configure, and manage our penetration testing lab environments in the cloud. We
    then used Terraform, one of the most powerful and most used IaC tools available,
    to create, modify, and delete cloud infrastructure resources. After setting up
    Terraform in our environment, we then proceeded with several hands-on examples
    to demonstrate the different capabilities of the tool. In addition to this, we
    rebuilt the vulnerable lab environment we prepared in *[Chapter 2](B19755_02.xhtml)*
    using Terraform (this time, automatically). Finally, we had a quick look at how
    to configure a Terraform backend with state locking to help prevent conflicts
    when multiple engineers are using Terraform to modify infrastructure resources.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll dive deep into the different strategies for isolating
    accounts and environments in the cloud. The information, along with the hands-on
    solutions in the next chapter, will help us secure and manage our penetration
    testing lab environments in the cloud properly.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on the topics covered in this chapter, feel free to check
    out the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Finding the canonical user ID for your AWS* *account* ([https://docs.aws.amazon.com/AmazonS3/latest/userguide/finding-canonical-user-id.html](https://docs.aws.amazon.com/AmazonS3/latest/userguide/finding-canonical-user-id.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Terraform Language* *Documentation* ([https://developer.hashicorp.com/terraform/language](https://developer.hashicorp.com/terraform/language))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Terraform—Remote* *State* ([https://developer.hashicorp.com/terraform/language/state/remote](https://developer.hashicorp.com/terraform/language/state/remote))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Terraform—State* *Locking* ([https://developer.hashicorp.com/terraform/language/state/locking](https://developer.hashicorp.com/terraform/language/state/locking))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Terraform—Recovering from State* *Disasters* ([https://developer.hashicorp.com/terraform/cli/state/recover](https://developer.hashicorp.com/terraform/cli/state/recover))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Great Vim Cheat* *Sheet* ([https://vimsheet.com/](https://vimsheet.com/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tmux Cheat Sheet & Quick* *Reference* ([https://tmuxcheatsheet.com/](https://tmuxcheatsheet.com/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 2: Setting Up Isolated Penetration Testing Lab Environments in the Cloud'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will learn how to build and automate isolated penetration
    testing lab environments on AWS, Azure, and GCP.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Chapter 4](B19755_04.xhtml)*, *Setting Up Isolated Penetration Testing Lab
    Environments on GCP*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[Chapter 5](B19755_05.xhtml)*, *Setting Up Isolated Penetration Testing Lab
    Environments on Azure*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[Chapter 6](B19755_06.xhtml)*, *Setting Up Isolated Penetration Testing Lab
    Environments on AWS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
