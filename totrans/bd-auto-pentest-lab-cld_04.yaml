- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up Isolated Penetration Testing Lab Environments on GCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While setting up cloud-based penetration testing labs, we are deliberately creating
    a vulnerable and misconfigured environment where we can practice various security
    techniques. It is critical that we secure the resources inside this lab environment
    from unauthorized external attacks and mitigate the risk of planned interference
    with any of the authorized testing activities or simulations inside the environment.
    *Imagine attackers managing to gain unauthorized access to vulnerable resources
    inside your penetration testing lab environment!* These attackers would be able
    to leverage the cloud resources to perform various malicious activities—including
    launching **Distributed Denial-of-Service** (**DDoS**) attacks, attacking the
    systems owned by other users and organizations, and even spreading malware from
    inside the compromised cloud account. *Scary, right?* By isolating vulnerable
    lab resources using a properly configured network environment, we can maintain
    a secure testing environment and minimize the risks associated with having penetration
    testing lab environments in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will prepare an isolated network environment in **Google
    Cloud Platform** (**GCP**) and use this network environment for setting up a penetration
    testing lab environment secured from unauthorized external attacks. Inside one
    of the **Virtual Private Cloud** (**VPC**) networks of the overall network environment,
    we will set up a target **virtual machine** (**VM**) instance that hosts an intentionally
    vulnerable web application called the **OWASP Juice Shop**. Then, in a separate
    VPC network, we will launch an attacker VM instance (running a penetration testing-focused
    Linux distribution called **Kali Linux**) and configure it with browser-based
    access to its desktop environment. We will then establish VPC peering to create
    a connection between the target VPC network and the attacker VPC network. Finally,
    we will perform a quick penetration testing simulation inside the isolated network
    environment to verify that everything is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, we will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the necessary components and prerequisites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the project structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the isolated network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the target VM instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing the Kali Linux Generic Cloud Image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually setting up the attacker VM instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Terraform to automatically set up the attacker VM instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating penetration testing in an isolated network environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first few chapters of this book, we primarily focused on using AWS when
    setting up penetration testing lab environments in the cloud. However, in this
    chapter, our attention will shift to GCP, where we will deploy various cloud resources
    inside a new GCP account. Since its introduction in 2008, GCP has rapidly evolved
    to offer a diverse range of infrastructure and platform services—including VMs
    and database services, along with data engineering and **machine learning** (**ML**)
    services. That said, it is essential for us to explore the process of building
    penetration testing lab environments within this mature and versatile cloud platform.
  prefs: []
  type: TYPE_NORMAL
- en: With these points in mind, let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start, we must have the following ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A GCP account**—You may start with a free trial account by completing the
    steps specified in the following link: [https://cloud.google.com/free/](https://cloud.google.com/free/).
    In case you have not set up a billing account in your GCP account, make sure that
    you have properly set up billing information/profile so that you can access and
    use the GCP services without interruption. For more information on how to create
    a billing account, check the following link: [https://www.youtube.com/watch?v=NeRYUoR4u0s](https://www.youtube.com/watch?v=NeRYUoR4u0s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any text editor (such as Notepad++, Visual Studio Code, or Sublime Text) where
    we can temporarily store specific values (for example, your local machine’s IP
    address) used in the hands-on solutions in this chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may proceed with the next steps once these are ready.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure *NOT* to use any existing GCP account with production (or staging)
    environment resources for the hands-on exercises and solutions in this book. It
    is strongly recommended to create a *new* GCP account specifically for launching
    intentionally vulnerable resources. This will ensure that your production (or
    staging) environment resources remain separate and secure. In addition to this,
    make sure to read the available documentation along with the FAQs to have a solid
    understanding of what is free (and what is not free) when creating resources in
    GCP. For more information, see the following link: [https://cloud.google.com/free/docs/free-cloud-features](https://cloud.google.com/free/docs/free-cloud-features).'
  prefs: []
  type: TYPE_NORMAL
- en: The source code and other files used for each chapter are available in this
    book’s GitHub repository at [https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the necessary components and prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will focus on preparing the prerequisites needed for this
    chapter. We will start by retrieving the IP address of your local machine. We’ll
    use this IP address value later when configuring the firewall rules to allow our
    local machine to access specific resources inside the lab environment. In addition
    to this, we will also set up the Google Cloud project where the cloud resources
    will be deployed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will generate SSH keys (a **public key** and a **private key**) for
    accessing the attacker VM instance later in this chapter. As we can see in *Figure
    4**.1*, the private key will be stored inside your local machine while the public
    key will be stored inside the attacker VM instance.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Generating SSH keys for accessing the attacker VM instance
  prefs: []
  type: TYPE_NORMAL
- en: With this setup, the server (the attacker VM instance) can confirm the identity
    of the client (your local machine) using the private key without having to transmit
    sensitive credentials. This will then allow us to access the attacker VM instance
    via SSH and establish a secure connection for running commands and managing the
    instance remotely.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.1*, we can see the target VM instance along with the other components
    of the penetration testing lab environment. We will dive deeper into how the other
    resources in the lab environment will be configured in the succeeding sections
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, we’ll divide this section into three parts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 3 – Retrieving the IP address of your* *local machine*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 3 – Setting up the Google* *Cloud project*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 3 of 3 – Generating SSH keys to access the attacker* *VM instance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these points in mind, let’s proceed with the preparation of the necessary
    components and prerequisites for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 3 – Retrieving the IP address of your local machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Take note of your local machine’s IP address using [https://ipinfo.io/ip](https://ipinfo.io/ip),
    [https://ifconfig.io/](https://ifconfig.io/), or other similar websites and online
    tools. Alternatively, you may use Google search to retrieve your local machine’s
    IP address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store and save your IP address information in a text editor as we will use this
    to allow our local machine to access the attacker VM instance later in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Part 2 of 3 – Setting up the Google Cloud project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s create the Google Cloud project where we will deploy the cloud resources
    in this chapter. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the Google Cloud console by opening the following link in your
    web browser: [https://console.cloud.google.com/](https://console.cloud.google.com/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Google Cloud console** is a web interface provided by GCP for managing
    cloud resources. You can think of it as the counterpart of the **AWS Management
    Console** we used in the first few chapters of this book. If you need a quick
    introduction to how to use the Google Cloud console, feel free to watch the following
    6-minute video: [https://www.youtube.com/watch?v=27Pb5g7bEAA](https://www.youtube.com/watch?v=27Pb5g7bEAA).'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Google Cloud** console, open the navigation menu (**☰**):![](image/B19755_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.2 – Navigating to the Create a Project page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Locate and click **Create a project** under **IAM & Admin**, as highlighted
    in *Figure 4**.2*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Project name** field, specify **secure-network-environments**. Keep
    the value in the **Location** field as it is (**No organization**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **CREATE** button afterward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Projects** in GCP are used to organize resources into logical groups. Inside
    a project, we can have a set of users who have access to the project resources.
    A project includes the users and the APIs, along with specific configuration settings
    for these APIs. For more information, feel free to check the following link: [https://cloud.google.com/storage/docs/projects](https://cloud.google.com/storage/docs/projects).'
  prefs: []
  type: TYPE_NORMAL
- en: Once the project has been successfully created, click the drop-down menu highlighted
    in *Figure 4**.3*:![](image/B19755_04_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.3 – Opening the Select a project popup
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Select a project** popup, select the **secure-network-environments**
    project and then click the **OPEN** button afterward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Locate and click the **Activate Cloud Shell** button, as highlighted in *Figure
    4**.4*:![](image/B19755_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.4 – Activating Cloud Shell
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This should open a terminal where we can run command-line commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It may take a minute or two for Cloud Shell to be ready.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Open Editor** button located at the upper right-hand corner of the
    Cloud Shell terminal pane. This should open the Cloud Shell editor, similar to
    what we have in *Figure 4**.5*:![](image/B19755_04_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.5 – Cloud Shell editor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you can’t see a terminal similar to what we have in *Figure 4**.5*, open
    the **Terminal** menu of the Cloud Shell editor and then select **New Terminal**
    from the list of options.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Google **Cloud Shell** provides a web-based interactive shell environment where
    we can run commands, write scripts, and manage resources when working with cloud
    resources and applications. Since we used **AWS CloudShell** in the previous chapters,
    we should easily adapt to using Google Cloud Shell in this chapter. It is important
    to note that Google Cloud Shell also provides an integrated code editor, allowing
    us to write, edit, and save scripts and configuration files directly within the
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal (right after the **$** sign), run the following command to
    list the projects in your GCP account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you see the **Authorize Cloud Shell** popup (similar to what is shown in
    *Figure 4**.6*), make sure to click the **AUTHORIZE** button to allow the **gcloud**
    **command-line interface** (**CLI**) to make API calls for us:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.6 – Authorize Cloud Shell
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If this is your first time using the **gcloud** CLI, it is simply a command-line
    tool that helps us create and manage a variety of Google Cloud resources.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Running the preceding command should then give us the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to take note of the **PROJECT_ID** value as we’ll need this when configuring
    the active project in the next set of steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, run the following command to check the active project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the previous command returned a project ID that does not match the **<PROJECT_ID>**
    value from the previous step, run the following command to configure a new active
    project—this time specifying the **<PROJECT_ID>** value obtained from the previous
    step:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Feel free to use the **gcloud config get-value project** command again to verify
    that the previous command succeeded. Note that when the Cloud Shell environment
    restarts, we may have to configure the active project again using **gcloud config
    set project <PROJECT_ID>** so that we’re running commands and creating cloud resources
    inside the correct project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure *NOT* to use the project name (that is, **secure-network-environments**)
    for the **<PROJECT_ID>** value when using the **gcloud config set project** command.
    Specifying the incorrect **<PROJECT_ID>** value will yield the following warning
    message: **You do not appear to have access to project [secure-network-environments]
    or it does** **not exist.**'
  prefs: []
  type: TYPE_NORMAL
- en: Using the search bar, navigate to the **VPC networks** page using the **vpc
    networks** search query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the Compute Engine API is not enabled yet, you will be redirected to the
    Compute Engine API page, similar to what is shown in *Figure 4**.7*:![](image/B19755_04_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.7 – Enabling the Compute Engine API
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **ENABLE** button to proceed. Wait for about 3-5 minutes for the Compute
    Engine API to be enabled. Note that this step is necessary to ensure that you
    have access to Compute Engine services and functionalities within your project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Part 3 of 3 – Generating SSH keys to access the attacker VM instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s generate SSH keys for accessing the attacker VM instance (which
    we’ll set up later in this chapter). Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing where we left off in the previous part, let’s open a new **Cloud
    Shell** terminal (or reuse an existing one). Make sure that we are using **secure-network-environments**
    as the active project configured before proceeding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the terminal (right after the **$** sign), run the following commands to
    create a new directory (named **kali_keys**) and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will store the generated keys inside this directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate a new SSH key pair and save the generated key files in the **kali_keys**
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When asked for a passphrase, just press *Enter* as we won’t add a passphrase
    to our key (the same goes for the password confirmation). This will generate two
    files—**kali-ssh** (the private key) and **kali-ssh.pub** (the public key).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*How do these SSH key files work?* SSH key files consist of a **private key**
    (stored and kept on the client’s machine) and a corresponding **public key** uploaded
    to the remote server. During authentication, the client uses its private key to
    generate a digital signature, and the server verifies it using the corresponding
    public key. Here, the server can confirm the client’s identity based on the possession
    of the private key without having to transmit sensitive credentials.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the public key value using the **cat** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Store this value in a text editor on your local machine as we will use this
    later in the *Manually setting up the attacker VM instance* section of this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Open Editor** button (in case the editor is not yet open).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It may take a minute or two for the **Cloud Shell editor** to load.
  prefs: []
  type: TYPE_NORMAL
- en: Locate the generated private key (**kali-ssh**) in the file tree of the editor
    (similar to what is shown in *Figure 4**.8*):![](image/B19755_04_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.8 – Downloading the generated private key file
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the file and then select **Download** from the options in the
    context menu. Feel free to perform the same set of steps for the public key (**kali-ssh.pub**)
    to download it to your local machine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the prerequisites ready, we can now proceed with setting up
    and defining the project structure!
  prefs: []
  type: TYPE_NORMAL
- en: Defining the project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce the usage of Terraform **modules** to help
    define and organize our **Infrastructure-as-Code** (**IaC**) project structure.
    Modules allow us to encapsulate and reuse sets of resources to make our Terraform
    code more modular, maintainable, and scalable. By leveraging modules, we will
    be able to simplify the management of complex infrastructure deployments and abstract
    common configurations into reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *[Chapter 3](B19755_03.xhtml)*, *Succeeding with Infrastructure as Code
    Tools and Strategies*, we stored all our **.tf** files in a single directory.
    *It feels a bit messy, right?* In case you are wondering how modules change how
    we organize our code and our files, here’s an example of what the project structure
    might look like once we utilize Terraform modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Sample file and folder structure using Terraform modules
  prefs: []
  type: TYPE_NORMAL
- en: 'We have in *Figure 4**.9* a sample file and folder structure (left) along with
    how module directories are loaded in the **main.tf** file of the root module (right).
    Here, the **root_module** directory serves as the main entry point for the Terraform
    configuration. Directories such as **module1** and **module2** inside the project
    root directory will contain Terraform files such as **main.tf**, **variables.tf**,
    and **outputs.tf** specific to those modules. The modules are then defined in
    the **main.tf** file of the root module using the **module** block, similar to
    what we have in the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that while it is common practice to have a separate directory named **modules**
    to store individual module directories such as **module1**, **module2**, and **module3**,
    we will follow the current project and folder structure shown in *Figure 4**.9*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the **module1**, **module2**, and **module3** directory
    names used in our example are arbitrary and can be renamed according to the user’s
    preference. For instance, alternative names such as **secure_network**, **attacker_vm**,
    and **target_vm** can be used to provide more descriptive and meaningful names
    for the modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The organization and modularization of the IaC configuration files are influenced
    by the overall design of the penetration testing lab environment along with how
    the resources are grouped together. It is crucial that we discuss (at a high level
    for now) what our lab environment will look like in this section. Have a look
    at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – High-level diagram of our penetration testing lab environment
    in GCP
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4**.10*, we have two VPC networks: **VPC 01** and **VPC 02**. If
    you are wondering what VPC networks are, these are simply isolated virtual networks
    within a cloud computing environment that allow us to securely separate and manage
    resources. *That being said, which resources are we planning to have inside these
    networks?* Inside **VPC 01**, we’ll have the target VM instance. On the other
    hand, we’ll have the attacker VM instance inside **VPC 02**. One way to group
    these resources together is by using the following groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Group 1**—**VPC 01** and the target VM instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group 2**—**VPC 02** and the attacker VM instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should take into consideration the possible limitations of this approach.
    Grouping **VPC 01** and the target VM instance together may restrict the flexibility
    and scalability of the network environment (from a modularization standpoint).
    If we want to add more target VM instances in the future, we will need to modify
    the existing group and potentially cause the first group to have too many resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with VPCs and VM instances, do not worry as we will discuss
    these in more detail in the upcoming section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, another option involves creating three distinct modules, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **secure_network** module—Network resources such as **VPC 01** and **VPC
    02**, along with other relevant resources grouped together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **target_vm** module—The target VM instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **attacker_vm** module—The attacker VM instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This alternative appears to be a more favorable choice as it leans toward the
    preparation of a reusable network environment module that can be easily utilized
    for various iterations of our penetration testing lab environments in GCP. In
    addition to this, it provides the flexibility to swap out the target VM instance
    module with one or more alternative vulnerable-by-design target modules. While
    this approach is not perfect, this should do the trick for now as it offers significant
    advantages in terms of scalability, modularity, and adaptability for building
    dynamic penetration testing lab environments in GCP.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the overview of our penetration testing lab environment in this section feels
    a bit vague and lacking in detail, do not worry – we will have a more comprehensive
    discussion as we go through each of the succeeding sections in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s proceed with setting up the initial project files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing where we left off in the previous section, let’s make sure that we
    have a terminal ready where we’ll run the commands:![](image/B19755_04_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.11 – Opening a new terminal
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the **Terminal** menu of the Cloud Shell editor (as highlighted in *Figure
    4**.11*). Select **New Terminal** from the list of options available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the terminal (right after the **$** sign), run the following commands to
    create a **pentest_lab** project directory (and navigate to the new directory
    as well):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **pentest_lab** directory, let’s also create **secure_network**,
    **target_vm**, and **attacker_vm** directories, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll store the corresponding module files later in these directories.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While it is common practice to have a separate directory named **modules** to
    store individual module directories such as **secure_network**, **target_vm**,
    and **attacker_vm**, our current project and folder structure should suffice for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the files we’ll have in the root folder of our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that at this point, these files are still empty. We will populate them
    with the necessary configurations as we go along. This is what our project structure
    currently looks like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.12 – What our current project structure looks like in the file tree
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, we have three empty directories (**attacker_vm**, **secure_network**,
    and **target_vm**) along with six empty files (**main.tf**, **outputs.tf**, **provider.tf**,
    **terraform.tfvars**, **variables.tf**, and **versions.tf**) inside the **pentest_lab**
    directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By locating the file in the file tree (left of the editor), open the **provider.tf**
    file in the editor and add the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are configuring the Google provider, specifying the region as **us-central1**
    and the zone as **us-central1-c**. This provider configuration ensures that the
    resources we deploy with Terraform will be provisioned within the specified region
    and zone in GCP. With this in mind, make sure to save any modifications made to
    the **provider.tf** file before moving on to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In the next set of steps, we will be updating and adding code to multiple files
    inside the **~/pentest_lab** directory. Make sure that any changes made to each
    of the files are saved so that we don’t encounter unexpected errors when running
    the **terraform** commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s open **versions.tf** in the editor. Let’s add the following block
    of code to specify the required version constraints for the providers used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we’re specifying the source and version for the random and Google Cloud
    providers. *Why is this necessary?* This ensures that the correct versions of
    the providers are used to maintain compatibility and consistency while using Terraform.
    That said, make sure to save any modifications made to the **versions.tf** file
    before moving on to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open **variables.tf** in the editor and add the following blocks of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are defining two variables—**my_ip** and **my_public_ssh_key**. Note
    that we won’t be specifying default values this time since we’ll be using the
    **terraform.tfvars** file to store the variable values instead. Make sure to save
    any modifications made to the **variables.tf** file before moving on to the next
    step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open **terraform.tfvars** in the editor and add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<IP ADDRESS OF YOUR LOCAL MACHINE>** with the current
    IP address value of the laptop or desktop you are using. In addition to this,
    make sure to replace **<PUBLIC SSH KEY>** with the public key string value (after
    running **cat kali-ssh.pub** in an earlier step). Note that the value of **<PUBLIC
    SSH KEY>** should follow a format resembling **ssh-rsa ... kali**. Do not forget
    to save the **terraform.tfvars** file before proceeding to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might be wondering what this file is used for! The **terraform.tfvars**
    file is used to store input variable values in a Terraform project. It provides
    a convenient way to manage and customize the properties of the infrastructure
    without having to modify the configuration code. In addition to this, the values
    stored in the **terraform.tfvars** file are automatically loaded when using the
    **terraform** **apply** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **main.tf** in the editor and add the following blocks of code to define
    the modules that will be used for this project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are adding module blocks in **main.tf** to include the **secure_network**,
    **attacker_vm**, and **target_vm** modules from their respective source directories.
    Make sure to save the **main.tf** file before proceeding to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the terminal (right after the **$** sign), let’s run the **terraform init**
    command to initialize the Terraform working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you are inside the **~/pentest_lab** directory before running
    the **terraform init** command (and the other **terraform** commands in the next
    set of steps).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the **terraform plan** command, let’s run **terraform fmt**
    to format our Terraform code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are using the **terraform fmt** command to ensure a consistent coding
    style across all Terraform configuration files. This command will scan the Terraform
    configuration files and adjust the indentation, spacing, and line breaks automatically
    to match the official Terraform style guide.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While this step is optional, it is highly recommended to use the **terraform
    fmt** command as part of your development workflow to maintain a clean and consistent
    coding style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command should complete without any errors. Otherwise, make sure to review
    and fix any issues before proceeding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Given that we have not yet defined and configured any cloud resource in our
    configuration code, this is the result that we’re expecting! That said, if the
    **terraform apply** command runs without any errors, we are ready to proceed to
    the next section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With our project structure and skeleton ready, we can now proceed with setting
    up the isolated VPC network environment.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the isolated network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having a solid understanding of the compute and networking services in GCP
    is essential for designing and implementing secure network environments where
    penetration testing lab resources are deployed. That said, before we dive deep
    into the secure network design, let’s quickly go through some of the resources,
    concepts, features, and components we will work with in this chapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VPC**—A VPC is a virtual network within a cloud computing environment that
    allows us to securely separate and manage resources. With VPCs, we can design
    and customize our own custom network architectures to meet specific requirements
    as well as enable secure communication between the resources deployed within the
    VPC. Inside a VPC, we can have **subnetworks** (**subnets**) that allow for further
    segmentation and isolation of resources within the larger VPC network. Subnets
    enable us to group resources together based on different considerations and requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the following diagram:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Simplified network diagram
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.13*, we have a *simplified* network diagram with two VPC networks.
    Each of these VPCs has two subnets. Inside these subnets, we can have various
    resources such as VMs and other cloud resources. If this is your first time dealing
    with these concepts, you can think of a VPC network as a country and subnets as
    cities within a country. Similar to how a country establishes its own rules and
    borders, a VPC network creates a controlled environment (inside a cloud account)
    to securely manage resources. Just as cities within a country have their own distinct
    characteristics, subnets within a VPC network act as isolated zones that segregate
    various types of resources inside the larger VPC network.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that we didn’t include projects or zones, along with
    other typical network components, in our simplified network diagram to focus instead
    on the key elements of networks that are relevant to our discussion.
  prefs: []
  type: TYPE_NORMAL
- en: '**Firewall rules**—Firewall rules are security rules that dictate how traffic
    is allowed or denied within a network. By setting up firewall rules, we can define
    the allowed (or blocked) communication paths and prevent unauthorized access and
    potential threats from reaching resources inside the network. Similar to how traffic
    police maintain order on city streets, firewall rules regulate the flow of data
    and help establish secure communication between various components in our cloud
    infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VPC peering**—VPC peering is a networking capability that enables secure
    and private communication between two VPC networks as if they were part of the
    same network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, have a look at the following diagram:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Simplified network diagram
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.14*, we have a simplified network diagram with two VPC networks
    connected through VPC peering. With VPC peering, traffic from resources deployed
    in the subnet of the first VPC network would be able to reach resources deployed
    in the subnet of the second VPC network (and vice versa) as long as the necessary
    firewall rules have been configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using VPC peering to connect VPC networks, it is important to note that
    IP address ranges used in peered VPC networks must not overlap to prevent routing
    conflicts. For instance, if VPC A has an IP address range of **10.0.0.0/16** and
    VPC B has an IP address range of **192.168.0.0/16**, then we should have a successful
    VPC peering connection since these ranges do not overlap. However, if both VPC
    A and VPC B have IP address ranges of **10.0.0.0/16**, then there would be an
    overlap that would result in routing conflicts and prevent the establishment of
    a VPC peering connection. In addition to this, VPC peering connections in GCP
    are unidirectional since each peering connection must be configured separately
    in each VPC network. This allows traffic to flow from one VPC network to another,
    but not in the reverse direction unless a reciprocal peering connection is established.
    Finally, VPC peering is non-transitive—meaning that peering connections do not
    extend to other VPC networks beyond immediate peers. If connectivity is required
    between multiple VPC networks, separate peering connections need to be established.
  prefs: []
  type: TYPE_NORMAL
- en: '**VM instance**—A VM instance refers to a virtualized computer system that
    runs within a cloud environment that enables users to deploy and run applications
    and services in a virtualized environment. A VM instance generally includes an
    operating system along with allocated computing resources such as CPU and memory,
    as well as storage capacity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private IP address**—A private IP address is an IP address assigned to a
    resource in a VPC that is used for internal communication between resources within
    the VPC. It’s important to note that the private IP address of a resource would
    fall within the range of available addresses designated for the specific subnet
    where the resource is launched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public IP address**—A public IP address is an IP address assigned to a resource
    in a VPC that allows resources to be reachable from outside the VPC network. If
    a resource does not have a public IP address, it means that the resource is only
    accessible within the private network of the VPC and cannot be reached directly
    from the public internet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial console**—The serial console is a capability (or feature) that provides
    direct access to the CLI of a VM instance. It allows us to troubleshoot and configure
    the operating system of the VM instance even when the VM’s network connectivity
    is unreliable or unavailable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple ways to establish a secure network environment setup in GCP
    that restricts traffic from external hosts from reaching cloud resources deployed
    inside the network environment. By configuring strict firewall rules, implementing
    network segmentation, and leveraging relevant VPC features and configurations,
    we can prevent unauthorized external access to the internal network environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on one of the various solutions that satisfy
    the following constraints and requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Attacker resources (for example, a Kali Linux VM instance) should be deployed
    and grouped within a dedicated VPC network. Similarly, target resources (for example,
    vulnerable-by-design applications and resources) should be deployed and grouped
    within a separate VPC network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic originating from attacker resources should reach the target resources
    without issues even if these resources are deployed in a different VPC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial console access should be enabled to allow direct access to both the attacker
    and target VM resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we will configure the attacker VM instance to establish SSH connections
    and SSH tunnels with your machine, we will restrict port **22** of the attacker
    VM instance to only allow access from your local machine. Similarly, since we
    will configure the attacker VM instance with browser-based access to its desktop
    environment, we will restrict port **8081** of the attacker VM instance to only
    allow access from your local machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given these constraints and requirements, what should our network environment
    look like? The following diagram gives us an overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – High-level architecture diagram of our penetration testing lab
    environment
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.15*, we have a simplified network diagram with two VPC networks
    connected through VPC peering. Here, traffic from the attacker VM instance deployed
    in **VPC 02** would be able to reach the target VM instance deployed in **VPC
    01** (and vice versa). With the correct project configuration, we should be able
    to use the serial console to connect to the attacker and target VM instances.
    The firewall rules configured should allow our local machines to access the attacker
    VM instance via port **22** and port **8081**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that the architecture we discussed is just one of the
    potential solutions. That said, several alternative approaches can meet the requirements
    and specified constraints.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to blocking external inbound traffic, the VPC networks in *Figure
    4**.15* may be configured to block outbound traffic to resources outside of the
    peered networks as well. While this is possible, it prevents the VM instances
    and other resources within the VPC networks from accessing resources outside of
    the peered networks. This means that these resources won’t be able to access external
    repositories for downloading updates and packages, which could impact the setup
    process. In this chapter, we will configure the VPC networks to allow outbound
    traffic (that is, the instances inside the peered VPCs should be able to access
    resources outside the overall network). However, after you have completed the
    chapter, feel free to explore the alternative approach of blocking outbound traffic
    for a more restricted network environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these points in mind, let’s proceed with preparing the network environment,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Cloud Shell terminal (right after the **$** sign), run the following
    commands (one line at a time) to navigate to the **~/****pentest_lab/secure_network**
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, run the following commands to create the files we will need in our **secure_network**
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure not to get confused since we have a few files with the same filename
    in different directories! While we have the **main.tf**, **variables.tf**, and
    **outputs.tf** files inside the **~/pentest_lab/secure_network** directory, we
    also have files with the same name in the **~/****pentest_lab** directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the editor, add the following block of code to the **secure_network/variables.tf**
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to save the **secure_network/variables.tf** file before proceeding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, open the **secure_network/main.tf** file in the editor. In the next set
    of steps, we will be adding blocks of code here to define and configure multiple
    network resources. Let’s start by adding the following block of code, which will
    allow us later to use serial connect to access our VM instances from the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a variety of ways to connect to running VM instances. In this chapter,
    we’ll use **serial connect** since it offers a convenient way to access the VM
    instances we launched from the browser. Feel free to check the following link
    for more information: [https://cloud.google.com/compute/docs/troubleshooting/troubleshooting-using-serial-console](https://cloud.google.com/compute/docs/troubleshooting/troubleshooting-using-serial-console).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file (**secure_network/main.tf**), add the following block of code
    to define **google_compute_network** and **google_compute_subnetwork** resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we define a VPC network with a single subnet with the **10.1.0.0/20**
    **Classless Inter-Domain Routing** (**CIDR**) range. Since **auto_create_subnetworks**
    is set to **false**, no other subnets will be created (other than the subnet we
    just defined).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same file (**secure_network/main.tf**), define **vpc_02** and **subnet_02**
    resources as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will launch the attacker VM instance in these network resources later in
    this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same file (**secure_network/main.tf**), let’s define two **net_01**
    and **net_02** local values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll use these local values when defining the other networking resources in
    the next set of steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same file (**secure_network/main.tf**), let’s define two **google_compute_network_peering**
    resources using the following blocks of code—one from **vpc-01** to **vpc-02**
    and another from **vpc-02** to **vpc-01**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In order for VPC Network Peering to work properly, the CIDR blocks of the VPCs
    involved should *NOT* overlap. In our case, our setup should work just fine since
    the CIDR blocks of **VPC 01** (**10.1.0.0/20**-**10.1.0.0**-**10.1.15.255**) and
    **VPC 02** (**10.2.0.0/20**-**10.2.0.0**-**10.2.15.255**) do not overlap. Feel
    free to use an online subnet calculator to verify this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file (**secure_network/main.tf**), let’s define **allow-all-from-vpc2**
    and **allow-all-from-vpc-1** firewalls using the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These blocks will (1) allow traffic from resources deployed in **VPC 02** to
    reach resources deployed in **VPC 01** (that is, from **10.2.0.0/20** to **10.1.0.0/20**)
    and (2) allow traffic from resources deployed in **VPC 01** to reach resources
    deployed in **VPC 02** (that is, from **10.1.0.0/20** to **10.2.0.0/20**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Priority numbers in GCP firewall rules determine the order in which rules are
    evaluated. The *lower* the priority number, the *higher* the priority of the rule.
    GCP evaluates firewall rules in ascending order based on priority numbers until
    a matching rule is found, at which point the evaluation stops. That said, it is
    important to assign unique and appropriately sequenced priority numbers to ensure
    that the desired firewall rules are applied correctly and in the intended order.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file (**secure_network/main.tf**), let’s define **allow-ssh-from-my-ip**
    and **allow-desktop-access-from-my-ip** firewalls using the following block of
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These firewall rules will allow your local machine to access resources launched
    inside **VPC 02** (via ports **22** and **8081**) once the entire penetration
    lab environment has been set up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to save the **secure_network/main.tf** file (**File** menu > **Save**)
    before running the terminal commands in the succeeding set of steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s open **secure_network/outputs.tf** in the editor. Add the following
    blocks of code to define the **subnet_01** and **subnet_02** outputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to save the **secure_network/outputs.tf** file as well before proceeding
    to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate to our **pentest_lab** project directory, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s use the **terraform init** command to reinitialize the Terraform working
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should give us a **Missing required argument — The argument “my_ip” is
    required, but no definition was found** error message since we have not provided
    any value for the **my_ip** argument while declaring the **secure_network** module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering why this issue has suddenly occurred, it’s important to
    recall that we defined the **my_ip** variable in the **secure_network/variables.tf**
    file in an earlier step.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the issue encountered in the previous step, we need to provide a
    value for the **my_ip** argument when declaring the **secure_network** module
    (similar to what we have in *Figure 4**.16*):![](image/B19755_04_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.16 – Passing the my_ip variable value to the my_ip input variable of
    the secure_network module
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using *Figure 4**.16* as a reference, we will resolve the issue by passing the
    **my_ip** variable value (of the root module) to the **my_ip** input variable
    of the **secure_network** module. Since we had the **terraform.tfvars** file prepared
    in an earlier step, the default variable values for **my_public_ssh_key** and
    **my_ip** will be loaded from the **terraform.tfvars** file when we run the **terraform
    apply** command in a later step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have a better idea of how to resolve the issue, let’s locate the
    following block of code in our **main.tf** file (**~/pentest_lab/main.tf**):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update it with the following block of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are passing the **my_ip** variable value to the **my_ip** input variable
    of the **secure_network** module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to save the **main.tf** file (**~/pentest_lab/main.tf**) before proceeding
    to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Cloud Shell terminal (right after the **$** sign), let’s run the following
    command to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should be able to proceed without encountering an error this time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the command should return the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a few minutes for the **terraform apply** command to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s check the resources created by Terraform using the console. Navigate
    to the list of existing VPC networks by typing **vpc networks** in the search
    bar and then selecting **VPC networks** from the search results:![](image/B19755_04_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.17 – List of VPC networks
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *Figure 4**.17*, we can see that **vpc-01** and **vpc-02** VPC networks have
    been created by Terraform successfully. Here, we can also see that both **vpc-01**
    and **vpc-02** have a single subnet each (indicated by the count under the **Subnets**
    column). Feel free to click the **REFRESH** button in case the list does not reflect
    the new VPCs we just created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s check the VPC network where we’ll host the target VM instance. Click **vpc-01**
    from the list of VPC networks to navigate to the VPC network details page of the
    said VPC:![](image/B19755_04_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.18 – VPC network details
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We should see that we only have a single subnet inside **vpc-01**, similar to
    what we have in *Figure 4**.18*. You may also check the resources under the **FIREWALLS**
    and **VPC NETWORK PEERING** tabs to verify that these resources have been created
    and configured correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may navigate back to the list of VPC networks and check **vpc-02** along
    with the other resources created using the Google Cloud console as well.
  prefs: []
  type: TYPE_NORMAL
- en: '*Wasn’t that easy?* Without further ado, let’s move on to the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the target VM instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our isolated network environment ready, we can now proceed with setting
    up the target VM instance. In this section, we will set up the target VM instance
    in the subnet of **VPC 01**, similar to what we have in *Figure 4**.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – Setting up the target VM instance in the subnet of VPC 01
  prefs: []
  type: TYPE_NORMAL
- en: Inside the target VM instance, we will be running an intentionally vulnerable
    application called **OWASP Juice Shop**. OWASP Juice Shop was designed, developed,
    and prepared by the **Open Web Application Security Project** (**OWASP**) to help
    developers, security engineers, and penetration testers enhance their understanding
    of secure coding practices and vulnerability identification, along with various
    mitigation strategies. To simplify the setup and installation of the OWASP Juice
    Shop application in our VM instance, we will utilize the **bkimminich/juice-shop**
    container image. This container image will allow us to run the vulnerable-by-design
    application inside a container.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering what **containers** are, they are simply lightweight and
    isolated runtime environments that provide a consistent and portable way to run
    applications across various computing environments. On the other hand, container
    images (such as the **bkimminich/juice-shop** container image) are templates that
    contain the necessary files and configurations to create and run containers. They
    include the application code, along with all the prerequisites required to execute
    an application within a containerized environment.
  prefs: []
  type: TYPE_NORMAL
- en: Containers allow different vulnerable-by-design applications to coexist inside
    the VM instance without interfering with each other. That said, while we are planning
    to have only one container running inside the target VM instance, it is worth
    mentioning that running multiple intentionally vulnerable applications inside
    containers on the same VM instance is possible as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section is divided into the following subparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 2 – Preparing the target VM instance* *using Terraform*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 2 – Using the serial console to access the target* *VM instance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without further ado, let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 2 – Preparing the target VM instance using Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **~/pentest_lab/target_vm** directory by running the following
    in the Cloud Shell Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following commands to create the files we’ll need in our **target_vm**
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open a new browser tab and navigate to this book’s official GitHub repository:
    [https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the **target_boot_script.tpl** template file inside the **ch04/pentest_lab/target_vm**
    directory ([https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/target_boot_script.tpl](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/target_boot_script.tpl)):![](image/B19755_04_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.20 – Copy Link Address option
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the **Raw** button and select **Copy Link Address** from the
    list of options in the context menu (as highlighted in *Figure 4**.20*). This
    will copy the link address of the file to the clipboard of your local machine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Download the **target_boot_script.tpl** template file using the **wget** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<DOWNLOAD LINK>** with the link copied earlier (it should
    be in your clipboard after selecting **Copy Link Address** from the context menu
    options).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also use this link instead for the **<DOWNLOAD** **LINK>** value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/target_boot_script.tpl](https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/target_boot_script.tpl)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly check the contents of the **target_boot_script.tpl** file we
    downloaded using the **cat** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Spend a few minutes reading the code inside the file. You’ll see that the script
    is divided into three parts, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**SET UP USER**—Running the script creates a new user on the system, sets a
    password for that user, and then grants the new user **sudo** privileges (without
    requiring a password)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INSTALL DOCKER**—Here, we run a few commands for installing Docker on the
    system where the script will run'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SET UP OWASP JUICE SHOP**—This portion of the script focuses on running the
    OWASP Juice Shop application in a Docker container and making it accessible on
    port **80** of the host machine where the script will run'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s open a new browser tab and locate the **wait_for_boot.tpl** template
    file inside the **ch04/pentest_lab/target_vm** directory ([https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl)):![](image/B19755_04_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.21 – Copy Link Address option
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the **Raw** button and select **Copy Link Address** from the
    list of options in the context menu (as highlighted in *Figure 4**.21*). This
    will copy the link address of the file to the clipboard of your local machine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Download the **wait_for_boot.tpl** template file using the **wget** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<DOWNLOAD LINK>** with the link copied earlier (it should
    be in your clipboard after selecting **Copy Link Address** from the context menu
    options).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also use this link instead for the **<DOWNLOAD** **LINK>** value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl](https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly check the contents of the **wait_for_boot.tpl** file we downloaded
    using the **cat** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Spend a minute or two reading the code inside the file. You’ll see that the
    script simply waits for the target boot script (based on the **target_boot_script.tpl**
    template script file) to finish running. The script loops for a certain number
    of retry attempts and checks if the target boot script has executed the following
    line of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the **target_boot_script.tpl** and **wait_for_boot.tpl** template
    files are inside the **pentest_lab/target_vm** directory before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s open **target_vm/variables.tf** in the editor and add the following
    block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we’ll define a single variable that will be used when configuring in which
    subnet the VM instance will be launched.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to save the **target_vm/variables.tf** file before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s open the **target_vm/main.tf** file in the editor. We will add several
    blocks of code in the next set of steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **target_vm/main.tf** file, let’s define a resource called **random_password**
    that generates a random string of length **12** with special characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we provide our own list of special characters to be used when generating
    the random password value. If you are wondering where we’ll use this generated
    password, we will use it when accessing the target VM instance (via the serial
    console) in the succeeding set of steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the **target_vm/main.tf** file, let’s define a few local variables that
    we will use when configuring our VM instance (before defining our **google_compute_instance**
    resource):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we define **vm_username**, **vm_password**, **script**, and **subnet_01**
    local variables. When defining the **script** local variable, we use the **templatefile()**
    function to render the contents of the **target_boot_script.tpl** template file
    by passing in the values of **vm_username** and **vm_password** as variables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the **target_vm/main.tf** file, let’s define our first **google_compute_instance**
    resource using the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **target_vm/main.tf** file, let’s also define **wait_for_startup_script**
    and **null_resource** resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are wondering what this is for, this code block simply runs a script
    (coded inside the **wait_for_boot.tpl** template file) inside the VM instance
    and waits for the entire boot script (coded inside the **target_boot_script.tpl**
    template file) to complete.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Without this block, the **terraform apply** command would finish prematurely,
    even if the target VM instance’s boot process had not finished. This would mean
    that the OWASP Juice Shop application may not be available and accessible yet
    by the time the **terraform apply** command has completed!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **target_vm/main.tf** file, let’s define the following local values
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to save the **target_vm/main.tf** file before proceeding with the
    next set of steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the **target_vm/outputs.tf** file in the editor. Add the following
    blocks of code to define the outputs of the **target_vm** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to save the **target_vm/outputs.tf** file before proceeding with the
    next set of steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will use these output values in the **~/****pentest_lab/outputs.tf** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Cloud Shell terminal (right after the **$** sign), navigate to the **pentest_lab**
    project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s use the **terraform init** command to reinitialize the Terraform working
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should give us a **Missing required argument — The argument “subnet_01”
    is required, but no definition was found** error message since we have not provided
    any values for the **subnet_01** argument while declaring the **target_vm** module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering why we suddenly encountered this issue, it’s important
    to recall that we defined the **subnet_01** variable in the **target_vm/variables.tf**
    file in an earlier step. We will have this resolved in the next set of steps!
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the issue encountered in the previous step, we need to ensure that
    we provide a value for the **subnet_01** argument when declaring the **target_vm**
    module (similar to what we have in *Figure 4**.22*):![](image/B19755_04_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.22 – Providing a value for the subnet_01 argument when declaring the
    target_vm module
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using *Figure 4**.22* as a reference, we will resolve the issue by passing
    the **subnet_01** output value from the **secure_network** module to the **subnet_01**
    input variable of the **target_vm** module. Now that we have a better idea of
    how we’ll resolve the issue, let’s locate the following block of code in our **main.tf**
    file (**~/pentest_lab/main.tf**):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update it with the following block of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are passing the output value from the **secure_network** module (**module.secure_network.subnet_01**)
    to the **subnet_01** input variable of the **target_vm** module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to save the changes made to the **main.tf** file (**~/pentest_lab/main.tf**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should be able to proceed without encountering an error this time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the command should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a minute or two for the **terraform apply** command to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for us to see the output values, let’s open the **outputs.tf** file
    (**~/pentest_lab/outputs.tf**) in the editor and add the following blocks of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will utilize the outputs from the **target_vm** module in the root module’s
    **outputs.tf** file (**~/pentest_lab/outputs.tf**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see the output values after running the **terraform apply -auto-approve**
    command since we defined the outputs in the root module (that is, the code stored
    inside **~/pentest_lab**) in an earlier step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Store and save the output values for **target_vm_username**, **target_vm_password**,
    and **target_vm_private_ip** in a text editor as we will use these in the succeeding
    steps in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Part 2 of 2 – Using the serial console to access the target VM instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **VM instances** page by typing **compute engine** in the search
    box and selecting **Compute Engine** from the search results (similar to what
    is shown in *Figure 4**.23*):![](image/B19755_04_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.23 – Navigating to the VM instances page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the **VM instances** page, we’ll find a list of VM instances in our GCP account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the link (**vm-target**) under the **Name** column to navigate to the
    **Instance details** page of our target VM instance (**vm-target**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s time we accessed the serial console! In case you are wondering what it
    is, the **serial console** serves as a troubleshooting tool that allows users
    to conveniently access the serial port of a VM instance directly in GCP. It enables
    users to interact with the VM’s console output, access the boot process, and diagnose
    issues even when SSH or other network-based connections are unavailable (or misconfigured).
    With this in mind, let’s click on the **CONNECT TO SERIAL CONSOLE** button. This
    will open a pop-up window similar to what we have in *Figure 4**.24*:![](image/B19755_04_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.24 – Serial console popup
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you see a blank page inside the pop-up window, click inside the blank page
    and then press the *Enter* key. Use the output values for **target_vm_username**
    (**testuser**) and **target_vm_password** (generated password) to log in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to run the **terraform show** command in the Cloud Shell terminal
    to retrieve the output values for **target_vm_username** and **target_vm_password**.
    Make sure that you are inside the **~/pentest_lab** directory before running the
    **terraform** **show** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to check if the OWASP Juice Shop container is running
    inside the target VM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If prompted for the password, simply use the **target_vm_password** output value
    to proceed with the command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **sudo docker ps** command should return a single running container using
    the **bkimminich/juice-shop** container image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_25.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.25 – Confirming that the OWASP Juice shop container is already running
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Accessing port **80** of the VM instance would allow you to interact with the
    container running the **bkimminich/juice-shop** image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to send a sample request to the local server and
    check whether a website is running on port **80**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_26.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.26 – Result after using the curl command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Looks like we have confirmed that we have a website running on port **80** of
    the VM instance (mapped to a web application inside the running container).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have a better idea of what’s running inside the target VM instance,
    we can close the serial console (**SSH** **in-browser**) popup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this stage, you might be excited about exploring and accessing the OWASP
    Juice Shop application already! Given that we’ve intentionally configured the
    network environment to only allow resources in **VPC 02** to access **VPC 01**
    (where the target VM instance is launched), we will have to set up our attacker
    VM instance in **VPC 02** first before we can access the vulnerable-by-design
    application, along with performing a penetration testing simulation inside the
    network environment.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the Kali Linux Generic Cloud Image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Kali Linux** is a specialized operating system designed specifically for
    advanced penetration testing and ethical hacking activities. With its wide range
    of security tools, Kali Linux enables cybersecurity professionals and enthusiasts
    to perform penetration tests, digital forensics investigations, and vulnerability
    assessments. If you have not used Kali Linux before, think of it as an upgraded
    version of a specific operating system where powerful security tools are pre-installed,
    turning it into a specialized arsenal for cybersecurity professionals. It’s like
    transforming a regular car into a heavily armored tank with an array of advanced
    weapons!'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As a specialized operating system with advanced hacking tools, Kali Linux has
    the potential to cause harm or engage in malicious activities if used improperly.
    While it is generally safe to use Kali Linux inside your own penetration testing
    lab environments, always make sure that you have proper authorization when using
    it for conducting security assessments and penetration testing exercises. This
    ensures that you stay within legal and ethical boundaries and avoid any unauthorized
    activities that may lead to legal consequences or harm the integrity of systems.
    Remember to obtain explicit permission from the owner of the systems or networks
    you are testing and adhere to any applicable laws, regulations, or guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Given that Kali Linux is not available as a preconfigured image in **Google
    Cloud Marketplace**, we need to follow a specific set of steps to import the Generic
    Cloud Image before launching a Kali Linux VM. *Generic what??* The **Generic Cloud
    Image** of Kali Linux is simply a preconfigured and optimized image for deployment
    on various cloud platforms (including GCP). You can think of the image as a DNA
    template that can be used to prepare clones of Kali Linux instances on different
    cloud platforms. It serves as a foundational blueprint, containing all the essential
    configurations and software required for penetration testing and security assessments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a better understanding of what Kali Linux is and what the
    Generic Cloud Image is used for, let’s proceed with importing the said image to
    our Google GCP project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new browser tab and navigate to [https://www.kali.org/get-kali/#kali-cloud](https://www.kali.org/get-kali/#kali-cloud).
    Locate and right-click on the **Generic Cloud Image** download box to open the
    context menu:![](image/B19755_04_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.27 – Copying the link address of the Generic Cloud Image
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Select **Copy Link Address** from the list of options in the context menu similar
    to what is shown in *Figure 4**.27*. This should copy the following download link
    to our local machine’s clipboard:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this download link may change as new versions of the image are made
    available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Store and save this download link in a text editor as we will use this in the
    succeeding steps in this chapter. In case you are unable to copy the link address,
    you may find the Generic Cloud Image files here: [https://kali.download/cloud-images/kali-2023.1/](https://kali.download/cloud-images/kali-2023.1/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate back to our Google Cloud console browser tab. In the Cloud Shell terminal
    (after the **$** sign), run the following commands to create a directory named
    **kali-image** (and navigate to the created directory as well):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download the latest version of the **Generic Cloud Image** using **wget** by
    running the following commands in the Cloud Shell terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should download the **kl_image.tar.xz** file inside our **kali-image**
    directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to update the **IMAGE_SOURCE** variable value with the download link
    you copied to the text editor in an earlier step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a compatible **.tar.gz** file for storing the Kali Linux Generic Cloud
    Image by running the following lines (one line at a time):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are able to prepare a compressed tarball file named **kl_image.tar.gz**
    containing the contents of the **disk.raw** file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new **Google Cloud Storage** (**GCS**) bucket using the **gsutil**
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure to replace **<BUCKET NAME>** with a globally unique bucket name (for
    a bucket that is yet to be created). Feel free to check the following link on
    some considerations when naming Cloud Storage buckets: [https://cloud.google.com/storage/docs/buckets](https://cloud.google.com/storage/docs/buckets).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If this is your first time using the **gsutil** command-line utility, it is
    a command-line tool provided by GCP for interacting with GCS. To grant permission
    for the **gsutil** command, we need to proceed by clicking on the **AUTHORIZE**
    button in the **Authorize Cloud Shell** pop-up window. This will allow the necessary
    permissions for the **gsutil** command to be executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upload the **.tar.gz** file to an existing GCS bucket using the **gsutil**
    utility:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may navigate to the **Cloud Storage Buckets** page using the user interface
    (Cloud console) and check if the **.tar.gz** file has been uploaded to the bucket
    successfully.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the **gcloud compute images create** command to create an image from the
    **.tar.gz** file uploaded to the GCS bucket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Feel free to replace **kali-linux-2023-000** with a different **IMAGE_NAME**
    value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The **gcloud** CLI is a unified command-line utility provided by GCP that allows
    users to access and manage various Google Cloud resources from the terminal. With
    this command-line utility, we can perform tasks such as provisioning and managing
    VMs, configuring networking, deploying applications, managing storage resources,
    and accessing service APIs. The **gsutil** tool, on the other hand, facilitates
    various tasks, including uploading, downloading, copying, and managing data within
    Cloud Storage buckets. It is worth noting that **gcloud** and **gsutil** have
    different functionalities, and it is important not to mistake one for the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to verify that we were able to successfully create
    the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have a filtered list of custom images that have been created or imported
    into our account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Now that we have the image imported to Google Cloud, what’s next?* From this
    image, we should be able to launch a VM instance that will serve as the attacker
    instance in our penetration testing lab environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Manually setting up the attacker VM instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our custom image and the VPC network setup ready, setting up our Kali Linux
    attacker machine on GCP should be straightforward. However, before proceeding
    with the hands-on portion of this section, let’s quickly discuss how our attacker
    VM machine will be configured and deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we will be deploying the Kali Linux attacker machine in **VPC
    02**, similar to what we have in *Figure 4**.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.28 – Setting up the attacker VM instance in the subnet of VPC 02
  prefs: []
  type: TYPE_NORMAL
- en: Traffic from our attacker machine should be able to reach resources deployed
    in **VPC 01** since **VPC 02** is peered with **VPC 01** and the configured firewall
    rules allow traffic from each of these VPC networks to reach the resources deployed
    in these networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, we will set up the following in the attacker VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TigerVNC**—A high-performance cross-platform implementation of **Virtual
    Network Computing** (**VNC**) that enables users to remotely access and interact
    with graphical applications on remote machines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**noVNC**—A web-based implementation of VNC that allows users to access and
    control a remote desktop environment through a web browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These will allow us to interact with the desktop environment of the attacker
    machine remotely from the browser (similar to what is shown in *Figure 4**.29*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.29 – Accessing the target instance from a browser running in the attacker
    instance
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to distinguish between the two browsers shown in *Figure 4**.29*.
    The first browser, which will run on our local machine, displays the desktop environment
    of our Kali Linux VM instance. Within this environment, we will launch the Firefox
    browser to access the **OWASP Juice Shop** web application running in the target
    VM instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, we’ll divide this section into three parts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 3 – Manually launching the* *attacker instance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 3 – Enabling browser access to our Kali* *Linux server*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 3 of 3 – Validating* *our setup*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these points in mind, let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 3 – Manually launching the attacker instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **VM instances** page by typing **compute engine** in the search
    box and selecting **Compute Engine** from the search results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take note of the **Zone** value for **vm-target** (that is, **us-central1-c**)
    as we will use the same zone when creating the **kali-00** VM instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **CREATE INSTANCE** button. Specify the following configuration values
    when creating the new instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Name**: **kali-00**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Region**: **us-central1 (Iowa)**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zone**: **us-central1-c**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Machine** **type**: **e2-medium**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boot disk**: Locate and click the **CHANGE** button. Navigate to the **CUSTOM
    IMAGES** tab and select the **kali-linux-2023-000** image from the list of drop-down
    options, similar to what is shown in *Figure 4.30*. For the **Size (GB)** field,
    specify a value of **50**. Click the **SELECT** button afterward:![](image/B19755_04_30.jpg)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 4.30 – Configuring the boot disk
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Advanced options** (expand) > **Networking** (expand) > **Network interfaces**:
    Change **default** to **vpc-02** under **Edit** **network interface**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scroll down to the bottom of the page and then click the **CREATE** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a minute or two for this step to complete. Feel free to grab a cup
    of coffee or tea while waiting!
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 of 3 – Enabling browser access to our Kali Linux server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **VM instances** page where we can find a list of running instances.
    Click the link (**kali-00**) under the **Name** column to navigate to the **Instance
    details** page of our Kali Linux VM instance (**kali-00**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s access the serial console by clicking on the **CONNECT TO SERIAL CONSOLE**
    button. A pop-up window will open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The serial console allows users to conveniently access the serial port of a
    VM instance directly in GCP. If the serial console is unresponsive, feel free
    to reboot or restart the VM instance, as this can often resolve the issue and
    restore functionality for troubleshooting and diagnostics. You may also run the
    **clear** command in case you need to clear the contents of the terminal screen.
  prefs: []
  type: TYPE_NORMAL
- en: Once you see a blank page inside the pop-up window, click inside the blank page
    and then press the *Enter* key. You should see a **root@kali:~#** prompt where
    you can run **bash** commands as the **root** user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s run the following block of code (after **root@kali:~#**) to set
    up access to our **kali** user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we first check if the **kali** user exists and create it if it doesn’t
    exist. It then sets up the SSH directory for the user, ensuring proper ownership
    and permissions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following commands (one line at a time) to write the value of the **$SSH_KEY**
    variable to the **authorized_keys** file located in the **.ssh** directory of
    the user’s home directory. After that, use the **cat** command to display the
    contents of the **authorized_keys** file to check if the changes have been applied
    correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<SSH PUBLIC KEY VALUE>** with the output of the **cat
    kali-ssh.pub** command we ran in a previous step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The value of the **$SSH_KEY** variable should follow a format resembling **ssh-rsa
    ...** **kali**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s run the following commands (one line at a time) to change the ownership
    of the **authorized_keys** file to the **$NEW_USER** user, set the file permissions
    to **600** for restricted access, and then restart the SSH service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following commands to (1) add the **$NEW_USER** user to the **sudo**
    group, (2) grant the user passwordless sudo privileges by creating a configuration
    file in the **/etc/sudoers.d/** directory, and (3) set appropriate permissions
    for the configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s switch to the **kali** user account and then navigate to the home
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s update the package lists and then install the default set of packages
    for Kali Linux using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This step may take 15-20 minutes to complete. Feel free to grab a cup of coffee
    or tea while waiting! In case you’re looking for a script that automates *most*
    of the work done in this section, you may check the following link: [https://bit.ly/kali-desktop-setup](https://bit.ly/kali-desktop-setup).
    In this chapter, we have set up the attacker VM instance manually so that we have
    a better understanding and appreciation of what’s happening behind the scenes
    while running the installation commands. In the next chapter, we will use an automated
    script to set up the attacker VM instance to speed things up a bit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, download the **xfce4.sh** script, make it executable using the **chmod**
    command, and then execute it using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This step may take around 10 minutes to complete. Feel free to grab a cup of
    coffee or tea while waiting!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s enable and start the **xrdp** service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also set the password for the **kali** user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s install **TigerVNC** and **noVNC**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This step may take a minute or two to complete. Feel free to run the **clear**
    command to clear the screen (after the previous block of commands has finished
    running).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands to check if the VNC server and the noVNC proxy have
    been installed successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s run the following command to edit the **cron table** (**crontab**) for
    the **kali** user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we specified that we want to use **Vim** to edit the crontab configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In case you are wondering what the **crontab** is used for, it is simply a time-based
    job scheduler often used by users when performing administrative and scheduled
    (often repetitive) tasks. Each user on the system can have their own crontab file
    containing a list of scheduled tasks. Users can create, edit, and manage their
    crontab files using the **crontab** command, which provides options to view, modify,
    or remove entries.
  prefs: []
  type: TYPE_NORMAL
- en: Press *Shift* + *g* to jump to the last line of the file. Press *o* (lowercase
    letter “o”) to open a new line below the current line and enter **insert mode**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following two entries to the end of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By including these crontab entries prefixed with **@reboot**, the VNC server
    and the noVNC proxy will automatically start upon each system reboot. This will
    (1) ensure persistent access to the graphical desktop environment and (2) enable
    remote connections via the web-based noVNC client. Here, you can see that we’ve
    configured **vncserver** and **novnc_proxy** to run after 60 seconds to wait for
    the system processes to be ready before these are run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that there are other alternative methods available for running
    the VNC server and the noVNC proxy during system boot. These include using **init**
    scripts, **systemd** units, or startup configuration files, depending on the specific
    operating system and configuration preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Press the *Esc* key to switch to **normal mode**. Type **:wq!**. Press *Enter*
    afterward. This will save the changes to the crontab configuration and then exit
    Vim as well. Feel free to use **crontab -l** to verify that the scheduled tasks
    and commands have been correctly configured in the cron job scheduler of the VM
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the serial console pop-up window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **VM details** page, locate and click the **RESET** button to restart
    the instance. Wait for about 3-5 minutes for the instance to reboot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can safely close the Cloud Shell editor for now, as we won’t lose any files
    or progress (closing the editor does not delete or remove any files). We can open
    it again later when we need to edit files or run terminal commands.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 of 3 – Validating our setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before automating our current setup, we first need to validate that the VM
    instance we manually set up and configured is working. To do so, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Instance details** page of our Kali Linux VM instance (**kali-00**),
    scroll down and locate the **External IP address** value (under **Network interfaces**)
    and copy it to your clipboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new browser tab and access the web-based noVNC client using the following
    URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<ATTACKER VM PUBLIC IP ADDRESS>** with the **External
    IP address** value copied to the clipboard in an earlier step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This should open a welcome screen with a **Connect** button, similar to what
    we have in *Figure 4**.31*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_31.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.31 – noVNC welcome screen
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself unable to access the welcome screen, it is possible that
    your IP address might have changed already. Simply open the Cloud Shell editor
    and update the **terraform.tfvars** file. Once the **terraform.tfvars** file has
    been updated with the new IP address of your local machine, run the **terraform
    apply** command again to update the firewall rule to whitelist your new IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Connect** button and then use the password **kali123** (or use the
    password you specified in an earlier step) to access the desktop environment,
    similar to what we have in *Figure 4**.32*:![](image/B19755_04_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.32 – Accessing the Kali Linux desktop/GUI environment in the browser
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we’re able to access the desktop environment, we should be able to perform
    various tasks and access the wide range of tools and utilities available in Kali
    Linux (similar to how we would use it on our local machine).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In case you encounter a **Failed to connect to server** error, wait for about
    2-3 minutes before trying to access the desktop/GUI environment again.
  prefs: []
  type: TYPE_NORMAL
- en: Open the Firefox browser by clicking on the **Firefox** icon located at the
    upper-left corner of the desktop environment. Navigate to **http://<PRIVATE IP
    OF TARGET VM>** to open the OWASP Juice Shop vulnerable web application:![](image/B19755_04_33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.33 – Accessing the target instance from a browser running in the attacker
    instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Please remember to use the private IP address of the target VM instance instead
    of the public IP address, as our **VPC 01** network has been specifically configured
    to allow traffic only from resources within **VPC 02**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have verified that our setup is working correctly, we can close
    the browser tab used to access the Kali Linux desktop environment. We’ll resume
    the exploration of the OWASP Juice Shop application in the *Simulating penetration
    testing in the isolated network environment* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that we can also access the desktop environment of
    the attacker instance from our local machine using an **SSH tunnel**. *Remember
    the private key file we generated earlier in this chapter?* Once we’ve downloaded
    this key file to our local machine, we simply need to (1) open a new terminal
    tab in our local machine, (2) navigate to the directory containing the private
    key file, and (3) run the following command to create an SSH tunnel between our
    local machine and the attacker VM instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Once the SSH tunnel has been set up, we can access the same desktop environment
    through **http://localhost:8081/vnc.html** (instead of using the public IP address
    of the attacker VM instance). If you are wondering what an SSH tunnel is, it is
    simply a secure encrypted connection used to access services and applications
    running inside a remote server. SSH tunnels leverage the encryption and authentication
    capabilities of SSH to secure data transmitted over the tunnel. With an SSH tunnel,
    we can securely access the desktop environment of the attack VM instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We’ll leave this to you as an exercise. In addition to this, feel free to check
    [https://github.com/novnc/noVNC/wiki/Advanced-usage](https://github.com/novnc/noVNC/wiki/Advanced-usage)
    in case you want to further upgrade our setup.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Terraform to automatically set up the attacker VM instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section primarily focused on setting up the attacker VM instance
    manually. This was necessary because we will utilize this VM instance (**kali-00**)
    as a reference to create a **golden image**. By creating a golden image, we can
    capture the desired configuration and settings of the VM instance, making it easier
    to replicate and deploy similar instances with the same specifications in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Note that another approach when automating the process of setting up VM instances
    involves the usage of IaC tools such as Ansible to set up *what’s inside the VM
    instance* (in addition to the usage of Terraform for setting up, configuring,
    and managing the cloud resources). When preparing VM instances, it is important
    that we have a good understanding of the distinct advantages and differences of
    each approach. Golden images are well suited to scenarios where a predefined and
    static environment is required since they can capture the desired configuration,
    settings, and software of a fully configured VM instance. By using golden images
    as templates, new instances can be quickly created with the exact same specifications—ensuring
    consistency along with reducing the time and effort required for manual configuration.
    On the other hand, using IaC tools such as Ansible (in addition to Terraform)
    allows for dynamic configuration changes, making them suitable for environments
    that require frequent updates and configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: That said, the most suitable approach really depends on the specific needs of
    the environment and the level of customization required, along with the desired
    level of automation and flexibility in managing VM instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll divide this section into three parts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 3 – Creating a* *golden image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 3 – Using Terraform to prepare the attacker* *VM instance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 3 of 3 – Accessing the Kali Linux* *desktop environment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these points in mind, let’s proceed with automating the process of setting
    up our attacker VM instance!
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 3 – Creating a golden image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **VM instances** page by typing **compute engine** in the search
    box and selecting **Compute Engine** from the search results. Here, we’ll find
    a list of VM instances in our GCP account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the link (**kali-00**) under the **Name** column to navigate to the **Instance
    details** page of our attacker VM instance (**kali-00**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn off the instance by clicking **STOP**. Confirm the action by clicking **STOP**
    in the **Stop kali-00** popup that appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Take note that it may take around 3-5 minutes for the VM instance to stop. Please
    wait for the VM instance to stop before proceeding to the next set of steps.
  prefs: []
  type: TYPE_NORMAL
- en: Next, click **CREATE** **MACHINE IMAGE**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create a machine image** page, specify **kali-golden-image** for the
    **Name** value and then click the **CREATE** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Machine images** page, wait for a few minutes for the status of the
    **kali-golden-image** image to be **Ready**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may click the **REFRESH** button to update the status and check if the image
    is ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **Machine image details** page. Scroll down to the bottom of
    the page and click the **REST** link (from **Equivalent REST or** **command line**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate and copy the **selfLink** value, as highlighted in *Figure 4**.34*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_34.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.34 – Locating the selfLink value of the machine image
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Store this value in a text editor on your local machine. The **selfLink** value
    should have a format similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Keep in mind that you’ll get a different **<PROJECT ID>** value (so do not copy
    and paste exactly what’s in the screenshot).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that further upgrades can still be implemented on top of the image we prepared
    in the previous set of steps. In the meantime, this should do the trick for now.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate back to the **VM instances** page. Click the link (**kali-00**) under
    the **Name** column to navigate to the **Instance details** page of our attacker
    VM instance (**kali-00**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the Kali Linux instance (named **kali-00**) we created manually using
    the **DELETE** button in the **VM instances** page. Confirm the deletion by clicking
    **DELETE** in the **Delete** **kali-00** popup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Part 2 of 3 – Using Terraform to prepare the attacker VM instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Cloud Shell terminal. In case you closed it while working on an earlier
    step, simply click the **Activate Cloud Shell** button on the upper right-hand
    corner of the page (as highlighted in *Figure 4**.35*):![](image/B19755_04_35.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.35 – Activating Cloud Shell
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This should open a terminal where we can run command-line commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Open Editor** button located at the upper right-hand corner of the
    Cloud Shell Terminal pane. If you can’t see the terminal, open the **Terminal**
    menu of the Cloud Shell editor and then select **New Terminal** from the list
    of options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Cloud Shell terminal (after the **$** sign), navigate to the **~/pentest_lab/attacker_vm**
    directory by running the following commands (one line at a time):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following commands (one line at a time) to create the files we’ll need
    in our **attacker_vm** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are creating three empty files inside the **~/pentest_lab/attacker_vm**
    directory—(1) a **main.tf** file for defining the main configuration and resources,
    (2) a **variables.tf** file for declaring and managing variables used in the configuration,
    and (3) an **outputs.tf** file for specifying outputs or values that will be exposed
    after applying the configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, open the **attacker_vm/variables.tf** file in the editor and add the
    following blocks of code to define **subnet_02**, **kali_machine_image**, and
    **my_public_ssh_key** variables for our **attacker_vm** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<INSERT IMAGE>** with the **selfLink** value of the machine
    image from the previous section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to save the **attacker_vm/variables.tf** file before proceeding
    to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **attacker_vm/main.tf** file in the editor and add the following blocks
    of code to define and configure the attacker VM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we’re using **google_compute_instance_from_machine_image** instead of
    **google_compute_instance** when defining the attacker VM resource since we want
    to create the VM instance from a pre-existing machine image. This allows us to
    quickly provision an instance with the desired configuration and software setup,
    such as using a Kali Linux image for the attacker VM. When typing these blocks
    of code, make sure that **{** is after **"kali_vm"** (same line instead of next
    line).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to save the **attacker_vm/main.tf** file before proceeding to
    the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **attacker_vm/outputs.tf** file in the editor and add the following
    lines of code to define the following outputs: (1) **attacker_vm_public_ip**—public
    IP address value of the attacker VM instance, (2) **attacker_vm_access**—URL used
    to access the desktop environment from the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to save the **attacker_vm/outputs.tf** file before proceeding to the
    next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate back to the **~/pentest_lab** project folder by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s use the **terraform init** command to reinitialize the Terraform working
    directory (since there are changes to the **attacker_vm** module code):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should give us **Missing required argument — The argument “subnet_02” is
    required, but no definition was found** and **Missing required argument — The
    argument “my_public_ssh_key ” is required, but no definition was found** error
    messages since we have not provided any values for the **subnet_02** and **my_public_ssh_key**
    arguments while declaring the **attacker_vm** module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering why this issue has suddenly occurred, it’s important to
    recall that we defined **subnet_02** and **my_public_ssh_key** variables in the
    **attacker_vm/variables.tf** file in an earlier step.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the issue encountered in the previous step, we need to ensure that
    we provide a value for the **subnet_02** and **my_public_ssh_key** arguments when
    declaring the **attacker_vm** module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using *Figure 4**.36* as a reference, we will resolve the issue by passing
    the **subnet_02** output value from the **secure_network** module to the **subnet_02**
    input variable of the **attacker_vm** module:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_36.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.36 – Providing a value for the subnet_02 and my_public_ssh_key arguments
    when declaring the attacker_vm module
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the same time, we will pass the **my_public_ssh_key** variable value to
    the **my_public_ssh_key** input variable of the **attacker_vm** module. Now that
    we have a better idea of how we’ll solve the issue, let’s locate the following
    block of code in our **main.tf** file (**~/pentest_lab/main.tf**):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s replace this with the following block of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are passing the output value from the **secure_network** module (**module.secure_network.subnet_02**)
    to the **subnet_02** input variable of the **attacker_vm** module. In addition
    to this, we are passing the **my_public_ssh_key** variable value to the **my_public_ssh_key**
    input variable of the **attacker_vm** module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time, we should not encounter a **Missing required argument** error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a minute or two for this step to complete. Feel free to grab a cup
    of coffee or tea while waiting!
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to display the public IP address of the attacker VM instance along
    with the Kali Linux desktop environment access URL as output, we will reference
    and utilize the outputs from the **attacker_vm** module (as well as the outputs
    from the **target_vm** module) in the root module **outputs.tf** file (similar
    to what we have in *Figure 4**.37*):![](image/B19755_04_37.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.37 – Utilizing the outputs from the attacker_vm and target_vm modules
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using *Figure 4**.37* as a reference, we will update the **outputs.tf** file
    with the following block of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we’re defining the following outputs: (1) **target_vm_username** and
    **target_vm_password**—username and password used to access the target VM instance
    using the serial console, (2) **target_vm_public_ip** and **target_vm_private_ip**—public
    and private IP address values of the target VM instance, (3) **attacker_vm_public_ip**—public
    IP address value of the attacker VM instance, (4) **attacker_vm_access**—URL used
    to access the desktop environment from the browser.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure not to duplicate the output blocks defined in the **outputs.tf** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wait for a minute or two for this step to complete. This should yield the following
    output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Store and save the **attacker_vm_public_ip** output value in a text editor as
    we will use this in the succeeding steps in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Part 3 of 3 – Accessing the Kali Linux desktop environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should have the following set up already:![](image/B19755_04_38.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.38 – Current setup deployed and configured in GCP
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we have the IP address of our local machine whitelisted to access the
    attacker VM instance in **VPC 02** via ports **22** and **8081**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While we can further upgrade this setup to include additional security mechanisms
    (such as establishing a VPN connection), this should do the trick for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s open a new browser tab and access the desktop environment using
    the following URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<ATTACKER VM PUBLIC IP ADDRESS>** with the **attacker_vm_public_ip**
    output value after running the **terraform apply** command in an earlier step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This should open a welcome screen with a **Connect** button, similar to what
    we have in *Figure 4**.39*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.39 – noVNC welcome screen
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself unable to access the welcome screen, it is possible that
    your IP address might have changed already. Simply update the **terraform.tfvars**
    file, then run the **terraform apply** command again to update the firewall rule
    to whitelist your new IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Connect** button and then use the password **kali123** (or use the
    password you specified in an earlier step) to access the desktop environment,
    similar to what we have in *Figure 4**.40*:![](image/B19755_04_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.40 – Accessing the Kali Linux desktop/GUI environment in the browser
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we’re able to access the desktop environment, we should be able to perform
    various tasks and access the wide range of tools and utilities available in Kali
    Linux (similar to how we would use it on our local machine).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you may use the **Connectivity Tests** diagnostic tool to validate
    network connectivity. For more information, feel free to check the following link:
    [https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/how-to/running-connectivity-tests](https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/how-to/running-connectivity-tests).'
  prefs: []
  type: TYPE_NORMAL
- en: Simulating penetration testing in an isolated network environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given that our lab environment in GCP has been set up, we can now proceed with
    having a penetration testing simulation to verify that everything has been configured
    correctly. Of course, we will work with a simplified penetration testing process,
    as our primary goal is to assess whether the penetration testing lab environment
    has been set up and configured correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.41 – Penetration testing simulation
  prefs: []
  type: TYPE_NORMAL
- en: Our simulation will start with a port scan to check the open ports of the target
    VM instance (**vm-target**). After identifying that port **80** is open, we will
    use a web browser to navigate through the pages and explore the functionality
    of the vulnerable web application (running inside a container) accessible on the
    said port. We’ll end the simulation right after we have used an SQL Injection
    attack to gain administrator access and successfully signed in using an administrator’s
    account.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is unethical and illegal to attack cloud resources owned by another user
    or company. Before proceeding, make sure to read the *Examining considerations
    when building penetration testing lab environments in the cloud* section of *[Chapter
    1](B19755_01.xhtml)*, *Getting Started with Penetration Testing Labs in the Cloud*,
    since we will be simulating the attack process to validate if misconfigurations
    and vulnerabilities present in applications and services running in the target
    VM instance are exploitable.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let’s start the penetration testing simulation. Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing where we left off in the previous section, let’s access the Terminal
    application by selecting the **Terminal** icon located in the upper-left corner
    of the Kali Linux desktop interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the terminal window, run the following command (after the **$** sign) to
    store the private IP address value of the target VM instance in the **TARGET_IP**
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<PRIVATE IP ADDRESS OF TARGET VM>** with the private
    IP address of the target VM instance (**vm-target**). Using a private IP ensures
    that the request stays within the intended network environment. In addition to
    this, we won’t be able to access the target VM instance using its public IP address.
    That’s because the network environment is not configured to allow outside traffic
    to reach **VPC 01** where the target VM instance is launched, even if the network
    traffic came from another cloud resource running inside **VPC 01** and **VPC 02**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the CIDR range of the subnet where the target VM instance is launched
    is **10.1.0.0/20**, the target IP address of the VM instance should fall within
    the range of **10.1.0.0** to **10.1.15.255** (excluding the reserved IP addresses).
    For more information, feel free to check the following link: [https://cloud.google.com/vpc/docs/subnets](https://cloud.google.com/vpc/docs/subnets).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use **nmap** to scan the top **1000** ports of the target VM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should provide information about the open ports and the corresponding
    services running on the target VM instance. It allows us to identify which ports
    are accessible and potentially vulnerable to attacks, such as SSH (port **22**)
    and HTTP (port **80**), similar to what we have in *Figure 4**.42*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_42.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.42 – Results of the nmap scan
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Depending on the results of the **nmap** scan, further steps can be performed
    to evaluate the open ports and services running on the target VM instance. However,
    for now, we will skip these steps and proceed with the other aspects of the penetration
    testing process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering what **nmap** is, it is a popular open source network scanning
    tool designed to discover hosts and services on a computer network by sending
    packets and analyzing the responses. With **nmap**, we can perform tasks such
    as **host discovery** (to identify active hosts within a network), **port scanning**
    (for identifying potential entry points or services running on specific ports),
    **OS detection** (to gather information about the operating system running on
    a target host), and **service enumeration** (to gather details about specific
    services running on open ports). In addition to these, **nmap** provides other
    advanced features and capabilities such as **script scanning** (to automate specific
    tasks), **version detection** (to identify specific software versions running
    on target systems), **stealth scanning** (to evade detection), and **timing and
    performance tuning** (to optimize scan speed and accuracy). *Powerful, right?*
    When using **nmap** in conjunction with other penetration testing tools, it is
    important to exercise extreme caution as it can generate significant network traffic
    and potentially trigger security alerts or disrupt network operations if not used
    responsibly. It is advisable to follow ethical hacking practices, obtain necessary
    permissions, and employ proper filtering mechanisms to minimize any unintended
    consequences while performing comprehensive security assessments.
  prefs: []
  type: TYPE_NORMAL
- en: You can now close the terminal window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s check what’s running on port **80** of the target VM instance. Launch
    the **Firefox** browser by selecting the **Firefox** icon located in the top-left
    corner of the desktop interface. Navigate to the following URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open the OWASP Juice Shop vulnerable-by-design web application,
    similar to what we have in *Figure 4**.43*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_43.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.43 – Accessing the target instance from a browser running in the attacker
    instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we have the OWASP Juice Shop—a vulnerable-by-design application with various
    challenges and vulnerabilities meant to help security practitioners and engineers
    understand and learn about common security flaws.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Please remember to use the private IP address of the target VM instance (instead
    of the public IP address), as our **VPC 01** network has been specifically configured
    to allow traffic only from resources within **VPC 02**.
  prefs: []
  type: TYPE_NORMAL
- en: For the next few minutes, explore the functionality and content of the OWASP
    Juice Shop application by navigating through the different pages and features.
    Feel free to interact with the forms, buttons, and links within the application
    to understand their behavior and purpose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s navigate to the **Login** page by opening the **Account** menu located
    in the upper-left corner of the page and then clicking **Login**. This will redirect
    us to the **Login** page, similar to what we have in *Figure 4**.44*:![](image/B19755_04_44.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.44 – OWASP Juice Shop Login page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we have a login form allowing us to specify an email address value and
    a password value. By analyzing the login process and attempting various techniques,
    we should be able to identify and exploit any vulnerabilities present in the login
    functionality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s try performing an SQL Injection attack! Type **' or 1=1--** in the **Email**
    field. After that, type **123** (or any combination of characters) in the **Password**
    field. Click the **Log in** button afterward. This should give us a success notification
    similar to what we have in *Figure 4**.45*:![](image/B19755_04_45.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.45 – Successfully solving a challenge using an SQL Injection attack
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Looks like we were able to successfully sign in with the administrator’s user
    account!* *What just happened?* Here, our SQL Injection attack allowed us to authenticate
    using the first record in the table containing the registered application users
    (or accounts). Luckily for us, this record happened to be an administrator account
    (**admin@juice-sh.op**) as well!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you are wondering what an **SQL Injection attack** is, it is a technique
    where an attacker exploits vulnerabilities in an application’s input fields to
    inject malicious SQL statements. In this specific case, by entering **'' or 1=1--**
    in the **Email** field, the updated SQL query executed by the application’s backend
    might look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The injected portion causes the **WHERE** condition to always evaluate to **true**—bypassing
    the need for a valid email address and password. This allowed us to log in without
    having to provide legitimate credentials. **--** at the end is used to comment
    out the remainder of the original query to ensure that the injected code does
    not cause any syntax errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We have intentionally skipped some steps as we’ve used a simplified penetration
    testing process validating our lab configuration and setup. That said, real-world
    penetration testing involves a more comprehensive and structured approach that
    includes various techniques, tools, and methodologies to thoroughly assess the
    security of an application or a system.
  prefs: []
  type: TYPE_NORMAL
- en: While our relatively simple SQL Injection example demonstrates a common attack
    technique, it’s important to note that various other attacks and techniques can
    be performed in our penetration testing lab environment. Feel free to explore
    and experiment further with the OWASP Juice Shop application before cleaning up
    the lab environment we prepared in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cleaning up the cloud resources we created or deployed is a crucial step when
    working with vulnerable cloud applications and environments. If we don’t clean
    up and delete the resources we created right away, we might end up paying for
    unused cloud resources. In addition to this, these cloud resources may end up
    being attacked by malicious users as well. At a *minimum*, we will be paying for
    the time the following resources are running:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 x **e2-medium** VM instance for the attacker machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x **f1-micro** VM instance for the target machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please be aware that there are other costs we have to take into account as well—including
    data transfer fees, storage costs for persistent data used by instances, potential
    charges for other services utilized in the account, and any applicable taxes or
    fees associated with using resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the overall cost when running these resources depends on several parameters,
    it is best to refer to the pricing documentation page provided by the cloud platform,
    found here: [https://cloud.google.com/compute/vm-instance-pricing](https://cloud.google.com/compute/vm-instance-pricing).
    You can also utilize the **Google Cloud Pricing Calculator** to estimate the cost
    of deploying resources on GCP. You can access the Google Cloud Pricing Calculator
    using the following link: [https://cloud.google.com/products/calculator](https://cloud.google.com/products/calculator).'
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let’s proceed with deleting the resources we created in this chapter,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Close the browser tab we used to access the Kali Linux desktop environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Cloud Shell terminal, navigate to the **~/pentest_lab** directory and
    then use **terraform destroy** to clean up the resources we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Feel free to run the **terraform destroy** command again in case there are some
    resources that fail to delete. Alternatively, you may delete resources manually
    using the user interface if all else fails.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that the resources have been destroyed successfully using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should return an empty response since all resources should have been deleted
    successfully.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to perform a full audit of your account using the Google Cloud console.
    This will help ensure that all resources have been properly deleted, minimize
    the risk of unintended costs, and address any potential security concerns.
  prefs: []
  type: TYPE_NORMAL
- en: That’s pretty much it! At this point, we should have a good idea of how to prepare
    penetration testing lab environments on GCP.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were able to successfully build a penetration testing lab
    in GCP. We started by preparing the prerequisites, along with defining the project
    structure of the Terraform code for automating the lab environment. We then set
    up an isolated network for securing the lab environment resources from external
    attacks. Inside this isolated network, we launched a target VM instance running
    the OWASP Juice Shop application (inside a container). After that, we imported
    the Kali Linux Generic Cloud Image into our Google Cloud account. Using the imported
    image, we proceeded with the setup of the attacker VM instance inside the network
    environment. After completing the lab environment, we performed a simplified penetration
    testing simulation to verify that our lab had been (mis)configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, our focus will shift toward setting up a penetration
    testing lab in Microsoft Azure. We will set up a lab environment where we can
    practice container breakout techniques for gaining authorized access to the host
    system (where the container is running). Our lab setup will also highlight how
    managed identities can be misused to access other resources in the cloud environment.
    If you are excited to learn how to build penetration testing labs in Azure, then
    the next chapter is for you!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For additional information on the topics covered in this chapter, you may find
    the following resources helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Google Cloud – Guide to Cloud Billing Resource Organization & Access* *Management*
    ([https://cloud.google.com/billing/docs/onboarding-checklist](https://cloud.google.com/billing/docs/onboarding-checklist))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Integrate Azure services with virtual networks for network* *isolation* ([https://learn.microsoft.com/en-us/azure/virtual-network/vnet-integration-for-azure-services](https://learn.microsoft.com/en-us/azure/virtual-network/vnet-integration-for-azure-services))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Google Cloud – Best practices and reference architectures for VPC* *design*
    ([https://cloud.google.com/architecture/best-practices-vpc-design](https://cloud.google.com/architecture/best-practices-vpc-design))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kali Linux –* *Cloud* ([https://www.kali.org/docs/cloud/](https://www.kali.org/docs/cloud/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kali Linux – What is Kali* *Linux?* ([https://www.kali.org/docs/introduction/what-is-kali-linux/](https://www.kali.org/docs/introduction/what-is-kali-linux/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Google Cloud – Manually import boot* *disks* ([https://cloud.google.com/compute/docs/import/import-existing-image](https://cloud.google.com/compute/docs/import/import-existing-image))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*OWASP Juice Shop: Probably the most modern and sophisticated insecure web*
    *application* ([https://github.com/juice-shop/juice-shop](https://github.com/juice-shop/juice-shop))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
