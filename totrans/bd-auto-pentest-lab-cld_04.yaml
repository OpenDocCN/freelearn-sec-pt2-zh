- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up Isolated Penetration Testing Lab Environments on GCP
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While setting up cloud-based penetration testing labs, we are deliberately creating
    a vulnerable and misconfigured environment where we can practice various security
    techniques. It is critical that we secure the resources inside this lab environment
    from unauthorized external attacks and mitigate the risk of planned interference
    with any of the authorized testing activities or simulations inside the environment.
    *Imagine attackers managing to gain unauthorized access to vulnerable resources
    inside your penetration testing lab environment!* These attackers would be able
    to leverage the cloud resources to perform various malicious activities—including
    launching **Distributed Denial-of-Service** (**DDoS**) attacks, attacking the
    systems owned by other users and organizations, and even spreading malware from
    inside the compromised cloud account. *Scary, right?* By isolating vulnerable
    lab resources using a properly configured network environment, we can maintain
    a secure testing environment and minimize the risks associated with having penetration
    testing lab environments in the cloud.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will prepare an isolated network environment in **Google
    Cloud Platform** (**GCP**) and use this network environment for setting up a penetration
    testing lab environment secured from unauthorized external attacks. Inside one
    of the **Virtual Private Cloud** (**VPC**) networks of the overall network environment,
    we will set up a target **virtual machine** (**VM**) instance that hosts an intentionally
    vulnerable web application called the **OWASP Juice Shop**. Then, in a separate
    VPC network, we will launch an attacker VM instance (running a penetration testing-focused
    Linux distribution called **Kali Linux**) and configure it with browser-based
    access to its desktop environment. We will then establish VPC peering to create
    a connection between the target VPC network and the attacker VPC network. Finally,
    we will perform a quick penetration testing simulation inside the isolated network
    environment to verify that everything is working correctly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, we will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the necessary components and prerequisites
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the project structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the isolated network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the target VM instance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing the Kali Linux Generic Cloud Image
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually setting up the attacker VM instance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Terraform to automatically set up the attacker VM instance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating penetration testing in an isolated network environment
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first few chapters of this book, we primarily focused on using AWS when
    setting up penetration testing lab environments in the cloud. However, in this
    chapter, our attention will shift to GCP, where we will deploy various cloud resources
    inside a new GCP account. Since its introduction in 2008, GCP has rapidly evolved
    to offer a diverse range of infrastructure and platform services—including VMs
    and database services, along with data engineering and **machine learning** (**ML**)
    services. That said, it is essential for us to explore the process of building
    penetration testing lab environments within this mature and versatile cloud platform.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前几章主要集中在使用 AWS 来设置云端渗透测试实验室环境。然而，在本章中，我们的重点将转向 GCP，我们将在新的 GCP 账户内部署各种云资源。自2008年推出以来，GCP迅速发展，提供了多种基础设施和平台服务——包括虚拟机和数据库服务，以及数据工程和**机器学习**（**ML**）服务。因此，探索如何在这个成熟且多功能的云平台上构建渗透测试实验室环境是非常必要的。
- en: With these points in mind, let’s begin!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些准备，我们就可以开始了！
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we start, we must have the following ready:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，以下准备工作需要完成：
- en: '**A GCP account**—You may start with a free trial account by completing the
    steps specified in the following link: [https://cloud.google.com/free/](https://cloud.google.com/free/).
    In case you have not set up a billing account in your GCP account, make sure that
    you have properly set up billing information/profile so that you can access and
    use the GCP services without interruption. For more information on how to create
    a billing account, check the following link: [https://www.youtube.com/watch?v=NeRYUoR4u0s](https://www.youtube.com/watch?v=NeRYUoR4u0s).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个 GCP 账户**——您可以通过完成以下链接中的步骤，开始使用免费的试用账户：[https://cloud.google.com/free/](https://cloud.google.com/free/)。如果您尚未在
    GCP 账户中设置账单账户，请确保您已正确设置账单信息/个人资料，以便可以不间断地访问和使用 GCP 服务。有关如何创建账单账户的更多信息，请查看以下链接：[https://www.youtube.com/watch?v=NeRYUoR4u0s](https://www.youtube.com/watch?v=NeRYUoR4u0s)。'
- en: Any text editor (such as Notepad++, Visual Studio Code, or Sublime Text) where
    we can temporarily store specific values (for example, your local machine’s IP
    address) used in the hands-on solutions in this chapter.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何文本编辑器（例如 Notepad++、Visual Studio Code 或 Sublime Text），我们可以在其中临时存储本章实践中使用的特定值（例如，您本地计算机的
    IP 地址）。
- en: You may proceed with the next steps once these are ready.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些准备工作完成，您就可以继续进行下一步操作。
- en: Important note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Make sure *NOT* to use any existing GCP account with production (or staging)
    environment resources for the hands-on exercises and solutions in this book. It
    is strongly recommended to create a *new* GCP account specifically for launching
    intentionally vulnerable resources. This will ensure that your production (or
    staging) environment resources remain separate and secure. In addition to this,
    make sure to read the available documentation along with the FAQs to have a solid
    understanding of what is free (and what is not free) when creating resources in
    GCP. For more information, see the following link: [https://cloud.google.com/free/docs/free-cloud-features](https://cloud.google.com/free/docs/free-cloud-features).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确保*不要*使用任何现有的 GCP 账户，其中有生产（或暂存）环境资源，用于本书中的实践练习和解决方案。强烈建议为启动故意存在漏洞的资源创建一个*新的*
    GCP 账户。这将确保您的生产（或暂存）环境资源保持独立和安全。此外，请确保阅读可用文档和常见问题解答，以便充分了解在 GCP 中创建资源时哪些是免费的（哪些不是免费的）。有关更多信息，请参阅以下链接：[https://cloud.google.com/free/docs/free-cloud-features](https://cloud.google.com/free/docs/free-cloud-features)。
- en: The source code and other files used for each chapter are available in this
    book’s GitHub repository at [https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每章使用的源代码和其他文件可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud)。
- en: Preparing the necessary components and prerequisites
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备必要的组件和前提条件
- en: In this section, we will focus on preparing the prerequisites needed for this
    chapter. We will start by retrieving the IP address of your local machine. We’ll
    use this IP address value later when configuring the firewall rules to allow our
    local machine to access specific resources inside the lab environment. In addition
    to this, we will also set up the Google Cloud project where the cloud resources
    will be deployed in this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we will generate SSH keys (a **public key** and a **private key**) for
    accessing the attacker VM instance later in this chapter. As we can see in *Figure
    4**.1*, the private key will be stored inside your local machine while the public
    key will be stored inside the attacker VM instance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Generating SSH keys for accessing the attacker VM instance
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: With this setup, the server (the attacker VM instance) can confirm the identity
    of the client (your local machine) using the private key without having to transmit
    sensitive credentials. This will then allow us to access the attacker VM instance
    via SSH and establish a secure connection for running commands and managing the
    instance remotely.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.1*, we can see the target VM instance along with the other components
    of the penetration testing lab environment. We will dive deeper into how the other
    resources in the lab environment will be configured in the succeeding sections
    of this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, we’ll divide this section into three parts, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 3 – Retrieving the IP address of your* *local machine*'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 3 – Setting up the Google* *Cloud project*'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 3 of 3 – Generating SSH keys to access the attacker* *VM instance*'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these points in mind, let’s proceed with the preparation of the necessary
    components and prerequisites for this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 3 – Retrieving the IP address of your local machine
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Take note of your local machine’s IP address using [https://ipinfo.io/ip](https://ipinfo.io/ip),
    [https://ifconfig.io/](https://ifconfig.io/), or other similar websites and online
    tools. Alternatively, you may use Google search to retrieve your local machine’s
    IP address.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Store and save your IP address information in a text editor as we will use this
    to allow our local machine to access the attacker VM instance later in this chapter.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Part 2 of 3 – Setting up the Google Cloud project
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s create the Google Cloud project where we will deploy the cloud resources
    in this chapter. Proceed as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the Google Cloud console by opening the following link in your
    web browser: [https://console.cloud.google.com/](https://console.cloud.google.com/).'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Google Cloud console** is a web interface provided by GCP for managing
    cloud resources. You can think of it as the counterpart of the **AWS Management
    Console** we used in the first few chapters of this book. If you need a quick
    introduction to how to use the Google Cloud console, feel free to watch the following
    6-minute video: [https://www.youtube.com/watch?v=27Pb5g7bEAA](https://www.youtube.com/watch?v=27Pb5g7bEAA).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: In the **Google Cloud** console, open the navigation menu (**☰**):![](image/B19755_04_02.jpg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.2 – Navigating to the Create a Project page
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Locate and click **Create a project** under **IAM & Admin**, as highlighted
    in *Figure 4**.2*.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Project name** field, specify **secure-network-environments**. Keep
    the value in the **Location** field as it is (**No organization**).
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **CREATE** button afterward.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '**Projects** in GCP are used to organize resources into logical groups. Inside
    a project, we can have a set of users who have access to the project resources.
    A project includes the users and the APIs, along with specific configuration settings
    for these APIs. For more information, feel free to check the following link: [https://cloud.google.com/storage/docs/projects](https://cloud.google.com/storage/docs/projects).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Once the project has been successfully created, click the drop-down menu highlighted
    in *Figure 4**.3*:![](image/B19755_04_03.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.3 – Opening the Select a project popup
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Select a project** popup, select the **secure-network-environments**
    project and then click the **OPEN** button afterward.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Locate and click the **Activate Cloud Shell** button, as highlighted in *Figure
    4**.4*:![](image/B19755_04_04.jpg)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.4 – Activating Cloud Shell
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This should open a terminal where we can run command-line commands.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: It may take a minute or two for Cloud Shell to be ready.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Open Editor** button located at the upper right-hand corner of the
    Cloud Shell terminal pane. This should open the Cloud Shell editor, similar to
    what we have in *Figure 4**.5*:![](image/B19755_04_05.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.5 – Cloud Shell editor
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you can’t see a terminal similar to what we have in *Figure 4**.5*, open
    the **Terminal** menu of the Cloud Shell editor and then select **New Terminal**
    from the list of options.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Google **Cloud Shell** provides a web-based interactive shell environment where
    we can run commands, write scripts, and manage resources when working with cloud
    resources and applications. Since we used **AWS CloudShell** in the previous chapters,
    we should easily adapt to using Google Cloud Shell in this chapter. It is important
    to note that Google Cloud Shell also provides an integrated code editor, allowing
    us to write, edit, and save scripts and configuration files directly within the
    environment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal (right after the **$** sign), run the following command to
    list the projects in your GCP account:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you see the **Authorize Cloud Shell** popup (similar to what is shown in
    *Figure 4**.6*), make sure to click the **AUTHORIZE** button to allow the **gcloud**
    **command-line interface** (**CLI**) to make API calls for us:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_06.jpg)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.6 – Authorize Cloud Shell
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If this is your first time using the **gcloud** CLI, it is simply a command-line
    tool that helps us create and manage a variety of Google Cloud resources.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Running the preceding command should then give us the following output:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Make sure to take note of the **PROJECT_ID** value as we’ll need this when configuring
    the active project in the next set of steps.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, run the following command to check the active project:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the previous command returned a project ID that does not match the **<PROJECT_ID>**
    value from the previous step, run the following command to configure a new active
    project—this time specifying the **<PROJECT_ID>** value obtained from the previous
    step:'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Feel free to use the **gcloud config get-value project** command again to verify
    that the previous command succeeded. Note that when the Cloud Shell environment
    restarts, we may have to configure the active project again using **gcloud config
    set project <PROJECT_ID>** so that we’re running commands and creating cloud resources
    inside the correct project.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure *NOT* to use the project name (that is, **secure-network-environments**)
    for the **<PROJECT_ID>** value when using the **gcloud config set project** command.
    Specifying the incorrect **<PROJECT_ID>** value will yield the following warning
    message: **You do not appear to have access to project [secure-network-environments]
    or it does** **not exist.**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Using the search bar, navigate to the **VPC networks** page using the **vpc
    networks** search query.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the Compute Engine API is not enabled yet, you will be redirected to the
    Compute Engine API page, similar to what is shown in *Figure 4**.7*:![](image/B19755_04_07.jpg)
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.7 – Enabling the Compute Engine API
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **ENABLE** button to proceed. Wait for about 3-5 minutes for the Compute
    Engine API to be enabled. Note that this step is necessary to ensure that you
    have access to Compute Engine services and functionalities within your project.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Part 3 of 3 – Generating SSH keys to access the attacker VM instance
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s generate SSH keys for accessing the attacker VM instance (which
    we’ll set up later in this chapter). Follow the next steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Continuing where we left off in the previous part, let’s open a new **Cloud
    Shell** terminal (or reuse an existing one). Make sure that we are using **secure-network-environments**
    as the active project configured before proceeding.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the terminal (right after the **$** sign), run the following commands to
    create a new directory (named **kali_keys**) and navigate to it:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will store the generated keys inside this directory.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate a new SSH key pair and save the generated key files in the **kali_keys**
    directory:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When asked for a passphrase, just press *Enter* as we won’t add a passphrase
    to our key (the same goes for the password confirmation). This will generate two
    files—**kali-ssh** (the private key) and **kali-ssh.pub** (the public key).
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '*How do these SSH key files work?* SSH key files consist of a **private key**
    (stored and kept on the client’s machine) and a corresponding **public key** uploaded
    to the remote server. During authentication, the client uses its private key to
    generate a digital signature, and the server verifies it using the corresponding
    public key. Here, the server can confirm the client’s identity based on the possession
    of the private key without having to transmit sensitive credentials.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the public key value using the **cat** command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Store this value in a text editor on your local machine as we will use this
    later in the *Manually setting up the attacker VM instance* section of this chapter.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Open Editor** button (in case the editor is not yet open).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: It may take a minute or two for the **Cloud Shell editor** to load.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Locate the generated private key (**kali-ssh**) in the file tree of the editor
    (similar to what is shown in *Figure 4**.8*):![](image/B19755_04_08.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.8 – Downloading the generated private key file
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the file and then select **Download** from the options in the
    context menu. Feel free to perform the same set of steps for the public key (**kali-ssh.pub**)
    to download it to your local machine.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have the prerequisites ready, we can now proceed with setting up
    and defining the project structure!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Defining the project structure
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will introduce the usage of Terraform **modules** to help
    define and organize our **Infrastructure-as-Code** (**IaC**) project structure.
    Modules allow us to encapsulate and reuse sets of resources to make our Terraform
    code more modular, maintainable, and scalable. By leveraging modules, we will
    be able to simplify the management of complex infrastructure deployments and abstract
    common configurations into reusable components.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'In *[Chapter 3](B19755_03.xhtml)*, *Succeeding with Infrastructure as Code
    Tools and Strategies*, we stored all our **.tf** files in a single directory.
    *It feels a bit messy, right?* In case you are wondering how modules change how
    we organize our code and our files, here’s an example of what the project structure
    might look like once we utilize Terraform modules:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_09.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Sample file and folder structure using Terraform modules
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'We have in *Figure 4**.9* a sample file and folder structure (left) along with
    how module directories are loaded in the **main.tf** file of the root module (right).
    Here, the **root_module** directory serves as the main entry point for the Terraform
    configuration. Directories such as **module1** and **module2** inside the project
    root directory will contain Terraform files such as **main.tf**, **variables.tf**,
    and **outputs.tf** specific to those modules. The modules are then defined in
    the **main.tf** file of the root module using the **module** block, similar to
    what we have in the following block of code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that while it is common practice to have a separate directory named **modules**
    to store individual module directories such as **module1**, **module2**, and **module3**,
    we will follow the current project and folder structure shown in *Figure 4**.9*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the **module1**, **module2**, and **module3** directory
    names used in our example are arbitrary and can be renamed according to the user’s
    preference. For instance, alternative names such as **secure_network**, **attacker_vm**,
    and **target_vm** can be used to provide more descriptive and meaningful names
    for the modules.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'The organization and modularization of the IaC configuration files are influenced
    by the overall design of the penetration testing lab environment along with how
    the resources are grouped together. It is crucial that we discuss (at a high level
    for now) what our lab environment will look like in this section. Have a look
    at the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_10.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – High-level diagram of our penetration testing lab environment
    in GCP
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4**.10*, we have two VPC networks: **VPC 01** and **VPC 02**. If
    you are wondering what VPC networks are, these are simply isolated virtual networks
    within a cloud computing environment that allow us to securely separate and manage
    resources. *That being said, which resources are we planning to have inside these
    networks?* Inside **VPC 01**, we’ll have the target VM instance. On the other
    hand, we’ll have the attacker VM instance inside **VPC 02**. One way to group
    these resources together is by using the following groups:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Group 1**—**VPC 01** and the target VM instance'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group 2**—**VPC 02** and the attacker VM instance'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should take into consideration the possible limitations of this approach.
    Grouping **VPC 01** and the target VM instance together may restrict the flexibility
    and scalability of the network environment (from a modularization standpoint).
    If we want to add more target VM instances in the future, we will need to modify
    the existing group and potentially cause the first group to have too many resources.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with VPCs and VM instances, do not worry as we will discuss
    these in more detail in the upcoming section of this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, another option involves creating three distinct modules, as
    follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The **secure_network** module—Network resources such as **VPC 01** and **VPC
    02**, along with other relevant resources grouped together
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **target_vm** module—The target VM instance
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **attacker_vm** module—The attacker VM instance
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This alternative appears to be a more favorable choice as it leans toward the
    preparation of a reusable network environment module that can be easily utilized
    for various iterations of our penetration testing lab environments in GCP. In
    addition to this, it provides the flexibility to swap out the target VM instance
    module with one or more alternative vulnerable-by-design target modules. While
    this approach is not perfect, this should do the trick for now as it offers significant
    advantages in terms of scalability, modularity, and adaptability for building
    dynamic penetration testing lab environments in GCP.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: If the overview of our penetration testing lab environment in this section feels
    a bit vague and lacking in detail, do not worry – we will have a more comprehensive
    discussion as we go through each of the succeeding sections in this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s proceed with setting up the initial project files and directories:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Continuing where we left off in the previous section, let’s make sure that we
    have a terminal ready where we’ll run the commands:![](image/B19755_04_11.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.11 – Opening a new terminal
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the **Terminal** menu of the Cloud Shell editor (as highlighted in *Figure
    4**.11*). Select **New Terminal** from the list of options available.
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the terminal (right after the **$** sign), run the following commands to
    create a **pentest_lab** project directory (and navigate to the new directory
    as well):'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Inside the **pentest_lab** directory, let’s also create **secure_network**,
    **target_vm**, and **attacker_vm** directories, like so:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ll store the corresponding module files later in these directories.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: While it is common practice to have a separate directory named **modules** to
    store individual module directories such as **secure_network**, **target_vm**,
    and **attacker_vm**, our current project and folder structure should suffice for
    now.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the files we’ll have in the root folder of our project:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that at this point, these files are still empty. We will populate them
    with the necessary configurations as we go along. This is what our project structure
    currently looks like:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_12.jpg)'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.12 – What our current project structure looks like in the file tree
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, we have three empty directories (**attacker_vm**, **secure_network**,
    and **target_vm**) along with six empty files (**main.tf**, **outputs.tf**, **provider.tf**,
    **terraform.tfvars**, **variables.tf**, and **versions.tf**) inside the **pentest_lab**
    directory.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By locating the file in the file tree (left of the editor), open the **provider.tf**
    file in the editor and add the following block of code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are configuring the Google provider, specifying the region as **us-central1**
    and the zone as **us-central1-c**. This provider configuration ensures that the
    resources we deploy with Terraform will be provisioned within the specified region
    and zone in GCP. With this in mind, make sure to save any modifications made to
    the **provider.tf** file before moving on to the next step.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In the next set of steps, we will be updating and adding code to multiple files
    inside the **~/pentest_lab** directory. Make sure that any changes made to each
    of the files are saved so that we don’t encounter unexpected errors when running
    the **terraform** commands.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s open **versions.tf** in the editor. Let’s add the following block
    of code to specify the required version constraints for the providers used:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we’re specifying the source and version for the random and Google Cloud
    providers. *Why is this necessary?* This ensures that the correct versions of
    the providers are used to maintain compatibility and consistency while using Terraform.
    That said, make sure to save any modifications made to the **versions.tf** file
    before moving on to the next step.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open **variables.tf** in the editor and add the following blocks of code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are defining two variables—**my_ip** and **my_public_ssh_key**. Note
    that we won’t be specifying default values this time since we’ll be using the
    **terraform.tfvars** file to store the variable values instead. Make sure to save
    any modifications made to the **variables.tf** file before moving on to the next
    step.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open **terraform.tfvars** in the editor and add the following lines of code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Make sure to replace **<IP ADDRESS OF YOUR LOCAL MACHINE>** with the current
    IP address value of the laptop or desktop you are using. In addition to this,
    make sure to replace **<PUBLIC SSH KEY>** with the public key string value (after
    running **cat kali-ssh.pub** in an earlier step). Note that the value of **<PUBLIC
    SSH KEY>** should follow a format resembling **ssh-rsa ... kali**. Do not forget
    to save the **terraform.tfvars** file before proceeding to the next step.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might be wondering what this file is used for! The **terraform.tfvars**
    file is used to store input variable values in a Terraform project. It provides
    a convenient way to manage and customize the properties of the infrastructure
    without having to modify the configuration code. In addition to this, the values
    stored in the **terraform.tfvars** file are automatically loaded when using the
    **terraform** **apply** command.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Open **main.tf** in the editor and add the following blocks of code to define
    the modules that will be used for this project:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are adding module blocks in **main.tf** to include the **secure_network**,
    **attacker_vm**, and **target_vm** modules from their respective source directories.
    Make sure to save the **main.tf** file before proceeding to the next step.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the terminal (right after the **$** sign), let’s run the **terraform init**
    command to initialize the Terraform working directory:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should return the following output:'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you are inside the **~/pentest_lab** directory before running
    the **terraform init** command (and the other **terraform** commands in the next
    set of steps).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the **terraform plan** command, let’s run **terraform fmt**
    to format our Terraform code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we are using the **terraform fmt** command to ensure a consistent coding
    style across all Terraform configuration files. This command will scan the Terraform
    configuration files and adjust the indentation, spacing, and line breaks automatically
    to match the official Terraform style guide.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: While this step is optional, it is highly recommended to use the **terraform
    fmt** command as part of your development workflow to maintain a clean and consistent
    coding style.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should return the following output:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command should complete without any errors. Otherwise, make sure to review
    and fix any issues before proceeding.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This should yield the following output:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Given that we have not yet defined and configured any cloud resource in our
    configuration code, this is the result that we’re expecting! That said, if the
    **terraform apply** command runs without any errors, we are ready to proceed to
    the next section.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With our project structure and skeleton ready, we can now proceed with setting
    up the isolated VPC network environment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the isolated network
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having a solid understanding of the compute and networking services in GCP
    is essential for designing and implementing secure network environments where
    penetration testing lab resources are deployed. That said, before we dive deep
    into the secure network design, let’s quickly go through some of the resources,
    concepts, features, and components we will work with in this chapter, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**VPC**—A VPC is a virtual network within a cloud computing environment that
    allows us to securely separate and manage resources. With VPCs, we can design
    and customize our own custom network architectures to meet specific requirements
    as well as enable secure communication between the resources deployed within the
    VPC. Inside a VPC, we can have **subnetworks** (**subnets**) that allow for further
    segmentation and isolation of resources within the larger VPC network. Subnets
    enable us to group resources together based on different considerations and requirements.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the following diagram:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_13.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Simplified network diagram
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.13*, we have a *simplified* network diagram with two VPC networks.
    Each of these VPCs has two subnets. Inside these subnets, we can have various
    resources such as VMs and other cloud resources. If this is your first time dealing
    with these concepts, you can think of a VPC network as a country and subnets as
    cities within a country. Similar to how a country establishes its own rules and
    borders, a VPC network creates a controlled environment (inside a cloud account)
    to securely manage resources. Just as cities within a country have their own distinct
    characteristics, subnets within a VPC network act as isolated zones that segregate
    various types of resources inside the larger VPC network.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that we didn’t include projects or zones, along with
    other typical network components, in our simplified network diagram to focus instead
    on the key elements of networks that are relevant to our discussion.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**Firewall rules**—Firewall rules are security rules that dictate how traffic
    is allowed or denied within a network. By setting up firewall rules, we can define
    the allowed (or blocked) communication paths and prevent unauthorized access and
    potential threats from reaching resources inside the network. Similar to how traffic
    police maintain order on city streets, firewall rules regulate the flow of data
    and help establish secure communication between various components in our cloud
    infrastructure.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VPC peering**—VPC peering is a networking capability that enables secure
    and private communication between two VPC networks as if they were part of the
    same network.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, have a look at the following diagram:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_14.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Simplified network diagram
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.14*, we have a simplified network diagram with two VPC networks
    connected through VPC peering. With VPC peering, traffic from resources deployed
    in the subnet of the first VPC network would be able to reach resources deployed
    in the subnet of the second VPC network (and vice versa) as long as the necessary
    firewall rules have been configured correctly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: When using VPC peering to connect VPC networks, it is important to note that
    IP address ranges used in peered VPC networks must not overlap to prevent routing
    conflicts. For instance, if VPC A has an IP address range of **10.0.0.0/16** and
    VPC B has an IP address range of **192.168.0.0/16**, then we should have a successful
    VPC peering connection since these ranges do not overlap. However, if both VPC
    A and VPC B have IP address ranges of **10.0.0.0/16**, then there would be an
    overlap that would result in routing conflicts and prevent the establishment of
    a VPC peering connection. In addition to this, VPC peering connections in GCP
    are unidirectional since each peering connection must be configured separately
    in each VPC network. This allows traffic to flow from one VPC network to another,
    but not in the reverse direction unless a reciprocal peering connection is established.
    Finally, VPC peering is non-transitive—meaning that peering connections do not
    extend to other VPC networks beyond immediate peers. If connectivity is required
    between multiple VPC networks, separate peering connections need to be established.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '**VM instance**—A VM instance refers to a virtualized computer system that
    runs within a cloud environment that enables users to deploy and run applications
    and services in a virtualized environment. A VM instance generally includes an
    operating system along with allocated computing resources such as CPU and memory,
    as well as storage capacity.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private IP address**—A private IP address is an IP address assigned to a
    resource in a VPC that is used for internal communication between resources within
    the VPC. It’s important to note that the private IP address of a resource would
    fall within the range of available addresses designated for the specific subnet
    where the resource is launched.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public IP address**—A public IP address is an IP address assigned to a resource
    in a VPC that allows resources to be reachable from outside the VPC network. If
    a resource does not have a public IP address, it means that the resource is only
    accessible within the private network of the VPC and cannot be reached directly
    from the public internet.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial console**—The serial console is a capability (or feature) that provides
    direct access to the CLI of a VM instance. It allows us to troubleshoot and configure
    the operating system of the VM instance even when the VM’s network connectivity
    is unreliable or unavailable.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple ways to establish a secure network environment setup in GCP
    that restricts traffic from external hosts from reaching cloud resources deployed
    inside the network environment. By configuring strict firewall rules, implementing
    network segmentation, and leveraging relevant VPC features and configurations,
    we can prevent unauthorized external access to the internal network environment.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on one of the various solutions that satisfy
    the following constraints and requirements:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Attacker resources (for example, a Kali Linux VM instance) should be deployed
    and grouped within a dedicated VPC network. Similarly, target resources (for example,
    vulnerable-by-design applications and resources) should be deployed and grouped
    within a separate VPC network.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic originating from attacker resources should reach the target resources
    without issues even if these resources are deployed in a different VPC.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial console access should be enabled to allow direct access to both the attacker
    and target VM resources.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we will configure the attacker VM instance to establish SSH connections
    and SSH tunnels with your machine, we will restrict port **22** of the attacker
    VM instance to only allow access from your local machine. Similarly, since we
    will configure the attacker VM instance with browser-based access to its desktop
    environment, we will restrict port **8081** of the attacker VM instance to only
    allow access from your local machine.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given these constraints and requirements, what should our network environment
    look like? The following diagram gives us an overview:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_15.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – High-level architecture diagram of our penetration testing lab
    environment
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.15*, we have a simplified network diagram with two VPC networks
    connected through VPC peering. Here, traffic from the attacker VM instance deployed
    in **VPC 02** would be able to reach the target VM instance deployed in **VPC
    01** (and vice versa). With the correct project configuration, we should be able
    to use the serial console to connect to the attacker and target VM instances.
    The firewall rules configured should allow our local machines to access the attacker
    VM instance via port **22** and port **8081**.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that the architecture we discussed is just one of the
    potential solutions. That said, several alternative approaches can meet the requirements
    and specified constraints.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: In addition to blocking external inbound traffic, the VPC networks in *Figure
    4**.15* may be configured to block outbound traffic to resources outside of the
    peered networks as well. While this is possible, it prevents the VM instances
    and other resources within the VPC networks from accessing resources outside of
    the peered networks. This means that these resources won’t be able to access external
    repositories for downloading updates and packages, which could impact the setup
    process. In this chapter, we will configure the VPC networks to allow outbound
    traffic (that is, the instances inside the peered VPCs should be able to access
    resources outside the overall network). However, after you have completed the
    chapter, feel free to explore the alternative approach of blocking outbound traffic
    for a more restricted network environment.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'With these points in mind, let’s proceed with preparing the network environment,
    as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Cloud Shell terminal (right after the **$** sign), run the following
    commands (one line at a time) to navigate to the **~/****pentest_lab/secure_network**
    directory:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, run the following commands to create the files we will need in our **secure_network**
    module:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Make sure not to get confused since we have a few files with the same filename
    in different directories! While we have the **main.tf**, **variables.tf**, and
    **outputs.tf** files inside the **~/pentest_lab/secure_network** directory, we
    also have files with the same name in the **~/****pentest_lab** directory.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the editor, add the following block of code to the **secure_network/variables.tf**
    file:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Make sure to save the **secure_network/variables.tf** file before proceeding.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, open the **secure_network/main.tf** file in the editor. In the next set
    of steps, we will be adding blocks of code here to define and configure multiple
    network resources. Let’s start by adding the following block of code, which will
    allow us later to use serial connect to access our VM instances from the browser:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a variety of ways to connect to running VM instances. In this chapter,
    we’ll use **serial connect** since it offers a convenient way to access the VM
    instances we launched from the browser. Feel free to check the following link
    for more information: [https://cloud.google.com/compute/docs/troubleshooting/troubleshooting-using-serial-console](https://cloud.google.com/compute/docs/troubleshooting/troubleshooting-using-serial-console).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file (**secure_network/main.tf**), add the following block of code
    to define **google_compute_network** and **google_compute_subnetwork** resources:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we define a VPC network with a single subnet with the **10.1.0.0/20**
    **Classless Inter-Domain Routing** (**CIDR**) range. Since **auto_create_subnetworks**
    is set to **false**, no other subnets will be created (other than the subnet we
    just defined).
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same file (**secure_network/main.tf**), define **vpc_02** and **subnet_02**
    resources as well:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will launch the attacker VM instance in these network resources later in
    this chapter.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same file (**secure_network/main.tf**), let’s define two **net_01**
    and **net_02** local values:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We’ll use these local values when defining the other networking resources in
    the next set of steps.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same file (**secure_network/main.tf**), let’s define two **google_compute_network_peering**
    resources using the following blocks of code—one from **vpc-01** to **vpc-02**
    and another from **vpc-02** to **vpc-01**:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Important note
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: In order for VPC Network Peering to work properly, the CIDR blocks of the VPCs
    involved should *NOT* overlap. In our case, our setup should work just fine since
    the CIDR blocks of **VPC 01** (**10.1.0.0/20**-**10.1.0.0**-**10.1.15.255**) and
    **VPC 02** (**10.2.0.0/20**-**10.2.0.0**-**10.2.15.255**) do not overlap. Feel
    free to use an online subnet calculator to verify this.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file (**secure_network/main.tf**), let’s define **allow-all-from-vpc2**
    and **allow-all-from-vpc-1** firewalls using the following block of code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These blocks will (1) allow traffic from resources deployed in **VPC 02** to
    reach resources deployed in **VPC 01** (that is, from **10.2.0.0/20** to **10.1.0.0/20**)
    and (2) allow traffic from resources deployed in **VPC 01** to reach resources
    deployed in **VPC 02** (that is, from **10.1.0.0/20** to **10.2.0.0/20**).
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Priority numbers in GCP firewall rules determine the order in which rules are
    evaluated. The *lower* the priority number, the *higher* the priority of the rule.
    GCP evaluates firewall rules in ascending order based on priority numbers until
    a matching rule is found, at which point the evaluation stops. That said, it is
    important to assign unique and appropriately sequenced priority numbers to ensure
    that the desired firewall rules are applied correctly and in the intended order.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file (**secure_network/main.tf**), let’s define **allow-ssh-from-my-ip**
    and **allow-desktop-access-from-my-ip** firewalls using the following block of
    code:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These firewall rules will allow your local machine to access resources launched
    inside **VPC 02** (via ports **22** and **8081**) once the entire penetration
    lab environment has been set up.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to save the **secure_network/main.tf** file (**File** menu > **Save**)
    before running the terminal commands in the succeeding set of steps.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s open **secure_network/outputs.tf** in the editor. Add the following
    blocks of code to define the **subnet_01** and **subnet_02** outputs:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Make sure to save the **secure_network/outputs.tf** file as well before proceeding
    to the next step.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate to our **pentest_lab** project directory, like so:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s use the **terraform init** command to reinitialize the Terraform working
    directory:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This should give us a **Missing required argument — The argument “my_ip” is
    required, but no definition was found** error message since we have not provided
    any value for the **my_ip** argument while declaring the **secure_network** module.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering why this issue has suddenly occurred, it’s important to
    recall that we defined the **my_ip** variable in the **secure_network/variables.tf**
    file in an earlier step.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the issue encountered in the previous step, we need to provide a
    value for the **my_ip** argument when declaring the **secure_network** module
    (similar to what we have in *Figure 4**.16*):![](image/B19755_04_16.jpg)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.16 – Passing the my_ip variable value to the my_ip input variable of
    the secure_network module
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using *Figure 4**.16* as a reference, we will resolve the issue by passing the
    **my_ip** variable value (of the root module) to the **my_ip** input variable
    of the **secure_network** module. Since we had the **terraform.tfvars** file prepared
    in an earlier step, the default variable values for **my_public_ssh_key** and
    **my_ip** will be loaded from the **terraform.tfvars** file when we run the **terraform
    apply** command in a later step.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have a better idea of how to resolve the issue, let’s locate the
    following block of code in our **main.tf** file (**~/pentest_lab/main.tf**):'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Update it with the following block of code:'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we are passing the **my_ip** variable value to the **my_ip** input variable
    of the **secure_network** module.
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to save the **main.tf** file (**~/pentest_lab/main.tf**) before proceeding
    to the next step.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Cloud Shell terminal (right after the **$** sign), let’s run the following
    command to preview the changes to be performed by Terraform:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This should yield the following output:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We should be able to proceed without encountering an error this time.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Running the command should return the following output:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a few minutes for the **terraform apply** command to complete.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s check the resources created by Terraform using the console. Navigate
    to the list of existing VPC networks by typing **vpc networks** in the search
    bar and then selecting **VPC networks** from the search results:![](image/B19755_04_17.jpg)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.17 – List of VPC networks
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *Figure 4**.17*, we can see that **vpc-01** and **vpc-02** VPC networks have
    been created by Terraform successfully. Here, we can also see that both **vpc-01**
    and **vpc-02** have a single subnet each (indicated by the count under the **Subnets**
    column). Feel free to click the **REFRESH** button in case the list does not reflect
    the new VPCs we just created.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s check the VPC network where we’ll host the target VM instance. Click **vpc-01**
    from the list of VPC networks to navigate to the VPC network details page of the
    said VPC:![](image/B19755_04_18.jpg)
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.18 – VPC network details
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We should see that we only have a single subnet inside **vpc-01**, similar to
    what we have in *Figure 4**.18*. You may also check the resources under the **FIREWALLS**
    and **VPC NETWORK PEERING** tabs to verify that these resources have been created
    and configured correctly.
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: You may navigate back to the list of VPC networks and check **vpc-02** along
    with the other resources created using the Google Cloud console as well.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '*Wasn’t that easy?* Without further ado, let’s move on to the next section.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the target VM instance
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our isolated network environment ready, we can now proceed with setting
    up the target VM instance. In this section, we will set up the target VM instance
    in the subnet of **VPC 01**, similar to what we have in *Figure 4**.19*:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_19.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – Setting up the target VM instance in the subnet of VPC 01
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Inside the target VM instance, we will be running an intentionally vulnerable
    application called **OWASP Juice Shop**. OWASP Juice Shop was designed, developed,
    and prepared by the **Open Web Application Security Project** (**OWASP**) to help
    developers, security engineers, and penetration testers enhance their understanding
    of secure coding practices and vulnerability identification, along with various
    mitigation strategies. To simplify the setup and installation of the OWASP Juice
    Shop application in our VM instance, we will utilize the **bkimminich/juice-shop**
    container image. This container image will allow us to run the vulnerable-by-design
    application inside a container.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering what **containers** are, they are simply lightweight and
    isolated runtime environments that provide a consistent and portable way to run
    applications across various computing environments. On the other hand, container
    images (such as the **bkimminich/juice-shop** container image) are templates that
    contain the necessary files and configurations to create and run containers. They
    include the application code, along with all the prerequisites required to execute
    an application within a containerized environment.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Containers allow different vulnerable-by-design applications to coexist inside
    the VM instance without interfering with each other. That said, while we are planning
    to have only one container running inside the target VM instance, it is worth
    mentioning that running multiple intentionally vulnerable applications inside
    containers on the same VM instance is possible as well.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'This section is divided into the following subparts:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 2 – Preparing the target VM instance* *using Terraform*'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 2 – Using the serial console to access the target* *VM instance*'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without further ado, let’s begin!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 2 – Preparing the target VM instance using Terraform
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **~/pentest_lab/target_vm** directory by running the following
    in the Cloud Shell Terminal:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Run the following commands to create the files we’ll need in our **target_vm**
    module:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Open a new browser tab and navigate to this book’s official GitHub repository:
    [https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/).'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the **target_boot_script.tpl** template file inside the **ch04/pentest_lab/target_vm**
    directory ([https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/target_boot_script.tpl](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/target_boot_script.tpl)):![](image/B19755_04_20.jpg)
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.20 – Copy Link Address option
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the **Raw** button and select **Copy Link Address** from the
    list of options in the context menu (as highlighted in *Figure 4**.20*). This
    will copy the link address of the file to the clipboard of your local machine.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Download the **target_boot_script.tpl** template file using the **wget** command:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Make sure to replace **<DOWNLOAD LINK>** with the link copied earlier (it should
    be in your clipboard after selecting **Copy Link Address** from the context menu
    options).
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also use this link instead for the **<DOWNLOAD** **LINK>** value:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/target_boot_script.tpl](https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/target_boot_script.tpl)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly check the contents of the **target_boot_script.tpl** file we
    downloaded using the **cat** command:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Spend a few minutes reading the code inside the file. You’ll see that the script
    is divided into three parts, as follows:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**SET UP USER**—Running the script creates a new user on the system, sets a
    password for that user, and then grants the new user **sudo** privileges (without
    requiring a password)'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INSTALL DOCKER**—Here, we run a few commands for installing Docker on the
    system where the script will run'
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SET UP OWASP JUICE SHOP**—This portion of the script focuses on running the
    OWASP Juice Shop application in a Docker container and making it accessible on
    port **80** of the host machine where the script will run'
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s open a new browser tab and locate the **wait_for_boot.tpl** template
    file inside the **ch04/pentest_lab/target_vm** directory ([https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/tree/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl)):![](image/B19755_04_21.jpg)
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.21 – Copy Link Address option
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the **Raw** button and select **Copy Link Address** from the
    list of options in the context menu (as highlighted in *Figure 4**.21*). This
    will copy the link address of the file to the clipboard of your local machine.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Download the **wait_for_boot.tpl** template file using the **wget** command:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Make sure to replace **<DOWNLOAD LINK>** with the link copied earlier (it should
    be in your clipboard after selecting **Copy Link Address** from the context menu
    options).
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also use this link instead for the **<DOWNLOAD** **LINK>** value:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl](https://raw.githubusercontent.com/PacktPublishing/Building-Penetration-Testing-Labs-in-the-Cloud/main/ch04/pentest_lab/target_vm/wait_for_boot.tpl)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly check the contents of the **wait_for_boot.tpl** file we downloaded
    using the **cat** command:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Spend a minute or two reading the code inside the file. You’ll see that the
    script simply waits for the target boot script (based on the **target_boot_script.tpl**
    template script file) to finish running. The script loops for a certain number
    of retry attempts and checks if the target boot script has executed the following
    line of code:'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Important note
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the **target_boot_script.tpl** and **wait_for_boot.tpl** template
    files are inside the **pentest_lab/target_vm** directory before proceeding.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s open **target_vm/variables.tf** in the editor and add the following
    block of code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we’ll define a single variable that will be used when configuring in which
    subnet the VM instance will be launched.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to save the **target_vm/variables.tf** file before proceeding.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s open the **target_vm/main.tf** file in the editor. We will add several
    blocks of code in the next set of steps.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **target_vm/main.tf** file, let’s define a resource called **random_password**
    that generates a random string of length **12** with special characters:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we provide our own list of special characters to be used when generating
    the random password value. If you are wondering where we’ll use this generated
    password, we will use it when accessing the target VM instance (via the serial
    console) in the succeeding set of steps.
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the **target_vm/main.tf** file, let’s define a few local variables that
    we will use when configuring our VM instance (before defining our **google_compute_instance**
    resource):'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we define **vm_username**, **vm_password**, **script**, and **subnet_01**
    local variables. When defining the **script** local variable, we use the **templatefile()**
    function to render the contents of the **target_boot_script.tpl** template file
    by passing in the values of **vm_username** and **vm_password** as variables.
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the **target_vm/main.tf** file, let’s define our first **google_compute_instance**
    resource using the following block of code:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the **target_vm/main.tf** file, let’s also define **wait_for_startup_script**
    and **null_resource** resources:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you are wondering what this is for, this code block simply runs a script
    (coded inside the **wait_for_boot.tpl** template file) inside the VM instance
    and waits for the entire boot script (coded inside the **target_boot_script.tpl**
    template file) to complete.
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Without this block, the **terraform apply** command would finish prematurely,
    even if the target VM instance’s boot process had not finished. This would mean
    that the OWASP Juice Shop application may not be available and accessible yet
    by the time the **terraform apply** command has completed!
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **target_vm/main.tf** file, let’s define the following local values
    as well:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to save the **target_vm/main.tf** file before proceeding with the
    next set of steps.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the **target_vm/outputs.tf** file in the editor. Add the following
    blocks of code to define the outputs of the **target_vm** module:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Make sure to save the **target_vm/outputs.tf** file before proceeding with the
    next set of steps.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: We will use these output values in the **~/****pentest_lab/outputs.tf** file.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Cloud Shell terminal (right after the **$** sign), navigate to the **pentest_lab**
    project directory:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let’s use the **terraform init** command to reinitialize the Terraform working
    directory:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This should give us a **Missing required argument — The argument “subnet_01”
    is required, but no definition was found** error message since we have not provided
    any values for the **subnet_01** argument while declaring the **target_vm** module.
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering why we suddenly encountered this issue, it’s important
    to recall that we defined the **subnet_01** variable in the **target_vm/variables.tf**
    file in an earlier step. We will have this resolved in the next set of steps!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the issue encountered in the previous step, we need to ensure that
    we provide a value for the **subnet_01** argument when declaring the **target_vm**
    module (similar to what we have in *Figure 4**.22*):![](image/B19755_04_22.jpg)
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.22 – Providing a value for the subnet_01 argument when declaring the
    target_vm module
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using *Figure 4**.22* as a reference, we will resolve the issue by passing
    the **subnet_01** output value from the **secure_network** module to the **subnet_01**
    input variable of the **target_vm** module. Now that we have a better idea of
    how we’ll resolve the issue, let’s locate the following block of code in our **main.tf**
    file (**~/pentest_lab/main.tf**):'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Update it with the following block of code:'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, we are passing the output value from the **secure_network** module (**module.secure_network.subnet_01**)
    to the **subnet_01** input variable of the **target_vm** module.
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to save the changes made to the **main.tf** file (**~/pentest_lab/main.tf**).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This should give us the following output:'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We should be able to proceed without encountering an error this time.
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Running the command should yield the following output:'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a minute or two for the **terraform apply** command to complete.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for us to see the output values, let’s open the **outputs.tf** file
    (**~/pentest_lab/outputs.tf**) in the editor and add the following blocks of code:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This will utilize the outputs from the **target_vm** module in the root module’s
    **outputs.tf** file (**~/pentest_lab/outputs.tf**).
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This should yield the following output:'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This should give us the following output:'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we can see the output values after running the **terraform apply -auto-approve**
    command since we defined the outputs in the root module (that is, the code stored
    inside **~/pentest_lab**) in an earlier step.
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Store and save the output values for **target_vm_username**, **target_vm_password**,
    and **target_vm_private_ip** in a text editor as we will use these in the succeeding
    steps in this chapter.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Part 2 of 2 – Using the serial console to access the target VM instance
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **VM instances** page by typing **compute engine** in the search
    box and selecting **Compute Engine** from the search results (similar to what
    is shown in *Figure 4**.23*):![](image/B19755_04_23.jpg)
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.23 – Navigating to the VM instances page
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the **VM instances** page, we’ll find a list of VM instances in our GCP account.
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the link (**vm-target**) under the **Name** column to navigate to the
    **Instance details** page of our target VM instance (**vm-target**).
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s time we accessed the serial console! In case you are wondering what it
    is, the **serial console** serves as a troubleshooting tool that allows users
    to conveniently access the serial port of a VM instance directly in GCP. It enables
    users to interact with the VM’s console output, access the boot process, and diagnose
    issues even when SSH or other network-based connections are unavailable (or misconfigured).
    With this in mind, let’s click on the **CONNECT TO SERIAL CONSOLE** button. This
    will open a pop-up window similar to what we have in *Figure 4**.24*:![](image/B19755_04_24.jpg)
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.24 – Serial console popup
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you see a blank page inside the pop-up window, click inside the blank page
    and then press the *Enter* key. Use the output values for **target_vm_username**
    (**testuser**) and **target_vm_password** (generated password) to log in.
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to run the **terraform show** command in the Cloud Shell terminal
    to retrieve the output values for **target_vm_username** and **target_vm_password**.
    Make sure that you are inside the **~/pentest_lab** directory before running the
    **terraform** **show** command.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to check if the OWASP Juice Shop container is running
    inside the target VM instance:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If prompted for the password, simply use the **target_vm_password** output value
    to proceed with the command.
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **sudo docker ps** command should return a single running container using
    the **bkimminich/juice-shop** container image:'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_25.jpg)'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.25 – Confirming that the OWASP Juice shop container is already running
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Accessing port **80** of the VM instance would allow you to interact with the
    container running the **bkimminich/juice-shop** image.
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to send a sample request to the local server and
    check whether a website is running on port **80**:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This should yield the following output:'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_26.jpg)'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.26 – Result after using the curl command
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Looks like we have confirmed that we have a website running on port **80** of
    the VM instance (mapped to a web application inside the running container).
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have a better idea of what’s running inside the target VM instance,
    we can close the serial console (**SSH** **in-browser**) popup.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this stage, you might be excited about exploring and accessing the OWASP
    Juice Shop application already! Given that we’ve intentionally configured the
    network environment to only allow resources in **VPC 02** to access **VPC 01**
    (where the target VM instance is launched), we will have to set up our attacker
    VM instance in **VPC 02** first before we can access the vulnerable-by-design
    application, along with performing a penetration testing simulation inside the
    network environment.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Importing the Kali Linux Generic Cloud Image
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Kali Linux** is a specialized operating system designed specifically for
    advanced penetration testing and ethical hacking activities. With its wide range
    of security tools, Kali Linux enables cybersecurity professionals and enthusiasts
    to perform penetration tests, digital forensics investigations, and vulnerability
    assessments. If you have not used Kali Linux before, think of it as an upgraded
    version of a specific operating system where powerful security tools are pre-installed,
    turning it into a specialized arsenal for cybersecurity professionals. It’s like
    transforming a regular car into a heavily armored tank with an array of advanced
    weapons!'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: As a specialized operating system with advanced hacking tools, Kali Linux has
    the potential to cause harm or engage in malicious activities if used improperly.
    While it is generally safe to use Kali Linux inside your own penetration testing
    lab environments, always make sure that you have proper authorization when using
    it for conducting security assessments and penetration testing exercises. This
    ensures that you stay within legal and ethical boundaries and avoid any unauthorized
    activities that may lead to legal consequences or harm the integrity of systems.
    Remember to obtain explicit permission from the owner of the systems or networks
    you are testing and adhere to any applicable laws, regulations, or guidelines.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Given that Kali Linux is not available as a preconfigured image in **Google
    Cloud Marketplace**, we need to follow a specific set of steps to import the Generic
    Cloud Image before launching a Kali Linux VM. *Generic what??* The **Generic Cloud
    Image** of Kali Linux is simply a preconfigured and optimized image for deployment
    on various cloud platforms (including GCP). You can think of the image as a DNA
    template that can be used to prepare clones of Kali Linux instances on different
    cloud platforms. It serves as a foundational blueprint, containing all the essential
    configurations and software required for penetration testing and security assessments.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a better understanding of what Kali Linux is and what the
    Generic Cloud Image is used for, let’s proceed with importing the said image to
    our Google GCP project, as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Open a new browser tab and navigate to [https://www.kali.org/get-kali/#kali-cloud](https://www.kali.org/get-kali/#kali-cloud).
    Locate and right-click on the **Generic Cloud Image** download box to open the
    context menu:![](image/B19755_04_27.jpg)
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.27 – Copying the link address of the Generic Cloud Image
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Select **Copy Link Address** from the list of options in the context menu similar
    to what is shown in *Figure 4**.27*. This should copy the following download link
    to our local machine’s clipboard:'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note that this download link may change as new versions of the image are made
    available.
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'Store and save this download link in a text editor as we will use this in the
    succeeding steps in this chapter. In case you are unable to copy the link address,
    you may find the Generic Cloud Image files here: [https://kali.download/cloud-images/kali-2023.1/](https://kali.download/cloud-images/kali-2023.1/)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate back to our Google Cloud console browser tab. In the Cloud Shell terminal
    (after the **$** sign), run the following commands to create a directory named
    **kali-image** (and navigate to the created directory as well):'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Download the latest version of the **Generic Cloud Image** using **wget** by
    running the following commands in the Cloud Shell terminal:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This should download the **kl_image.tar.xz** file inside our **kali-image**
    directory.
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to update the **IMAGE_SOURCE** variable value with the download link
    you copied to the text editor in an earlier step.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a compatible **.tar.gz** file for storing the Kali Linux Generic Cloud
    Image by running the following lines (one line at a time):'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, we are able to prepare a compressed tarball file named **kl_image.tar.gz**
    containing the contents of the **disk.raw** file.
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new **Google Cloud Storage** (**GCS**) bucket using the **gsutil**
    command:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Make sure to replace **<BUCKET NAME>** with a globally unique bucket name (for
    a bucket that is yet to be created). Feel free to check the following link on
    some considerations when naming Cloud Storage buckets: [https://cloud.google.com/storage/docs/buckets](https://cloud.google.com/storage/docs/buckets).'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: If this is your first time using the **gsutil** command-line utility, it is
    a command-line tool provided by GCP for interacting with GCS. To grant permission
    for the **gsutil** command, we need to proceed by clicking on the **AUTHORIZE**
    button in the **Authorize Cloud Shell** pop-up window. This will allow the necessary
    permissions for the **gsutil** command to be executed successfully.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'Upload the **.tar.gz** file to an existing GCS bucket using the **gsutil**
    utility:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You may navigate to the **Cloud Storage Buckets** page using the user interface
    (Cloud console) and check if the **.tar.gz** file has been uploaded to the bucket
    successfully.
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the **gcloud compute images create** command to create an image from the
    **.tar.gz** file uploaded to the GCS bucket:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Feel free to replace **kali-linux-2023-000** with a different **IMAGE_NAME**
    value.
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: The **gcloud** CLI is a unified command-line utility provided by GCP that allows
    users to access and manage various Google Cloud resources from the terminal. With
    this command-line utility, we can perform tasks such as provisioning and managing
    VMs, configuring networking, deploying applications, managing storage resources,
    and accessing service APIs. The **gsutil** tool, on the other hand, facilitates
    various tasks, including uploading, downloading, copying, and managing data within
    Cloud Storage buckets. It is worth noting that **gcloud** and **gsutil** have
    different functionalities, and it is important not to mistake one for the other.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to verify that we were able to successfully create
    the image:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This should return the following output:'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here, we have a filtered list of custom images that have been created or imported
    into our account.
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Now that we have the image imported to Google Cloud, what’s next?* From this
    image, we should be able to launch a VM instance that will serve as the attacker
    instance in our penetration testing lab environment.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Manually setting up the attacker VM instance
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our custom image and the VPC network setup ready, setting up our Kali Linux
    attacker machine on GCP should be straightforward. However, before proceeding
    with the hands-on portion of this section, let’s quickly discuss how our attacker
    VM machine will be configured and deployed.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we will be deploying the Kali Linux attacker machine in **VPC
    02**, similar to what we have in *Figure 4**.28*:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_28.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
- en: Figure 4.28 – Setting up the attacker VM instance in the subnet of VPC 02
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Traffic from our attacker machine should be able to reach resources deployed
    in **VPC 01** since **VPC 02** is peered with **VPC 01** and the configured firewall
    rules allow traffic from each of these VPC networks to reach the resources deployed
    in these networks.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, we will set up the following in the attacker VM:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '**TigerVNC**—A high-performance cross-platform implementation of **Virtual
    Network Computing** (**VNC**) that enables users to remotely access and interact
    with graphical applications on remote machines'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**noVNC**—A web-based implementation of VNC that allows users to access and
    control a remote desktop environment through a web browser'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These will allow us to interact with the desktop environment of the attacker
    machine remotely from the browser (similar to what is shown in *Figure 4**.29*):'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_29.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
- en: Figure 4.29 – Accessing the target instance from a browser running in the attacker
    instance
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to distinguish between the two browsers shown in *Figure 4**.29*.
    The first browser, which will run on our local machine, displays the desktop environment
    of our Kali Linux VM instance. Within this environment, we will launch the Firefox
    browser to access the **OWASP Juice Shop** web application running in the target
    VM instance.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, we’ll divide this section into three parts, as follows:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 3 – Manually launching the* *attacker instance*'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 3 – Enabling browser access to our Kali* *Linux server*'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 3 of 3 – Validating* *our setup*'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these points in mind, let’s begin!
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 3 – Manually launching the attacker instance
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **VM instances** page by typing **compute engine** in the search
    box and selecting **Compute Engine** from the search results.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take note of the **Zone** value for **vm-target** (that is, **us-central1-c**)
    as we will use the same zone when creating the **kali-00** VM instance.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **CREATE INSTANCE** button. Specify the following configuration values
    when creating the new instance:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Name**: **kali-00**'
  id: totrans-514
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Region**: **us-central1 (Iowa)**'
  id: totrans-515
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zone**: **us-central1-c**'
  id: totrans-516
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Machine** **type**: **e2-medium**'
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boot disk**: Locate and click the **CHANGE** button. Navigate to the **CUSTOM
    IMAGES** tab and select the **kali-linux-2023-000** image from the list of drop-down
    options, similar to what is shown in *Figure 4.30*. For the **Size (GB)** field,
    specify a value of **50**. Click the **SELECT** button afterward:![](image/B19755_04_30.jpg)'
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 4.30 – Configuring the boot disk
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Advanced options** (expand) > **Networking** (expand) > **Network interfaces**:
    Change **default** to **vpc-02** under **Edit** **network interface**.'
  id: totrans-520
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scroll down to the bottom of the page and then click the **CREATE** button.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a minute or two for this step to complete. Feel free to grab a cup
    of coffee or tea while waiting!
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 of 3 – Enabling browser access to our Kali Linux server
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **VM instances** page where we can find a list of running instances.
    Click the link (**kali-00**) under the **Name** column to navigate to the **Instance
    details** page of our Kali Linux VM instance (**kali-00**).
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s access the serial console by clicking on the **CONNECT TO SERIAL CONSOLE**
    button. A pop-up window will open.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: The serial console allows users to conveniently access the serial port of a
    VM instance directly in GCP. If the serial console is unresponsive, feel free
    to reboot or restart the VM instance, as this can often resolve the issue and
    restore functionality for troubleshooting and diagnostics. You may also run the
    **clear** command in case you need to clear the contents of the terminal screen.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Once you see a blank page inside the pop-up window, click inside the blank page
    and then press the *Enter* key. You should see a **root@kali:~#** prompt where
    you can run **bash** commands as the **root** user.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s run the following block of code (after **root@kali:~#**) to set
    up access to our **kali** user:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, we first check if the **kali** user exists and create it if it doesn’t
    exist. It then sets up the SSH directory for the user, ensuring proper ownership
    and permissions.
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following commands (one line at a time) to write the value of the **$SSH_KEY**
    variable to the **authorized_keys** file located in the **.ssh** directory of
    the user’s home directory. After that, use the **cat** command to display the
    contents of the **authorized_keys** file to check if the changes have been applied
    correctly:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Make sure to replace **<SSH PUBLIC KEY VALUE>** with the output of the **cat
    kali-ssh.pub** command we ran in a previous step.
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: The value of the **$SSH_KEY** variable should follow a format resembling **ssh-rsa
    ...** **kali**.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s run the following commands (one line at a time) to change the ownership
    of the **authorized_keys** file to the **$NEW_USER** user, set the file permissions
    to **600** for restricted access, and then restart the SSH service:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Run the following commands to (1) add the **$NEW_USER** user to the **sudo**
    group, (2) grant the user passwordless sudo privileges by creating a configuration
    file in the **/etc/sudoers.d/** directory, and (3) set appropriate permissions
    for the configuration file:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, let’s switch to the **kali** user account and then navigate to the home
    folder:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let’s update the package lists and then install the default set of packages
    for Kali Linux using the following commands:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: 'This step may take 15-20 minutes to complete. Feel free to grab a cup of coffee
    or tea while waiting! In case you’re looking for a script that automates *most*
    of the work done in this section, you may check the following link: [https://bit.ly/kali-desktop-setup](https://bit.ly/kali-desktop-setup).
    In this chapter, we have set up the attacker VM instance manually so that we have
    a better understanding and appreciation of what’s happening behind the scenes
    while running the installation commands. In the next chapter, we will use an automated
    script to set up the attacker VM instance to speed things up a bit.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, download the **xfce4.sh** script, make it executable using the **chmod**
    command, and then execute it using the following commands:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: This step may take around 10 minutes to complete. Feel free to grab a cup of
    coffee or tea while waiting!
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s enable and start the **xrdp** service:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Let’s also set the password for the **kali** user:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Next, let’s install **TigerVNC** and **noVNC**:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: This step may take a minute or two to complete. Feel free to run the **clear**
    command to clear the screen (after the previous block of commands has finished
    running).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands to check if the VNC server and the noVNC proxy have
    been installed successfully:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Let’s run the following command to edit the **cron table** (**crontab**) for
    the **kali** user:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Here, we specified that we want to use **Vim** to edit the crontab configuration.
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: In case you are wondering what the **crontab** is used for, it is simply a time-based
    job scheduler often used by users when performing administrative and scheduled
    (often repetitive) tasks. Each user on the system can have their own crontab file
    containing a list of scheduled tasks. Users can create, edit, and manage their
    crontab files using the **crontab** command, which provides options to view, modify,
    or remove entries.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: Press *Shift* + *g* to jump to the last line of the file. Press *o* (lowercase
    letter “o”) to open a new line below the current line and enter **insert mode**.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following two entries to the end of the file:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: By including these crontab entries prefixed with **@reboot**, the VNC server
    and the noVNC proxy will automatically start upon each system reboot. This will
    (1) ensure persistent access to the graphical desktop environment and (2) enable
    remote connections via the web-based noVNC client. Here, you can see that we’ve
    configured **vncserver** and **novnc_proxy** to run after 60 seconds to wait for
    the system processes to be ready before these are run.
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that there are other alternative methods available for running
    the VNC server and the noVNC proxy during system boot. These include using **init**
    scripts, **systemd** units, or startup configuration files, depending on the specific
    operating system and configuration preferences.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: Press the *Esc* key to switch to **normal mode**. Type **:wq!**. Press *Enter*
    afterward. This will save the changes to the crontab configuration and then exit
    Vim as well. Feel free to use **crontab -l** to verify that the scheduled tasks
    and commands have been correctly configured in the cron job scheduler of the VM
    instance.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the serial console pop-up window.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **VM details** page, locate and click the **RESET** button to restart
    the instance. Wait for about 3-5 minutes for the instance to reboot.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: We can safely close the Cloud Shell editor for now, as we won’t lose any files
    or progress (closing the editor does not delete or remove any files). We can open
    it again later when we need to edit files or run terminal commands.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 of 3 – Validating our setup
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before automating our current setup, we first need to validate that the VM
    instance we manually set up and configured is working. To do so, proceed as follows:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: In the **Instance details** page of our Kali Linux VM instance (**kali-00**),
    scroll down and locate the **External IP address** value (under **Network interfaces**)
    and copy it to your clipboard.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a new browser tab and access the web-based noVNC client using the following
    URL:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Make sure to replace **<ATTACKER VM PUBLIC IP ADDRESS>** with the **External
    IP address** value copied to the clipboard in an earlier step.
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This should open a welcome screen with a **Connect** button, similar to what
    we have in *Figure 4**.31*:'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_31.jpg)'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.31 – noVNC welcome screen
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself unable to access the welcome screen, it is possible that
    your IP address might have changed already. Simply open the Cloud Shell editor
    and update the **terraform.tfvars** file. Once the **terraform.tfvars** file has
    been updated with the new IP address of your local machine, run the **terraform
    apply** command again to update the firewall rule to whitelist your new IP address.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Connect** button and then use the password **kali123** (or use the
    password you specified in an earlier step) to access the desktop environment,
    similar to what we have in *Figure 4**.32*:![](image/B19755_04_32.jpg)
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.32 – Accessing the Kali Linux desktop/GUI environment in the browser
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we’re able to access the desktop environment, we should be able to perform
    various tasks and access the wide range of tools and utilities available in Kali
    Linux (similar to how we would use it on our local machine).
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: In case you encounter a **Failed to connect to server** error, wait for about
    2-3 minutes before trying to access the desktop/GUI environment again.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Open the Firefox browser by clicking on the **Firefox** icon located at the
    upper-left corner of the desktop environment. Navigate to **http://<PRIVATE IP
    OF TARGET VM>** to open the OWASP Juice Shop vulnerable web application:![](image/B19755_04_33.jpg)
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.33 – Accessing the target instance from a browser running in the attacker
    instance
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Please remember to use the private IP address of the target VM instance instead
    of the public IP address, as our **VPC 01** network has been specifically configured
    to allow traffic only from resources within **VPC 02**.
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have verified that our setup is working correctly, we can close
    the browser tab used to access the Kali Linux desktop environment. We’ll resume
    the exploration of the OWASP Juice Shop application in the *Simulating penetration
    testing in the isolated network environment* section of this chapter.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that we can also access the desktop environment of
    the attacker instance from our local machine using an **SSH tunnel**. *Remember
    the private key file we generated earlier in this chapter?* Once we’ve downloaded
    this key file to our local machine, we simply need to (1) open a new terminal
    tab in our local machine, (2) navigate to the directory containing the private
    key file, and (3) run the following command to create an SSH tunnel between our
    local machine and the attacker VM instance:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Once the SSH tunnel has been set up, we can access the same desktop environment
    through **http://localhost:8081/vnc.html** (instead of using the public IP address
    of the attacker VM instance). If you are wondering what an SSH tunnel is, it is
    simply a secure encrypted connection used to access services and applications
    running inside a remote server. SSH tunnels leverage the encryption and authentication
    capabilities of SSH to secure data transmitted over the tunnel. With an SSH tunnel,
    we can securely access the desktop environment of the attack VM instance.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: We’ll leave this to you as an exercise. In addition to this, feel free to check
    [https://github.com/novnc/noVNC/wiki/Advanced-usage](https://github.com/novnc/noVNC/wiki/Advanced-usage)
    in case you want to further upgrade our setup.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Terraform to automatically set up the attacker VM instance
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section primarily focused on setting up the attacker VM instance
    manually. This was necessary because we will utilize this VM instance (**kali-00**)
    as a reference to create a **golden image**. By creating a golden image, we can
    capture the desired configuration and settings of the VM instance, making it easier
    to replicate and deploy similar instances with the same specifications in the
    future.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Note that another approach when automating the process of setting up VM instances
    involves the usage of IaC tools such as Ansible to set up *what’s inside the VM
    instance* (in addition to the usage of Terraform for setting up, configuring,
    and managing the cloud resources). When preparing VM instances, it is important
    that we have a good understanding of the distinct advantages and differences of
    each approach. Golden images are well suited to scenarios where a predefined and
    static environment is required since they can capture the desired configuration,
    settings, and software of a fully configured VM instance. By using golden images
    as templates, new instances can be quickly created with the exact same specifications—ensuring
    consistency along with reducing the time and effort required for manual configuration.
    On the other hand, using IaC tools such as Ansible (in addition to Terraform)
    allows for dynamic configuration changes, making them suitable for environments
    that require frequent updates and configuration changes.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: That said, the most suitable approach really depends on the specific needs of
    the environment and the level of customization required, along with the desired
    level of automation and flexibility in managing VM instances.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll divide this section into three parts, as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 3 – Creating a* *golden image*'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 3 – Using Terraform to prepare the attacker* *VM instance*'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 3 of 3 – Accessing the Kali Linux* *desktop environment*'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these points in mind, let’s proceed with automating the process of setting
    up our attacker VM instance!
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 3 – Creating a golden image
  id: totrans-615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **VM instances** page by typing **compute engine** in the search
    box and selecting **Compute Engine** from the search results. Here, we’ll find
    a list of VM instances in our GCP account.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the link (**kali-00**) under the **Name** column to navigate to the **Instance
    details** page of our attacker VM instance (**kali-00**).
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn off the instance by clicking **STOP**. Confirm the action by clicking **STOP**
    in the **Stop kali-00** popup that appears.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Take note that it may take around 3-5 minutes for the VM instance to stop. Please
    wait for the VM instance to stop before proceeding to the next set of steps.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Next, click **CREATE** **MACHINE IMAGE**.
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create a machine image** page, specify **kali-golden-image** for the
    **Name** value and then click the **CREATE** button.
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Machine images** page, wait for a few minutes for the status of the
    **kali-golden-image** image to be **Ready**.
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: You may click the **REFRESH** button to update the status and check if the image
    is ready for use.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **Machine image details** page. Scroll down to the bottom of
    the page and click the **REST** link (from **Equivalent REST or** **command line**).
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate and copy the **selfLink** value, as highlighted in *Figure 4**.34*:'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_34.jpg)'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.34 – Locating the selfLink value of the machine image
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Store this value in a text editor on your local machine. The **selfLink** value
    should have a format similar to the following:'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Keep in mind that you’ll get a different **<PROJECT ID>** value (so do not copy
    and paste exactly what’s in the screenshot).
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: Note that further upgrades can still be implemented on top of the image we prepared
    in the previous set of steps. In the meantime, this should do the trick for now.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: Navigate back to the **VM instances** page. Click the link (**kali-00**) under
    the **Name** column to navigate to the **Instance details** page of our attacker
    VM instance (**kali-00**).
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the Kali Linux instance (named **kali-00**) we created manually using
    the **DELETE** button in the **VM instances** page. Confirm the deletion by clicking
    **DELETE** in the **Delete** **kali-00** popup.
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Part 2 of 3 – Using Terraform to prepare the attacker VM instance
  id: totrans-638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Open the Cloud Shell terminal. In case you closed it while working on an earlier
    step, simply click the **Activate Cloud Shell** button on the upper right-hand
    corner of the page (as highlighted in *Figure 4**.35*):![](image/B19755_04_35.jpg)
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.35 – Activating Cloud Shell
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This should open a terminal where we can run command-line commands.
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Open Editor** button located at the upper right-hand corner of the
    Cloud Shell Terminal pane. If you can’t see the terminal, open the **Terminal**
    menu of the Cloud Shell editor and then select **New Terminal** from the list
    of options.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Cloud Shell terminal (after the **$** sign), navigate to the **~/pentest_lab/attacker_vm**
    directory by running the following commands (one line at a time):'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Run the following commands (one line at a time) to create the files we’ll need
    in our **attacker_vm** module:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Here, we are creating three empty files inside the **~/pentest_lab/attacker_vm**
    directory—(1) a **main.tf** file for defining the main configuration and resources,
    (2) a **variables.tf** file for declaring and managing variables used in the configuration,
    and (3) an **outputs.tf** file for specifying outputs or values that will be exposed
    after applying the configuration.
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, open the **attacker_vm/variables.tf** file in the editor and add the
    following blocks of code to define **subnet_02**, **kali_machine_image**, and
    **my_public_ssh_key** variables for our **attacker_vm** module:'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-650
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Make sure to replace **<INSERT IMAGE>** with the **selfLink** value of the machine
    image from the previous section.
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to save the **attacker_vm/variables.tf** file before proceeding
    to the next step.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **attacker_vm/main.tf** file in the editor and add the following blocks
    of code to define and configure the attacker VM instance:'
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Here, we’re using **google_compute_instance_from_machine_image** instead of
    **google_compute_instance** when defining the attacker VM resource since we want
    to create the VM instance from a pre-existing machine image. This allows us to
    quickly provision an instance with the desired configuration and software setup,
    such as using a Kali Linux image for the attacker VM. When typing these blocks
    of code, make sure that **{** is after **"kali_vm"** (same line instead of next
    line).
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to save the **attacker_vm/main.tf** file before proceeding to
    the next step.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **attacker_vm/outputs.tf** file in the editor and add the following
    lines of code to define the following outputs: (1) **attacker_vm_public_ip**—public
    IP address value of the attacker VM instance, (2) **attacker_vm_access**—URL used
    to access the desktop environment from the browser:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Make sure to save the **attacker_vm/outputs.tf** file before proceeding to the
    next step.
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate back to the **~/pentest_lab** project folder by running the following
    command:'
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Let’s use the **terraform init** command to reinitialize the Terraform working
    directory (since there are changes to the **attacker_vm** module code):'
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-665
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-667
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This should give us **Missing required argument — The argument “subnet_02” is
    required, but no definition was found** and **Missing required argument — The
    argument “my_public_ssh_key ” is required, but no definition was found** error
    messages since we have not provided any values for the **subnet_02** and **my_public_ssh_key**
    arguments while declaring the **attacker_vm** module.
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering why this issue has suddenly occurred, it’s important to
    recall that we defined **subnet_02** and **my_public_ssh_key** variables in the
    **attacker_vm/variables.tf** file in an earlier step.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the issue encountered in the previous step, we need to ensure that
    we provide a value for the **subnet_02** and **my_public_ssh_key** arguments when
    declaring the **attacker_vm** module.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using *Figure 4**.36* as a reference, we will resolve the issue by passing
    the **subnet_02** output value from the **secure_network** module to the **subnet_02**
    input variable of the **attacker_vm** module:'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_36.jpg)'
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.36 – Providing a value for the subnet_02 and my_public_ssh_key arguments
    when declaring the attacker_vm module
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the same time, we will pass the **my_public_ssh_key** variable value to
    the **my_public_ssh_key** input variable of the **attacker_vm** module. Now that
    we have a better idea of how we’ll solve the issue, let’s locate the following
    block of code in our **main.tf** file (**~/pentest_lab/main.tf**):'
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Let’s replace this with the following block of code:'
  id: totrans-677
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Here, we are passing the output value from the **secure_network** module (**module.secure_network.subnet_02**)
    to the **subnet_02** input variable of the **attacker_vm** module. In addition
    to this, we are passing the **my_public_ssh_key** variable value to the **my_public_ssh_key**
    input variable of the **attacker_vm** module.
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-681
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This time, we should not encounter a **Missing required argument** error message.
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Note
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a minute or two for this step to complete. Feel free to grab a cup
    of coffee or tea while waiting!
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to display the public IP address of the attacker VM instance along
    with the Kali Linux desktop environment access URL as output, we will reference
    and utilize the outputs from the **attacker_vm** module (as well as the outputs
    from the **target_vm** module) in the root module **outputs.tf** file (similar
    to what we have in *Figure 4**.37*):![](image/B19755_04_37.jpg)
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.37 – Utilizing the outputs from the attacker_vm and target_vm modules
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using *Figure 4**.37* as a reference, we will update the **outputs.tf** file
    with the following block of code:'
  id: totrans-689
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Here, we’re defining the following outputs: (1) **target_vm_username** and
    **target_vm_password**—username and password used to access the target VM instance
    using the serial console, (2) **target_vm_public_ip** and **target_vm_private_ip**—public
    and private IP address values of the target VM instance, (3) **attacker_vm_public_ip**—public
    IP address value of the attacker VM instance, (4) **attacker_vm_access**—URL used
    to access the desktop environment from the browser.'
  id: totrans-691
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: Make sure not to duplicate the output blocks defined in the **outputs.tf** file.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-695
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-697
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Wait for a minute or two for this step to complete. This should yield the following
    output:'
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-699
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Store and save the **attacker_vm_public_ip** output value in a text editor as
    we will use this in the succeeding steps in this chapter.
  id: totrans-700
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Part 3 of 3 – Accessing the Kali Linux desktop environment
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the next steps:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should have the following set up already:![](image/B19755_04_38.jpg)
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.38 – Current setup deployed and configured in GCP
  id: totrans-704
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we have the IP address of our local machine whitelisted to access the
    attacker VM instance in **VPC 02** via ports **22** and **8081**.
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: While we can further upgrade this setup to include additional security mechanisms
    (such as establishing a VPN connection), this should do the trick for now.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s open a new browser tab and access the desktop environment using
    the following URL:'
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Make sure to replace **<ATTACKER VM PUBLIC IP ADDRESS>** with the **attacker_vm_public_ip**
    output value after running the **terraform apply** command in an earlier step.
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This should open a welcome screen with a **Connect** button, similar to what
    we have in *Figure 4**.39*:'
  id: totrans-711
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_39.jpg)'
  id: totrans-712
  prefs: []
  type: TYPE_IMG
- en: Figure 4.39 – noVNC welcome screen
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself unable to access the welcome screen, it is possible that
    your IP address might have changed already. Simply update the **terraform.tfvars**
    file, then run the **terraform apply** command again to update the firewall rule
    to whitelist your new IP address.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Connect** button and then use the password **kali123** (or use the
    password you specified in an earlier step) to access the desktop environment,
    similar to what we have in *Figure 4**.40*:![](image/B19755_04_32.jpg)
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.40 – Accessing the Kali Linux desktop/GUI environment in the browser
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we’re able to access the desktop environment, we should be able to perform
    various tasks and access the wide range of tools and utilities available in Kali
    Linux (similar to how we would use it on our local machine).
  id: totrans-718
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you may use the **Connectivity Tests** diagnostic tool to validate
    network connectivity. For more information, feel free to check the following link:
    [https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/how-to/running-connectivity-tests](https://cloud.google.com/network-intelligence-center/docs/connectivity-tests/how-to/running-connectivity-tests).'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: Simulating penetration testing in an isolated network environment
  id: totrans-721
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given that our lab environment in GCP has been set up, we can now proceed with
    having a penetration testing simulation to verify that everything has been configured
    correctly. Of course, we will work with a simplified penetration testing process,
    as our primary goal is to assess whether the penetration testing lab environment
    has been set up and configured correctly:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_04_41.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
- en: Figure 4.41 – Penetration testing simulation
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: Our simulation will start with a port scan to check the open ports of the target
    VM instance (**vm-target**). After identifying that port **80** is open, we will
    use a web browser to navigate through the pages and explore the functionality
    of the vulnerable web application (running inside a container) accessible on the
    said port. We’ll end the simulation right after we have used an SQL Injection
    attack to gain administrator access and successfully signed in using an administrator’s
    account.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: It is unethical and illegal to attack cloud resources owned by another user
    or company. Before proceeding, make sure to read the *Examining considerations
    when building penetration testing lab environments in the cloud* section of *[Chapter
    1](B19755_01.xhtml)*, *Getting Started with Penetration Testing Labs in the Cloud*,
    since we will be simulating the attack process to validate if misconfigurations
    and vulnerabilities present in applications and services running in the target
    VM instance are exploitable.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let’s start the penetration testing simulation. Proceed as follows:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: Continuing where we left off in the previous section, let’s access the Terminal
    application by selecting the **Terminal** icon located in the upper-left corner
    of the Kali Linux desktop interface.
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the terminal window, run the following command (after the **$** sign) to
    store the private IP address value of the target VM instance in the **TARGET_IP**
    variable:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Make sure to replace **<PRIVATE IP ADDRESS OF TARGET VM>** with the private
    IP address of the target VM instance (**vm-target**). Using a private IP ensures
    that the request stays within the intended network environment. In addition to
    this, we won’t be able to access the target VM instance using its public IP address.
    That’s because the network environment is not configured to allow outside traffic
    to reach **VPC 01** where the target VM instance is launched, even if the network
    traffic came from another cloud resource running inside **VPC 01** and **VPC 02**.
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the CIDR range of the subnet where the target VM instance is launched
    is **10.1.0.0/20**, the target IP address of the VM instance should fall within
    the range of **10.1.0.0** to **10.1.15.255** (excluding the reserved IP addresses).
    For more information, feel free to check the following link: [https://cloud.google.com/vpc/docs/subnets](https://cloud.google.com/vpc/docs/subnets).'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use **nmap** to scan the top **1000** ports of the target VM instance:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'This should provide information about the open ports and the corresponding
    services running on the target VM instance. It allows us to identify which ports
    are accessible and potentially vulnerable to attacks, such as SSH (port **22**)
    and HTTP (port **80**), similar to what we have in *Figure 4**.42*:'
  id: totrans-737
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_42.jpg)'
  id: totrans-738
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.42 – Results of the nmap scan
  id: totrans-739
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Depending on the results of the **nmap** scan, further steps can be performed
    to evaluate the open ports and services running on the target VM instance. However,
    for now, we will skip these steps and proceed with the other aspects of the penetration
    testing process.
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering what **nmap** is, it is a popular open source network scanning
    tool designed to discover hosts and services on a computer network by sending
    packets and analyzing the responses. With **nmap**, we can perform tasks such
    as **host discovery** (to identify active hosts within a network), **port scanning**
    (for identifying potential entry points or services running on specific ports),
    **OS detection** (to gather information about the operating system running on
    a target host), and **service enumeration** (to gather details about specific
    services running on open ports). In addition to these, **nmap** provides other
    advanced features and capabilities such as **script scanning** (to automate specific
    tasks), **version detection** (to identify specific software versions running
    on target systems), **stealth scanning** (to evade detection), and **timing and
    performance tuning** (to optimize scan speed and accuracy). *Powerful, right?*
    When using **nmap** in conjunction with other penetration testing tools, it is
    important to exercise extreme caution as it can generate significant network traffic
    and potentially trigger security alerts or disrupt network operations if not used
    responsibly. It is advisable to follow ethical hacking practices, obtain necessary
    permissions, and employ proper filtering mechanisms to minimize any unintended
    consequences while performing comprehensive security assessments.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: You can now close the terminal window.
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s check what’s running on port **80** of the target VM instance. Launch
    the **Firefox** browser by selecting the **Firefox** icon located in the top-left
    corner of the desktop interface. Navigate to the following URL:'
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-745
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'This should open the OWASP Juice Shop vulnerable-by-design web application,
    similar to what we have in *Figure 4**.43*:'
  id: totrans-746
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_04_43.jpg)'
  id: totrans-747
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.43 – Accessing the target instance from a browser running in the attacker
    instance
  id: totrans-748
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we have the OWASP Juice Shop—a vulnerable-by-design application with various
    challenges and vulnerabilities meant to help security practitioners and engineers
    understand and learn about common security flaws.
  id: totrans-749
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: Please remember to use the private IP address of the target VM instance (instead
    of the public IP address), as our **VPC 01** network has been specifically configured
    to allow traffic only from resources within **VPC 02**.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: For the next few minutes, explore the functionality and content of the OWASP
    Juice Shop application by navigating through the different pages and features.
    Feel free to interact with the forms, buttons, and links within the application
    to understand their behavior and purpose.
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s navigate to the **Login** page by opening the **Account** menu located
    in the upper-left corner of the page and then clicking **Login**. This will redirect
    us to the **Login** page, similar to what we have in *Figure 4**.44*:![](image/B19755_04_44.jpg)
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.44 – OWASP Juice Shop Login page
  id: totrans-754
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we have a login form allowing us to specify an email address value and
    a password value. By analyzing the login process and attempting various techniques,
    we should be able to identify and exploit any vulnerabilities present in the login
    functionality.
  id: totrans-755
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s try performing an SQL Injection attack! Type **' or 1=1--** in the **Email**
    field. After that, type **123** (or any combination of characters) in the **Password**
    field. Click the **Log in** button afterward. This should give us a success notification
    similar to what we have in *Figure 4**.45*:![](image/B19755_04_45.jpg)
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 4.45 – Successfully solving a challenge using an SQL Injection attack
  id: totrans-757
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Looks like we were able to successfully sign in with the administrator’s user
    account!* *What just happened?* Here, our SQL Injection attack allowed us to authenticate
    using the first record in the table containing the registered application users
    (or accounts). Luckily for us, this record happened to be an administrator account
    (**admin@juice-sh.op**) as well!'
  id: totrans-758
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you are wondering what an **SQL Injection attack** is, it is a technique
    where an attacker exploits vulnerabilities in an application’s input fields to
    inject malicious SQL statements. In this specific case, by entering **'' or 1=1--**
    in the **Email** field, the updated SQL query executed by the application’s backend
    might look like this:'
  id: totrans-759
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-760
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The injected portion causes the **WHERE** condition to always evaluate to **true**—bypassing
    the need for a valid email address and password. This allowed us to log in without
    having to provide legitimate credentials. **--** at the end is used to comment
    out the remainder of the original query to ensure that the injected code does
    not cause any syntax errors.
  id: totrans-761
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: We have intentionally skipped some steps as we’ve used a simplified penetration
    testing process validating our lab configuration and setup. That said, real-world
    penetration testing involves a more comprehensive and structured approach that
    includes various techniques, tools, and methodologies to thoroughly assess the
    security of an application or a system.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: While our relatively simple SQL Injection example demonstrates a common attack
    technique, it’s important to note that various other attacks and techniques can
    be performed in our penetration testing lab environment. Feel free to explore
    and experiment further with the OWASP Juice Shop application before cleaning up
    the lab environment we prepared in this chapter.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  id: totrans-765
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cleaning up the cloud resources we created or deployed is a crucial step when
    working with vulnerable cloud applications and environments. If we don’t clean
    up and delete the resources we created right away, we might end up paying for
    unused cloud resources. In addition to this, these cloud resources may end up
    being attacked by malicious users as well. At a *minimum*, we will be paying for
    the time the following resources are running:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: 1 x **e2-medium** VM instance for the attacker machine
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x **f1-micro** VM instance for the target machine
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please be aware that there are other costs we have to take into account as well—including
    data transfer fees, storage costs for persistent data used by instances, potential
    charges for other services utilized in the account, and any applicable taxes or
    fees associated with using resources.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the overall cost when running these resources depends on several parameters,
    it is best to refer to the pricing documentation page provided by the cloud platform,
    found here: [https://cloud.google.com/compute/vm-instance-pricing](https://cloud.google.com/compute/vm-instance-pricing).
    You can also utilize the **Google Cloud Pricing Calculator** to estimate the cost
    of deploying resources on GCP. You can access the Google Cloud Pricing Calculator
    using the following link: [https://cloud.google.com/products/calculator](https://cloud.google.com/products/calculator).'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let’s proceed with deleting the resources we created in this chapter,
    as follows:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: Close the browser tab we used to access the Kali Linux desktop environment.
  id: totrans-773
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Cloud Shell terminal, navigate to the **~/pentest_lab** directory and
    then use **terraform destroy** to clean up the resources we created earlier:'
  id: totrans-774
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-775
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Feel free to run the **terraform destroy** command again in case there are some
    resources that fail to delete. Alternatively, you may delete resources manually
    using the user interface if all else fails.
  id: totrans-776
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that the resources have been destroyed successfully using the following
    command:'
  id: totrans-777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-778
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This should return an empty response since all resources should have been deleted
    successfully.
  id: totrans-779
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to perform a full audit of your account using the Google Cloud console.
    This will help ensure that all resources have been properly deleted, minimize
    the risk of unintended costs, and address any potential security concerns.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: That’s pretty much it! At this point, we should have a good idea of how to prepare
    penetration testing lab environments on GCP.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-783
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were able to successfully build a penetration testing lab
    in GCP. We started by preparing the prerequisites, along with defining the project
    structure of the Terraform code for automating the lab environment. We then set
    up an isolated network for securing the lab environment resources from external
    attacks. Inside this isolated network, we launched a target VM instance running
    the OWASP Juice Shop application (inside a container). After that, we imported
    the Kali Linux Generic Cloud Image into our Google Cloud account. Using the imported
    image, we proceeded with the setup of the attacker VM instance inside the network
    environment. After completing the lab environment, we performed a simplified penetration
    testing simulation to verify that our lab had been (mis)configured correctly.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, our focus will shift toward setting up a penetration
    testing lab in Microsoft Azure. We will set up a lab environment where we can
    practice container breakout techniques for gaining authorized access to the host
    system (where the container is running). Our lab setup will also highlight how
    managed identities can be misused to access other resources in the cloud environment.
    If you are excited to learn how to build penetration testing labs in Azure, then
    the next chapter is for you!
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-786
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For additional information on the topics covered in this chapter, you may find
    the following resources helpful:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '*Google Cloud – Guide to Cloud Billing Resource Organization & Access* *Management*
    ([https://cloud.google.com/billing/docs/onboarding-checklist](https://cloud.google.com/billing/docs/onboarding-checklist))'
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Integrate Azure services with virtual networks for network* *isolation* ([https://learn.microsoft.com/en-us/azure/virtual-network/vnet-integration-for-azure-services](https://learn.microsoft.com/en-us/azure/virtual-network/vnet-integration-for-azure-services))'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Google Cloud – Best practices and reference architectures for VPC* *design*
    ([https://cloud.google.com/architecture/best-practices-vpc-design](https://cloud.google.com/architecture/best-practices-vpc-design))'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kali Linux –* *Cloud* ([https://www.kali.org/docs/cloud/](https://www.kali.org/docs/cloud/))'
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kali Linux – What is Kali* *Linux?* ([https://www.kali.org/docs/introduction/what-is-kali-linux/](https://www.kali.org/docs/introduction/what-is-kali-linux/))'
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Google Cloud – Manually import boot* *disks* ([https://cloud.google.com/compute/docs/import/import-existing-image](https://cloud.google.com/compute/docs/import/import-existing-image))'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*OWASP Juice Shop: Probably the most modern and sophisticated insecure web*
    *application* ([https://github.com/juice-shop/juice-shop](https://github.com/juice-shop/juice-shop))'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
