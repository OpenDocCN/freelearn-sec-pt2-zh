- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up Isolated Penetration Testing Lab Environments on Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we successfully built and automated a relatively simple
    penetration testing lab inside an isolated network environment in **Google Cloud
    Platform** (**GCP**). We primarily focused on one of the most important aspects
    when building lab environments in the cloud – protecting the vulnerable lab resources
    from the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take things a step further and build a more intricate
    lab environment using various services in **Microsoft Azure**. Our lab setup in
    this chapter will help us practice **container breakout** techniques, which involve
    escaping from a Docker container environment to gain unauthorized access to the
    host system. With containers being a fundamental component in modern deployments,
    understanding their security vulnerabilities is critical for ensuring the security
    of cloud-based applications. In addition to this, we will look at how **managed
    identities** in Azure can be abused to gain unauthorized access to other cloud
    resources. While managed identities are effective for preventing credential exposure,
    they introduce a new problem as these set up other attack paths that can be abused
    by an attacker (or someone assuming the role of an attacker).
  prefs: []
  type: TYPE_NORMAL
- en: After setting up the lab environment, we will validate if our vulnerable-by-design
    lab environment has been (mis)configured correctly by performing a simplified
    penetration testing simulation using various tools, such as **Nmap** and **Metasploit**.
    In our simulation, we will go through a sequence of steps showing how multiple
    vulnerabilities and misconfigurations can be exploited to gain unauthorized access
    to cloud resources containing sensitive credentials and information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the necessary components and prerequisites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the project’s structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the isolated network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the target resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually setting up the attacker VM instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Terraform to automatically set up the attacker VM instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating penetration testing in the isolated network environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have an exciting chapter ahead of us as we will learn various techniques,
    from building penetration testing lab environments in Azure to using security
    tools for validating misconfigurations and vulnerabilities in our lab setup.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start, we must have the following ready:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Microsoft** **Azure** account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any text editor (such as Notepad++, Visual Studio Code, or Sublime Text) where
    we can temporarily store specific values (for example, our local machine’s IP
    address) used in the hands-on solutions in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may proceed with the next steps once these are ready.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Similar to AWS and GCP, Azure is a mature cloud platform that offers a wide
    range of services that allow us to build penetration testing environments in the
    cloud. We’ll find various options for configuring virtual machines, databases,
    and other cloud resources for building vulnerable-by-design lab environments in
    Azure. The costs associated with running these resources can vary, so make sure
    you read the available documentation, along with the FAQs, to have a solid understanding
    of what is free (and what is not free) when creating resources. In addition to
    this, make sure you *don’t* use any existing account with production (or staging)
    environment resources for the hands-on exercises and solutions in this book. It
    is strongly recommended that you create a *new* Azure account specifically for
    launching intentionally vulnerable resources. This will ensure that your production
    (or staging) environment resources remain separate and secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code and other files used for each chapter are available in this
    book’s GitHub repository: [https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud).'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the necessary components and prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be setting up a few key components and prerequisites
    before we proceed with preparing the Terraform code in the next section. We will
    start by manually creating a resource group for storing some of the resources
    later in this chapter. In addition to this, we will generate the SSH keys that
    will be used to access the attacker’s **virtual machine** (**VM**) instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed with the hands-on portion of this section, let’s familiarize
    ourselves first with a few key services and terminologies relevant to this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource group**: A logical container for grouping multiple resources together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Golden image**: A custom VM image containing all applications, along with
    the configuration settings designed to serve as a standardized template for provisioning
    multiple instances with identical software and configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud Shell**: A browser-based interactive command-line environment that
    enables users to access and manage resources directly through a web browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSH keys**: These are pairs of cryptographic keys (that is, a **private key**
    and its corresponding **public key**) that are used for secure authentication
    and communication between systems over a network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That said, this section is divided into the following subparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 2 – Manually creating a* *resource group*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 2 – Generating SSH keys to access the attacker* *VM instance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these in mind, let’s proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 2 – Manually creating a resource group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by creating a resource group:'
  prefs: []
  type: TYPE_NORMAL
- en: In the search bar, type **resource groups** and then select **Resource groups**
    from the search results (under **Services**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **+ Create** button located on the toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Create a resource group** form (similar to what is shown in *Figure
    5**.1*), specify **image-resource-group** for the **Resource group** input field
    value:![](image/B19755_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.1 – Create a resource group
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will use this resource group later when we create an image for our VM instance.
    If you are wondering how many resource groups we will have in this chapter, we
    will have exactly three resource groups – the manually created resource group
    (**image-resource-group**), along with two other resource groups we will automatically
    create using Terraform (**resource-group-01** and **resource-group-02**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that **Region** is set to **(US) East US** as we will use the same
    region when creating the other resources in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Review +** **create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click **Create** to finish creating the new resource group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The resource group we just created will be used to contain the golden image
    we will prepare later in this chapter. *Why do we need to create a separate resource
    group for the golden image?* As we will see later, having the golden image in
    a separate resource group will allow us to use the **terraform apply** and **terraform
    destroy** commands without issues and blockers. If the golden image is inside
    one of the automatically created resource groups, we will be forced to delete
    the golden image for the **terraform destroy** command to succeed and complete
    while we’re cleaning up and deleting the resources. We won’t be able to delete
    the automatically created resource group using **terraform destroy** if it contains
    additional resources not managed by Terraform (unless we also delete those resources
    manually before retrying the **terraform** **destroy** command).
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 of 2 – Generating SSH keys to access the attacker VM instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s proceed with generating the SSH keys for accessing the attacker
    VM instance later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Cloud Shell** editor by clicking the button highlighted in *Figure
    5**.2*:![](image/B19755_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.2 – Opening Cloud Shell
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When prompted to select **Bash** or **PowerShell**, choose **Bash**. This will
    open a terminal where we can run bash commands (after the **$** sign). Similar
    to Google Cloud Shell, which we used in the previous chapter, Azure Cloud Shell
    provides a convenient way to manage resources using a ready-to-use terminal and
    editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Azure Cloud Shell requires a file share to persist files, we need to
    create a storage account in case we see the **You have no storage mounted** message.
    Refer to the following link on how to persist files and create a new storage account
    for Azure Cloud Shell: [https://learn.microsoft.com/en-us/azure/cloud-shell/persisting-shell-storage](https://learn.microsoft.com/en-us/azure/cloud-shell/persisting-shell-storage).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terminal (right after the **$** sign), run the following commands to
    create a new directory (named **kali_keys**) and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will store the generated keys inside this directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate a new SSH key pair and save the generated key files in the **kali_keys**
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When asked for a passphrase, just press *Enter*. This will generate two files
    — **kali-ssh** (the private key) and **kali-ssh.pub** (the public key).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In SSH key-based authentication, the private key is kept secret, often stored
    on the client side (for example, in our local machine), while the corresponding
    public key is used for authentication, typically stored on the server we are trying
    to access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the public key value using the **cat** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Store this value in a text editor in your local machine – we will use this later
    when configuring the Kali Linux VM instance in the succeeding sections of this
    chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Upload**/**Download files** button, as highlighted in *Figure 5**.3*:![](image/B19755_05_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.3 – Downloading the private key we generated
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the **Download** option from the list of options available. When you
    see the **Download a file** popup window, type **/kali_keys/kali-ssh** in the
    input field highlighted in *Figure 5**.3* and then click **Download**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Given that the key (**kali-ssh**) has the same name as the key we downloaded
    in the previous chapter, make sure you don’t mix up the keys (in your local machine)
    to avoid confusion. You may rename the downloaded key from *[Chapter 4](B19755_04.xhtml)*
    to **kali-ssh-gcp** instead before proceeding to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Click here to download your file** link to proceed with the actual
    download operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the prerequisites ready, we can now proceed with setting up the project’s
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the project’s structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will use a Terraform project structure similar to what
    we had in *[Chapter 4](B19755_04.xhtml)*, *Setting Up Isolated Penetration Testing
    Lab Environments on GCP*. While there are similarities between the lab environments
    in the previous chapter and this one, the lab environment in this chapter will
    have a few additional components to give it a bit more complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – What our lab setup looks like (without the network environment)
  prefs: []
  type: TYPE_NORMAL
- en: One of the major components of the lab environment in this chapter will be a
    secure secrets store (Azure Key Vault) where we will store one of the flags. We
    will also make it possible for lab users (assuming the role of an attacker) to
    break out of a running container and gain unauthorized access to the host system
    inside the VM instance. Once access to the host system has been obtained, a system-assigned
    managed identity will allow access to the Azure Key Vault secrets from within
    the VM instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Do not worry if the terms used in this section seem unfamiliar as we will discuss
    and define these concepts, terminologies, and services in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we will focus on what these lab environments have in common – a **network
    peering** setup bridging an attacker network and a target network (similar to
    what is shown in *Figure 5**.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Network peering setup connecting two networks
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that we will set up a more complex lab environment in this chapter, we
    must plan where we will configure the additional resources without having to drastically
    change how the resources are grouped. That said, our Terraform project structure
    will have the following modules in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**secure_network**: The module that will contain the code for creating and
    configuring the network resources for this lab environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**target_vm**: The module for creating and configuring the target VM instance,
    along with other target resources (including the Azure Key Vault resource where
    we will store a secret flag)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**attacker_vm**: The module containing the code for setting up the attacker
    VM instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this approach is not perfect, this should do the trick for now as our
    primary goal in this chapter is to introduce new vulnerable and misconfigured
    components that may be present in modern cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let’s proceed with setting up the initial project files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing where we left off in the previous section, let’s open the Cloud Shell
    editor by clicking the button highlighted in *Figure 5**.6*:![](image/B19755_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.6 – Opening the Cloud Shell editor
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Feel free to maximize the Cloud Shell window by clicking the maximize icon located
    at the top-left corner of the editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the Terminal (right after the **$** sign), run the following commands to
    create the **pentest_lab** project directory (and navigate to the new directory
    as well):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the **pentest_lab** directory, let’s also create the **secure_network**,
    **target_vm**, and **attacker_vm** directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll store the corresponding module files in these directories later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While it is a common practice to have a separate directory named **modules**
    for storing individual module directories such as **secure_network**, **target_vm**,
    and **attacker_vm**, our current project and folder structure should suffice for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the files we’ll have in the root folder of our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that at this point, these files are still empty. We will populate them
    with the necessary configurations as we go along.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to click the refresh button in the editor if the new files and directories
    do not appear automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **provider.tf** file in the editor and add the following block of
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s open **versions.tf** in the editor. Let’s add the following block
    of code to specify the required version constraints for the providers used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open **variables.tf** in the editor and add the following blocks of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open **terraform.tfvars** in the editor and add the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you replace **<INSERT IP ADDRESS>** with the IP address of your local
    machine and **<INSERT PUBLIC SSH KEY>** with the string value of the public SSH
    key (which we printed using the **cat** command previously). Since we have not
    created the golden image of the attacker VM instance yet, leave the **kali_image_id**
    placeholder value (that is, **<INSERT KALI IMAGE ID>**) as is for now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open **main.tf** in the editor and add the following blocks of code to define
    the modules that will be used for this project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are adding module blocks to **main.tf** to include the **secure_network**,
    **attacker_vm**, and **target_vm** modules from their respective source directories.
    Make sure you save the **main.tf** file before proceeding to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s create an empty **secure_network/main.tf** file using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the **secure_network/main.tf** file in the editor and add the following
    blocks of code for the resource groups that will be used for the lab environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our Cloud Shell terminal (after the **$** sign), run the following command
    to initialize the Terraform working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The command should complete without any errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the **terraform apply** command runs without any errors, we are ready to
    proceed to the next section. Otherwise, feel free to check and fix any existing
    code issues in your Terraform configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that the resources have been created successfully using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should return the two resource groups that we created in the previous step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With our project structure and skeleton ready, we can now proceed with setting
    up the isolated **virtual network** (**VNet**) environment.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the isolated network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will focus on setting up the isolated network environment
    that will contain the resources for our penetration testing lab. We will establish
    a secure network environment setup in Microsoft Azure that restricts traffic from
    external hosts from reaching the cloud resources deployed inside the network environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Isolated network environment
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the resources deployed inside should be able to communicate with
    each other even if they are deployed in different VNets. We will accomplish this
    by setting up a **VNet peering connection** to bridge two virtual networks, similar
    to how a VPC peering connection bridges two Google Cloud VPCs, as we saw in the
    previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed with preparing the isolated network environment, let’s quickly
    go through some of the Azure concepts, features, and terminologies relevant to
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subscription**: A logical unit that serves as a billing and management boundary
    that enables the organization and governance of Azure resources, access controls,
    and usage reporting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tenant**: This represents an organization or identity in Azure. Each Azure
    subscription is associated with a specific tenant, and multiple subscriptions
    can be associated with the same tenant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VNet**: A network that provides a private network environment for resources
    to communicate securely within Azure (similar to the VPC networks in GCP and AWS).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VNet peering**: Connects VNets, enabling traffic between these networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource group**: A logical container that helps organize and manage related
    resources within an Azure subscription.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network interface card** (**NIC**): A networking component in Azure that
    enables communication with other resources by acting as the interface between
    a VM and the underlying network infrastructure. NICs provide properties and configurations
    related to IP addresses, network security groups, and network routing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application security group** (**ASG**): A construct in Azure that allows
    you to group and manage network security policies based on application requirements.
    ASGs provide a way to define network security rules and associate them with specific
    applications or services within a virtual network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network security group** (**NSG**): A networking security construct that
    acts as a virtual firewall for controlling inbound and outbound traffic to resources.
    NSGs allow for the creation of rules that define network security policies, including
    **access control lists** (**ACLs**), filtering, and port forwarding. By associating
    NSGs with subnets or network interfaces, administrators and engineers can enforce
    fine-grained network traffic controls and implement security measures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: NSGs focus on network-level security controls, allowing engineers to define
    rules based on IP addresses, ports, and protocols. On the other hand, ASGs provide
    a higher level of abstraction by allowing engineers to group resources based on
    their application context to enable more application-centric security policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a better idea of the Microsoft Azure concepts and terminologies
    we will work with in this chapter, let’s proceed with preparing the network environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing where we left off in the previous section, let’s locate the following
    block of code in our **main.tf** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s replace it with the following block of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create an empty **secure_network/variables.tf** file using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open the **secure_network/variables.tf** file in the editor and add the
    following block of code to define the **my_ip** variable for our **secure_network**
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you save the **secure_network/variables.tf** file before proceeding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the **secure_network/main.tf** file, we will define and configure the first
    VNet, along with a single subnet inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s define the corresponding ASG and NSG as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s define and configure a second VNet, along with a single subnet
    inside it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s define the ASG and NSG for the VNet where the attacker VM instance
    will be deployed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s define the peering connections using the following blocks of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this VNet peering configuration, traffic from the resources deployed in
    the subnet of the first VNet, **vnet-01**, will be able to reach the resources
    deployed in the subnet of the second VNet, **vnet-02** (and vice versa), so long
    as the necessary firewall rules have been defined and configured correctly as
    well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For our local machine to access the resources inside the second VNet via port
    **8081**, we will need to define a network security rule as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition to this, let’s create a network security rule to allow our local
    machine to access the resources in the second VNet via port **22**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you save the **secure_network/main.tf** file before proceeding to
    the next set of steps. You can find a copy of the **secure_network/main.tf** file
    here: [https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/blob/main/ch05/pentest_lab/secure_network/main.tf](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/blob/main/ch05/pentest_lab/secure_network/main.tf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create an empty **secure_network/outputs.tf** file using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the **secure_network/outputs.tf** file in the editor and add the following
    lines of code to define the following outputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following outputs right after the last defined output block in **secure_network/outputs.tf**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you save the **secure_network/outputs.tf** file before proceeding
    to the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Navigate back to the **~/pentest_lab** project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s use **terraform apply** to implement the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Running this command may yield a few deprecation warnings. This should be okay,
    so long as we can successfully run the command without errors.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the network environment is ready! In the next section, we’ll
    proceed with setting up the target resources.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the target resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our isolated network environment ready, we can now proceed with setting
    up the target VM instance, along with a few additional resources such as the Azure
    Key Vault (containing an additional flag secret) and a vulnerable container running
    inside the VM instance with elevated privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – The target resources we will set up in this section
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will set up the target VM instance inside VNet 01, similar
    to how we set up the target VM instance in the previous chapter. One major difference
    we will have in this chapter is that we will run the **Metasploitable 2** container
    instead of the **OWASP Juice Shop** container. Like OWASP Juice Shop, Metasploitable
    2 intentionally includes a variety of insecure configurations and vulnerable software
    packages. While Metasploitable 2 was primarily designed and distributed as a vulnerable
    VM, it is possible to configure and run it as a container. We will run this vulnerable
    container with the **--privileged** flag, which will allow us to break out of
    the container during the penetration testing simulation toward the end of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The **--privileged** flag in Docker grants a container elevated privileges within
    the host system. It introduces a potential security risk that allows attackers
    to break out of a container and gain root-level access to the host (from inside
    the container). While we won’t dive deep into the details of how container breakouts
    work, we will provide a quick demonstration of how this is performed during the
    simulation session toward the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, we will configure the target VM instance so that it has
    a system-assigned managed identity. This will enable us to access the Azure Key
    Vault secrets from within the instance without having to (explicitly) specify
    credentials when using the Azure CLI. If you are wondering what **Azure Key Vault**
    is, it is a cloud-based service in Microsoft Azure that allows users, developers,
    and engineers to securely store and manage cryptographic keys, secrets, and certificates
    in a centralized repository. Understanding how Azure Key Vault works is essential
    from a penetration testing standpoint since testers will need to assess the security
    controls in place and identify potential vulnerabilities and misconfigurations
    when using this service.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, this section is divided into the following subparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 2 – Preparing the target resources* *using Terraform*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 2 – Verifying our target VM* *instance setup*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 1 of 2 – Preparing the target resources using Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the **main.tf**, **variables.tf**, and **outputs.tf** files inside
    the **target_vm** directory using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the **wget** command to download the **boot-script.sh** script file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure that the **DOWNLOAD_URL** variable value is correct and properly pointing
    to the boot-script.sh file. If you are wondering what’s inside **boot-script.sh**,
    here’s a quick screenshot of what’s inside the script file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.9 – boot-script.sh
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When executed, the following script file will (1) create a **flag1.txt** file
    for the first flag, (2) install Docker inside the VM instance, (3) pull the **Metasploitable
    2** container image, (4) run the vulnerable container with elevated privileges,
    along with mapping specific container ports to the VM instance ports, (5) install
    the **Azure CLI** inside the VM instance, and (6) set up the second flag as a
    secret inside Azure Key Vault.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering what a **flag** is, it serves as an essential marker of
    successful exploitation and progress in a penetration testing lab environment.
    Flags may represent sensitive data or credentials that an attacker (or someone
    assuming the role of an attacker) aims to acquire during a real-world compromise.
    So, we can think of a penetration testing lab environment as a maze with flags
    that act as valuable treasures waiting to be discovered at different points along
    the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, define the following variables in **target_vm/variables.tf**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These variables will be used later when we define the resources under the **target_vm**
    module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you save the changes you’ve made to the **target_vm/variables.tf**
    file before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s open **target_vm/main.tf** in the editor. Keep this file open – we
    will define various resources inside this file in the next set of steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **target_vm/main.tf** file, add the following blocks of code for the
    credentials that will be used to access the target VM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **target_vm/main.tf** file, let’s also define the public IP address
    and network interface resources for the target VM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to define the associations in the **target_vm/main.tf** file as
    well using the following blocks of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With all the prerequisites ready, let’s add the following block of code to
    the **target_vm/main.tf** file to define and configure the target VM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Can you see the **identity** block, where **type = "SystemAssigned"**? This
    VM instance will be configured (in the next set of steps) with a system-assigned
    managed identity that will be used to authenticate and authorize this resource
    when we’re interacting with other Azure services or resources, such as Azure Key
    Vault.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean for penetration testers? This means that if we’re able to
    compromise the VM instance, then we may be able to access other services and resources
    (such as Azure Key Vault) from within the VM instance without having to specify
    or provide credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **target_vm/main.tf** file, let’s define and configure the Azure Key
    Vault resource. Make sure you update the Key Vault **name** value from **rg-01-key-vault**
    to any unused vault name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the first access policy grants permissions to a principal associated with
    an Azure Linux VM. The specified secret permissions allow the principal to perform
    operations such as **Get**, **Set**, and **List** on secrets stored in the key
    vault. On the other hand, the second access policy grants permissions to a user-assigned
    managed identity. Similar to the first access policy, the specified secret permissions
    of the second access policy allow the principal to perform operations such as
    **Get**, **Set**, and **List** on secrets stored in the key vault.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you update the Key Vault **name** value from **rg-01-key-vault**
    to any unused vault name as you’ll encounter the following error (since vault
    names are globally unique) once you run the **terraform apply** command in a later
    step: **VaultAlreadyExists — The vault name ‘rg-01-key-vault’ is already in use.
    Vault names are globally unique so it is possible that the name is** **already
    taken.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to add random characters to the Key Vault **name** value to help
    ensure that your vault name is globally unique. A good example would be **rg-01-key-vault-a1b2c3d4**.
    Of course, try something else as other readers of this book may use the same vault
    name! Finally, we have to update the key vault name specified in the **target_vm/boot-script.sh**
    file as well. You should find the following line at the end of the script: **az
    keyvault secret set --vault-name rg-01-key-vault --name "flag2" --value "FLAG
    #** **2!"**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define the managed identity in the **target_vm/main.tf** file as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the **target_vm/main.tf** file, define the following data blocks. These
    will be used when we set up the permissions and role assignments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, define the following role assignment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This role assignment grants the **Contributor** role to a user-assigned managed
    identity within the specified resource group (in this case, it would be **resource-group-01**).
    Assigning the **Contributor** role means that the managed identity will have the
    necessary permissions to manage resources within the specified resource group,
    such as creating, modifying, and deleting resources.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s define the following role assignment as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This role assignment grants the **Contributor** role to the principal associated
    with an Azure Linux VM within the specified resource group (in this case, it would
    be **resource-group-01**). This means the principal will have the necessary permissions
    to manage resources within the specified resource group, such as creating, modifying,
    and deleting resources.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you save the changes you’ve made to the **target_vm/main.tf** file
    before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **target_vm/main.tf** file ready, let’s open the **target_vm/outputs.tf**
    file in the editor. Add the following blocks of code to **target_vm/outputs.tf**
    to define the outputs of the **target_vm** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you save the changes you’ve made to the **target_vm/outputs.tf** file
    before proceeding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s update **outputs.tf** (inside the **pentest_lab** directory) with
    the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you save the changes you’ve made to the **outputs.tf** file (in the
    **~/pentest_lab** directory) before proceeding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s update the key vault **name** value specified in the **target_vm/boot-script.sh**
    file. You should find the following line at the end of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you replace **rg-01-key-vault** with the vault name you configured
    for the **azure_rm_key_vault.key_vault** resource defined in **target_vm/main.tf**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Upon running the command, we should encounter multiple **Missing required**
    **argument** errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s locate the following block of code in our **main.tf** file (inside the
    **pentest_lab** directory):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update it with the following block of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you save the file before proceeding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that compared to how the target VM instance was prepared
    in *[Chapter 4](B19755_04.xhtml)*, there is no waiting mechanism in this chapter’s
    implementation. Feel free to utilize the same technique from the previous chapter
    and upgrade the current implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Running this command may yield a few deprecation warnings. This should be okay,
    so long as we can successfully run the command without errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you copy the output values into a text editor on your local machine
    as we will use these values in the succeeding sections in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you update the Key Vault **name** value (defined in **target_vm/main.tf**)
    to any unused vault name in case you encounter an error message similar to **VaultAlreadyExists
    — The vault name ‘rg-01-key-vault’ is already in use. Vault names are globally
    unique so it is possible that the name is already taken**. Feel free to add random
    characters to the **name** value to help ensure that your vault name is globally
    unique (for example, **rg-01-key-vault-a1b2c3d4**).
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 of 2 – Verifying our target VM instance setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **Overview** blade of the target VM instance (**vm-target**)
    by (1) typing **vm-target** in the search bar and then (2) selecting **vm-target
    — Virtual machine** from the list of search results. Locate and select **Serial
    console** under the **Help** section of the resource menu in the left pane to
    open a serial console pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may simply close Cloud Shell and refresh the page (or open the page in a
    new browser tab) if you are having issues loading the serial console Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Press *Enter* to load the **vm-target login** prompt. Use the **vm_target_username**
    (**testuser**) and **vm_target_password** (*randomly generated*) output values
    to authenticate and log in using the serial console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to run the **terraform show** command in the Cloud Shell Terminal
    (inside the **~/pentest_lab** directory) if you were not able to copy the **vm_target_username**
    (**testuser**) and **vm_target_password** output values to the text editor on
    your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by checking if the Metasploitable 2 container is running (by executing
    the following command after the **$** sign):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Feel free to wait and try running the same command after a few minutes in case
    the vulnerable container does not appear after running the **sudo docker** **ps**
    command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are having issues setting up and configuring the target VM instance,
    simply open the **/var/log/** directory and troubleshoot using the logs generated
    by the installation and boot scripts. For example, you may run **cat /var/log/syslog
    | grep STEP** to check which steps from the **boot-script.sh** script file have
    already been executed inside the target VM instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, check if we can authenticate using the system-assigned
    managed identity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that we should be able to authenticate and perform specific actions
    in Azure without (explicitly) requiring credentials
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s also verify if we’re able to list the vaults:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return a nested JSON structure similar to what we have here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that you’ll get a different vault name value depending on how you configured
    the **azurerm_key_vault.keyvault** resource in the **target_vm/main.tf** Terraform
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s run the following command to list all the secrets stored in
    **rg-01-key-vault**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you replace **rg-01-key-vault** with the actual key vault name that
    you retrieved after running the command from the previous step. Running the command
    should return a list with a single nested JSON value corresponding to the **flag2**
    secret.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If the previous command returned an empty **[]** value, make sure that the vault
    names specified in the **target_vm/main.tf** and **target_vm/boot-script.sh**
    files are the same. After updating the files, feel free to run the **terraform
    apply** command again to apply the changes you’ve made to these files and rebuild
    the target VM instance, which will run **boot-script.sh** again. To help you troubleshoot
    and resolve issues, you may delete the resources (using **terraform destroy**)
    and then create the resources again (using **terraform apply**).
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, you might be excited to explore and attack the target resources
    already! Given that we have intentionally configured the network environment to
    only allow resources in *VNet 02* to access *VNet 01* (where the target VM instance
    is launched), we will have to set up our attacker VM instance in *VNet 02* first
    before we can access the vulnerable-by-design application, along with performing
    a penetration testing simulation inside the network environment.
  prefs: []
  type: TYPE_NORMAL
- en: Manually setting up the attacker VM instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our peered network environment setup ready (with the target resources running
    inside it), we can now proceed with setting up our Kali Linux attacker. In the
    previous chapter, we took a step-by-step approach to setting up and configuring
    the attacker VM instance. In this chapter, we will optimize things a bit and make
    use of a couple of scripts to further speed up the installation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, we will divide this section into two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 2 – Manually launching and configuring the* *attacker instance*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 2 – Verifying that our setup* *is working*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 1 of 2 – Manually launching and setting up the attacker instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the search bar, type **virtual machines** and press *Enter*:![](image/B19755_05_010.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.10 – Navigating to the Virtual machines page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Virtual machines** from the list of available options to navigate to
    the **Virtual** **machines** page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the **Virtual machines** page, click the **Create** button. Choose **Azure
    virtual machine** from the list of options from the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the **Create a virtual machine** page, specify the following configuration
    values under the **Basics** tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Project details** > **Subscription**: Use existing subscription'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project details** > **Resource** **group**: **resource-group-02**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance details** > **Virtual machine** **name**: **kali-00**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance details** > **Region**: **(US)** **East US**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance details** > **Security** **type**: **Standard**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance details** > **Image**: Click the **See all** **images** link'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Clicking **See all images** will redirect you to the **Select an** **image**
    page.
  prefs: []
  type: TYPE_NORMAL
- en: On the **Select an image** page, type **kali** in the search box and then press
    *Enter*:![](image/B19755_05_011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.11 – Selecting the Kali Linux image
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Choose **Kali Linux — The Most Advanced Penetration Testing Distribution. Ever.**
    by clicking the **Select** button, as highlighted in *Figure 5**.11*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Kali 2022.3 – x64 Gen 2** (or if there are other newer versions, choose
    the first one from the list of options). This should redirect you back to the
    **Create a virtual** **machine** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are having issues selecting the Kali Linux image and making it reflect
    in the drop-down menu as the selected image (even if the **Security type** configuration
    is already set to **Standard**), simply refresh the page and then try again. Note
    that you will need to input the VM configuration settings again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing where we left off on the **Create a virtual machine** page, specify
    the following configuration values under the **Basics** tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Administrator account** > **Authentication** **type**: **Password**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Administrator account** > **Username**: **kali_admin**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Administrator account** > **Password**: **KaliLinux1234!!!**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Administrator account** > **Confirm** **password**: **KaliLinux1234!!!**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inbound port rules** > **Public inbound** **ports**: **None**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click the **Next : Disks >** button afterward.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Accept the default configuration under the **Disks** tab and click **Next :**
    **Networking >**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the **Networking** tab, make sure that the following configuration values
    are set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Virtual** **network**: **vnet-02**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subnet**: **subnet-02 (192.168.1.0/24)**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NIC network security** **group**: **Advanced**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure network security** **group**: **nsg-02**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delete public IP and NIC when VM** **is deleted**:**(checked)**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, continue clicking the **Next** button until you reach the last tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Simply accept the default settings under **Disks**, **Networking**, **Management**,
    **Monitoring**, **Advanced**, **Tags**, and **Review +** **create**.
  prefs: []
  type: TYPE_NORMAL
- en: Once you reach the **Review + create** tab, click the **Create** button after
    reviewing the configuration details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until you see the **Your deployment is complete** message. Scroll down
    and click the **Go to resource** button. This should redirect you to the **Overview**
    blade of the VM we just created (**kali-00**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate and select **Serial console** under the **Help** section of the resource
    menu in the left pane to open a serial console pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the serial console has loaded, press *Enter* to continue to the **kali
    login:** prompt. Use **kali_admin** for the username and **KaliLinux1234!!!**
    for the password to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you see a bunch of question mark characters before the prompt (for example,
    **?????????????????????????kali_admin@kali:~$**), simply ignore these extra characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the **kali_setup.sh** script by running the following commands (after
    the **$** sign):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that the shortened link provided simply points to the complete script,
    which can be found at [https://gist.githubusercontent.com/joshualat/e01be82543c238d7f0a13f4c33f22802/raw/8b6af622f340cdce14f13260a4ca16678f1dbb50/kali_setup.sh](https://gist.githubusercontent.com/joshualat/e01be82543c238d7f0a13f4c33f22802/raw/8b6af622f340cdce14f13260a4ca16678f1dbb50/kali_setup.sh).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the installation script inside **kali_setup.sh**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should display the contents of the script, similar to what is shown in
    *Figure 5**.12*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_012.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.12 – kali_setup.sh
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In case you have forgotten already, this is the same set of commands we used
    in *[Chapter 4](B19755_04.xhtml)*, *Setting Up Isolated Penetration Testing Lab
    Environments* *on GCP*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s use the **chmod** command to make the **kali_setup.sh** file executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download the **setup_cron_job.sh** script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that the shortened link provided simply points to the complete script,
    which can be found at [https://gist.githubusercontent.com/joshualat/e01be82543c238d7f0a13f4c33f22802/raw/8b6af622f340cdce14f13260a4ca16678f1dbb50/setup_cron_job.sh](https://gist.githubusercontent.com/joshualat/e01be82543c238d7f0a13f4c33f22802/raw/8b6af622f340cdce14f13260a4ca16678f1dbb50/setup_cron_job.sh).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check what’s inside the **setup_cron_job.sh** script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should display the contents of the script, similar to what is shown in
    *Figure 5**.13*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_013.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.13 – setup_cron_job.sh
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will configure the VNC server and the noVNC proxy to automatically start
    upon each system reboot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s make **setup_cron_job.sh** executable using the **chmod** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With everything ready, let’s run the first script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This step may take 20-30 minutes to complete. Feel free to grab a cup of coffee
    or tea while waiting. Given that it takes a while for the script to finish, you
    might as well grab a snack and eat that as well!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly clear our screen before running the next set of commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s run the **setup_cron_job.sh** script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s check if we were able to successfully update the **crontab** configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you can see that we’ve configured **vncserver** and **novnc_proxy** to
    run after 60 seconds to ensure that the system processes are ready before these
    are run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Restart the VM instance using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Wait for about 3-5 minutes for the attacker VM instance to restart.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 of 2 – Verifying that our setup is working
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Once the serial console has loaded, press *Enter* to continue to the **kali
    login:** prompt. Use **kali_admin** for the username and **KaliLinux1234!!!**
    for the password to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s use the **ps** command to quickly check if everything has been set up
    as planned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that you see the following running after using the **ps -ef | grep**
    **vnc** command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may need to wait for an extra minute for **ps -ef | grep vnc** to yield
    this output.
  prefs: []
  type: TYPE_NORMAL
- en: Using the resource menu in the left pane, navigate to the **Overview** blade
    of the VM instance:![](image/B19755_05_014.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.14 – Retrieving the Public IP address value of the target VM instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the **Public IP address** value (to the clipboard), as highlighted in *Figure
    5**.14*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open a new browser tab and access the web-based noVNC client using the **http://<ATTACKER
    VM PUBLIC IP ADDRESS>:8081/vnc.html** URL. Make sure you replace **<ATTACKER VM
    PUBLIC IP ADDRESS>** with the **Public IP address** value you copied to the clipboard
    previously:![](image/B19755_05_015.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.15 – noVNC welcome screen
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This should open a welcome screen with a **Connect** button, similar to what
    we have in *Figure 5**.15*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself unable to access the welcome screen, your IP address might
    have changed already. Simply open the Cloud Shell editor and update the **terraform.tfvars**
    file. Once the **terraform.tfvars** file has been updated with the new IP address
    of your local machine, run the **terraform apply** command again to update the
    firewall rule to whitelist your new IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Connect** button and then use the **kali123** password (or the password
    you specified previously) to access the desktop environment, similar to what is
    shown in *Figure 5**.16*:![](image/B19755_05_016.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.16 – Accessing the Kali Linux desktop/GUI environment in the browser
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we can access the desktop environment, we can proceed with creating the
    golden image based on the current VM instance (**kali-00**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to close the browser tab (Kali Linux desktop/GUI environment) before
    proceeding with the next set of steps.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to setting up a Kali Linux machine in GCP, setting up a similar VM
    instance in Microsoft Azure requires fewer steps as we no longer need to import
    the Kali Linux Generic Cloud Image. Of course, this chapter builds on top of the
    previous chapter and makes use of automated scripts to further reduce the number
    of steps when setting up the attacker machine manually.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Terraform to automatically set up the attacker VM instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section primarily focused on setting up the attacker VM instance
    using pre-built scripts. This was necessary because we will utilize this VM instance
    (**kali-00**) as a reference to create a golden image. This golden image will
    be used in the Terraform configuration file to automatically set up the attacker
    VM instance (**vm-kali**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: What will happen to the original VM instance (**kali-00**) we created? After
    using it to create the golden image, it becomes *generalized* and cannot be started
    again. That said, once the golden image has been successfully created, we will
    delete the original VM instance (**kali-00**).
  prefs: []
  type: TYPE_NORMAL
- en: 'This section is divided into the following subparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 3 – Creating the* *golden image*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 3 – Deleting the manually* *created resources*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 3 of 3 – Preparing the Terraform* *configuration files*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without further ado, let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 3 – Creating the golden image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the VM instance’ **Overview** blade of our Kali Linux (**kali-00**)
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate and click the **Capture** button to be redirected to the **Create an**
    **image** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the **Create an image** page, specify the following configuration values
    under the **Basics** tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Project details** > **Subscription** > **Resource** **group**: **image-resource-group**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gallery details** > **Target Azure compute gallery**: Click **Create new**.
    Specify **kali_gallery** in the text field before clicking the **OK** button.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target VM image definition**: Click **Create new**. Specify **golden-image**
    in the **VM image definition name** field. Leave everything else as is and then
    click the **OK** button to proceed with creating the new VM image definition.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version details** > **Version** **number**: **1.0.0**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click the **Next : Tags >** button afterward.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you take note of the **Publisher**, **Offer**, and **SKU** configuration
    values (**Publisher**: **kali-linux**, **Offer**: **kali**, **SKU**: **kali**)
    while creating the VM image definition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the **Tags** tab, simply locate and click **Next: Review +** **create >**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the configuration settings and then click the **Create** button. This
    will stop the running VM instance and redirect you to the **Deployment** page
    (where you’ll see the **Deployment is in** **progress** message).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This step may take around 10-15 minutes to complete. Feel free to grab a cup
    of coffee or tea while waiting!
  prefs: []
  type: TYPE_NORMAL
- en: Once you see the **Your deployment is complete** success message, click the
    **Go to resource** button to navigate to the **Overview** blade of the resource
    we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate and click the **JSON View** link located at the top-left corner of the
    page (as highlighted in *Figure 5**.17*):![](image/B19755_05_017.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.17 – Locating the JSON View link
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Clicking the **JSON View** link will open the **Resource JSON** pane. Click
    the **Copy to clipboard** button and then store this **id** value in a text editor
    on your local machine. Note that the **id** value should have a format similar
    to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use this value later when we prepare the Terraform configuration files
    for automating the creation of our Kali Linux server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Part 2 of 3 – Deleting the manually created resources
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the **Overview** blade of the Kali Linux (**kali-00**) VM instance
    by (1) typing **kali-00** in the search bar and then (2) selecting **kali-00 —
    Virtual machine** from the list of search results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s delete the instance. In the resource menu in the left pane, locate
    and click **Overview**. In the **Overview** blade, click the **Delete** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the list of associated resources, make sure you have all three checkboxes
    checked (**OS disk**, **Network interfaces**, and **Public IP addresses**) under
    the **Delete with VM** column when possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the **I have read and understand that this virtual machine as well as
    any selected associated resources listed above will be deleted** checkbox as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Delete** button afterward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: After a minute or two, you should see a success message stating that the resource(s)
    have been deleted successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 of 3 – Preparing the Terraform configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to code again! Make sure that the Cloud Shell editor is activated
    and maximized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we run any of the succeeding commands, let’s make sure that we are inside
    the **pentest_lab** directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create the **main.tf**, **variables.tf**, and **outputs.tf** files inside
    the **attacker_vm** directory using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When you encounter issues using Cloud Shell, feel free to restart using the
    **Restart Cloud Shell** button. Make sure you navigate back to the **~/pentest_lab**
    directory after restarting Cloud Shell. If that does not work, you may sign out
    and sign in of your Azure account to help you troubleshoot and resolve various
    types of issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the **attacker_vm/variables.tf** file in the editor and add the
    following blocks of code to define the **source_image_id**, **asg**, **nsg**,
    **rg_location**, **rg_name**, **subnet**, and **my_public_ssh_key** variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the **attacker_vm/main.tf** file in the editor and add the following blocks
    of code to define the public IP address and network interface resources for the
    attacker VM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s define the following block of code to establish an association
    between the network interface of the attacker VM instance and the specified NSG:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s define the following block of code to establish an association
    between the network interface of the attacker VM instance and the specified ASG:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With everything ready, let’s define and configure the attacker VM instance,
    which will utilize the golden image we prepared earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are allowing the attacker VM instance to be accessed using an SSH key
    as well (in addition to being accessed using a username and password).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you save the **attacker_vm/main.tf** file before proceeding to the
    next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **attacker_vm/outputs.tf** file in the editor and add the following
    lines of code to output the private and public IP addresses of the attacker VM
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow the root module to access these values, which are currently
    only accessible from within the **attacker_vm** module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let’s define the following outputs in the **outputs.tf** file (inside
    the **pentest_lab** directory):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we are defining two outputs in the root module: **vm_kali_private_ip**,
    which is the private IP address of the attacker VM instance from the list of outputs
    of the **attacker_vm** module, and **vm_kali_public_ip**, which is the public
    IP address of the attacker VM instance from the list of outputs of the **attacker_vm**
    module.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since the **outputs.tf** file has defined output values already, make sure you
    append these blocks of code instead of replacing existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should give us a couple of missing required argument errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To resolve these issues, let’s locate the following block of code in our **main.tf**
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s replace this with the following block of code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you save the changes you’ve made to the **main.tf** file before proceeding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll encounter another issue, this time concerning the **"<INSERT KALI IMAGE
    ID>"** string value we specified as a placeholder earlier.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To fix this issue, let’s open the **terraform.tfvars** file and update it with
    the ID of the golden image we created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are wondering what this value looks like, the value for the **<INSERT
    KALI IMAGE ID>** placeholder should have a format similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s run **terraform** **plan** again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command should complete without any errors this time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the **terraform apply** command runs without any errors, we are ready to
    proceed to the next section!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you copy the output values into a text editor on your local machine
    as we will use these values in the succeeding sections in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to access the attacker VM instance using the SSH key (**kali-ssh**)
    you downloaded earlier in this chapter. After updating the permissions of the
    SSH key file using **chmod 600 kali-ssh**, you can run the following command to
    create the SSH tunnel between our local machine and the attacker VM instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Once the SSH tunnel has been set up, we can access the same desktop environment
    through http://localhost:8081/vnc.html (instead of using the public IP address
    of the attacker VM instance).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the current implementation is not perfect and will
    need a few additional tweaks and upgrades before it can handle other scenarios
    such as VM instance restarts, along with container restarts. Feel free to utilize
    and combine some of the techniques used in the previous chapter to further enhance
    what we have running in the Azure environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have everything ready, we can proceed with simulating a penetration
    testing exercise inside our lab environment.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating penetration testing in the isolated network environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given that our lab environment in Microsoft Azure has been set up successfully,
    we can now proceed with a simplified penetration testing simulation to verify
    if everything has been (mis)configured correctly. Compared to the previous chapter,
    our penetration testing simulation in this chapter will be a bit longer as we
    are dealing with a relatively more complex setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_05_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Penetration testing simulation
  prefs: []
  type: TYPE_NORMAL
- en: Our simulation starts by compromising a **Metasploitable 2** container running
    inside the VM instance. Given that this running container has been configured
    with the **--privileged** flag enabled, we can escape the container environment
    using a container breakout technique and access the host system, where we’ll find
    the first flag. We will then utilize the system-assigned managed identity assigned
    to the VM instance to access Azure Key Vault, where we’ll find the second flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our penetration testing simulation, we will use **Metasploit** – a widely
    recognized penetration testing framework used by security professionals. We will
    use the interactive command-line interface of the Metasploit Framework called
    **msfconsole**. This command-line interface allows us to perform tasks such as
    searching for vulnerabilities, exploiting systems, conducting reconnaissance,
    managing sessions, and launching various security-related modules and exploits.
    Using it generally involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Running the **msfconsole** command in the Terminal to launch the interactive
    console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identifying and selecting a module (for example, an exploit module) from the
    comprehensive collection of modules available in Metasploit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the module by adjusting its parameters and settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exploring and using other modules for subsequent post-exploitation actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this is a simplified way of describing how to use **msfconsole** as
    there are various advanced features, modules, and configurations available within
    the Metasploit Framework. Depending on the scenario, additional options such as
    auxiliary modules, post-exploitation techniques, scripting capabilities, and integration
    with external tools can be leveraged within **msfconsole**. If you have not used
    Metasploit before, don’t worry – the step-by-step guide in this section will help
    you utilize this framework along with other tools and techniques to validate if
    our lab environment has been (mis)configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will divide this section into four subparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 4 – Scanning* *with Nmap*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 4 – Using the VNC login scanner module* *of Metasploit*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 3 of 4 – Breaking out of* *the container*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 4 of 4 – Locating* *the flags*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is unethical and illegal to attack cloud resources owned by another user
    or company. Before proceeding, make sure you read the *Examining the considerations
    when building penetration testing lab environments in the cloud* section of *[Chapter
    1](B19755_01.xhtml)*, *Getting Started with Penetration Testing Labs in the Cloud*,
    since we will be simulating the attack process to validate if misconfigurations
    and vulnerabilities present in the applications and services running in the target
    VM instance are exploitable.
  prefs: []
  type: TYPE_NORMAL
- en: With these in mind, we can now start the penetration testing simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 4 – Scanning with Nmap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s open a new browser tab and access the desktop environment using the following
    URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you replace **<ATTACKER VM PUBLIC IP ADDRESS>** with the **vm_kali_public_ip**
    output value after running the **terraform** **apply** command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_019..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.19 – noVNC welcome screen
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This should open a welcome screen with a **Connect** button, similar to what
    we have in *Figure 5**.19*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself unable to access the welcome screen, your IP address might
    have changed already. Simply update the **terraform.tfvars** file and then run
    the **terraform apply** command again to update the firewall rule to whitelist
    your new IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Connect** button and then use the **kali123** password (or the password
    you specified previously in this chapter) to access the desktop environment, similar
    to what we have in *Figure 5**.20*:![](image/B19755_05_020..jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.20 – Accessing the Kali Linux desktop/GUI environment in the browser
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we’re able to access the desktop environment, we should be able to perform
    various tasks and access the wide range of tools and utilities available in Kali
    Linux (similar to how we would use it on our local machine).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open a Terminal window inside the Kali Linux instance by clicking the icon highlighted
    in *Figure 5**.21*:![](image/B19755_05_021..jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.21 – Opening a Terminal window
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This should open a Terminal window where we can run commands after the **$**
    sign.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the **TARGET_IP** variable value to the private IP address of the target
    VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you replace **<PRIVATE IP ADDRESS OF TARGET VM>** with the private
    IP address of the target VM instance (for example, **10.0.1.4**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that you might get a different private IP address for the target VM. Feel
    free to check the Terraform output value (**vm_target_private_ip**) by running
    **terraform output** inside the **~/pentest_lab** directory in the Cloud Shell
    Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield a scan report similar to what we have in *Figure 5**.22*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_022..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.22 – Result after running the nmap command again
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*What just happened?* Here, we used Nmap to check and scan the open ports on
    the target VM instance. To quickly check for open ports, we used the **--top-ports**
    option while running Nmap. This allowed us to get (non-exhaustive) scan results
    within just a few seconds:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_023..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.23 – Using the Nmap scanner to scan the open ports
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we mapped some of the container’s ports to the VM, we are effectively
    using Nmap to scan and examine the services running within the Metasploitable
    2 container as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to check the boot script we used to configure the target VM instance
    (**vm-target**) for more details: [https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/blob/main/ch05/pentest_lab/target_vm/boot-script.sh](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/blob/main/ch05/pentest_lab/target_vm/boot-script.sh).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s run the same command but this time with the **-sV** (service version
    detection) and **-sV** (TCP SYN scan) flags enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield a scan report similar to what we have in *Figure 5**.24*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_024..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.24 – Result after running the nmap command again
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that with the **-sV** and **-sS** flags enabled, we can determine
    the characteristics (such as the version or fingerprint) of the services running
    in each port of the target VM instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This step may take around 4-10 minutes to complete. Feel free to grab a cup
    of coffee or tea while you’re waiting!
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 of 4 – Using the VNC login scanner module of Metasploit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous set of steps, we used Nmap to identify the open ports along
    with the services running in each of these ports. While there are several ports
    open, we will focus on port **5900** and use the VNC login auxiliary scanner module
    of Metasploit to try and authenticate using different username and password combinations:![](image/B19755_05_025..jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.25 – Using the VNC login auxiliary scanner to authenticate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the scanner, we will check if weak or default credentials are used to
    access the running VNC server process (application). Now that we have a better
    understanding of how the VNC login auxiliary scanner works, let’s execute the
    following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will launch the Metasploit Framework console, similar to what we have
    in *Figure 5**.26*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_026..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.26 – Metasploit Framework console
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that it may take a minute or two for **msfconsole** to be ready.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you are not aware, the Metasploit Framework is a framework written
    using the Ruby language! Even if you have not used Ruby to write scripts or build
    applications before, you will be able to understand the code written using said
    language. To see how the scanner works behind the scenes, feel free to check out
    the official Metasploit Framework GitHub repository: [https://github.com/rapid7/metasploit-framework/blob/master/modules/auxiliary/scanner/vnc/vnc_login.rb](https://github.com/rapid7/metasploit-framework/blob/master/modules/auxiliary/scanner/vnc/vnc_login.rb).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following in **msfconsole**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will search the module database and return a set of results, similar to
    what we have in *Figure 5**.27*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_027..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.27 – Results after executing the search vnc login command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since we are planning to scan and attempt to log in via VNC, we will choose
    the first one (**auxiliary/scanner/vnc/vnc_login**) in the next set of steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Here, you’ll notice that the module path (**auxiliary/scanner/vnc/vnc_login**)
    matches the file path (**auxiliary/scanner/vnc/vnc_login.rb**) where the Ruby
    code is stored inside the **modules** directory (without the *.rb* file extension).
    This means that if we need to check how a module has been implemented, we can
    simply locate the corresponding file inside the Metasploit Framework GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, execute the following command to use the VNC login auxiliary scanner
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running this command will make the system ready to proceed with the module’s
    configuration and execution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have selected the VNC login auxiliary scanner module, let’s run
    the following to configure the **RHOST** (remote host) variable with the private
    IP address of the target VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you replace **<PRIVATE IP ADDRESS OF TARGET VM>** with the private
    IP address of the target VM instance before running the command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s quickly check the settings and options we have before running the scanner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return a list of module options, similar to what we have in *Figure
    5**.28*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_028..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.28 – Output after executing the show options command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see a description of each module option, along with which options
    are required. As shown in *Figure 5**.**28*, all required options have been set
    accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With everything ready, let’s run the scanner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_029..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.29 – Output after executing the run command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that we should be able to log in using **password**. Wow! While
    this may seem a bit too easy, it is relatively common for users and administrators
    to overlook the importance of changing default or weak passwords, thus providing
    a convenient entry point for exploitation in a penetration testing exercise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s exit **msfconsole**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in our Terminal console (with **msfconsole** exited already), let’s run
    the following command to check if the **$TARGET_IP** variable value is still set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If not, just set it to the private IP address of the target VM instance again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s check if we’re able to log into the VNC server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After using **password** as the password, a window similar to what we have
    in *Figure 5**.30* should open:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_030..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.30 – Using vncviewer to access the Metasploitable 2 container
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, it is important to note that we are inside the Metasploitable 2 container
    running inside the VM instance. *How do we know this?* *Well, for one thing, we
    designed and built this penetration testing lab setup ourselves!* Joking aside,
    we will confirm this in the next set of steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that, alternatively, we can run **echo "password" | vncviewer $TARGET_IP
    -autopass** to accomplish the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the following command in the Terminal window inside the **TightVNC:
    root’s X** **desktop** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should return **uid=0(root)** **gid=0(root) groups=0(root)**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will see that we are running this command inside an **Ubuntu 8.04** “environment,”
    similar to what is shown in *Figure 5**.31*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_031..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.31 – Result after running lsb_release -a inside the container
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is the expected result given that we are inside a running Metasploitable
    2 container inside the target VM instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is just one of the ways to exploit **Metasploitable 2**. For
    more information, feel free to check out [https://docs.rapid7.com/metasploit/metasploitable-2-exploitability-guide/](https://docs.rapid7.com/metasploit/metasploitable-2-exploitability-guide/).
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 of 4 – Breaking out of the container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we currently are inside the running Metasploitable 2 container.
    Now, let’s check if we can break out of the container!
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_05_032..jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.32 – Breaking out of the container
  prefs: []
  type: TYPE_NORMAL
- en: 'Container breakout techniques involve exploiting vulnerabilities within a Docker
    environment to gain unauthorized access outside of the running container. Techniques
    range from kernel vulnerabilities and shared namespaces to insecure container
    configurations. In this part, we will run a sequence of commands to break out
    of a container running in privileged mode:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by quickly checking and listing all existing disk partitions using
    the **fdisk -****l** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should display the disk partitions on the system, providing information
    about their sizes, types, and filesystems, similar to what is shown in *Figure
    5**.34*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_033..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.33 – Output after running the fdisk -l command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that we can try mounting the **/dev/sda1** partition to **/mnt**
    (which is what we will do in the next step!).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the following command to mount the **/dev/sda1** partition
    to the **/****mnt** directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s navigate to the **/mnt** directory and then perform **chroot** inside
    the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are using the **chroot** command to break out of the container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the following command to check the identity information of the current
    user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s check the specific distribution and version of the operating system using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will be surprised to see that we’re now getting **Ubuntu 22.02 LTS** instead
    of **Ubuntu 8.04**!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_034..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.34 – Output after running the lsb_release -a command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*This means that we were able to successfully break out of the container* and
    we should be able to run certain commands as the root user of the VM instance!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Running a container with the **--privileged** flag grants the container unrestricted
    access to the host system’s resources. Given that the isolation and security mechanisms
    and features are deactivated when this flag is enabled, an attacker (or someone
    playing the role of the attacker) can break out of the container using various
    container breakout techniques. We won’t dive deep into the details of this topic,
    so feel free to check other resources available online.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Firefox browser (inside the Kali Linux desktop environment) and navigate
    to the following URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open a page similar to what is shown in *Figure 5**.35*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_035..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.35 – Commands we will use in the next set of steps
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we have a reference for the commands we will use in the succeeding set
    of steps. While this step is optional, having a cheat sheet or a reference will
    come in handy as we might accidentally miss a character or two when typing and
    running these commands!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This shortened link will open the following GitHub Gist: [https://gist.githubusercontent.com/joshualat/bec319f607001e1ffd69d41d031a5526/raw/030e7efc13bddfb64fb50935fe0487054589dcdc/create_user.sh](https://gist.githubusercontent.com/joshualat/bec319f607001e1ffd69d41d031a5526/raw/030e7efc13bddfb64fb50935fe0487054589dcdc/create_user.sh).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, navigate back to the Terminal inside the VNC viewer window (**TightVNC:
    root’s X desktop**). Let’s create a new user by running the following commands
    (one line at a time):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when typing and running these commands! Make sure you check the spelling
    and capitalization of the commands, flags, and arguments used. Finally, be mindful
    of the spaces as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s set up the necessary prerequisites for SSH access for the new user
    by running the following commands (one line at a time):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After running the last line from the preceding block of commands, we should
    receive a **System has not been booted with systemd as init system...** message,
    similar to what is shown in *Figure 5**.36*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_036..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.36 – Creating a new SSH user
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, we should be able to access the VM instance directly via SSH
    using the **new_user** user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Close the VNC viewer (**TightVNC: root’s X desktop**) window and close the
    Firefox browser window as well.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in our Terminal shell (where we previously ran **vncviewer $TARGET_IP**),
    quickly check if the **$TARGET_IP** variable value is still set to the private
    IP address of the target VM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should yield an IP address value similar to **10.0.1.4**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you encounter strange characters while typing in the Terminal, simply close
    the noVNC browser tab (where we can access the Kali Linux desktop environment).
    After that, reopen it in a new browser tab and check if the issue has been resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s check if we were able to properly set up SSH access for a new user (similar
    to what we have in *Figure 5**.37*):![](image/B19755_05_037..jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.37 – Accessing the target instance via SSH using the new_user account
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we will try authenticating using the **new_user** account we created in
    the previous set of steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you are ready, run the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When prompted for a password, use **password** to proceed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_038..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.38 – Accessing the target VM via SSH
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If all the steps were performed correctly, we should be able to access the target
    VM instance via SSH, similar to what we have in *Figure 5**.38*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let’s switch to the **root** user using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Wasn’t that fun?!* Now, let’s proceed with searching for the flags!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Part 4 of 4 – Locating the flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s locate the first flag by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will search the entire filesystem for files with a filename starting with
    **flag**. After a few minutes, we should get a list of results that includes a
    **/****root/flag1.txt** file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s check the contents of **/root/flag1.txt**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us **FLAG # 1!**. One down, one more to go!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When setting up penetration testing lab environments, feel free to use a cryptographic
    hash function or a random string generator to generate a unique value for the
    flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check if the Azure CLI is installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should return the **/****usr/bin/az** path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, check the version as well using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us the version number of the tool (along with its dependencies),
    similar to what is shown in *Figure 5**.39*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_039..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.39 – Result after running the az --version command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, we can see that version **2.49.0** is currently installed in the target
    VM instance. Now that we have verified that we can use the Azure CLI inside the
    VM instance, let’s try signing in using the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we use the system-assigned managed identity of the VM instance to authenticate
    without (explicitly) requiring credentials:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_040..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.40 – Result after running the az login --identity command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *Figure 5**.40*, we can see that we have logged in using the system-assigned
    identity of the target VM instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s check if we can list all Azure Key Vaults from the Terminal using the
    Azure CLI (inside the VM instance), similar to what we have in *Figure 5**.41*:![](image/B19755_05_041..jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.41 – Accessing Azure Key Vault from the VM instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are a few things we can check using the Azure CLI but we will proceed
    with checking the Azure Key Vault resources since we are trying to validate whether
    the lab environment has been configured correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That said, let’s run the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return a nested structure, similar to what we have in *Figure 5**.42*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_042..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.42 – Result after running the az keyvault list command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Wait a minute! How were we able to use the **az keyvault list** command? It
    seems that the system-assigned identity of the target VM instance allows us to
    authenticate and interact with Azure Key Vault without the need for explicit authentication
    credentials or secrets!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that you’ll get a different vault name value depending on how you configured
    the **azurerm_key_vault.keyvault** resource in the **target_vm/main.tf** Terraform
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s run the following command to list all the secrets stored in **rg-01-key-vault**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you replace **rg-01-key-vault** with the actual key vault **name**
    value that you retrieved after running the command from the previous step. This
    should return a nested structure, similar to what we have in *Figure 5**.43*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_043..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.43 – Result after running the az keyvault secret list command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that we have one secret stored called **flag2**. *What is the
    value that’s been mapped to this secret?* We’ll find out in the next step!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let’s retrieve the value of the **flag2** secret. Again, make sure
    you replace **rg-01-key-vault** with the actual Key Vault name you retrieved after
    running the **az keyvault** **list** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return a nested JSON output, similar to what we have in *Figure
    5**.44*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_05_044..jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.44 – Result after running the az keyvault secret show command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, we can see that the value of the **flag2** secret is **FLAG #** **2!**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s run the same command, this time specifying **"value"** as the **--query**
    parameter value. Make sure you replace **rg-01-key-vault** with the Key Vault
    **name** value you retrieved after running the **az keyvault** **list** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead of a nested JSON output, we should get the **FLAG # 2!** string value.
    *Looks like we were able to successfully retrieve the* *second flag!*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that we are just scratching the surface of what we can
    do with Azure Key Vault. For more information, feel free to check out [https://learn.microsoft.com/en-us/azure/key-vault/general/manage-with-cli2](https://learn.microsoft.com/en-us/azure/key-vault/general/manage-with-cli2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, you are probably excited to try out other exploits and techniques!
    Given that we have automated the setup process, we can simply run **terraform
    destroy -auto-approve** to delete the resources and then run **terraform apply
    -auto-approve** again to rebuild the entire environment. Note that it is also
    possible to rebuild only a specific component of the environment by running a
    (one-liner) command, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Running this command will destroy and recreate the target VM instance, along
    with other resources related to or dependent on it. Given that penetration testing
    activities may leave the infrastructure in an unstable or misconfigured state,
    rebuilding the infrastructure will return it to the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*For one thing, the* **new_user** *user should not be there in the first place,
    right?* That said, recreating the target VM instance (along with other resources
    in the environment) would revert the setup to an “untouched” state.'
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cleaning up the cloud resources we created or deployed is a crucial step when
    working with vulnerable cloud applications and environments. If we don’t clean
    up and delete the resources we created right away, we might end up paying for
    unused cloud resources. In addition to this, these cloud resources may end up
    being attacked by malicious users. At a *minimum*, we will be paying for the time
    the following resources are running:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 x **Standard_DS1_v2** Azure VM instance for the attacker machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x **Standard_D2s_v3** Azure VM instance for the target machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please be aware that there are other costs we have to take into account as well
    — including data transfer fees, storage costs for persistent data used by the
    instances, and potential charges for other Azure services utilized in the account,
    along with any applicable taxes or fees associated with the usage of Azure resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the overall cost when running these resources depends on several parameters,
    it is best to refer to the pricing documentation page provided by the cloud platform:
    [https://azure.microsoft.com/en-us/pricing/details/virtual-machines/](https://azure.microsoft.com/en-us/pricing/details/virtual-machines/).
    Since we utilized Azure Key Vault in the lab environment, feel free to check out
    the following as well: [https://azure.microsoft.com/en-us/pricing/details/key-vault/](https://azure.microsoft.com/en-us/pricing/details/key-vault/).
    You can also utilize the **Azure Pricing Calculator** to estimate the cost of
    deploying resources on Azure. You can access the Azure Pricing Calculator at [https://azure.microsoft.com/en-us/pricing/calculator/](https://azure.microsoft.com/en-us/pricing/calculator/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, let’s proceed with deleting the resources we created in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Close the browser tab we used to access the Kali Linux desktop environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Cloud Shell Terminal, navigate to the **~/pentest_lab** directory and
    then use **terraform destroy** to clean up the resources we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Feel free to run the **terraform destroy** command a few times in case some
    resources fail to delete (or take a bit of time to delete). Alternatively, you
    may delete resources manually using the user interface if all else fails.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This step may take 10-15 minutes to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the resources have been destroyed successfully using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should return an empty response since all the resources should have been
    deleted successfully.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to perform a full audit of your Microsoft Azure account. This will
    help ensure that all resources have been properly deleted, minimize the risk of
    unintended costs, and address any potential security concerns.
  prefs: []
  type: TYPE_NORMAL
- en: That’s pretty much it! At this point, we should have a good idea of how to prepare
    penetration testing lab environments on Microsoft Azure. The penetration testing
    simulation we performed in the previous section should validate that our lab environment
    has been (mis)configured properly as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on setting up a penetration testing lab environment
    in Microsoft Azure. We prepared a vulnerable-by-design lab setup where we can
    practice container breakout techniques to gain unauthorized access to host systems.
    Our lab environment also highlighted the potential misuse of managed identities
    in Azure as these inadvertently create other exploitable attack paths for attackers.
    After setting everything up, we performed a penetration testing simulation to
    validate if our lab environment had been (mis)configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, our focus will shift to preparing a penetration testing
    lab environment on AWS. In addition to setting up an isolated network environment,
    we’ll focus on preparing a lab setup where we can practice pivoting techniques
    that can be used to access internal systems and networks using the initially compromised
    machine. If you are excited to learn how to build a pivoting lab, then the next
    chapter is for you!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For additional information on the topics covered in this chapter, you may find
    the following resources helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Connecting from your application to resources without handling* *credentials*
    ([https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview-for-developers?tabs=portal%2Cdotnet](https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview-for-developers?tabs=portal%2Cdotnet))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How managed identities for Azure resources work with Azure virtual* *machines*
    ([https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-managed-identities-work-vm](https://learn.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-managed-identities-work-vm))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Authentication in Azure Key* *Vault* ([https://learn.microsoft.com/en-us/azure/key-vault/general/authentication](https://learn.microsoft.com/en-us/azure/key-vault/general/authentication))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Manage Key Vault using the Azure* *CLI* ([https://learn.microsoft.com/en-us/azure/key-vault/general/manage-with-cli2](https://learn.microsoft.com/en-us/azure/key-vault/general/manage-with-cli2))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Best practices for using Azure Key* *Vault* ([https://learn.microsoft.com/en-us/azure/key-vault/general/best-practices](https://learn.microsoft.com/en-us/azure/key-vault/general/best-practices))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Metasploitable 2 Exploitability* *Guide* ([https://docs.rapid7.com/metasploit/metasploitable-2-exploitability-guide/](https://docs.rapid7.com/metasploit/metasploitable-2-exploitability-guide/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is Microsoft Cost Management and* *Billing?* ([https://learn.microsoft.com/en-us/azure/cost-management-billing/cost-management-billing-overview](https://learn.microsoft.com/en-us/azure/cost-management-billing/cost-management-billing-overview))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to optimize your cloud investment with Cost* *Management* ([https://learn.microsoft.com/en-us/azure/cost-management-billing/costs/cost-mgt-best-practices](https://learn.microsoft.com/en-us/azure/cost-management-billing/costs/cost-mgt-best-practices))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*YouTube Playlist – Azure Cost* *Management* ([https://www.youtube.com/playlist?list=PLLasX02E8BPBJW49E5_sHgbgvztb4oz6D](https://www.youtube.com/playlist?list=PLLasX02E8BPBJW49E5_sHgbgvztb4oz6D))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
