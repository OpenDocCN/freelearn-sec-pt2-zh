- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up Isolated Penetration Testing Lab Environments on AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have worked on real-world projects and systems running in the cloud,
    you are probably aware that actual network environments generally involve more
    than a single cloud resource. To ensure that critical resources are not exposed
    and directly accessible from resources outside of the network environment, cloud
    resources are grouped and proper network configuration involving security groups,
    network access control lists, and routing rules is implemented as well. With a
    segmented network architecture, attackers may need to compromise a less secure
    system first and then use this compromised system to pivot to critical resources
    in internal networks. This technique, known as **pivoting**, involves using the
    right set of tools along with the correct sequence of steps, which can be mastered
    through practice. If only we had a lab environment where we could try out various
    tools and techniques for pivoting! Well, I have some good news for you – we will
    be setting up a **pivoting lab** on AWS in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: In case you are wondering what a pivoting lab is, it is a type of penetration
    testing lab where the focus is on moving from one compromised system to another
    within a target network and leveraging the compromised systems (as stepping stones)
    to gain access to other systems and resources. After setting up the pivoting lab,
    we will then perform a penetration testing simulation to verify if the lab environment
    has been configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Terraform to automatically set up the lab environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating network connectivity and security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the attacker VM instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating penetration testing in the isolated network environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without further ado, let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start, we must have the following ready:'
  prefs: []
  type: TYPE_NORMAL
- en: An **Amazon Web** **Services** account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any text editor (such as Notepad++, Visual Studio Code, or Sublime Text) where
    we can temporarily store specific values (for example, our local machine’s IP
    address) used in the hands-on solutions in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may proceed with the next steps once these are ready.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you read the available documentation, along with the FAQs, to have
    a solid understanding of what is free (and what is not free) when creating resources
    in AWS. In addition to this, make sure you *don’t* use any existing AWS account
    with production (or staging) environment resources for the hands-on exercises
    and solutions in this book. It is strongly recommended that you create a *new*
    AWS account specifically for launching intentionally vulnerable resources. This
    will ensure that your production (or staging) environment resources remain separate
    and secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code and other files used for each chapter are available in this
    book’s GitHub repository: [https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/).'
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Terraform to automatically set up the lab environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will have a network environment in AWS that mimics the peered
    network setup we prepared in *[Chapter 4](B19755_04.xhtml)*, *Setting Up Isolated
    Penetration Testing Lab Environments on GCP*, and *[Chapter 5](B19755_05.xhtml)*,
    *Setting Up Isolated Penetration Testing Lab Environments on Azure*. It is important
    to note that while the chapter titles are very similar, the design of the lab
    environments in these chapters has significant differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the previous chapters, we will use Terraform to set up the lab environment
    using various types of resources and components in our AWS account. We must familiarize
    ourselves with the key AWS concepts and services before proceeding with the hands-on
    portion of this chapter. Once we have a solid understanding of the relevant AWS
    concepts and services, it will be much easier to interpret and tweak the Terraform
    configuration code. In case you are not yet familiar with the concepts, services,
    and resource types specific to AWS, here’s a quick overview to help you:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Elastic Compute Cloud** (**Amazon EC2**): Amazon EC2 is a computing
    service that allows users to rent virtual servers (also known as instances or
    EC2 instances) where users can run, deploy, and manage various types of applications.
    You can think of an EC2 instance as your laptop running in the cloud. Just like
    your laptop, an EC2 instance provides a virtual computing environment where you
    can install and run your desired operating system, applications, and software.
    However, unlike a physical laptop machine, an EC2 instance can easily be scaled
    up or down based on your computing needs. In addition to this, EC2 instances can
    be accessed and managed remotely from anywhere with an internet connection. If
    you are wondering how these instances are accessed, the assigned public and private
    IP addresses are used to communicate and access an EC2 instance. The **public
    IP address** of the instance allows the instance to access resources on the internet
    and receive requests from external sources. On the other hand, the **private IP
    address** is used for communication between resources within the same network
    environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security group**: A security group acts as a virtual firewall for resources
    (such as EC2 instances) inside a network environment. Security group rules are
    used to define inbound and outbound traffic to and from the resources within the
    security group. For example, if all outbound traffic is denied by the security
    group of an EC2 instance, then we won’t be able to initiate external communication
    from within the EC2 instance. Similarly, if all inbound traffic is denied by the
    security group of an EC2 instance, then the EC2 instance (protected by the security
    group) won’t be able to receive incoming connections or accept incoming communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Virtual Private Cloud** (**Amazon VPC**): Amazon VPC is a service
    that allows users to create and define isolated virtual private network environments
    in the AWS cloud. In this network environment, users can launch various types
    of resources (including EC2 instances). VPCs can have one or more **subnets**
    (subnetworks). Subnets have smaller address ranges within the VPC and are smaller
    networks that are part of the larger VPC network. Depending on how the network
    is configured, a subnet can be a public subnet or a private subnet. A **public
    subnet** is configured to allow instances within the subnet to communicate directly
    with the internet. On the other hand, resources (such as instances) within a **private
    subnet** cannot communicate directly with the internet and resources do not have
    public IP addresses by default. The configuration of public and private subnets
    allows for the separation of resources based on security requirements and the
    need for direct internet access:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](image/B19755_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Sample VPC setup
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 6**.1*, we have a sample VPC with a public subnet and a private subnet.
    Inside the public subnet, we have two EC2 instances, **EC2 INSTANCE 01** and **EC2
    INSTANCE 02**, that can communicate directly with the internet – with inbound
    and outbound traffic routed through the associated **INTERNET GATEWAY**. In the
    private subnet, we have a single EC2 instance (**EC2 INSTANCE 03**). The instance
    in the private subnet will not have a public IP address by default and will have
    outbound internet access routed through a **NAT GATEWAY** resource in the public
    subnet. Since direct access from the internet to the resource(s) in the private
    subnet of the VPC is prevented, it is important to note that **INSTANCE 03** is
    not reachable from resources outside of the VPC. Finally, since instances within
    the same VPC can communicate with each other in a typical VPC configuration (regardless
    of whether they are in a public subnet or a private subnet), **INSTANCE 03** should
    be reachable from **INSTANCE 01** and **INSTANCE 02**. Of course, this is under
    the assumption that the necessary network configuration, security groups, and
    routing settings are properly configured to allow the desired communication. What
    if **INSTANCE 01** and/or **INSTANCE 02** is/are compromised by an attacker? This
    would mean that the attacker can now attack **INSTANCE 03** through the compromised
    instance(s) in the public subnet (since **INSTANCE 03** is reachable from **INSTANCE
    01** or **INSTANCE 02**).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Server configuration, network design, and firewall configuration play an important
    role in shaping the options available for deploying shells and executing pivoting
    techniques during a penetration testing exercise. The effectiveness of these techniques
    depends on what is allowed by the network’s design. For example, restrictive firewall
    rules along with tightly configured network segmentation can limit the use of
    certain shells (making the exploitation process a bit more challenging).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we should have a better understanding of the relevant AWS concepts
    and services we will work with in this chapter. Now, let’s discuss what our lab
    environment would look like. The lab environment we will set up in this chapter
    will have a **VPC peering connection**, similar to what is shown in *Figure 6**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – What our lab environment should look like
  prefs: []
  type: TYPE_NORMAL
- en: The VPC peering connection enables traffic to flow securely between the peered
    VPCs (using the private IP addresses of the resources deployed inside the VPCs).
    In the first VPC network, we will have two EC2 (VM) instances, which will serve
    as the target resources. In the second VPC network, we will have the attacker
    instance set up and ready. Out of the two target instances, only one of these
    instances should be directly reachable from the attacker instance. In addition
    to this, the traffic from the outside world (that is, outside of the peered network
    environment) should not reach the resources that have been deployed inside the
    network environment. This will help make sure that only authorized users can access
    the resources that have been deployed in the lab environment. Given that the target
    VM instances are configured to be vulnerable, we can’t afford to have random attackers
    compromise our lab environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To keep things simple, the lab environment we will set up in this chapter will
    not have a private subnet. Both target EC2 instances will be deployed in a public
    subnet – removing the need for a NAT gateway (or a NAT instance) to help us reduce
    the overall cost of running the lab environment. Instead of a typical VPC network
    setup comprised of public and private subnets, we will only have public subnets,
    where network flow and connectivity are managed through customized security group
    rules. After completing this chapter, feel free to build more complex network
    architectures by introducing new public and private subnets, as well as new peered
    VPC networks containing resources which can not directly be accessed from the
    attacker VM instance. I will leave that to you as an exercise!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a better idea of what our lab environment will look like,
    let’s proceed with using Terraform to set up our lab environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the official GitHub repository of this book using the following
    URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should find multiple folders containing the corresponding files and source
    code for each of the chapters of this book:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.3 – Navigating to the ch06 directory
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the **ch06** directory, as highlighted in *Figure 6**.3*. Inside
    the **ch06** directory, we should find a **pentest_lab.zip** file. Click the **pentest_lab.zip**
    file link afterward.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering what is inside the **pentest_lab.zip** file, it contains
    the Terraform code for setting up the *entire* lab environment for this chapter.
    In this chapter, we will simply download the code and run **terraform apply**
    to set up the infrastructure. This will allow us to focus more on the other aspects
    when we start building and testing the pivoting lab environment.
  prefs: []
  type: TYPE_NORMAL
- en: Next, right-click on the **Download** or **Raw** button, as highlighted in *Figure
    6**.4*:![](image/B19755_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.4 – Copying the link address of the pentest_lab.zip file
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Copy Link Address** from the list of options available in the context
    menu. Store the string value in a text editor on your local machine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s open a new browser tab and navigate to the **AWS Management Console**
    using the following link: [https://aws.amazon.com/console/](https://aws.amazon.com/console/).
    Make sure you sign in to your AWS account before proceeding with the next steps.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type **shell** in the search bar and then select **CloudShell** from the list
    of results (as highlighted in *Figure 6**.5*):![](image/B19755_06_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.5 – Navigating to the CloudShell console
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Alternatively, you may simply locate and click the **CloudShell** button located
    at the top-left corner of the AWS Management Console (near the region selection
    drop-down menu).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Locate and click the **Open in new browser tab** button, as highlighted in *Figure
    6**.6*:![](image/B19755_06_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.6 – Opening CloudShell in a new browser tab
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will open a CloudShell environment within a new browser tab. When you see
    the **Welcome to AWS CloudShell** pop-up window, simply click the **Close** button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the Terminal of our CloudShell environment (right after the **$** sign),
    run the following commands to create the **pentest_lab** project directory and
    navigate to the new directory as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, download the **pentest_lab.zip** file from this book’s GitHub repository
    to the **pentest_lab** directory inside the CloudShell environment using the following
    commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Feel free to set the **$DOWNLOAD_URL** variable value with the download link
    you copied to the editor on your local machine. Make sure that the **$DOWNLOAD_URL**
    variable value is correct and properly pointing to the **pentest_lab.zip** file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, the **pentestlab.zip** file should have been downloaded from
    the GitHub repository to our CloudShell environment (inside the **pentest_lab**
    directory). Now, it’s time to open it! Extract the Terraform configuration files
    using the **unzip** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should extract several **.tf** files for setting up the entire lab environment
    for this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to check the content of each file using the **cat** or **less** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the **pentest_lab.zip** file afterward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the configuration files ready, let’s use the **terraform init** command
    to initialize the Terraform working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you encounter a **no space left on device** error while running Terraform,
    feel free to run **du -h --max-depth=1 ~** to see which directory inside your
    CloudShell environment is taking up a bit of space. Once you have identified the
    directory, feel free to perform the necessary cleanup steps before proceeding
    to the next set of steps in this chapter. Make sure that you have a backup of
    the files and directories you are planning to delete before the actual deletion
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run **terraform plan** to preview the changes to be performed by Terraform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command should complete without any errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s use the **terraform apply** command to implement the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the **terraform apply** command runs without any errors, we are ready to
    proceed to the next section. If you encounter issues (for example, the **Unable
    to modify EC2 VPC Peering Connection Options** error), simply run the **terraform
    apply -auto-approve** command again:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.7 – Results after running the terraform apply command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In addition to the network environment, running the **terraform apply** command
    will also create three EC2 instances – a **t2.micro** target instance labeled
    **target-vm-01**, a **t2.micro** target instance labeled **target-vm-02**, and
    a **t3.medium** attacker instance labeled **vm-kali**. Each of these instances
    will have its corresponding public and private IP addresses, similar to what is
    shown in *Figure 6**.7*. Make sure you copy the output values (that is, the public
    and private IP addresses under **Outputs**) to the text editor on your local machine.
    Note that you will get a different set of IP addresses after running the **terraform**
    **apply** command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to review the configuration of the resources that were deployed using
    the **terraform show** command. Note that if we were to include a private subnet
    and launch another target VM instance inside it, then we would need a few more
    resources defined in our Terraform code (such as a NAT gateway in the public subnet)
    that would increase the cost of running this lab environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding to the next section, let’s quickly check what we have so
    far. In *Figure 6**.8*, we can see that after running the **terraform apply**
    command, we should have two target instances (**target-vm-01** and **target-vm-02**)
    in the first VPC network (**Target VPC**) and one attacker instance (**vm-kali**)
    in the second VPC network (**Attacker VPC**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – What we have at the moment
  prefs: []
  type: TYPE_NORMAL
- en: The two VPC networks are connected through a peering connection, which allows
    traffic from the attacker instance to reach the target instances. Of course, as
    we will see later, additional layers of security (such as the security group used
    by the second target instance) will prevent traffic from the attacker instance
    (**vm-kali**) from directly reaching the second target instance (**target-vm-02**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are other networking components and resources we can configure in AWS
    to manage the network flow and connectivity inside the lab environment. These
    include **network ACLs**, **load balancers**, and **route table configuration**,
    along with various types of **firewalls** and **gateways**. We will not discuss
    these in detail in this book so feel free to check out the *Further reading* section
    for more information about these topics.
  prefs: []
  type: TYPE_NORMAL
- en: Validating network connectivity and security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a pivoting lab, we must test and validate the network connectivity
    of the environment. This will help ensure that the network configuration, necessary
    routes, and firewall rules have been set up to facilitate the movement of traffic
    between different segments and systems in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Even if we use automation tools to build the lab infrastructure, it is still
    possible to encounter network connectivity issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a variety of ways to validate network connectivity and security.
    In this section, we will test and validate network connectivity the *manual way*
    and the *automated way*. That said, this section is divided into the following
    subparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 3 – Authorizing the use of the* *serial console*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 3 – Manually verifying network connectivity with* *ping tests*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 3 of 3 – Using the Reachability Analyzer to validate* *network connectivity*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without further ado, let’s begin.
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 3 – Authorizing the use of the serial console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different ways to access an EC2 instance. One of the options would
    be to use the **EC2 serial console**, which helps us access EC2 instances and
    troubleshoot various issues (for example, boot and network configuration issues).
    Before we can access EC2 instances through the EC2 serial console, we need to
    enable it first:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the EC2 console by typing **ec2 instances** in the search bar and
    then selecting **Instances** from the list of results (under **Features**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Toggle the checkbox *on* (that is, mark it with a check) to select **vm-kali**
    and then click the **Connect** button. This will redirect you to the **Connect
    to** **instance** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the last tab (**EC2 serial console**), if you have not authorized the use
    of the EC2 serial console in your account, simply click the **Manage access**
    button, as highlighted in *Figure 6**.9*:![](image/B19755_06_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.9 – Account not yet authorized to use the EC2 serial console
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After clicking the **Manage access** button, simply toggle the **Allow** checkbox
    *on* (that is, mark it with a check) and then click the **Update** button to authorize
    the use of the EC2 serial console in your AWS account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate back to the list of EC2 instances (using the sidebar). Toggle the checkbox
    *on* to select **vm-kali** and then click the **Connect** button. This will redirect
    you to the **Connect to** **instance** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the last tab (**EC2 serial console**), click the **Connect** button to access
    the instance via the **EC2** **serial console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Inside the serial console, if you are seeing a blank black screen, simply press
    the *Enter* key to see the **root@kali:~#** command prompt. If you are having
    issues accessing the attacker VM instance (**vm-kali**), feel free to reboot the
    EC2 instance and then try accessing it again via the EC2 serial console.
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 of 3 – Manually verifying network connectivity with ping tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the **ping** command, we will quickly test the network connectivity between
    the different resources that have been deployed inside our lab network:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing where we left off in the previous part, let’s check if we can ping
    the first target VM instance, **target-vm-01**, from the attacker VM instance,
    **vm-kali**, using its private IP address (similar to what we have in *Figure
    6**.10*):![](image/B19755_06_010.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.10 – Pinging the first target instance from the attacker instance (diagram)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we are expecting the first target VM instance, **target-vm-01**, to be
    reachable from the attacker VM instance, **vm-kali**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With this in mind, let’s run the following command (in the EC2 serial console):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you replace **<TARGET VM 01 PRIVATE IP>** with the private IP address
    of the first target VM instance (the **vm_target_private_ip** output value after
    running **terraform** **apply** previously):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_011.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.11 – Pinging the first target instance from the attacker instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As shown in *Figure 6**.11*, we can ping the first target VM instance, **target-vm-01**,
    from the attacker VM instance, **vm-kali**, using its private IP address.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to use *Ctrl* + *C* to stop the **ping** command.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s check if we can ping the second target VM instance, **target-vm-02**,
    from the attacker VM instance, **vm-kali**, using its private IP address (similar
    to what is shown in *Figure 6**.12*):![](image/B19755_06_012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.12 – Pinging the second target instance from the attacker instance
    (diagram)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we are expecting the second target VM instance, **target-vm-02**, to *not*
    be reachable from the attacker VM instance, **vm-kali**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That said, let’s run the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you replace **<TARGET VM 02 PRIVATE IP>** with the private IP address
    of the second target VM instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_013.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.13 – Pinging the second target instance from the attacker instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As shown in *Figure 6**.13*, we are not able to ping the second target VM instance,
    **target-vm-02**, from the attacker VM instance, **vm-kali**, using its private
    IP address.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Why is that? That’s because we configured the security group used by **target-vm-02**
    to only be accessible from the resources using the security group used by **target-vm-01**.
    In other words, we can only access the second target VM instance (**target-vm-02**)
    from the first target VM instance (**target-vm-01**). Note that there are various
    ways we can prevent the attacker VM traffic from reaching the second target VM
    instance. Another possible approach would be to introduce a private subnet in
    VPC 01, and then launch the second target VM instance in the private subnet. In
    addition to this, we could also create a new VPC, set up VPC peering between the
    new VPC and VPC 01, and then launch the second target VM instance in the new VPC.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate back to the list of EC2 instances. Toggle the checkbox *on* to select
    **target-vm-01** and then click the **Connect** button. This will redirect you
    to the **Connect to** **instance** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the first tab (**EC2 Instance Connect**), locate and click the **Connect**
    button to access the instance via **EC2** **Instance Connect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s check if we can ping the second target VM instance, **target-vm-02**,
    from the first target VM instance, **target-vm-01**, using its private IP address
    (similar to what is shown in *Figure 6**.14*):![](image/B19755_06_014.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.14 – Pinging the second target instance from the first target instance
    (diagram)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we are expecting the second target VM instance, **target-vm-02**, to be
    reachable from the first target instance, **target-vm-01**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That said, let’s run the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you replace **<TARGET VM 02 PRIVATE IP>** with the private IP address
    of the second target VM instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_015.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.15 — Pinging the second target instance from the first target instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As shown in *Figure 6**.15*, we can ping the second target VM instance, **target-vm-02**,
    from the first target VM instance, **target-vm-02**, using its private IP address.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, we can try to ping the second target VM instance, **target-vm-02**,
    from the first target VM instance, **target-vm-01**, using its public IP address.
    Since the VM instances are not reachable from outside the network environment,
    we should not be able to ping the second target VM instance, **target-vm-02**,
    using its public IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 of 3 – Using the Reachability Analyzer to validate network connectivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the initial network connectivity tests we have just performed,
    we will also use the **VPC Reachability Analyzer** – a network diagnostics tool
    provided by AWS – to help us detect and troubleshoot network misconfigurations
    that could lead to connectivity issues. As we will see in the succeeding set of
    steps, using it is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the **VPC Reachability Analyzer** console by typing **vpc reachability
    analyzer** in the search bar and then selecting **VPC Reachability Analyzer**
    from the list of results (under **Features**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create and analyze** **path** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the **Reachability Analyzer > Create and analyze path** page, specify the
    following form field values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Path configuration** > **Name** **tag**: **attacker-to-target-01**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path Source** > **Source** **type**: **Instances**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path Source** > **Source**: Select **vm-kali**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path destination** > **Destination** **type**: **Instances**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path destination** > **Destination**: Select **target-vm-01**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protocol**: **TCP**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you verify and check the instance IDs of the resources involved in
    the reachability check. Feel free to open another browser tab and navigate to
    the EC2 console to quickly check the instance IDs of the resources involved in
    the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Create and analyze path** button afterward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Wait for about 2-3 minutes for the analysis to complete. Feel free to grab a
    cup of coffee or tea while waiting! You may click the refresh button in case the
    user interface is not updating automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Once the analysis has finished, we should see that **Reachability status** is
    set to **Reachable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Toggle *on* the checkbox of the analysis we ran to view the diagram under **Analysis
    explorer** > **Path details**, similar to what we have in *Figure 6**.16*:![](image/B19755_06_016.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.16 – Analysis explorer > Path details
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the **Analysis explorer**, we should be able to analyze and evaluate the
    network reachability and connectivity between different resources within the VPC
    environment in AWS. Here, we can see that the first target VM instance, **target-vm-01**,
    is reachable from the attacker instance, **vm-kali**, as well as the network traffic
    passed through the VPC network peering connection. If you have time, you may use
    the VPC Reachability Analyzer to verify that we can’t ping the second target VM
    instance (**target-vm-02**) from the attacker VM instance (**vm-kali**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In addition to using the solutions discussed in this section, note that there
    are several other ways to test network connectivity inside the lab network environment.
    Feel free to experiment with other tools such as **telnet**, **nmap**, and **traceroute**
    when troubleshooting network connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should have a better idea of how the network is set up and
    configured. In the next section, we will proceed with setting up and configuring
    the attacker VM instance to prepare it for the penetration testing simulation
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you are planning to take a break for more than an hour, it might be a good
    idea to clean up and delete the lab environment first (refer to the *Cleaning
    up* section at the end of this chapter) and then bring it back up when you can
    continue working on the succeeding sections of this chapter. This will help you
    avoid paying for the time several unused cloud resources are running. While the
    IP addresses of the resources in the lab environment may change (after bringing
    the lab environment back up), the overall network and security configuration of
    the lab environment should more or less be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the attacker VM instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be setting up our attacker EC2 instance. Compared to
    *[Chapter 4](B19755_04.xhtml)*, *Setting Up Isolated Penetration Testing Lab Environments
    on GCP*, and *[Chapter 5](B19755_05.xhtml)*, *Setting Up Isolated Penetration
    Testing Lab Environments on Azure*, our attacker instance setup in this chapter
    will be much simpler as we will only work with a Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, let’s proceed with setting up the attacker VM instance:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the list of EC2 instances (using the sidebar). Toggle the checkbox
    *on* to select **vm-kali** and then click the **Connect** button. This will redirect
    you to the **Connect to** **instance** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the last tab (**EC2 serial console**), click the **Connect** button to access
    the instance via the **EC2** **serial console**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Inside the serial console, if you are seeing a blank black screen, simply press
    the *Enter* key to see the **root@kali:~#** command prompt. If you are having
    issues accessing the attacker VM instance, **vm-kali**, feel free to reboot the
    EC2 instance and then try accessing it again via the EC2 serial console. In addition
    to this, make sure that there are no other open sessions to the instance that
    could potentially interfere with the serial console connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will be using Metasploit later, we’ll need to verify if we can use
    **msfconsole** inside the attacker VM instance. That said, let’s run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running this command will return **msfconsole not found**. Looks like we need
    to do some essential installation and setup work first!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s update the package lists and then install the default set of packages
    for Kali Linux using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Feel free to tweak the installation and setup commands as needed (just in case!).
    If these commands worked just fine, then we can proceed with the next set of steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This step may take 20-30 minutes to complete. Feel free to check the following
    link while waiting: [https://www.kali.org/docs/general-use/metapackages/](https://www.kali.org/docs/general-use/metapackages/).
    Once installation has finished, feel free to run the **clear** command to clear
    the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the **which msfconsole** command again to verify if we can use **msfconsole**
    inside the attacker VM instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should return **/usr/bin/msfconsole**. Looks like we’re ready for showtime!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s prepare the **username.txt** and **passwords.txt** files we will
    use to perform a sample SSH brute-force attack. Let’s start by creating two blank
    files using the **touch** command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to open the empty **/root/usernames.txt** file using
    Vim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Feel free to type **:set nu** and then press the *Enter* key to show the line
    numbers inside the editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, press the *i* key to switch to **insert mode** so that we can edit the
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In case you have forgotten already, **insert mode** in Vim allows us to type
    and make changes as we would in a regular text editor. In this mode, we can freely
    add, delete, or modify characters without affecting the surrounding text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type or paste the following block of code into our **usernames.txt** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have an intentionally simplified list of usernames to speed up the
    simulation process. In real penetration testing activities, we would use a more
    extensive list of usernames. This would include commonly used usernames, default
    usernames specific to certain systems or applications, and, potentially, custom
    usernames.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press the *Esc* key to switch to **normal mode**. Type **:wq!**. Press *Enter*
    afterward. This will save the changes you’ve made to **usernames.txt** and then
    exit Vim as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To refresh your memory, **normal mode** in Vim allows us to navigate through
    the text, execute commands, and perform various operations on the file. In this
    mode, specific keystrokes (such as **:wq!**) can be used to move the cursor, search
    for text, copy and paste, and perform editing actions such as deleting, replacing,
    and undoing changes. For instance, **w** represents the *write* command (which
    saves changes to the file), and **q** represents the *quit* command (which exits
    the editor). Finally, the exclamation point, **!**, is simply an optional modifier
    that forces the command to execute, even if there are unsaved changes along with
    other warnings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to open the empty **/root/passwords.txt** file using
    Vim:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Feel free to type **:set nu** and then press the *Enter* key to show the line
    numbers inside the editor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, press the *i* key to switch to **insert mode** so that we can edit the
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type or paste the following block of code into our **passwords.txt** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have an intentionally simplified list of passwords to speed up the
    simulation process later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press the *Esc* key to switch to **normal mode**. Type **:wq!**. Press *Enter*
    afterward. This will save the changes you’ve made to **passwords.txt** and then
    exit Vim as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have everything ready, we can proceed with performing a penetration
    testing simulation inside our lab environment!
  prefs: []
  type: TYPE_NORMAL
- en: Simulating penetration testing in the isolated network environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that our lab environment in AWS has been set up successfully, we can now
    proceed with having a penetration testing simulation to verify that everything
    has been configured correctly. Of course, we will work with a simplified penetration
    testing process as our primary goal is to assess if the lab environment has been
    set up and configured properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start the simulation, let’s quickly discuss the relevant concepts,
    terminologies, and tools we need to know for this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network pivoting**: Network pivoting refers to the technique of using a compromised
    system as a gateway to access other interconnected systems or segments within
    a network. Using various network pivoting techniques and tools, an attacker can
    extend their reach, navigate through internal resources, and potentially escalate
    privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lateral movement**: Lateral movement refers to the act of an attacker moving
    horizontally across systems within the same network (or domain) after gaining
    initial access. It involves exploiting vulnerabilities, leveraging credentials,
    and using various techniques to access and compromise additional systems within
    the same environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meterpreter**: Meterpreter is an advanced payload within the Metasploit Framework
    that provides an extensive range of capabilities, including interactive command
    execution, privilege escalation, and network pivoting. Leveraging a Meterpreter
    session provides the attacker with an interactive shell that helps with various
    information gathering and advanced post-exploitation tasks for ethical hacking
    requirements. We can think of a Meterpreter session as an advanced SSH shell with
    several additional powerful capabilities specifically designed for penetration
    testing and security research.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metasploit post/multi/manage/autoroute module**: The **post/multi/manage/autoroute**
    module is a specialized module within the Metasploit Framework that helps establish
    network routes from compromised systems to other target subnets. This module is
    particularly useful for lateral movement and network pivoting during post-exploitation
    activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we delve deeper into cybersecurity, we will encounter other advanced methods
    and techniques for network pivoting and lateral movement. There’s more to learn,
    but these should do the trick for now!
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is unethical and illegal to attack cloud resources owned by another user
    or company. Before proceeding, make sure you read the *Examining the considerations
    when building penetration testing lab environments in the cloud* section of *[Chapter
    1](B19755_01.xhtml)*, *Getting Started with Penetration Testing Labs in the Cloud*,
    since we will be simulating the attack process to validate if misconfigurations
    and vulnerabilities present in the applications and services running in the target
    VM instance are exploitable.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, this section is divided into the following subparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Part 1 of 3 – Obtaining the* *first flag*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 2 of 3 – Pivoting to attack* *other resources*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Part 3 of 3 – Using the Reachability Analyzer to validate* *network connectivity*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these aspects in mind, we can now start the penetration testing simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 3 – Obtaining the first flag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuing where we left off in the previous section, let’s check and scan the
    open ports on the first target EC2 instance (**target-vm-01**):![](image/B19755_06_017.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.17 – Scanning the first target instance with Nmap
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similar to what is shown in *Figure 6**.17*, we’ll initiate the Nmap scan from
    the attacker instance (**vm-kali**), which is deployed in another VPC. Make sure
    that you can access and run commands inside the attacker instance via the **EC2**
    **serial console**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you are ready to perform the scan, run the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you replace **<TARGET VM 01 PRIVATE IP>** with the private IP address
    of the first target VM instance. If you are wondering where you can get this value,
    it’s probably in the text editor on your local machine (after you copied the output
    values to the text editor after running the **terraform apply** command earlier):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_018.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.18 – Result after running the nmap command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After a few seconds, we should see the results that are returned after running
    this command. We should see that port **22** is open, similar to what is shown
    in *Figure 6**.18*!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that the private IP address of the first target machine
    we used in our example (in *Figure 6**.18*) has changed! Behind the scenes, the
    lab environment used in this chapter was destroyed and rebuilt (a couple of times)
    to manage the cost of running the lab during long periods of inactivity. That
    said, the private IP address of an EC2 instance should remain the same unless
    the instance has been deleted and then recreated. On your end, make sure you use
    the actual private IP address values of your EC2 instances as you will most likely
    get a different IP address value after running the **terraform apply** and **terraform**
    **show** commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, execute the following command to launch the Metasploit Framework console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will launch the Metasploit Framework console, similar to what we have
    in *Figure 6**.19*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_019.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.19 – The Metasploit Framework console
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that you might get a different loading screen (or loading text) after running
    **msfconsole**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It may take a minute or two for **msfconsole** to be ready.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to search for the **auxiliary/scanner/ssh/ssh_login**
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following results:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_020.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.20 – Results after running search ssh_login
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we have two matching modules – **SSH Login Check Scanner** (**auxiliary/scanner/ssh/ssh_login**)
    and **SSH Public Key Login** **Scanner** (**auxiliary/scanner/ssh/ssh_login_pubkey**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, run the following command to select and use the **auxiliary/scanner/ssh/ssh_login**
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After running the command, our prompt should change to **auxiliary(scanner/ssh/ssh_login)
    >**, indicating that we have successfully selected the auxiliary SSH login scanner
    module. From here, we can configure the module options and execute the scanner
    to check if we can gain access to the target system using different username and
    password combinations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s quickly check the settings and options we have using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return a list of module options, similar to what is shown in *Figure
    6**.21*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_021.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.21 – Output after executing the show options command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Out of these options, we will set the following values: **USER_FILE** (not
    shown in the screenshot) for the filename where the usernames are stored, **PASS_FILE**
    for the filename where the passwords are stored, **RHOSTS** (not shown in the
    screenshot) for the target resource(s) to be scanned by the SSH login scanner
    module, **THREADS** (not shown in the screenshot) for the number of threads, and
    **VERBOSE** (not shown in the screenshot) for the verbosity level.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following commands (one command at a time) to configure our scanner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you replace **<TARGET VM 01 PRIVATE IP>** with the private IP address
    of the first target EC2 instance (**target-vm-01**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when specifying the **RHOSTS** configuration value as we do not want
    to accidentally attack a random resource outside of our lab environment.
  prefs: []
  type: TYPE_NORMAL
- en: With everything ready, let’s proceed with running the SSH login scanner:![](image/B19755_06_022.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.22 – Scanning the first target instance with the SSH login scanner
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Like the Nmap scan we performed previously, we will scan the first target EC2
    instance (**target-vm-01**) using the SSH login scanner from the attacker instance
    (**vm-kali**), similar to what is shown in *Figure 6**.22*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you are ready to perform the scan, run the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will yield the following set of logs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_023.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.23 – Logs after running the SSH login scanner
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After several failed attempts, we can see that we were able to successfully
    authenticate using **adminuser** as the username and **password** as the password!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This step may take a few minutes to complete. Feel free to grab a cup of coffee
    or tea while waiting!
  prefs: []
  type: TYPE_NORMAL
- en: 'List the existing sessions by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return a single active session, similar to what is shown in *Figure
    6**.24*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_024.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.24 – List of sessions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we have the **Connection** column, which shows us a few additional details
    about the active session (that is, the attacker instance is connected to the first
    target instance).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to interact with the first session (ID = 1):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow you to interact with the session (to the first VM instance,
    **vm-target-01**) and execute commands within it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you are inside the session, run the following command to check the username
    of the current user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_025.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.25 – Result after using the whoami command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *Figure 6**.25*, we can see that running the **whoami** command yields **adminuser**
    as output, indicating that we are currently logged in as the **adminuser** user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Elevate privileges to **root** by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Wasn’t that a bit too easy? Looks like **passwordless sudo** allowed us to use
    the **su** (switch/substitute user) command to switch to the **root** account
    without requiring the root user’s password. Passwordless sudo is more common than
    you might think as system administrators and engineers often leverage it to streamline
    automated tasks and ensure operational convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to check the username of the current user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_026.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.26 – Result after using the whoami command after sudo su
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *Figure 6**.26*, we can see that running the **whoami** command (after **sudo
    su**) yields the **root** as the output, indicating that we are currently logged
    in as the **root** user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have root access, let’s locate the first flag by running the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will search the entire filesystem for files starting with **flag**. After
    a few minutes, we should get a list of results that includes a **/****root/flag.txt**
    file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Looks like we found the flag file!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s check the contents of **/root/flag.txt**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us **FLAG # 1!**. Good job!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, press *Ctrl* + *Z* to run the session in background mode. When prompted
    with **Background session 1? [y/N]**, enter **y** to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that it should be *Ctrl* + *Z* (background session) and *not* *Ctrl* +
    *C* (abort session).
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 of 3 – Pivoting to attack other resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s list the existing sessions by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command should return a single session connecting the attacker
    instance (**vm-kali**) and the first target instance (**target-vm-01**):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_027.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.27 – A session connecting the attacker instance and the first target
    instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, we have one session connecting the attacker instance (**vm-kali**)
    with the first target instance (**target-vm-01**), similar to what is shown in
    *Figure 6**.27*. In this context, a **session** refers to an active and interactive
    connection between the attacker’s machine (where Metasploit is running) and a
    compromised target system. When a successful exploit or payload is delivered to
    a vulnerable target, it can establish a session, granting the attacker various
    levels of control and access to the compromised system. In our case, after running
    the SSH Login Scanner on the first target instance (**target-vm-01**) previously,
    a session was established automatically between the attacker instance (**vm-kali**)
    and the first target instance (**target-vm-01**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, run the following commands (one command at a time) to use the first session
    to prepare an upgraded **meterpreter** session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should open a second session, similar to what we have in *Figure 6**.28*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_028.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.28 – Opening an upgraded session
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Since we executed **sessions -i 2**, we will be able to use and interact with
    the upgraded session (known as a Meterpreter session) and execute additional commands
    within it. Compared to a “normal” shell, the Metasploit **Meterpreter** session
    offers a wider range of capabilities and features, including filesystem access,
    privilege escalation, process manipulation, pivoting, and more. These enhancements
    over a normal shell allow for advanced post-exploitation activities such as lateral
    movement within the network, persistence on the compromised system, data exfiltration,
    and comprehensive reconnaissance. With Meterpreter, penetration testers and ethical
    hackers have a more powerful toolset at their disposal that enables them to perform
    more thorough assessments and simulate real-world attack scenarios:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_029.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.29 – Two sessions connecting the attacker instance and the first target
    instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we have two sessions connecting the attacker instance and the first target
    instance (with one of the sessions being a Meterpreter session).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s check the network configuration using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_030.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.30 – Results after running ipconfig
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given the following configuration, we should be able to derive the **SUBNET**
    value of **10.0.1.0** (which we’ll use later when we configure the **autoroute**
    module).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, press *Ctrl* + *Z* to run the session in background mode. When prompted
    with **Background session 2? [y/N]**, enter **y** to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following commands to search for, select, and use the **autoroute**
    module (one command at a time):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s quickly check the settings and options we have using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return a list of module options, similar to what is shown in *Figure
    6**.31*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_031.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.31 – Output after executing the show options command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will specify the configuration values for the **SESSION** and **SUBNET**
    module options shortly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Configure the **SESSION** setting and set it to **2**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the **SUBNET** setting and set it to **10.0.1.0/24**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s quickly check the settings and options we have using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return a list of module options, similar to what we have in *Figure
    6**.32*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_032.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.32 – Output after executing the show options command
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Looks like our **post/multi/manage/autoroute** module configuration is ready
    to go!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s execute the **autoroute** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield the following set of logs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.33 – Logs after running the autoroute module
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have executed the **autoroute** module, we should be able to pivot
    and reach other resources or networks that are accessible from the first target
    VM instance (**target-vm-01**).
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 of 3 – Obtaining the second flag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to select and use the **auxiliary/scanner/portscan/tcp**
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, we will be scanning the second target instance for open ports, similar
    to what is shown in *Figure 6**.34*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_034.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.34 – Using the TCP port scanner on the second target instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Even if the attacker instance (**vm-kali**) does not have direct access to the
    second target EC2 instance, we should be able to run the TCP port scanner on the
    second target EC2 instance (**target-vm-02**) *through* the first target EC2 instance
    (**target-vm-01**). *Amazing, right?*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that only the traffic from the first target instance (**target-vm-01**)
    is allowed by the security group of the second target instance (**target-vm-02**).
    This means that we won’t be able to *directly* scan the second target instance
    (**target-vm-02**) from the attacker instance (**vm-kali**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the **RHOSTS** setting and set it to the private IP address of the
    second target VM instance (**target-vm-02**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you replace **<TARGET VM 02 PRIVATE IP>** with the private IP address
    of the second target VM instance. If you are wondering where you can get this
    value, it’s *probably* in the text editor on your local machine (after you copied
    the output values to the text editor after running the **terraform apply** command
    earlier).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when specifying the **RHOSTS** configuration value as we do not want
    to accidentally attack a random resource outside of our lab environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use the following command to proceed with the scan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield a set of logs, similar to what we have in *Figure 6**.35*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_035.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.35 – Results after running the scanner
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After running the scanner, we can see that port **22** of the second target
    VM instance (**target-vm-02**) is open.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This step may take around 3-5 minutes to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command using the **auxiliary/scanner/ssh/ssh_login** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure the **RHOSTS** setting and set it to the private IP address of the
    second target VM instance (**target-vm-02**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you replace **<TARGET VM 02 PRIVATE IP>** with the private IP address
    of the second target VM instance (**target-vm-02**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when specifying the **RHOSTS** configuration value as we do not want
    to accidentally attack a random resource outside of our lab environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s verify if we’ve set all the relevant options and configuration
    settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return a list of module options, similar to what we have in *Figure
    6**.36*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_036.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.36 – show options
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given that we have just set and updated the **RHOSTS** value to the private
    IP address of the second VM instance, all relevant configuration settings have
    been set already (since we are reusing most of the previous configurations that
    we set when we first used the module).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let’s proceed with running the SSH login scanner on the second target EC2
    instance (**target-vm-02**):![](image/B19755_06_037.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 6.37 – Using the SSH login scanner on the second target instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Even if the attacker instance (**vm-kali**) does not have direct access to the
    second target EC2 instance, we should be able to run the SSH login scanner on
    the second target EC2 instance (**target-vm-02**) *through* the first target EC2
    instance (**target-vm-01**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you are ready to perform the scan, run the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will yield the following set of logs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_038.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.38 – Logs after running the SSH login scanner on the second target
    instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After trying several username and password combinations, we can see that we
    were able to successfully authenticate using **adminuser2** as the username and
    **password** as the password!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This step may take around 3-5 minutes to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'List the existing sessions by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return three active sessions, similar to what is shown in *Figure
    6**.39*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_039.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.39 – List of active sessions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here, we can see that we have a third active session, which allows us to access
    (and control) the second target instance (**vm-target-02**):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_040.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.40 – A new session that accesses the second target instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, we have two sessions connecting the attacker instance (**vm-kali**)
    with the first target instance (**target-vm-01**) and one session connecting the
    first target instance with the second target instance (**target-vm-02**).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s access the second target instance (**target-vm-02**) using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow us to interact with the session and execute commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to check the username of the current user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should yield **adminuser2** as the output, indicating that we are currently
    logged in as the **adminuser2** user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Elevate privileges to **root** by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Looks like passwordless sudo has been configured for **adminuser2**! If you
    are wondering how this was configured, simply locate and check the **user_data**
    attribute of the **aws_instance** resource blocks in our Terraform configuration
    code (in CloudShell).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to check the username of the current user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_06_041.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 6.41 – Result after running the whoami command after sudo su
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *Figure 6**.41*, we can see that running the **whoami** command (after **sudo
    su**) yields **root** as the output, indicating that we are currently logged in
    as the **root** user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s locate the second flag by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will search the entire filesystem for files starting with **flag**. After
    a few minutes, we should get a list of results that includes a **/****root/flag.txt**
    file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Looks like we found the flag file!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This step may take around 2-4 minutes to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s check the contents of **/root/flag.txt**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us **FLAG #** **2!**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, press *Ctrl* + *Z* to run the session in background mode. When prompted
    with **Background session 3? [y/N]**, enter **y** to proceed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, let’s exit **msfconsole** using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s pretty much it! At this point, we have completed the penetration testing
    simulation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Right now, you are probably excited to try out other pivoting techniques! Given
    that we have automated the setup process, we can simply run the following command
    to rebuild the target environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Running this command will destroy and recreate the resources identified by **<RESOURCE
    ADDRESS>**, along with other resources related to or dependent on it. Given that
    penetration testing activities may leave the infrastructure in an unstable or
    misconfigured state, rebuilding the infrastructure will return it to the desired
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wait a minute... we are not done yet! Cleaning up the cloud resources we created
    or deployed is a crucial step when working with penetration testing lab environments.
    If we don’t clean up and delete the resources we created right away, we might
    end up paying for unused cloud resources.
  prefs: []
  type: TYPE_NORMAL
- en: At a minimum, we will be paying for the time the **t3.medium** EC2 instance
    (for the attacker instance) and the two **t2.micro** EC2 instances (for the target
    instances) are running. Note that there are other costs we should consider as
    well, including data transfer fees, storage costs for any persistent data used
    by the instances (such as EBS volumes attached to the EC2 instances), potential
    charges for additional AWS services utilized in the lab environment (for example,
    monitoring logs), and any applicable taxes or fees associated with AWS usage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the overall cost when running these resources depends on several parameters,
    it is best to refer to the pricing documentation page provided by the cloud platform:
    [https://aws.amazon.com/ec2/pricing/on-demand/](https://aws.amazon.com/ec2/pricing/on-demand/).
    You may also use the **AWS Pricing Calculator** to help you estimate the cost
    of running resources on AWS. You can access the AWS Pricing Calculator here: [https://calculator.aws/](https://calculator.aws/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, let’s proceed with deleting the resources we created in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the AWS CloudShell Terminal, navigate to the **~/pentest_lab** directory
    and then use **terraform destroy** to clean up the resources we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Feel free to run the **terraform destroy** command a few times in case some
    resources fail to delete (or take a bit of time to delete). Alternatively, you
    may delete resources manually using the user interface if all else fails.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This step may take 10-15 minutes to complete. Feel free to grab a snack while
    waiting!
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the resources have been destroyed successfully using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should return an empty response since all the resources should have been
    deleted successfully.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you leverage the **AWS Billing Dashboard** to conduct a comprehensive
    audit of your AWS account. It offers features such as **Cost Explorer** for visualizing
    spending patterns, detailed billing reports for service breakdowns, and budgeting
    tools with alerts to help users proactively manage expenses. Using the different
    features of the AWS Billing Dashboard will help ensure that all resources have
    been properly deleted and minimize the risk of unintended costs.
  prefs: []
  type: TYPE_NORMAL
- en: That’s pretty much it! At this point, we should have a good idea of how to prepare
    penetration testing lab environments on AWS. Feel free to tweak the Terraform
    configuration code and evolve the current lab environment setup so that you have
    more target resources and subnets (along with a more complex network configuration
    setup).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed how to set up a pivoting lab on AWS where we can
    practice pivoting techniques. We started by using Terraform to automatically build
    a simple environment with an attacker instance, along with two target instances.
    We then tested the network connectivity and security of the lab to validate the
    network configuration specified in the Terraform code. Lastly, we performed a
    penetration testing simulation to verify if the lab environment had been set up
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve finished this chapter, we will shift our focus to preparing an
    IAM privilege escalation lab environment in the next chapter. If you are wondering
    how an IAM privilege escalation lab is (mis)configured, then the next chapter
    is for you!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For additional information on the topics covered in this chapter, you may find
    the following resources helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Amazon Virtual Private Cloud – What is VPC* *peering?* ([https://docs.aws.amazon.com/vpc/latest/peering/what-is-vpc-peering.html](https://docs.aws.amazon.com/vpc/latest/peering/what-is-vpc-peering.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Amazon Virtual Private Cloud – What is Network Access* *Analyzer?* ([https://docs.aws.amazon.com/vpc/latest/network-access-analyzer/what-is-network-access-analyzer.html](https://docs.aws.amazon.com/vpc/latest/network-access-analyzer/what-is-network-access-analyzer.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*New – VPC Reachability* *Analyzer* ([https://aws.amazon.com/blogs/aws/new-vpc-insights-analyzes-reachability-and-visibility-in-vpcs/](https://aws.amazon.com/blogs/aws/new-vpc-insights-analyzes-reachability-and-visibility-in-vpcs/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AWS Architecture Blog – Reduce Cost and Increase Security with Amazon VPC*
    *Endpoints* ([https://aws.amazon.com/blogs/architecture/reduce-cost-and-increase-security-with-amazon-vpc-endpoints/](https://aws.amazon.com/blogs/architecture/reduce-cost-and-increase-security-with-amazon-vpc-endpoints/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AWS Architecture Blog – One to Many: Evolving VPC* *Design* ([https://aws.amazon.com/blogs/architecture/one-to-many-evolving-vpc-design/](https://aws.amazon.com/blogs/architecture/one-to-many-evolving-vpc-design/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AWS re:Invent 2022 – Advanced VPC design and new Amazon VPC* *capabilities*
    ([https://www.youtube.com/watch?v=cbUNbK8ZdA0](https://www.youtube.com/watch?v=cbUNbK8ZdA0))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Upgrading shells to* *Meterpreter* ([https://docs.metasploit.com/docs/pentesting/metasploit-guide-upgrading-shells-to-meterpreter.html](https://docs.metasploit.com/docs/pentesting/metasploit-guide-upgrading-shells-to-meterpreter.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pivoting in* *Metasploit* ([https://docs.metasploit.com/docs/using-metasploit/intermediate/pivoting-in-metasploit.html](https://docs.metasploit.com/docs/using-metasploit/intermediate/pivoting-in-metasploit.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Network* *Segmentation* ([https://www.vmware.com/topics/glossary/content/network-segmentation.html](https://www.vmware.com/topics/glossary/content/network-segmentation.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Exploring Advanced Strategies and Best Practices in Lab Environment
    Design'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will explore the various strategies and best practices for
    building penetration testing lab environments in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Chapter 7](B19755_07.xhtml)*, *Setting Up* *an IAM Privilege Escalation Lab*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[Chapter 8](B19755_08.xhtml)*, *Designing and Building a Vulnerable Active
    Directory Lab*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*[Chapter 9](B19755_09.xhtml)*, *Recommended Strategies and Best Practices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
