- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommended Strategies and Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Great job reaching the last chapter of this book! The last few chapters have
    been focused primarily on giving you the hands-on experience needed to help you
    build more complex penetration testing labs in the cloud. If you took the time
    to understand what’s happening in the hands-on examples and solutions in this
    book, then you should be a bit more confident about what you can accomplish with
    your current knowledge and skills. In this chapter, we will build on top of what
    you learned in the previous chapters, and we will explore how we can take things
    to the next level!
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the complexity of penetration testing lab environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Generative AI for estimating penetration testing lab costs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unleashing the power of AI-powered tools to accelerate automation script development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AI-powered solutions to generate and explain IaC template code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing relevant considerations and practical strategies when building and
    automating lab environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these in mind, let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start, you must have the following ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio Code** (**VS Code**) installed and set up on your local machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub Copilot** set up and configured with VS Code – sign up for a free
    trial subscription (**Copilot for Individuals**) using the following link: [https://github.com/features/copilot](https://github.com/features/copilot).
    Make sure that the **GitHub Copilot extension** is installed and set up completely.
    You may check the following link for more information: [https://docs.github.com/en/copilot/getting-started-with-github-copilot?tool=vscode](https://docs.github.com/en/copilot/getting-started-with-github-copilot?tool=vscode).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub Copilot Labs** set up and configured with VS Code – sign up using
    the following link: [https://githubnext.com/projects/copilot-labs/](https://githubnext.com/projects/copilot-labs/).
    Make sure that the **GitHub Copilot Labs extension** is installed and set up completely.
    You may check the following link for more information: [https://marketplace.visualstudio.com/items?itemName=GitHub.copilot-labs](https://marketplace.visualstudio.com/items?itemName=GitHub.copilot-labs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon CodeWhisperer** set up and configured with VS Code – we will be utilizing
    **CodeWhisperer Professional** for a single user ([https://aws.amazon.com/codewhisperer/pricing/](https://aws.amazon.com/codewhisperer/pricing/)).
    Before we install and set up the CodeWhisperer extension in VS Code, we need to
    (1) enable **IAM Identity Center** and create an **AWS organization**, (2) create
    an **IAM organization user**, (3) set up CodeWhisperer for a single user, and
    (4) set up the **AWS Toolkit** for VS Code ([https://aws.amazon.com/visualstudiocode/](https://aws.amazon.com/visualstudiocode/)).
    Make sure that the **CodeWhisperer extension** is installed and set up completely.
    You may check the following link for more information: [https://docs.aws.amazon.com/codewhisperer/latest/userguide/whisper-setup-prof-devs.html](https://docs.aws.amazon.com/codewhisperer/latest/userguide/whisper-setup-prof-devs.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tabnine Pro** set up and configured with VS Code – sign up for a free trial
    subscription (**Pro**) using the following link: [https://www.tabnine.com/pricing](https://www.tabnine.com/pricing).
    Make sure that the **Tabnine extension** is installed and set up completely. You
    may check the following link for more information: [https://www.tabnine.com/install/vscode](https://www.tabnine.com/install/vscode).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A **ChatGPT Plus** account – sign up for an account using the following link:
    [https://chat.openai.com/auth/login](https://chat.openai.com/auth/login). Since
    we will be using the **Advanced Data Analysis** feature in this chapter, we would
    need to upgrade our plan to **ChatGPT Plus** so that we can access GPT-4 along
    with other beta features exclusively available to ChatGPT Plus users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may proceed with the next steps once these are ready. If you don’t intend
    to commit to these subscriptions long term, feel free to unsubscribe or downgrade
    your current plan for each of these subscriptions after completing the hands-on
    examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid any conflict that may arise with the newly added extensions, you can
    temporarily disable all currently installed extensions in VS Code. *How?* Click
    on the **Extensions** icon in the sidebar on the left side of the VS Code window.
    In the **Extensions** view, click the three dots (**···**) button and select **Disable
    All Installed Extensions** from the list of options available in the context menu.
    Do not worry as we can easily enable these extensions later on. For more information,
    feel free to check the following link: [https://code.visualstudio.com/docs/editor/extension-marketplace](https://code.visualstudio.com/docs/editor/extension-marketplace).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code and other files used for each chapter are available in this
    book’s GitHub repository: [https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud](https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud).'
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the complexity of penetration testing lab environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have been to a bouldering (rock-climbing) gym before, you would realize
    how similar a penetration testing lab environment is to an indoor facility filled
    with climbing walls of varying difficulty. Just like how indoor rock-climbing
    gyms provide climbers with a controlled environment to exercise and practice their
    climbing skills, penetration testing labs provide cybersecurity professionals
    with an isolated environment to practice and perfect their hacking techniques.
    Both environments challenge users with various types of scenarios with increasing
    complexity and difficulty to push their limits. Given that these environments
    have been built to mimic real-world challenges and obstacles, we should expect
    these environments to evolve and grow in complexity so that users are presented
    with new challenges to solve.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss how we can further evolve and increase the
    complexity of the penetration testing lab environments we have built in the previous
    chapters of this book. Let’s start with the lab environment we have prepared in
    *[Chapter 4](B19755_04.xhtml)*, *Setting Up Isolated Penetration Testing Lab Environments*
    *on GCP*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – High-level diagram of our penetration testing lab environment in
    GCP
  prefs: []
  type: TYPE_NORMAL
- en: In this lab setup, we have an isolated network for securing the lab environment
    resources from external attacks. This isolated network environment consists of
    two VPCs along with a VPC peering connection bridging these VPC networks. We have
    a single target VM instance deployed inside the first VPC while we have the attacker
    VM instance in the other VPC. Inside the target VM instance, we have a container
    running an intentionally vulnerable application called the **OWASP Juice Shop**.
    While we had the opportunity to add more vulnerable services, applications, and
    containers inside the VM instance, we decided to keep things simple by having
    only a single running container to reduce the setup work required. In addition
    to this, we could have launched more VM instances inside the VPC as well. *What
    if we had more time (and more pages to spare) to set up a more complex* *lab environment?*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s imagine a hypothetical lab environment (similar to what is shown in *Figure
    9**.2*) consisting of various cloud resources running inside a **Google Cloud
    Platform** (**GCP**) account. In this new lab environment, we have three VM instances
    running vulnerable services, applications, and containers inside them: (1) **vm-target**,
    (2) **vm-target-02**, and (3) **vm-target-03**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – A more complex version of the penetration testing lab environment
  prefs: []
  type: TYPE_NORMAL
- en: The first target VM instance (**vm-target**) is similar to the target VM instance
    we prepared in *[Chapter 4](B19755_04.xhtml)*, *Setting Up Isolated Penetration
    Testing Lab Environments on GCP*. To make things a bit more exciting, we will
    also run a few more containers running vulnerable applications and services inside
    this instance (**vm-target**). In addition to this, similar to what we set up
    in *[Chapter 5](B19755_05.xhtml)*, *Setting Up Isolated Penetration Testing Lab
    Environments on Azure*, we can configure some of these containers to run with
    the **--privileged** flag. This will allow lab users to practice container breakout
    techniques as well. The second target VM instance (**vm-target-02**) is a new
    VM instance running a different operating system. This instance would be running
    various vulnerable services without any containers involved. We also have a third
    target VM instance (**vm-target-03**) running a different set of vulnerable applications
    and services. The network configuration is configured to not allow direct access
    from the attacker VM instance to the third target VM instance (**vm-target-03**).
    This will force lab users to compromise the second target VM instance (**vm-target-02**)
    first and use that to access the third target VM instance (**vm-target-03**) similar
    to the pivoting lab we set up in *[Chapter 6](B19755_06.xhtml)*, *Setting Up Isolated
    Penetration Testing Lab Environments on AWS*. Finally, from the third target VM
    instance (**vm-target-03**), a Cloud Storage bucket (with a flag) can be accessed
    through a service account.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further increase the complexity of the lab environment, we can replace the
    third target VM instance (**vm-target-03**) with a vulnerable-by-design **Kubernetes**
    cluster environment similar to what we have in *Figure 9**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Including a vulnerable-by-design cluster environment
  prefs: []
  type: TYPE_NORMAL
- en: If this is your first time learning about Kubernetes, it is a popular open source
    container orchestration system that provides a framework for running resilient
    distributed systems. By setting up this vulnerable-by-design Kubernetes cluster,
    users can gain hands-on experience with various attack scenarios inside an isolated
    environment. Inside this cluster, we would have multiple scenarios involving misconfigurations,
    risks, and vulnerabilities discussed in the **OWASP Kubernetes Top 10**. These
    scenarios may include overly permissive **Role-Based Access Control** (**RBAC**)
    configurations, broken authentication mechanisms, container breakouts due to insecure
    workload configurations, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about this topic, feel free to check the following link:
    [https://owasp.org/www-project-kubernetes-top-ten/](https://owasp.org/www-project-kubernetes-top-ten/).'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a Kubernetes cluster, we could also introduce a **Windows Active
    Directory** setup similar to what is shown in *Figure 9**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Including a Windows Active Directory lab
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have two Windows VM instances similar to what we prepared in *[Chapter
    8](B19755_08.xhtml)*, *Designing and Building a Vulnerable Active Directory Lab*.
    One of the VM instances will be the domain controller (**vm-target-03**) and the
    other one will be a workstation machine (**vm-target-04**) that will be joined
    to the domain. Of course, we can add more machines to this setup and make the
    lab environment a bit more realistic. To increase the difficulty a bit, we can
    make the Windows VM instances not accessible directly from the attacker machine
    and require the second target VM instance (**vm-target-02**) to be compromised
    first, and use that to access and attack the domain controller instance (**vm-target-03**)
    and the workstation machine instance (**vm-target-04**).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When designing lab environments, it is essential that we take into account the
    penetration testing skills (or techniques) being focused on as certain lab components
    are required depending on the techniques and actions we want the lab user to perform
    inside the lab environment. In addition to this, it is important that we have
    a good idea of who will use the lab to help us identify the experience level of
    the lab users. This will help us manage the varying levels of difficulty across
    the various sections of the lab environment. That said, we can increase the complexity
    and difficulty of certain parts of the lab by adding web application firewalls
    to allow lab users to practice more advanced web penetration testing techniques.
    We can also increase the difficulty even further by adding specific resources
    such as an **intrusion prevention system** (**IPS**) for practicing evasion techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Another possibility is to have a more complex lab setup with all of these included!
    Of course, this would entail a significantly higher cost of running the cloud
    resources within the lab environment. In addition to this, we would need to invest
    a bit more time in automating the setup of the various components deployed in
    our penetration testing lab setup. At this point, you might be wondering how we
    could significantly accelerate the preparation of complex lab environments! The
    good news is that we now have AI-powered solutions that could help us in various
    types of tasks, such as estimating penetration testing lab costs, generating automation
    scripts and **Infrastructure-as-Code** (**IaC**) templates, along with explaining
    existing code written by other engineers and professionals. We’ll see this in
    action in the next sections of this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Generative AI for estimating penetration testing lab costs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way we design our penetration testing lab environments can have a significant
    impact on the overall cost of running these labs in the cloud. Certain implementations
    and variations may require more resources than others, which would lead to increased
    costs. By carefully considering the architecture of our lab setup, we can identify
    opportunities to reduce costs without compromising the quality, performance, and
    stability of our penetration testing lab environment. Estimating the associated
    costs when running these environments is another crucial aspect as this allows
    security professionals (and teams) to plan their budget and maintain a sustainable
    lab setup in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *[Chapter 6](B19755_06.xhtml)*, *Setting Up Isolated Penetration Testing
    Lab Environments on AWS*, we prepared a lab setup where we can practice network
    pivoting techniques. In case you’ve forgotten already, here’s a simplified diagram
    showing what our lab environment looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B19755_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Our lab environment setup in Chapter 6
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have an attacker VM instance running inside one VPC network and two
    target VM instances running inside another VPC network. *Have you ever wondered
    how much it would cost to run this lab environment?* While it is possible to compute
    the costs manually, we can use Generative AI tools, capabilities, and plugins
    to help us estimate and compute the costs automatically!
  prefs: []
  type: TYPE_NORMAL
- en: In *[Chapter 7](B19755_07.xhtml)*, *Setting Up an IAM Privilege Escalation Lab*,
    we had our first look into how we can use Generative AI solutions to automatically
    generate code for penetration testing simulations and activities. There’s more
    to where that came from! In this section, we will use **ChatGPT Advanced Data
    Analysis** to help us estimate the cost using the Terraform configuration files
    we used to generate a lab environment. All we need to do is input the right set
    of prompts and let the AI model generate the cost calculations and insights for
    us. Amazing, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let’s proceed with the estimation of the associated costs
    for running our lab environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to this book’s GitHub repository and locate the ZIP file we used to
    prepare the lab environment for *[Chapter 6](B19755_06.xhtml)*, *Setting Up Isolated
    Penetration Testing Lab Environments on AWS*. Feel free to use the following link
    to help you locate the ZIP file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Locate and click the **Download raw file** button (located near the **Raw**
    button in the right-hand corner of the page). This will download the **pentest_lab.zip**
    ZIP file from the GitHub repository to your local machine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In a new browser tab, access your **ChatGPT Plus** account using the following
    URL: [https://chat.openai.com/](https://chat.openai.com/). Ensure that you configure
    your account to have **Advanced data analysis** enabled before proceeding.![](image/B19755_09_06.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.6 – Enabling Advanced data analysis
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enabling **Advanced data analysis** will allow us to automate complex data computations
    and analyze valuable information from uploaded files. Yes, you heard that right!
    We can upload files and leverage the AI model’s capabilities to generate detailed
    analyses, visualize trends, and extract meaningful patterns directly from the
    uploaded data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As of writing, **Advanced Data Analysis** is in Beta. By the time you read this
    book, it may have transitioned out of the Beta phase already!
  prefs: []
  type: TYPE_NORMAL
- en: Create a new chat session and select **GPT-4** (or the latest model available
    exclusively to ChatGPT Plus users):![](image/B19755_09_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.7 – Selecting GPT-4 and Advanced Data Analysis for our chat session
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure that **Advanced Data Analysis** is selected (instead of **Default**)
    similar to what we have in *Figure 9**.7*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **+** button (highlighted in *Figure 9**.8*):![](image/B19755_09_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.8 – Uploading the pentest_lab.zip file
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Upload the **pentest_lab.zip** file we downloaded to our local machine in a
    previous step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do not press *Enter* or click the **Send a message** button yet as we will be
    specifying a prompt (in the next step).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the following prompt inside the text bar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Press the *Enter* key afterward to submit the uploaded file along with the
    prompt. This should yield a response similar to what is shown in *Figure 9**.9*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_09_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.9 – Analyzing what the ZIP file contains
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Simply enter **No need** when asked a question similar to **Would you like a
    brief overview of each** **file’s contents?**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that even with the same prompt, you may get a different set of responses
    from ChatGPT. That said, feel free to modify and adjust your prompts accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new browser tab and navigate to [https://instances.vantage.sh/](https://instances.vantage.sh/).
    This should open a website built to help compare various EC2 instance types.![](image/B19755_09_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.10 – Website built for comparing various EC2 instance types
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Export** button highlighted in *Figure 9**.10*. This will download
    an **Amazon EC2 Instance Comparison.csv** file to the **Downloads** folder (or
    alternative) of your local machine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate back to the browser tab where we have our ChatGPT session open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s compute the monthly cost of running each EC2 instance specified
    in the Terraform configuration files. Let’s do this by uploading the **Amazon
    EC2 Instance Comparison.csv** file and entering the following prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will yield the following (final) output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_09_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.11 – Breakdown of the monthly costs for the EC2 instances defined
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that ChatGPT successfully returned a breakdown of the monthly
    costs for the identified EC2 instances from the Terraform configuration files
    inside the ZIP file we uploaded earlier. To simplify things a bit, we have only
    considered the cost of running the EC2 instances in this example. Note that there
    are other costs we must take into account as well to get a more accurate monthly
    cost estimate. These include the data transfer fees, the storage costs associated
    with the EBS volumes attached to the EC2 instances, as well as the potential charges
    for using other services in the account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: By identifying which components and resources of the lab setup contribute the
    most to the overall cost, we can focus our optimization efforts on these areas
    to achieve maximum cost savings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are not planning to have the resources running for an entire month,
    let’s enter the following prompt and specify that we will only have the resources
    running for 6 hours:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should yield a response similar to what is shown in *Figure 9**.12*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_09_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.12 – Estimated cost of running the resources for 6 hours instead of
    1 month
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This time, we have the estimated cost of running the EC2 instances for 6 hours
    (instead of a month). *Cool, right?*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: One of the simplest yet most effective ways to manage costs is to ensure that
    resources are turned off or deleted when they are not actively being used. It
    is common for lab environments to consist of multiple VMs, databases, and other
    resources that contribute the most to the overall cost. By setting up automated
    scripts (that create and delete resources), we can ensure that these resources
    are running only when they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take things one step further by generating a bar chart using the following
    prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_09_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.13 – Bar chart comparing the cost associated per Terraform file
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that a significant portion of the cost comes from the resources
    defined in **network_02.tf**. Again, note that we have only considered the cost
    of running the EC2 instances when generating the bar chart.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To help us identify which blocks of code in our Terraform files have a contribution
    to the overall cost, enter the following prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_09_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.14 – Identifying which blocks of code have a contribution to the overall
    cost
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Looks like ChatGPT was able to successfully identify and provide the (simplified)
    resource blocks that have associated EC2 instance costs!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, let’s enter the following prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should return the following response:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_09_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.15 – Checking how updating the instance type affects the estimated
    cost
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In *Figure 9**.15*, we can see that the cost associated with the **vm_kali**
    resource has been updated automatically as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To accommodate various workloads, cloud providers offer instance types with
    varying performance levels and costs. By properly assessing the performance requirements
    of the applications, services, and tools that would run inside the cloud resources,
    we would be able to choose the right instance type. With this, we can make informed
    decisions to help us manage and reduce costs significantly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the initial set of resources created using the Terraform configuration
    files, we must take into account any additional resources that might be created
    by the lab environment users (while they are using the lab). What if lab environment
    users could create cloud resources that could potentially be expensive? What if
    extensive network traffic is generated by the user? In a lab environment where
    users have the capability to create cloud resources, it’s crucial to implement
    safeguards to prevent accidental or intentional overspending.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should have a good idea of how to use Generative AI solutions
    to estimate the cost of running our penetration testing lab environment in the
    cloud. The example scenario we just discussed is just one of the many practical
    applications of Generative AI. It is important to note that the capabilities of
    AI-powered solutions extend *far beyond* this example scenario! We’ll see more
    of this in the next sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Unleashing the power of AI-powered tools to accelerate automation script development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to fully automate the creation and deletion of our penetration testing
    lab environment would help us significantly reduce the cost of running these lab
    environments in the cloud. While the potential benefits are undeniable, in reality,
    *fully* *automating* the preparation of lab environments is not as easy as it
    sounds. Coding automation scripts takes time, skill, and effort, and it may sometimes
    involve an entire team of experienced (and expensive) engineers to get the job
    done properly.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe AI-powered tools can help! In addition to ChatGPT, there are many other
    AI-powered solutions available to help us significantly speed up the preparation
    of the automation scripts for building our penetration testing lab environments.
    In this section, we will take a closer look at how AI-powered tools such as **GitHub
    Copilot**, **Amazon CodeWhisperer**, and **Tabnine** can help us accelerate automation
    script development. These cutting-edge tools leverage machine learning and natural
    language processing to accelerate the coding and scripting process. These tools
    help developers by suggesting code snippets, autocompleting lines of code, and
    even generating blocks of code through comments. Amazing, right?
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you have the **GitHub Copilot**, **Amazon CodeWhisperer**, and
    **Tabnine** extensions set up (completely) as specified in the *Technical requirements*
    section at the start of this chapter. It may take around 15 minutes to set up
    and complete all the prerequisites and dependencies for these to work in VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see these AI-powered tools in action in the next set of steps.
  prefs: []
  type: TYPE_NORMAL
- en: Part 1 of 3 – Leveraging GitHub Copilot to speed up shell scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s try using GitHub Copilot to help speed up the preparation of a sample
    script that can create specific lab environment resources in our GCP account:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by making sure that all VS Code extensions are disabled. This will
    help prevent any conflict that may arise with the newly added AI-powered extensions.![](image/B19755_09_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.16 – Disabling all installed extensions in VS Code
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Extensions** icon in the sidebar on the left side of the VS Code
    window. In the **Extensions** view, click the three dots (**···**) button and
    select **Disable All Installed Extensions** from the list of options available
    in the context menu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to check [https://code.visualstudio.com/docs/editor/extension-marketplace](https://code.visualstudio.com/docs/editor/extension-marketplace)
    for more information about this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s enable the GitHub Copilot extension. In the **EXTENSIONS: MARKETPLACE**
    view, we should see a search bar at the top. Type **GitHub Copilot** in this search
    bar to locate the extension we need to enable.![](image/B19755_09_17.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.17 – Enabling the GitHub Copilot extension
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Scroll through the list of extensions to find the **GitHub Copilot** extension.
    Right-click on the extension and then select **Enable** from the list of options
    available in the context menu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the setup is complete before proceeding. In some cases, VS Code
    may prompt you to restart the application. If prompted, go ahead and restart VS
    Code.
  prefs: []
  type: TYPE_NORMAL
- en: With our AI-powered extension enabled already, let’s proceed by creating a new
    file named **copilot.sh**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following in the first line of our script file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following line of code (in the second or third line):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure to replace **<BUCKET NAME>** with a globally unique bucket name (for
    a bucket that is yet to be created).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the fourth or fifth line, type the following single-line comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, our **copilot.sh** script file should look similar to what we
    have in *Figure 9**.18*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_09_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.18 – Typing a single-line comment
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, you can see that we’ve specified **my-sample-bucket-abc123** for the **<BUCKET
    NAME>** placeholder value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *Enter*. You should see the following suggested code generated automatically:![](image/B19755_09_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.19 – Copilot suggesting a line of code
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that GitHub Copilot suggested **gsutil mb gs://$BUCKET_NAME**
    for the next line in our script file!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that you might get a different suggestion while working on this example.
  prefs: []
  type: TYPE_NORMAL
- en: Press *Tab* to accept the suggestion and complete the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the following line of code (after the existing lines of code in our
    file):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, type the following single-line comment (in a new line):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Press *Enter*. You should see the following suggested code generated automatically:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_09_20.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.20 – Copilot suggesting a line of code
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that GitHub Copilot suggested **gsutil cp flag.txt gs://$BUCKET_NAME**
    for the next line in our script file!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Do not press *Tab* yet as we will be checking the other suggestions first!
  prefs: []
  type: TYPE_NORMAL
- en: Press the right arrow key (*→*) a few times to see the other suggestions, similar
    to what we have in *Figure 9**.21*:![](image/B19755_09_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.21 – Checking the other suggestions using the arrow key
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *Tab* to accept the suggestion and complete the code. At this point, we
    have a small script ready for use! It is important to note that the code generated
    by the AI tool/extension may not always work. Make sure to review, run, and test
    the code generated thoroughly before using it in a real project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t discuss all the features of GitHub Copilot in this book. Feel free
    to check the following video (*Get Started with the Future of Coding: GitHub Copilot*)
    for more information about this topic: [https://www.youtube.com/watch?v=Fi3AJZZregI](https://www.youtube.com/watch?v=Fi3AJZZregI).'
  prefs: []
  type: TYPE_NORMAL
- en: Part 2 of 3 – Accelerating Python coding with Amazon CodeWhisperer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s try using Amazon CodeWhisperer to assist us while we code a portion
    of the script we prepared in *[Chapter 7](B19755_07.xhtml)*, *Setting Up an IAM
    Privilege* *Escalation Lab*:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by making sure that all VS Code extensions are disabled to avoid
    any conflict that may arise with the newly added AI-powered extensions. Click
    on the **Extensions** icon in the sidebar on the left side of the VS Code window.
    In the **Extensions** view, click the three dots (**···**) button and select **Disable
    All Installed Extensions** from the list of options available in the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s enable the **AWS Toolkit** extension. In the **EXTENSIONS: MARKETPLACE**
    view, we should see a search bar at the top. Type **CodeWhisperer** in this search
    bar to locate the extension we need to enable.![](image/B19755_09_22.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.22 – Enabling the AWS Toolkit extension
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Scroll through the list of extensions to find the **AWS Toolkit** extension.
    Right-click on the extension and then select **Enable** from the list of options
    available in the context menu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When prompted with the message **Connection expired. To continue using CodeWhisperer,
    connect with AWS Builder ID or AWS IAM Identity center.**, click the **Connect
    with AWS** button and ensure that the setup is complete before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: With our AI-powered extension enabled already, let’s proceed by creating a new
    file named **whisperer.py**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s start by typing the following single-line comment (in the first line):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Press *Enter*. You should see the following suggested code (or similar) generated
    automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that you might get a different suggestion while working on this example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Do not press *Tab* yet as we will be checking the other suggestions first!
  prefs: []
  type: TYPE_NORMAL
- en: Press the right arrow key (*→*) a few times to see the other suggestions, similar
    to what we have in *Figure 9**.23*:![](image/B19755_09_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.23 – Checking the other suggestions using the arrow key
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that accepting the current suggested block of code would automatically
    add **import boto3** as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *Tab* to accept the suggestion and complete the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a new line, type **if** with a space after it (similar to what is shown in
    *Figure 9**.24*). You should see Amazon Whisperer suggesting lines of code that
    would call the function we just defined:![](image/B19755_09_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.24 – More code suggestions from Amazon CodeWhisperer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *Tab* to accept the suggestion and complete the code. At this point, we
    have a small Python script ready for use! It is important to note that the code
    generated by the AI tools and extensions may not always work. Make sure to review,
    run, and test the code generated thoroughly before using it in a real project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t dive deep into the features of Amazon CodeWhisperer in this book.
    Feel free to check the following video (*Amazon CodeWhisperer Overview*) for more
    information about this topic: [https://www.youtube.com/watch?v=j8BoVmHKFlI](https://www.youtube.com/watch?v=j8BoVmHKFlI).'
  prefs: []
  type: TYPE_NORMAL
- en: Part 3 of 3 – Coding PowerShell scripts faster with Tabnine Pro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s try using Tabnine Pro to accelerate the preparation of a sample
    PowerShell script that can help us review and manage the resources running in
    our Microsoft Azure account:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by making sure that all VS Code extensions are disabled to avoid
    any conflict that may arise with the newly added AI-powered extensions. Click
    on the **Extensions** icon in the sidebar on the left side of the VS Code window.
    In the **Extensions** view, click the three dots (**···**) button and select **Disable
    All Installed Extensions** from the list of options available in the context menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s enable the **Tabnine** extension. In the **EXTENSIONS: MARKETPLACE**
    view, we should see a search bar at the top. Type **Tabnine** in this search bar
    to locate the extension we need to enable.![](image/B19755_09_25.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.25 – Enabling the Tabnine extension
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Scroll through the list of extensions to find the **Tabnine: AI Autocomplete
    & Chat for Javascript, Python, Typescript, PHP, Go, Java & more** extension. Right-click
    on the extension and then select **Enable** from the list of options available
    in the context menu.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the setup is complete before proceeding. In some cases, VS Code
    may prompt you to restart the application. If prompted, go ahead and restart VS
    Code.
  prefs: []
  type: TYPE_NORMAL
- en: With our AI-powered extension enabled already, let’s proceed by creating a new
    file named **tabnine.ps1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following single-line comment in the first line of our script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Press *Enter*. You should see the following suggested code (or similar) generated
    automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Amazing, right?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that you might get a different suggestion while working on this example.
  prefs: []
  type: TYPE_NORMAL
- en: Press *Tab* to accept the suggestion and complete the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, type the following comment in a new line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Press *Enter*. You should see the following suggested code generated automatically:![](image/B19755_09_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.26 – Tabnine suggesting a line of code
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see one of the suggestions generated by Tabnine. Note that you
    might get a different suggestion while working on this example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Do not press *Tab* yet as we will be checking the other suggestions first!
  prefs: []
  type: TYPE_NORMAL
- en: Press the right arrow key (*→*) a few times to see other suggestions, similar
    to what we have in *Figure 9**.27*:![](image/B19755_09_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.27 – Checking the other suggestions using the arrow key
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *Tab* to accept a suggestion similar to what we have in *Figure 9**.27*.
    If there’s an extra line (at the end) with triple backticks (**[PRE17]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate Terraform code to create the following resources in GCP:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- a VPC named vpc-01 with a single subnet subnet-01'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- the VPC vpc-01 should have the auto create subnetworks configuration set
    to false'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- the subnet subnet-01 should have the following IP CIDR range: 10.1.0.0/20'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure that the generated Terraform code is valid
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the previous answer by using "us-central1" for the region
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Draw a diagram to help visualize how this network environment looks like
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: https://github.com/PacktPublishing/Building-and-Automating-Penetration-Testing-Labs-in-the-Cloud/blob/main/ch04/pentest_lab/attacker_vm/main.tf
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '```'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the code (from the browser) and paste the Terraform template code to the
    **copilot_labs.tf** file (in VS Code) we created in an earlier step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **GitHub Copilot Labs** icon in the sidebar on the left side of the
    VS Code window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Highlight the code corresponding to the resource block for creating the **vm-kali**
    attacker VM instance:![](image/B19755_09_33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 9.33 – Explaining the highlighted code with GitHub Copilot Labs
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make sure that **Explain code** is selected before clicking the **Ask Copilot**
    button. Clicking the **Ask Copilot** button will produce the following result:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](image/B19755_09_34.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.34 – Result after clicking the Ask Copilot button
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we can see that we are able to use GitHub Copilot to help us interpret
    and explain an existing block of code. Imagine using this on longer and more complex
    code bases! Amazing, right? Reading code is equally as important as writing code.
    As you get to work with a larger team while building complex penetration testing
    lab environments, you’ll realize that you’ll be spending more time reading code
    (written by other members) than writing new code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t dive deep into the features of the GitHub Copilot Labs extension in
    this book. Feel free to check the following link for more information on this
    topic: [https://githubnext.com/projects/copilot-labs/](https://githubnext.com/projects/copilot-labs/).'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should have a good idea of how AI-powered tools can help us
    read and write IaC template code faster. Before we end this section, it is important
    to note that while these tools can certainly speed up the generation and interpretation
    of code, their output may sometimes contain inaccuracies, suboptimal configurations,
    or even security vulnerabilities. That said, it is essential that we exercise
    caution when using these tools.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing relevant considerations and practical strategies when building and
    automating lab environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are down to the last major section of this book! In the previous few sections
    of this chapter, we learned how to use various AI-powered solutions and tools
    to accelerate and automate relevant tasks when building lab environments. In addition
    to the strategies and solutions we have discussed already, we have a few more
    considerations and recommended practices we must take into account when building
    penetration testing lab environments in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick list of the things we should consider and plan for when designing
    lab environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying the purpose of the lab**: Before designing and building a lab
    environment, it is important that we identify why we are building the lab in the
    first place. We need to know how the lab will be used as this will dictate the
    necessary resources and configurations required for the lab environment. For one
    thing, it’s possible that we could be building a lab environment specifically
    for practicing **exploit development**. Maybe we are building a lab environment
    for **red teams** and **blue teams** to simulate real-world attack and defense
    scenarios. It is also possible that we are building a lab environment to test
    AI-powered penetration testing tools such as **PentestGPT**. Given that there
    are various reasons for building a lab, it is essential that we identify and understand
    the purpose of what we’ll be setting up so that we can design the best environment
    for our needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifying the number of users of the lab environment**: Lab resources may
    be shared (or not shared) by multiple lab users playing the role of the attacker.
    If the penetration testing lab environment is shared, the overall cost of running
    the lab environment may be lower. However, this may affect the experience of the
    lab users trying to attack and compromise the same set of resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifying the lab environment size**: Penetration testing lab environments
    don’t need to have the same size network environment as an enterprise company.
    That’s because having more resources would entail a higher cost associated with
    running the lab environment in the cloud.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifying which attacks or techniques are not allowed in cloud environments**:
    Understanding which attacks and techniques are harmful to the lab environment
    and prohibited by the cloud provider is critical. As discussed in the *Examining
    the considerations when building penetration testing lab environments in the cloud*
    section of *[Chapter 1](B19755_01.xhtml)*, *Getting Started with Penetration Testing
    Labs in the Cloud*, cloud providers have policies and guidelines that we need
    to review before doing penetration tests on applications running in the cloud.
    If you don’t follow these guidelines, your cloud account might get suspended or
    even terminated!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Surprised to see just four considerations? Of course, there’s more where they
    came from! In addition to what was just discussed, we need to be mindful of the
    following implementation considerations and recommended practices as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating custom vulnerable applications versus using existing vulnerable
    applications**: By designing our own vulnerable-by-design applications, we have
    full control over the complexity along with the types of security weaknesses,
    vulnerabilities, and misconfigurations present in the application. However, one
    of the major downsides of creating custom applications is that this requires additional
    time and effort, especially if we need to prepare these from scratch. On the other
    hand, using existing vulnerable containers or applications (such as **Metasploitable**
    and **OWASP WebGoat**) can speed things up a bit during the preparation of lab
    environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifying the best way to automate certain components of the lab environment**:
    There are various ways and tools to automate the setup and configuration of lab
    resources and components. Instead of just using Terraform to set up cloud resources,
    it might make sense to use tools such as **Ansible** (or other alternatives) for
    configuration management as well. Here, we can utilize more than one tool. Some
    tools can focus on infrastructure provisioning while other tools take care of
    configuration management. By strategically selecting and combining tools, we can
    leverage their unique strengths when building various components of our penetration
    testing lab environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Providing the lab users the ability to reset specific components in the lab
    setup**: While using the penetration testing lab environments, lab users playing
    the role of the attacker may encounter scenarios where they would need to restore
    a specific component or resource to its initial state. That said, a “reset” button
    (or an alternative solution) for restoring specific VM instances and other cloud
    resources to their initial state would be useful. In case you are wondering what
    they would do next... of course, they would try attacking and compromising these
    resources again!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding cloud platform differences**: Understanding the major and minor
    differences between various cloud platforms is critical as this will affect how
    we design and implement our penetration testing lab environments. In addition
    to this, we need to stay up to date with the announcements from these cloud providers
    as they constantly update their services, features, pricing models, and even the
    security defaults of the cloud resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enforcing a Code of Conduct**: Maintaining a **Code of Conduct** for lab
    users helps set clear expectations and guidelines to govern their behavior while
    performing penetration testing activities and simulations inside the environment.
    This document should outline what’s allowed and what’s not allowed inside the
    lab set up in the cloud account. You could also set up and install various monitoring
    tools to quickly identify any potential violations and ensure the compliance of
    the lab users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documenting the setup**: Proper documentation can help onboard new members
    who will also be maintaining the same lab environment and help troubleshoot issues
    faster. In addition to these, a well-documented setup promotes consistency across
    multiple deployments or iterations of the lab. This will help ensure that the
    lab is (mis)configured the way it should be. Note that this is not just about
    preparing detailed documentation with diagrams and step-by-step instructions on
    how each component of the lab environment is configured. This also includes writing
    self-documenting code, preparing automated tests as needed, and following the
    best practices when using version control systems (such as **Git**) to manage
    the automation scripts and IaC templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s definitely more we can add here, but these should do the trick for now.
    Feel free to read this section twice (or as many times as needed!) as these considerations
    and practical strategies will help you manage the risks and challenges involved
    when running penetration testing labs in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a closer look at how we can increase the complexity
    and difficulty of the penetration testing lab environments we set up in the previous
    chapters of this book. In addition to this, we learned how to utilize various
    AI-powered solutions such as ChatGPT, GitHub Copilot, Amazon CodeWhisperer, and
    Tabnine to significantly speed up relevant tasks when building these vulnerable-by-design
    labs. These include estimating the cost of running these labs in the cloud, generating
    automation scripts and IaC templates, and explaining existing code written by
    other professionals. We ended the chapter by tackling relevant recommendations,
    considerations, and strategies when building penetration testing lab environments
    in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve finally reached the end of this book! Congratulations on completing all
    the chapters along with the hands-on examples and solutions. Close your eyes and
    take a moment to reflect on everything you have learned. I hope this book inspires
    you to embark on many more adventures to explore this fascinating world of cybersecurity.
  prefs: []
  type: TYPE_NORMAL
