- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash Command-Line and Its Hacking Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this foundational chapter, you will embark on your journey into the world
    of Bash shell scripting for **penetration testers** ( **pentesters** ). You will
    gain a clear understanding of what Bash is, why it is essential for **penetration
    testing** ( **pentesting** ), and how to set up your scripting environment. Through
    hands-on examples and explanations, you will lay the groundwork for becoming a
    proficient Bash scripter in the context of cybersecurity.
  prefs: []
  type: TYPE_NORMAL
- en: Bash is more than just a command interpreter – it’s a tool for automating the
    complex and tedious tasks that we encounter daily in cybersecurity. In the hands
    of the untrained, Bash is a club. It seems heavy, overly complex, and uncomfortable.
    In the hands of those able to see the benefits and invest time in learning its
    intricacies, it’s a scalpel that you can use to slice through data with the skill
    of a surgeon and automate pentesting methodology like a robotics engineer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lab setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your hacker shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up essential pentesting tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with the exercises in this chapter, you’ll need a Linux environment.
    This book assumes you have enough skill to install an operating system and are
    familiar with installing and configuring virtual machine environments. If you
    need help setting up your lab environment, the VirtualBox online manual ( *Oracle
    VM VirtualBox User Manual* , ( [https://download.virtualbox.org/virtualbox/UserManual.pdf](https://download.virtualbox.org/virtualbox/UserManual.pdf)
    ) and several YouTube videos (VirtualBox – YouTube [https://www.youtube.com/results?search_query=virtualbox](https://www.youtube.com/results?search_query=virtualbox)
    ) will be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are many ways to configure a Bash learning environment for
    free. All examples will be shown using Kali Linux. However, any Linux or macOS
    environment will work.
  prefs: []
  type: TYPE_NORMAL
- en: '*“Kali Linux is an open source, Debian-based Linux distribution geared toward
    various information security tasks, such as penetration testing, security research,
    computer forensics, and reverse engineering.”* ( *Kali* *Linux* , [https://www.kali.org/](https://www.kali.org/)
    )'
  prefs: []
  type: TYPE_NORMAL
- en: I strongly suggest that you use a fresh Kali Linux virtual machine to follow
    along with the exercises or when performing pentests. Throughout this book and
    your pentests, you will be installing a lot of tools and their dependencies. It’s
    common for tool dependencies to clash and create what is known as *dependency
    hell* . This could result in damage to your main system if you haven’t properly
    isolated the tools during installation. You also don’t want to risk infecting
    your main system with malware.
  prefs: []
  type: TYPE_NORMAL
- en: Kali offers a wide variety of solutions. They provide installer images, virtual
    machines, cloud images, and **Windows Subsystem for Linux** ( **WSL** ) packages.
  prefs: []
  type: TYPE_NORMAL
- en: You can download Kali from [https://www.kali.org/get-kali/#kali-platforms](https://www.kali.org/get-kali/#kali-platforms)
    .
  prefs: []
  type: TYPE_NORMAL
- en: All the commands that will be used in this chapter can be found in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter01](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter01)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash, also known as the *Bourne Again Shell* , is a command-line shell interpreter
    and scripting language. Bash was created by Brian Fox in 1989 as a free software
    replacement for the Bourne shell, which was proprietary software. (Bash – GNU
    Project – Free Software Foundation, [https://www.gnu.org/software/bash/](https://www.gnu.org/software/bash/)
    ). It’s the most common Linux shell. Bash also introduced the ability to combine
    multiple commands into shell scripts that could be run by entering one command.
  prefs: []
  type: TYPE_NORMAL
- en: When you open a Terminal on a Linux system and enter commands, your Bash shell
    manages interactions with the operating system and running executables and scripts.
    Bash and Linux executables form a symbiotic relationship, each enhancing the functionality
    and efficiency of the other. Bash serves as the gateway for users and scripts
    to interact with the Linux kernel, the core of the operating system. It interprets
    user commands, whether entered directly into the Terminal or scripted in files,
    and initiates actions within the system. Linux executables, on the other hand,
    are the workhorses that carry out these actions. They are binary files, often
    written in programming languages such as C or C++, compiled to run efficiently
    on Linux systems. When a user issues a command in Bash, it often involves invoking
    one or more of these executables to perform a task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of Bash’s features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command execution with arguments** : Commands can be binaries, built-in shell
    commands, and scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command completion** : A feature that helps the user by automatically completing
    partially typed commands or filenames upon the *Tab* key being pressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command history** : Command history allows you to quickly reuse commands
    previously entered in the shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Job control** : Sending commands to the background and bringing them to the
    foreground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shell functions and alias** : A function groups related code under a name
    that can be called when needed. An alias allows the user to shorten complex commands
    to a single name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arrays** : Arrays store elements in a list that we can later retrieve and
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command and brace expansion** : Command expansion uses the result of a command
    as the input for another command. Brace expansion allows strings to be generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pipelines and redirection** : The output of one command is used as input
    for another command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment variables** : Dynamic values are assigned to name tags, which
    are frequently used to represent system configuration or store information about
    the environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filesystem navigation** : Bash provides commands to change directories, print
    the current directory, and find files and directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Help** : The **man** command, short for *manual* , provides the user with
    information and examples of how to execute commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash scripting is one of the most important skills that I’ve learned in my pentesting
    career and that I use daily. When you’re developing applications, at some point,
    you’ll find the need to use another scripting language, such as Python. In most
    cases, anything you could want to do at the Terminal can be done in Bash, with
    Bash orchestrating the input and output and parsing the data from multiple tools.
    Bash is so deeply integrated with the Linux operating system that it makes sense
    to learn it before branching out into scripting languages such as Python or Ruby.
    Despite knowing multiple scripting and programming languages, Bash is the one
    that I use most often due to its tight integration with the shell and how easy
    it is to quickly get results with a one-line or even one-word command.
  prefs: []
  type: TYPE_NORMAL
- en: On any given day in my work as a pentester, I use Bash to parse data or automate
    chaining together multiple tools. When a customer gives me scoping data, I must
    frequently copy a list of scoped IP addresses or hostnames from a *Rules of Engagement*
    document, email, or Excel spreadsheet and paste it into a text file. Inevitably,
    there are stray characters in the data, or the data isn’t formatted cleanly for
    use as a list of scan targets. I can use Bash to clean up the file data and format
    it as I need for testing purposes with one simple line of code entered in my Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Pentesting tools accept data in various formats, and output scan results or
    data in common formats such as XML, JSON, or plain text. The plain text output
    may be formatted with multiple spaces, tabs, or a combination. I pipe the contents
    of a source file and pass it through the Bash pipeline to parse, clean, reformat,
    and sort the data. I may use a combination of Bash commands to perform these actions
    in between the output of one command and the input of another in an automation
    pipeline. Bash truly is an indispensable tool in a pentester’s toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some common uses for Bash scripting in my pentesting workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated network scanning** : I frequently process the output of Masscan,
    a fast TCP scanner, and feed it to Nmap for in-depth service detection and script
    scanning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password cracking** : I use a Bash script for a complex series of password
    cracking functions related to cracking Microsoft LM and NTLM hashes and formatting
    the output of Hashcat for input into a reporting tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching text** : Searching for IP addresses or other details in text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scoping automation** : I use subdomain enumeration tools with a Bash script
    to ensure the discovered subdomains are in the scope of the pentest rules of engagement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Formatting data** : I use Bash to parse and reformat the output of Nuclei
    scans to enumerate subdomains and web applications from TLS certificates and reformat
    the data for use in bypassing **content delivery networks** ( **CDNs** ) to bypass
    a **web application firewall** ( **WAF** ) and scan the target directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching and sorting Nmap reports** : After scanning hundreds or even thousands
    of IP addresses, I use Bash to parse the **gnmap** files to create text files
    containing targets organized by TCP or UDP ports for use in more targeted scans.
    For example, all SMB servers or HTTP servers’ IP addresses are carved out and
    placed into files named **smb.txt** and **http.txt** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting data and deduplication** : Sort the unique IP addresses into a file
    for deduplication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data conversion** : Convert first and last names into various formats for
    password spraying. If I can get a list of employee names through **Open Source
    Intelligence** ( **OSINT** ), I’ll look at anything that may tip me off to how
    their Active Directory names are formatted, such as **f.last** or **first.last**
    , and use Bash to format the names appropriately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data filtering** : Occasionally, I have to remove Terminal color codes from
    tool output log files for use in reporting because I forgot to include a command-line
    flag for no color, or the tool may not have this option. I don’t want to screenshot
    data for my customer’s report with it containing color codes that make the data
    confusing to read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterating over data** : I use Bash **for** and **while** loops to loop through
    a file and run a command on each line. A good example of this is when you need
    to use a tool that scans one host at a time with no option to process multiple
    targets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’m confident that learning Bash scripting will make you more efficient with
    your time and more effective in your job. When you can automate time-intensive,
    boring tasks using Bash, it frees up your time to take on more important things.
    Wouldn’t it be great to have more time for learning or research instead of wasting
    it on manual tasks that can be automated with little effort?
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of Bash and why it’s useful in our pentesting
    endeavors, let’s explore how to set up a lab environment where you can safely
    learn and follow along with the exercises. In the next section, we’ll explore
    setting up your lab environment so that you can follow along with me.
  prefs: []
  type: TYPE_NORMAL
- en: Lab setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash isn’t the only shell interpreter for Linux and Unix systems, but it is
    the most common. Other shells were influenced by Bash. You may also encounter
    Zsh on macOS and Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why this book has chosen to focus on Bash, despite some
    operating systems switching to Zsh. While macOS and Kali have switched to Zsh
    for new user accounts, they still have Bash installed. Most code written for Bash
    will also work on Zsh with a few minor changes. You can include a **shebang**
    line in your shell scripts to ensure that the Bash interpreter runs your script
    on systems where multiple shells are installed. While performing security assessments,
    you’re very likely to encounter Linux servers where Bash is the default shell.
    It will be essential for a pentester to understand how to interact with Bash to
    exploit applications, escalate privileges, and move laterally.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are many ways you can access a Bash shell for free. This
    section will explore a variety of ways you can access a Bash shell in an ideal
    setting so that you can follow along and learn how to use Bash for pentesting.
    We will also explore vulnerable lab environments where you can safely practice
    using Bash and pentesting tools.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machines are the preferred way to follow along with this book’s activities,
    as well as when performing pentesting. You may be tempted to install your pentesting
    tools and exploit code on the same system you use for business or personal activities.
    It’s easy to damage your system by installing software prerequisites for various
    tools. There’s always a risk of hacking tools containing malware and infecting
    the same system that you use from day to day to send emails or access the web.
    A virtual machine provides a convenient sandbox environment with everything you
    need to quickly refresh or replace a testing environment. I have chosen to use
    Kali Linux in all demonstrations. We want to avoid installing pentesting tools
    and exploit code in the same system we use daily for business or personal use.
    It’s best to use a clean testing environment to avoid creating software dependency
    issues for us. Kali makes it easy to install the needed software packages related
    to pentesting.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a **virtual machine** is the preferred method. During a pentest, you’ll
    likely install a multitude of tools and exploit proof of concept code. At some
    point, you’ll also save sensitive data about your customer or target. A virtual
    machine provides a convenient container that you can snapshot and restore, or
    delete and replace easily after an assessment.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous free and paid virtualization solutions to fit any need:'
  prefs: []
  type: TYPE_NORMAL
- en: Oracle VirtualBox is a free x86 virtualization hypervisor. It’s available for
    Windows, macOS (Intel chipset), and Linux. VirtualBox is user-friendly, making
    it a popular choice for beginners and professionals alike. It supports a wide
    range of guest operating systems and offers features such as snapshots, seamless
    mode, and shared folders.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VMware offers a free version of their virtualization software called VMware
    Workstation Player for non-commercial use. It’s compatible with Windows and Linux
    hosts. Workstation Player is easy to use and supports VMware’s VMDK virtual disk
    format, and it’s also compatible with virtual machines created by other VMware
    products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Hyper-V is free and available on Windows 10 Pro, Enterprise, and Education
    editions. While it’s more commonly used in server environments, Hyper-V can also
    be a good option for desktop virtualization on Microsoft Windows hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: For those on macOS with the Apple CPU, your virtualization options are UTM,
    Parallels, and VMWare Fusion. UTM is the only free option.
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Docker containers** offer a lightweight option over virtual machines. Docker
    offers a runtime for Windows, Linux, and macOS. Containers are more lightweight
    and efficient on lower-end hardware than virtual machines because they use the
    host’s kernel, so they don’t have to virtualize hardware as traditional hypervisors
    do.'
  prefs: []
  type: TYPE_NORMAL
- en: Because Docker uses the host’s kernel, you’re limited to running containers
    while utilizing the same operating system as the host. Docker Desktop is an alternative
    that uses a virtual machine to run containers with a different operating system
    from the host.
  prefs: []
  type: TYPE_NORMAL
- en: Based on my experience, there are some positive and negative points to consider
    about using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is more lightweight and is a good alternative to traditional hypervisors
    when your hardware is less robust. The minimum hardware resources I would assign
    to a virtual machine running Kali Linux is 4 GB of RAM and 40 GB of disk space.
    You’re not always going to be using that 4 GB/40 GB. At the same time, you’re
    limited to those values unless you shut down the virtual machine, adjust the RAM,
    and extend the disk. A Docker container runs in a native process (excluding Docker
    Desktop), so it uses only as much memory and disk space as needed to run the container.
  prefs: []
  type: TYPE_NORMAL
- en: On a Linux host, you can attach a container directly to the host network and
    open and close ports as needed, provided you include specific command-line arguments.
    This allows you to dynamically open listening server ports on the host’s network
    adapter without stopping and starting the container. You can also attach a container
    to a USB or serial port to interface with hardware devices. I sometimes use this
    option when I need to run an old Python2 pentesting application that interfaces
    with a USB or serial device for radio frequency and hardware hacking.
  prefs: []
  type: TYPE_NORMAL
- en: When using Docker Desktop, NAT is used to connect container network ports to
    the host’s network, so the container must be stopped and restarted if you need
    to close or open additional ports. With Docker Desktop, it isn’t possible to attach
    a container to hardware devices. This can be aggravating when you’ve configured
    an application and its dependencies on a container and then lose your work and
    have to start over when you destroy the container and start a new instance, just
    to open another TCP port for a reverse listener or server application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, my preference is to use Docker only on a Linux host, and I use
    it for three specific pentesting use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides an easy way to isolate old Python 2 applications and avoid dependency
    hell. There are official Docker containers for all Python 2 and 3 versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I use it to create and run applications that aren’t available through my package
    manager, and I want to avoid wasting time solving dependency issues. For example,
    a particular hacking tool is available through the Kali software repository, but
    not in Ubuntu. I can create a thin Kali container that uses only enough resources
    to run the contained application and use an alias in my **~/.bashrc** file to
    reduce a long **docker run** command to a single word I can enter in my Terminal.
    This is a much faster and more lightweight option than a heavy virtual machine
    when I just want to run a single application that can’t be run or would be difficult
    to run on my host system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When I want to practice exploiting or creating an exploit tool for a recently
    announced vulnerable web application, I can frequently find a Docker container
    that allows me to immediately start the vulnerable application without spending
    precious time installing and configuring it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker containers are perfect for specific use cases. However, they’re less
    preferred than virtual machines. Next, we’ll explore using live USB systems as
    an alternative to virtual machines and containers.
  prefs: []
  type: TYPE_NORMAL
- en: Live USB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **live USB** is an operating system image written to a USB disk in a way that
    makes it bootable. Live USB is a good choice to use when your computer doesn’t
    have the hardware resources to run a virtual machine. You can use imaging software
    to burn Linux ISO disks to USB and boot a Linux operating system. After you finish
    your work on Linux, you simply restart the computer and remove the USB drive to
    revert to the installed operating system. Some Linux distributions enable you
    to create persistent storage on the USB drive so that you don’t lose your changes
    when you reboot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some general steps for running a Linux distribution from
    live USB:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the ISO image. Some popular Linux distributions for pentesters include
    Kali, Parrot Security OS, and BlackArch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a live USB drive. Common tools for this purpose include Rufus, balenaEtcher,
    and the Linux **dd** command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure persistence (optional). This usually involves creating a separate
    partition on the USB drive and configuring the bootloader to recognize and use
    this partition. You can find the documented steps required to create a live USB
    Kali system at [https://www.kali.org/docs/usb/usb-persistence/](https://www.kali.org/docs/usb/usb-persistence/)
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are some considerations and drawbacks to using live USB:'
  prefs: []
  type: TYPE_NORMAL
- en: USB storage is usually much slower than running directly from an SSD. If you
    use live USB, be sure to use the USB 3.0 or 3.1 standard for best performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always download the ISO image from official sources and verify the checksum
    before trusting it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re planning to use it for production use, be sure to use encrypted persistence
    due to the risk of exposing the sensitive data on the drive to someone not authorized
    to have it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s move on and discuss cloud-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-based systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many cloud platforms create free tiers for access to Linux systems with enough
    resources for modest workloads. Cloud providers with free tiers include **Google
    Cloud Platform** ( **GCP** ), Microsoft Azure, and Amazon EC2. Be aware that the
    free tier may not provide enough RAM for production use and will not be suitable
    for running Kali Linux images.
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux provides documentation and marketplace images for running on AWS,
    Digital Ocean, Linode, and Azure ( [https://www.kali.org/docs/cloud/](https://www.kali.org/docs/cloud/)
    ). I have experience with customers who have configured Kali in the cloud for
    cloud security assessments, or connected via VPN to their internal network infrastructure
    to facilitate internal network pentests. If the customer’s internal network is
    already connected to a cloud provider over VPN, it’s relatively easy for them
    to spin up a Kali image and create a firewall rule to allow SSH access from my
    IP address. Now that we’ve explored options for running a pentesting system with
    Bash, let’s discover a few vulnerable systems we can use to practice within our
    lab.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerable lab targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While following along with some of the later chapters related to pentesting
    methodology, it will be beneficial for you to have access to vulnerable targets
    when running the commands and developing your Bash scripts. There are several
    great sources of vulnerable targets you can use for practice in your lab.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploitable 2 is a vulnerable virtual machine provided by Rapid7. It was
    designed to showcase the capabilities of the Metasploit Framework. Metasploitable
    2 is also a good beginner-level challenge for developing your hacker methodology
    and learning Bash for pentesting. The project requires modest resources to run
    the virtual machine and includes documentation on the machine’s vulnerabilities
    ( *Metasploitable 2 | Metasploit* *Documentation* , [https://docs.rapid7.com/metasploit/metasploitable-2/](https://docs.rapid7.com/metasploit/metasploitable-2/)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Game of Active Directory (GOAD) is also an option.
  prefs: []
  type: TYPE_NORMAL
- en: '*“GOAD is a pentesting Active Directory LAB project. The purpose of this lab
    is to give pentesters a vulnerable Active Directory environment ready to use for
    them to practice usual attack techniques* *.”* ( *Game of Active Directory –*
    *Orange-CyberDefense* , [https://github.com/Orange-Cyberdefense/GOAD](https://github.com/Orange-Cyberdefense/GOAD)
    )'
  prefs: []
  type: TYPE_NORMAL
- en: Note that GOAD is free to use and uses free Microsoft Windows licenses that
    are activated for 180 days. GOAD is the best resource I’ve found for practicing
    hacking on internal Active Directory network environments.
  prefs: []
  type: TYPE_NORMAL
- en: MayFly is the creator of GOAD. Their website contains plenty of articles on
    how to set GOAD up on different virtual machine hypervisors, as well as lab guides
    for using common pentesting tools to hack Active Directory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: MayFly also published a comprehensive mind map for pentesting Active Directory.
    Despite having years of experience in hacking Active Directory, I still find times
    that I’m running out of things to test and will refer to this mind map when I
    get stuck or want to ensure that I’ve left no stone unturned. This mind map is
    also the number one resource I recommend to junior pentesters who are learning
    Active Directory hacking techniques and tools (you can find more details at [https://orange-cyberdefense.github.io/ocd-mindmaps/img/pentest_ad_dark_2022_11.svg](https://orange-cyberdefense.github.io/ocd-mindmaps/img/pentest_ad_dark_2022_11.svg)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to practice your Bash scripts, tools, and methodology on web applications,
    OWASP Juice Shop is a great resource.
  prefs: []
  type: TYPE_NORMAL
- en: '*“OWASP Juice Shop is probably the most modern and sophisticated insecure web
    application! It can be used in security training, awareness demos, CTFs, and as
    a guinea pig for security tools! Juice Shop encompasses vulnerabilities from the
    entire OWASP Top Ten* ( [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)
    ) *, along with many other security flaws found in real-world applications!”*
    ( *OWASP Juice Shop – OWASP* *Foundation* , [https://owasp.org/www-project-juice-shop/](https://owasp.org/www-project-juice-shop/)
    )'
  prefs: []
  type: TYPE_NORMAL
- en: An older yet still very relevant vulnerable web application is Mutillidae II.
  prefs: []
  type: TYPE_NORMAL
- en: '*“OWASP Mutillidae II is a free, open source, deliberately vulnerable web application
    that provides a target for web-security training. With dozens of vulnerabilities
    and hints to help the user, this is an easy-to-use web hacking environment designed
    for labs, security enthusiasts, classrooms, CTF, and vulnerability assessment
    tool targets.”* ( *OWASP Mutillidae II – OWASP* *Foundation* [https://owasp.org/www-project-mutillidae-ii/](https://owasp.org/www-project-mutillidae-ii/)
    )'
  prefs: []
  type: TYPE_NORMAL
- en: One of the things I love about Mutillidae is that it embeds hints, tutorials,
    and video tutorials in the content. Mutillidae is a resource I used many years
    ago to learn web app testing when I was a junior pentester. The difference between
    Juice Shop and Mutillidae is that Juice Shop is a modern web application that
    uses JavaScript frameworks, whereas Mutillidae is a more traditional web application.
    While Juice Shop has a scoreboard and you can find third-party walkthroughs online,
    Mutillidae has a large amount of training text and video embedded in the application.
  prefs: []
  type: TYPE_NORMAL
- en: The cybersecurity landscape is always changing, and new vulnerabilities are
    discovered regularly. A lab setup is an ideal place for research and development,
    allowing you to experiment with these vulnerabilities safely. It’s where you can
    contribute to the cybersecurity community by discovering new vulnerabilities or
    enhancing existing pentesting methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored vulnerable targets for your pentesting lab, next up,
    we’ll talk about customizing your Bash shell so that it suits your needs and personal
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your hacker shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re following along using Kali Linux or macOS, note that your Terminal
    shell uses Zsh by default instead of Bash. Zsh has more features (such as better
    tab completion and theme support) but Bash is more widespread and standard. Bash
    has been around since the late 80s, making it a veteran in the shell world. It’s
    the default on most Linux distributions and macOS (up until Catalina, where Zsh
    took over). Bash’s longevity means it’s extremely stable and well-supported.
  prefs: []
  type: TYPE_NORMAL
- en: Zsh, on the other hand, came a bit later. It’s known for its improvements over
    Bash, including better interactive use and more powerful scripting capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: You can determine which shell is configured by entering the **echo $SHELL**
    command in your terminal. Almost all code shown in this book will work in both
    Bash and Zsh, except where noted. In my day-to-day pentesting activities, I rarely
    notice any difference. However, if you want to change your shell from Zsh to Bash,
    execute the **chsh -s /bin/bash** command in your Terminal, then log out and log
    in to see the change take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bash configuration files can be found in the user home directory, **/home/username**
    . Because the filenames begin with a period character, they are commonly referred
    to as *dotfiles* . The following configuration files are used to configure the
    Bash shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '**~/.bash_profile** : This file is executed at the start of an interactive
    login and is used to initialize the user environment. Think of an interactive
    login as logging in via the command line via a text-based Terminal such as an
    SSH session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**~/.bashrc** : This file is used to configure the Terminal when you’ve logged
    in through the **graphical user interface** ( **GUI** ). This file contains settings
    including aliases, functions, prompt customizations, and environment variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**~/.bash_logout** : This file is executed when your session ends. It’s used
    to perform tasks related to cleaning up the environment when you log out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t understand the purpose of the tilde ( **~** ) character and forward
    slash preceding the dotfile name, the tilde character represents the user’s home
    directory. The **~/.bashrc** path is equivalent to **/home/username/.bashrc**
    . This concept will be covered in [*Chapter 2*](B22229_02.xhtml#_idTextAnchor034)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The most common edits you’ll want to make will include adding aliases and functions
    and customizing your command prompt in your **~/.bashrc** file. Aliases are a
    great way to shorten long or complex commands to a single word. Functions are
    more complex. Think of functions as a short script that you can include in your
    shell configuration and call by name in your Terminal. Functions will be discussed
    later in [*Chapter 5*](B22229_05.xhtml#_idTextAnchor089) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example alias from my **~/.bashrc** file that I use to search for
    IP addresses in text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can see how this command would be difficult to remember, so it helps to
    create an alias for any complex command you may need to use repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When you make edits to your Bash configuration files, you must either log out
    and log in or source the file to enact the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command to source a file and enact changes immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that you understand the purpose of Bash’s dotfiles, let’s move on and take
    a look at how we can edit them to personalize our environment.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Bash prompt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prompt is where you enter commands in the Bash Terminal. Your prompt can
    be as simple or complex as you desire to meet your tastes and reflect your personality.
    Think of your prompt design choices like how a painter chooses their palate.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find your currently configured prompt by looking in your **~/.bashrc**
    file for a line that begins with **PS1** . A common Bash prompt would use a **PS1**
    value such as **export PS1="\u@\h \w\$ "** , and it would look like **username@hostname
    ~$** at the prompt. Let’s break this down. Here’s what each part does:'
  prefs: []
  type: TYPE_NORMAL
- en: '**\u** will be replaced by the current username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@** is a literal character and will appear after the username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**\h** will be replaced by the hostname up to the first period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**\w** will be replaced by the current working directory, with **$HOME** abbreviated
    to a tilde character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**\$** displays a **$** character for a regular user, or **#** for the root
    user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you edit your **PS1** prompt, be sure to source the file to see the changes
    take effect.
  prefs: []
  type: TYPE_NORMAL
- en: You can also get really fancy with your prompt. I’ve been known to insert the
    **$(ip a show eth0 | grep -m 1 inet | tr -s ' ' | cut -d ' ' -f 3)** string in
    the middle of my **PS1** prompt to show my IP address for capturing in my logs
    or report screenshots for the customer to correlate my activity with their **Security
    Information and Event Management** ( **SIEM** ) alerts. See [https://bash-prompt-generator.org/](https://bash-prompt-generator.org/)
    for a graphical Bash prompt generator, or the official Bash manual for all options.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing your Bash environment is about making your Terminal work for you.
    It’s a process of trial and improvement, finding what makes you more productive,
    and what brings a bit of joy into your command-line sessions. Start small, experiment,
    and see how a few changes can make a big difference in your daily tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up essential pentesting tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll go over setting up our pentesting environment by updating
    system software packages and installing the tools required to follow along. Most
    of the tools needed will already be installed in Kali, so we’ll only need to install
    a few more software packages.
  prefs: []
  type: TYPE_NORMAL
- en: Update the package manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your first step when using a new Linux installation should be updating packages.
    As stated earlier, I’ll be using Kali Linux in all demonstrations. Kali is based
    on the Debian Linux distribution, which uses the **Advanced Package Tool** ( **APT**
    ) package manager. At its core, **apt** streamlines software management. It automates
    the process of retrieving, configuring, and installing software packages from
    predefined repositories. This automation not only saves time but also ensures
    that software dependencies are resolved without manual intervention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running **sudo apt update** refreshes the local database of available packages
    and their versions, ensuring you have the latest information from the repositories.
    This step is crucial before installing new software or updating existing packages
    to ensure you’re getting the latest versions. If you’re using Kali, Ubuntu, or
    Debian Linux, the following commands to update and upgrade will work as expected
    because they all use the **apt** package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we use **sudo** to elevate privileges and **apt**
    to update the list of available packages. The double ampersand symbols ( **&&**
    ) operate like a logical AND operator; the second command to upgrade packages
    without prompting ( **-y** ) is only run if the first command results in success.
    Finally, we reboot to ensure that all services and kernel updates take effect.
  prefs: []
  type: TYPE_NORMAL
- en: Install ProjectDiscovery tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ProjectDiscovery** offers some great tools I recommend for pentesting (PDTM
    – ProjectDiscovery, [https://github.com/projectdiscovery/pdtm](https://github.com/projectdiscovery/pdtm)
    ). Before we can install them, we must install the Go programming language runtime
    and libraries. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: In your web browser, navigate to [https://go.dev/dl/](https://go.dev/dl/) .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the correct package for your Linux distribution. Be sure to look closely
    at the processor architecture. Typically, this would be a **Kind** value of **archive**
    , an **OS** value of **Linux** , and an **Arch** value of either **x86-64** or
    **ARM64** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extract the downloaded archive. Be sure to change the package version so that
    it matches what you downloaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add **/usr/local/go/bin** to the **PATH** environment variable in your **~/.bashrc**
    file. The **PATH** environment variable tells your Bash shell where to find the
    full path to an executable program when you don’t include the path before your
    command. The **echo** command prints the text inside quotes to the Terminal and
    the greater-than symbol ( **>** ) redirects the output to a file. Notice that
    we use two greater-than symbols here to redirect the output. If we were to use
    only one, it would overwrite the file contents. We want to append to the file
    by using two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Source the file to enact your changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check to ensure that **/usr/local/go/bin** has been appended to your **PATH**
    (look after the last colon character):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that Go has been installed properly and can be found in your **PATH**
    . Your version and architecture may vary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install **pdtm** from ProjectDiscovery. This is the tool that installs and
    manages updates for all of ProjectDiscovery ’s tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add **pdtm** to your path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following **pdtm** command to install all tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install **libpcap** for **naabu** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That wraps up installing all of the needed ProjectDiscovery tools.
  prefs: []
  type: TYPE_NORMAL
- en: Install NetExec
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*NetExec is a network service exploitation tool that helps automate assessing
    the security of large networks* ( *NetExec* *wiki* , [https://www.netexec.wiki/](https://www.netexec.wiki/)
    ).'
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, NetExec is one of the most useful tools for internal network
    pentesting. It supports most of the network protocols needed during internal network
    pentesting, plus Microsoft Active Directory testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are far too many features to list here. Some of the things I use NetExec
    for include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for vulnerabilities; NetExec includes some useful modules to test for
    common vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute-force attacks on authentication to test for weak passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spraying a password or password hash against servers to find where the supplied
    credentials have local administrator access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating SMB shares for read/write access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enter the following command to install NetExec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That wraps up the process of installing the most common pentesting tools that
    are not installed by default.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to the indispensable world of Bash shell
    scripting, a cornerstone skill for anyone aspiring to excel in pentesting. This
    chapter began by demystifying what Bash is and underscoring its significance in
    cybersecurity tasks. It wasn’t just about memorizing commands; it was about leveraging
    Bash to automate repetitive tasks, manipulate data, and conduct security assessments
    with efficiency. The journey continued with guidance on selecting the appropriate
    operating system that supports Bash, setting the stage for successful scripting
    endeavors. Then, we rolled up our sleeves to configure our hacker shell, customizing
    its appearance and behavior to reflect personal tastes and preferences. This customization
    wasn’t just for aesthetics; it was about creating a functional and efficient working
    environment. Finally, this chapter introduced essential pentesting tools, walking
    you through their installation and basic usage. At this point, you're equipped
    with a well-prepared environment and a foundational understanding of how Bash
    scripting can significantly enhance your pentesting capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover techniques for working with files and directories.
  prefs: []
  type: TYPE_NORMAL
