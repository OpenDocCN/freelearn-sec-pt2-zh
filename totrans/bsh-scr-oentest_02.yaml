- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash Command-Line and Its Hacking Environment
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this foundational chapter, you will embark on your journey into the world
    of Bash shell scripting for **penetration testers** ( **pentesters** ). You will
    gain a clear understanding of what Bash is, why it is essential for **penetration
    testing** ( **pentesting** ), and how to set up your scripting environment. Through
    hands-on examples and explanations, you will lay the groundwork for becoming a
    proficient Bash scripter in the context of cybersecurity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Bash is more than just a command interpreter – it’s a tool for automating the
    complex and tedious tasks that we encounter daily in cybersecurity. In the hands
    of the untrained, Bash is a club. It seems heavy, overly complex, and uncomfortable.
    In the hands of those able to see the benefits and invest time in learning its
    intricacies, it’s a scalpel that you can use to slice through data with the skill
    of a surgeon and automate pentesting methodology like a robotics engineer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Bash
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lab setup
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring your hacker shell
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up essential pentesting tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with the exercises in this chapter, you’ll need a Linux environment.
    This book assumes you have enough skill to install an operating system and are
    familiar with installing and configuring virtual machine environments. If you
    need help setting up your lab environment, the VirtualBox online manual ( *Oracle
    VM VirtualBox User Manual* , ( [https://download.virtualbox.org/virtualbox/UserManual.pdf](https://download.virtualbox.org/virtualbox/UserManual.pdf)
    ) and several YouTube videos (VirtualBox – YouTube [https://www.youtube.com/results?search_query=virtualbox](https://www.youtube.com/results?search_query=virtualbox)
    ) will be helpful.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are many ways to configure a Bash learning environment for
    free. All examples will be shown using Kali Linux. However, any Linux or macOS
    environment will work.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '*“Kali Linux is an open source, Debian-based Linux distribution geared toward
    various information security tasks, such as penetration testing, security research,
    computer forensics, and reverse engineering.”* ( *Kali* *Linux* , [https://www.kali.org/](https://www.kali.org/)
    )'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: I strongly suggest that you use a fresh Kali Linux virtual machine to follow
    along with the exercises or when performing pentests. Throughout this book and
    your pentests, you will be installing a lot of tools and their dependencies. It’s
    common for tool dependencies to clash and create what is known as *dependency
    hell* . This could result in damage to your main system if you haven’t properly
    isolated the tools during installation. You also don’t want to risk infecting
    your main system with malware.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Kali offers a wide variety of solutions. They provide installer images, virtual
    machines, cloud images, and **Windows Subsystem for Linux** ( **WSL** ) packages.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: You can download Kali from [https://www.kali.org/get-kali/#kali-platforms](https://www.kali.org/get-kali/#kali-platforms)
    .
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: All the commands that will be used in this chapter can be found in this book’s
    GitHub repository at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter01](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter01)
    .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Bash
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash, also known as the *Bourne Again Shell* , is a command-line shell interpreter
    and scripting language. Bash was created by Brian Fox in 1989 as a free software
    replacement for the Bourne shell, which was proprietary software. (Bash – GNU
    Project – Free Software Foundation, [https://www.gnu.org/software/bash/](https://www.gnu.org/software/bash/)
    ). It’s the most common Linux shell. Bash also introduced the ability to combine
    multiple commands into shell scripts that could be run by entering one command.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: When you open a Terminal on a Linux system and enter commands, your Bash shell
    manages interactions with the operating system and running executables and scripts.
    Bash and Linux executables form a symbiotic relationship, each enhancing the functionality
    and efficiency of the other. Bash serves as the gateway for users and scripts
    to interact with the Linux kernel, the core of the operating system. It interprets
    user commands, whether entered directly into the Terminal or scripted in files,
    and initiates actions within the system. Linux executables, on the other hand,
    are the workhorses that carry out these actions. They are binary files, often
    written in programming languages such as C or C++, compiled to run efficiently
    on Linux systems. When a user issues a command in Bash, it often involves invoking
    one or more of these executables to perform a task.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of Bash’s features:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Command execution with arguments** : Commands can be binaries, built-in shell
    commands, and scripts.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command completion** : A feature that helps the user by automatically completing
    partially typed commands or filenames upon the *Tab* key being pressed.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command history** : Command history allows you to quickly reuse commands
    previously entered in the shell.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Job control** : Sending commands to the background and bringing them to the
    foreground.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shell functions and alias** : A function groups related code under a name
    that can be called when needed. An alias allows the user to shorten complex commands
    to a single name.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arrays** : Arrays store elements in a list that we can later retrieve and
    process.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command and brace expansion** : Command expansion uses the result of a command
    as the input for another command. Brace expansion allows strings to be generated.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pipelines and redirection** : The output of one command is used as input
    for another command.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment variables** : Dynamic values are assigned to name tags, which
    are frequently used to represent system configuration or store information about
    the environment.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境变量**：动态值被分配到标签名，这些标签通常用于表示系统配置或存储环境相关信息。'
- en: '**Filesystem navigation** : Bash provides commands to change directories, print
    the current directory, and find files and directories.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统导航**：Bash提供了更改目录、打印当前目录以及查找文件和目录的命令。'
- en: '**Help** : The **man** command, short for *manual* , provides the user with
    information and examples of how to execute commands.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帮助**：**man**命令，简写为*manual*，为用户提供有关如何执行命令的信息和示例。'
- en: Bash scripting is one of the most important skills that I’ve learned in my pentesting
    career and that I use daily. When you’re developing applications, at some point,
    you’ll find the need to use another scripting language, such as Python. In most
    cases, anything you could want to do at the Terminal can be done in Bash, with
    Bash orchestrating the input and output and parsing the data from multiple tools.
    Bash is so deeply integrated with the Linux operating system that it makes sense
    to learn it before branching out into scripting languages such as Python or Ruby.
    Despite knowing multiple scripting and programming languages, Bash is the one
    that I use most often due to its tight integration with the shell and how easy
    it is to quickly get results with a one-line or even one-word command.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Bash脚本是我在渗透测试生涯中学到的最重要的技能之一，并且我每天都会使用。当你在开发应用程序时，某一时刻你可能会需要使用其他脚本语言，例如Python。在大多数情况下，你在终端中想做的任何事情，都可以通过Bash完成，Bash负责协调输入输出以及解析来自多个工具的数据。Bash与Linux操作系统紧密集成，因此在学习其他脚本语言如Python或Ruby之前，学习Bash是非常有意义的。尽管我知道多种脚本和编程语言，但由于Bash与Shell的紧密集成以及通过一行甚至一个单词的命令快速获得结果的便利性，Bash仍是我最常使用的工具。
- en: On any given day in my work as a pentester, I use Bash to parse data or automate
    chaining together multiple tools. When a customer gives me scoping data, I must
    frequently copy a list of scoped IP addresses or hostnames from a *Rules of Engagement*
    document, email, or Excel spreadsheet and paste it into a text file. Inevitably,
    there are stray characters in the data, or the data isn’t formatted cleanly for
    use as a list of scan targets. I can use Bash to clean up the file data and format
    it as I need for testing purposes with one simple line of code entered in my Terminal.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我作为渗透测试员的工作中，每天我都会使用Bash来解析数据或自动化将多个工具串联在一起。当客户给我提供范围数据时，我通常需要从*参与规则*文档、电子邮件或Excel表格中复制一个范围内的IP地址或主机名列表，并粘贴到文本文件中。数据中难免会有多余的字符，或者数据的格式不适合用作扫描目标列表。我可以使用Bash清理文件数据，并通过在终端中输入一行简单的代码，将其格式化成我需要的样子以便测试。
- en: Pentesting tools accept data in various formats, and output scan results or
    data in common formats such as XML, JSON, or plain text. The plain text output
    may be formatted with multiple spaces, tabs, or a combination. I pipe the contents
    of a source file and pass it through the Bash pipeline to parse, clean, reformat,
    and sort the data. I may use a combination of Bash commands to perform these actions
    in between the output of one command and the input of another in an automation
    pipeline. Bash truly is an indispensable tool in a pentester’s toolbox.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试工具接受各种格式的数据，并输出扫描结果或以常见格式如XML、JSON或纯文本显示的数据。纯文本输出可能会通过多个空格、制表符或两者的组合进行格式化。我通过管道将源文件的内容传递到Bash管道中，以解析、清理、重新格式化并排序数据。我可能会使用一组合适的Bash命令，在一个命令的输出和另一个命令的输入之间执行这些操作，形成自动化管道。Bash确实是渗透测试工具箱中不可或缺的工具。
- en: 'The following are some common uses for Bash scripting in my pentesting workflow:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我在渗透测试工作流中常用的一些Bash脚本应用：
- en: '**Automated network scanning** : I frequently process the output of Masscan,
    a fast TCP scanner, and feed it to Nmap for in-depth service detection and script
    scanning.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化网络扫描**：我经常处理Masscan（一个快速的TCP扫描器）的输出，并将其输入到Nmap中进行深入的服务检测和脚本扫描。'
- en: '**Password cracking** : I use a Bash script for a complex series of password
    cracking functions related to cracking Microsoft LM and NTLM hashes and formatting
    the output of Hashcat for input into a reporting tool.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码破解**：我使用一个Bash脚本，执行一系列复杂的密码破解功能，涉及破解Microsoft LM和NTLM哈希值，并将Hashcat的输出格式化，以便输入到报告工具中。'
- en: '**Searching text** : Searching for IP addresses or other details in text.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本搜索**：在文本中搜索IP地址或其他细节。'
- en: '**Scoping automation** : I use subdomain enumeration tools with a Bash script
    to ensure the discovered subdomains are in the scope of the pentest rules of engagement.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Formatting data** : I use Bash to parse and reformat the output of Nuclei
    scans to enumerate subdomains and web applications from TLS certificates and reformat
    the data for use in bypassing **content delivery networks** ( **CDNs** ) to bypass
    a **web application firewall** ( **WAF** ) and scan the target directly.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Searching and sorting Nmap reports** : After scanning hundreds or even thousands
    of IP addresses, I use Bash to parse the **gnmap** files to create text files
    containing targets organized by TCP or UDP ports for use in more targeted scans.
    For example, all SMB servers or HTTP servers’ IP addresses are carved out and
    placed into files named **smb.txt** and **http.txt** .'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting data and deduplication** : Sort the unique IP addresses into a file
    for deduplication.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data conversion** : Convert first and last names into various formats for
    password spraying. If I can get a list of employee names through **Open Source
    Intelligence** ( **OSINT** ), I’ll look at anything that may tip me off to how
    their Active Directory names are formatted, such as **f.last** or **first.last**
    , and use Bash to format the names appropriately.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data filtering** : Occasionally, I have to remove Terminal color codes from
    tool output log files for use in reporting because I forgot to include a command-line
    flag for no color, or the tool may not have this option. I don’t want to screenshot
    data for my customer’s report with it containing color codes that make the data
    confusing to read.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterating over data** : I use Bash **for** and **while** loops to loop through
    a file and run a command on each line. A good example of this is when you need
    to use a tool that scans one host at a time with no option to process multiple
    targets.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’m confident that learning Bash scripting will make you more efficient with
    your time and more effective in your job. When you can automate time-intensive,
    boring tasks using Bash, it frees up your time to take on more important things.
    Wouldn’t it be great to have more time for learning or research instead of wasting
    it on manual tasks that can be automated with little effort?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of Bash and why it’s useful in our pentesting
    endeavors, let’s explore how to set up a lab environment where you can safely
    learn and follow along with the exercises. In the next section, we’ll explore
    setting up your lab environment so that you can follow along with me.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Lab setup
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash isn’t the only shell interpreter for Linux and Unix systems, but it is
    the most common. Other shells were influenced by Bash. You may also encounter
    Zsh on macOS and Kali Linux.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why this book has chosen to focus on Bash, despite some
    operating systems switching to Zsh. While macOS and Kali have switched to Zsh
    for new user accounts, they still have Bash installed. Most code written for Bash
    will also work on Zsh with a few minor changes. You can include a **shebang**
    line in your shell scripts to ensure that the Bash interpreter runs your script
    on systems where multiple shells are installed. While performing security assessments,
    you’re very likely to encounter Linux servers where Bash is the default shell.
    It will be essential for a pentester to understand how to interact with Bash to
    exploit applications, escalate privileges, and move laterally.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there are many ways you can access a Bash shell for free. This
    section will explore a variety of ways you can access a Bash shell in an ideal
    setting so that you can follow along and learn how to use Bash for pentesting.
    We will also explore vulnerable lab environments where you can safely practice
    using Bash and pentesting tools.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machines are the preferred way to follow along with this book’s activities,
    as well as when performing pentesting. You may be tempted to install your pentesting
    tools and exploit code on the same system you use for business or personal activities.
    It’s easy to damage your system by installing software prerequisites for various
    tools. There’s always a risk of hacking tools containing malware and infecting
    the same system that you use from day to day to send emails or access the web.
    A virtual machine provides a convenient sandbox environment with everything you
    need to quickly refresh or replace a testing environment. I have chosen to use
    Kali Linux in all demonstrations. We want to avoid installing pentesting tools
    and exploit code in the same system we use daily for business or personal use.
    It’s best to use a clean testing environment to avoid creating software dependency
    issues for us. Kali makes it easy to install the needed software packages related
    to pentesting.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machines
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a **virtual machine** is the preferred method. During a pentest, you’ll
    likely install a multitude of tools and exploit proof of concept code. At some
    point, you’ll also save sensitive data about your customer or target. A virtual
    machine provides a convenient container that you can snapshot and restore, or
    delete and replace easily after an assessment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous free and paid virtualization solutions to fit any need:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Oracle VirtualBox is a free x86 virtualization hypervisor. It’s available for
    Windows, macOS (Intel chipset), and Linux. VirtualBox is user-friendly, making
    it a popular choice for beginners and professionals alike. It supports a wide
    range of guest operating systems and offers features such as snapshots, seamless
    mode, and shared folders.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VMware offers a free version of their virtualization software called VMware
    Workstation Player for non-commercial use. It’s compatible with Windows and Linux
    hosts. Workstation Player is easy to use and supports VMware’s VMDK virtual disk
    format, and it’s also compatible with virtual machines created by other VMware
    products.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Hyper-V is free and available on Windows 10 Pro, Enterprise, and Education
    editions. While it’s more commonly used in server environments, Hyper-V can also
    be a good option for desktop virtualization on Microsoft Windows hosts.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: For those on macOS with the Apple CPU, your virtualization options are UTM,
    Parallels, and VMWare Fusion. UTM is the only free option.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Docker containers** offer a lightweight option over virtual machines. Docker
    offers a runtime for Windows, Linux, and macOS. Containers are more lightweight
    and efficient on lower-end hardware than virtual machines because they use the
    host’s kernel, so they don’t have to virtualize hardware as traditional hypervisors
    do.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Because Docker uses the host’s kernel, you’re limited to running containers
    while utilizing the same operating system as the host. Docker Desktop is an alternative
    that uses a virtual machine to run containers with a different operating system
    from the host.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Based on my experience, there are some positive and negative points to consider
    about using Docker.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Docker is more lightweight and is a good alternative to traditional hypervisors
    when your hardware is less robust. The minimum hardware resources I would assign
    to a virtual machine running Kali Linux is 4 GB of RAM and 40 GB of disk space.
    You’re not always going to be using that 4 GB/40 GB. At the same time, you’re
    limited to those values unless you shut down the virtual machine, adjust the RAM,
    and extend the disk. A Docker container runs in a native process (excluding Docker
    Desktop), so it uses only as much memory and disk space as needed to run the container.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: On a Linux host, you can attach a container directly to the host network and
    open and close ports as needed, provided you include specific command-line arguments.
    This allows you to dynamically open listening server ports on the host’s network
    adapter without stopping and starting the container. You can also attach a container
    to a USB or serial port to interface with hardware devices. I sometimes use this
    option when I need to run an old Python2 pentesting application that interfaces
    with a USB or serial device for radio frequency and hardware hacking.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: When using Docker Desktop, NAT is used to connect container network ports to
    the host’s network, so the container must be stopped and restarted if you need
    to close or open additional ports. With Docker Desktop, it isn’t possible to attach
    a container to hardware devices. This can be aggravating when you’ve configured
    an application and its dependencies on a container and then lose your work and
    have to start over when you destroy the container and start a new instance, just
    to open another TCP port for a reverse listener or server application.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker Desktop 时，NAT 用于将容器网络端口连接到主机网络，因此，如果需要关闭或打开额外的端口，必须停止并重新启动容器。在 Docker
    Desktop 中，无法将容器附加到硬件设备。当你在容器中配置了应用程序及其依赖项，之后摧毁容器并启动一个新实例时，你可能会失去工作进度并需要重新开始，特别是当你只是想为反向监听器或服务器应用程序打开另一个
    TCP 端口时，这会让人感到沮丧。
- en: 'In summary, my preference is to use Docker only on a Linux host, and I use
    it for three specific pentesting use cases:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我更倾向于仅在 Linux 主机上使用 Docker，并且我将其用于三种特定的渗透测试场景：
- en: It provides an easy way to isolate old Python 2 applications and avoid dependency
    hell. There are official Docker containers for all Python 2 and 3 versions.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一种轻松隔离旧版 Python 2 应用程序并避免依赖地狱的方式。对于所有 Python 2 和 3 版本，Docker 都有官方容器。
- en: I use it to create and run applications that aren’t available through my package
    manager, and I want to avoid wasting time solving dependency issues. For example,
    a particular hacking tool is available through the Kali software repository, but
    not in Ubuntu. I can create a thin Kali container that uses only enough resources
    to run the contained application and use an alias in my **~/.bashrc** file to
    reduce a long **docker run** command to a single word I can enter in my Terminal.
    This is a much faster and more lightweight option than a heavy virtual machine
    when I just want to run a single application that can’t be run or would be difficult
    to run on my host system.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我用它来创建和运行通过我的包管理器无法获得的应用程序，并且我想避免浪费时间解决依赖问题。例如，某个黑客工具可以通过 Kali 软件库获得，但在 Ubuntu
    中无法使用。我可以创建一个简洁的 Kali 容器，只使用足够的资源来运行其中的应用程序，并在 **~/.bashrc** 文件中使用别名，将冗长的 **docker
    run** 命令缩短为我可以在终端中输入的单个单词。当我只想运行一个无法或难以在主机系统上运行的应用程序时，这是比沉重的虚拟机更快、更轻量的选择。
- en: When I want to practice exploiting or creating an exploit tool for a recently
    announced vulnerable web application, I can frequently find a Docker container
    that allows me to immediately start the vulnerable application without spending
    precious time installing and configuring it.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我想练习利用或创建针对最近公布的易受攻击的 web 应用程序的利用工具时，我通常可以找到一个 Docker 容器，让我立即启动这个易受攻击的应用程序，而无需花费宝贵的时间进行安装和配置。
- en: Docker containers are perfect for specific use cases. However, they’re less
    preferred than virtual machines. Next, we’ll explore using live USB systems as
    an alternative to virtual machines and containers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器非常适合特定的使用场景。然而，它们不如虚拟机更受青睐。接下来，我们将探讨将 live USB 系统作为虚拟机和容器的替代方案。
- en: Live USB
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Live USB
- en: A **live USB** is an operating system image written to a USB disk in a way that
    makes it bootable. Live USB is a good choice to use when your computer doesn’t
    have the hardware resources to run a virtual machine. You can use imaging software
    to burn Linux ISO disks to USB and boot a Linux operating system. After you finish
    your work on Linux, you simply restart the computer and remove the USB drive to
    revert to the installed operating system. Some Linux distributions enable you
    to create persistent storage on the USB drive so that you don’t lose your changes
    when you reboot.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**Live USB** 是一种将操作系统镜像写入 USB 硬盘的方式，使其可以启动。Live USB 是当计算机没有足够的硬件资源运行虚拟机时的一个不错选择。你可以使用镜像软件将
    Linux ISO 镜像刻录到 USB 并启动 Linux 操作系统。在 Linux 上完成工作后，你只需重新启动计算机并拔掉 USB 驱动器，即可恢复到已安装的操作系统。某些
    Linux 发行版允许你在 USB 驱动器上创建持久存储，这样你在重启时就不会丢失更改。'
- en: 'The following are some general steps for running a Linux distribution from
    live USB:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通过 live USB 运行 Linux 发行版的一些常规步骤：
- en: Download the ISO image. Some popular Linux distributions for pentesters include
    Kali, Parrot Security OS, and BlackArch.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 ISO 镜像。一些受渗透测试者喜爱的 Linux 发行版包括 Kali、Parrot Security OS 和 BlackArch。
- en: Create a live USB drive. Common tools for this purpose include Rufus, balenaEtcher,
    and the Linux **dd** command.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 live USB 驱动器。常用的工具包括 Rufus、balenaEtcher 和 Linux 的**dd**命令。
- en: Configure persistence (optional). This usually involves creating a separate
    partition on the USB drive and configuring the bootloader to recognize and use
    this partition. You can find the documented steps required to create a live USB
    Kali system at [https://www.kali.org/docs/usb/usb-persistence/](https://www.kali.org/docs/usb/usb-persistence/)
    .
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are some considerations and drawbacks to using live USB:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: USB storage is usually much slower than running directly from an SSD. If you
    use live USB, be sure to use the USB 3.0 or 3.1 standard for best performance.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always download the ISO image from official sources and verify the checksum
    before trusting it.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re planning to use it for production use, be sure to use encrypted persistence
    due to the risk of exposing the sensitive data on the drive to someone not authorized
    to have it.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s move on and discuss cloud-based systems.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-based systems
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many cloud platforms create free tiers for access to Linux systems with enough
    resources for modest workloads. Cloud providers with free tiers include **Google
    Cloud Platform** ( **GCP** ), Microsoft Azure, and Amazon EC2. Be aware that the
    free tier may not provide enough RAM for production use and will not be suitable
    for running Kali Linux images.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux provides documentation and marketplace images for running on AWS,
    Digital Ocean, Linode, and Azure ( [https://www.kali.org/docs/cloud/](https://www.kali.org/docs/cloud/)
    ). I have experience with customers who have configured Kali in the cloud for
    cloud security assessments, or connected via VPN to their internal network infrastructure
    to facilitate internal network pentests. If the customer’s internal network is
    already connected to a cloud provider over VPN, it’s relatively easy for them
    to spin up a Kali image and create a firewall rule to allow SSH access from my
    IP address. Now that we’ve explored options for running a pentesting system with
    Bash, let’s discover a few vulnerable systems we can use to practice within our
    lab.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerable lab targets
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While following along with some of the later chapters related to pentesting
    methodology, it will be beneficial for you to have access to vulnerable targets
    when running the commands and developing your Bash scripts. There are several
    great sources of vulnerable targets you can use for practice in your lab.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Metasploitable 2 is a vulnerable virtual machine provided by Rapid7. It was
    designed to showcase the capabilities of the Metasploit Framework. Metasploitable
    2 is also a good beginner-level challenge for developing your hacker methodology
    and learning Bash for pentesting. The project requires modest resources to run
    the virtual machine and includes documentation on the machine’s vulnerabilities
    ( *Metasploitable 2 | Metasploit* *Documentation* , [https://docs.rapid7.com/metasploit/metasploitable-2/](https://docs.rapid7.com/metasploit/metasploitable-2/)
    ).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Game of Active Directory (GOAD) is also an option.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '*“GOAD is a pentesting Active Directory LAB project. The purpose of this lab
    is to give pentesters a vulnerable Active Directory environment ready to use for
    them to practice usual attack techniques* *.”* ( *Game of Active Directory –*
    *Orange-CyberDefense* , [https://github.com/Orange-Cyberdefense/GOAD](https://github.com/Orange-Cyberdefense/GOAD)
    )'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Note that GOAD is free to use and uses free Microsoft Windows licenses that
    are activated for 180 days. GOAD is the best resource I’ve found for practicing
    hacking on internal Active Directory network environments.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: MayFly is the creator of GOAD. Their website contains plenty of articles on
    how to set GOAD up on different virtual machine hypervisors, as well as lab guides
    for using common pentesting tools to hack Active Directory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: MayFly also published a comprehensive mind map for pentesting Active Directory.
    Despite having years of experience in hacking Active Directory, I still find times
    that I’m running out of things to test and will refer to this mind map when I
    get stuck or want to ensure that I’ve left no stone unturned. This mind map is
    also the number one resource I recommend to junior pentesters who are learning
    Active Directory hacking techniques and tools (you can find more details at [https://orange-cyberdefense.github.io/ocd-mindmaps/img/pentest_ad_dark_2022_11.svg](https://orange-cyberdefense.github.io/ocd-mindmaps/img/pentest_ad_dark_2022_11.svg)
    ).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to practice your Bash scripts, tools, and methodology on web applications,
    OWASP Juice Shop is a great resource.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '*“OWASP Juice Shop is probably the most modern and sophisticated insecure web
    application! It can be used in security training, awareness demos, CTFs, and as
    a guinea pig for security tools! Juice Shop encompasses vulnerabilities from the
    entire OWASP Top Ten* ( [https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)
    ) *, along with many other security flaws found in real-world applications!”*
    ( *OWASP Juice Shop – OWASP* *Foundation* , [https://owasp.org/www-project-juice-shop/](https://owasp.org/www-project-juice-shop/)
    )'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: An older yet still very relevant vulnerable web application is Mutillidae II.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '*“OWASP Mutillidae II is a free, open source, deliberately vulnerable web application
    that provides a target for web-security training. With dozens of vulnerabilities
    and hints to help the user, this is an easy-to-use web hacking environment designed
    for labs, security enthusiasts, classrooms, CTF, and vulnerability assessment
    tool targets.”* ( *OWASP Mutillidae II – OWASP* *Foundation* [https://owasp.org/www-project-mutillidae-ii/](https://owasp.org/www-project-mutillidae-ii/)
    )'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: One of the things I love about Mutillidae is that it embeds hints, tutorials,
    and video tutorials in the content. Mutillidae is a resource I used many years
    ago to learn web app testing when I was a junior pentester. The difference between
    Juice Shop and Mutillidae is that Juice Shop is a modern web application that
    uses JavaScript frameworks, whereas Mutillidae is a more traditional web application.
    While Juice Shop has a scoreboard and you can find third-party walkthroughs online,
    Mutillidae has a large amount of training text and video embedded in the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The cybersecurity landscape is always changing, and new vulnerabilities are
    discovered regularly. A lab setup is an ideal place for research and development,
    allowing you to experiment with these vulnerabilities safely. It’s where you can
    contribute to the cybersecurity community by discovering new vulnerabilities or
    enhancing existing pentesting methodologies.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored vulnerable targets for your pentesting lab, next up,
    we’ll talk about customizing your Bash shell so that it suits your needs and personal
    style.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your hacker shell
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re following along using Kali Linux or macOS, note that your Terminal
    shell uses Zsh by default instead of Bash. Zsh has more features (such as better
    tab completion and theme support) but Bash is more widespread and standard. Bash
    has been around since the late 80s, making it a veteran in the shell world. It’s
    the default on most Linux distributions and macOS (up until Catalina, where Zsh
    took over). Bash’s longevity means it’s extremely stable and well-supported.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Zsh, on the other hand, came a bit later. It’s known for its improvements over
    Bash, including better interactive use and more powerful scripting capabilities.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: You can determine which shell is configured by entering the **echo $SHELL**
    command in your terminal. Almost all code shown in this book will work in both
    Bash and Zsh, except where noted. In my day-to-day pentesting activities, I rarely
    notice any difference. However, if you want to change your shell from Zsh to Bash,
    execute the **chsh -s /bin/bash** command in your Terminal, then log out and log
    in to see the change take place.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Bash configuration files can be found in the user home directory, **/home/username**
    . Because the filenames begin with a period character, they are commonly referred
    to as *dotfiles* . The following configuration files are used to configure the
    Bash shell:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**~/.bash_profile** : This file is executed at the start of an interactive
    login and is used to initialize the user environment. Think of an interactive
    login as logging in via the command line via a text-based Terminal such as an
    SSH session.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**~/.bashrc** : This file is used to configure the Terminal when you’ve logged
    in through the **graphical user interface** ( **GUI** ). This file contains settings
    including aliases, functions, prompt customizations, and environment variables.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**~/.bash_logout** : This file is executed when your session ends. It’s used
    to perform tasks related to cleaning up the environment when you log out.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t understand the purpose of the tilde ( **~** ) character and forward
    slash preceding the dotfile name, the tilde character represents the user’s home
    directory. The **~/.bashrc** path is equivalent to **/home/username/.bashrc**
    . This concept will be covered in [*Chapter 2*](B22229_02.xhtml#_idTextAnchor034)
    .
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The most common edits you’ll want to make will include adding aliases and functions
    and customizing your command prompt in your **~/.bashrc** file. Aliases are a
    great way to shorten long or complex commands to a single word. Functions are
    more complex. Think of functions as a short script that you can include in your
    shell configuration and call by name in your Terminal. Functions will be discussed
    later in [*Chapter 5*](B22229_05.xhtml#_idTextAnchor089) .
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example alias from my **~/.bashrc** file that I use to search for
    IP addresses in text:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see how this command would be difficult to remember, so it helps to
    create an alias for any complex command you may need to use repeatedly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: When you make edits to your Bash configuration files, you must either log out
    and log in or source the file to enact the change.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command to source a file and enact changes immediately:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that you understand the purpose of Bash’s dotfiles, let’s move on and take
    a look at how we can edit them to personalize our environment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Bash prompt
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prompt is where you enter commands in the Bash Terminal. Your prompt can
    be as simple or complex as you desire to meet your tastes and reflect your personality.
    Think of your prompt design choices like how a painter chooses their palate.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find your currently configured prompt by looking in your **~/.bashrc**
    file for a line that begins with **PS1** . A common Bash prompt would use a **PS1**
    value such as **export PS1="\u@\h \w\$ "** , and it would look like **username@hostname
    ~$** at the prompt. Let’s break this down. Here’s what each part does:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**\u** will be replaced by the current username.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@** is a literal character and will appear after the username.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**\h** will be replaced by the hostname up to the first period.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**\w** will be replaced by the current working directory, with **$HOME** abbreviated
    to a tilde character.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**\$** displays a **$** character for a regular user, or **#** for the root
    user.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you edit your **PS1** prompt, be sure to source the file to see the changes
    take effect.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: You can also get really fancy with your prompt. I’ve been known to insert the
    **$(ip a show eth0 | grep -m 1 inet | tr -s ' ' | cut -d ' ' -f 3)** string in
    the middle of my **PS1** prompt to show my IP address for capturing in my logs
    or report screenshots for the customer to correlate my activity with their **Security
    Information and Event Management** ( **SIEM** ) alerts. See [https://bash-prompt-generator.org/](https://bash-prompt-generator.org/)
    for a graphical Bash prompt generator, or the official Bash manual for all options.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Customizing your Bash environment is about making your Terminal work for you.
    It’s a process of trial and improvement, finding what makes you more productive,
    and what brings a bit of joy into your command-line sessions. Start small, experiment,
    and see how a few changes can make a big difference in your daily tasks.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Setting up essential pentesting tools
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll go over setting up our pentesting environment by updating
    system software packages and installing the tools required to follow along. Most
    of the tools needed will already be installed in Kali, so we’ll only need to install
    a few more software packages.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Update the package manager
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your first step when using a new Linux installation should be updating packages.
    As stated earlier, I’ll be using Kali Linux in all demonstrations. Kali is based
    on the Debian Linux distribution, which uses the **Advanced Package Tool** ( **APT**
    ) package manager. At its core, **apt** streamlines software management. It automates
    the process of retrieving, configuring, and installing software packages from
    predefined repositories. This automation not only saves time but also ensures
    that software dependencies are resolved without manual intervention.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Running **sudo apt update** refreshes the local database of available packages
    and their versions, ensuring you have the latest information from the repositories.
    This step is crucial before installing new software or updating existing packages
    to ensure you’re getting the latest versions. If you’re using Kali, Ubuntu, or
    Debian Linux, the following commands to update and upgrade will work as expected
    because they all use the **apt** package manager:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding command, we use **sudo** to elevate privileges and **apt**
    to update the list of available packages. The double ampersand symbols ( **&&**
    ) operate like a logical AND operator; the second command to upgrade packages
    without prompting ( **-y** ) is only run if the first command results in success.
    Finally, we reboot to ensure that all services and kernel updates take effect.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Install ProjectDiscovery tools
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ProjectDiscovery** offers some great tools I recommend for pentesting (PDTM
    – ProjectDiscovery, [https://github.com/projectdiscovery/pdtm](https://github.com/projectdiscovery/pdtm)
    ). Before we can install them, we must install the Go programming language runtime
    and libraries. Follow these steps to do so:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: In your web browser, navigate to [https://go.dev/dl/](https://go.dev/dl/) .
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the correct package for your Linux distribution. Be sure to look closely
    at the processor architecture. Typically, this would be a **Kind** value of **archive**
    , an **OS** value of **Linux** , and an **Arch** value of either **x86-64** or
    **ARM64** .
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extract the downloaded archive. Be sure to change the package version so that
    it matches what you downloaded:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add **/usr/local/go/bin** to the **PATH** environment variable in your **~/.bashrc**
    file. The **PATH** environment variable tells your Bash shell where to find the
    full path to an executable program when you don’t include the path before your
    command. The **echo** command prints the text inside quotes to the Terminal and
    the greater-than symbol ( **>** ) redirects the output to a file. Notice that
    we use two greater-than symbols here to redirect the output. If we were to use
    only one, it would overwrite the file contents. We want to append to the file
    by using two:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Source the file to enact your changes:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Check to ensure that **/usr/local/go/bin** has been appended to your **PATH**
    (look after the last colon character):'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Verify that Go has been installed properly and can be found in your **PATH**
    . Your version and architecture may vary:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Install **pdtm** from ProjectDiscovery. This is the tool that installs and
    manages updates for all of ProjectDiscovery ’s tools:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add **pdtm** to your path:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the following **pdtm** command to install all tools:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Install **libpcap** for **naabu** :'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That wraps up installing all of the needed ProjectDiscovery tools.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Install NetExec
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*NetExec is a network service exploitation tool that helps automate assessing
    the security of large networks* ( *NetExec* *wiki* , [https://www.netexec.wiki/](https://www.netexec.wiki/)
    ).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, NetExec is one of the most useful tools for internal network
    pentesting. It supports most of the network protocols needed during internal network
    pentesting, plus Microsoft Active Directory testing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'There are far too many features to list here. Some of the things I use NetExec
    for include the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for vulnerabilities; NetExec includes some useful modules to test for
    common vulnerabilities
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute-force attacks on authentication to test for weak passwords
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spraying a password or password hash against servers to find where the supplied
    credentials have local administrator access
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command execution
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering credentials
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating SMB shares for read/write access
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enter the following command to install NetExec:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That wraps up the process of installing the most common pentesting tools that
    are not installed by default.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to the indispensable world of Bash shell
    scripting, a cornerstone skill for anyone aspiring to excel in pentesting. This
    chapter began by demystifying what Bash is and underscoring its significance in
    cybersecurity tasks. It wasn’t just about memorizing commands; it was about leveraging
    Bash to automate repetitive tasks, manipulate data, and conduct security assessments
    with efficiency. The journey continued with guidance on selecting the appropriate
    operating system that supports Bash, setting the stage for successful scripting
    endeavors. Then, we rolled up our sleeves to configure our hacker shell, customizing
    its appearance and behavior to reflect personal tastes and preferences. This customization
    wasn’t just for aesthetics; it was about creating a functional and efficient working
    environment. Finally, this chapter introduced essential pentesting tools, walking
    you through their installation and basic usage. At this point, you're equipped
    with a well-prepared environment and a foundational understanding of how Bash
    scripting can significantly enhance your pentesting capabilities.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover techniques for working with files and directories.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
