- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File and Directory Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering Bash file and directory management equips you with the skills to navigate
    the filesystem efficiently, manipulate files and directories, control access through
    permissions, and automate routine tasks. These abilities are essential for anyone
    looking to harness the full power of their Linux or Unix system. With practice,
    patience, and a bit of creativity, you can turn the complexity of the filesystem
    into a well-organized collection of files and directories at your command.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will become skilled at creating, deleting, copying,
    and moving files. You will understand the significance of absolute and relative
    paths. This will also include an introduction to directory structures and how
    to efficiently navigate the filesystem in a Bash environment. You’ll grasp the
    concept of user and group permissions in a Linux environment. You’ll learn the
    difference between hard links and **symbolic links** ( **symlinks** or soft links),
    how to create them, and scenarios where each type of link is useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directory navigation and manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File permissions and ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking files—hard links and symlinks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Access to a Linux system with a Bash shell is required to follow along. All
    commands used in this chapter can be found in the GitHub code repository located
    at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter02](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter02)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Working with files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll cover commands for working with files and directories
    and how to navigate the filesystem. We’ll start with the **ls** command, which
    is used to list files, directories, and their permissions.
  prefs: []
  type: TYPE_NORMAL
- en: The **ls** command in Bash is like the Swiss Army knife for listing directory
    contents. It’s simple yet packed with options to customize the output to your
    needs. Let’s dive into how you can use **ls** to make your life at the terminal
    easier and more productive.
  prefs: []
  type: TYPE_NORMAL
- en: 'At its most basic, **ls** will list the files and directories in your current
    directory using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display all non-hidden files and directories. Hidden files (those
    starting with a dot) won’t show up. To see hidden files as well, use the **-a**
    option to get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Hidden files are shown when using the -a option with the ls
    command](image/B22229_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Hidden files are shown when using the -a option with the ls command
  prefs: []
  type: TYPE_NORMAL
- en: Now, you’ll see everything, including files such as **.bashrc** .
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to view a listing of files and directories in a location different
    from the current directory, add the directory location to the end of the **ls**
    command as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In a shell command such as **ls *.txt** , the asterisk ( ***** ) is referred
    to as a **glob** character. The ***** character matches any sequence of characters,
    so this command lists all files in the current directory that have a **.txt**
    extension. You could also use the glob character to list all files that start
    with a specified string and end with any character or series of characters using
    the **ls** **sometext*** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **-l** option for more details, such as file permissions, number of
    links, owner, group, size, and timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Extended file and directory information is displayed using the
    ls command -l option](image/B22229_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Extended file and directory information is displayed using the
    ls command -l option
  prefs: []
  type: TYPE_NORMAL
- en: This long format is incredibly useful for getting a quick overview of the filesystem’s
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using **-l** , file sizes are listed in bytes by default. Add the **-h**
    option to make sizes more readable (for example, KB, MB). This makes it easier
    to gauge file sizes at a glance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – The ls command -h option displays file sizes in a human-readable
    format](image/B22229_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – The ls command -h option displays file sizes in a human-readable
    format
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the most recently modified files at the top, use the **-t** option.
    To sort the output of **ls -t** in reverse, include the **-r** option. Combine
    this with **-h** to get a detailed, human-readable list of files sorted by modification
    time, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The ls command options show how to sort based on file modification
    time](image/B22229_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – The ls command options show how to sort based on file modification
    time
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting files by size can quickly show you the largest or smallest files in
    a directory. The following command will sort the output of **ls** based on file
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you want to see not just the contents of the current directory but
    all subdirectories as well. Use **-R** to show the contents of all subdirectories
    recursively.
  prefs: []
  type: TYPE_NORMAL
- en: Some common actions you may want to take on a file or directory besides listing
    them with the **ls** command include making, copying, and deleting them.
  prefs: []
  type: TYPE_NORMAL
- en: You can make a new file or directory with the **touch** and **mkdir** commands,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a new empty file, as shown next, using the **touch** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a new directory, as shown, using the **mkdir** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to create multiple nested directories in a path, include the **-p**
    option. For example, suppose you want to create a new directory named **first**
    , and inside of **first** , you want to create a **second** directory. The following
    example creates this new directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can copy files and directories using the **cp** command. The syntax of
    the **cp** command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete a file, use the **rm** command. Be careful with this command because
    deletions cannot be recovered. If you’re deleting a directory, include the **-r**
    option to recursively delete files and directories contained in the directory.
    The following command demonstrates how to delete a file using **rm** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve learned how to list, create, and delete files, it’s time to
    move on to learning how to navigate your filesystem in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Directory navigation and manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll learn the layout of the Linux filesystem directories,
    the purpose of common directories, and how to navigate your way around the system.
    By the end of this section, you should be comfortable with the location and design
    decisions of the filesystem and will be using common Bash commands to navigate
    it like a pro.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem design and hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the heart of Bash file management is an understanding of the filesystem hierarchy.
    Here, we’ll review the various filesystem directories and their purpose. We’ll
    also review particular directories of interest to pentest. This will enable you
    to be confident as you navigate your filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the filesystem as a tree with branches spreading out from the trunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the **tree** command, you can find a high-level overview of the filesystem,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – An overview of the filesystem hierarchy](image/B22229_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – An overview of the filesystem hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand the elements of this high-level overview as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**/** : At the root of this structure lies the **/** directory, known simply
    as the root. This is the starting point: the base from which everything else extends.
    Imagine it as a tree trunk from which all other paths diverge. The following figure
    demonstrates running the **tree** command without specifying the number of levels
    to show the full layout of the filesystem:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.6 – A deeper understanding of the directory structure as a tree
    is discovered](image/B22229_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – A deeper understanding of the directory structure as a tree is
    discovered
  prefs: []
  type: TYPE_NORMAL
- en: '**/bin** : Directly under the root, you’ll find **/bin** , a directory filled
    with essential user binaries or programs. These are the tools every user has access
    to and are necessary for daily operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/boot** : The **/boot** directory contains files required for booting the
    system, such as the Linux kernel and initial RAM disk ( **initrd** ) files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/dev** : The **/dev** directory contains device files that represent hardware
    devices and special files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc** : The **/etc** directory contains many configuration files that are
    critical to the operation of the system. As a pentest, you may be interested in
    certain files and directories within **/etc** . Here are some of the most notable
    ones:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc/passwd** : This file contains essential information about users on the
    system, such as user IDs, group IDs, home directories, and shells.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc/group** : This file contains a list of groups on the system, along with
    their group IDs and member usernames.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc/shadow** : This file stores password information for users, including
    hashed passwords and account expiration dates.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc/sudoers** : This file contains a list of users and groups that are allowed
    to use the **sudo** command to execute commands with elevated privileges.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc/sysconfig** : This directory contains configuration files for various
    system services and applications, such as network settings, display manager configurations,
    and firewall rules.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc/network** : This directory contains configuration files for network
    interfaces, including IP addresses, subnet masks, and **Domain Name System** (
    **DNS** ) server settings.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc/hosts** : This file maps hostnames to IP addresses, allowing the system
    to resolve hostnames to IP addresses without relying on DNS servers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc/services** : This file lists services that are available on the system,
    along with their port numbers and protocols.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc/protocols** : This file lists network protocols that are supported by
    the system, along with their version numbers and other configuration details.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/etc/fstab** : This file contains information about filesystems that are
    mounted on the system, including mount points, filesystem types, and options.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/home** : User-specific data resides in **/home** , a collection of personal
    spaces within the filesystem. Each user’s directory is like their home, storing
    personal files and settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/lib** : System libraries, the shared resources that programs need to run,
    are kept in **/lib** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/mnt** : For mounting external devices or filesystems, there are **/mnt**
    and **/media** . These act as docks for external filesystems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/opt** : Optional or third-party software is stored in **/opt** . It’s common
    for pentesters to clone **git** repositories to their own directory under **/opt**
    to run tools that aren’t installed in the usual **/** **bin** directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/proc** : The **/proc** directory stores information about running processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/root** : The home directory of the root user is located at **/root** . Because
    root is the superuser, its files are stored separately from other users found
    under **/home** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/run** : The **/run** directory is a temporary filesystem that stores transient
    information since the last boot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/sbin** : Adjacent to **/bin** is **/sbin** , housing system binaries. These
    are utilities typically reserved for the system administrator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/srv** : The **/srv** directory stores data used by system services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/sys** : The **/sys** directory provides an interface to kernel objects and
    their attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/tmp** : The **/tmp** directory stores temporary files that are removed on
    system reboot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/usr** : The **/usr** directory is a broader collection of user binaries,
    libraries, documentation, and more. It’s like a city’s commercial district, offering
    a wide array of services beyond the essentials found in **/bin** and **/lib**
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var** : The **/var** directory on a Linux system is a key component of the
    filesystem hierarchy, with its primary purpose being to store variable data, files,
    and directories expected to grow in size over time. This can include logs, spool
    files, temporary files, and other types of transient or dynamic data that change
    or expand as the system operates. The structure and contents of the **/var** directory
    are designed to accommodate the storage of variable data across system reboots,
    ensuring that data persists between sessions. Here are some significant subdirectories
    within **/var** and their typical uses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var/log** : Contains log files generated by the system and various applications
    running on it. These logs can include system logs, application logs, and logs
    of system events, which are crucial for troubleshooting and monitoring system
    health.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var/spool** : Used for queuing up tasks and data, such as print jobs, mail,
    and other queued tasks. This area is designed to hold data that is awaiting processing
    by some service or application.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var/tmp** : Intended for temporary files that are preserved between system
    reboots. Unlike **/tmp** , which may also store temporary files, **/var/tmp**
    is not meant to be deleted or cleared at reboot.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var/cache** : Stores cached data from applications. This data can be regenerated
    as needed, but it’s stored to improve performance by reducing the need to recalculate
    or fetch the same data repeatedly.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var/mail** : Holds users’ email messages in some configurations. This directory
    is essential for systems that handle on-site mail storage.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var/www** : Commonly used as the default directory for web server content.
    This includes websites hosted on the server, and it’s a standard location for
    web files in many Linux distributions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var/lib** : Contains dynamic state information that programs typically modify
    while they run. This can include databases, application state files, and other
    data that applications need to store and manage during operation.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read the documentation of the Linux filesystem hierarchy by entering
    the **hier** command as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The **man** command is short for manual. Remember to use **man** when you need
    to discover options and conventions required by a command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the current working directory may be displayed in the Bash shell prompt,
    you can print the current directory using the **pwd** command as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve discovered the filesystem layout and understand its hierarchy
    and design, let’s move on to find out how to navigate it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem navigation commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Navigating the filesystem can be done using various tools and techniques. The
    most common way is to use the **command-line interface** ( **CLI** ) and navigate
    through directories using the **cd** command. For example, to change to the **/home**
    directory, you would type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, we mentioned how the tilde ( **~** ) character is a shortcut to
    typing the full path to the user directory, so you could also navigate to your
    home directory by using the tilde after the **cd** command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you have tab completion configured in your profile, you can also use the
    tab key to autocomplete directory names as you type, making it easier to navigate
    the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to **cd** , the Bash shell provides several commands to navigate
    through directories, including **pushd** and **popd** . These two commands are
    like a trail of breadcrumbs left in the wilderness, helping you track where you’ve
    been so that you can easily return. When you **pushd** into a directory, Bash
    remembers your current location before moving you to the new one. Need to get
    back? Just **popd** , and you’re returned to your previous directory. It’s like
    having a teleportation device in your command-line toolkit. The following command
    output demonstrates the use of the **pushd** and **popd** commands to navigate
    the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This would be a good time to mention **absolute** versus **relative** paths.
    An absolute path is the full path, starting from the root ( **/** ) of the drive.
    An absolute path to a file in your home directory would be **/home/user/filename**
    . The relative path would be in relation to the directory you’re currently in.
    The current directory is represented by a period and slash ( **./** ). One directory
    up in the hierarchy is represented by **../** . Two levels up would be **../../**
    , and so on. To go down into a subdirectory from where you are now, you’d simply
    use the directory name. For example, to reference a file two directories down
    from the current directory, this would be **directory1/directory2/filename** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine you’re working deep within a directory tree and need to jump back
    several levels. Typing **cd ../../..** is not only tedious but also prone to error.
    Enter the **cd -** command, a simple yet powerful shortcut that instantly takes
    you back to the last directory you were in. It’s like having an undo button for
    your navigation mistakes. Here, we see how it works and takes us back to where
    we came from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: But what if you could jump to frequently used directories without remembering
    their paths? That’s where aliases come into play. By adding lines such as **alias
    docs='cd /home/user/documents'** to your **.bashrc** file, you create shortcuts
    for those long-winded paths. Suddenly, moving to your **documents** folder is
    as easy as typing **docs** . It’s like setting up personal shortcuts in a vast
    city.
  prefs: []
  type: TYPE_NORMAL
- en: For those who love efficiency, the *Ctrl* + *R* reverse search functionality
    is a game-changer. Press these keys and start typing part of a previously used
    command. Bash will search through your history and suggest commands that match.
    It’s like having a search engine for your command history, saving you from retyping
    long commands.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let’s not forget about tab completion, a feature that feels almost magical.
    Start typing the name of a directory or file and hit the *Tab* key. Bash will
    either autocomplete it for you or show you the possible completions if there’s
    more than one match. It’s similar to having a personal assistant who finishes
    your sentences but for directory navigation.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, mastering these advanced Bash navigation tips and tricks can
    transform your command-line experience from frustrating to fluid. Whether it’s
    jumping back and forth between directories with **pushd** and **popd** , creating
    shortcuts with aliases, or leveraging the power of reverse search and tab completion,
    these techniques are all about making your life easier. So, next time you open
    the terminal, remember these tricks and watch how quickly you can move through
    your filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should have a firm grasp of the filesystem layout and be confident
    as you navigate around the system. Next, we’ll explore filesystem permissions.
  prefs: []
  type: TYPE_NORMAL
- en: File permissions and ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, you may have noticed a string that looked similar to
    **drwxr-xr-x** in the output of the **ls -l** command. This represents the permissions
    of a file or directory. Linux filesystem permissions are like the rules at a playground.
    They determine who can play on the swings (access files), who can invite friends
    to play (change permissions), and who can set rules (ownership). Understanding
    these permissions is crucial for anyone looking to manage a Linux system effectively.
    Let’s break it down into simple terms, including the use of **chown** , **chmod**
    , **SUID** , and **SGID** .
  prefs: []
  type: TYPE_NORMAL
- en: Ownership and groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every file and directory in Linux has an owner and a group associated with
    it. Think of the owner as the parent who has control over their child’s toy and
    the group as selected friends who can play with it under certain conditions. The
    following description may help:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Owner** : The user who has control over the file or directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group** : A set of users who share certain permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing ownership – chown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To change who owns a file or directory, we use the **chown** command (this
    may require prefixing the command with **sudo** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This command changes both the owner and the group of the file. If you want
    to change just the owner or the group, you can omit the group in the command.
    However, if you omit the user, the group must be preceded with a colon character.
    The following command demonstrates how to change only the group ownership of a
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That would leave the owner intact but change the group on the file or directory
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a file and want to apply the same permissions used on a reference
    file, include the **--reference** parameter, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two common **chown** options that you should be familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-h** : Affect symlinks instead of any referenced file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-R** : Operate on files and directories recursively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having learned to use **chown** to change file ownership, in the next section,
    you’ll learn how to modify permissions using **chmod** .
  prefs: []
  type: TYPE_NORMAL
- en: Modifying permissions – chmod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Permissions determine what actions can be performed on a file or directory.
    There are three types of permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read** ( **r** ): View the contents of a file or directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write** ( **w** ): Modify the contents of a file or directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execute** ( **x** ): Run a file as a program or access a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Permissions are set for three categories of users:'
  prefs: []
  type: TYPE_NORMAL
- en: Owner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can enumerate the permissions on a file or directory using the **ls -l**
    command. The following command output demonstrates how to list file permissions
    using **ls** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The permissions shown previously indicate the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: The first character is **-** , meaning it is a file. A directory would be represented
    by **d** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the initial **–** character indicating a file, the next three characters
    represent the user permissions ( **steve** ). This is who owns the file. These
    characters are **rw-** , which translates to the file owner who has read and write
    permissions, but the file is not executable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next three characters represent the group ( **steve** ). The permissions
    are **r--** , which means that the **steve** group can read the file but can’t
    write to it and can’t execute it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last three characters are **r--** . This means that anyone other than the
    owner or group members can read the file but cannot write to it or execute it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s visualize file permissions to make them easier to understand. The following
    diagram shows how to decipher read, write, and execute permissions and how they
    can be combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Filesystem permissions broken down by rwx bits](image/B22229_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Filesystem permissions broken down by rwx bits
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated earlier, the permissions are repeated in three groups of **rwx**
    . As read ( **r** ) = **4** , write ( **w** ) = **2** , and execute ( **x** )
    = **1** , you can add them to represent the permissions with a single number in
    place of three characters. The following diagram shows a numeric representation
    of permissions from each possible combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Filesystem permissions shown with octal representation](image/B22229_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Filesystem permissions shown with octal representation
  prefs: []
  type: TYPE_NORMAL
- en: 'Using **chmod** , we can change these permissions. For example, the following
    command sets permissions to read, write, and execute for the owner and read and
    execute for the group and others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use **chmod** to modify files symbolically. For example, if you
    wanted to make a file executable, you could use the command as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After having learned basic file permissions, in the next section, you’ll learn
    some special permissions that have an effect when a user other than the owner
    executes a file.
  prefs: []
  type: TYPE_NORMAL
- en: Special permissions – SUID and SGID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SUID** (Set User ID) and **SGID** (Set Group ID) are special types of permissions
    that can be set on executable files. They allow users to execute a file with the
    permission of the file’s owner or group, respectively. When an executable with
    **SUID** permission is run, it operates with the privileges of the file owner
    rather than the user who launched it. Similarly, an executable with **SGID** permission
    runs with the privileges of the file’s group owner. This mechanism allows users
    to perform tasks under elevated privileges that are normally restricted. They
    can be briefed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SUID** : If set on an executable file, users who run this file get the same
    privileges as the owner of the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SGID** : Similar to **SUID** but applies to group permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To set **SUID** using the **chmod** command, you would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To set **SGID** using the **chmod** command, you would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From a system security perspective, **SUID** and **SGID** are double-edged swords.
    On the one hand, they’re essential for tasks that require temporary elevation
    of privileges without exposing sensitive credentials. For example, the **passwd**
    command, which allows users to change their passwords, needs access to the system’s
    shadow file—a file regular users can’t touch. With **SUID** permission set on
    **passwd** , users can update their passwords while the command runs with elevated
    privileges necessary to modify the shadow file.
  prefs: []
  type: TYPE_NORMAL
- en: However, on the other hand, this power can be exploited if not carefully managed.
    Hackers salivate at the prospect of finding executables with **SUID** or **SGID**
    permissions improperly set. Why? Because it opens a door to elevating their privileges
    on a system. Imagine a scenario where a benign-looking executable has **SUID**
    permission and is owned by root. If this executable has any vulnerability, it
    allows arbitrary command execution; a hacker can leverage it to execute commands
    as root, effectively taking over the system.
  prefs: []
  type: TYPE_NORMAL
- en: Hackers employ various techniques to exploit **SUID** and **SGID** permissions.
    They might scan a system for all files with these permissions set and then attempt
    to exploit vulnerabilities in those files. Another common tactic is binary planting,
    where a hacker replaces or links a legitimate **SUID** / **SGID** file with a
    malicious one, waiting for an unsuspecting user to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting against such exploits involves diligent management of **SUID** and
    **SGID** permissions. Regular audits of these permissions can help identify and
    rectify potential vulnerabilities. System administrators should ensure that only
    absolutely necessary files have **SUID** or **SGID** permissions and that these
    files are kept up to date to mitigate known vulnerabilities. Additionally, employing
    **intrusion detection systems** ( **IDSs** ) can help monitor for unusual activity
    related to these permissions.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, while **SUID** and **SGID** are indispensable tools in Linux
    for managing privileged operations, they must be handled with care. Their misuse
    or misconfiguration can turn them into weapons in a hacker’s arsenal. By understanding
    their function and potential for abuse, system administrators can better safeguard
    their systems against unauthorized privilege escalation, and you as the pentest
    can understand the intricacies when auditing system security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding Linux filesystem permissions is like learning the rules of a
    new game. Once you know who can do what (permissions), who owns what (ownership),
    and how to change these (using **chown** and **chmod** ), you’re well on your
    way to managing your Linux system effectively. Remember: *with great power comes
    great responsibility* . Use these commands wisely to keep your system secure and
    functional.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve become a pro at listing and setting filesystem permissions,
    let’s move on to the next section and discover filesystem symlinks.
  prefs: []
  type: TYPE_NORMAL
- en: Linking files – hard links and symlinks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **hard link** is essentially an additional name for an existing file on the
    filesystem. Imagine you have a favorite book in your library. One day, you decide
    it belongs in both the *Classics* and *Favorites* sections. Instead of buying
    a new copy, you simply place another label on the book that leads readers from
    both sections to it. In the world of Linux, creating a hard link means you’re
    adding a new reference to the file, but it’s the same single file on the disk.
    If you delete the original filename, the content remains accessible through the
    hard link. It’s like magic: the book remains on the shelf, even if one of its
    labels is removed.'
  prefs: []
  type: TYPE_NORMAL
- en: However, hard links have their limitations. They cannot span across different
    filesystems; a hard link on one drive can’t point to a file on another, and they
    cannot link to directories to prevent potentially creating loops within the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Enter **symlinks** , which are more flexible and akin to shortcuts. Using our
    library analogy, a symlink would be like placing a note in the *Classics* section
    that directs you to the book’s location in *Favorites* . This note is not the
    book itself but a pointer to where the book can be found. In Linux, a symlink
    is a separate file that points to another file or directory. Unlike hard links,
    if you remove the original file, the symlink breaks because its reference point
    is gone. It’s as if someone took the book out of the library. The note in *Classics*
    now leads to an empty spot on the shelf.
  prefs: []
  type: TYPE_NORMAL
- en: Symlinks shine with their ability to cross filesystem boundaries and link to
    directories, making them incredibly versatile for tasks such as creating accessible
    paths to deeply nested directories or maintaining compatibility between different
    versions of files or programs.
  prefs: []
  type: TYPE_NORMAL
- en: Why use these links? Efficiency and convenience are the primary reasons. Hard
    links allow you to have multiple access points for a single file without duplicating
    its content, saving space. Symlinks offer a way to create easy-to-navigate structures
    in your filesystem without moving or duplicating files.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, managing these links is straightforward with commands such as **ln**
    for creating both hard links and symlinks ( **ln** for hard links and **ln -s**
    for symlinks) and **ls -l** to view them. The real art comes in knowing when to
    use each type of link. Hard links are great for backup systems or when working
    within a single filesystem where file integrity is crucial. Symlinks are perfect
    for creating flexible paths and shortcuts, especially across different filesystems
    or when linking directories.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, hard links and symlinks offer creative ways to manage and access
    files, each with its own set of rules and potential uses. Whether you’re optimizing
    your workspace or crafting intricate systems, understanding these links opens
    up a world of possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, mastering Bash file and directory management equips you with
    the skills to navigate the filesystem efficiently, manipulate files and directories,
    control access through permissions, and automate routine tasks. These abilities
    are essential for anyone looking to harness the full power of their Linux or Unix
    system. With practice, patience, and a bit of creativity, you can turn the complexity
    of the filesystem into a well-organized collection of files and directories at
    your command. As a pentest, it’s crucial that you understand the complexities
    of the Linux filesystem in order to audit systems and exploit them to demonstrate
    risk.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll be learning about regular expressions, and soon,
    you’ll be slicing and dicing text and command output like a Samurai wields a sword!
  prefs: []
  type: TYPE_NORMAL
