- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables, Conditionals, Loops, and Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we provided information that led up to the topics we’ll
    be covering here. We did this by walking you through the process of getting your
    system set up and common commands that are used for navigating the Linux filesystem
    using Bash commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll dive into the essentials of programming that make your
    code smart and efficient: **variables** , **conditionals** , **loops** , and **arrays**
    . Think of variables as name tags referring to data, conditionals as crossroads
    that decide which path your program takes, and loops as the way you can keep doing
    something until a certain condition is met. These concepts are the building blocks
    for creating dynamic and responsive programs. Whether you’re just starting or
    brushing up on the basics, understanding these elements is critical for any coding
    journey.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching with conditional statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeating with loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using arrays for data containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ll need a Linux Bash Terminal to follow along. You can
    find this chapter’s code at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter03](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter03)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Introducing variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think of variables as name tags or containers that store data. You can assign
    any data, such as text, numbers, filenames, and more, to a short and memorable
    variable name. Throughout your script, you can repeatedly refer to the data by
    its given variable name and make decisions on the data or even change the data
    the variable refers to. Technically, a variable is a declaration that allocates
    memory storage space and assigns it a value.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we’ll be breaking the subject of variables into
    bite-sized chunks to make it easier to digest.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To declare a variable in Bash, you simply assign a value to a variable name.
    The syntax for declaring a variable is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to declare a variable named **my_variable** with a value of **Hello,
    World!** , you would use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There should be no spaces around the equals sign, **=** . Also, it’s good practice
    to enclose string values in double quotes, **"** , as it allows for proper handling
    of spaces and special characters. Use single quotes to prevent expansion; double
    quotes if you want variables or special characters to be expanded. If you must
    use special characters such as **$** in a double-quoted string, you can make them
    display as a literal character instead of being evaluated by escaping the character
    with a backslash – for example, **\$** .
  prefs: []
  type: TYPE_NORMAL
- en: 'One powerful feature of Bash variables is their ability to store the output
    of commands using **command substitution** . This can be achieved by enclosing
    the command within backticks **`** , or using the **$()** syntax. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Both commands will store the current date and time in the **current_date** variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Bash, you can pass arguments to a script when you run it from the command
    line. These arguments are stored in special variables, which you can then use
    inside your script. Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the script, you can access these arguments using the following special
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**$0** : The name of the script itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$n** : The n th argument passed to the script, **$1** through **$9** . Examples
    include **$1** , **$2** , and **$3**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**${10}** : The tenth argument passed to the script (curly braces are required
    for arguments >= 10)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$#** : The number of parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$?** : The exit status of the last executed command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$$** : The process ID of the current shell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$@** : Contains the command-line arguments in an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$*** : Represents all the positional parameters (arguments) passed to the
    script or a function as a single string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To access the value of a variable, you simply use the variable’s name preceded
    by a dollar sign, **$** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_variables_01.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following script shows how to access command-line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_variables_02.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this script, we’ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What would happen if you entered your first and last name without enclosing
    them in double quotes? Give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can perform arithmetic operations on variables using the **$(())** syntax
    or the **let** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_variables_03.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code block, we assign a value of **5** to the **a** variable
    and **3** to the **b** variable. Next, we added **a** and **b** and assigned the
    sum to the **c** variable. The last two lines show addition and multiplication
    using the **let** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output when we run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that you understand how to create and access variables, we’ll move on to
    a special type of variable, the **environment variable** .
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Environment variables** are essentially named objects that store data used
    by operating system processes. These variables can influence the behavior of software
    on the system by providing context about the user’s environment, such as the current
    user’s home directory or the path to executable files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, variables defined in a Bash script are local to that script. To
    make a variable available to other processes (such as subshells or child processes),
    you need to export it using the **export** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After exporting a variable, you can access its value in subshells or child processes.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of environment variables lies in their ability to streamline processes.
    Without them, every time you want to run a program or script, you might need to
    type out the full path to its location. With environment variables, Bash knows
    where to look for certain files or directories because these paths are stored
    in variables such as **PATH** .
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, environment variables ensure that software behaves correctly in different
    user environments. For instance, the **HOME** variable tells applications where
    a user’s home directory is located, allowing programs to save files in the right
    place without needing explicit instructions every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put this into perspective with some practical examples. Say you frequently
    access a directory that’s buried deep within your filesystem. Typing out the full
    path every time can be tedious. By creating a custom environment variable for
    this path, you can simplify the process significantly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever you need to access this directory, you can simply type **cd $MY_DEEP_DIRECTORY**
    , and Bash will take you there instantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common use case is modifying the **PATH** variable. The **PATH** variable
    tells Bash where to look for executable files. If you’ve installed a program that’s
    not in your system’s default executable paths, you can add its location to your
    **PATH** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This addition allows you to run your program from anywhere in the Terminal without
    the need to specify its full path.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the path to your program is preceded by **$PATH:** . What this does
    is append the new path to the existing path. Without this, you would be overwriting
    your **PATH** and you would have errors until you fix it or reboot your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you want an environment variable to persist across reboots, put it in your
    **.bashrc** file. To make the change to **.bashrc** take effect, run the **source
    ~/.** **bashrc** command.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a firm grip on variables, it’s time to cement this knowledge
    with some practice by reviewing everything you’ve learned about them.
  prefs: []
  type: TYPE_NORMAL
- en: A review of variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s examine a script that includes everything we’ve covered so far in this
    chapter. Take a look at the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_variables_04.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: First, it’s important to point out that I’m introducing something new here.
    Comments in scripts start with **#** and continue through the end of the line.
    Anything that follows **#** on the same line isn’t printed, provided the symbol
    isn’t escaped. You may have noticed that on one line, we used **$#** to print
    the number of parameters provided to the script. The comment behavior doesn’t
    apply in this case since it’s inside double quotes, preceded by a **$** symbol,
    and is not escaped.
  prefs: []
  type: TYPE_NORMAL
- en: You must document your scripts with comments. If you need to edit your script
    after some time, comments are helpful to remind you what you were trying to do
    and are also helpful to others if you share or publish your script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run the script. There are two ways we can run it. We can run it
    by entering **bash** followed by the script’s name, or we can make the script
    executable and prefix the path, as shown in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s list the file permissions, as you learned to do in [*Chapter 2*](B22229_02.xhtml#_idTextAnchor034)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding command, you can see that we used the **-l** option with the
    **ls** command to see the permissions. It’s readable and writable for the owner,
    and only readable by the group and others. Next, let’s use the **chmod** command
    to make it executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that after entering the **chmod** command with the **+x**
    argument, the file is now executable by the owner, group, and others. And of course,
    you could make it executable only by the owner by using the **chmod 744 ch03_variables_04.sh**
    command instead. Please refer to [*Chapter 2*](B22229_02.xhtml#_idTextAnchor034)
    or run the **man chmod** command if you need a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the file is executable, you can run it by prepending the path before
    the filename. You can specify the absolute or relative path, as discussed in [*Chapter
    2*](B22229_02.xhtml#_idTextAnchor034) . Here’s how you can run it using a relative
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The **shebang** ( **#!** ) is the first line in a script that specifies the
    interpreter (program) to be used for executing the script. Using the **#!/usr/bin/env
    bash** shebang tells the shell to run the script using the Bash interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Without the shebang, the following execution method may not work because the
    shell may not know what program to use to execute the code.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t include a shebang and make your script executable, you have to
    prefix your script name with **bash** to be able to run your script.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should have a good grasp of how variables work. In the next section,
    you’ll learn how to use conditionals to make decisions and branches in your scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Branching with conditional statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, a conditional statement in Bash is a way to tell your script, “Hey,
    if this specific thing is true, then go ahead and do this; otherwise, do that.”
    It’s the foundation of making decisions in your scripts. The most common conditional
    statements you’ll encounter in Bash are **if** , **else** , and **elif** .
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **if** statement is the simplest form of conditional statement. It checks
    for a condition, and if that condition is true, it executes a block of code. Here’s
    a straightforward example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_conditionals_01.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the script checks whether the current user is **steve** based
    on matching the first command-line argument. If it is, it greets Steve. Notice
    the syntax here: square brackets around the condition, double equals for comparison,
    and **then** indicate the start of what to do if the condition is true. The **fi**
    part at the end of the **if** block signifies to the shell that it’s closing out
    the **if** statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to point out that the semicolon ( **;** ) character has a special
    meaning as a command separator. Without it, this **if** statement block would
    break. Semicolons can also be used to put multiple commands on the same line.
    The preceding **if** statement can be rewritten using more semicolons, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Adding else
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'But what if you want to do something else when the condition isn’t met? That’s
    where **else** comes in handy. It allows you to specify an alternative action
    if the condition is false. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_conditionals_02.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if the user isn’t **steve** , the script responds with **Access denied.**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The power of elif
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you have more than two possibilities to consider. That’s where **elif**
    (short for **else if** ) becomes useful. It lets you check multiple conditions
    one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_conditionals_03.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding script, the **USER** variable comes from the environment variable
    for the logged-in user. Change your code in the **if** or **elif** statements
    so that it matches your username as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run it while logged in as **Steve** , you get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With **elif** , you can add as many additional conditions as you need, making
    your script capable of handling a wide range of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to use commonly used conditional statements, let’s dive
    into slightly more advanced examples that are commonly used in Bash scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond simple comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bash conditional statements aren’t limited to just checking whether one thing
    equals another. You can check for a variety of conditions, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether a file exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether a variable is greater than a certain value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether a file is writable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Bash, **primaries** refer to the expressions that are used in conditional
    tests within **[** (single-bracket), **[[** (double-bracket), and test commands.
    These primaries are used to evaluate different types of conditions, such as file
    attributes, string comparisons, and arithmetic operations. Primaries are essential
    building blocks in conditional statements, allowing you to test files, strings,
    numbers, and logical conditions. They are typically used within **if** , **while**
    , or **until** constructs to determine the flow of the script based on these evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: '**File test primaries** are used to check properties of files, such as whether
    they exist, are readable, are directories, and so on. The following list specifies
    file test primaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-e FILE** : True if the file exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-f FILE** : True if the file exists and is a regular file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-d FILE** : True if the file exists and is a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-r FILE** : True if the file exists and is readable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-w FILE** : True if the file exists and is writable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-x FILE** : True if the file exists and is executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-s FILE** : True if the file exists and is not empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-L FILE** : True if the file exists and is a symbolic link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, checking whether a file exists before trying to read from it
    can save your script from crashing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_conditionals_04.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: The **-f** flag tests whether the provided filename exists and is a regular
    file. To test for directories instead, we can use the **-d** flag. To test for
    both files and directories, we can use the **-e** flag. If we hadn’t checked that
    the file exists first, our script would have crashed. Using an **if** statement
    allows us to handle the error gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare integer variables in Bash, you should use the **-eq** , **-ne**
    , **-lt** , **-le** , **-gt** , and **-** **ge** primaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-eq** : True if the numbers are equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-ne** : True if the numbers are not equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-gt** : True if the first number is greater than the second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-ge** : True if the first number is greater than or equal to the second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-lt** : True if the first number is less than the second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-le** : True if the first number is less than or equal to the second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples demonstrating integer comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_conditionals_05.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, I declared two variables. Then, I used the **-eq** comparison
    operator inside an **if** - **else** block to print the result. You can also do
    this all on one line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, I declare two variables. Then, I put the comparison
    inside square brackets. The logical and ( **&&** ) operator means *if the previous
    command is successful (that is, returns true or 0), then execute the next command*
    . Otherwise, the logical or ( **||** ) operator means *if the previous command
    is not successful (that is, returns a non-zero exit code), then execute the next
    command* . Try running this code in your Terminal and check the output. You should
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code demonstrates how to use the less than **-lt** operator to
    compare integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_conditionals_06.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding code should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code demonstrates how to use the greater-than or equal-to operator,
    **-ge** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_conditionals_07.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'String comparisons in Bash are done using **=** and **!=** for equality and
    inequality, and **<** and **>** for lexicographical comparisons. The following
    are string primaries in Bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-z STRING** : True if the string is empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-n STRING** : True if the string is not empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**STRING1 == STRING2** : True if the strings are equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**STRING1 != STRING2** : True if the strings are not equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example demonstrating string comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_conditionals_08.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how to compare bytes in a string. To extract the first character
    of a string, use **byte="${string:1:1}"** . Then, compare **byte** as you would
    any other string.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve been comparing simple text and integer numbers. Comparing **UTF-8**
    encoded strings is the same as comparing English characters. Bash itself doesn’t
    have built-in support for direct comparison of **UTF-16** encoded strings in a
    way that it’s aware of the encoding specifics. However, you can use external tools
    such as **iconv** to convert and compare these strings. However, that subject
    is beyond the scope of this book. I simply want you to be aware of this limitation
    and where to look should you ever need to compare UTF-16 encoded strings.
  prefs: []
  type: TYPE_NORMAL
- en: Having covered comparing conditionals in depth, next, we’ll take a look at combining
    conditions using logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Combining conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if you need to check multiple conditions at once? Bash has you covered
    with logical operators such as **&&** (AND) and **||** (OR). These operators allow
    you to combine conditions, making your scripts even smarter. The following example
    shows how to use logical operators to check multiple conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_conditionals_09.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use an **if** condition, which evaluates to **TRUE** (returns **0**
    ) if both conditions are true. This part of the code uses a logical AND, **&&**
    . This means that only if the first condition and the second condition are both
    true, then the result is true.
  prefs: []
  type: TYPE_NORMAL
- en: In the **elif** condition, if either evaluation is true, the block returns **TRUE**
    . Think of **&&** as “If test1 AND test2 are true, return **TRUE** ” and **||**
    as “If test1 OR test2 is true, return **TRUE** , otherwise return **FALSE** (
    returns **1** ).”
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators simplify comparisons and save us a lot of typing! Without
    them, we would have to write much longer and more complex code. Logical comparisons
    in Bash are like decision-making tools that help your script understand and react
    to different situations. Just as you might decide what to wear based on the weather,
    your Bash script uses logical comparisons to decide what actions to take based
    on the data it processes.
  prefs: []
  type: TYPE_NORMAL
- en: Case statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at the **case** statement. It’s somewhat like the **switch** statement
    you might know from other programming languages. The **case** statement allows
    you to match a variable against a series of patterns and execute commands based
    on the match. It’s incredibly useful when you have multiple conditions to check
    against the same variable. Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_conditionals_10.sh** file in this
    chapter’s folder.
  prefs: []
  type: TYPE_NORMAL
- en: In this script, we use **read -p** to prompt the user for their favorite fruit,
    assign the input to the fruit variable, and use a **case** statement to respond
    with a custom message based on this variable. The ***)** pattern acts as a catch-all,
    similar to **else** in an **if** statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run it, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Having introduced the Bash **read** built-in, let’s review its parameters and
    their effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-p prompt** : Display a prompt before reading input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**t timeout** : Set a timeout for input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-s** : Silent mode; do not echo input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-r** : Raw input; do not allow backslashes to escape characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-a array** : Read input into an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-n nchars** : Read only **nchars** characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-d delimiter** : Read until the first occurrence of the delimiter instead
    of a newline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash conditional statements are a powerful tool in your scripting arsenal. They
    allow your scripts to make decisions and react to different situations intelligently.
    By understanding and using **if** , **else** , **elif** , and **case** , and combining
    conditions with logical operators such as **&&** and **||** , you can write more
    efficient and responsive Bash scripts.
  prefs: []
  type: TYPE_NORMAL
- en: With conditionals added to our arsenal, we’ll explore loops in the next section.
    Loops, when combined with conditionals and variables, make our scripting so much
    more powerful!
  prefs: []
  type: TYPE_NORMAL
- en: Repeating with loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash loops are iteration statements, a repetition of a process. Imagine that
    you have the output of many lines of data from log files or vulnerability scans.
    Reviewing each line manually would be akin to climbing a mountain with your hands
    tied; possible, but unnecessarily challenging. Bash loops, with their simple syntax
    and versatile application, turn this mountain into a molehill. In this section,
    we’ll dive into the essence of Bash loops, exploring their types, how they work,
    and why they’re an indispensable part of scripting in Linux environments.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **for** loop is your go-to when you know how many times you want to repeat
    an action. It’s like saying, “For each item in this list, do this task.” Bash
    **for** loops iterate over a list of items or a range of values, executing commands
    for each item. Here’s the basic **for** loop syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the **for** loop starts with a syntax that looks like “for this
    one item in a list of items.” In the case of a file, this could be **for $line
    in lines** . This statement initializes the loop. Next, you have the **do** keyword,
    followed by the loop statements, ending finally with **done** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have a folder that contains some text files and you want to
    print their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This loop goes through each file with a **.txt** extension in the current directory,
    assigning the filename to the **file** variable before printing it out using the
    **echo** statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re writing a simple script such as the one shown here, it’s usually
    easier to make this a *one-liner* by separating each section using a semicolon,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that **for** loops are sometimes used with a **sequence** . The Bash sequence
    expression generates a range of integers or characters. You define the start and
    end points of the range of integers or characters. A sequence consists of a range
    of values in curly brackets. This sequence takes the form of **{START..END[..INCREMENT]}**
    . If **INCREMENT** isn’t provided, it is **1** by default. A sequence is generally
    used in combination with **for** loops. Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve learned about **for** loops, let’s move on and explore **while**
    loops.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use a **while** loop when you want to repeat a task until a certain condition
    is no longer true. It’s like saying, “While this is true, keep going.” Here’s
    the basic syntax of a **while** loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example where we create a countdown from **5** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_loops_01.sh** file in this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we initialize the **count** variable to **5** . Then, we check
    the value of **count** ; if it’s greater than **0** , we print the value and then
    decrement the value by **1** . The loop continues to run, so long as **count**
    is greater than **0** . Each iteration decreases **count** by **1** until it is
    **0** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this script results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The most common way I use **while** loops is to read host names or IP addresses
    from a file and perform some operation on them. Sometimes, pentesting tools perform
    some operation on a single host and I want to run them across a list of hosts.
    Here’s a quick example where I use a one-line script with a **while** loop to
    read IP addresses from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Demonstrating a one-line while loop](image/B22229_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Demonstrating a one-line while loop
  prefs: []
  type: TYPE_NORMAL
- en: I’ll explain this in more detail shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is the **PetitPotam** tool, which is used for coercing password
    hashes from unpatched Windows hosts. You can find more information about this
    and download the tool from [https://github.com/topotam/PetitPotam](https://github.com/topotam/PetitPotam)
    . This tool accepts only one target host. Here, I’ve run it against a file containing
    a list of hosts using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Demonstrating a one-line while loop with PetitPotam](image/B22229_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Demonstrating a one-line while loop with PetitPotam
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the preceding screenshot can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**while read line** : The **while** keyword ensures that we continue performing
    the loop until the condition is no longer true. In this case, we continue looping
    until it has reached the end of the file. The **read** keyword reads one line
    up until the newline from standard input ( **stdin** ) and assigns the data read
    to a variable named **line** . The **read** command returns a non-zero ( **false**
    ) status when it reaches the end of the file, causing the loop to terminate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Bash scripting, semicolons ( **;** ) are used to separate multiple commands
    on the same line. This allows you to write concise, one-line scripts where multiple
    commands are executed sequentially.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**do python3 PetitPotam.py 10.2.10.99 $line** : In Bash scripting, the **do**
    keyword marks the beginning of the block of commands to be executed in each iteration
    of a loop. In this case, it’s running the **PetitPotam** command. The first IP
    address, **10.2.10.99** , is my Kali host IP address. The **$line** variable is
    the line of data that’s been read from the file. This becomes the target IP address
    for the **PetitPotam** command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**done** : In Bash scripting, the **done** keyword marks the end of the block
    of commands that are executed in each iteration of a loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**< ips.txt** : I’m redirecting the content of the **ips.txt** file to **stdin**
    to be read by the **read** command. This file contains a list of IP addresses,
    with one address on each line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before running the **PetitPotam** command, I ran **Responder** in another Terminal
    tab using the **sudo responder -I eth0** command. Responder is a rogue server
    that’s designed to elicit authentication from victims. Make sure you replace the
    IP address with your own if you’re performing this exercise. In the Responder
    output, I found that I captured a password hash from a vulnerable system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – A password hash has been captured from the victim](image/B22229_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – A password hash has been captured from the victim
  prefs: []
  type: TYPE_NORMAL
- en: Without the Bash **while** loop, I would have had to run the command manually
    for each host on the network. If I were testing a large network, this could be
    very tiring and I would have wasted a lot of time had I not harnessed the power
    of Bash!
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned the power of **while** loops, let’s look at its alter-ego,
    the **until** loop.
  prefs: []
  type: TYPE_NORMAL
- en: The until loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **until** loop is the opposite of the **while** loop. It keeps running until
    a condition becomes true. Think of it as, “Until this happens, do that.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax of the **until** loop is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you’re waiting for a file named **done.txt** to appear in the current
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_loops_02.sh** file in this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: This loop runs until done **.txt** exists, checking every second.
  prefs: []
  type: TYPE_NORMAL
- en: I rarely use the **until** loop; however, it is very particular in some circumstances
    when you want to do something until a condition is true.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll explore how to use **select** to build interactive menus!
  prefs: []
  type: TYPE_NORMAL
- en: Select – interactive menus made easy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another lesser-known loop command is **select** . It’s perfect for creating
    simple interactive menus in your scripts. With **select** , users can choose from
    options presented to them, making it ideal for navigation or settings menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_loops_03.sh** file in this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: This script presents a list of programming languages and executes commands based
    on the user’s selection. The **select** command automatically creates a numbered
    menu, and the user inputs the number corresponding to their choice. Notice that
    each option must end with two semicolon ( **;;** ) characters. The ***)** expression
    is a fall-through that catches anything that’s entered that doesn’t match the
    previous choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what it looks like when you run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when you run it, it continues to loop forever until you enter **5**
    for **Quit** , which uses the **break** statement in the code. The **break** statement
    breaks out of the loop. The **break** statement can be used in any loop to exit
    the loop, regardless of the conditional statement return value.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a firm grasp of using loops, let’s explore some advanced examples.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced usage – nested loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can nest loops within each other and use the **break** and **continue**
    keywords to control the flow more precisely. Here’s an example that prints a simple
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_loops_04.sh** file in this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script prints a 3x3 grid of numbers, showing how nested loops work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s explore how the **break** and **continue** keywords can be used
    to help us use advanced logic in nested loops.
  prefs: []
  type: TYPE_NORMAL
- en: Using break and continue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **break** command completely exits the loop, while the **continue** command
    skips the rest of the current loop and starts the next iteration. The following
    example combines **break** and **continue** to demonstrate these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_loops_05.sh** file in this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, a **for** loop iterates over a sequence of **1**
    to **20** . Next, I introduce the **modulus** operator, **%** , which results
    in the remainder of a division operation. If the remainder isn’t zero, it continues
    to the next iteration of the loop. If the value of **i** equals **10** , it breaks
    out of the loop. Otherwise, it prints the value of **i** . Here’s the result of
    running this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As you would expect, it prints all even numbers and exits when it reaches **10**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Bash loops are a fundamental part of scripting that can simplify and automate
    repetitive tasks. Whether you’re iterating over files, waiting for conditions,
    or creating interactive menus, understanding these loops can significantly enhance
    your scripting prowess. Start small, experiment with examples, and soon you’ll
    be looping like a pro!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, you’ll combine what you learned previously with a new
    concept: arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: Using arrays for data containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the powerful features of Bash scripting is the use of arrays. Arrays
    allow you to store multiple values in a single variable, making your scripts more
    efficient and your code cleaner. Let’s dive into the basics of Bash arrays and
    explore how they can be utilized through practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, an array is a collection of elements that can be accessed by an
    index. Think of it as a row of mailboxes, each with a unique number. You can store
    different pieces of mail (data) in each mailbox (element) and retrieve them using
    their mailbox number (index).
  prefs: []
  type: TYPE_NORMAL
- en: In Bash, arrays are incredibly flexible. They don’t require you to declare a
    type, and they can grow or shrink as needed. This means you can add or remove
    elements without having to worry about the size of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring an array in Bash is straightforward. You don’t need to explicitly
    declare a variable as an array; simply assigning values to it in an array context
    does the job. Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This line creates an array named **my_array** with three elements: **apple**
    , **banana** , and **cherry** .'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access an element in an array, you must use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, array indices in Bash start at **0** . So, to access the first element
    (apple) in **my_array** , you would use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding elements to an array or modifying existing ones is just as simple. To
    add an element to the end of the array, you can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The **+=** operator is common to many programming languages. This operation
    says **my_array** is equal to the current value of **my_array** plus **date**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, **my_array** contains four elements: **apple** , **banana** , **cherry**
    , and **date** . To modify an existing element, you must directly assign a new
    value to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This command changes the second element from **banana** to **blueberry** .
  prefs: []
  type: TYPE_NORMAL
- en: Looping through arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Looping through arrays is a common task in scripting. Here’s how you can iterate
    over each element in **my_array** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_arrays_01.sh** file in this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This loop prints each element in the array on a new line, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Bash also supports **associative arrays** (sometimes called **hash maps** or
    **dictionaries** ), where each element is identified by a key instead of a numeric
    index. To declare an associative array, use the **-A** flag with the **declare**
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_arrays_02.sh** file in this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing and modifying elements in an associative array works similarly to
    indexed arrays, but you use keys instead of numeric indices.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding script, the associative array is declared by using **declare
    -A** and the array’s name. Then, key/value pairs are added to the associative
    array. Next, the **for** loop uses the **key** variable to access each loop in
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the whole associative array using **"${!my_assoc_array[@]}"**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, during each iteration of the **for** loop, the current key/value pair
    is printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that associative arrays in Bash don’t maintain order; they’re
    unordered collections of key/value pairs. This is why the key/value pairs were
    printed in a different order than the order they were added to the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the value of a specific associative array key/value pair using
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The following script shows the same code as the previous script with this concept
    added on the last line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch03_arrays_03.sh** file in this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Bash arrays are a powerful feature that can make your scripts more efficient
    and easier to read. Whether you’re storing a simple list of items or dealing with
    more complex data structures, such as associative arrays, understanding how to
    work with arrays will significantly enhance your scripting capabilities. Remember,
    practice is key to mastering Bash arrays, so don’t hesitate to experiment with
    the examples provided and explore further applications on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This concludes a closely related set of topics. Bash variables, conditionals,
    loops, and arrays are tools in Bash scripting for storing data, making decisions,
    repeating tasks, and handling lists of values, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The loop is the star of the show. Just like the cast of any show, they require
    a supporting cast. In the case of loops, they require variables to assign labels
    to data, conditionals to test equality, and arrays to store data. Together, they
    work as a team and make your Bash scripts much more powerful and flexible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about Bash regular expressions, a valuable
    skill that you’ll need to master to search and match text effectively.
  prefs: []
  type: TYPE_NORMAL
