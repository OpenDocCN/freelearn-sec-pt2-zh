<html><head></head><body>
  <div id="_idContainer047">
   <h1 class="chapter-number" id="_idParaDest-71">
    <a id="_idTextAnchor073">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     4
    </span>
   </h1>
   <h1 id="_idParaDest-72">
    <a id="_idTextAnchor074">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Regular Expressions
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.3.1">
      Regular expressions
     </span>
    </strong>
    <span class="koboSpan" id="kobo.4.1">
     , or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.5.1">
      regex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.6.1">
     , might seem daunting at first, but they’re an incredibly powerful tool for anyone working
    </span>
    <a id="_idIndexMarker193">
    </a>
    <span class="koboSpan" id="kobo.7.1">
     with text, especially in Bash scripting.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     This chapter is designed to ease you into the world of regex, starting from the basics and gradually moving to more complex patterns and techniques.
    </span>
    <span class="koboSpan" id="kobo.7.3">
     Whether you’re looking to validate email addresses, search for specific patterns in log files, or automate text processing tasks, understanding regex is a game-changer.
    </span>
    <span class="koboSpan" id="kobo.7.4">
     We’ll explore how to craft regex patterns, understand their structure, and apply them in practical scenarios.
    </span>
    <span class="koboSpan" id="kobo.7.5">
     By the end of this chapter, you’ll not only be comfortable using regex but also appreciate how they can make your scripting tasks more efficient
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      and versatile.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     This chapter builds on the topics you learned about in the previous chapter.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     Regex is frequently used together with variables and conditional statements.
    </span>
    <span class="koboSpan" id="kobo.9.3">
     For example, you’re likely going to use a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.10.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.11.1">
     loop to read in a line of data from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.12.1">
      stdin
     </span>
    </strong>
    <span class="koboSpan" id="kobo.13.1">
     or from a file and assign the data you read to a variable.
    </span>
    <span class="koboSpan" id="kobo.13.2">
     Then, you’re going to perform a regex on the variable data, and finally make a decision using a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.14.1">
      conditional statement.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.15.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.16.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      The basics
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       of regex
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      Advanced regex patterns
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       and techniques
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.21.1">
      Demonstrating
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.22.1">
       practical applications
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.23.1">
      Regex tips and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.24.1">
       best practices
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-73">
    <a id="_idTextAnchor075">
    </a>
    <span class="koboSpan" id="kobo.25.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     It is helpful but not required to be able to install a Kali virtual machine, as stated in
    </span>
    <a href="B22229_01.xhtml#_idTextAnchor017">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.27.1">
        Chapter 1
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.28.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     The code for this chapter can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.30.1">
      at
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter04">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.31.1">
       https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter04
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.32.1">
      .
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-74">
    <a id="_idTextAnchor076">
    </a>
    <span class="koboSpan" id="kobo.33.1">
     The basics of regex
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.34.1">
     At their core, regex is a method for searching, matching, and manipulating text.
    </span>
    <span class="koboSpan" id="kobo.34.2">
     Think of them as a sophisticated
    </span>
    <a id="_idIndexMarker194">
    </a>
    <span class="koboSpan" id="kobo.35.1">
     search tool that goes beyond the capabilities of the standard search feature in your text editor or word processor.
    </span>
    <span class="koboSpan" id="kobo.35.2">
     Regex allows you to define patterns in text, making it possible to perform complex searches and edits with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.36.1">
      relative ease.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.37.1">
     Regex is incredibly versatile.
    </span>
    <span class="koboSpan" id="kobo.37.2">
     Here are just a few examples of what they can be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.38.1">
      used for:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.39.1">
       Data validation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.40.1">
      : Ensuring that
     </span>
     <a id="_idIndexMarker195">
     </a>
     <span class="koboSpan" id="kobo.41.1">
      user input matches a specific format, such as email addresses or
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.42.1">
       phone numbers
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.43.1">
       Data extraction
      </span>
     </strong>
     <span class="koboSpan" id="kobo.44.1">
      : Pulling specific pieces
     </span>
     <a id="_idIndexMarker196">
     </a>
     <span class="koboSpan" id="kobo.45.1">
      of information from a larger dataset, such as extracting all URLs from a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.46.1">
       web page
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.47.1">
       Search and replace
      </span>
     </strong>
     <span class="koboSpan" id="kobo.48.1">
      : Finding
     </span>
     <a id="_idIndexMarker197">
     </a>
     <span class="koboSpan" id="kobo.49.1">
      and replacing text in a document based on patterns rather than
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.50.1">
       exact matches
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.51.1">
     The regex alphabet consists of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.52.1">
      characters
     </span>
    </strong>
    <span class="koboSpan" id="kobo.53.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.54.1">
      metacharacters
     </span>
    </strong>
    <span class="koboSpan" id="kobo.55.1">
     .
    </span>
    <span class="koboSpan" id="kobo.55.2">
     Characters are just what you think: letters, numbers, and
    </span>
    <a id="_idIndexMarker198">
    </a>
    <span class="koboSpan" id="kobo.56.1">
     symbols that you’re trying to find in your text.
    </span>
    <span class="koboSpan" id="kobo.56.2">
     Metacharacters, on the
    </span>
    <a id="_idIndexMarker199">
    </a>
    <span class="koboSpan" id="kobo.57.1">
     other hand, are the special sauce of regex.
    </span>
    <span class="koboSpan" id="kobo.57.2">
     They’re symbols that have a special meaning, helping to define patterns.
    </span>
    <span class="koboSpan" id="kobo.57.3">
     Some common metacharacters include
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.58.1">
      .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.59.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.60.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.61.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.62.1">
      +
     </span>
    </strong>
    <span class="koboSpan" id="kobo.63.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.64.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.65.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.66.1">
      ^
     </span>
    </strong>
    <span class="koboSpan" id="kobo.67.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.68.1">
      $
     </span>
    </strong>
    <span class="koboSpan" id="kobo.69.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.70.1">
      []
     </span>
    </strong>
    <span class="koboSpan" id="kobo.71.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.72.1">
      {n}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.73.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.74.1">
      {n, m}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.75.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.76.1">
      {n,}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.77.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.78.1">
      (a|b)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.79.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.80.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.81.1">
       =~
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.82.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.83.1">
     In this section, I’ll be showing examples using the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.84.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     command.
    </span>
    <span class="koboSpan" id="kobo.85.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.86.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.87.1">
     command searches for patterns in files or
    </span>
    <a id="_idIndexMarker200">
    </a>
    <span class="koboSpan" id="kobo.88.1">
     piped input.
    </span>
    <span class="koboSpan" id="kobo.88.2">
     You can learn more about
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.89.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.90.1">
     by entering the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.91.1">
      man
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.92.1">
       grep
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.93.1">
      command.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.94.1">
     The period (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.95.1">
      .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.96.1">
     ) metacharacter matches any single character except newline, which is the end of a line and is represented by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.97.1">
      \n
     </span>
    </strong>
    <span class="koboSpan" id="kobo.98.1">
     .
    </span>
    <span class="koboSpan" id="kobo.98.2">
     One of the common ways I use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.99.1">
      .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.100.1">
     in regex is when parsing the output of a program and I want to eliminate blank lines.
    </span>
    <span class="koboSpan" id="kobo.100.2">
     Just as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.101.1">
      .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.102.1">
     matches any character, when used by itself in a regex, its use removes any blank lines since there’s nothing to match.
    </span>
    <span class="koboSpan" id="kobo.102.2">
     The following figure demonstrates that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.103.1">
      .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.104.1">
     matches any character.
    </span>
    <span class="koboSpan" id="kobo.104.2">
     The matched text is highlighted in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.105.1">
      red font:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer030">
     <span class="koboSpan" id="kobo.106.1">
      <img alt="Figure 4.1 – Matching non-blank lines using the period metacharacter" src="image/B22229_04_1.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.107.1">
     Figure 4.1 – Matching non-blank lines using the period metacharacter
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.108.1">
     As you can see, not only does the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.109.1">
      .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.110.1">
     metacharacter match any character (highlighted in red), but it also helps us to
    </span>
    <a id="_idIndexMarker201">
    </a>
    <span class="koboSpan" id="kobo.111.1">
     match only lines that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.112.1">
      aren’t blank.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     The asterisk (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.114.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.115.1">
     ) metacharacter matches zero or more occurrences of the preceding element.
    </span>
    <span class="koboSpan" id="kobo.115.2">
     Imagine that you have a text file named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.116.1">
      sample.txt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.117.1">
     with various lines of text, and you’re interested in finding lines that match the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.118.1">
      ho*p
     </span>
    </strong>
    <span class="koboSpan" id="kobo.119.1">
     pattern.
    </span>
    <span class="koboSpan" id="kobo.119.2">
     The pattern should match lines with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.120.1">
      hop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.121.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.122.1">
      hoop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.123.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.124.1">
      hooooop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.125.1">
     , and so on.
    </span>
    <span class="koboSpan" id="kobo.125.2">
     The content of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.126.1">
      sample.txt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.127.1">
     file is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.128.1">
      shown here:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer031">
     <span class="koboSpan" id="kobo.129.1">
      <img alt="Figure 4.2 – The content of the sample.txt file" src="image/B22229_04_2.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.130.1">
     Figure 4.2 – The content of the sample.txt file
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.131.1">
     Tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.132.1">
     You must use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.133.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.134.1">
     command with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.135.1">
      -E
     </span>
    </strong>
    <span class="koboSpan" id="kobo.136.1">
     option for extended regex, which allows you to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.137.1">
      *
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.138.1">
      metacharacter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.139.1">
     This command tells
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.140.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.141.1">
     to search within
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.142.1">
      sample.txt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.143.1">
     for lines that match the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.144.1">
      ho*p
     </span>
    </strong>
    <span class="koboSpan" id="kobo.145.1">
     pattern:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.146.1">
      grep -E 'ho*p' sample.txt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.147.1">
     .
    </span>
    <span class="koboSpan" id="kobo.147.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.148.1">
      -E
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     option is used to enable extended regex, which includes support for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     metacharacter, among other features.
    </span>
    <span class="koboSpan" id="kobo.151.2">
     Otherwise, outside of
    </span>
    <a id="_idIndexMarker202">
    </a>
    <span class="koboSpan" id="kobo.152.1">
     a regex,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.153.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.154.1">
     is called a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.155.1">
      glob
     </span>
    </strong>
    <span class="koboSpan" id="kobo.156.1">
     character, as discussed in
    </span>
    <a href="B22229_02.xhtml#_idTextAnchor034">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.157.1">
        Chapter 2
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.158.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.159.1">
     The plus (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.160.1">
      +
     </span>
    </strong>
    <span class="koboSpan" id="kobo.161.1">
     ) metacharacter matches one or more occurrences of the preceding element.
    </span>
    <span class="koboSpan" id="kobo.161.2">
     For example, if you’re analyzing log files for errors, a pattern such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.162.1">
      Error: +
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     could help you find lines where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.164.1">
      Error:
     </span>
    </strong>
    <span class="koboSpan" id="kobo.165.1">
     is followed by one or more spaces, indicating the start of an error message.
    </span>
    <span class="koboSpan" id="kobo.165.2">
     Without the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.166.1">
      +
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     metacharacter, you’d either miss cases with multiple spaces or waste time
    </span>
    <a id="_idIndexMarker203">
    </a>
    <span class="koboSpan" id="kobo.168.1">
     sifting through
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.169.1">
      irrelevant data.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.170.1">
     The question (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.171.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.172.1">
     ) metacharacter makes the preceding element optional.
    </span>
    <span class="koboSpan" id="kobo.172.2">
     At its core, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.173.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.174.1">
     metacharacter represents optionality.
    </span>
    <span class="koboSpan" id="kobo.174.2">
     It tells the regex engine to match the preceding element zero or one time.
    </span>
    <span class="koboSpan" id="kobo.174.3">
     Simply put, it means that the character or pattern right before
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.175.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.176.1">
     might be there, but it’s OK if
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.177.1">
      it’s not.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.178.1">
     This concept is easier to grasp with an example.
    </span>
    <span class="koboSpan" id="kobo.178.2">
     Imagine that you’re tasked with processing log files.
    </span>
    <span class="koboSpan" id="kobo.178.3">
     These logs follow a naming convention such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.179.1">
      app-log-2024.txt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.180.1">
     , but sometimes, they include an extra identifier, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.181.1">
      app-log-2024-debug.txt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.182.1">
     .
    </span>
    <span class="koboSpan" id="kobo.182.2">
     Using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.183.1">
      ?
     </span>
    </strong>
    <span class="koboSpan" id="kobo.184.1">
     metacharacter allows your script to be more flexible.
    </span>
    <span class="koboSpan" id="kobo.184.2">
     A pattern such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.185.1">
      app-log-2024(-debug)?.txt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.186.1">
     can match both filenames, ensuring your script works seamlessly across different
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.187.1">
      log types.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.188.1">
     The caret (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.189.1">
      ^
     </span>
    </strong>
    <span class="koboSpan" id="kobo.190.1">
     ) metacharacter matches the start of a line.
    </span>
    <span class="koboSpan" id="kobo.190.2">
     You might be wondering why you’d need to specify that something should be at the beginning of a line.
    </span>
    <span class="koboSpan" id="kobo.190.3">
     It’s all about precision.
    </span>
    <span class="koboSpan" id="kobo.190.4">
     In this example, if we didn’t use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.191.1">
      ^
     </span>
    </strong>
    <span class="koboSpan" id="kobo.192.1">
     metacharacter and searched for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.193.1">
      DONE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.194.1">
     alone, we’d get any line containing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.195.1">
      DONE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.196.1">
     anywhere in the text – not just at the beginning.
    </span>
    <span class="koboSpan" id="kobo.196.2">
     This could include lines where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.197.1">
      DONE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.198.1">
     appears in a note or reminder, not just as a task
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.199.1">
      status marker.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.200.1">
     The dollar (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.201.1">
      $
     </span>
    </strong>
    <span class="koboSpan" id="kobo.202.1">
     ) metacharacter matches the end of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.203.1">
      a line.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.204.1">
     The following is an example of matching
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.205.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.206.1">
       $
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.207.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer032">
     <span class="koboSpan" id="kobo.208.1">
      <img alt="Figure 4.3 – Matching the end of a string using the $ metacharacter" src="image/B22229_04_3.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.209.1">
     Figure 4.3 – Matching the end of a string using the $ metacharacter
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.210.1">
     Bracket expressions (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.211.1">
      [ ]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     ) match any single character within the brackets.
    </span>
    <span class="koboSpan" id="kobo.212.2">
     You can perform a logical
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.213.1">
      NOT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.214.1">
     expression by
    </span>
    <a id="_idIndexMarker204">
    </a>
    <span class="koboSpan" id="kobo.215.1">
     making the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.216.1">
      ^
     </span>
    </strong>
    <span class="koboSpan" id="kobo.217.1">
     symbol the first character in the list.
    </span>
    <span class="koboSpan" id="kobo.217.2">
     That would result in matching characters that are not on the list.
    </span>
    <span class="koboSpan" id="kobo.217.3">
     For example, if you wanted to match vowel characters, an
    </span>
    <a id="_idIndexMarker205">
    </a>
    <span class="koboSpan" id="kobo.218.1">
     appropriate bracket expression would be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.219.1">
      [aeiou]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.220.1">
     , whereas if you wanted to match consonants, you could
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.221.1">
      use
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.222.1">
       [^aeiou]
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.223.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.224.1">
     Range expressions are frequently used inside bracket expressions to save you the time and effort of typing all subsequent characters or numbers in a range.
    </span>
    <span class="koboSpan" id="kobo.224.2">
     For example, instead of typing the letters
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.225.1">
      a
     </span>
    </em>
    <span class="koboSpan" id="kobo.226.1">
     through
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.227.1">
      z
     </span>
    </em>
    <span class="koboSpan" id="kobo.228.1">
     inside brackets, you can use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.229.1">
      [a-z]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.230.1">
     as a handy shortcut.
    </span>
    <span class="koboSpan" id="kobo.230.2">
     Similarly, for numbers, you can use a range such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.231.1">
      [1-10]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.232.1">
     .
    </span>
    <span class="koboSpan" id="kobo.232.2">
     The following figure demonstrates how bracket
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.233.1">
      expressions work:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer033">
     <span class="koboSpan" id="kobo.234.1">
      <img alt="Figure 4.4 – Examples of using bracket expressions" src="image/B22229_04_4.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.235.1">
     Figure 4.4 – Examples of using bracket expressions
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.236.1">
     Bracket expressions are a valuable, time-saving
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.237.1">
      regex feature!
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.238.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.239.1">
      {n}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.240.1">
     metacharacter
    </span>
    <a id="_idIndexMarker206">
    </a>
    <span class="koboSpan" id="kobo.241.1">
     specifies that the preceding element is matched exactly
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.242.1">
      n
     </span>
    </em>
    <span class="koboSpan" id="kobo.243.1">
     times.
    </span>
    <span class="koboSpan" id="kobo.243.2">
     It can also be written as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.244.1">
      {n, m}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.245.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.246.1">
      {n,}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.247.1">
     , meaning the preceding element is matched between
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.248.1">
      n
     </span>
    </strong>
    <span class="koboSpan" id="kobo.249.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.250.1">
      n
     </span>
    </strong>
    <span class="koboSpan" id="kobo.251.1">
     times, or is matched exactly
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.252.1">
      n
     </span>
    </strong>
    <span class="koboSpan" id="kobo.253.1">
     or more times, respectively.
    </span>
    <span class="koboSpan" id="kobo.253.2">
     Let’s look at how this can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.254.1">
      be used:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer034">
     <span class="koboSpan" id="kobo.255.1">
      <img alt="Figure 4.5 – An example showing how to match n or more times" src="image/B22229_04_5.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.256.1">
     Figure 4.5 – An example showing how to match n or more times
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.257.1">
     The preceding figure shows that I specified that it must match
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.258.1">
      3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.259.1">
     or more times for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.260.1">
      o
     </span>
    </strong>
    <span class="koboSpan" id="kobo.261.1">
     character.
    </span>
    <span class="koboSpan" id="kobo.261.2">
     The word
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.262.1">
      hoooop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.263.1">
     was the only match.
    </span>
    <span class="koboSpan" id="kobo.263.2">
     Note that I had to include the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.264.1">
      -E
     </span>
    </strong>
    <span class="koboSpan" id="kobo.265.1">
     argument in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.266.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.267.1">
     to enable
    </span>
    <a id="_idIndexMarker207">
    </a>
    <span class="koboSpan" id="kobo.268.1">
     extended regex capability, and had to escape the brackets with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.269.1">
      a backslash.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.270.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.271.1">
      (a|b)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.272.1">
     metacharacter matches either
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.273.1">
      a
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.274.1">
      or
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.275.1">
       b
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.276.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.277.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.278.1">
      =~
     </span>
    </strong>
    <span class="koboSpan" id="kobo.279.1">
     match operator is typically used inside scripts.
    </span>
    <span class="koboSpan" id="kobo.279.2">
     Let’s discuss the basic example shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.280.1">
      following figure:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer035">
     <span class="koboSpan" id="kobo.281.1">
      <img alt="Figure 4.6 – An example demonstrating the match operator" src="image/B22229_04_6.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.282.1">
     Figure 4.6 – An example demonstrating the match operator
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     If the string on the left-hand side of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.284.1">
      =~
     </span>
    </strong>
    <span class="koboSpan" id="kobo.285.1">
     operator matches the regex on the right, the expression evaluates to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.286.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.287.1">
     , and the exit status of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.288.1">
      [[ ]]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.289.1">
     bracket expression is 0 (zero).
    </span>
    <span class="koboSpan" id="kobo.289.2">
     In Bash shell scripting, an exit status of 0 signifies success or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.290.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.291.1">
     .
    </span>
    <span class="koboSpan" id="kobo.291.2">
     An exit value of anything other than 0 signifies failure
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      or
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.293.1">
       false
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.294.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.295.1">
     In Bash scripting,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.296.1">
      &amp;&amp;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.297.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.298.1">
      ||
     </span>
    </strong>
    <span class="koboSpan" id="kobo.299.1">
     are
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.300.1">
      logical operators
     </span>
    </strong>
    <span class="koboSpan" id="kobo.301.1">
     that are used within conditional expressions to combine multiple
    </span>
    <a id="_idIndexMarker208">
    </a>
    <span class="koboSpan" id="kobo.302.1">
     commands or conditions.
    </span>
    <span class="koboSpan" id="kobo.302.2">
     Their usage is tied to the exit status of commands.
    </span>
    <span class="koboSpan" id="kobo.302.3">
     Applied to the previous figure, if the match pattern finds a match on the input expression, it results in an exit status of 0, or true.
    </span>
    <span class="koboSpan" id="kobo.302.4">
     If the string doesn’t match the regex, the expression evaluates to false, and the exit status of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.303.1">
      [[ ]]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.304.1">
     expression is 1 (an exit status of 1 signifies failure or false).
    </span>
    <span class="koboSpan" id="kobo.304.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.305.1">
      &amp;&amp;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.306.1">
     operator passes the exit status to the following
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.307.1">
      ||
     </span>
    </strong>
    <span class="koboSpan" id="kobo.308.1">
     expression, which can be thought of as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.309.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.310.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.311.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.312.1">
     .
    </span>
    <span class="koboSpan" id="kobo.312.2">
     If the expression was true, the statement on the left,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.313.1">
      echo Match found!
     </span>
    </strong>
    <span class="koboSpan" id="kobo.314.1">
     , is executed.
    </span>
    <span class="koboSpan" id="kobo.314.2">
     If false, the
    </span>
    <a id="_idIndexMarker209">
    </a>
    <span class="koboSpan" id="kobo.315.1">
     statement on the right,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.316.1">
      echo "No match"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.317.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.318.1">
      is executed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.319.1">
     Now that you’re familiar with metacharacters, let’s explore
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.320.1">
      character classes
     </span>
    </strong>
    <span class="koboSpan" id="kobo.321.1">
     , which provide handy shortcuts when using the bracket expressions we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.322.1">
      just covered.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-75">
    <a id="_idTextAnchor077">
    </a>
    <span class="koboSpan" id="kobo.323.1">
     Using character classes
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.324.1">
     When used inside bracket
    </span>
    <a id="_idIndexMarker210">
    </a>
    <span class="koboSpan" id="kobo.325.1">
     expressions, character classes
    </span>
    <a id="_idIndexMarker211">
    </a>
    <span class="koboSpan" id="kobo.326.1">
     are a handy shortcut that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.327.1">
      simplifies regex:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.328.1">
       [:alpha:]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.329.1">
      :
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.330.1">
       Alphabet characters
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.331.1">
       [:alnum:]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.332.1">
      :
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.333.1">
       Alphanumeric characters
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.334.1">
       [:digit:]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.335.1">
      : The numbers 0
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.336.1">
       through 9
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.337.1">
       [:blank:]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.338.1">
      : Spaces
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.339.1">
       and tabs
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.340.1">
       [:cntrl:]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.341.1">
      :
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.342.1">
       Control characters
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.343.1">
       [:lower:]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.344.1">
      :
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.345.1">
       Lowercase letters
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.346.1">
       [:upper:]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.347.1">
      :
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.348.1">
       Uppercase letters
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.349.1">
       [:punct:]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.350.1">
      :
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.351.1">
       Punctuation characters
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.352.1">
       [:space:]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.353.1">
      : Space characters, including space, tab, newline, vertical tab, form feed, and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.354.1">
       carriage return
      </span>
     </span>
    </li>
   </ul>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.355.1">
     Tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.356.1">
     Character classes must be enclosed inside bracket expressions – for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.357.1">
      example,
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.358.1">
       [[:alpha:]]
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.359.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.360.1">
     Character classes
    </span>
    <a id="_idIndexMarker212">
    </a>
    <span class="koboSpan" id="kobo.361.1">
     are a time-saving shorthand that greatly simplifies the
    </span>
    <a id="_idIndexMarker213">
    </a>
    <span class="koboSpan" id="kobo.362.1">
     process of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.363.1">
      creating regex.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-76">
    <a id="_idTextAnchor078">
    </a>
    <span class="koboSpan" id="kobo.364.1">
     Flags – modifying your search
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.365.1">
     Regex allows you to modify your search with flags.
    </span>
    <span class="koboSpan" id="kobo.365.2">
     These are usually single letters that change how the regex
    </span>
    <a id="_idIndexMarker214">
    </a>
    <span class="koboSpan" id="kobo.366.1">
     engine interprets your pattern.
    </span>
    <span class="koboSpan" id="kobo.366.2">
     Here are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.367.1">
      some
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker215">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.368.1">
      examples:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.369.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.370.1">
      : Makes the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.371.1">
       search case-insensitive
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.372.1">
       g
      </span>
     </strong>
     <span class="koboSpan" id="kobo.373.1">
      : Performs a global search (finds all matches rather than stopping after the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.374.1">
       first match)
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.375.1">
       m
      </span>
     </strong>
     <span class="koboSpan" id="kobo.376.1">
      : Multiline mode (changes the behavior of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.377.1">
       ^
      </span>
     </strong>
     <span class="koboSpan" id="kobo.378.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.379.1">
       $
      </span>
     </strong>
     <span class="koboSpan" id="kobo.380.1">
      to match the start and end of lines rather than the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.381.1">
       whole string)
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.382.1">
     This is not an exhaustive list.
    </span>
    <span class="koboSpan" id="kobo.382.2">
     See
    </span>
    <a href="https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html">
     <span class="koboSpan" id="kobo.383.1">
      https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html
     </span>
    </a>
    <span class="koboSpan" id="kobo.384.1">
     for more information.
    </span>
    <span class="koboSpan" id="kobo.384.2">
     These flags can be used alone or in combination, depending on the requirements of the regex operation.
    </span>
    <span class="koboSpan" id="kobo.384.3">
     The way to apply these flags varies slightly between tools, but they are usually appended to the regex pattern.
    </span>
    <span class="koboSpan" id="kobo.384.4">
     Since their use is tool-dependent, I’ll show you examples of how they can be used when I present practical examples later in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.385.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.386.1">
     Now that you understand the basics of regex, let’s review some examples showing how
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.387.1">
      they work.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-77">
    <a id="_idTextAnchor079">
    </a>
    <span class="koboSpan" id="kobo.388.1">
     Applying basic regex examples
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.389.1">
     This example
    </span>
    <a id="_idIndexMarker216">
    </a>
    <span class="koboSpan" id="kobo.390.1">
     simply uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.391.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.392.1">
     to match on the letter
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.393.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.394.1">
     .
    </span>
    <span class="koboSpan" id="kobo.394.2">
     By default,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.395.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.396.1">
     performs a global search.
    </span>
    <span class="koboSpan" id="kobo.396.2">
     Therefore, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.397.1">
      g
     </span>
    </strong>
    <span class="koboSpan" id="kobo.398.1">
     flag
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.399.1">
      isn’t necessary:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer036">
     <span class="koboSpan" id="kobo.400.1">
      <img alt="Figure 4.7 – A basic grep on the t character" src="image/B22229_04_7.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.401.1">
     Figure 4.7 – A basic grep on the t character
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.402.1">
     This example matches
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.403.1">
      all vowels:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer037">
     <span class="koboSpan" id="kobo.404.1">
      <img alt="Figure 4.8 – A pattern that matches all vowels" src="image/B22229_04_8.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.405.1">
     Figure 4.8 – A pattern that matches all vowels
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.406.1">
     This example matches all consonants.
    </span>
    <span class="koboSpan" id="kobo.406.2">
     Remember
    </span>
    <a id="_idIndexMarker217">
    </a>
    <span class="koboSpan" id="kobo.407.1">
     that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.408.1">
      ^
     </span>
    </strong>
    <span class="koboSpan" id="kobo.409.1">
     symbol takes on a different meaning inside of brackets.
    </span>
    <span class="koboSpan" id="kobo.409.2">
     This essentially means that it matches any character not in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.410.1">
      the list:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer038">
     <span class="koboSpan" id="kobo.411.1">
      <img alt="Figure 4.9 – A pattern that matches all consonants" src="image/B22229_04_9.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.412.1">
     Figure 4.9 – A pattern that matches all consonants
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.413.1">
     Now, I’ll show you a slightly more advanced example.
    </span>
    <span class="koboSpan" id="kobo.413.2">
     Can you spot the difference between the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.414.1">
      two examples?
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer039">
     <span class="koboSpan" id="kobo.415.1">
      <img alt="Figure 4.10 – Two patterns used to demonstrate a subtle difference" src="image/B22229_04_10.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.416.1">
     Figure 4.10 – Two patterns used to demonstrate a subtle difference
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.417.1">
     The first pattern matches
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.418.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.419.1">
     followed by zero or more characters that are not
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.420.1">
      w
     </span>
    </strong>
    <span class="koboSpan" id="kobo.421.1">
     .
    </span>
    <span class="koboSpan" id="kobo.421.2">
     It’s important to note that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.422.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.423.1">
     applies to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.424.1">
      [^w]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.425.1">
     part of the pattern, allowing for any sequence of characters that does not start with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.426.1">
      w
     </span>
    </strong>
    <span class="koboSpan" id="kobo.427.1">
     immediately following
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.428.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.429.1">
     .
    </span>
    <span class="koboSpan" id="kobo.429.2">
     Therefore, it matches everything, including the spaces, starting with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.430.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.431.1">
     in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.432.1">
      told
     </span>
    </strong>
    <span class="koboSpan" id="kobo.433.1">
     , and continues through the end of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.434.1">
      the input.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.435.1">
     The second pattern specifically looks for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.436.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.437.1">
     followed by a single character that is not
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.438.1">
      w
     </span>
    </strong>
    <span class="koboSpan" id="kobo.439.1">
     , and then zero or more alphabetic characters.
    </span>
    <span class="koboSpan" id="kobo.439.2">
     The inclusion of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.440.1">
      [[:alpha:]]*
     </span>
    </strong>
    <span class="koboSpan" id="kobo.441.1">
     after
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.442.1">
      [^w]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.443.1">
     means that after finding
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.444.1">
      t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.445.1">
     followed by any non-
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.446.1">
      w
     </span>
    </strong>
    <span class="koboSpan" id="kobo.447.1">
     character, it matches only if the following characters
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.448.1">
      are alphabetic.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.449.1">
     Tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.450.1">
     The examples in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.451.1">
       Figure 4
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.452.1">
      .10
     </span>
    </em>
    <span class="koboSpan" id="kobo.453.1">
     show a backslash character escaping the asterisk.
    </span>
    <span class="koboSpan" id="kobo.453.2">
     A small number of characters have special meaning.
    </span>
    <span class="koboSpan" id="kobo.453.3">
     The following characters must be escaped with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.454.1">
      backslash:
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.455.1">
       [\^$.|?*+()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.456.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.457.1">
     Now that you understand
    </span>
    <a id="_idIndexMarker218">
    </a>
    <span class="koboSpan" id="kobo.458.1">
     the basics, let’s get a taste of some advanced
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.459.1">
      regex concepts.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-78">
    <a id="_idTextAnchor080">
    </a>
    <span class="koboSpan" id="kobo.460.1">
     Advanced regex patterns and techniques
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.461.1">
     In regex, using
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.462.1">
      capture groups
     </span>
    </strong>
    <span class="koboSpan" id="kobo.463.1">
     is like putting a part of your pattern into a box.
    </span>
    <span class="koboSpan" id="kobo.463.2">
     Everything inside this box is treated as a
    </span>
    <a id="_idIndexMarker219">
    </a>
    <span class="koboSpan" id="kobo.464.1">
     single unit.
    </span>
    <span class="koboSpan" id="kobo.464.2">
     You can apply quantifiers to it, look for repetitions, or even extract information from it.
    </span>
    <span class="koboSpan" id="kobo.464.3">
     In Bash, you use parentheses,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.465.1">
      ()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.466.1">
     , to create
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.467.1">
      these groups.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.468.1">
      Grouping
     </span>
    </strong>
    <span class="koboSpan" id="kobo.469.1">
     isn’t just
    </span>
    <a id="_idIndexMarker220">
    </a>
    <span class="koboSpan" id="kobo.470.1">
     about treating parts of your pattern as a single unit; it’s also about capturing information.
    </span>
    <span class="koboSpan" id="kobo.470.2">
     When you group part of a regex pattern, Bash remembers what text matched that
    </span>
    <a id="_idIndexMarker221">
    </a>
    <span class="koboSpan" id="kobo.471.1">
     part of the pattern.
    </span>
    <span class="koboSpan" id="kobo.471.2">
     This is incredibly useful for extracting information
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.472.1">
      from strings.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.473.1">
     Let’s say you’re working with log files and you want to extract timestamps.
    </span>
    <span class="koboSpan" id="kobo.473.2">
     Your log lines might look something like this:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.474.1">
      2023-04-01 12:00:00 Error: Something went wrong.
     </span>
    </strong>
    <span class="koboSpan" id="kobo.475.1">
     A regex pattern to match the timestamp could be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.476.1">
      (\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})
     </span>
    </strong>
    <span class="koboSpan" id="kobo.477.1">
     .
    </span>
    <span class="koboSpan" id="kobo.477.2">
     Here,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.478.1">
      \d
     </span>
    </strong>
    <span class="koboSpan" id="kobo.479.1">
     matches any digit, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.480.1">
      {n}
     </span>
    </strong>
    <span class="koboSpan" id="kobo.481.1">
     specifies how many times that element should repeat.
    </span>
    <span class="koboSpan" id="kobo.481.2">
     The entire timestamp pattern is grouped, so you can extract it from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.482.1">
      string easily.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.483.1">
     Let’s look at some practical examples to help you solidify your understanding of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.484.1">
      capture groups.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-79">
    <a id="_idTextAnchor081">
    </a>
    <span class="koboSpan" id="kobo.485.1">
     Practical example – extracting data using regex
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.486.1">
     Imagine you’re tasked with extracting
    </span>
    <a id="_idIndexMarker222">
    </a>
    <span class="koboSpan" id="kobo.487.1">
     usernames and their corresponding email addresses from a list.
    </span>
    <span class="koboSpan" id="kobo.487.2">
     The list looks something
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.488.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.489.1">
john_doe: john.doe@example.com
jane_smith: jane.smith@example.com</span></pre>
   <p>
    <span class="koboSpan" id="kobo.490.1">
     You could use the following regex pattern to match and extract the usernames and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.491.1">
      email addresses:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.492.1">
([a-zA-Z0-9_]+): ([a-zA-Z0-9_.]+@[a-zA-Z0-9_.]+)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.493.1">
     Here,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.494.1">
      [a-zA-Z0-9_]+
     </span>
    </strong>
    <span class="koboSpan" id="kobo.495.1">
     matches one or more alphanumeric characters or underscores (the username), and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.496.1">
      [a-zA-Z0-9_.]+@[a-zA-Z0-9_.]+
     </span>
    </strong>
    <span class="koboSpan" id="kobo.497.1">
     matches the email addresses.
    </span>
    <span class="koboSpan" id="kobo.497.2">
     By grouping them, you can extract both the username and the email
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.498.1">
      address separately.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.499.1">
     For example, let’s say you
    </span>
    <a id="_idIndexMarker223">
    </a>
    <span class="koboSpan" id="kobo.500.1">
     have
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.501.1">
      I love apples and I love oranges
     </span>
    </strong>
    <span class="koboSpan" id="kobo.502.1">
     as a string and you want to find every instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.503.1">
      I love
     </span>
    </strong>
    <span class="koboSpan" id="kobo.504.1">
     .
    </span>
    <span class="koboSpan" id="kobo.504.2">
     In regex, you could write this pattern as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.505.1">
      (I love)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.506.1">
     .
    </span>
    <span class="koboSpan" id="kobo.506.2">
     This tells Bash to treat
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.507.1">
      I love
     </span>
    </strong>
    <span class="koboSpan" id="kobo.508.1">
     as a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.509.1">
      single unit.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.510.1">
     Regex grouping in Bash might seem complex at first glance, but once you understand the basics, it opens up a world of possibilities for string manipulation and data extraction.
    </span>
    <span class="koboSpan" id="kobo.510.2">
     By breaking down patterns into manageable groups, you can simplify your scripts and make them more efficient.
    </span>
    <span class="koboSpan" id="kobo.510.3">
     Remember, practice makes perfect.
    </span>
    <span class="koboSpan" id="kobo.510.4">
     Start experimenting with regex grouping in your Bash scripts, and you’ll soon wonder how you ever managed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.511.1">
      without it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.512.1">
     Next, we’ll expand on regex grouping by showing you how to use alternations to make your capture groups more powerful
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.513.1">
      and flexible.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-80">
    <a id="_idTextAnchor082">
    </a>
    <span class="koboSpan" id="kobo.514.1">
     Utilizing alternations
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.515.1">
     Regex
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.516.1">
      alternation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.517.1">
     is represented by the pipe symbol (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.518.1">
      |
     </span>
    </strong>
    <span class="koboSpan" id="kobo.519.1">
     ), which functions similarly to a logical OR.
    </span>
    <span class="koboSpan" id="kobo.519.2">
     It allows you to specify
    </span>
    <a id="_idIndexMarker224">
    </a>
    <span class="koboSpan" id="kobo.520.1">
     multiple patterns within the same regex, offering a way to match one thing or another.
    </span>
    <span class="koboSpan" id="kobo.520.2">
     Think of it as telling your script, “Hey, if you see this or that, consider it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.521.1">
      a match.”
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.522.1">
     Let’s say you’re writing a script that needs to process files with specific extensions.
    </span>
    <span class="koboSpan" id="kobo.522.2">
     You’re interested in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.523.1">
      .txt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.524.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.525.1">
      .log
     </span>
    </strong>
    <span class="koboSpan" id="kobo.526.1">
     files but want to handle them using a single regex.
    </span>
    <span class="koboSpan" id="kobo.526.2">
     Here’s how you could
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.527.1">
      do it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.528.1">
#!/usr/bin/env bash
filename="example.txt"
if [[ $filename =~ \.(txt|log)$ ]]; then
  echo "File is either a .txt or .log file."
</span><span class="koboSpan" id="kobo.528.2">else
  echo "File is not a .txt or .log file."
</span><span class="koboSpan" id="kobo.528.3">fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.529.1">
     This example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.530.1">
      ch04_regex_01.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.531.1">
     file in this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.532.1">
      chapter’s folder.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.533.1">
     Running this example
    </span>
    <a id="_idIndexMarker225">
    </a>
    <span class="koboSpan" id="kobo.534.1">
     provides the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.535.1">
      following output:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.536.1">
$ bash ch04_regex_01.sh
File is either a .txt or .log file.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.537.1">
     In this example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.538.1">
      (txt|log\)$
     </span>
    </strong>
    <span class="koboSpan" id="kobo.539.1">
     is the regex pattern.
    </span>
    <span class="koboSpan" id="kobo.539.2">
     The pipe symbol,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.540.1">
      |
     </span>
    </strong>
    <span class="koboSpan" id="kobo.541.1">
     , separates the two alternatives,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.542.1">
      txt
     </span>
    </strong>
    <span class="koboSpan" id="kobo.543.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.544.1">
      log
     </span>
    </strong>
    <span class="koboSpan" id="kobo.545.1">
     , while the backslashes,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.546.1">
      \
     </span>
    </strong>
    <span class="koboSpan" id="kobo.547.1">
     , are used to escape characters that have special meanings in regex.
    </span>
    <span class="koboSpan" id="kobo.547.2">
     The dollar sign,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.548.1">
      $
     </span>
    </strong>
    <span class="koboSpan" id="kobo.549.1">
     , ensures that the pattern matches the end of the string, preventing false positives on files such
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.550.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.551.1">
       example.txt.bak
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.552.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.553.1">
     You might be wondering why bother with alternation when you could just write separate conditions for each case.
    </span>
    <span class="koboSpan" id="kobo.553.2">
     The answer lies in simplicity and efficiency.
    </span>
    <span class="koboSpan" id="kobo.553.3">
     Using alternation, you can consolidate multiple conditions into a single line of code, making your scripts cleaner and easier
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.554.1">
      to maintain.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.555.1">
     In scenarios where you’re matching against a long list of possibilities, alternation can significantly reduce the complexity of your code.
    </span>
    <span class="koboSpan" id="kobo.555.2">
     Instead of having an unwieldy series of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.556.1">
      if
     </span>
    </strong>
    <span class="koboSpan" id="kobo.557.1">
     statements or a cumbersome
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.558.1">
      case
     </span>
    </strong>
    <span class="koboSpan" id="kobo.559.1">
     statement, you can list all your options in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.560.1">
      one place.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.561.1">
     While alternation is powerful, it’s essential to use it wisely to avoid pitfalls.
    </span>
    <span class="koboSpan" id="kobo.561.2">
     Here are a couple of tips to keep
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.562.1">
      in mind:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.563.1">
       Be specific
      </span>
     </strong>
     <span class="koboSpan" id="kobo.564.1">
      : Regex patterns can sometimes match more than you intend.
     </span>
     <span class="koboSpan" id="kobo.564.2">
      To prevent unexpected
     </span>
     <a id="_idIndexMarker226">
     </a>
     <span class="koboSpan" id="kobo.565.1">
      behavior, make your patterns as specific
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.566.1">
       as possible.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.567.1">
       Testing
      </span>
     </strong>
     <span class="koboSpan" id="kobo.568.1">
      : Always test your regex patterns with various inputs to ensure they behave as expected.
     </span>
     <span class="koboSpan" id="kobo.568.2">
      Tools such as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.569.1">
       grep
      </span>
     </strong>
     <span class="koboSpan" id="kobo.570.1">
      and online regex testers (
     </span>
     <a href="https://regex101.com">
      <span class="koboSpan" id="kobo.571.1">
       https://regex101.com
      </span>
     </a>
     <span class="koboSpan" id="kobo.572.1">
      ) can be
     </span>
     <a id="_idIndexMarker227">
     </a>
     <span class="koboSpan" id="kobo.573.1">
      invaluable
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.574.1">
       for this.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.575.1">
     Regex alternations in Bash scripting are like having a secret weapon in your arsenal.
    </span>
    <span class="koboSpan" id="kobo.575.2">
     They allow you to write more concise, readable, and maintainable code by simplifying complex pattern-matching logic.
    </span>
    <span class="koboSpan" id="kobo.575.3">
     Whether you’re a seasoned scripter or just starting, mastering alternations will
    </span>
    <a id="_idIndexMarker228">
    </a>
    <span class="koboSpan" id="kobo.576.1">
     undoubtedly make your scripting journey smoother and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.577.1">
      more enjoyable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.578.1">
     Remember, the key to effective scripting is not just knowing what tools are available but understanding how to use them wisely.
    </span>
    <span class="koboSpan" id="kobo.578.2">
     With regex alternations, you’re well-equipped to tackle a wide range of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.579.1">
      string-matching challenges.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.580.1">
     Now that you have a good grasp of how regex works, let’s explore some practical
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.581.1">
      regex applications.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-81">
    <a id="_idTextAnchor083">
    </a>
    <span class="koboSpan" id="kobo.582.1">
     Demonstrating practical applications
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.583.1">
     Here, I’m using various variables and arrays that were introduced in previous chapters.
    </span>
    <span class="koboSpan" id="kobo.583.2">
     Let’s put this into
    </span>
    <a id="_idIndexMarker229">
    </a>
    <span class="koboSpan" id="kobo.584.1">
     practice with the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.585.1">
      Bash script:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer040">
     <span class="koboSpan" id="kobo.586.1">
      <img alt="Figure 4.11 – Introducing BASH_REMATCH in a practical application" src="image/B22229_04_11.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.587.1">
     Figure 4.11 – Introducing BASH_REMATCH in a practical application
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.588.1">
     This example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.589.1">
      ch04_regex_02.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.590.1">
     file in this chapter’s folder.
    </span>
    <span class="koboSpan" id="kobo.590.2">
     In this script, I declared the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.591.1">
      user_list
     </span>
    </strong>
    <span class="koboSpan" id="kobo.592.1">
     variable on
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.593.1">
      line 3
     </span>
    </em>
    <span class="koboSpan" id="kobo.594.1">
     .
    </span>
    <span class="koboSpan" id="kobo.594.2">
     On
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.595.1">
      line 6
     </span>
    </em>
    <span class="koboSpan" id="kobo.596.1">
     , I declared the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.597.1">
      pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.598.1">
     variable.
    </span>
    <span class="koboSpan" id="kobo.598.2">
     On
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.599.1">
      line 8
     </span>
    </em>
    <span class="koboSpan" id="kobo.600.1">
     , I started a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.601.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.602.1">
     loop that reads each line of data from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.603.1">
      $
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.604.1">
       user_list
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.605.1">
      variable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.606.1">
     On
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.607.1">
      line 9
     </span>
    </em>
    <span class="koboSpan" id="kobo.608.1">
     , I used the match operator,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.609.1">
      =~
     </span>
    </strong>
    <span class="koboSpan" id="kobo.610.1">
     , to compare each line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.611.1">
      ($line
     </span>
    </strong>
    <span class="koboSpan" id="kobo.612.1">
     ) against our regex pattern (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.613.1">
      $pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.614.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.614.2">
     These are referred to by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.615.1">
      $line
     </span>
    </strong>
    <span class="koboSpan" id="kobo.616.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.617.1">
      $pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.618.1">
     variables, which are declared.
    </span>
    <span class="koboSpan" id="kobo.618.2">
     When you use the match operator, the string on the left (represented by the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.619.1">
      $line
     </span>
    </strong>
    <span class="koboSpan" id="kobo.620.1">
     variable) is matched against the regex pattern on the right.
    </span>
    <span class="koboSpan" id="kobo.620.2">
     If the pattern matches, the expression returns true (0); otherwise, it returns
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.621.1">
      false (1).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.622.1">
     First, the pattern captures a username using the relevant capture group:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.623.1">
      ([a-zA-Z0-9_]+)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.624.1">
     .
    </span>
    <span class="koboSpan" id="kobo.624.2">
     Remember, a capture group consists of parenthesis,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.625.1">
      ()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.626.1">
     , surrounding a regex.
    </span>
    <span class="koboSpan" id="kobo.626.2">
     Inside the capture group, we
    </span>
    <a id="_idIndexMarker230">
    </a>
    <span class="koboSpan" id="kobo.627.1">
     have a bracket expression that will match all alphanumeric characters, plus an underscore to match usernames.
    </span>
    <span class="koboSpan" id="kobo.627.2">
     The second capture group matches an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.628.1">
      email address.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.629.1">
     If a line matches, Bash populates an array called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.630.1">
      BASH_REMATCH
     </span>
    </strong>
    <span class="koboSpan" id="kobo.631.1">
     with the captured groups.
    </span>
    <span class="koboSpan" id="kobo.631.2">
     Here,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.632.1">
      BASH_REMATCH[1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.633.1">
     contains
    </span>
    <a id="_idIndexMarker231">
    </a>
    <span class="koboSpan" id="kobo.634.1">
     the first captured group (the username), and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.635.1">
      BASH_REMATCH[2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.636.1">
     contains the second group (the email address).
    </span>
    <span class="koboSpan" id="kobo.636.2">
     Then, we print
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.637.1">
      these out:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.638.1">
~ $ bash ch04_regex_02.sh
Username: john_doe, Email: john.doe@example.com
Username: jane_smith, Email: jane.smith@example.com</span></pre>
   <p>
    <span class="koboSpan" id="kobo.639.1">
     Did you spot where I could have made the capture groups easier to read and write?
    </span>
    <span class="koboSpan" id="kobo.639.2">
     The first capture group,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.640.1">
      ([a-zA-Z0-9_]+)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.641.1">
     , could have been simplified to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.642.1">
      ([[:alnum:]_]+)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.643.1">
     , and the second capture group,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.644.1">
      ([a-zA-Z0-9_.]+@[a-zA-Z0-9_.]+)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.645.1">
     , could have been simplified
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.646.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.647.1">
       ([[alnum]_.]+@[[:alnum:]_.]+)
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.648.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-82">
    <a id="_idTextAnchor084">
    </a>
    <span class="koboSpan" id="kobo.649.1">
     Matching IP addresses with grep
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.650.1">
     In this example, we’re going to look at a practical case involving a port scan to locate IP addresses with specific ports open.
    </span>
    <span class="koboSpan" id="kobo.650.2">
     This is a common pentest task that is frequently used to
    </span>
    <a id="_idIndexMarker232">
    </a>
    <span class="koboSpan" id="kobo.651.1">
     produce a list of hosts to use
    </span>
    <a id="_idIndexMarker233">
    </a>
    <span class="koboSpan" id="kobo.652.1">
     with subsequent targeted scans, or for producing a list of affected hosts for a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.653.1">
      pentest
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.654.1">
      finding.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.655.1">
     Since this involves scanning your local network, make sure you have permission to scan the network if you don’t own it.
    </span>
    <span class="koboSpan" id="kobo.655.2">
     I’ve included a sample Nmap scan file from my lab for your convenience in this book’s GitHub
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.656.1">
      repository:
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.657.1">
       test_nmap.gnmap
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.658.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.659.1">
     Use the following Nmap command to scan the network, replacing the network address with one applicable to your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.660.1">
      network address:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.661.1">
nmap -oG test.gnmap 10.1.0.0/24</span></pre>
   <p>
    <span class="koboSpan" id="kobo.662.1">
     The scan command’s options specify greppable output,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.663.1">
      -oG
     </span>
    </strong>
    <span class="koboSpan" id="kobo.664.1">
     , the output filename,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.665.1">
      test_nmap.gnmap
     </span>
    </strong>
    <span class="koboSpan" id="kobo.666.1">
     , followed by the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.667.1">
      network address.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.668.1">
     In my scan, one line of the scan that’s output from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.669.1">
      test_nmap.gnmap
     </span>
    </strong>
    <span class="koboSpan" id="kobo.670.1">
     file looks
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.671.1">
      like this:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.672.1">
Host: 10.1.0.1 ()     Ports: 53/open/tcp//domain///, 80/open/tcp//http///, 443/open/tcp//https///</span></pre>
   <p>
    <span class="koboSpan" id="kobo.673.1">
     Next, we want to
    </span>
    <a id="_idIndexMarker234">
    </a>
    <span class="koboSpan" id="kobo.674.1">
     identify any host IP addresses with open
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.675.1">
      http
     </span>
    </strong>
    <span class="koboSpan" id="kobo.676.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.677.1">
      https
     </span>
    </strong>
    <span class="koboSpan" id="kobo.678.1">
     service ports.
    </span>
    <span class="koboSpan" id="kobo.678.2">
     Execute the following command in the same directory as the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.679.1">
       test_nmap.gnmap
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.680.1">
      file:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.681.1">
grep /open/tcp//http test_nmap.gnmap | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.682.1">
     This example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.683.1">
      ch04_regex_03.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.684.1">
     file in this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.685.1">
      chapter’s folder.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.686.1">
     The preceding
    </span>
    <a id="_idIndexMarker235">
    </a>
    <span class="koboSpan" id="kobo.687.1">
     command uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.688.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.689.1">
     to search for a regex of the literal (no metacharacters) text,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.690.1">
      /open/tcp//http
     </span>
    </strong>
    <span class="koboSpan" id="kobo.691.1">
     .
    </span>
    <span class="koboSpan" id="kobo.691.2">
     The output of that command is the full line of text of every line that includes that string.
    </span>
    <span class="koboSpan" id="kobo.691.3">
     The pipe character,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.692.1">
      |
     </span>
    </strong>
    <span class="koboSpan" id="kobo.693.1">
     , simply connects the output (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.694.1">
      stdout
     </span>
    </strong>
    <span class="koboSpan" id="kobo.695.1">
     ) of the first process with the input (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.696.1">
      stdin
     </span>
    </strong>
    <span class="koboSpan" id="kobo.697.1">
     ) of the next process.
    </span>
    <span class="koboSpan" id="kobo.697.2">
     Then, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.698.1">
      -oE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.699.1">
     arguments are provided with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.700.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.701.1">
     command.
    </span>
    <span class="koboSpan" id="kobo.701.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.702.1">
      -o
     </span>
    </strong>
    <span class="koboSpan" id="kobo.703.1">
     option means to output only the matching text instead of the full line, and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.704.1">
      -E
     </span>
    </strong>
    <span class="koboSpan" id="kobo.705.1">
     option enables the extended regex feature.
    </span>
    <span class="koboSpan" id="kobo.705.2">
     Finally, the regex pattern for an IP address ends the command.
    </span>
    <span class="koboSpan" id="kobo.705.3">
     The following output is produced by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.706.1">
      this command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.707.1">
~ $ grep /open/tcp//http test_nmap.gnmap | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b"
10.1.0.1
10.1.0.4
10.1.0.6
10.1.0.7
10.1.0.13</span></pre>
   <p>
    <span class="koboSpan" id="kobo.708.1">
     The pipe character’s use to redirect output to the input of another process is a powerful feature that we’ll be
    </span>
    <a id="_idIndexMarker236">
    </a>
    <span class="koboSpan" id="kobo.709.1">
     using frequently in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.710.1">
      later chapters.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-83">
    <a id="_idTextAnchor085">
    </a>
    <span class="koboSpan" id="kobo.711.1">
     Using handy grep flags
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.712.1">
     While these
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.713.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.714.1">
     flags are pretty simple, they’re also very handy.
    </span>
    <span class="koboSpan" id="kobo.714.2">
     I use them frequently and want to share them
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.715.1">
      with you.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.716.1">
     Something that I frequently do
    </span>
    <a id="_idIndexMarker237">
    </a>
    <span class="koboSpan" id="kobo.717.1">
     on internal network pentest is use any credentials that I’ve obtained to enumerate file shares that can be accessed with
    </span>
    <a id="_idIndexMarker238">
    </a>
    <span class="koboSpan" id="kobo.718.1">
     those credentials.
    </span>
    <span class="koboSpan" id="kobo.718.2">
     In this example, I’m using NetExec to check for SMB file shares that are accessible with the credentials I have.
    </span>
    <span class="koboSpan" id="kobo.718.3">
     You can find NetExec
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.719.1">
      at
     </span>
    </span>
    <a href="https://github.com/Pennyw0rth/NetExec">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.720.1">
       https://github.com/Pennyw0rth/NetExec
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.721.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.722.1">
     The following figure shows the output of a NetExec SMB file share
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.723.1">
      enumeration scan:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer041">
     <span class="koboSpan" id="kobo.724.1">
      <img alt="Figure 4.12 – NetExec SMB share enumeration scan" src="image/B22229_04_12.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.725.1">
     Figure 4.12 – NetExec SMB share enumeration scan
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.726.1">
     The scan output was saved to a file,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.727.1">
      nxc.log
     </span>
    </strong>
    <span class="koboSpan" id="kobo.728.1">
     .
    </span>
    <span class="koboSpan" id="kobo.728.2">
     Let’s imagine that I’ve run this scan on a large network with hundreds or even thousands of hosts and I want to focus on finding those shares where I can either read or write to the share, but I don’t want to see any of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.729.1">
      IPC$
     </span>
    </strong>
    <span class="koboSpan" id="kobo.730.1">
     or
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.731.1">
       PRINT$
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.732.1">
      shares.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.733.1">
     While there are regex patterns that could reasonably work here to match a combination of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.734.1">
      READ
     </span>
    </strong>
    <span class="koboSpan" id="kobo.735.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.736.1">
      WRITE
     </span>
    </strong>
    <span class="koboSpan" id="kobo.737.1">
     , we want to keep this simple so that we don’t have to refer to our notes.
    </span>
    <span class="koboSpan" id="kobo.737.2">
     The following command can accomplish
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.738.1">
      this goal:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer042">
     <span class="koboSpan" id="kobo.739.1">
      <img alt="Figure 4.13 – Our grep flags simplify the task" src="image/B22229_04_13.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.740.1">
     Figure 4.13 – Our grep flags simplify the task
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.741.1">
     This example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.742.1">
      ch04_regex_04.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.743.1">
     file in this chapter’s folder.
    </span>
    <span class="koboSpan" id="kobo.743.2">
     Let’s break down the
    </span>
    <a id="_idIndexMarker239">
    </a>
    <span class="koboSpan" id="kobo.744.1">
     sequence
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.745.1">
      of commands:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.746.1">
       cat nxc.log
      </span>
     </strong>
     <span class="koboSpan" id="kobo.747.1">
      : This prints the
     </span>
     <a id="_idIndexMarker240">
     </a>
     <span class="koboSpan" id="kobo.748.1">
      output of the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.749.1">
        nxc.log
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.750.1">
       file.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.751.1">
       |
      </span>
     </strong>
     <span class="koboSpan" id="kobo.752.1">
      : This connects the output of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.753.1">
       cat
      </span>
     </strong>
     <span class="koboSpan" id="kobo.754.1">
      command to the input of the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.755.1">
        grep
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.756.1">
       command.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.757.1">
       grep -e READ -e WRITE
      </span>
     </strong>
     <span class="koboSpan" id="kobo.758.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.759.1">
       grep
      </span>
     </strong>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.760.1">
       -e
      </span>
     </strong>
     <span class="koboSpan" id="kobo.761.1">
      flag specifies a pattern.
     </span>
     <span class="koboSpan" id="kobo.761.2">
      More than one pattern can be used if you include additional
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.762.1">
       -e
      </span>
     </strong>
     <span class="koboSpan" id="kobo.763.1">
      flags.
     </span>
     <span class="koboSpan" id="kobo.763.2">
      This will match if either or both of the words
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.764.1">
       are found.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.765.1">
       grep -v …
      </span>
     </strong>
     <span class="koboSpan" id="kobo.766.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.767.1">
       grep
      </span>
     </strong>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.768.1">
       -v
      </span>
     </strong>
     <span class="koboSpan" id="kobo.769.1">
      flag means invert the match.
     </span>
     <span class="koboSpan" id="kobo.769.2">
      This is similar to a logical
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.770.1">
       NOT
      </span>
     </strong>
     <span class="koboSpan" id="kobo.771.1">
      expression.
     </span>
     <span class="koboSpan" id="kobo.771.2">
      In other words, filter out anything that matches
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.772.1">
       this expression.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.773.1">
     You will use these patterns frequently in your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.774.1">
      pentest
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.775.1">
      career.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-84">
    <a id="_idTextAnchor086">
    </a>
    <span class="koboSpan" id="kobo.776.1">
     Redacting IP addresses
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.777.1">
     While the following
    </span>
    <a id="_idIndexMarker241">
    </a>
    <span class="koboSpan" id="kobo.778.1">
     example demonstrates redacting IP addresses using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.779.1">
      sed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.780.1">
     (stream editor) command, it can
    </span>
    <a id="_idIndexMarker242">
    </a>
    <span class="koboSpan" id="kobo.781.1">
     be adapted to other cases of mass editing text in a file or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.782.1">
      input stream.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.783.1">
     Let’s imagine that you want to redact the IP addresses in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.784.1">
      test_nmap.gnmap
     </span>
    </strong>
    <span class="koboSpan" id="kobo.785.1">
     file before you share it with someone.
    </span>
    <span class="koboSpan" id="kobo.785.2">
     Again, we’ll use the regex for an IP address.
    </span>
    <span class="koboSpan" id="kobo.785.3">
     However, this time, we’ll pipe the output to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.786.1">
      sed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.787.1">
     and redact all IP addresses.
    </span>
    <span class="koboSpan" id="kobo.787.2">
     Run the following command in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.788.1">
      your Terminal:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.789.1">
sed -E 's/([0-9]{1,3}\.){3}[0-9]{1,3}/REDACTED_IP/g' test_nmap.gnmap</span></pre>
   <p>
    <span class="koboSpan" id="kobo.790.1">
     This example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.791.1">
      ch04_regex_05.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.792.1">
     file in this chapter’s folder.
    </span>
    <span class="koboSpan" id="kobo.792.2">
     The output should show that every IP address in the file has
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.793.1">
      been redacted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.794.1">
     So, what does this
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.795.1">
      sed
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.796.1">
      command do?
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.797.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.798.1">
       -E
      </span>
     </strong>
     <span class="koboSpan" id="kobo.799.1">
      option enables
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.800.1">
       extended regex.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.801.1">
      The command after
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.802.1">
       sed
      </span>
     </strong>
     <span class="koboSpan" id="kobo.803.1">
      is enclosed in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.804.1">
       single quotes.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.805.1">
      After the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.806.1">
       sed
      </span>
     </strong>
     <span class="koboSpan" id="kobo.807.1">
      command and arguments, you’ll see a pattern similar
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.808.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.809.1">
        's/MATCH/REPLACE/g'
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.810.1">
       .
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.811.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.812.1">
       s
      </span>
     </strong>
     <span class="koboSpan" id="kobo.813.1">
      option means search for
     </span>
     <a id="_idIndexMarker243">
     </a>
     <span class="koboSpan" id="kobo.814.1">
      anything (literal text or regex) between the next
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.815.1">
       /
      </span>
     </strong>
     <span class="koboSpan" id="kobo.816.1">
      characters (the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.817.1">
        MATCH
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.818.1">
       text).
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.819.1">
      Replace the
     </span>
     <a id="_idIndexMarker244">
     </a>
     <span class="koboSpan" id="kobo.820.1">
      matched text with the pattern between the next set of slash (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.821.1">
       /
      </span>
     </strong>
     <span class="koboSpan" id="kobo.822.1">
      ) characters (the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.823.1">
        REPLACE
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.824.1">
       text).
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.825.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.826.1">
       g
      </span>
     </strong>
     <span class="koboSpan" id="kobo.827.1">
      flag means to make it a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.828.1">
       global
      </span>
     </strong>
     <span class="koboSpan" id="kobo.829.1">
      search and replace every occurrence.
     </span>
     <span class="koboSpan" id="kobo.829.2">
      Otherwise, if the regex or literal string was matched twice on the same line, it would only perform the substitution on the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.830.1">
       first match.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.831.1">
     In this example, we didn’t edit the original file in place.
    </span>
    <span class="koboSpan" id="kobo.831.2">
     We only edited the text output to the screen.
    </span>
    <span class="koboSpan" id="kobo.831.3">
     There are two ways we could have edited and saved the text: by including the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.832.1">
      sed -i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.833.1">
     flag or by redirecting the output to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.834.1">
      a file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.835.1">
     In the first case, edit the file in place by adding the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.836.1">
      sed -
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.837.1">
       i
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.838.1">
      flag:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.839.1">
sed -iE 's/([0-9]{1,3}\.){3}[0-9]{1,3}/REDACTED_IP/g' test_nmap.gnmap</span></pre>
   <p>
    <span class="koboSpan" id="kobo.840.1">
     This example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.841.1">
      ch04_regex_06.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.842.1">
     file in this chapter’s folder.
    </span>
    <span class="koboSpan" id="kobo.842.2">
     The other option omits the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.843.1">
      -i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.844.1">
     flag.
    </span>
    <span class="koboSpan" id="kobo.844.2">
     It will preserve the original file and redirect the edited text to a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.845.1">
      new file:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.846.1">
sed -E 's/([0-9]{1,3}\.){3}[0-9]{1,3}/REDACTED_IP/g' test_nmap.gnmap &gt; new_test_nmap.gnmap</span></pre>
   <p>
    <span class="koboSpan" id="kobo.847.1">
     This example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.848.1">
      ch04_regex_07.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.849.1">
     file in this chapter’s folder.
    </span>
    <span class="koboSpan" id="kobo.849.2">
     The preceding command uses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.850.1">
      &gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.851.1">
     character to redirect the output to the filename
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.852.1">
      that follows.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.853.1">
     Tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.854.1">
     When using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.855.1">
      &gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.856.1">
     character to redirect output (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.857.1">
      stdout
     </span>
    </strong>
    <span class="koboSpan" id="kobo.858.1">
     ) to a file, it will overwrite the file if it exists.
    </span>
    <span class="koboSpan" id="kobo.858.2">
     To append to an existing file instead of overwriting it, utilize
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.859.1">
      &gt;&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.860.1">
     in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.861.1">
      the command.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.862.1">
     Next, let’s examine using
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.863.1">
      awk
     </span>
    </strong>
    <span class="koboSpan" id="kobo.864.1">
     for
    </span>
    <a id="_idIndexMarker245">
    </a>
    <span class="koboSpan" id="kobo.865.1">
     regex matching.
    </span>
    <span class="koboSpan" id="kobo.865.2">
     Awk is much more than just a tool for regex; it’s a full-fledged programming
    </span>
    <a id="_idIndexMarker246">
    </a>
    <span class="koboSpan" id="kobo.866.1">
     language.
    </span>
    <span class="koboSpan" id="kobo.866.2">
     Where it shines is when you’re sifting through tabular data (columns, tab, and comma-separated data).
    </span>
    <span class="koboSpan" id="kobo.866.3">
     Before learning awk, I mistakenly believed it to
    </span>
    <a id="_idIndexMarker247">
    </a>
    <span class="koboSpan" id="kobo.867.1">
     be too complex and I would chain together multiple tools to do the same job, ultimately putting in more work than I would if I just used awk.
    </span>
    <span class="koboSpan" id="kobo.867.2">
     I’ll be a bit brief in this chapter and stick to a few quick examples because we’ll be going more in depth in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.868.1">
      next chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.869.1">
     Awk programs can be a single line for quick one-off scripts, though they can be used in files for more complex use cases.
    </span>
    <span class="koboSpan" id="kobo.869.2">
     The format of a one-line awk script is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.870.1">
      awk 'pattern {action}'
     </span>
    </strong>
    <span class="koboSpan" id="kobo.871.1">
     .
    </span>
    <span class="koboSpan" id="kobo.871.2">
     Either
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.872.1">
      pattern
     </span>
    </strong>
    <span class="koboSpan" id="kobo.873.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.874.1">
      action
     </span>
    </strong>
    <span class="koboSpan" id="kobo.875.1">
     may be omitted, but
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.876.1">
      not both.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.877.1">
     The default field separator is any whitespace, such as spaces or tabs.
    </span>
    <span class="koboSpan" id="kobo.877.2">
     Multiple whitespace characters are treated as a single unit.
    </span>
    <span class="koboSpan" id="kobo.877.3">
     This is very helpful as I used to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.878.1">
      tr -s ' '
     </span>
    </strong>
    <span class="koboSpan" id="kobo.879.1">
     to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.880.1">
      squeeze
     </span>
    </em>
    <span class="koboSpan" id="kobo.881.1">
     or combine multiple spaces into one before
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.882.1">
      learning awk.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.883.1">
     Before diving into our first awk example, let’s take a minute to understand common
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.884.1">
      awk terms:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.885.1">
       Record
      </span>
     </strong>
     <span class="koboSpan" id="kobo.886.1">
      : Each line of an input file is referred to as
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.887.1">
       a record.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.888.1">
       Field
      </span>
     </strong>
     <span class="koboSpan" id="kobo.889.1">
      : Each column is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.890.1">
       a field.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.891.1">
       $n
      </span>
     </strong>
     <span class="koboSpan" id="kobo.892.1">
      : Each field (column).
     </span>
     <span class="koboSpan" id="kobo.892.2">
      The whole record (line) is
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.893.1">
       $0
      </span>
     </strong>
     <span class="koboSpan" id="kobo.894.1">
      , the first field is
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.895.1">
       $1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.896.1">
      , and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.897.1">
       so on.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.898.1">
       $NF
      </span>
     </strong>
     <span class="koboSpan" id="kobo.899.1">
      : The number of fields in a record.
     </span>
     <span class="koboSpan" id="kobo.899.2">
      It can also be used to refer to the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.900.1">
       last field.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.901.1">
       $NR
      </span>
     </strong>
     <span class="koboSpan" id="kobo.902.1">
      : The number of records
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.903.1">
       so far.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.904.1">
       -F
      </span>
     </strong>
     <span class="koboSpan" id="kobo.905.1">
      : A field separator; this is a space by default.
     </span>
     <span class="koboSpan" id="kobo.905.2">
      Remember, any number of consecutive spaces are combined.
     </span>
     <span class="koboSpan" id="kobo.905.3">
      So, if the first two fields are separated by one or multiple spaces,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.906.1">
       $1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.907.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.908.1">
       $2
      </span>
     </strong>
     <span class="koboSpan" id="kobo.909.1">
      still refer to the first and second
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.910.1">
       fields (columns).
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.911.1">
     In the following figure, you
    </span>
    <a id="_idIndexMarker248">
    </a>
    <span class="koboSpan" id="kobo.912.1">
     can see the output of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.913.1">
      ps -ef
     </span>
    </strong>
    <span class="koboSpan" id="kobo.914.1">
     command on
    </span>
    <a id="_idIndexMarker249">
    </a>
    <span class="koboSpan" id="kobo.915.1">
     my system.
    </span>
    <span class="koboSpan" id="kobo.915.2">
     This is the data I’ll be using in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.916.1">
      following examples:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer043">
     <span class="koboSpan" id="kobo.917.1">
      <img alt="Figure 4.14 – System processes are shown when using the ps command" src="image/B22229_04_14.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.918.1">
     Figure 4.14 – System processes are shown when using the ps command
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.919.1">
     In our first awk example, I’m simply going to print each
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.920.1">
      record (
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.921.1">
       line
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.922.1">
      ):
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer044">
     <span class="koboSpan" id="kobo.923.1">
      <img alt="Figure 4.15 – Printing the whole record using $0" src="image/B22229_04_15.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.924.1">
     Figure 4.15 – Printing the whole record using $0
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.925.1">
     This example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.926.1">
      ch04_regex_08.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.927.1">
     file in this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.928.1">
      chapter’s folder.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.929.1">
     Next, we’re going to look at a more advanced example.
    </span>
    <span class="koboSpan" id="kobo.929.2">
     In the following figure, I’m using a pattern and action.
    </span>
    <span class="koboSpan" id="kobo.929.3">
     This example will match any process with a UID of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.930.1">
      author
     </span>
    </strong>
    <span class="koboSpan" id="kobo.931.1">
     and print the CMD (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.932.1">
      $8
     </span>
    </strong>
    <span class="koboSpan" id="kobo.933.1">
     , or the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.934.1">
      8
     </span>
    </span>
    <span class="No-Break">
     <span class="superscript">
      <span class="koboSpan" id="kobo.935.1">
       th
      </span>
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.936.1">
      field):
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer045">
     <span class="koboSpan" id="kobo.937.1">
      <img alt="Figure 4.16 – Printing the CMD of any process owned by author" src="image/B22229_04_16.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.938.1">
     Figure 4.16 – Printing the CMD of any process owned by author
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.939.1">
     This example code can be
    </span>
    <a id="_idIndexMarker250">
    </a>
    <span class="koboSpan" id="kobo.940.1">
     found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.941.1">
      ch04_regex_09.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.942.1">
     file in this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.943.1">
      chapter’s folder.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.944.1">
     In our final awk example, we’re
    </span>
    <a id="_idIndexMarker251">
    </a>
    <span class="koboSpan" id="kobo.945.1">
     going to examine how to use regex and print the output with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.946.1">
      custom separator:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer046">
     <span class="koboSpan" id="kobo.947.1">
      <img alt="Figure 4.17 – Using a regex and printing the custom output with awk" src="image/B22229_04_17.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.948.1">
     Figure 4.17 – Using a regex and printing the custom output with awk
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.949.1">
     This example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.950.1">
      ch04_regex_10.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.951.1">
     file in this chapter’s folder.
    </span>
    <span class="koboSpan" id="kobo.951.2">
     In the preceding example, the regex in the pattern matches anything in the eighth field that starts with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.952.1">
      [irq/
     </span>
    </strong>
    <span class="koboSpan" id="kobo.953.1">
     , followed by exactly two digits, followed by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.954.1">
      -pciehp]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.955.1">
     .
    </span>
    <span class="koboSpan" id="kobo.955.2">
     For any matching records, the action prints the first and eighth fields, separated by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.956.1">
      ---&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.957.1">
     instead of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.958.1">
      default space.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.959.1">
     We’ve only scratched the surface of how to use awk.
    </span>
    <span class="koboSpan" id="kobo.959.2">
     However, the concepts demonstrated here will solve the most common scripting tasks.
    </span>
    <span class="koboSpan" id="kobo.959.3">
     We’ll explore this subject more in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.960.1">
      next chapter.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-85">
    <a id="_idTextAnchor087">
    </a>
    <span class="koboSpan" id="kobo.961.1">
     Regex tips and best practices
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.962.1">
     The following tips will help guide you
    </span>
    <a id="_idIndexMarker252">
    </a>
    <span class="koboSpan" id="kobo.963.1">
     through creating complex
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.964.1">
      regex patterns:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.965.1">
       Start small
      </span>
     </strong>
     <span class="koboSpan" id="kobo.966.1">
      : Begin with simple patterns and gradually introduce
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.967.1">
       more complexity.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.968.1">
       Practice
      </span>
     </strong>
     <span class="koboSpan" id="kobo.969.1">
      : Use online regex testers to experiment with different patterns
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.970.1">
       and flags.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.971.1">
       Break it down
      </span>
     </strong>
     <span class="koboSpan" id="kobo.972.1">
      : When faced with a complex pattern, break it down into smaller parts to understand
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.973.1">
       each component.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.974.1">
       Refer to documentation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.975.1">
      : Keep a cheat sheet or reference guide handy until you’re more comfortable with common patterns and metacharacters.
     </span>
     <span class="koboSpan" id="kobo.975.2">
      While there are plenty of regex cheat sheets to be found online, I suggest that you make your own while
     </span>
     <a id="_idIndexMarker253">
     </a>
     <span class="koboSpan" id="kobo.976.1">
      reading this book and experimenting.
     </span>
     <span class="koboSpan" id="kobo.976.2">
      I find that the act of making notes helps me commit difficult concepts
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.977.1">
       to memory.
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-86">
    <a id="_idTextAnchor088">
    </a>
    <span class="koboSpan" id="kobo.978.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.979.1">
     In this chapter, we provided an introduction to regex, followed by more advanced topics, including metacharacters and capture groups.
    </span>
    <span class="koboSpan" id="kobo.979.2">
     Finally, we learned how to apply these techniques to real-world applications of Bash scripting that you will find useful
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.980.1">
      for
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.981.1">
      pentest
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.982.1">
      ing.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.983.1">
     Regex doesn’t have to be intimidating.
    </span>
    <span class="koboSpan" id="kobo.983.2">
     With a basic understanding of characters, metacharacters, and flags, you’re well on your way to harnessing their power.
    </span>
    <span class="koboSpan" id="kobo.983.3">
     Whether you’re editing text, analyzing data, or validating user input, regex can be an invaluable tool in your toolkit.
    </span>
    <span class="koboSpan" id="kobo.983.4">
     Remember, like any skill, proficiency comes with practice.
    </span>
    <span class="koboSpan" id="kobo.983.5">
     So, dive in, start experimenting, and soon they will become easy with a bit
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.984.1">
      of practice.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.985.1">
     In the next chapter, we’ll combine the regex concepts we learned in this chapter with common text parsing tools so that we can focus on common cybersecurity and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.986.1">
      pentest
     </span>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.987.1">
      ing tasks.
     </span>
    </span>
   </p>
  </div>
 </body></html>