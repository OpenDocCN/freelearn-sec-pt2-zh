- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Regular expressions** , or **regex** , might seem daunting at first, but
    they’re an incredibly powerful tool for anyone working with text, especially in
    Bash scripting. This chapter is designed to ease you into the world of regex,
    starting from the basics and gradually moving to more complex patterns and techniques.
    Whether you’re looking to validate email addresses, search for specific patterns
    in log files, or automate text processing tasks, understanding regex is a game-changer.
    We’ll explore how to craft regex patterns, understand their structure, and apply
    them in practical scenarios. By the end of this chapter, you’ll not only be comfortable
    using regex but also appreciate how they can make your scripting tasks more efficient
    and versatile.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter builds on the topics you learned about in the previous chapter.
    Regex is frequently used together with variables and conditional statements. For
    example, you’re likely going to use a **while** loop to read in a line of data
    from **stdin** or from a file and assign the data you read to a variable. Then,
    you’re going to perform a regex on the variable data, and finally make a decision
    using a conditional statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of regex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced regex patterns and techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstrating practical applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regex tips and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is helpful but not required to be able to install a Kali virtual machine,
    as stated in [*Chapter 1*](B22229_01.xhtml#_idTextAnchor017) .
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter04](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter04)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The basics of regex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At their core, regex is a method for searching, matching, and manipulating text.
    Think of them as a sophisticated search tool that goes beyond the capabilities
    of the standard search feature in your text editor or word processor. Regex allows
    you to define patterns in text, making it possible to perform complex searches
    and edits with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regex is incredibly versatile. Here are just a few examples of what they can
    be used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data validation** : Ensuring that user input matches a specific format, such
    as email addresses or phone numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data extraction** : Pulling specific pieces of information from a larger
    dataset, such as extracting all URLs from a web page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search and replace** : Finding and replacing text in a document based on
    patterns rather than exact matches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The regex alphabet consists of **characters** and **metacharacters** . Characters
    are just what you think: letters, numbers, and symbols that you’re trying to find
    in your text. Metacharacters, on the other hand, are the special sauce of regex.
    They’re symbols that have a special meaning, helping to define patterns. Some
    common metacharacters include **.** , ***** , **+** , **?** , **^** , **$** ,
    **[]** , **{n}** , **{n, m}** , **{n,}** , **(a|b)** , and **=~** .'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll be showing examples using the **grep** command. The **grep**
    command searches for patterns in files or piped input. You can learn more about
    **grep** by entering the **man** **grep** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The period ( **.** ) metacharacter matches any single character except newline,
    which is the end of a line and is represented by **\n** . One of the common ways
    I use **.** in regex is when parsing the output of a program and I want to eliminate
    blank lines. Just as **.** matches any character, when used by itself in a regex,
    its use removes any blank lines since there’s nothing to match. The following
    figure demonstrates that **.** matches any character. The matched text is highlighted
    in red font:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Matching non-blank lines using the period metacharacter](image/B22229_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Matching non-blank lines using the period metacharacter
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, not only does the **.** metacharacter match any character (highlighted
    in red), but it also helps us to match only lines that aren’t blank.
  prefs: []
  type: TYPE_NORMAL
- en: 'The asterisk ( ***** ) metacharacter matches zero or more occurrences of the
    preceding element. Imagine that you have a text file named **sample.txt** with
    various lines of text, and you’re interested in finding lines that match the **ho*p**
    pattern. The pattern should match lines with **hop** , **hoop** , **hooooop**
    , and so on. The content of the **sample.txt** file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The content of the sample.txt file](image/B22229_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The content of the sample.txt file
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You must use the **grep** command with the **-E** option for extended regex,
    which allows you to use the ***** metacharacter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command tells **grep** to search within **sample.txt** for lines that
    match the **ho*p** pattern: **grep -E ''ho*p'' sample.txt** . The **-E** option
    is used to enable extended regex, which includes support for the ***** metacharacter,
    among other features. Otherwise, outside of a regex, ***** is called a **glob**
    character, as discussed in [*Chapter 2*](B22229_02.xhtml#_idTextAnchor034) .'
  prefs: []
  type: TYPE_NORMAL
- en: 'The plus ( **+** ) metacharacter matches one or more occurrences of the preceding
    element. For example, if you’re analyzing log files for errors, a pattern such
    as **Error: +** could help you find lines where **Error:** is followed by one
    or more spaces, indicating the start of an error message. Without the **+** metacharacter,
    you’d either miss cases with multiple spaces or waste time sifting through irrelevant
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: The question ( **?** ) metacharacter makes the preceding element optional. At
    its core, the **?** metacharacter represents optionality. It tells the regex engine
    to match the preceding element zero or one time. Simply put, it means that the
    character or pattern right before **?** might be there, but it’s OK if it’s not.
  prefs: []
  type: TYPE_NORMAL
- en: This concept is easier to grasp with an example. Imagine that you’re tasked
    with processing log files. These logs follow a naming convention such as **app-log-2024.txt**
    , but sometimes, they include an extra identifier, such as **app-log-2024-debug.txt**
    . Using the **?** metacharacter allows your script to be more flexible. A pattern
    such as **app-log-2024(-debug)?.txt** can match both filenames, ensuring your
    script works seamlessly across different log types.
  prefs: []
  type: TYPE_NORMAL
- en: The caret ( **^** ) metacharacter matches the start of a line. You might be
    wondering why you’d need to specify that something should be at the beginning
    of a line. It’s all about precision. In this example, if we didn’t use the **^**
    metacharacter and searched for **DONE** alone, we’d get any line containing **DONE**
    anywhere in the text – not just at the beginning. This could include lines where
    **DONE** appears in a note or reminder, not just as a task status marker.
  prefs: []
  type: TYPE_NORMAL
- en: The dollar ( **$** ) metacharacter matches the end of a line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of matching using **$** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Matching the end of a string using the $ metacharacter](image/B22229_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Matching the end of a string using the $ metacharacter
  prefs: []
  type: TYPE_NORMAL
- en: Bracket expressions ( **[ ]** ) match any single character within the brackets.
    You can perform a logical **NOT** expression by making the **^** symbol the first
    character in the list. That would result in matching characters that are not on
    the list. For example, if you wanted to match vowel characters, an appropriate
    bracket expression would be **[aeiou]** , whereas if you wanted to match consonants,
    you could use **[^aeiou]** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Range expressions are frequently used inside bracket expressions to save you
    the time and effort of typing all subsequent characters or numbers in a range.
    For example, instead of typing the letters *a* through *z* inside brackets, you
    can use **[a-z]** as a handy shortcut. Similarly, for numbers, you can use a range
    such as **[1-10]** . The following figure demonstrates how bracket expressions
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Examples of using bracket expressions](image/B22229_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Examples of using bracket expressions
  prefs: []
  type: TYPE_NORMAL
- en: Bracket expressions are a valuable, time-saving regex feature!
  prefs: []
  type: TYPE_NORMAL
- en: 'The **{n}** metacharacter specifies that the preceding element is matched exactly
    *n* times. It can also be written as **{n, m}** or **{n,}** , meaning the preceding
    element is matched between **n** and **n** times, or is matched exactly **n**
    or more times, respectively. Let’s look at how this can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – An example showing how to match n or more times](image/B22229_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – An example showing how to match n or more times
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows that I specified that it must match **3** or more
    times for the **o** character. The word **hoooop** was the only match. Note that
    I had to include the **-E** argument in **grep** to enable extended regex capability,
    and had to escape the brackets with a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: The **(a|b)** metacharacter matches either **a** or **b** .
  prefs: []
  type: TYPE_NORMAL
- en: 'The **=~** match operator is typically used inside scripts. Let’s discuss the
    basic example shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – An example demonstrating the match operator](image/B22229_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – An example demonstrating the match operator
  prefs: []
  type: TYPE_NORMAL
- en: If the string on the left-hand side of the **=~** operator matches the regex
    on the right, the expression evaluates to **true** , and the exit status of the
    **[[ ]]** bracket expression is 0 (zero). In Bash shell scripting, an exit status
    of 0 signifies success or **true** . An exit value of anything other than 0 signifies
    failure or **false** .
  prefs: []
  type: TYPE_NORMAL
- en: In Bash scripting, **&&** and **||** are **logical operators** that are used
    within conditional expressions to combine multiple commands or conditions. Their
    usage is tied to the exit status of commands. Applied to the previous figure,
    if the match pattern finds a match on the input expression, it results in an exit
    status of 0, or true. If the string doesn’t match the regex, the expression evaluates
    to false, and the exit status of the **[[ ]]** expression is 1 (an exit status
    of 1 signifies failure or false). The **&&** operator passes the exit status to
    the following **||** expression, which can be thought of as **true** or **false**
    . If the expression was true, the statement on the left, **echo Match found!**
    , is executed. If false, the statement on the right, **echo "No match"** , is
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’re familiar with metacharacters, let’s explore **character classes**
    , which provide handy shortcuts when using the bracket expressions we just covered.
  prefs: []
  type: TYPE_NORMAL
- en: Using character classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When used inside bracket expressions, character classes are a handy shortcut
    that simplifies regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[:alpha:]** : Alphabet characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[:alnum:]** : Alphanumeric characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[:digit:]** : The numbers 0 through 9'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[:blank:]** : Spaces and tabs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[:cntrl:]** : Control characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[:lower:]** : Lowercase letters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[:upper:]** : Uppercase letters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[:punct:]** : Punctuation characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[:space:]** : Space characters, including space, tab, newline, vertical tab,
    form feed, and carriage return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Character classes must be enclosed inside bracket expressions – for example,
    **[[:alpha:]]** .
  prefs: []
  type: TYPE_NORMAL
- en: Character classes are a time-saving shorthand that greatly simplifies the process
    of creating regex.
  prefs: []
  type: TYPE_NORMAL
- en: Flags – modifying your search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Regex allows you to modify your search with flags. These are usually single
    letters that change how the regex engine interprets your pattern. Here are some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**i** : Makes the search case-insensitive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**g** : Performs a global search (finds all matches rather than stopping after
    the first match)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**m** : Multiline mode (changes the behavior of **^** and **$** to match the
    start and end of lines rather than the whole string)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not an exhaustive list. See [https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html](https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html)
    for more information. These flags can be used alone or in combination, depending
    on the requirements of the regex operation. The way to apply these flags varies
    slightly between tools, but they are usually appended to the regex pattern. Since
    their use is tool-dependent, I’ll show you examples of how they can be used when
    I present practical examples later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the basics of regex, let’s review some examples showing
    how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Applying basic regex examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example simply uses **grep** to match on the letter **t** . By default,
    **grep** performs a global search. Therefore, the **g** flag isn’t necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – A basic grep on the t character](image/B22229_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – A basic grep on the t character
  prefs: []
  type: TYPE_NORMAL
- en: 'This example matches all vowels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – A pattern that matches all vowels](image/B22229_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – A pattern that matches all vowels
  prefs: []
  type: TYPE_NORMAL
- en: 'This example matches all consonants. Remember that the **^** symbol takes on
    a different meaning inside of brackets. This essentially means that it matches
    any character not in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – A pattern that matches all consonants](image/B22229_04_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – A pattern that matches all consonants
  prefs: []
  type: TYPE_NORMAL
- en: Now, I’ll show you a slightly more advanced example. Can you spot the difference
    between the following two examples?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Two patterns used to demonstrate a subtle difference](image/B22229_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Two patterns used to demonstrate a subtle difference
  prefs: []
  type: TYPE_NORMAL
- en: The first pattern matches **t** followed by zero or more characters that are
    not **w** . It’s important to note that ***** applies to the **[^w]** part of
    the pattern, allowing for any sequence of characters that does not start with
    **w** immediately following **t** . Therefore, it matches everything, including
    the spaces, starting with **t** in **told** , and continues through the end of
    the input.
  prefs: []
  type: TYPE_NORMAL
- en: The second pattern specifically looks for **t** followed by a single character
    that is not **w** , and then zero or more alphabetic characters. The inclusion
    of **[[:alpha:]]*** after **[^w]** means that after finding **t** followed by
    any non- **w** character, it matches only if the following characters are alphabetic.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples in *Figure 4* *.10* show a backslash character escaping the asterisk.
    A small number of characters have special meaning. The following characters must
    be escaped with a backslash: **[\^$.|?*+()** .'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the basics, let’s get a taste of some advanced regex
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced regex patterns and techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In regex, using **capture groups** is like putting a part of your pattern into
    a box. Everything inside this box is treated as a single unit. You can apply quantifiers
    to it, look for repetitions, or even extract information from it. In Bash, you
    use parentheses, **()** , to create these groups.
  prefs: []
  type: TYPE_NORMAL
- en: '**Grouping** isn’t just about treating parts of your pattern as a single unit;
    it’s also about capturing information. When you group part of a regex pattern,
    Bash remembers what text matched that part of the pattern. This is incredibly
    useful for extracting information from strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you’re working with log files and you want to extract timestamps.
    Your log lines might look something like this: **2023-04-01 12:00:00 Error: Something
    went wrong.** A regex pattern to match the timestamp could be **(\d{4}-\d{2}-\d{2}
    \d{2}:\d{2}:\d{2})** . Here, **\d** matches any digit, and **{n}** specifies how
    many times that element should repeat. The entire timestamp pattern is grouped,
    so you can extract it from the string easily.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some practical examples to help you solidify your understanding
    of capture groups.
  prefs: []
  type: TYPE_NORMAL
- en: Practical example – extracting data using regex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you’re tasked with extracting usernames and their corresponding email
    addresses from a list. The list looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You could use the following regex pattern to match and extract the usernames
    and email addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, **[a-zA-Z0-9_]+** matches one or more alphanumeric characters or underscores
    (the username), and **[a-zA-Z0-9_.]+@[a-zA-Z0-9_.]+** matches the email addresses.
    By grouping them, you can extract both the username and the email address separately.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say you have **I love apples and I love oranges** as a string
    and you want to find every instance of **I love** . In regex, you could write
    this pattern as **(I love)** . This tells Bash to treat **I love** as a single
    unit.
  prefs: []
  type: TYPE_NORMAL
- en: Regex grouping in Bash might seem complex at first glance, but once you understand
    the basics, it opens up a world of possibilities for string manipulation and data
    extraction. By breaking down patterns into manageable groups, you can simplify
    your scripts and make them more efficient. Remember, practice makes perfect. Start
    experimenting with regex grouping in your Bash scripts, and you’ll soon wonder
    how you ever managed without it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll expand on regex grouping by showing you how to use alternations
    to make your capture groups more powerful and flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing alternations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regex **alternation** is represented by the pipe symbol ( **|** ), which functions
    similarly to a logical OR. It allows you to specify multiple patterns within the
    same regex, offering a way to match one thing or another. Think of it as telling
    your script, “Hey, if you see this or that, consider it a match.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you’re writing a script that needs to process files with specific
    extensions. You’re interested in **.txt** and **.log** files but want to handle
    them using a single regex. Here’s how you could do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch04_regex_01.sh** file in this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this example provides the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, **(txt|log\)$** is the regex pattern. The pipe symbol, **|**
    , separates the two alternatives, **txt** and **log** , while the backslashes,
    **\** , are used to escape characters that have special meanings in regex. The
    dollar sign, **$** , ensures that the pattern matches the end of the string, preventing
    false positives on files such as **example.txt.bak** .
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why bother with alternation when you could just write
    separate conditions for each case. The answer lies in simplicity and efficiency.
    Using alternation, you can consolidate multiple conditions into a single line
    of code, making your scripts cleaner and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In scenarios where you’re matching against a long list of possibilities, alternation
    can significantly reduce the complexity of your code. Instead of having an unwieldy
    series of **if** statements or a cumbersome **case** statement, you can list all
    your options in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'While alternation is powerful, it’s essential to use it wisely to avoid pitfalls.
    Here are a couple of tips to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Be specific** : Regex patterns can sometimes match more than you intend.
    To prevent unexpected behavior, make your patterns as specific as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing** : Always test your regex patterns with various inputs to ensure
    they behave as expected. Tools such as **grep** and online regex testers ( [https://regex101.com](https://regex101.com)
    ) can be invaluable for this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regex alternations in Bash scripting are like having a secret weapon in your
    arsenal. They allow you to write more concise, readable, and maintainable code
    by simplifying complex pattern-matching logic. Whether you’re a seasoned scripter
    or just starting, mastering alternations will undoubtedly make your scripting
    journey smoother and more enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the key to effective scripting is not just knowing what tools are
    available but understanding how to use them wisely. With regex alternations, you’re
    well-equipped to tackle a wide range of string-matching challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a good grasp of how regex works, let’s explore some practical
    regex applications.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating practical applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, I’m using various variables and arrays that were introduced in previous
    chapters. Let’s put this into practice with the following Bash script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Introducing BASH_REMATCH in a practical application](image/B22229_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Introducing BASH_REMATCH in a practical application
  prefs: []
  type: TYPE_NORMAL
- en: This example code can be found in the **ch04_regex_02.sh** file in this chapter’s
    folder. In this script, I declared the **user_list** variable on *line 3* . On
    *line 6* , I declared the **pattern** variable. On *line 8* , I started a **while**
    loop that reads each line of data from the **$** **user_list** variable.
  prefs: []
  type: TYPE_NORMAL
- en: On *line 9* , I used the match operator, **=~** , to compare each line **($line**
    ) against our regex pattern ( **$pattern** ). These are referred to by the **$line**
    and **$pattern** variables, which are declared. When you use the match operator,
    the string on the left (represented by the **$line** variable) is matched against
    the regex pattern on the right. If the pattern matches, the expression returns
    true (0); otherwise, it returns false (1).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the pattern captures a username using the relevant capture group: **([a-zA-Z0-9_]+)**
    . Remember, a capture group consists of parenthesis, **()** , surrounding a regex.
    Inside the capture group, we have a bracket expression that will match all alphanumeric
    characters, plus an underscore to match usernames. The second capture group matches
    an email address.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a line matches, Bash populates an array called **BASH_REMATCH** with the
    captured groups. Here, **BASH_REMATCH[1]** contains the first captured group (the
    username), and **BASH_REMATCH[2]** contains the second group (the email address).
    Then, we print these out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Did you spot where I could have made the capture groups easier to read and write?
    The first capture group, **([a-zA-Z0-9_]+)** , could have been simplified to **([[:alnum:]_]+)**
    , and the second capture group, **([a-zA-Z0-9_.]+@[a-zA-Z0-9_.]+)** , could have
    been simplified to **([[alnum]_.]+@[[:alnum:]_.]+)** .
  prefs: []
  type: TYPE_NORMAL
- en: Matching IP addresses with grep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we’re going to look at a practical case involving a port scan
    to locate IP addresses with specific ports open. This is a common pentest task
    that is frequently used to produce a list of hosts to use with subsequent targeted
    scans, or for producing a list of affected hosts for a pentest finding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this involves scanning your local network, make sure you have permission
    to scan the network if you don’t own it. I’ve included a sample Nmap scan file
    from my lab for your convenience in this book’s GitHub repository: **test_nmap.gnmap**
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following Nmap command to scan the network, replacing the network address
    with one applicable to your network address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The scan command’s options specify greppable output, **-oG** , the output filename,
    **test_nmap.gnmap** , followed by the network address.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my scan, one line of the scan that’s output from the **test_nmap.gnmap**
    file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to identify any host IP addresses with open **http** or **https**
    service ports. Execute the following command in the same directory as the **test_nmap.gnmap**
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch04_regex_03.sh** file in this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command uses **grep** to search for a regex of the literal (no
    metacharacters) text, **/open/tcp//http** . The output of that command is the
    full line of text of every line that includes that string. The pipe character,
    **|** , simply connects the output ( **stdout** ) of the first process with the
    input ( **stdin** ) of the next process. Then, the **-oE** arguments are provided
    with the **grep** command. The **-o** option means to output only the matching
    text instead of the full line, and the **-E** option enables the extended regex
    feature. Finally, the regex pattern for an IP address ends the command. The following
    output is produced by this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The pipe character’s use to redirect output to the input of another process
    is a powerful feature that we’ll be using frequently in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Using handy grep flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While these **grep** flags are pretty simple, they’re also very handy. I use
    them frequently and want to share them with you.
  prefs: []
  type: TYPE_NORMAL
- en: Something that I frequently do on internal network pentest is use any credentials
    that I’ve obtained to enumerate file shares that can be accessed with those credentials.
    In this example, I’m using NetExec to check for SMB file shares that are accessible
    with the credentials I have. You can find NetExec at [https://github.com/Pennyw0rth/NetExec](https://github.com/Pennyw0rth/NetExec)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the output of a NetExec SMB file share enumeration
    scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – NetExec SMB share enumeration scan](image/B22229_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – NetExec SMB share enumeration scan
  prefs: []
  type: TYPE_NORMAL
- en: The scan output was saved to a file, **nxc.log** . Let’s imagine that I’ve run
    this scan on a large network with hundreds or even thousands of hosts and I want
    to focus on finding those shares where I can either read or write to the share,
    but I don’t want to see any of the **IPC$** or **PRINT$** shares.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are regex patterns that could reasonably work here to match a combination
    of **READ** / **WRITE** , we want to keep this simple so that we don’t have to
    refer to our notes. The following command can accomplish this goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Our grep flags simplify the task](image/B22229_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Our grep flags simplify the task
  prefs: []
  type: TYPE_NORMAL
- en: 'This example code can be found in the **ch04_regex_04.sh** file in this chapter’s
    folder. Let’s break down the sequence of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cat nxc.log** : This prints the output of the **nxc.log** file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**|** : This connects the output of the **cat** command to the input of the
    **grep** command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**grep -e READ -e WRITE** : The **grep** **-e** flag specifies a pattern. More
    than one pattern can be used if you include additional **-e** flags. This will
    match if either or both of the words are found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**grep -v …** : The **grep** **-v** flag means invert the match. This is similar
    to a logical **NOT** expression. In other words, filter out anything that matches
    this expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will use these patterns frequently in your pentest career.
  prefs: []
  type: TYPE_NORMAL
- en: Redacting IP addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the following example demonstrates redacting IP addresses using the **sed**
    (stream editor) command, it can be adapted to other cases of mass editing text
    in a file or input stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s imagine that you want to redact the IP addresses in the **test_nmap.gnmap**
    file before you share it with someone. Again, we’ll use the regex for an IP address.
    However, this time, we’ll pipe the output to **sed** and redact all IP addresses.
    Run the following command in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch04_regex_05.sh** file in this chapter’s
    folder. The output should show that every IP address in the file has been redacted.
  prefs: []
  type: TYPE_NORMAL
- en: So, what does this **sed** command do?
  prefs: []
  type: TYPE_NORMAL
- en: The **-E** option enables extended regex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command after **sed** is enclosed in single quotes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the **sed** command and arguments, you’ll see a pattern similar to **'s/MATCH/REPLACE/g'**
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **s** option means search for anything (literal text or regex) between the
    next **/** characters (the **MATCH** text).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace the matched text with the pattern between the next set of slash ( **/**
    ) characters (the **REPLACE** text).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **g** flag means to make it a **global** search and replace every occurrence.
    Otherwise, if the regex or literal string was matched twice on the same line,
    it would only perform the substitution on the first match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we didn’t edit the original file in place. We only edited
    the text output to the screen. There are two ways we could have edited and saved
    the text: by including the **sed -i** flag or by redirecting the output to a file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first case, edit the file in place by adding the **sed -** **i** flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This example code can be found in the **ch04_regex_06.sh** file in this chapter’s
    folder. The other option omits the **-i** flag. It will preserve the original
    file and redirect the edited text to a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This example code can be found in the **ch04_regex_07.sh** file in this chapter’s
    folder. The preceding command uses the **>** character to redirect the output
    to the filename that follows.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When using the **>** character to redirect output ( **stdout** ) to a file,
    it will overwrite the file if it exists. To append to an existing file instead
    of overwriting it, utilize **>>** in the command.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s examine using **awk** for regex matching. Awk is much more than
    just a tool for regex; it’s a full-fledged programming language. Where it shines
    is when you’re sifting through tabular data (columns, tab, and comma-separated
    data). Before learning awk, I mistakenly believed it to be too complex and I would
    chain together multiple tools to do the same job, ultimately putting in more work
    than I would if I just used awk. I’ll be a bit brief in this chapter and stick
    to a few quick examples because we’ll be going more in depth in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Awk programs can be a single line for quick one-off scripts, though they can
    be used in files for more complex use cases. The format of a one-line awk script
    is **awk 'pattern {action}'** . Either **pattern** or **action** may be omitted,
    but not both.
  prefs: []
  type: TYPE_NORMAL
- en: The default field separator is any whitespace, such as spaces or tabs. Multiple
    whitespace characters are treated as a single unit. This is very helpful as I
    used to use **tr -s ' '** to *squeeze* or combine multiple spaces into one before
    learning awk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into our first awk example, let’s take a minute to understand
    common awk terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Record** : Each line of an input file is referred to as a record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Field** : Each column is a field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$n** : Each field (column). The whole record (line) is **$0** , the first
    field is **$1** , and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$NF** : The number of fields in a record. It can also be used to refer to
    the last field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$NR** : The number of records so far.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-F** : A field separator; this is a space by default. Remember, any number
    of consecutive spaces are combined. So, if the first two fields are separated
    by one or multiple spaces, **$1** and **$2** still refer to the first and second
    fields (columns).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following figure, you can see the output of the **ps -ef** command on
    my system. This is the data I’ll be using in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – System processes are shown when using the ps command](image/B22229_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – System processes are shown when using the ps command
  prefs: []
  type: TYPE_NORMAL
- en: 'In our first awk example, I’m simply going to print each record ( **line**
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Printing the whole record using $0](image/B22229_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Printing the whole record using $0
  prefs: []
  type: TYPE_NORMAL
- en: This example code can be found in the **ch04_regex_08.sh** file in this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’re going to look at a more advanced example. In the following figure,
    I’m using a pattern and action. This example will match any process with a UID
    of **author** and print the CMD ( **$8** , or the 8 th field):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Printing the CMD of any process owned by author](image/B22229_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Printing the CMD of any process owned by author
  prefs: []
  type: TYPE_NORMAL
- en: This example code can be found in the **ch04_regex_09.sh** file in this chapter’s
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our final awk example, we’re going to examine how to use regex and print
    the output with a custom separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Using a regex and printing the custom output with awk](image/B22229_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Using a regex and printing the custom output with awk
  prefs: []
  type: TYPE_NORMAL
- en: This example code can be found in the **ch04_regex_10.sh** file in this chapter’s
    folder. In the preceding example, the regex in the pattern matches anything in
    the eighth field that starts with **[irq/** , followed by exactly two digits,
    followed by **-pciehp]** . For any matching records, the action prints the first
    and eighth fields, separated by **--->** instead of the default space.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve only scratched the surface of how to use awk. However, the concepts demonstrated
    here will solve the most common scripting tasks. We’ll explore this subject more
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Regex tips and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following tips will help guide you through creating complex regex patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start small** : Begin with simple patterns and gradually introduce more complexity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Practice** : Use online regex testers to experiment with different patterns
    and flags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Break it down** : When faced with a complex pattern, break it down into smaller
    parts to understand each component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refer to documentation** : Keep a cheat sheet or reference guide handy until
    you’re more comfortable with common patterns and metacharacters. While there are
    plenty of regex cheat sheets to be found online, I suggest that you make your
    own while reading this book and experimenting. I find that the act of making notes
    helps me commit difficult concepts to memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided an introduction to regex, followed by more advanced
    topics, including metacharacters and capture groups. Finally, we learned how to
    apply these techniques to real-world applications of Bash scripting that you will
    find useful for pentest ing.
  prefs: []
  type: TYPE_NORMAL
- en: Regex doesn’t have to be intimidating. With a basic understanding of characters,
    metacharacters, and flags, you’re well on your way to harnessing their power.
    Whether you’re editing text, analyzing data, or validating user input, regex can
    be an invaluable tool in your toolkit. Remember, like any skill, proficiency comes
    with practice. So, dive in, start experimenting, and soon they will become easy
    with a bit of practice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll combine the regex concepts we learned in this chapter
    with common text parsing tools so that we can focus on common cybersecurity and
    pentest ing tasks.
  prefs: []
  type: TYPE_NORMAL
