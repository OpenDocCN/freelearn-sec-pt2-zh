- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions and Script Organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about regular expressions and how to apply
    them in practical applications. This chapter builds on this by teaching you how
    to apply everything you’ve learned in previous chapters to organize your code
    into functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functions are a fundamental concept in Bash scripting that allow you to organize
    your code into reusable and modular units. By mastering functions, you can write
    more efficient, maintainable, and readable scripts. This chapter will dive deep
    into the world of **Bash functions** , exploring their syntax, usage, and advanced
    techniques. We’ll also discuss how functions can help you structure your scripts
    and simplify common pentesting tasks. Lastly, we will compare and contrast functions
    and aliases.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have a solid understanding of how to define
    and use functions in your Bash scripts. You’ll learn how to pass arguments to
    functions, understand variable scope and lifetime within functions, and explore
    advanced techniques such as recursion and callbacks. Most importantly, you’ll
    see how functions can help you write cleaner, more organized scripts that are
    easier to maintain and extend, ultimately streamlining your pentesting workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Bash functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing arguments to functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scope and lifetime of variables in functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced function techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions versus aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter05](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter05)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Bash functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash functions are an essential tool for anyone who works with the Bash shell
    on Linux systems. They allow you to encapsulate reusable pieces of code into named,
    parameterized units that can be called from anywhere in your Bash scripts or interactive
    shell sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore some of the key reasons why Bash functions are so important and
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Code reuse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the biggest benefits of Bash functions is that they promote code reuse.
    If you find yourself writing the same or very similar code over and over in your
    Bash scripts, that’s a good sign that you should extract that code into a reusable
    function!
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s say many of your scripts need to parse command-line arguments
    in a consistent way. Rather than copying and pasting the argument parsing logic
    into each script, you could define a **parse_args** function (the code can be
    found in this chapter’s folder in the book’s GitHub repository as **ch05_parse_args.sh**
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, any script that needs to parse arguments in this way can simply call the
    **parse_args** function. This makes your code more concise, readable, and maintainable.
    If you ever need to update the argument parsing logic, you only have to do it
    in one place.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if you don’t understand what the preceding function is doing. You’ll
    understand it soon enough.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bash functions allow you to break your scripts down into smaller, self-contained,
    and more manageable pieces. Each function should ideally do one specific task
    and do it well.
  prefs: []
  type: TYPE_NORMAL
- en: By decomposing your scripts into modular functions, your code becomes easier
    to understand, debug, and maintain. It’s much simpler to troubleshoot a specific
    function than a monolithic script with hundreds or thousands of lines.
  prefs: []
  type: TYPE_NORMAL
- en: Well-designed functions also make your scripts more readable by giving semantic
    names to chunks of code. For example, a script full of calls such as **fetch_data**
    , **parse_response** , and **update_database** is much easier to follow than a
    script with all those operations intermixed.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions provide **encapsulation** , meaning they create a separate scope for
    variables and other resources. Any variables defined inside a function are local
    to that function by default. They don’t pollute the global namespace or conflict
    with variables in other parts of your script.
  prefs: []
  type: TYPE_NORMAL
- en: This encapsulation makes functions safer and less error-prone than just using
    global variables everywhere. It prevents accidental naming collisions and makes
    it clear which variables are used where.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, sometimes you do want to share variables between functions or with
    the main script. Bash allows this by declaring variables with the **global** keyword
    or by using **upvar-style** references. But these techniques should be used sparingly.
    In general, it’s best to keep functions as independent and self-contained as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another major benefit of Bash functions is that they make your code more testable.
    It’s much easier to write unit tests for individual functions than for a whole
    script.
  prefs: []
  type: TYPE_NORMAL
- en: You can write test cases that call your functions with different arguments and
    verify that they produce the expected output or side effects. This gives you more
    confidence that your code is correct and helps prevent regressions when you make
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: There are several popular frameworks for unit testing Bash code, such as **Bats**
    and **shUnit2** . These allow you to write concise, readable test cases in a familiar
    **xUnit** style.
  prefs: []
  type: TYPE_NORMAL
- en: Without functions, your Bash code is much harder to test in an automated fashion.
    You might have to resort to clunky end-to-end tests that invoke your whole script
    with different arguments. These tests are slower, more brittle, and harder to
    maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, using Bash functions can also improve the performance of your scripts,
    especially if you’re calling the same code multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: When you call a function, Bash doesn’t have to spawn a new process or reparse
    the function definition each time. The function code is already loaded in memory,
    so the overhead of calling a function is very low.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, if you put the same code in a separate script and invoke it with
    **bash myscript.sh** , Bash has to fork a new process and parse the script from
    disk each time. For code that’s called in a tight loop, this overhead can really
    add up.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the performance gains of functions are usually pretty small in absolute
    terms. Spawning processes in Bash are already fast. But in scripts that prioritize
    performance, using functions instead of separate scripts can give you a little
    extra boost.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of why functions are useful, let’s explore
    how to define and call a function.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and calling a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define a function in Bash, you use the following syntax (the code can be
    found in this chapter’s folder in the book’s GitHub repository as **ch05_function_
    definition.sh** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the **function** keyword before the function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the components of a function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '**function_name** : This is the name you give to your function. It should be
    descriptive and follow the same naming conventions as variables (alphanumeric
    characters and underscores, starting with a letter or underscore).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**()** : The parentheses after the function name are required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**{** and **}** : The curly braces enclose the body of the function, where
    you put the commands that make up the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a simple example of a function that prints a greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following provides an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**greet** is the name of the function. The function name must be followed by
    parentheses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The curly braces, **{}** , enclose the body of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **echo** command inside the function body prints the string **Hello, world!**
    to the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you’ve defined a function, you can call it by simply using its name followed
    by any arguments (if required). Here’s an example with a function definition for
    th e **greet** function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is how we call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be found in the book’s GitHub repository as **ch05_greet.sh**
    , and we can explain it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **greet** function is defined with the **echo** command, which prints **Hello,
    world!** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To call the function, we simply use its name, **greet** , on a new line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the script is executed, the **greet** function is called, and the output
    **Hello, world!** is printed to the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can call a function multiple times within your script.
  prefs: []
  type: TYPE_NORMAL
- en: Having learned how to declare and call functions, let’s move on to the next
    section where you’ll learn all about passing arguments to functions and how to
    apply this to practical applications.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash functions are a powerful tool for automating repetitive tasks and creating
    reusable code blocks. They allow you to encapsulate a series of commands into
    a single, named unit that can be called from anywhere in your script. However,
    functions become even more versatile and flexible when you can pass arguments
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to Bash functions is a technique that enables you to provide
    dynamic input to your functions, making them more adaptable and reusable across
    different scenarios. By accepting arguments, functions can perform actions based
    on the specific values passed to them, rather than relying on hardcoded or predefined
    values within the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few reasons why passing arguments to Bash functions is beneficial:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility** : Functions that accept arguments can be used in a variety
    of contexts. Instead of creating multiple functions with slight variations, you
    can create a single function that adapts its behavior based on the arguments provided.
    This promotes code reuse and reduces duplication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameterization** : Arguments allow you to parameterize your functions,
    meaning you can pass different values to the function to control its behavior.
    This enables you to customize the function’s actions based on specific requirements
    or inputs, making it more versatile and applicable to different situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modularity** : By accepting arguments, functions become self-contained modules
    that can operate independently of the surrounding code. They can be easily moved
    or reused in other scripts without requiring significant modifications. This modularity
    enhances code organization and maintainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readability** : When functions accept arguments, it makes the code more readable
    and self-explanatory. The arguments provide a clear indication of what values
    the function expects and how it will use them. This improves code comprehension
    and makes it easier for other developers to understand and maintain the script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency** : Passing arguments to functions can help optimize your code
    by avoiding the need for global variables or complex logic within the function.
    Instead of relying on external variables, the function can receive the necessary
    data directly through its arguments, making the code more efficient and focused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this tutorial, we will explore the different ways to pass arguments
    to Bash functions and demonstrate how to effectively utilize this technique in
    your scripts. By mastering the art of passing arguments, you’ll be able to create
    more flexible, reusable, and maintainable Bash functions that can greatly enhance
    your scripting capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s dive in and learn how to harness the power of passing arguments to
    Bash functions!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a basic example of a Bash function that accepts arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this script and call the **greet** function, it will output the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Bash functions can accept multiple arguments. Let’s modify the previous example
    to handle multiple arguments (this code can be found in the book’s GitHub repository
    as **ch05_greet_args.sh** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following provides an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: The **greet** function now expects two arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the function, **$1** refers to the first argument, and **$2** refers
    to the second argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **echo** command is updated to include both arguments in the greeting message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We call the **greet** function with two arguments: **John** and **Doe** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Having learned the basics of passing arguments, let’s move on to learn more
    advanced use cases for passing arguments to functions.
  prefs: []
  type: TYPE_NORMAL
- en: Handling a variable number of arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you may want to create a function that can handle a variable number
    of arguments. Bash provides a special variable, **$@** , that represents all the
    arguments passed to the function. Here’s an example where we use this concept
    to loop through usernames (this code can be found in the book’s GitHub repository
    a s **ch05_variable_args.sh** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following provides an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: The **print_arguments** function is defined to handle a variable number of arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the function, a **for** loop is used to iterate over all the arguments
    passed to the function using **$@** , which represents the array of arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **echo** command is used to print each argument on a separate line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We call the **print_arguments** function with three arguments: **apple** ,
    **banana** , and **cherry** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'While the **$@** variable represents the array of arguments passed to a script
    or function, it’s also helpful to know about the **$#** variable, which represents
    the count of arguments. You should always ensure that the user has entered the
    correct number of arguments if the script or function requires them. This is shown
    in the following code, and it can also be found in the book’s GitHub reposit ory
    as **ch05_count_args.sh** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This **if** statement checks that the number of arguments is not equal to **2**
    . If the test is true, it prints a helpful usage statement and exits. The **$0**
    variable represents the name of the script.
  prefs: []
  type: TYPE_NORMAL
- en: Default values for arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can assign default values to function arguments in case they are not provided
    when calling the function. Here’s an example (this code can be found in the book’s
    GitHub repositor y as **ch05_default_args.sh** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following provides an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: The **greet** function is defined with one argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the function, a local variable, **name** , is assigned the value of
    the first argument using **${1:-"Guest"}** . If the first argument is not provided,
    it defaults to **Guest** . This is broken down further here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local variables will be explained later in this chapter. Basically, a variable
    declared as local is valid only while the function is executing. Once the local
    variable returns control back to the main script or function that called it, the
    local variable can no longer be referenced.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1** refers to the first argument ( **$1** ). The second argument ( **$2**
    ) would be referred to as **2** .'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**:-** is the default value operator.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Guest** is the default value.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The **echo** command is used to print the greeting message with the **name**
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We call the **greet** function twice: once without an argument and once with
    the argument **John** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: By including a default value for a function variable, you can write less code
    to cover cases when no parameter is passed to your function.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up a thorough review of passing arguments to functions. In the next
    section, you’ll discover why it’s important to understand the scope and lifetime
    of variables in your Bash code.
  prefs: []
  type: TYPE_NORMAL
- en: The scope and lifetime of variables in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing Bash scripts, it’s important to understand how variable scope and
    lifetime work, especially when dealing with functions. Properly managing variables
    can help avoid bugs, make your code more maintainable, and prevent unintended
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Variable scope** refers to the visibility and accessibility of a variable
    within a script. It determines where a variable can be accessed and modified.
    Understanding variable scope is crucial for writing clean, modular, and reusable
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lifetime** , on the other hand, refers to how long a variable exists and
    retains its value during the execution of a script. Variables with different lifetimes
    can have different implications on resource usage and data persistence.'
  prefs: []
  type: TYPE_NORMAL
- en: Properly managing variable scope and lifetime becomes particularly important
    when working with functions. Functions allow you to encapsulate reusable code
    blocks, but they also introduce their own scope. Understanding how variables behave
    within and across functions is essential for writing robust and maintainable Bash
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, we’ll explore Bash variable scope and lifetime within functions,
    using examples to illustrate variable lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, variables declared in a Bash script have global scope, meaning they
    can be accessed and modified from anywhere within the script, including inside
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example (this code can be found in the book’s GitHub repository as
    **ch05_global_var.sh** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following provides an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 3** : We declare a global variable, **name** , and assign it the value
    **John** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 5-7** : We define a function called **greet** that prints a greeting
    message using the **name** variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 9** : We call the **greet** function, which accesses the global **name**
    variable and prints **Hello, John!** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 10** : We print the value of the **name** variable, which is still accessible
    outside the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, the **name** variable is global and can be accessed both inside
    the **greet** function and in the main script.
  prefs: []
  type: TYPE_NORMAL
- en: Local variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To limit the scope of a variable to a specific function, you can declare it
    as a local variable using the **local** keyword. Local variables are only accessible
    within the function where they are declared. If the **local** keyword is not used,
    then the variable is global. Here’s an example (this code is found in the book’s
    Gi tHub repository as **ch05_local_var.sh** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following provides an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 3-6** : We define a function called **greet** that declares a local
    variable, **name** , using the **local** keyword, and assigns it the value **Alice**
    . The **name** variable is only accessible within the **greet** function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 5** : We print a greeting message using the local **name** variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 8** : We call the **greet** function, which prints **Hello, Alice!**
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 9** : We attempt to print the value of the **name** variable outside
    the function, but it is not accessible, resulting in an empty output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, the **name** variable is local to the **greet** function and
    cannot be accessed outside of it. Attempting to use **$name** outside the function
    results in an empty value.
  prefs: []
  type: TYPE_NORMAL
- en: Variable lifetime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The lifetime of a variable depends on its scope. Global variables have a lifetime
    that spans the entire script execution, while local variables have a lifetime
    limited to the function in which they are declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that demonstrates variable lifetime (this code is found in
    the book’s GitH ub repository as **ch05_var_lifetime.sh** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following provides an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 3** : We declare a global variable, **global_var** , and assign it the
    value **I''m global** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 5-10** : We define a function called **my_function** that declares
    a local variable, **local_var** , and assigns it the value **I''m local** . Inside
    the function, we print the values of both the global and local variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 12** : We call the **my_function** function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 14-16** : Outside the function, we print the values of the global and
    local variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, the global variable, **global_var** , is accessible both inside
    and outside the function, demonstrating its lifetime throughout the script. On
    the other hand, the local variable, **local_var** , is only accessible within
    the **my_function** function and has no value outside of it.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying global variables inside functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to modify a global variable inside a function, you can do so by
    referencing the variable without any special declaration. Because Bash lacks a
    **global** keyword, any variable that lacks the **local** keyword is effectively
    global. It’s generally recommended to minimize the modification of global variables
    inside functions to avoid unexpected side effects and maintain code clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that modifies a global variable inside a function (this code
    can be found in the book’s GitHub repository as **ch05_modify_global_var.sh**
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following provides an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 3** : We declare a global variable, **count** , and initialize it to
    **0** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 5-7** : We define a function called **increment** that modifies the
    global **count** variable by incrementing its value by **1** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 9** : We print the value of **count** before calling the **increment**
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 10** : We call the **increment** function, which modifies the global
    **count** variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 11** : We print the value of **count** after calling the **increment**
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, the **increment** function directly modifies the global **count**
    variable, incrementing its value by **1** . The modification is reflected outside
    the function, as evidenced by the output.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding variable scope and lifetime is crucial for writing clean, maintainable,
    and bug-free Bash scripts. Global variables have a scope that spans the entire
    script, while local variables are limited to the function in which they are declared.
    The lifetime of a variable depends on its scope, with global variables existing
    throughout the script execution and local variables existing only within their
    respective functions.
  prefs: []
  type: TYPE_NORMAL
- en: By properly managing variable scope and lifetime, you can create modular and
    reusable code, avoid naming conflicts, and maintain better control over your script’s
    behavior. It’s generally recommended to use local variables within functions to
    encapsulate data and prevent unintended side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to be cautious when modifying global variables inside functions, as
    it can lead to unexpected behavior and make your code harder to reason about.
    Whenever possible, aim for a clear separation of concerns and minimize the reliance
    on global variables.
  prefs: []
  type: TYPE_NORMAL
- en: With a solid understanding of Bash variable scope and lifetime, you’ll be well
    equipped to write more robust and maintainable scripts, making your Bash programming
    experience more enjoyable and productive.
  prefs: []
  type: TYPE_NORMAL
- en: Having gained a thorough understanding of functions, in the next section, we’ll
    build on that knowledge to explore advanced function techniques that I’m confident
    you’ll find useful in your Bash scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced function techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll explore some advanced techniques for working with Bash
    functions, including return values and recursive functions. We’ll provide code
    examples and thorough explanations to help you master these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Function return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Bash, functions don’t return values in the same way that functions in most
    programming languages do. Instead, they return an exit status, also known as a
    **return code** , which is an integer where **0** typically indicates success
    and any non-zero value indicates an error or some type of failure.
  prefs: []
  type: TYPE_NORMAL
- en: Returning an exit status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Bash function returns an exit status using the **return** command. By default,
    a Bash function will return the exit status of the last command executed within
    the function. Here’s a basic example (this code is provided in the book’s GitHub
    repository as **ch05_exit_status.sh** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the **check_file** function attempts to list a file provided
    as an argument to the function. The **$?** special variable captures the exit
    status of the last command executed, which in this case is **ls** . After the
    function is called, **$?** will contain the return status of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explicitly set a return value from a function using the **return**
    command followed by an integer. Here’s an example (this code is provided in the
    book’s G itHub repository as **ch05_explicit_exit_status.sh** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding script, **is_even** checks whether a number is even. If the
    number is even, it returns **0** ; otherwise, it returns **1** . The result of
    the function call is then checked to print whether the number is even or odd.
  prefs: []
  type: TYPE_NORMAL
- en: Using output instead of return codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you need to capture output from a function rather than just an exit status,
    you can use command substitution. Here’s an example of setting a return value
    by using both a variable and the **echo** command (this code is provided in the
    book’s GitHub repository as **ch05_command_substitution.sh** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following provides an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we define a function called **square** that takes one argument
    and calculates its square.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the function, we perform the calculation **$1 * $1** and assign the result
    to a local variable called **result** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The math expression **$1 * $1** is enclosed in Bash shell arithmetic expansion
    by enclosing the factors as **$(($1 * $** **1))** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then use **echo** to output the value of **result** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To capture the return value of the function, we use command substitution, **$()**
    , when calling the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We assign the output of **square 5** to a variable called **squared** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we print a message that includes the value of **squared** , which is
    **25** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For what you have learned, it’s important that you remember the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exit status range** : The exit status should be an integer from 0 to 255.
    Any value outside this range might wrap around (e.g., 256 becomes 0).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using output** : Functions can output data to **stdout** , which can be captured
    with command substitution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return early** : You can use multiple return statements in a function to
    exit the function under different conditions early.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having gained a thorough knowledge of using functions in Bash code, let’s take
    a brief look at how to use them recursively in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bash supports **recursive functions** , which are functions that call themselves.
    Recursive functions are useful for solving problems that can be divided into smaller
    subproblems. Here’s an example that calculates the factorial of a number using
    recursion (this code is provided in the bo ok’s GitHub repository as **ch05_recursive_function.sh**
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following provides an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we define a function called **factorial** that takes one argument,
    the number for which we want to calculate the factorial. The function uses an
    **if** statement to check whether the argument is equal to **0** . If it is, the
    function returns **1** , which is the base case of the recursion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the argument is not **0** , the function calls itself with the argument decremented
    by **1** . This recursive call continues until the base case is reached. The result
    of each recursive call is stored in a local variable called **prev** . Finally,
    the function multiplies the current argument by the result of the previous recursive
    call and returns the product using **echo** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use the **factorial** function, we call it with an argument of **5** and
    capture the result using command substitution. We assign the result to a variable
    called **result** and print a message that includes the factorial of **5** , which
    is **120** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One example of a good use case for a recursive function is when performing file
    and directory enumeration in a web application. You would want to create an array
    of discovered directories and begin anew inside each directory to discover files.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions can be powerful, but they can also be difficult to understand
    and debug. It’s important to ensure that the recursive function has a well-defined
    base case to prevent infinite recursion and to carefully consider the termination
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll continue building on everything you’ve learned in
    this chapter by learning how to import functions to reduce the amount of code
    you write and reuse code.
  prefs: []
  type: TYPE_NORMAL
- en: Importing functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I previously stated that one of the nice features of Bash functions is code
    reuse. You can solve a problem once by writing a function and calling that function
    repeatedly. In programmer lingo, that’s referred to as **don’t repeat yourself**
    , or **DRY** . Now, let’s take that a step further.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine for a moment that you previously solved a problem by implementing
    a function that you can call as many times as you need. What happens when you
    find the need to use that function in a new Bash script? Do you go searching through
    your scripts to find that function and copy and paste it into your new script?
    This is really not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Make it a habit to start putting your functions into one script, such as a library
    or module. When you need to use a function that you’ve previously defined, simply
    *source* it before you call that function in your new script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code can be found in this chapter’s folder in the book’s
    GitHub repository as **ch05_importing_funcs_1.sh** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, source the script from another script before you call the function (
    **ch05_importing_funcs_2.sh** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You should be aware that sourcing a file may add a very small amount of time
    to the startup of the script that sources another script since it has to load
    the sourced script into memory. It has to do this one time only. If you use more
    than one function from a function library file, you source it only one time since
    the whole script is loaded into memory when it’s sourced.
  prefs: []
  type: TYPE_NORMAL
- en: Having learned how to use functions, from basics through to advanced usage,
    I want to briefly discuss the differences and use cases to help you choose between
    functions and aliases, in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Functions versus aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are essential building blocks in programming that allow developers
    to encapsulate a set of instructions into a reusable block of code. By defining
    functions, programmers can streamline their code, improve readability, and promote
    code reusability. Functions are designed to perform specific tasks when called
    upon, making it easier to manage and maintain code bases. They are a fundamental
    concept in programming languages such as Python, JavaScript, and Java, enabling
    developers to break down complex problems into smaller, more manageable components.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aliases** , on the other hand, serve a different purpose in programming.
    An alias is a symbolic name given to an entity, such as a variable, function,
    or command. Aliases provide a way to create shortcuts or alternative names for
    existing elements in a program. They can help simplify the syntax of commands
    or make code more concise and easier to understand. In Unix-based systems, aliases
    are commonly used to define custom commands or shorten lengthy commands for convenience.'
  prefs: []
  type: TYPE_NORMAL
- en: While functions and aliases both play important roles in programming, they serve
    distinct purposes and have different applications. Functions are primarily used
    to encapsulate a set of instructions into a reusable block of code, promoting
    modularity and code organization. On the other hand, aliases are used to create
    symbolic names for entities, providing shortcuts or alternative names for convenience.
    Understanding the differences between functions and aliases can help you leverage
    these programming concepts to improve code quality and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored functions in depth, I want to introduce you to how you
    can use functions outside of scripts to simplify your pentesting workflow. Aliases
    are great for simplifying a workflow because they allow you to create a named
    command you can enter to replace more complicated commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I have an alias in my **~/.bashrc** file that simplifies a very
    long, complex command to run a Docker container that provides information about
    a web application. I run this command at the beginning of every web application
    pentest to give me information related to the frameworks in use by the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That’s a lot to remember, isn’t it?! Thankfully, we have aliases for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: While aliases are very handy, they lack one crucial feature that we need; they
    don’t accept parameters such as **$1 $2 $3** . In the preceding alias, when we
    enter the alias in our terminal, anything appended after the alias name is included
    with the command when Bash expands the alias to the full command and executes
    it in the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, Bash expands the **zapit www.example.com** command to the **Docker**
    **run** command shown previously with **www.example.com** appended to it. What
    if we wanted to run a command that requires multiple parameters in a particular
    order, so we can’t simply append them after the alias name? This is where functions
    are helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use generating shellcode with **msfvenom** as an example. **msfvenom**
    is a command that’s included with the **Metasploit Framework** to generate shellcode
    in various formats. This tool is used frequently in pentesting and exploit development:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is provided in the book’s GitHub repository as **ch05_gen_shellcode.sh**
    . We can explain it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a function named **gen_shellcode** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number of arguments equals **0** , print the usage and exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the **msfvenom** command, the first argument, **$1** , is inserted as the
    payload, after **-p** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **LHOST=$(ip -o -4 a show tun0 | awk '{print $4}'** code gets your IP address
    for the **tun0** network interface and inserts it in place of **$()** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument, **$2** , is assigned to the **LPORT** variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third argument, **$3** , is for the output format **-** **f** argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, add this code at the end of your **~/.bashrc** file and you will be
    able to use this function any time you need to generate shellcode with **msfvenom**
    . If you forget which options are required, simply enter **gen_shellcode** without
    arguments and press the Enter key and it will print the usage example for you.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, aliases are expanded to represent the command inside the quotes,
    but you’re limited to appending extra arguments after the alias name. With functions,
    there are no limitations. In addition to the great value you get from using functions
    in your scripts, any valid Bash function code can be placed in your **.bashrc**
    file to call on the command line with arguments that are interpolated in the function
    code on execution. Imagine the possibilities for creating automation for your
    pentesting workflow! We’ll be diving into that topic in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dove deep into the world of Bash functions and how they
    can revolutionize your scripting game. By mastering functions, you’ll write cleaner,
    more organized, and more efficient scripts that save you time and headaches.
  prefs: []
  type: TYPE_NORMAL
- en: We started with the basics, understanding what functions are and why they’re
    so helpful. Then we got into the nitty-gritty of passing arguments to functions,
    making them flexible and reusable. We explored the scope and lifetime of variables
    inside functions, so you know exactly what’s happening under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Things got really exciting when we hit the advanced techniques. You learned
    how to use recursion to elegantly solve complex problems and how to use callbacks
    to make your functions even more powerful. Finally, we compared functions to aliases
    and showed how functions are the clear winner for pentesting workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have some serious tools in your scripting toolbox. You can now write
    modular, organized scripts that are easy to read, debug, and maintain. And, most
    importantly, you can use functions to streamline your pentesting process, saving
    you valuable time and effort. So, go forth and script like a pro!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore using Bash commands for networking.
  prefs: []
  type: TYPE_NORMAL
