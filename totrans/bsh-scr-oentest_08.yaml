- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parallel Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore the powerful capabilities of **parallel processing**
    within the realm of Bash scripting. As tasks become more data-intensive and time-sensitive,
    leveraging parallelism can significantly enhance the efficiency and effectiveness
    of Bash scripts. This chapter is designed to progressively build your understanding
    and skills in parallel processing, starting with fundamental concepts and advancing
    to practical applications and best practices.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a comprehensive understanding of how
    to harness the power of parallel processing in Bash scripts, enabling you to handle
    tasks more efficiently and effectively in various cybersecurity and data processing
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding parallel processing in Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing basic parallel execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced parallel processing with **xargs** and GNU parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical applications and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter07](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter07)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Understanding parallel processing in Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parallel processing in Bash involves executing multiple tasks simultaneously,
    rather than sequentially, to improve efficiency and reduce execution time. This
    concept is particularly useful in scenarios where tasks are independent of each
    other and can be performed concurrently. Understanding the foundational principles
    of parallel processing is crucial for effectively leveraging this technique in
    Bash scripting.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will cover the basics of parallel processing, including its benefits
    and drawbacks. So, let’s begin with understanding some of the key concepts of
    parallel processing, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Serial execution** : Tasks are executed one after another in a sequence.
    Each task must be completed before the next one begins. This approach is straightforward
    but can be time-consuming for large or complex tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel execution** : Multiple tasks are executed at the same time, independently
    of each other. This can significantly reduce the overall execution time, especially
    for tasks that can run concurrently without dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency versus parallelism** : Concurrency refers to the ability to handle
    multiple tasks by switching between them, giving the illusion that they’re running
    simultaneously. Parallelism involves actually running multiple tasks simultaneously,
    typically utilizing multiple CPU cores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Separate processes** : In Bash, parallel tasks are typically executed as
    separate processes. Each process runs independently, with its own memory space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Background processes** : Running tasks in the background allows the shell
    to execute other commands while the background task continues to run. This is
    a common technique for achieving parallelism in Bash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The benefits of parallel processing include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved performance** : By utilizing multiple processors or cores, parallel
    processing can speed up the execution of scripts, making them more efficient'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource utilization** : Parallel processing allows for better utilization
    of system resources, such as CPU and memory, by distributing the workload across
    multiple processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability** : Scripts that use parallel processing can handle larger datasets
    and more complex tasks without a linear increase in execution time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are drawbacks to parallel processing. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity** : Writing and debugging parallel scripts can be more complex
    than serial scripts due to the need for synchronization and coordination between
    tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource exhaustion** : Multiple processes may compete for the same resources
    (e.g., CPU, memory), which can lead to contention and reduced performance if not
    managed properly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error management** : Managing errors in parallel tasks can be challenging,
    as failures in one task may not immediately impact others, making it harder to
    detect and handle issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By understanding these fundamental concepts, you will be well-equipped to explore
    and implement parallel processing techniques in Bash, enhancing their scripts’
    performance and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing basic parallel execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, this chapter has been completely theoretical. This section will dive
    into the practical side and teach you how to implement basic parallel processing
    in Bash. Practical examples will be used to help you understand and learn this
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: In Bash scripting, the ability to run commands or scripts in the background
    is a fundamental aspect of parallel processing. When a process is sent to the
    background, it allows the user to continue other work in the foreground. This
    is especially useful in a cybersecurity context where certain tasks such as network
    scans or data monitoring need to run continuously without tying up the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to send a process to the background in Bash is by appending
    an ampersand ( **&** ) to the end of a command, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command starts pinging **google.com** and immediately returns the command
    prompt to the user, allowing further commands to be entered without waiting for
    the **ping** process to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a process is running in the background, it’s managed by the shell without
    any user interface. However, Bash provides several commands to manage these background
    processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**jobs** : Lists all current background processes running in the current shell
    session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fg** : Brings a background process to the foreground. You can specify a job
    using its number (e.g., **fg %1** brings the first job back to the foreground).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**bg** : Resumes a paused background process, keeping it in the background.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, imagine you started a script that captures network packets and
    sent it to the bac kground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can list this process with **jobs** , pause it with **kill -s STOP %1**
    , and resume it with **bg %1** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – An example of controlling jobs](image/B22229_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – An example of controlling jobs
  prefs: []
  type: TYPE_NORMAL
- en: 'Background processes are extremely useful in cybersecurity for tasks that are
    time-consuming and do not require immediate interaction, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Long-term monitoring** : Setting a network monitoring tool to run in the
    background to log traffic patterns or detect anomalies over time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated scripts** : Running custom scripts that periodically check system
    logs or scan directories for changes without blocking access to the terminal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a simple script that monitors the system logs for specific security
    events, running in the background. You can find the script in this chapter’s folder
    in the book’s GitHub repository as **ch07_backgr ound_1.sh** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This script filters the authentication log for failed login attempts and outputs
    the results to a temporary file, all while running in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'While background processing is a powerful tool, it should be used judiciously,
    keeping in mind the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitor resource usage** : Background processes consume system resources.
    Use tools such as **top** or **htop** to monitor resource usage and ensure that
    background tasks do not adversely affect system performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use nohup for unattended tasks** : If you start a background process and
    then log out, the process will terminate unless you use **nohup** to allow it
    to continue running: **$ nohup ./** **your-script.sh &** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling** : Redirect error messages to a file or a logging service
    to keep track of any issues that might occur during the execution of background
    processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using background processes effectively allows pentesters to perform multiple
    tasks simultaneously, enhancing productivity and efficiency. By understanding
    and implementing the techniques discussed, you can optimize your Bash scripts
    for parallel processing tasks, essential in the field of cybersecurity.
  prefs: []
  type: TYPE_NORMAL
- en: In Bash, you can parallelize loops by running iterations in the background using
    **&** , and then synchronizing them with **wait** . This method is particularly
    useful when the tasks within each iteration do not depend on the completion of
    others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a basic example that can be found in this chapter’s folder in the book’s
    GitHub repository as **ch07_backg round_2.sh** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, **sleep 1 &** simulates a task being processed in the background.
    The **wait** command is used after the loop to ensure that the script waits for
    all background processes to complete before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example script for scanning multiple IP addresses concurrently can be
    found in the book’s GitHub repository as **ch07_backg round_3.sh** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each **nmap** scan runs in the background, and **scan_$ip.txt** captures the
    output. Once all scans are initiated, **wait** ensures that the script only proceeds
    once all scans are complete.
  prefs: []
  type: TYPE_NORMAL
- en: Simple parallel loops with **&** and **wait** in Bash provide a straightforward
    way to implement parallel processing for repetitive tasks, particularly useful
    in cybersecurity for tasks such as network scanning or log processing.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we have been using very basic parallel processing using built-in
    Bash features. The next section will demonstrate how to use **xargs** and GNU
    parallel for more advanced parallel processing.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced parallel processing with xargs and GNU parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will jump ahead from the basic, and therefore, limited background
    processing you have seen thus far. You will learn more robust parallel processing
    with the more capable **xargs** and Gnu parallel to implement performance-critical
    Bash code.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing xargs for robust parallel processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **xargs** application is a powerful command-line utility in Linux. It is
    used to build and execute command lines from standard input. By default, **xargs**
    reads items from the standard input and executes the command specified, one or
    more times, with the input provided. This tool is particularly useful for handling
    a large number of arguments or for processing items in parallel to improve efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax of **xargs** is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, **xargs** takes the output of **echo** (which lists three filenames)
    and constructs a command to remove those files, executing **rm file1** **file2
    file3** .
  prefs: []
  type: TYPE_NORMAL
- en: One of the most powerful features of **xargs** is its ability to execute commands
    in parallel using the **-P** option, which specifies the number of processes to
    run simultaneously. This can significantly speed up operations that can be performed
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you have a list of files to compress. Instead of compressing them one
    by one, you can use **xargs** to process them in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what each part of this command does:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ls *.log** lists all **.log** files in the current directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xargs -P 4** tells **xargs** to use up to four parallel processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-I {}** is a placeholder for the argument from the input ( each filename)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gzip {}** compresses each file listed by **ls**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This command will compress up to four log files simultaneously, making the operation
    much faster than processing each file sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cybersecurity, **xargs** is extremely useful for parallelizing tasks such
    as scanning multiple hosts, analyzing large sets of log files, or executing commands
    across many systems. Here’s an example of using **xargs** for parallel network
    scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This command does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cat hosts.txt** reads a list of hostnames or IP addresses from the **hosts.txt**
    file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xargs -P 5** runs up to five parallel instances of the following command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-I {}** inserts the hostname or IP address from **hosts.txt** into the command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nmap -sS -oN {}_scan.txt {}** runs an **nmap** scan on each host, saving
    the output to a file named after the host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing output from parallel processes can be tricky. Here are a few tips:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separate output files** : As shown in the examples, direct each command’s
    output to a unique file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Combine outputs** : Use **cat** or similar tools to combine output files
    after processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging** : Redirect both standard output and error to log files for each
    process to ensure you capture all relevant information, as shown in the following
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The **xargs** command is a versatile tool that can greatly enhance the efficiency
    of your Bash scripts by enabling parallel execution. Its ability to handle large
    numbers of arguments and process them in parallel makes it invaluable for various
    cybersecurity tasks, from network scanning to log file analysis. By mastering
    **xargs** , you can significantly reduce the time required for many repetitive
    tasks, improving both productivity and effectiveness in your cybersecurity operations.
  prefs: []
  type: TYPE_NORMAL
- en: Using GNU parallel for enhanced control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the usage of **GNU parallel** , ensure that it is installed
    on your system. On most Linux distributions, you can install it using the package
    manager. For example, on Debian-based systems, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'GNU parallel allows you to run commands in parallel by reading input from standard
    input, files, or command-line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**parallel** : The command to invoke GNU parallel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**echo** : The command to be executed in parallel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**:::** : A separator indicating the start of input values from the command
    line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A B C D** : The input values that will be processed in parallel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, GNU parallel runs the **echo** command four times concurrently,
    each time with one of the input values ( **A** , **B** , **C** , **D** ).
  prefs: []
  type: TYPE_NORMAL
- en: 'GNU parallel shines when dealing with more complex tasks, such as processing
    files or executing scripts on multiple targets. Suppose you have a directory with
    multiple text files and you want to count the number of lines in each file simultaneously,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ls *.txt** : Lists all text files in the current directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**| parallel** : Pipes the list of files to GNU parallel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wc -l** : The command to count the lines in each file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, GNU parallel runs **wc -l** on each file concurrently, significantly speeding
    up the process compared to running the command sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'GNU parallel can handle more complex scenarios involving scripts and multiple
    input arguments. Imagine you have a **scan.sh** script that performs network scans,
    and you need to run this script on multiple IP addresses. The following code demonstrates
    basic parallel usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**cat ips.txt** : Outputs the contents of **ips.txt** , which contains a list
    of IP addresses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**| parallel** : Pipes the list of IP addresses to GNU parallel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**./scan.sh** : The script to be executed on each IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, GNU parallel runs **scan.sh** for each IP address listed in
    **ips.txt** concurrently, enhancing the efficiency of your network scanning operations.
  prefs: []
  type: TYPE_NORMAL
- en: GNU parallel offers advanced options for controlling the number of concurrent
    jobs, handling input from multiple sources, and managing output.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can limit the number of jobs running simultaneously using the **-** **j**
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, **-j 4** limits the number of concurrent jobs to **4** . This command
    ensures that no more than four instances of **scan.sh** run at the same time,
    which can be useful for managing system resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parallel can also handle multiple input sources, enabling more complex workflows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-a ips.txt** : Specifies **ips.txt** as an input file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-a ports.txt** : Specifies **ports.txt** as another input file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**./scan.sh** : The script to be executed with combined inputs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, **parallel** combines inputs from both **ips.txt** and **ports.txt**
    , running **scan.sh** with pairs of IP addresses and ports. In the **ch07_parallel_1.sh**
    script, the input from **ips.txt** and **ports.txt** are referenced as positional
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be found in the book ’s GitHub repository as **ch07_parallel_1.sh**
    . Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Managing errors and outputs from parallel processes can be challenging, but
    **parallel** provides mechanisms to handle these scenarios, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**{}''>''** : Redirects standard output to a file. Note that the **>** character
    is quoted. Other special shell characters (such as ***** , **;** , **$** , **>**
    , **<** , **|** , **>>** , and **<<** ) also need to be put in quotes, as they
    may otherwise be interpreted by the shell and not given to parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**results/{#}.out** : The file to store standard output, with **{#}** representing
    the job number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2>** : Redirects standard error to a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**errors/{#}.err** : The file to store standard error, with **{#}** representing
    the job number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**:::: ips.txt** : Specifies **ips.txt** as the input file. **::::** is used
    to specify that the following arguments are filenames containing input items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This command redirects the output and errors of each job to separate files,
    making it easier to review results and debug issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Input to GNU parallel can be specified in four different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**:::** : Direct input list, **parallel echo ::: A** **B C**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**::::** : Input from a file, **parallel echo ::::** **input.txt**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**|** : Standard input, **cat input.txt |** **parallel echo**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--arg-file** or **-a** : Specify a file, **parallel --arg-file** **input.txt
    echo**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keep in mind that multiple inputs can be specified. The following example includes
    multiple fil e and argument inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down this complex parallel command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-a file1 -a file2** : The **-a** option specifies input sources. This tells
    **parallel** to read input lines from both **file1** and **file2** . Each line
    from these files will be used as an argument to the command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**::: arg1 arg2** : The **:::** separator introduces command-line arguments.
    **arg1** and **arg2** are literal arguments that will be used in each job.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**:::: file3** : The **::::** separator introduces another input source. **file3**
    will be read, and each of its lines will be used as an argument.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**:::: file4** : Another input source, similar to **file3** . Each line from
    **file4** will be used as an argument.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**command** : This is the actual command that will be executed in parallel
    for each combination of inputs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s how **parallel** will process this command. It will create a job for
    each combination of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A line from **file1**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A line from **file2**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either **arg1** or **arg2**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A line from **file3**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A line from **file4**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each of these combinations, it will execute **command** , substituting the
    arguments in order. The number of jobs that run simultaneously depends on the
    number of CPU cores available, unless specified otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a real-world example where we use the **parallel** command to perform
    a series of automated security checks on multiple servers using different tools
    and configurations. This could be part of a pentesting or security audit exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the contents of the **servers.txt** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the conten ts of the **ports.txt** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the contents of the **scan_types.txt** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the contents of the **output_formats.txt** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create a script that will perform these security checks. You can
    find this file in the book’s GitHub repository as **ch07_parallel_3.sh** . The
    purpose of this script is to automate and parallelize a series of simulated security
    checks across multiple servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the partial output of running the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This command structure is particularly useful when you need to process data
    from multiple sources in combination, allowing for complex parallel processing
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve been introduced to both **xargs** and parallel, I’ll explain
    in the next section when to choose one over the other.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing xargs and parallel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What are the key differences between **xargs** and parallel and how do you
    know when either one is the right tool for the job? The following table should
    help you choose the right tool for the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Aspect** | **xargs** | **GNU parallel** |'
  prefs: []
  type: TYPE_TB
- en: '| **Execution** | Serial by default. Can run parallel with the **-P** option,
    but is less flexible. | Designed for efficient parallel execution out of the box.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Complexity** | Simpler, lightweight. Good for straightforward tasks. |
    Feature-rich. Handles complex scenarios, job control, and load balancing. |'
  prefs: []
  type: TYPE_TB
- en: '| **Error handling** | Basic. May stop on errors. | Robust. Can continue despite
    failures. |'
  prefs: []
  type: TYPE_TB
- en: '| **Availability** | Installed by default on most Unix systems. | Requires
    separate installation. |'
  prefs: []
  type: TYPE_TB
- en: Table 7.1 – A comparison of xargs and parallel features
  prefs: []
  type: TYPE_NORMAL
- en: Having learned how Bash parallel processing works, in the next section, we’ll
    explore using these concepts in practical applications.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving parallelism using screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **screen** command is a Linux utility that allows users to manage multiple
    terminal sessions within a single window. It’s particularly useful for running
    long processes, managing remote sessions, and achieving parallelism in Bash scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding, ensure you have **screen** installed by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how you can use **screen** to run multiple tasks in parallel. You can
    find the code in the book’s GitHub repository as **ch07_screen_1.sh** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The **perform_task** function simply sleeps for five seconds to simulate performing
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code creates a new detached **screen** session named **parallel_tasks**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The **-d** flag starts the session in detached mode, and **m** creates a new
    session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding **for** loop starts multiple tasks in separate **screen** windows.
    This command creates a new window within the **parallel_tasks** session. The **-X**
    flag sends a command to the session, **screen** creates a new window, **-t** sets
    the window title, and **bash -c** executes the specified command in the new window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command waits for all windows in the session to close. It’s useful
    for synchronizing the completion of parallel tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command terminates the entire screen session once all tasks are
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a solid foundation on the use of **xargs** , **parallel** ,
    and **screen** , let’s move on to the next section and look at some practical
    applications and review best practices for their use.
  prefs: []
  type: TYPE_NORMAL
- en: Practical applications and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will further solidify your understanding of parallel processing
    in Bash by showing practical applications. This will be followed by best practices
    to help you get the most out of learning these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Practical applications of Bash parallel processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will use examples to show the real-world usage of Bash parallel
    processing in pentesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example uses GNU parallel for **SQL injection** testing, as shown
    in the followin g code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The code can be found in the book’s GitHub repository as **ch07_parallel_2.sh**
    . Here’s an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**urls** is an array of URLs to test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**echo "${urls[@]}"** outputs the list of URLs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**parallel -j 3 ''sqlmap -u {} --batch --crawl=2''** runs **sqlmap** on each
    URL with up to three concurrent jobs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next example shows how to do network TCP port scanning in parallel, as
    sho wn here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The code can be found in the book’s GitHub repository as **ch07_xargs_1.sh**
    . Here’s an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**seq 1 254 | awk ''{print "192.168.1." $1}''** generates IP addresses from
    **192.168.1.1** to **192.168.1.254** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**echo "$ips"** outputs the list of IPs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xargs -n 1 -P 10 -I {} bash -c ''nmap -sP {}''** runs **nmap** ’s ping scan
    ( **-sP** ) on each IP, with up to 10 parallel jobs. The **-n 1** option tells
    **xargs** to use, at most, one argument per command line. In this context, it
    means that **xargs** will run the **nmap** command once for each IP address or
    hostname it receives as input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the preceding is an example of performing port scanning in parallel, **nmap**
    already has this capability. Therefore, let’s explore how to do this in Bash.
    You may find yourself in a shell on a system you have exploited and can’t install
    tools such as **nmap** for one reason or another so you should be prepared to
    use the system as a pivot into other networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Bash script has no external dependencies and scans for live hosts,
    then port-scans the top 100 TCP ports. It’s not nearly as fast as it could be
    if **xargs** or **parallel** were used. Just keep in mind that, someday, you’ll
    need something that doesn’t require any external dependencies and you can’t be
    assured that **xargs** and **parallel** will always be available. This script
    should work anywhere with Bash and the **ping** appl ication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The code can be found in the book’s GitHub repository as **ch07_no_dependencies_scan.sh**
    . Here’s an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**#!/usr/bin/env bash** : The usual **shebang** that we’ve covered in earlier
    chapters. This basically tells the shell what program to use to execute the following
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IP_RANGE** : Defines the range of IP addresses to scan using brace expansion
    ( **{1..20}** ), which denotes the last octet ranging from 1 to 20 for the base
    IP **192.168.1** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PORTS** : An array holding the **nmap** top 100 TCP ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LIVE_HOSTS** : An empty array to store the IP addresses of live hosts that
    respond to pings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**for IP in $(eval echo $IP_RANGE)** : Iterates through the expanded list of
    IP addresses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ping -c 1 -W 1 $IP > /dev/null 2>&1** : Sends one ICMP echo request ( **-c
    1** ) with a 1-second timeout ( **-W 1** ) to check whether the host is up. The
    output is redirected to **/dev/null** to suppress it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LIVE_HOSTS+=($IP)** : Adds the IP address to the **LIVE_HOSTS** array if
    the host is up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**scan_ports $IP** : A function that takes an IP address as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(echo >/dev/tcp/$IP/$PORT) > /dev/null 2>&1** : Attempts to open a TCP connection
    to the specified port on the IP address. If successful, it prints the IP address
    and port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Export the function** : Using **export -f scan_ports** allows the function
    to be used in subshells.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**for IP in "${LIVE_HOSTS[@]}"** : Iterates through the list of live hosts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**scan_ports $IP &** : Calls the **scan_ports** function in the background
    for each IP address, allowing concurrent execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wait** : Waits for all background jobs to complete before exiting the script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The script checks 20 consecutive IP addresses for live hosts and then scans
    the top 100 TCP ports and completes in 10 seconds on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – A Bash TCP port scanner that should work on any system](image/B22229_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – A Bash TCP port scanner that should work on any system
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of downloading multiple files in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**parallel -j 3** : Executes three parallel jobs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wget :::** : The three URLs following the series of colon characters are
    the input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This command downloads three files concurrently using **wget** .
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for parallel execution in Bash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section explores best practices for using **xargs** and **parallel** to
    execute tasks concurrently, leveraging the full potential of your system’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the best practices for parallel execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Determine the optimal number of jobs** : The ideal number of parallel jobs
    depends on your system’s CPU and memory capacity. Start with the number of CPU
    cores and adjust based on performance. If you don’t specify a number of jobs,
    the defaults are one job for **xargs** and one job per CPU core for GNU parallel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor resource usage** : Use tools such as **htop** or **vmstat** to monitor
    CPU and memory usage during parallel execution, ensuring your system remains responsive.
    See the man entry for these tools for examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make a dry run** : You can check what will be run with parallel by including
    the **--** **dry-run** option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handle errors gracefully** : Both **xargs** and GNU parallel can capture
    and log errors. Use these features to identify and debug issues without halting
    the entire process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redirect output appropriately** : Redirect the output of each job to separate
    files or a log system to avoid interleaved and confusing outputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use meaningful job names** : When using GNU Parallel, you can assign meaningful
    names to jobs to easily track their progress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel execution with **xargs** and GNU parallel can vastly improve the efficiency
    of Bash scripts, particularly in cybersecurity and pentesting tasks. By following
    best practices such as optimizing job numbers, monitoring resources, handling
    errors, and managing output, you can harness the full potential of parallel processing
    to enhance your scripts and workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about parallel processing techniques in Bash scripting.
    This helped you gain knowledge on the basics of parallel execution using background
    processes and job control. We also learned about advanced parallel processing
    using tools such as **xargs** and GNU parallel and covered managing errors and
    output in parallel tasks. The chapter also covered applying parallel processing
    to pentesting workflows.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you significantly speed up tasks that involve processing
    large amounts of data or executing multiple commands simultaneously. Parallel
    processing can greatly reduce the time required for network scans, brute-force
    attacks, or analyzing multiple targets concurrently. Understanding how to manage
    parallel tasks helps in creating more efficient and robust scripts for various
    pentesting scenarios. The skills learned can be applied to optimize resource usage
    and improve overall productivity during security assessments.
  prefs: []
  type: TYPE_NORMAL
- en: By mastering parallel processing in Bash, pentesters can create more powerful
    and efficient scripts, allowing them to handle complex tasks and large-scale assessments
    more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we dive into *Part 2,* where we put all of the Bash goodness
    that you’ve learned to work for a pentest.
  prefs: []
  type: TYPE_NORMAL
