<html><head></head><body>
  <div id="_idContainer092">
   <h1 class="chapter-number" id="_idParaDest-139">
    <a id="_idTextAnchor213">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     8
    </span>
   </h1>
   <h1 id="_idParaDest-140">
    <a id="_idTextAnchor214">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Reconnaissance and Information Gathering
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     Previous chapters introduced you to Bash scripting concepts.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     In some cases, we ran applications that were not made with Bash.
    </span>
    <span class="koboSpan" id="kobo.3.3">
     In those cases, we used Bash to execute programs, pipe data between applications, or parse the output of these tools.
    </span>
    <span class="koboSpan" id="kobo.3.4">
     As we progress further into this book, we will be demonstrating less pure Bash and more on using Bash to execute our pentesting tools, automate them, and parse
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      their output.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     In this chapter, we dive into the essential first step of any pentest: reconnaissance.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     You’ll learn how to discover email addresses and assets owned by your target organization using various tools and techniques.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     This foundational knowledge will set the stage for more active assessments in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      later chapters.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.7.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.8.1">
     Don’t expect this and the following chapters to be a thorough reference on performing pentesting.
    </span>
    <span class="koboSpan" id="kobo.8.2">
     I will not be demonstrating every step, technique, and tool here.
    </span>
    <span class="koboSpan" id="kobo.8.3">
     This book is meant to teach you how to augment your pentests with Bash scripting, not how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.9.1">
      do pentesting.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.10.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.11.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <a id="_idTextAnchor215">
     </a>
     <a id="_idTextAnchor216">
     </a>
     <span class="koboSpan" id="kobo.12.1">
      Introduction to reconnaissance
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.13.1">
       with Bash
      </span>
     </span>
    </li>
    <li>
     <a id="_idTextAnchor217">
     </a>
     <a id="_idTextAnchor218">
     </a>
     <span class="koboSpan" id="kobo.14.1">
      Formatting usernames and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.15.1">
       email addresses
      </span>
     </span>
    </li>
    <li>
     <a id="_idTextAnchor219">
     </a>
     <a id="_idTextAnchor220">
     </a>
     <span class="koboSpan" id="kobo.16.1">
      Using Bash for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       DNS enumeration
      </span>
     </span>
    </li>
    <li>
     <a id="_idTextAnchor221">
     </a>
     <a id="_idTextAnchor222">
     </a>
     <span class="koboSpan" id="kobo.18.1">
      Using Bash to identify
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.19.1">
       web applications
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.20.1">
     By the end of this chapter, you’ll be proficient with using Bash with
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.21.1">
      Open source intelligence
     </span>
    </strong>
    <span class="koboSpan" id="kobo.22.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.23.1">
      OSINT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.24.1">
     ) tools and sources to discover domain names, email addresses, and IP addresses of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.25.1">
      your target.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-141">
    <a id="_idTextAnchor223">
    </a>
    <span class="koboSpan" id="kobo.26.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.27.1">
     The main prerequisite is that you started reading from
    </span>
    <a href="B22229_01.xhtml#_idTextAnchor017">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.28.1">
        Chapter 1
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.29.1">
     and have access to a Bash shell.
    </span>
    <span class="koboSpan" id="kobo.29.2">
     If you aren’t using Kali Linux, you will likely find it more difficult to follow along.
    </span>
    <span class="koboSpan" id="kobo.29.3">
     One script detailed later in this chapter requires a ProjectDiscovery Chaos API key (
    </span>
    <a href="https://chaos.projectdiscovery.io/">
     <span class="koboSpan" id="kobo.30.1">
      https://chaos.projectdiscovery.io/
     </span>
    </a>
    <span class="koboSpan" id="kobo.31.1">
     ), which can be obtained for free at the time
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.32.1">
      of writing.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.33.1">
     The code for this chapter can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.34.1">
      at
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter08">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.35.1">
       https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter08
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.36.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.37.1">
     Install the prerequisites in Kali Linux using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.38.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.39.1">
$ sudo apt update &amp;&amp; sudo apt install -y libxml2-utils whois</span></pre>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     You must also have Golang and the Chaos client installed.
    </span>
    <span class="koboSpan" id="kobo.40.2">
     Installing Golang was documented fully in
    </span>
    <a href="B22229_01.xhtml#_idTextAnchor017">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.41.1">
        Chapter 1
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.42.1">
     .
    </span>
    <span class="koboSpan" id="kobo.42.2">
     You can install the Chaos client with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.43.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.44.1">
$ </span><a id="_idTextAnchor224"/><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.45.1">go install -v github.com/projectdiscovery/chaos-client/cmd/chaos@latest</span></pre>
   <h1 id="_idParaDest-142">
    <a id="_idTextAnchor226">
    </a>
    <span class="koboSpan" id="kobo.46.1">
     Introducing reconnaissance with Bash
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     The urge to jump straight to scanning and
    </span>
    <a id="_idIndexMarker457">
    </a>
    <span class="koboSpan" id="kobo.48.1">
     hacking can be hard to overcome when you’re passionate about pentesting.
    </span>
    <span class="koboSpan" id="kobo.48.2">
     I’ve lost count of the number of times in my career that I’ve done a less than thorough job of reconnaissance before jumping to active scanning only to later hit a wall.
    </span>
    <span class="koboSpan" id="kobo.48.3">
     That’s when I find that circling back to the recon phase and finding some juicy nuggets is the key
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.49.1">
      to success.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.50.1">
     One pentest I did years ago stands out in my memories above the rest.
    </span>
    <span class="koboSpan" id="kobo.50.2">
     I was pentesting a simple web page with a login form.
    </span>
    <span class="koboSpan" id="kobo.50.3">
     Nothing else was in scope.
    </span>
    <span class="koboSpan" id="kobo.50.4">
     I wasn’t given any credentials.
    </span>
    <span class="koboSpan" id="kobo.50.5">
     If I managed to find working credentials or bypass the login form, it was
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.51.1">
      game over.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     I thoroughly attacked the login form for three days and had nothing to show for it.
    </span>
    <span class="koboSpan" id="kobo.52.2">
     That’s when I circled back to
    </span>
    <a id="_idIndexMarker458">
    </a>
    <span class="koboSpan" id="kobo.53.1">
     reconnaissance.
    </span>
    <span class="koboSpan" id="kobo.53.2">
     I ended up finding that the company had a GitHub account with some public repositories.
    </span>
    <span class="koboSpan" id="kobo.53.3">
     One of those repositories contained credentials hidden in old commits.
    </span>
    <span class="koboSpan" id="kobo.53.4">
     The credentials had been removed, but Git maintains versioning and history, which allowed me to pull them out and use them.
    </span>
    <span class="koboSpan" id="kobo.53.5">
     After logging in and being redirected, I found myself in complete control of a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.54.1">
      financial application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.55.1">
     Every type of pentest depends on doing research before attacking the target.
    </span>
    <span class="koboSpan" id="kobo.55.2">
     The most successful physical pentest I’ve done was successful because we researched our target company employees and found high-resolution photos of employee events on social media, which helped us to create very convincing clones of their badges.
    </span>
    <span class="koboSpan" id="kobo.55.3">
     While our badges wouldn’t open doors with electronic badge readers, together with our confidence and pretext (the story we told the employees to explain why we were visiting), we convinced employees to give us access.
    </span>
    <span class="koboSpan" id="kobo.55.4">
     On a wireless pentest of the same company, we were able to access their employee wireless network from the parking lot because we first checked their social media and websites and used Bash to make a wordlist of words and terms to use for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.56.1">
      password cracking.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.57.1">
     OSINT is the process of collecting and analyzing information from publicly available sources to produce actionable intelligence.
    </span>
    <span class="koboSpan" id="kobo.57.2">
     This type of intelligence gathering leverages data from various media, including the internet, social networks, public records, and news reports.
    </span>
    <span class="koboSpan" id="kobo.57.3">
     OSINT can aid in a wide range of activities, from national security to cybersecurity, providing valuable insights without the need for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.58.1">
      illicit methods.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.59.1">
     The importance of OSINT lies in its ability to offer a comprehensive view of a target’s available information, which can be critical in both offensive and defensive security measures.
    </span>
    <span class="koboSpan" id="kobo.59.2">
     For security pentests, OSINT helps identify potential vulnerabilities, gather details about the target’s infrastructure, and understand the organizational and personal behaviors that might be exploited by malicious actors.
    </span>
    <span class="koboSpan" id="kobo.59.3">
     The insights gained through OSINT enable testers to emulate potential real-world attacks
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.60.1">
      more effectively.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.61.1">
     In preparation for a security pentest, the types of data gathered during OSINT include domain and IP address information, employee details, email addresses, social media profiles, document metadata, network configurations, and software versions.
    </span>
    <span class="koboSpan" id="kobo.61.2">
     This information helps build a detailed profile of the target, uncovering entry points that might be exploited for unauthorized access or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.62.1">
      data breaches.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.63.1">
     In the next section, we’ll dive in
    </span>
    <a id="_idIndexMarker459">
    </a>
    <span class="koboSpan" id="kobo.64.1">
     by learning how to use Bash scripting to format usernames and passwords.
    </span>
    <span class="koboSpan" id="kobo.64.2">
     These skills will be very useful in various pentesting scenarios, such as phishing and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.65.1">
      password spraying.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-143">
    <a id="_idTextAnchor227">
    </a>
    <span class="koboSpan" id="kobo.66.1">
     Formatting usernames and email addresses
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.67.1">
     There are a few scenarios in
    </span>
    <a id="_idIndexMarker460">
    </a>
    <span class="koboSpan" id="kobo.68.1">
     pentesting where you’ll need to enumerate usernames and email addresses.
    </span>
    <span class="koboSpan" id="kobo.68.2">
     You may need them for phishing, password spraying, or enumerating
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.69.1">
      valid accounts.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.70.1">
     If you want to follow along while you perform this exercise, go to
    </span>
    <a href="https://hunter.io">
     <span class="koboSpan" id="kobo.71.1">
      https://hunter.io
     </span>
    </a>
    <span class="koboSpan" id="kobo.72.1">
     and register for a free account.
    </span>
    <span class="koboSpan" id="kobo.72.2">
     This is a website for finding company employee names and email addresses.
    </span>
    <span class="koboSpan" id="kobo.72.3">
     After logging in to your free account, click the drop-down arrow beside your name in the top-right corner and then click on
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.73.1">
      API
     </span>
    </strong>
    <span class="koboSpan" id="kobo.74.1">
     in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.75.1">
      the menu.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer078">
     <span class="koboSpan" id="kobo.76.1">
      <img alt="Figure 8.1 – Selecting API from the hunter.io menu" src="image/B22229_08_1.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.77.1">
     Figure 8.1 – Selecting API from the hunter.io menu
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.78.1">
     On this page, you’ll find example commands
    </span>
    <a id="_idIndexMarker461">
    </a>
    <span class="koboSpan" id="kobo.79.1">
     for various types of API searches.
    </span>
    <span class="koboSpan" id="kobo.79.2">
     Under
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.80.1">
      Domain Search
     </span>
    </strong>
    <span class="koboSpan" id="kobo.81.1">
     , click the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.82.1">
      Copy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.83.1">
     button.
    </span>
    <span class="koboSpan" id="kobo.83.2">
     Enter the following command in your terminal, substituting
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.84.1">
      [redacted]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.85.1">
     with your own
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.86.1">
      API key
     </span>
     <a id="_idTextAnchor228">
     </a>
     <a id="_idTextAnchor229">
     </a>
     <span class="koboSpan" id="kobo.87.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.88.1">
$ curl https://api.hunter.io/v2/domain-search\?domain=stripe.com\&amp;api_key=[redacted] &gt; employees.txt</span></pre>
   <p>
    <span class="koboSpan" id="kobo.89.1">
     In the URL, you can see
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.90.1">
      domain=stripe.com
     </span>
    </strong>
    <span class="koboSpan" id="kobo.91.1">
     .
    </span>
    <span class="koboSpan" id="kobo.91.2">
     Obviously, you will want to change the domain to match
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.92.1">
      your target.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.93.1">
     Critical
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.94.1">
     Stripe is used as an example in
    </span>
    <a id="_idIndexMarker462">
    </a>
    <span class="koboSpan" id="kobo.95.1">
     this text only because the
    </span>
    <a href="http://hunter.io">
     <span class="koboSpan" id="kobo.96.1">
      hunter.io
     </span>
    </a>
    <span class="koboSpan" id="kobo.97.1">
     website API page included it as an example.
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.98.1">
      Do not
     </span>
    </em>
    <span class="koboSpan" id="kobo.99.1">
     hack anyone if you don’t have written permission.
    </span>
    <span class="koboSpan" id="kobo.99.2">
     Not only is it illegal and unethical, but you’ll probably end up in prison when you
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.100.1">
      get caught.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.101.1">
     Next,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.102.1">
      cat
     </span>
    </strong>
    <span class="koboSpan" id="kobo.103.1">
     the text file to the terminal
    </span>
    <a id="_idIndexMarker463">
    </a>
    <span class="koboSpan" id="kobo.104.1">
     so we can get a look at the output format.
    </span>
    <span class="koboSpan" id="kobo.104.2">
     The first level of JSON data is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.105.1">
      data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.106.1">
     , as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.107.1">
      following figure:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer079">
     <span class="koboSpan" id="kobo.108.1">
      <img alt="Figure 8.2 – JSON first-level data" src="image/B22229_08_2.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.109.1">
     Figure 8.2 – JSON first-level data
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.110.1">
     The absolute simplest
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.111.1">
      jq
     </span>
    </strong>
    <span class="koboSpan" id="kobo.112.1">
     filter is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.113.1">
      jq .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.114.1">
     .
    </span>
    <span class="koboSpan" id="kobo.114.2">
     This filter takes its input and produces the same value as the output.
    </span>
    <span class="koboSpan" id="kobo.114.3">
     The data that we want to access is nested under
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.115.1">
      data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.116.1">
     .
    </span>
    <span class="koboSpan" id="kobo.116.2">
     Therefore, our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.117.1">
      jq
     </span>
    </strong>
    <span class="koboSpan" id="kobo.118.1">
     query will start with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.119.1">
      .data[]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.120.1">
     .
    </span>
    <span class="koboSpan" id="kobo.120.2">
     Enter the following command and see that everything contained in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.121.1">
      data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.122.1">
     is output,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.123.1">
      cat employees.txt | jq -r '.data[]'
     </span>
    </strong>
    <span class="koboSpan" id="kobo.124.1">
     .
    </span>
    <span class="koboSpan" id="kobo.124.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.125.1">
      -r
     </span>
    </strong>
    <span class="koboSpan" id="kobo.126.1">
     argument simply tells
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.127.1">
      jq
     </span>
    </strong>
    <span class="koboSpan" id="kobo.128.1">
     to output raw data without escapes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      and quotes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.130.1">
     If you look at the information nested under
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.131.1">
      data
     </span>
    </strong>
    <span class="koboSpan" id="kobo.132.1">
     , you’ll find that employee email addresses, names, and positions are nested under
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.133.1">
      emails
     </span>
    </strong>
    <span class="koboSpan" id="kobo.134.1">
     .
    </span>
    <span class="koboSpan" id="kobo.134.2">
     Building on our earlier query, the next command will be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.135.1">
      cat employees.txt | jq -r '.data.emails[]'
     </span>
    </strong>
    <span class="koboSpan" id="kobo.136.1">
     .
    </span>
    <span class="koboSpan" id="kobo.136.2">
     Do you notice a pattern here?
    </span>
    <span class="koboSpan" id="kobo.136.3">
     When you want to access nested data using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.137.1">
      jq
     </span>
    </strong>
    <span class="koboSpan" id="kobo.138.1">
     , start with a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.139.1">
      .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.140.1">
     symbol and the
    </span>
    <a id="_idIndexMarker464">
    </a>
    <span class="koboSpan" id="kobo.141.1">
     first field you want to access, followed by square brackets,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.142.1">
      .first_level[]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.143.1">
     .
    </span>
    <span class="koboSpan" id="kobo.143.2">
     If you want to access data nested one level deeper, use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.144.1">
      .first_level.second_level[]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.145.1">
     .
    </span>
    <span class="koboSpan" id="kobo.145.2">
     In this particular case, we want to access the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.146.1">
      value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.147.1">
     (email address),
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.148.1">
      first_name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.149.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      last_name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.152.1">
      position
     </span>
    </strong>
    <span class="koboSpan" id="kobo.153.1">
     fields, which are nested under
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.154.1">
      .data.emails[]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.155.1">
     .
    </span>
    <span class="koboSpan" id="kobo.155.2">
     Therefore, our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.156.1">
      jq
     </span>
    </strong>
    <span class="koboSpan" id="kobo.157.1">
     query wi
    </span>
    <a id="_idTextAnchor230">
    </a>
    <a id="_idTextAnchor231">
    </a>
    <span class="koboSpan" id="kobo.158.1">
     ll be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.159.1">
      .data.emails[] | [.value, .first_name, .last_name, .position]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.160.1">
     , as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.161.1">
      following figure:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer080">
     <span class="koboSpan" id="kobo.162.1">
      <img alt="Figure 8.3 – Our jq query to access email addresses and employee information" src="image/B22229_08_3.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.163.1">
     Figure 8.3 – Our jq query to access email addresses and employee information
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.164.1">
     Now that we have the information we need, the next step is to get it into a format that’s easier to work with, such as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.165.1">
      tab-separated values
     </span>
    </strong>
    <span class="koboSpan" id="kobo.166.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.167.1">
      TSV
     </span>
    </strong>
    <span class="koboSpan" id="kobo.168.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.168.2">
     Let’s check the manual for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.169.1">
      jq
     </span>
    </strong>
    <span class="koboSpan" id="kobo.170.1">
     to find out how to
    </span>
    <a id="_idIndexMarker465">
    </a>
    <span class="koboSpan" id="kobo.171.1">
     make this transformation.
    </span>
    <span class="koboSpan" id="kobo.171.2">
     Enter the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.172.1">
      man jq
     </span>
    </strong>
    <span class="koboSpan" id="kobo.173.1">
     command in your terminal.
    </span>
    <span class="koboSpan" id="kobo.173.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.174.1">
      jq
     </span>
    </strong>
    <span class="koboSpan" id="kobo.175.1">
     program has many options, but if you keep scrolling far enough, you’ll find a
    </span>
    <a id="_idIndexMarker466">
    </a>
    <span class="koboSpan" id="kobo.176.1">
     section named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.177.1">
      Format strings and escaping
     </span>
    </strong>
    <span class="koboSpan" id="kobo.178.1">
     .
    </span>
    <span class="koboSpan" id="kobo.178.2">
     In this section, we find that
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.179.1">
      Comma-Separated Values
     </span>
    </strong>
    <span class="koboSpan" id="kobo.180.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.181.1">
      CSV
     </span>
    </strong>
    <span class="koboSpan" id="kobo.182.1">
     ) and TSV are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.183.1">
      @csv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.184.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.185.1">
      @tsv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.186.1">
     .
    </span>
    <span class="koboSpan" id="kobo.186.2">
     All that’s needed now is to pipe the previous query to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.187.1">
      @tsv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.188.1">
     , as shown in the following figure.
    </span>
    <span class="koboSpan" id="kobo.188.2">
     Make sure that your pipe character and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.189.1">
      @tsv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.190.1">
     are enclosed inside the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.191.1">
      single quotes:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer081">
     <span class="koboSpan" id="kobo.192.1">
      <img alt="Figure 8.4 – Our final jq query extracts the needed data" src="image/B22229_08_4.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.193.1">
     Figure 8.4 – Our final jq query extracts the needed data
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.194.1">
     If we were authorized to do so and wanted to use this data for password spraying a login form on a website, we can guess that most likely their internal Active Directory domain user account is named the same as in their email address before the domain,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.195.1">
      @stripe.com
     </span>
    </strong>
    <span class="koboSpan" id="kobo.196.1">
     .
    </span>
    <span class="koboSpan" id="kobo.196.2">
     However, as a
    </span>
    <a id="_idIndexMarker467">
    </a>
    <span class="koboSpan" id="kobo.197.1">
     pentester, you will need to know how to take first and last names and reformat them in different formats, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.198.1">
      first.last
     </span>
    </strong>
    <span class="koboSpan" id="kobo.199.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.200.1">
      f.last
     </span>
    </strong>
    <span class="koboSpan" id="kobo.201.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.202.1">
      first_last
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     , and so on.
    </span>
    <span class="koboSpan" id="kobo.203.2">
     Notice that in the data in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.204.1">
       Figure 8
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.205.1">
      .4
     </span>
    </em>
    <span class="koboSpan" id="kobo.206.1">
     , the first and last names are in columns 2 and 3.
    </span>
    <span class="koboSpan" id="kobo.206.2">
     Let’s create a simple one-line script that will build on the previous command and take the first and last names and print them as first initial and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.207.1">
      last name:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer082">
     <span class="koboSpan" id="kobo.208.1">
      <img alt="Figure 8.5 – Formatting usernames as first initial, last name" src="image/B22229_08_5.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.209.1">
     Figure 8.5 – Formatting usernames as first initial, last name
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.210.1">
     Here is a full explanation of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.211.1">
      awk
     </span>
    </strong>
    <span class="koboSpan" id="kobo.212.1">
     command inside
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.213.1">
      single quotes:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.214.1">
       awk 'pattern {action}'
      </span>
     </strong>
     <span class="koboSpan" id="kobo.215.1">
      : You may remember from
     </span>
     <a href="B22229_04.xhtml#_idTextAnchor073">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.216.1">
         Chapter 4
        </span>
       </em>
      </span>
     </a>
     <span class="koboSpan" id="kobo.217.1">
      that
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.218.1">
       awk
      </span>
     </strong>
     <span class="koboSpan" id="kobo.219.1">
      commands are in the format of pattern and action.
     </span>
     <span class="koboSpan" id="kobo.219.2">
      The pattern is optional.
     </span>
     <span class="koboSpan" id="kobo.219.3">
      The action
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.220.1">
       is mandatory.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.221.1">
       print tolower()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.222.1">
      : This may be obvious.
     </span>
     <span class="koboSpan" id="kobo.222.2">
      It prints the output in all lowercase.
     </span>
     <span class="koboSpan" id="kobo.222.3">
      Inside this
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.223.1">
       awk
      </span>
     </strong>
     <span class="koboSpan" id="kobo.224.1">
      function, we’re printing the first initial of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.225.1">
       first_name
      </span>
     </strong>
     <span class="koboSpan" id="kobo.226.1">
      (second field or
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.227.1">
       $2
      </span>
     </strong>
     <span class="koboSpan" id="kobo.228.1">
      ) followed by the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.229.1">
       last_name
      </span>
     </strong>
     <span class="koboSpan" id="kobo.230.1">
      (third field
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.231.1">
       or
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.232.1">
        $3
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.233.1">
       ).
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.234.1">
       (substr($2,1,1)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.235.1">
      : Here, we’re
     </span>
     <a id="_idIndexMarker468">
     </a>
     <span class="koboSpan" id="kobo.236.1">
      making a substring of the data consisting of the second field (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.237.1">
       $2
      </span>
     </strong>
     <span class="koboSpan" id="kobo.238.1">
      ),
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.239.1">
       first_name
      </span>
     </strong>
     <span class="koboSpan" id="kobo.240.1">
      , starting with the first character and ending with the first character (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.241.1">
       1,1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.242.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.242.2">
      If we wanted to use the first two characters of the first name, the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.243.1">
       substr
      </span>
     </strong>
     <span class="koboSpan" id="kobo.244.1">
      command would
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.245.1">
       be
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.246.1">
        substr($2,1,2)
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.247.1">
       .
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.248.1">
     If you want to print the username as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.249.1">
      first_last
     </span>
    </strong>
    <span class="koboSpan" id="kobo.250.1">
     , use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.251.1">
      awk '{print tolower($1 "_" $2)}'
     </span>
    </strong>
    <span class="koboSpan" id="kobo.252.1">
     command to insert a specific character between first and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.253.1">
      last names.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.254.1">
     As a pentester, you should always use the right tool for the job.
    </span>
    <span class="koboSpan" id="kobo.254.2">
     Earlier in your career, you’re more likely to be running tools made by someone else.
    </span>
    <span class="koboSpan" id="kobo.254.3">
     These tools are frequently written in Python or C languages.
    </span>
    <span class="koboSpan" id="kobo.254.4">
     When performing OSINT, many of the tools are written in Python.
    </span>
    <span class="koboSpan" id="kobo.254.5">
     Regardless of which tool you use and the language it’s written in, eventually, you’ll need to filter and format data input or output from your tools.
    </span>
    <span class="koboSpan" id="kobo.254.6">
     That’s where the concepts in this chapter will save you
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.255.1">
      significant time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.256.1">
     In the next section, we’ll explore using Bash with DNS enumeration to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.257.1">
      discover targets.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-144">
    <a id="_idTextAnchor232">
    </a>
    <span class="koboSpan" id="kobo.258.1">
     Using Bash for DNS enumeration
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.259.1">
     As a pentester, you will typically be
    </span>
    <a id="_idIndexMarker469">
    </a>
    <span class="koboSpan" id="kobo.260.1">
     provided with a defined scope.
    </span>
    <span class="koboSpan" id="kobo.260.2">
     The scope is what you’re allowed to test.
    </span>
    <span class="koboSpan" id="kobo.260.3">
     It will usually be provided as a list of IP addresses, network addresses, domain names, URLs, or a combination of these.
    </span>
    <span class="koboSpan" id="kobo.260.4">
     On the other hand, you may also be tasked with discovering assets owned by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.261.1">
      the company.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.262.1">
     In my earlier years as a pentester before I got into consulting, I spent a lot of time enumerating DNS to discover new assets for a company that was global and acquired a lot of smaller companies.
    </span>
    <span class="koboSpan" id="kobo.262.2">
     I spent months discovering IP addresses, applications, and domain names owned by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.263.1">
      our acquisitions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.264.1">
     First, it’s essential to make sure we’re on the same page regarding terminology for domain names.
    </span>
    <span class="koboSpan" id="kobo.264.2">
     We need to
    </span>
    <a id="_idIndexMarker470">
    </a>
    <span class="koboSpan" id="kobo.265.1">
     quickly cover the difference between top-level domains, root domains, and subdomains.
    </span>
    <span class="koboSpan" id="kobo.265.2">
     I’ll use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.266.1">
      www.example.com
     </span>
    </strong>
    <span class="koboSpan" id="kobo.267.1">
     for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.268.1">
      this example:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.269.1">
       com
      </span>
     </strong>
     <span class="koboSpan" id="kobo.270.1">
      : This is
     </span>
     <a id="_idIndexMarker471">
     </a>
     <span class="koboSpan" id="kobo.271.1">
      the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.272.1">
       top-level
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.273.1">
        domain
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.274.1">
       (
      </span>
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.275.1">
        TLD
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.276.1">
       )
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.277.1">
       example
      </span>
     </strong>
     <span class="koboSpan" id="kobo.278.1">
      : This is the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.279.1">
       root domain
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.280.1">
       www
      </span>
     </strong>
     <span class="koboSpan" id="kobo.281.1">
      : This is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.282.1">
       the subdomain
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.283.1">
     With the terminology out of the way, let’s look at the methodology to discover additional root domains that are related to a known
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.284.1">
      root domain.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-145">
    <a id="_idTextAnchor233">
    </a>
    <span class="koboSpan" id="kobo.285.1">
     Expanding the scope using Bash
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.286.1">
     This section is dedicated to
    </span>
    <a id="_idIndexMarker472">
    </a>
    <span class="koboSpan" id="kobo.287.1">
     starting with a company’s domain name and discovering related assets exposed to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.288.1">
      the internet.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.289.1">
     Many companies use Microsoft 365.
    </span>
    <span class="koboSpan" id="kobo.289.2">
     If a company is enrolled as a Microsoft tenant with
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.290.1">
      Microsoft Defender for Identity
     </span>
    </strong>
    <span class="koboSpan" id="kobo.291.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.292.1">
      MDI
     </span>
    </strong>
    <span class="koboSpan" id="kobo.293.1">
     ), the
    </span>
    <a id="_idIndexMarker473">
    </a>
    <span class="koboSpan" id="kobo.294.1">
     following script will discover the tenant name and enumerate all domains enrolled in the same tenant.
    </span>
    <span class="koboSpan" id="kobo.294.2">
     This has been a very effective way to start with a simple domain name and discover related domains owned by the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.295.1">
      same entity.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.296.1">
     The script requires a domain as input.
    </span>
    <span class="koboSpan" id="kobo.296.2">
     You can find it in this chapter’s folder in the GitHub repository as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.297.1">
      ch08_check_mdi.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.298.1">
     .
    </span>
    <span class="koboSpan" id="kobo.298.2">
     I’m going to split up the code into smaller chunks to explain each part as we go.
    </span>
    <span class="koboSpan" id="kobo.298.3">
     It will be helpful to have the script in GitHub open on your computer monitor to compare to the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.299.1">
      code narrative:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.300.1">
#!/usr/bin/env bash
get_domains() {</span></pre>
   <p>
    <span class="koboSpan" id="kobo.301.1">
     In the preceding code, we start
    </span>
    <a id="_idIndexMarker474">
    </a>
    <span class="koboSpan" id="kobo.302.1">
     out with our familiar
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.303.1">
      shebang
     </span>
    </strong>
    <span class="koboSpan" id="kobo.304.1">
     , followed by the opening block of the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.305.1">
       get_domains
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.306.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.307.1">
     Here, we create a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.308.1">
      domain
     </span>
    </strong>
    <span class="koboSpan" id="kobo.309.1">
     variable
    </span>
    <a id="_idIndexMarker475">
    </a>
    <span class="koboSpan" id="kobo.310.1">
     from the first
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.311.1">
      command-line argument:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.312.1">
    domain=$1</span></pre>
   <p>
    <span class="koboSpan" id="kobo.313.1">
     In the following code block, we create the XML body of the HTTP request
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.314.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.315.1">
    body="&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;
    &lt;soap:Envelope xmlns:exm=\"http://schemas.microsoft.com/exchange/services/2006/messages\"
        xmlns:ext=\"http://schemas.microsoft.com/exchange/services/2006/types\"
        xmlns:a=\"http://www.w3.org/2005/08/addressing\"
        xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"
        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"&gt;
    &lt;soap:Header&gt;
        &lt;a:RequestedServerVersion&gt;Exchange2010&lt;/a:RequestedServerVersion&gt;
        &lt;a:MessageID&gt;urn:uuid:6389558d-9e05-465e-ade9-aae14c4bcd10&lt;/a:MessageID&gt;
        &lt;a:Action soap:mustUnderstand=\"1\"&gt;http://schemas.microsoft.com/exchange/2010/Autodiscover/Autodiscover/GetFederationInformation&lt;/a:Action&gt;
        &lt;a:To soap:mustUnderstand=\"1\"&gt;https://autodiscover.byfcxu-dom.extest.microsoft.com/autodiscover/autodiscover.svc&lt;/a:To&gt;
        &lt;a:ReplyTo&gt;
        &lt;a:Address&gt;http://www.w3.org/2005/08/addressing/anonymous&lt;/a:Address&gt;
        &lt;/a:ReplyTo&gt;
    &lt;/soap:Header&gt;
    &lt;soap:Body&gt;
        &lt;GetFederationInformationRequestMessage xmlns=\"http://schemas.microsoft.com/exchange/2010/Autodiscover\"&gt;
        &lt;Request&gt;
            &lt;Domain&gt;${domain}&lt;/Domain&gt;
        &lt;/Request&gt;
        &lt;/GetFederationInformationRequestMessage&gt;
    &lt;/soap:Body&gt;
    &lt;/soap:Envelope&gt;"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.316.1">
     In the preceding
    </span>
    <a id="_idIndexMarker476">
    </a>
    <span class="koboSpan" id="kobo.317.1">
     code, I created the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.318.1">
      Simple Object Access Protocol
     </span>
    </strong>
    <span class="koboSpan" id="kobo.319.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.320.1">
      SOAP
     </span>
    </strong>
    <span class="koboSpan" id="kobo.321.1">
     ) request body with the input
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.322.1">
      domain,
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.323.1">
       $1
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.324.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.325.1">
     In the following code, I have used
    </span>
    <a id="_idIndexMarker477">
    </a>
    <span class="koboSpan" id="kobo.326.1">
     command expansion (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.327.1">
      $()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.328.1">
     ) to perform the HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.329.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.330.1">
     request using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.331.1">
      curl
     </span>
    </strong>
    <span class="koboSpan" id="kobo.332.1">
     and store the response in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.333.1">
       response
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.334.1">
      variable:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.335.1">
    response=$(curl -s -X POST -H "Content-type: text/xml; charset=utf-8" -H "User-agent: AutodiscoverClient" -d "$body" "https://autodiscover-s.outlook.com/autodiscover/autodiscover.svc")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.336.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.337.1">
      body
     </span>
    </strong>
    <span class="koboSpan" id="kobo.338.1">
     variable containing the SOAP request body is expanded in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.339.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.340.1">
     data.
    </span>
    <span class="koboSpan" id="kobo.340.2">
     The request is sent to the Autodiscover service for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.341.1">
      Microsoft 365.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.342.1">
     The following code checks whether the response is empty (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.343.1">
      -z
     </span>
    </strong>
    <span class="koboSpan" id="kobo.344.1">
     , zero-length) and exits if true.
    </span>
    <span class="koboSpan" id="kobo.344.2">
     An
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.345.1">
      exit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.346.1">
     code that’s
    </span>
    <a id="_idIndexMarker478">
    </a>
    <span class="koboSpan" id="kobo.347.1">
     non-zero indicates that the process terminated with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.348.1">
      an error.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.349.1">
    if [[ -z "$response" ]]; then
        echo "[-] Unable to execute request. </span><span class="koboSpan" id="kobo.349.2">Wrong domain?"
</span><span class="koboSpan" id="kobo.349.3">        exit 1
    fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.350.1">
     The following code parses the XML response to extract domain names using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.351.1">
      xmllint
     </span>
    </strong>
    <span class="koboSpan" id="kobo.352.1">
     application and stores the result in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.353.1">
       domains
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.354.1">
      variable:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.355.1">
    domains=$(echo "$response" | xmllint --xpath '//*[local-name()="Domain"]/text()' -)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.356.1">
     The following code exits if no domains are found in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.357.1">
      the response.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.358.1">
    if [[ -z "$domains" ]]; then
        echo "[-] No domains found."
</span><span class="koboSpan" id="kobo.358.2">        exit 1
    fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.359.1">
     In the following code, we print the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.360.1">
      found domains:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.361.1">
    echo -e "\n[+] Domains found:"
    echo "$domains" | tr ' ' '\n'</span></pre>
   <p>
    <span class="koboSpan" id="kobo.362.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.363.1">
      tr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.364.1">
     command substitutes the first value with the second value; in this case, a space,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.365.1">
      ' '
     </span>
    </strong>
    <span class="koboSpan" id="kobo.366.1">
     , is replaced with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.367.1">
      newline,
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.368.1">
       '\n'
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.369.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.370.1">
     The following code extracts the tenant name from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.371.1">
      found domains.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.372.1">
    tenant=$(echo "$domains" | tr ' ' '\n' | grep "onmicrosoft.com" | head -n 1 | cut -d'.' </span><span class="koboSpan" id="kobo.372.2">-f1)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.373.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.374.1">
      tenant
     </span>
    </strong>
    <span class="koboSpan" id="kobo.375.1">
     variable is assigned the result of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.376.1">
      domains
     </span>
    </strong>
    <span class="koboSpan" id="kobo.377.1">
     variable with spaces substituted with a newline (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.378.1">
      tr ' ' '\n'
     </span>
    </strong>
    <span class="koboSpan" id="kobo.379.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.379.2">
     Then, it finds (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.380.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.381.1">
     ) any line that contains
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.382.1">
      onmicrosoft.com
     </span>
    </strong>
    <span class="koboSpan" id="kobo.383.1">
     .
    </span>
    <span class="koboSpan" id="kobo.383.2">
     That data is piped to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.384.1">
      head -n 1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.385.1">
     , which selects the first line of data, then pipes the result to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.386.1">
      cut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.387.1">
     command, which essentially splits the data on the period character and selects the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.388.1">
      first field.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.389.1">
     The following
    </span>
    <a id="_idIndexMarker479">
    </a>
    <span class="koboSpan" id="kobo.390.1">
     code exits if no tenant
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.391.1">
      is found:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.392.1">
    if [[ -z "$tenant" ]]; then
        echo "[-] No tenant found."
</span><span class="koboSpan" id="kobo.392.2">        exit 1
    fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.393.1">
     The following code prints the found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.394.1">
      tenant name:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.395.1">
    echo -e "\n[+] Tenant found: \n${tenant}"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.396.1">
     The following code calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.397.1">
      check_mdi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.398.1">
     function with the tenant name.
    </span>
    <span class="koboSpan" id="kobo.398.2">
     The closing brace ends the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.399.1">
       get_domains
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.400.1">
      function.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.401.1">
    check_mdi "$tenant"
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.402.1">
     In the following code, I declare the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.403.1">
      check_mdi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.404.1">
     function to identify
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.405.1">
      MDI usage:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.406.1">
check_mdi() {</span></pre>
   <p>
    <span class="koboSpan" id="kobo.407.1">
     The following code appends the MDI domain suffix to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.408.1">
      tenant name:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.409.1">
    tenant="$1.atp.azure.com"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.410.1">
     The following code runs
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.411.1">
      dig
     </span>
    </strong>
    <span class="koboSpan" id="kobo.412.1">
     to check whether the MDI instance exists for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.413.1">
      tenant domain:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.414.1">
    if dig "$tenant" +short; then
        echo -e "\n[+] An MDI instance was found for ${tenant}!\n"
    else
        echo -e "\n[-] No MDI instance was found for ${tenant}\n"
    fi
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.415.1">
     It prints a positive message if the MDI instance is found.
    </span>
    <span class="koboSpan" id="kobo.415.2">
     Otherwise, it prints a negative message if no MDI instance is found.
    </span>
    <span class="koboSpan" id="kobo.415.3">
     The closing brace ends the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.416.1">
       check_mdi
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.417.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.418.1">
     The following code checks whether the correct number of arguments is provided and whether the first
    </span>
    <a id="_idIndexMarker480">
    </a>
    <span class="koboSpan" id="kobo.419.1">
     argument is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.420.1">
      -d
     </span>
    </strong>
    <span class="koboSpan" id="kobo.421.1">
     .
    </span>
    <span class="koboSpan" id="kobo.421.2">
     The logical
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.422.1">
      or
     </span>
    </strong>
    <span class="koboSpan" id="kobo.423.1">
     (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.424.1">
      ||
     </span>
    </strong>
    <span class="koboSpan" id="kobo.425.1">
     ) operation means if the number of command-line arguments is not equal to two, or the first argument is not equal to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.426.1">
      -d
     </span>
    </strong>
    <span class="koboSpan" id="kobo.427.1">
     , then print the usage banner
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.428.1">
      and exit.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.429.1">
if [[ $# -ne 2 || $1 != "-d" ]]; then
    # Print the usage information if the arguments are incorrect
    echo "Usage: $0 -d &lt;domain&gt;"
    exit 1
fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.430.1">
     The following code declares the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.431.1">
      domain
     </span>
    </strong>
    <span class="koboSpan" id="kobo.432.1">
     argument from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.433.1">
      user input.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.434.1">
domain=$2</span></pre>
   <p>
    <span class="koboSpan" id="kobo.435.1">
     The following code calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.436.1">
      get_domains
     </span>
    </strong>
    <span class="koboSpan" id="kobo.437.1">
     function with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.438.1">
      provided domain.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.439.1">
get_domains "$domain"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.440.1">
     If you run this script with a well-known domain, you will find a lesser-known domain in the output.
    </span>
    <span class="koboSpan" id="kobo.440.2">
     Essentially, this script helps you cross-reference domains owned by the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.441.1">
      same entity:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer083">
     <span class="koboSpan" id="kobo.442.1">
      <img alt="Figure 8.6 – Running check_mdi on the cdw.com domain" src="image/B22229_08_6.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.443.1">
     Figure 8.6 – Running check_mdi on the cdw.com domain
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.444.1">
     The script output shown in the preceding figure demonstrates how our Bash script discovered many
    </span>
    <a id="_idIndexMarker481">
    </a>
    <span class="koboSpan" id="kobo.445.1">
     subdomains related to the target domain, greatly expanding our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.446.1">
      target footprint.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-146">
    <a id="_idTextAnchor234">
    </a>
    <span class="koboSpan" id="kobo.447.1">
     Automating subdomain enumeration with Bash
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.448.1">
     Next, I’m going to share some
    </span>
    <a id="_idIndexMarker482">
    </a>
    <span class="koboSpan" id="kobo.449.1">
     of the Bash functions I keep in my
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.450.1">
      .bashrc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.451.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.451.2">
     I use these functions on external pentests to allow me to quickly perform common reconnaissance tasks that I run before port and vulnerability scanning.
    </span>
    <span class="koboSpan" id="kobo.451.3">
     First, I will list the code in small sections and explain them as I go.
    </span>
    <span class="koboSpan" id="kobo.451.4">
     Finally, I’ll show you how I use these functions together to enumerate DNS and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.452.1">
      the output.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.453.1">
     The first function is named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.454.1">
      mdi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.455.1">
     and you’ve already seen it in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.456.1">
      ch08_check_mdi.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.457.1">
     script shown earlier in this chapter.
    </span>
    <span class="koboSpan" id="kobo.457.2">
     I’m going to include only the part that has changed from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.458.1">
      ch08_check_mdi.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.459.1">
     .
    </span>
    <span class="koboSpan" id="kobo.459.2">
     The example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.460.1">
      ch08_mdi_function.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.461.1">
     file in this chapter’s folder in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.462.1">
      GitHub repository:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.463.1">
mdi() {
    # This function takes a domain as input and checks MDI and returns domains using the same tenant.
</span><span class="koboSpan" id="kobo.463.2">    while IFS= read -r line; do
        body="&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.464.1">
     In the preceding code, I start by declaring a function named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.465.1">
      mdi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.466.1">
     .
    </span>
    <span class="koboSpan" id="kobo.466.2">
     I nested all of the earlier code inside a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.467.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.468.1">
     loop, which reads from standard input (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.469.1">
      stdin
     </span>
    </strong>
    <span class="koboSpan" id="kobo.470.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.470.2">
     This is required to read piped input, allowing us to pipe data between our functions.
    </span>
    <span class="koboSpan" id="kobo.470.3">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.471.1">
      IFS=
     </span>
    </strong>
    <span class="koboSpan" id="kobo.472.1">
     code preserves newlines, which is necessary when your input contains multiple lines.
    </span>
    <span class="koboSpan" id="kobo.472.2">
     You can pipe a single domain name or a line-separated list of domain names to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.473.1">
      this function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.474.1">
     The next function is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.475.1">
      rootdomain
     </span>
    </strong>
    <span class="koboSpan" id="kobo.476.1">
     .
    </span>
    <span class="koboSpan" id="kobo.476.2">
     This function takes a subdomain as input and returns the root domain.
    </span>
    <span class="koboSpan" id="kobo.476.3">
     For example, if you provide an input of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.477.1">
      www.example.com
     </span>
    </strong>
    <span class="koboSpan" id="kobo.478.1">
     , the output will be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.479.1">
      example.com
     </span>
    </strong>
    <span class="koboSpan" id="kobo.480.1">
     .
    </span>
    <span class="koboSpan" id="kobo.480.2">
     This function is used to take a root domain from a subdomain, which I can then send to other functions to find more subdomains.
    </span>
    <span class="koboSpan" id="kobo.480.3">
     The example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.481.1">
      ch08_rootdomain_function.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.482.1">
     file in this chapter’s folder in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.483.1">
      GitHub repository:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.484.1">
rootdomain() {
    # This function takes a subdomain as input and returns the root domain.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.485.1">
     In the preceding code, I first declare the function name, followed by a comment explaining the purpose, input, and output of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.486.1">
      the script.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.487.1">
    while IFS= read -r line; do</span></pre>
   <p>
    <span class="koboSpan" id="kobo.488.1">
     This line starts a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.489.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.490.1">
     loop that reads input line by line.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.491.1">
      IFS=
     </span>
    </strong>
    <span class="koboSpan" id="kobo.492.1">
     sets the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.493.1">
      internal field separator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.494.1">
     to nothing, which prevents leading/trailing
    </span>
    <a id="_idIndexMarker483">
    </a>
    <span class="koboSpan" id="kobo.495.1">
     whitespace from being trimmed.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.496.1">
      read -r
     </span>
    </strong>
    <span class="koboSpan" id="kobo.497.1">
     reads a line from standard input into the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.498.1">
      variable line.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.499.1">
            echo "$line" | awk -F. </span><span class="koboSpan" id="kobo.499.2">'</span></pre>
   <p>
    <span class="koboSpan" id="kobo.500.1">
     This line echoes the current line (subdomain) and pipes it to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.501.1">
      awk
     </span>
    </strong>
    <span class="koboSpan" id="kobo.502.1">
     .
    </span>
    <span class="koboSpan" id="kobo.502.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.503.1">
      -F.
     </span>
    </strong>
    <span class="koboSpan" id="kobo.504.1">
     option tells
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.505.1">
      awk
     </span>
    </strong>
    <span class="koboSpan" id="kobo.506.1">
     to use the
    </span>
    <a id="_idIndexMarker484">
    </a>
    <span class="koboSpan" id="kobo.507.1">
     period (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.508.1">
      .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.509.1">
     ) as the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.510.1">
      field separator.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.511.1">
            {</span></pre>
   <p>
    <span class="koboSpan" id="kobo.512.1">
     This opens the block of the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.513.1">
       awk
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.514.1">
      script.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.515.1">
                n = split($0, parts, ".");</span></pre>
   <p>
    <span class="koboSpan" id="kobo.516.1">
     This line splits the current line (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.517.1">
      $0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.518.1">
     ) into an array named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.519.1">
      parts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.520.1">
     using the period (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.521.1">
      .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.522.1">
     ) as the delimiter.
    </span>
    <span class="koboSpan" id="kobo.522.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.523.1">
      n
     </span>
    </strong>
    <span class="koboSpan" id="kobo.524.1">
     variable stores the number of elements in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.525.1">
      the array.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.526.1">
                if (n &gt;= 3 &amp;&amp; (parts[n-1] ~ /^(com|net|org|co|gov|edu|mil|int)$/ &amp;&amp; parts[n] ~ /^[a-z]{2}$/)) {</span></pre>
   <p>
    <span class="koboSpan" id="kobo.527.1">
     This condition checks whether the domain has at least three parts and whether the second-to-last part matches a common second-level domain (e.g.,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.528.1">
      com
     </span>
    </strong>
    <span class="koboSpan" id="kobo.529.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.530.1">
      net
     </span>
    </strong>
    <span class="koboSpan" id="kobo.531.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.532.1">
      org
     </span>
    </strong>
    <span class="koboSpan" id="kobo.533.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.534.1">
      co
     </span>
    </strong>
    <span class="koboSpan" id="kobo.535.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.536.1">
      gov
     </span>
    </strong>
    <span class="koboSpan" id="kobo.537.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.538.1">
      edu
     </span>
    </strong>
    <span class="koboSpan" id="kobo.539.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.540.1">
      mil
     </span>
    </strong>
    <span class="koboSpan" id="kobo.541.1">
     , or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.542.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.543.1">
     ) followed by a two-letter country code (e.g.,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.544.1">
      uk
     </span>
    </strong>
    <span class="koboSpan" id="kobo.545.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.546.1">
      us
     </span>
    </strong>
    <span class="koboSpan" id="kobo.547.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.548.1">
      or
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.549.1">
       de
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.550.1">
      ).
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.551.1">
                    print parts[n-2] "." </span><span class="koboSpan" id="kobo.551.2">parts[n-1] "." </span><span class="koboSpan" id="kobo.551.3">parts[n];</span></pre>
   <p>
    <span class="koboSpan" id="kobo.552.1">
     If the condition is true, this line prints the root domain, which consists of the third-to-last, second-to-last, and last parts of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.553.1">
      the array.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.554.1">
                } else if (n &gt;= 2) {</span></pre>
   <p>
    <span class="koboSpan" id="kobo.555.1">
     This condition checks whether the domain has at least two parts (
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.556.1">
      e.g.,
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.557.1">
       example.com
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.558.1">
      ).
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.559.1">
                    print parts[n-1] "." </span><span class="koboSpan" id="kobo.559.2">parts[n];</span></pre>
   <p>
    <span class="koboSpan" id="kobo.560.1">
     If the condition is true, this line prints the root domain, which consists of the second-to-last and last parts of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.561.1">
      the array.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.562.1">
                } else {
                    print $0;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.563.1">
     If none of the preceding conditions are met (e.g., the input is a single-label domain), this line prints the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.564.1">
      original input.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.565.1">
                }
            }'</span></pre>
   <p>
    <span class="koboSpan" id="kobo.566.1">
     The preceding code closes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.567.1">
      if
     </span>
    </strong>
    <span class="koboSpan" id="kobo.568.1">
     block, then closes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.569.1">
      awk
     </span>
    </strong>
    <span class="koboSpan" id="kobo.570.1">
     block.
    </span>
    <span class="koboSpan" id="kobo.570.2">
     Notice that when the curly bracket
    </span>
    <a id="_idIndexMarker485">
    </a>
    <span class="koboSpan" id="kobo.571.1">
     closes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.572.1">
      if
     </span>
    </strong>
    <span class="koboSpan" id="kobo.573.1">
     block, there is no
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.574.1">
      fi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.575.1">
     keyword like a Bash
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.576.1">
      if
     </span>
    </strong>
    <span class="koboSpan" id="kobo.577.1">
     statement.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.578.1">
      awk
     </span>
    </strong>
    <span class="koboSpan" id="kobo.579.1">
     has a slightly different syntax for
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.580.1">
       if
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.581.1">
      blocks.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.582.1">
    done</span></pre>
   <p>
    <span class="koboSpan" id="kobo.583.1">
     This closes the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.584.1">
       while
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.585.1">
      loop.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.586.1">
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.587.1">
     This bracket closes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.588.1">
      the function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.589.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.590.1">
      resolve
     </span>
    </strong>
    <span class="koboSpan" id="kobo.591.1">
     function takes a domain name as input and returns an IP address.
    </span>
    <span class="koboSpan" id="kobo.591.2">
     The example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.592.1">
      ch08_resolve_function.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.593.1">
     file in this chapter’s folder in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.594.1">
      GitHub repository.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.595.1">
resolve() {
    # This function takes a domain as input and returns the IP address.</span></pre>
   <p>
    <span class="koboSpan" id="kobo.596.1">
     This code is the start of the function and a comment that describes what the function does: it takes a domain as input and returns its corresponding
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.597.1">
      IP address.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.598.1">
    while IFS= read -r line; do</span></pre>
   <p>
    <span class="koboSpan" id="kobo.599.1">
     This line starts a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.600.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.601.1">
     loop that reads input line by line.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.602.1">
      IFS=
     </span>
    </strong>
    <span class="koboSpan" id="kobo.603.1">
     sets the internal field separator to nothing, which prevents leading/trailing whitespace from being trimmed.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.604.1">
      read -r
     </span>
    </strong>
    <span class="koboSpan" id="kobo.605.1">
     reads a line from standard input into the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.606.1">
      variable line.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.607.1">
            dig +short "$line" | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -n 1</span></pre>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.608.1">
      dig
     </span>
    </strong>
    <span class="koboSpan" id="kobo.609.1">
     is a DNS lookup utility.
    </span>
    <span class="koboSpan" id="kobo.609.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.610.1">
      +short
     </span>
    </strong>
    <span class="koboSpan" id="kobo.611.1">
     option makes the output concise by only printing the IP addresses or
    </span>
    <a id="_idIndexMarker486">
    </a>
    <span class="koboSpan" id="kobo.612.1">
     CNAME records.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.613.1">
      $line
     </span>
    </strong>
    <span class="koboSpan" id="kobo.614.1">
     is the domain name read
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.615.1">
      from input.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.616.1">
    done
    return 0
}</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.617.1">
      done
     </span>
    </strong>
    <span class="koboSpan" id="kobo.618.1">
     closes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.619.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.620.1">
     loop’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.621.1">
      do
     </span>
    </strong>
    <span class="koboSpan" id="kobo.622.1">
     block.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.623.1">
      return 0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.624.1">
     signifies to a calling script or function that the script
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.625.1">
      completed successfully.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.626.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.627.1">
      org
     </span>
    </strong>
    <span class="koboSpan" id="kobo.628.1">
     function takes
    </span>
    <a id="_idIndexMarker487">
    </a>
    <span class="koboSpan" id="kobo.629.1">
     an IP address as input and returns the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.630.1">
      OrgName
     </span>
    </strong>
    <span class="koboSpan" id="kobo.631.1">
     value found in the Whois output.
    </span>
    <span class="koboSpan" id="kobo.631.2">
     This information tells us who owns the network.
    </span>
    <span class="koboSpan" id="kobo.631.3">
     The example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.632.1">
      ch08_org_function.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.633.1">
     file in this chapter’s folder in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.634.1">
      GitHub repository:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.635.1">
org() {
    # This function takes an IP address as input and returns the organization name that owns the IP block.
</span><span class="koboSpan" id="kobo.635.2">    while IFS= read -r line; do
        whois "$line" | grep OrgName | tr -s ' ' | cut -d ' ' -f 2-
    done
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.636.1">
     The start of the function through to the start of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.637.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.638.1">
     loop is virtually the same as in previous scripts.
    </span>
    <span class="koboSpan" id="kobo.638.2">
     The line beginning with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.639.1">
      whois
     </span>
    </strong>
    <span class="koboSpan" id="kobo.640.1">
     runs the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.641.1">
      whois
     </span>
    </strong>
    <span class="koboSpan" id="kobo.642.1">
     command using the IP address sent as input to the function, runs
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.643.1">
      grep
     </span>
    </strong>
    <span class="koboSpan" id="kobo.644.1">
     to find the line containing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.645.1">
      OrgName
     </span>
    </strong>
    <span class="koboSpan" id="kobo.646.1">
     , runs the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.647.1">
      tr -s ' '
     </span>
    </strong>
    <span class="koboSpan" id="kobo.648.1">
     command to squeeze multiple spaces into a single space, and then pipes the output to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.649.1">
      cut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.650.1">
     command, which specifies a space as a delimiter and selects the second field through the end of input.
    </span>
    <span class="koboSpan" id="kobo.650.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.651.1">
      tr
     </span>
    </strong>
    <span class="koboSpan" id="kobo.652.1">
     program is very handy for squeezing
    </span>
    <a id="_idIndexMarker488">
    </a>
    <span class="koboSpan" id="kobo.653.1">
     multiple spaces into a single space, but you can also use it to replace one character with another.
    </span>
    <span class="koboSpan" id="kobo.653.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.654.1">
      cut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.655.1">
     program specifies a delimiter (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.656.1">
      -d
     </span>
    </strong>
    <span class="koboSpan" id="kobo.657.1">
     ) followed by the field
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.658.1">
      to cut.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.659.1">
     The last function ties the other functions together.
    </span>
    <span class="koboSpan" id="kobo.659.2">
     It performs domain and subdomain enumeration and prints subdomains, the IP address, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.660.1">
      OrgName
     </span>
    </strong>
    <span class="koboSpan" id="kobo.661.1">
     .
    </span>
    <span class="koboSpan" id="kobo.661.2">
     It will also find any related root domains and enumerate their subdomains if the input domain is part of a Microsoft 365 tenant with MDI.
    </span>
    <span class="koboSpan" id="kobo.661.3">
     This will significantly enhance subdomain discovery.
    </span>
    <span class="koboSpan" id="kobo.661.4">
     I tested the Chaos API alone with a particular domain and it returned 553 live subdomains.
    </span>
    <span class="koboSpan" id="kobo.661.5">
     When I ran this function and used MDI results to expand the scope to related domains hosted by the same company, it returned 3,682
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.662.1">
      live subdomains.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.663.1">
     The example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.664.1">
      ch08_dnsrecon_function.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.665.1">
     file in this chapter’s folder in the GitHub repository.
    </span>
    <span class="koboSpan" id="kobo.665.2">
     The script requires a ProjectDiscovery Chaos API key (
    </span>
    <a href="https://chaos.projectdiscovery.io/">
     <span class="koboSpan" id="kobo.666.1">
      https://chaos.projectdiscovery.io/
     </span>
    </a>
    <span class="koboSpan" id="kobo.667.1">
     ), which
    </span>
    <a id="_idIndexMarker489">
    </a>
    <span class="koboSpan" id="kobo.668.1">
     can be obtained for free at the time of writing.
    </span>
    <span class="koboSpan" id="kobo.668.2">
     Chaos is the most complete source of DNS data that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.669.1">
      I’ve found:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.670.1">
dnsrecon() {
    # Check if the correct number of arguments is provided
    if [[ $# -ne 1 ]]; then
        echo "You didn't provide a domain as input."
</span><span class="koboSpan" id="kobo.670.2">        echo "Usage: $0 [domain]"
        exit 1
    fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.671.1">
     Print the usage information and exit if one command-line argument is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.672.1">
      not included.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.673.1">
    if [[ -z "$CHAOS_KEY" ]]; then
        echo "No chaos API key found. </span><span class="koboSpan" id="kobo.673.2">Set env CHAOS_KEY."
</span><span class="koboSpan" id="kobo.673.3">        exit 1
    fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.674.1">
     Check whether the Chaos API key is set in an environment variable.
    </span>
    <span class="koboSpan" id="kobo.674.2">
     You should have a line in your
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.675.1">
      .bashrc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.676.1">
     file
    </span>
    <a id="_idIndexMarker490">
    </a>
    <span class="koboSpan" id="kobo.677.1">
     that looks like
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.678.1">
      CHAOS_KEY=[key value]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.679.1">
     .
    </span>
    <span class="koboSpan" id="kobo.679.2">
     After you edit your
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.680.1">
      .bashrc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.681.1">
     file to add the API key, you’ll need to make it recognized using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.682.1">
      source ~/.
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.683.1">
       bashrc
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.684.1">
      command.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.685.1">
    local domain=$1
    local domains=''
    local roots=''</span></pre>
   <p>
    <span class="koboSpan" id="kobo.686.1">
     Here, I have declared local variables.
    </span>
    <span class="koboSpan" id="kobo.686.2">
     It’s not strictly necessary to declare the variable ahead of its use, I did so based on personal preference.
    </span>
    <span class="koboSpan" id="kobo.686.3">
     Declaring variables as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.687.1">
      local
     </span>
    </strong>
    <span class="koboSpan" id="kobo.688.1">
     ensures that their scope is limited to the function in which they are defined, which helps to avoid potential conflicts with global variables or variables in other functions.
    </span>
    <span class="koboSpan" id="kobo.688.2">
     This is critical when the variable is in a function in your
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.689.1">
      .bashrc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.690.1">
     file to prevent collisions with other variables since these functions are available to everything in your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.691.1">
      Bash shell.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.692.1">
    local mdi_result=$(mdi &lt;&lt;&lt; "$domain")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.693.1">
     Here, I passed the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.694.1">
      domain
     </span>
    </strong>
    <span class="koboSpan" id="kobo.695.1">
     variable to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.696.1">
      mdi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.697.1">
     function to get the list of related domains.
    </span>
    <span class="koboSpan" id="kobo.697.2">
     Because the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.698.1">
      mdi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.699.1">
     function is designed to accept input from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.700.1">
      stdin
     </span>
    </strong>
    <span class="koboSpan" id="kobo.701.1">
     (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.702.1">
      echo example.com | mdi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.703.1">
     ) instead of being passed as a function argument (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.704.1">
      mdi example.com
     </span>
    </strong>
    <span class="koboSpan" id="kobo.705.1">
     ), it must be called as shown with three
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.706.1">
      &lt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.707.1">
     characters.
    </span>
    <span class="koboSpan" id="kobo.707.2">
     In Bash,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.708.1">
      &lt;&lt;&lt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.709.1">
     is known as the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.710.1">
      here-string
     </span>
    </strong>
    <span class="koboSpan" id="kobo.711.1">
     operator.
    </span>
    <span class="koboSpan" id="kobo.711.2">
     It is used to pass a string directly as input to a command, rather than reading from a file
    </span>
    <a id="_idIndexMarker491">
    </a>
    <span class="koboSpan" id="kobo.712.1">
     or standard input.
    </span>
    <span class="koboSpan" id="kobo.712.2">
     This operator essentially provides a quick way to feed a single line of text to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.713.1">
      a command.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.714.1">
    if [[ -z "$mdi_result" ]]; then
        domains=$(chaos -silent -d "$domain")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.715.1">
     If no domains are returned from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.716.1">
      mdi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.717.1">
     function, pass the input domain directly to the Chaos API and assign
    </span>
    <a id="_idIndexMarker492">
    </a>
    <span class="koboSpan" id="kobo.718.1">
     the output to the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.719.1">
       domains
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.720.1">
      variable.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.721.1">
    else
        echo "$mdi_result" | while IFS= read -r line; do
            root=$(rootdomain &lt;&lt;&lt; "$line")
            chaos_domains=$(chaos -silent -d "$root")
            domains=$(echo -e "$domains\n$chaos_domains")
        done</span></pre>
   <p>
    <span class="koboSpan" id="kobo.722.1">
     This part pipes the content of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.723.1">
      mdi_result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.724.1">
     variable line by line to the code inside the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.725.1">
      do
     </span>
    </strong>
    <span class="koboSpan" id="kobo.726.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.727.1">
      done
     </span>
    </strong>
    <span class="koboSpan" id="kobo.728.1">
     block.
    </span>
    <span class="koboSpan" id="kobo.728.2">
     The line of data (a domain) is passed to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.729.1">
      rootdomain
     </span>
    </strong>
    <span class="koboSpan" id="kobo.730.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.730.2">
     If the line of data is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.731.1">
      www.example.com
     </span>
    </strong>
    <span class="koboSpan" id="kobo.732.1">
     , this function would return
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.733.1">
      example.com
     </span>
    </strong>
    <span class="koboSpan" id="kobo.734.1">
     .
    </span>
    <span class="koboSpan" id="kobo.734.2">
     It then passes this root domain to the Chaos API call and assigns the result to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.735.1">
      chaos_domains
     </span>
    </strong>
    <span class="koboSpan" id="kobo.736.1">
     variable.
    </span>
    <span class="koboSpan" id="kobo.736.2">
     Finally, the list of subdomains returned from the API call is appended to the list of domains in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.737.1">
       domains
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.738.1">
      variable.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.739.1">
        domains=$(echo "$domains" | grep . </span><span class="koboSpan" id="kobo.739.2">| grep -v \* | sort -u)
    fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.740.1">
     This section of code ensures that blank lines are removed (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.741.1">
      grep .
     </span>
    </strong>
    <span class="koboSpan" id="kobo.742.1">
     returns non-blank lines), removes any wildcard domains (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.743.1">
      grep -v \*
     </span>
    </strong>
    <span class="koboSpan" id="kobo.744.1">
     ), and then removes duplicates (
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.745.1">
       sort -u
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.746.1">
      ).
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.747.1">
    echo "$domains" | while IFS= read -r line; do</span></pre>
   <p>
    <span class="koboSpan" id="kobo.748.1">
     This code passes each line of data in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.749.1">
      domains
     </span>
    </strong>
    <span class="koboSpan" id="kobo.750.1">
     variable to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.751.1">
      do
     </span>
    </strong>
    <span class="koboSpan" id="kobo.752.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.753.1">
      done
     </span>
    </strong>
    <span class="koboSpan" id="kobo.754.1">
     code block.
    </span>
    <span class="koboSpan" id="kobo.754.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.755.1">
      IFS=
     </span>
    </strong>
    <span class="koboSpan" id="kobo.756.1">
     part ensures that line endings
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.757.1">
      remain intact.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.758.1">
        ip=$(resolve &lt;&lt;&lt; "$line")
        if [[ -z "$ip" ]]; then
            continue
        fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.759.1">
     This code passes each domain in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.760.1">
      domains
     </span>
    </strong>
    <span class="koboSpan" id="kobo.761.1">
     variable to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.762.1">
      resolve
     </span>
    </strong>
    <span class="koboSpan" id="kobo.763.1">
     function, which returns an IP address and stores it in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.764.1">
      ip
     </span>
    </strong>
    <span class="koboSpan" id="kobo.765.1">
     variable.
    </span>
    <span class="koboSpan" id="kobo.765.2">
     If the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.766.1">
      ip
     </span>
    </strong>
    <span class="koboSpan" id="kobo.767.1">
     variable is zero-length,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.768.1">
      -z
     </span>
    </strong>
    <span class="koboSpan" id="kobo.769.1">
     (the domain name could not be resolved to an IP address), it returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.770.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.771.1">
     and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.772.1">
      continue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.773.1">
     keyword
    </span>
    <a id="_idIndexMarker493">
    </a>
    <span class="koboSpan" id="kobo.774.1">
     short-circuits the current iteration of the loop and skips to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.775.1">
      the next.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.776.1">
        orgname=$(org &lt;&lt;&lt; "$ip")
        echo "$line;$ip;$orgname"
    done
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.777.1">
     If the domain name has successfully resolved to an IP address, the data is printed as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.778.1">
      Domain;IP;Org
     </span>
    </strong>
    <span class="koboSpan" id="kobo.779.1">
     .
    </span>
    <span class="koboSpan" id="kobo.779.2">
     I chose semicolons for the field separator because the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.780.1">
      org
     </span>
    </strong>
    <span class="koboSpan" id="kobo.781.1">
     value may contain spaces
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.782.1">
      and commas.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.783.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.784.1">
      dnsrecon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.785.1">
     function is called on the command line as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.786.1">
      dnsrecon example.com
     </span>
    </strong>
    <span class="koboSpan" id="kobo.787.1">
     .
    </span>
    <span class="koboSpan" id="kobo.787.2">
     The following is an example of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.788.1">
      the output:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer084">
     <span class="koboSpan" id="kobo.789.1">
      <img alt="Figure 8.7 – The dnsrecon function output" src="image/B22229_08_7.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.790.1">
     Figure 8.7 – The dnsrecon function output
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.791.1">
     The output in the preceding figure shows that our Bash script has provided us with more targets, and contains information that we can use to determine whether the discovered domains are in scope
    </span>
    <a id="_idIndexMarker494">
    </a>
    <span class="koboSpan" id="kobo.792.1">
     by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.793.1">
      IP address.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.794.1">
     Next, we need to discuss how web applications use domain names to determine which application to serve to a website visitor.
    </span>
    <span class="koboSpan" id="kobo.794.2">
     This is critical to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.795.1">
      your success.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-147">
    <a id="_idTextAnchor235">
    </a>
    <span class="koboSpan" id="kobo.796.1">
     Using Bash to identify web applications
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.797.1">
     As a consultant pentester who is
    </span>
    <a id="_idIndexMarker495">
    </a>
    <span class="koboSpan" id="kobo.798.1">
     provided a list of IP or network addresses by an external customer, you may fall into a bad habit of just testing defined IP or network addresses and not performing enough OSINT to discover all domain names.
    </span>
    <span class="koboSpan" id="kobo.798.2">
     I did this myself when I was a junior pentester and have also witnessed this from people I have mentored.
    </span>
    <span class="koboSpan" id="kobo.798.3">
     The reason why this is not ideal is because of how web applications behave when requesting a website using an IP address versus a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.799.1">
      domain name.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.800.1">
     A web server hosting multiple applications, load balancer, or reverse proxy will return the default site when an IP address is in the URL or HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.801.1">
      HOST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.802.1">
     header.
    </span>
    <span class="koboSpan" id="kobo.802.2">
     Unbeknown to you, there may be additional websites hosted on that IP address and you absolutely will miss out on finding vulnerable applications if you don’t perform DNS enumeration and test applicable domain names.
    </span>
    <span class="koboSpan" id="kobo.802.3">
     You can read more about the HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.803.1">
      HOST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.804.1">
     header
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.805.1">
      at
     </span>
    </span>
    <a href="https://portswigger.net/web-security/host-header">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.806.1">
       https://portswigger.net/web-security/host-header
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.807.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.808.1">
     Here’s a relevant example.
    </span>
    <span class="koboSpan" id="kobo.808.2">
     OWASP Juice Shop is an intentionally vulnerable website.
    </span>
    <span class="koboSpan" id="kobo.808.3">
     You can find an example hosted at
    </span>
    <a href="https://demo.owasp-juice.shop/#/">
     <span class="koboSpan" id="kobo.809.1">
      https://demo.owasp-juice.shop/#/
     </span>
    </a>
    <span class="koboSpan" id="kobo.810.1">
     .
    </span>
    <span class="koboSpan" id="kobo.810.2">
     If you ping that hostname, you see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.811.1">
      the
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker496">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.812.1">
      following:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer085">
     <span class="koboSpan" id="kobo.813.1">
      <img alt="Figure 8.8 – Pinging OWASP Juice Shop demo" src="image/B22229_08_8.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.814.1">
     Figure 8.8 – Pinging OWASP Juice Shop demo
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.815.1">
     If you were provided with the IP address
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.816.1">
      81.169.145.156
     </span>
    </strong>
    <span class="koboSpan" id="kobo.817.1">
     in scope and scanned that IP and didn’t perform subdomain enumeration, you would visit that site in your browser and see
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.818.1">
       Not Found
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.819.1">
      :
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer086">
     <span class="koboSpan" id="kobo.820.1">
      <img alt="Figure 8.9 – Visiting a website via the IP address" src="image/B22229_08_9.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.821.1">
     Figure 8.9 – Visiting a website via the IP address
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.822.1">
     In the preceding figure, I have highlighted the relevant parts for you.
    </span>
    <span class="koboSpan" id="kobo.822.2">
     I requested a web page via the IP address.
    </span>
    <span class="koboSpan" id="kobo.822.3">
     You may see this response and think that this IP address and port aren’t interesting and move on.
    </span>
    <span class="koboSpan" id="kobo.822.4">
     However, if you visit the domain name, you see the following website, which
    </span>
    <a id="_idIndexMarker497">
    </a>
    <span class="koboSpan" id="kobo.823.1">
     contains
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.824.1">
      many vulnerabilities:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer087">
     <span class="koboSpan" id="kobo.825.1">
      <img alt="Figure 8.10 – OWASP Juice Shop, a vulnerable web application" src="image/B22229_08_10.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.826.1">
     Figure 8.10 – OWASP Juice Shop, a vulnerable web application
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.827.1">
     Before you start scanning your scoped IP addresses or network addresses, take the time to fully enumerate DNS first using the tools and techniques shown next.
    </span>
    <span class="koboSpan" id="kobo.827.2">
     Then, append the discovered domain names that resolve to the scoped IP addresses to the end of your scope file.
    </span>
    <span class="koboSpan" id="kobo.827.3">
     I can’t stress enough how important this is.
    </span>
    <span class="koboSpan" id="kobo.827.4">
     It could very well be the difference between a zero-finding pentest report (not to mention the risk of the customer getting breached due to your oversight) and finding high-impact vulnerabilities.
    </span>
    <span class="koboSpan" id="kobo.827.5">
     If you simply paste the list of network or IP addresses into a vulnerability scanner and then think there’s nothing to exploit based on the scan results, you will overlook
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.828.1">
      exploitable findings.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.829.1">
     Now that you have a better understanding of how web applications use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.830.1">
      HOST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.831.1">
     header, in the next section, we’ll examine how to discover the application root or subdomains served by a web server on any particular IP address.
    </span>
    <span class="koboSpan" id="kobo.831.2">
     Having this information will be critical to our success when scanning IP or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.832.1">
      network addresses.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-148">
    <a id="_idTextAnchor236">
    </a>
    <span class="koboSpan" id="kobo.833.1">
     Using Bash for certificate enumeration
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.834.1">
     I performed this one external network pentest that had many thousands of live IP addresses in scope.
    </span>
    <span class="koboSpan" id="kobo.834.2">
     One of the problems I ran into was that I was given large network blocks and needed to take the live IP addresses and discover hostnames before I could properly scan the web servers.
    </span>
    <span class="koboSpan" id="kobo.834.3">
     Remember
    </span>
    <a id="_idIndexMarker498">
    </a>
    <span class="koboSpan" id="kobo.835.1">
     earlier in this chapter where I demonstrated how the web page you see may be different when you request the website via IP address
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.836.1">
      versus hostname?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.837.1">
     Many thousands of those IP addresses were resolved to random subdomains in DNS, and they were usually proxy servers placed in front of a server pool.
    </span>
    <span class="koboSpan" id="kobo.837.2">
     We also knew that the customer was
    </span>
    <a id="_idIndexMarker499">
    </a>
    <span class="koboSpan" id="kobo.838.1">
     using a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.839.1">
      content delivery network
     </span>
    </strong>
    <span class="koboSpan" id="kobo.840.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.841.1">
      CDN
     </span>
    </strong>
    <span class="koboSpan" id="kobo.842.1">
     ) in front of their websites, and traffic was filtered by a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.843.1">
      web application firewall
     </span>
    </strong>
    <span class="koboSpan" id="kobo.844.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.845.1">
      WAF
     </span>
    </strong>
    <span class="koboSpan" id="kobo.846.1">
     ), which blocked attempts to
    </span>
    <a id="_idIndexMarker500">
    </a>
    <span class="koboSpan" id="kobo.847.1">
     scan the sites.
    </span>
    <span class="koboSpan" id="kobo.847.2">
     Furthermore, if we requested a website via domain name, the domain names resolved to an IP address residing on the CDN and the CDN IP addresses were not in scope so we couldn’t
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.848.1">
      attack them.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.849.1">
     Fortunately for me, the customer wasn’t filtering incoming traffic to allow only source IP addresses of the CDN provider.
    </span>
    <span class="koboSpan" id="kobo.849.2">
     At that point, what I needed to do was discover which website was being hosted on each IP address and then override DNS so that I could manually map domain names to IP addresses.
    </span>
    <span class="koboSpan" id="kobo.849.3">
     This would allow me to access the web applications directly.
    </span>
    <span class="koboSpan" id="kobo.849.4">
     I came up with a crafty way to discover which websites were hosted on those IP addresses and bypass the CDN WAFs at the same time.
    </span>
    <span class="koboSpan" id="kobo.849.5">
     I found that the Nuclei (
    </span>
    <a href="https://github.com/projectdiscovery/nuclei">
     <span class="koboSpan" id="kobo.850.1">
      https://github.com/projectdiscovery/nuclei
     </span>
    </a>
    <span class="koboSpan" id="kobo.851.1">
     ) vulnerability scanner has a template for discovering DNS names
    </span>
    <a id="_idIndexMarker501">
    </a>
    <span class="koboSpan" id="kobo.852.1">
     associated with
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.853.1">
      Transport Layer Security
     </span>
    </strong>
    <span class="koboSpan" id="kobo.854.1">
     (
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.855.1">
       TLS
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.856.1">
      ) certificates.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.857.1">
     TLS certificates are digital certificates that authenticate the identity of a website and enable an encrypted connection.
    </span>
    <span class="koboSpan" id="kobo.857.2">
     They contain information about the certificate holder, the certificate’s public key, and the
    </span>
    <a id="_idIndexMarker502">
    </a>
    <span class="koboSpan" id="kobo.858.1">
     digital signature of the issuing
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.859.1">
      certificate authority
     </span>
    </strong>
    <span class="koboSpan" id="kobo.860.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.861.1">
      CA
     </span>
    </strong>
    <span class="koboSpan" id="kobo.862.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.862.2">
     The TLS
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.863.1">
      Subject Alternative Name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.864.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.865.1">
      SAN
     </span>
    </strong>
    <span class="koboSpan" id="kobo.866.1">
     ) is an extension to the X.509 specification that
    </span>
    <a id="_idIndexMarker503">
    </a>
    <span class="koboSpan" id="kobo.867.1">
     allows users to specify additional hostnames for a single SSL/TLS certificate.
    </span>
    <span class="koboSpan" id="kobo.867.2">
     This means a single certificate can secure multiple domains and subdomains, simplifying certificate management and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.868.1">
      reducing costs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.869.1">
     The Nuclei vulnerability scanner has a scan template that extracts TLS SANs from the digital certificate.
    </span>
    <span class="koboSpan" id="kobo.869.2">
     First, I scanned the list of live IP addresses with Nuclei.
    </span>
    <span class="koboSpan" id="kobo.869.3">
     Here’s an example of using the Nuclei
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.870.1">
      ssl-dns-names
     </span>
    </strong>
    <span class="koboSpan" id="kobo.871.1">
     template to scan a network address that was in scope for the
    </span>
    <a id="_idIndexMarker504">
    </a>
    <span class="koboSpan" id="kobo.872.1">
     Hyatt Hotels bug bounty program (
    </span>
    <a href="https://hackerone.com/hyatt/policy_scopes">
     <span class="koboSpan" id="kobo.873.1">
      https://hackerone.com/hyatt/policy_scopes
     </span>
    </a>
    <span class="koboSpan" id="kobo.874.1">
     ) at the time
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.875.1">
      of writing:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer088">
     <span class="koboSpan" id="kobo.876.1">
      <img alt="Figure 8.11 – Scanning a network for TLS certificate SANs" src="image/B22229_08_11.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.877.1">
     Figure 8.11 – Scanning a network for TLS certificate SANs
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.878.1">
     Make sure you add the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.879.1">
      -o [filename]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.880.1">
     option to the Nuclei scan command seen in
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.881.1">
       Figure 8
      </span>
     </em>
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.882.1">
      .11
     </span>
    </em>
    <span class="koboSpan" id="kobo.883.1">
     to save the output to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.884.1">
      a file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.885.1">
     Now that we have this output, the next step is to clean it up and reformat it for our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.886.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.887.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.887.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.888.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.889.1">
     file is a simple text file that maps hostnames to IP addresses.
    </span>
    <span class="koboSpan" id="kobo.889.2">
     It’s an essential part of the networking stack in any operating system, including Linux.
    </span>
    <span class="koboSpan" id="kobo.889.3">
     You can view the contents of your
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.890.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.891.1">
     file by entering the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.892.1">
      cat /
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.893.1">
       etc/hosts
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.894.1">
      command.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.895.1">
     Before moving on, it’s important to understand how DNS works in regard to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.896.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.897.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.897.2">
     On a Linux system, when you use a domain name for network communications, your computer must resolve the domain name to an IP address.
    </span>
    <span class="koboSpan" id="kobo.897.3">
     At a very basic level, when you use a domain name to communicate with other hosts over the network, the first step is for your computer to check its own hostname for a match.
    </span>
    <span class="koboSpan" id="kobo.897.4">
     Next, it checks for an entry in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.898.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.899.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.899.2">
     If that doesn’t resolve the hostname, it communicates with the DNS server in your network interface configuration.
    </span>
    <span class="koboSpan" id="kobo.899.3">
     Essentially, hardcoding a domain name to an IP address in your
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.900.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.901.1">
     file overrides DNS.
    </span>
    <span class="koboSpan" id="kobo.901.2">
     Microsoft Windows also uses a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.902.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.903.1">
     file for the same purpose, although it’s in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.904.1">
      different location.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.905.1">
     The following screenshot shows the contents of my
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.906.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.907.1">
     file before making
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.908.1">
      any modifications:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer089">
     <span class="koboSpan" id="kobo.909.1">
      <img alt="Figure 8.12 – The content of my /etc/hosts file" src="image/B22229_08_12.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.910.1">
     Figure 8.12 – The content of my /etc/hosts file
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.911.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.912.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.913.1">
     file entries start on a new line with an IP address, followed by either tabs or spaces, followed by one or more domain names.
    </span>
    <span class="koboSpan" id="kobo.913.2">
     You can use tabs or spaces, just be consistent.
    </span>
    <span class="koboSpan" id="kobo.913.3">
     Now that you
    </span>
    <a id="_idIndexMarker505">
    </a>
    <span class="koboSpan" id="kobo.914.1">
     understand the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.915.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.916.1">
     files, let’s move on and learn how to reformat the data from the Nuclei scan for insertion into our
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.917.1">
       hosts
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.918.1">
      file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.919.1">
     The following code will take a filename as the only command-line argument and output lines you can copy and paste into your
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.920.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.921.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.921.2">
     The code is thoroughly commented to explain what each part does.
    </span>
    <span class="koboSpan" id="kobo.921.3">
     The example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.922.1">
      ch08_nuclei.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.923.1">
     file in this chapter’s folder in the GitHub repository.
    </span>
    <span class="koboSpan" id="kobo.923.2">
     I’m going to split up the code into smaller chunks to explain each part as we go.
    </span>
    <span class="koboSpan" id="kobo.923.3">
     It will be helpful to have the script in GitHub open on your screen to compare to the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.924.1">
      code narrative:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.925.1">
if [ "$#" -ne 1 ]; then
    echo "Converts Nuclei ssl-dns-names scan output to hosts file format"
    echo "Usage: $0 /path/to/file"
    exit 1
fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.926.1">
     If a file path isn’t passed on the command line, print usage and abort.
    </span>
    <span class="koboSpan" id="kobo.926.2">
     It first checks whether the number of arguments (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.927.1">
      $#
     </span>
    </strong>
    <span class="koboSpan" id="kobo.928.1">
     ) is not equal (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.929.1">
      -ne
     </span>
    </strong>
    <span class="koboSpan" id="kobo.930.1">
     ) to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.931.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.932.1">
     .
    </span>
    <span class="koboSpan" id="kobo.932.2">
     If the statement in square brackets is true, then echo the description of th
    </span>
    <a id="_idTextAnchor237">
    </a>
    <a id="_idTextAnchor238">
    </a>
    <span class="koboSpan" id="kobo.933.1">
     e script and usage example
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.934.1">
      and exit.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.935.1">
     In the following code, I pipe the file content to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.936.1">
      cut command:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.937.1">
cat "$1" | cut -d ' ' -f 4- | \</span></pre>
   <p>
    <span class="koboSpan" id="kobo.938.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.939.1">
      cut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.940.1">
     command uses a space as delimiter from the 4th field to the end of line.
    </span>
    <span class="koboSpan" id="kobo.940.2">
     The output is piped to the next command.
    </span>
    <span class="koboSpan" id="kobo.940.3">
     A backslash (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.941.1">
      \
     </span>
    </strong>
    <span class="koboSpan" id="kobo.942.1">
     ) at the end of a line continues the command on to the
    </span>
    <a id="_idIndexMarker506">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.943.1">
      next line.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.944.1">
     In the following code, multi-part (6) sed commands are separated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.945.1">
      by semi-colon:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.946.1">
sed 's/:443//;s/\[//g;s/\]//g;s/"//g;s/,/ /g;s/ \*\.[^ ]*//g' | \</span></pre>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.947.1">
      Only the beginning and end of the series of sed commands are enclosed in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.948.1">
       single quotes.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.949.1">
       s/:443//
      </span>
     </strong>
     <span class="koboSpan" id="kobo.950.1">
      : Removes the string
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.951.1">
       :443
      </span>
     </strong>
     <span class="koboSpan" id="kobo.952.1">
      from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.953.1">
       the input.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.954.1">
       s/\[//g
      </span>
     </strong>
     <span class="koboSpan" id="kobo.955.1">
      : Removes all occurrences of the [ character from the input.
     </span>
     <span class="koboSpan" id="kobo.955.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.956.1">
       g
      </span>
     </strong>
     <span class="koboSpan" id="kobo.957.1">
      at the end means
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.958.1">
       global
      </span>
     </em>
     <span class="koboSpan" id="kobo.959.1">
      , so it applies the substitution to all matches in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.960.1">
       each line.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.961.1">
       s/\]//g
      </span>
     </strong>
     <span class="koboSpan" id="kobo.962.1">
      : Removes all occurrences of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.963.1">
       ]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.964.1">
      character from the input (global).
     </span>
     <span class="koboSpan" id="kobo.964.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.965.1">
       ]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.966.1">
      character must be
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.967.1">
       escaped (
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.968.1">
        \
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.969.1">
       ).
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.970.1">
       s/"//g
      </span>
     </strong>
     <span class="koboSpan" id="kobo.971.1">
      : Removes all occurrences of the double quote (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.972.1">
       "
      </span>
     </strong>
     <span class="koboSpan" id="kobo.973.1">
      ) character from the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.974.1">
       input (global).
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.975.1">
       s/,/ /g
      </span>
     </strong>
     <span class="koboSpan" id="kobo.976.1">
      : Replaces all occurrences of the comma (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.977.1">
       ,
      </span>
     </strong>
     <span class="koboSpan" id="kobo.978.1">
      ) character with a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.979.1">
       space (global).
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.980.1">
       s/ \*\.[^ ]*//g
      </span>
     </strong>
     <span class="koboSpan" id="kobo.981.1">
      : This expression typically removes wildcard subdomain entries like
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.982.1">
       *.example.com
      </span>
     </strong>
     <span class="koboSpan" id="kobo.983.1">
      (global).
     </span>
     <span class="koboSpan" id="kobo.983.2">
      It removes any space followed by
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.984.1">
       *.
      </span>
     </strong>
     <span class="koboSpan" id="kobo.985.1">
      (escaped) and any sequence of non-space characters.
     </span>
     <span class="koboSpan" id="kobo.985.2">
      Remember from
     </span>
     <a href="B22229_04.xhtml#_idTextAnchor073">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.986.1">
         Chapter 4
        </span>
       </em>
      </span>
     </a>
     <span class="koboSpan" id="kobo.987.1">
      that the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.988.1">
       ^
      </span>
     </strong>
     <span class="koboSpan" id="kobo.989.1">
      character can have multiple meanings.
     </span>
     <span class="koboSpan" id="kobo.989.2">
      Outside of square brackets it matches the beginning of a word or line.
     </span>
     <span class="koboSpan" id="kobo.989.3">
      Inside of square brackets it negates the following characters.
     </span>
     <span class="koboSpan" id="kobo.989.4">
      In this case, it’s saying
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.990.1">
       do not
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.991.1">
        match spaces
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.992.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.993.1">
       | \
      </span>
     </strong>
     <span class="koboSpan" id="kobo.994.1">
      : Finally, the resulting output is piped (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.995.1">
       |
      </span>
     </strong>
     <span class="koboSpan" id="kobo.996.1">
      ) to the sort command that follows.
     </span>
     <span class="koboSpan" id="kobo.996.2">
      The backslash (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.997.1">
       \
      </span>
     </strong>
     <span class="koboSpan" id="kobo.998.1">
      ) character allows the command to continue on the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.999.1">
       next line.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1000.1">
     The input is sorted uniquely (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1001.1">
      -u
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1002.1">
     ), as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1003.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1004.1">
sort -u -k2 | \</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1005.1">
     The data is sorted on the second field through the end of line (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1006.1">
      -k2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1007.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.1007.2">
     If we did not want to sort on the second field to the end of the line and instead wanted to sort only the second field, we would
    </span>
    <a id="_idIndexMarker507">
    </a>
    <span class="koboSpan" id="kobo.1008.1">
     have used
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1009.1">
      -k2,2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1010.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1010.2">
     The numbers represent the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1011.1">
      start
     </span>
    </em>
    <span class="koboSpan" id="kobo.1012.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1013.1">
      stop
     </span>
    </em>
    <span class="koboSpan" id="kobo.1014.1">
     fields, which are delimited with spaces
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1015.1">
      by default.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1016.1">
     Again, the output is piped to the next command and the backslash continues the command to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1017.1">
      next line.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1018.1">
     The following code starts an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1019.1">
      awk
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1020.1">
     code block before initializing the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1021.1">
      new_line
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1022.1">
     variable as an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1023.1">
      empty string:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1024.1">
awk '{
    # Initialize new_line as an empty string
    new_line = ""
    for (i = 1; i &lt;= NF; i++) {</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1025.1">
     In the last line of the preceding code we start a for loop inside the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1026.1">
      awk
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1027.1">
     code block that iterates over all fields in the current record.
    </span>
    <span class="koboSpan" id="kobo.1027.2">
     Here’s a breakdown of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1028.1">
      that line:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1029.1">
       i = 1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1030.1">
      : Initializes the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1031.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1032.1">
      variable
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1033.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1034.1">
        1
       </span>
      </strong>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1035.1">
       i &lt;= NF
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1036.1">
      :
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1037.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1038.1">
      is less than or equal to the number of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1039.1">
       fields (
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1040.1">
        NF
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1041.1">
       )
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1042.1">
       i++
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1043.1">
      : Increment
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1044.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1045.1">
      and repeat
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1046.1">
       the loop
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1047.1">
     The following code skips any wildcard domains.
    </span>
    <span class="koboSpan" id="kobo.1047.2">
     Wildcard domains are those that have an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1048.1">
      asterisk (
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1049.1">
       *
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1050.1">
      ):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1051.1">
    if ($i !~ /\*/) {
        new_line = new_line $i " "
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1052.1">
     In the preceding code, if the current value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1053.1">
      i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1054.1">
     does not contain an asterisk (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1055.1">
      *
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1056.1">
     ), concatenate it to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1057.1">
      new_line
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1058.1">
     with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1059.1">
      a space.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1060.1">
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1061.1">
     In the preceding code, the
    </span>
    <a id="_idIndexMarker508">
    </a>
    <span class="koboSpan" id="kobo.1062.1">
     closing brace (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1063.1">
      }
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1064.1">
     ) ends the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1065.1">
       for
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1066.1">
      loop.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1067.1">
    sub(/[ \t]+$/, "", new_line)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1068.1">
     The preceding line of code uses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1069.1">
      sub
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1070.1">
     function to trim trailing spaces.
    </span>
    <span class="koboSpan" id="kobo.1070.2">
     The usage of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1071.1">
      sub
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1072.1">
     is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1073.1">
      sub(regex, replacement, target)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1074.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1074.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1075.1">
      target
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1076.1">
     value is optional, and when not included, it defaults to the entire current
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1077.1">
      record (
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1078.1">
       $0
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1079.1">
      ).
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1080.1">
    if (split(new_line, fields, " ") &gt; 1) {
     print new_line
    }
}'</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1081.1">
     The preceding code splits
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1082.1">
      new_line
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1083.1">
     into an array called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1084.1">
      fields
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1085.1">
     using a space as the delimiter, then prints the new line only if it contains more than
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1086.1">
      one column.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1087.1">
     The output of this script is shown in the following figure.
    </span>
    <span class="koboSpan" id="kobo.1087.2">
     If you copy and paste the output into your
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1088.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1089.1">
     file, it will override DNS when resolving
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1090.1">
      a hostname:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer090">
     <span class="koboSpan" id="kobo.1091.1">
      <img alt="Figure 8.13 – The output of the ch08_nuclei_01.sh script" src="image/B22229_08_13.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.1092.1">
     Figure 8.13 – The output of the ch08_nuclei_01.sh script
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1093.1">
     You may ask why I put so much work into making a script to create three lines instead of just copying and pasting.
    </span>
    <span class="koboSpan" id="kobo.1093.2">
     Remember, this exercise began as an example of a challenge I solved during an external
    </span>
    <a id="_idIndexMarker509">
    </a>
    <span class="koboSpan" id="kobo.1094.1">
     pentest that had thousands of live hosts in scope and the script printed hundreds of lines to add to my
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1095.1">
       hosts
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1096.1">
      file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1097.1">
     After adding the script output to my
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1098.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1099.1">
     file, when I scan those domain names, I can be sure that the names are resolving to the IP address that I choose, instead of resolving to the IP address of a CDN protected by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1100.1">
      a WAF.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-149">
    <a id="_idTextAnchor239">
    </a>
    <span class="koboSpan" id="kobo.1101.1">
     Using Bash to format vulnerability scan targets
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1102.1">
     In the previous sections, you
    </span>
    <a id="_idIndexMarker510">
    </a>
    <span class="koboSpan" id="kobo.1103.1">
     learned about HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1104.1">
      HOST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1105.1">
     headers, TLS certificate SANs, and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1106.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1107.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.1107.2">
     You also learned how to parse a Nuclei scan report and format the data for use in your
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1108.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1109.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.1109.2">
     Related to this theme, you may also need to convince your vulnerability scanner to override DNS when
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1110.1">
      scanning targets.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1111.1">
     Nessus (
    </span>
    <a href="https://www.tenable.com/products/nessus">
     <span class="koboSpan" id="kobo.1112.1">
      https://www.tenable.com/products/nessus
     </span>
    </a>
    <span class="koboSpan" id="kobo.1113.1">
     ) is a vulnerability scanner in common use by system administrators
    </span>
    <a id="_idIndexMarker511">
    </a>
    <span class="koboSpan" id="kobo.1114.1">
     and security professionals.
    </span>
    <span class="koboSpan" id="kobo.1114.2">
     On the same pentest where I needed to override DNS and add subdomains parsed from a Nuclei scan to my
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1115.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1116.1">
     file, I needed to accomplish the same task for my Nessus scan.
    </span>
    <span class="koboSpan" id="kobo.1116.2">
     I eventually learned that Nessus doesn’t use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1117.1">
      hosts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1118.1">
     file to resolve domain names.
    </span>
    <span class="koboSpan" id="kobo.1118.2">
     However, I did learn that Nessus does allow you to override DNS by specifying targets in the format
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1119.1">
      server1.example.com[192.168.1.1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1120.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1120.2">
     The following code will take the output of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1121.1">
      ch08_nuclei_01.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1122.1">
     script and convert it to the Nessus format.
    </span>
    <span class="koboSpan" id="kobo.1122.2">
     The example code can be found in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1123.1">
      ch08_nessus.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1124.1">
     file in this chapter’s folder in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1125.1">
      GitHub repository:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1126.1">
#!/usr/bin/env bash
if [ "$#" -ne 1 ]; then
    echo "This script is intended for use with Nuclei scan output from the ssl-dns-names template."
</span><span class="koboSpan" id="kobo.1126.2">    echo "The related Nuclei scan command is: nuclei -t \"$HOME/nuclei-templates/ssl/ssl-dns-names.yaml\" -nc -silent -u [IP or network address] -o [output file]"
    echo "Usage: $0 /path/to/file"
    exit 1
fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1127.1">
     This code simply checks to ensure that there is exactly one command-line argument passed to the script.
    </span>
    <span class="koboSpan" id="kobo.1127.2">
     If not one argument is entered, print the usage and exit.
    </span>
    <span class="koboSpan" id="kobo.1127.3">
     An
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1128.1">
      exit
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1129.1">
     code of anything other than zero is considered an error.
    </span>
    <span class="koboSpan" id="kobo.1129.2">
     This is important when your script logic must determine
    </span>
    <a id="_idIndexMarker512">
    </a>
    <span class="koboSpan" id="kobo.1130.1">
     whether a previous command or script was completed successfully before running the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1131.1">
      next one.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1132.1">
seen_hostnames=()</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1133.1">
     The preceding code creates an array to track
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1134.1">
      unique hostnames.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1135.1">
while read -r line; do</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1136.1">
     The preceding code reads the file and processes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1137.1">
      each line.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1138.1">
    ip=$(echo "$line" | cut -d ' ' -f 4 | cut -d ':' -f 1)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1139.1">
     This code reads each line of input and uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1140.1">
      cut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1141.1">
     to select the fourth field, the IP address.
    </span>
    <span class="koboSpan" id="kobo.1141.2">
     This results in an IP address and port that are separated by a colon.
    </span>
    <span class="koboSpan" id="kobo.1141.3">
     The last
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1142.1">
      cut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1143.1">
     statement separates the two, selects the IP address, and assigns it to the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1144.1">
       ip
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1145.1">
      variable.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1146.1">
    hostnames=$(echo "$line" | cut -d ' ' -f 5 | awk -F'[][]' '{print $2}')</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1147.1">
     This line cuts the data into fields separated by spaces and selects the fifth field.
    </span>
    <span class="koboSpan" id="kobo.1147.2">
     It then selects the data inside square brackets and assigns it to the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1148.1">
       hostnames
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1149.1">
      variable.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1150.1">
    IFS=',' read -ra ADDR &lt;&lt;&lt; "$hostnames"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1151.1">
     This line sets the comma as the field separator and reads each hostname into the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1152.1">
       ADDR
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1153.1">
      array.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1154.1">
    for hostname in "${ADDR[@]}"; do
        # Remove leading and trailing whitespace
        hostname=$(echo "$hostname" | xargs)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1155.1">
     This code removes leading and trailing spaces from the hostname.
    </span>
    <span class="koboSpan" id="kobo.1155.2">
     By default,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1156.1">
      xargs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1157.1">
     trims leading and trailing
    </span>
    <a id="_idIndexMarker513">
    </a>
    <span class="koboSpan" id="kobo.1158.1">
     whitespace and reduces any sequence of whitespace characters to a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1159.1">
      single space.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1160.1">
        if [[ "${hostname:0:1}" != "*" ]]; then</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1161.1">
     The preceding code checks whether the first character of the hostname is not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1162.1">
      an asterisk.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1163.1">
            if [[ ! </span><span class="koboSpan" id="kobo.1163.2">" ${seen_hostnames[@]} " =~ " ${hostname} " ]]; then</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1164.1">
     This code checks whether the value of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1165.1">
      hostname
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1166.1">
     variable is not present in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1167.1">
       seen_hostnames
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1168.1">
      array.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1169.1">
                seen_hostnames+=("$hostname")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1170.1">
     This code adds the hostname to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1171.1">
      seen_hostnames
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1172.1">
     array if the preceding
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1173.1">
      if
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1174.1">
     statement evaluates to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1175.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1176.1">
     (the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1177.1">
      hostname
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1178.1">
     variable value is not in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1179.1">
       seen_hostnames
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1180.1">
      array).
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1181.1">
                echo "$hostname[$ip]"
            fi
        fi
    done
done &lt; "$1"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1182.1">
     This code prints the hostname and IP in the desired format, then closes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1183.1">
      if
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1184.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1185.1">
      fi
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1186.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1187.1">
      do
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1188.1">
     /
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1189.1">
      done
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1190.1">
     code blocks.
    </span>
    <span class="koboSpan" id="kobo.1190.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1191.1">
      done &lt; "$1"
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1192.1">
     code passes the command-line argument to the code block
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1193.1">
      as input.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1194.1">
     The output of this
    </span>
    <a id="_idIndexMarker514">
    </a>
    <span class="koboSpan" id="kobo.1195.1">
     script can be copied into a Nessus scan target list.
    </span>
    <span class="koboSpan" id="kobo.1195.2">
     The output is shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1196.1">
      following figure:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer091">
     <span class="koboSpan" id="kobo.1197.1">
      <img alt="Figure 8.14 – The output of the Nessus script" src="image/B22229_08_14.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.1198.1">
     Figure 8.14 – The output of the Nessus script
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1199.1">
     This will allow you to make Nessus override DNS to scan by hostname resolved to the IP address that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1200.1">
      you specify.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-150">
    <a id="_idTextAnchor240">
    </a>
    <span class="koboSpan" id="kobo.1201.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1202.1">
     In this chapter, you learned about the critical phase of reconnaissance and information gathering, focusing on how to discover various assets owned by the target organization.
    </span>
    <span class="koboSpan" id="kobo.1202.2">
     This chapter equipped you with the knowledge and tools to perform thorough reconnaissance using Bash scripting, which sets the foundation for subsequent active
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1203.1">
      assessment stages.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1204.1">
     Building on the reconnaissance skills acquired in this chapter,
    </span>
    <a href="B22229_09.xhtml#_idTextAnchor241">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1205.1">
        Chapter 9
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1206.1">
     will guide you through the application of Bash scripting in web application pentesting.
    </span>
    <span class="koboSpan" id="kobo.1206.2">
     As web applications are often key targets due to their accessibility and potential vulnerabilities, this chapter will focus on various techniques to identify, exploit, and document security weaknesses in web applications using Bash and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1207.1">
      related tools.
     </span>
    </span>
   </p>
  </div>
 </body></html>