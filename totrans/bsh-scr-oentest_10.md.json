["```\n $ sudo apt update && sudo apt install -y libxml2-utils whois\n```", "```\n $ go install -v github.com/projectdiscovery/chaos-client/cmd/chaos@latest\n```", "```\n $ curl https://api.hunter.io/v2/domain-search\\?domain=stripe.com\\&api_key=[redacted] > employees.txt\n```", "```\n #!/usr/bin/env bash\nget_domains() {\n```", "```\n domain=$1\n```", "```\n body=\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\n    <soap:Envelope xmlns:exm=\\\"http://schemas.microsoft.com/exchange/services/2006/messages\\\"\n        xmlns:ext=\\\"http://schemas.microsoft.com/exchange/services/2006/types\\\"\n        xmlns:a=\\\"http://www.w3.org/2005/08/addressing\\\"\n        xmlns:soap=\\\"http://schemas.xmlsoap.org/soap/envelope/\\\"\n        xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\" xmlns:xsd=\\\"http://www.w3.org/2001/XMLSchema\\\">\n    <soap:Header>\n        <a:RequestedServerVersion>Exchange2010</a:RequestedServerVersion>\n        <a:MessageID>urn:uuid:6389558d-9e05-465e-ade9-aae14c4bcd10</a:MessageID>\n        <a:Action soap:mustUnderstand=\\\"1\\\">http://schemas.microsoft.com/exchange/2010/Autodiscover/Autodiscover/GetFederationInformation</a:Action>\n        <a:To soap:mustUnderstand=\\\"1\\\">https://autodiscover.byfcxu-dom.extest.microsoft.com/autodiscover/autodiscover.svc</a:To>\n        <a:ReplyTo>\n        <a:Address>http://www.w3.org/2005/08/addressing/anonymous</a:Address>\n        </a:ReplyTo>\n    </soap:Header>\n    <soap:Body>\n        <GetFederationInformationRequestMessage xmlns=\\\"http://schemas.microsoft.com/exchange/2010/Autodiscover\\\">\n        <Request>\n            <Domain>${domain}</Domain>\n        </Request>\n        </GetFederationInformationRequestMessage>\n    </soap:Body>\n    </soap:Envelope>\"\n```", "```\n response=$(curl -s -X POST -H \"Content-type: text/xml; charset=utf-8\" -H \"User-agent: AutodiscoverClient\" -d \"$body\" \"https://autodiscover-s.outlook.com/autodiscover/autodiscover.svc\")\n```", "```\n if [[ -z \"$response\" ]]; then\n        echo \"[-] Unable to execute request. Wrong domain?\"         exit 1\n    fi\n```", "```\n domains=$(echo \"$response\" | xmllint --xpath '//*[local-name()=\"Domain\"]/text()' -)\n```", "```\n if [[ -z \"$domains\" ]]; then\n        echo \"[-] No domains found.\"         exit 1\n    fi\n```", "```\n echo -e \"\\n[+] Domains found:\"\n    echo \"$domains\" | tr ' ' '\\n'\n```", "```\n tenant=$(echo \"$domains\" | tr ' ' '\\n' | grep \"onmicrosoft.com\" | head -n 1 | cut -d'.' -f1)\n```", "```\n if [[ -z \"$tenant\" ]]; then\n        echo \"[-] No tenant found.\"         exit 1\n    fi\n```", "```\n echo -e \"\\n[+] Tenant found: \\n${tenant}\"\n```", "```\n check_mdi \"$tenant\"\n}\n```", "```\n check_mdi() {\n```", "```\n tenant=\"$1.atp.azure.com\"\n```", "```\n if dig \"$tenant\" +short; then\n        echo -e \"\\n[+] An MDI instance was found for ${tenant}!\\n\"\n    else\n        echo -e \"\\n[-] No MDI instance was found for ${tenant}\\n\"\n    fi\n}\n```", "```\n if [[ $# -ne 2 || $1 != \"-d\" ]]; then\n    # Print the usage information if the arguments are incorrect\n    echo \"Usage: $0 -d <domain>\"\n    exit 1\nfi\n```", "```\n domain=$2\n```", "```\n get_domains \"$domain\"\n```", "```\n mdi() {\n    # This function takes a domain as input and checks MDI and returns domains using the same tenant.     while IFS= read -r line; do\n        body=\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\n```", "```\n rootdomain() {\n    # This function takes a subdomain as input and returns the root domain.\n```", "```\n while IFS= read -r line; do\n```", "```\n echo \"$line\" | awk -F. '\n```", "```\n {\n```", "```\n n = split($0, parts, \".\");\n```", "```\n if (n >= 3 && (parts[n-1] ~ /^(com|net|org|co|gov|edu|mil|int)$/ && parts[n] ~ /^[a-z]{2}$/)) {\n```", "```\n print parts[n-2] \".\" parts[n-1] \".\" parts[n];\n```", "```\n } else if (n >= 2) {\n```", "```\n print parts[n-1] \".\" parts[n];\n```", "```\n } else {\n                    print $0;\n```", "```\n }\n            }'\n```", "```\n done\n```", "```\n }\n```", "```\n resolve() {\n    # This function takes a domain as input and returns the IP address.\n```", "```\n while IFS= read -r line; do\n```", "```\n dig +short \"$line\" | grep -E '^[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+$' | head -n 1\n```", "```\n done\n    return 0\n}\n```", "```\n org() {\n    # This function takes an IP address as input and returns the organization name that owns the IP block.     while IFS= read -r line; do\n        whois \"$line\" | grep OrgName | tr -s ' ' | cut -d ' ' -f 2-\n    done\n}\n```", "```\n dnsrecon() {\n    # Check if the correct number of arguments is provided\n    if [[ $# -ne 1 ]]; then\n        echo \"You didn't provide a domain as input.\"         echo \"Usage: $0 [domain]\"\n        exit 1\n    fi\n```", "```\n if [[ -z \"$CHAOS_KEY\" ]]; then\n        echo \"No chaos API key found. Set env CHAOS_KEY.\"         exit 1\n    fi\n```", "```\n local domain=$1\n    local domains=''\n    local roots=''\n```", "```\n local mdi_result=$(mdi <<< \"$domain\")\n```", "```\n if [[ -z \"$mdi_result\" ]]; then\n        domains=$(chaos -silent -d \"$domain\")\n```", "```\n else\n        echo \"$mdi_result\" | while IFS= read -r line; do\n            root=$(rootdomain <<< \"$line\")\n            chaos_domains=$(chaos -silent -d \"$root\")\n            domains=$(echo -e \"$domains\\n$chaos_domains\")\n        done\n```", "```\n domains=$(echo \"$domains\" | grep . | grep -v \\* | sort -u)\n    fi\n```", "```\n echo \"$domains\" | while IFS= read -r line; do\n```", "```\n ip=$(resolve <<< \"$line\")\n        if [[ -z \"$ip\" ]]; then\n            continue\n        fi\n```", "```\n orgname=$(org <<< \"$ip\")\n        echo \"$line;$ip;$orgname\"\n    done\n}\n```", "```\n if [ \"$#\" -ne 1 ]; then\n    echo \"Converts Nuclei ssl-dns-names scan output to hosts file format\"\n    echo \"Usage: $0 /path/to/file\"\n    exit 1\nfi\n```", "```\n cat \"$1\" | cut -d ' ' -f 4- | \\\n```", "```\n sed 's/:443//;s/\\[//g;s/\\]//g;s/\"//g;s/,/ /g;s/ \\*\\.[^ ]*//g' | \\\n```", "```\n sort -u -k2 | \\\n```", "```\n awk '{\n    # Initialize new_line as an empty string\n    new_line = \"\"\n    for (i = 1; i <= NF; i++) {\n```", "```\n if ($i !~ /\\*/) {\n        new_line = new_line $i \" \"\n    }\n```", "```\n }\n```", "```\n sub(/[ \\t]+$/, \"\", new_line)\n```", "```\n if (split(new_line, fields, \" \") > 1) {\n     print new_line\n    }\n}'\n```", "```\n #!/usr/bin/env bash\nif [ \"$#\" -ne 1 ]; then\n    echo \"This script is intended for use with Nuclei scan output from the ssl-dns-names template.\"     echo \"The related Nuclei scan command is: nuclei -t \\\"$HOME/nuclei-templates/ssl/ssl-dns-names.yaml\\\" -nc -silent -u [IP or network address] -o [output file]\"\n    echo \"Usage: $0 /path/to/file\"\n    exit 1\nfi\n```", "```\n seen_hostnames=()\n```", "```\n while read -r line; do\n```", "```\n ip=$(echo \"$line\" | cut -d ' ' -f 4 | cut -d ':' -f 1)\n```", "```\n hostnames=$(echo \"$line\" | cut -d ' ' -f 5 | awk -F'[][]' '{print $2}')\n```", "```\n IFS=',' read -ra ADDR <<< \"$hostnames\"\n```", "```\n for hostname in \"${ADDR[@]}\"; do\n        # Remove leading and trailing whitespace\n        hostname=$(echo \"$hostname\" | xargs)\n```", "```\n if [[ \"${hostname:0:1}\" != \"*\" ]]; then\n```", "```\n if [[ ! \" ${seen_hostnames[@]} \" =~ \" ${hostname} \" ]]; then\n```", "```\n seen_hostnames+=(\"$hostname\")\n```", "```\n echo \"$hostname[$ip]\"\n            fi\n        fi\n    done\ndone < \"$1\"\n```"]