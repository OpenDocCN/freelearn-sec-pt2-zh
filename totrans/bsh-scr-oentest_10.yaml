- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reconnaissance and Information Gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previous chapters introduced you to Bash scripting concepts. In some cases,
    we ran applications that were not made with Bash. In those cases, we used Bash
    to execute programs, pipe data between applications, or parse the output of these
    tools. As we progress further into this book, we will be demonstrating less pure
    Bash and more on using Bash to execute our pentesting tools, automate them, and
    parse their output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we dive into the essential first step of any pentest: reconnaissance.
    You’ll learn how to discover email addresses and assets owned by your target organization
    using various tools and techniques. This foundational knowledge will set the stage
    for more active assessments in later chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t expect this and the following chapters to be a thorough reference on performing
    pentesting. I will not be demonstrating every step, technique, and tool here.
    This book is meant to teach you how to augment your pentests with Bash scripting,
    not how to do pentesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to reconnaissance with Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting usernames and email addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Bash for DNS enumeration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Bash to identify web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be proficient with using Bash with **Open
    source intelligence** ( **OSINT** ) tools and sources to discover domain names,
    email addresses, and IP addresses of your target.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main prerequisite is that you started reading from [*Chapter 1*](B22229_01.xhtml#_idTextAnchor017)
    and have access to a Bash shell. If you aren’t using Kali Linux, you will likely
    find it more difficult to follow along. One script detailed later in this chapter
    requires a ProjectDiscovery Chaos API key ( [https://chaos.projectdiscovery.io/](https://chaos.projectdiscovery.io/)
    ), which can be obtained for free at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter08](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter08)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the prerequisites in Kali Linux using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You must also have Golang and the Chaos client installed. Installing Golang
    was documented fully in [*Chapter 1*](B22229_01.xhtml#_idTextAnchor017) . You
    can install the Chaos client with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Introducing reconnaissance with Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The urge to jump straight to scanning and hacking can be hard to overcome when
    you’re passionate about pentesting. I’ve lost count of the number of times in
    my career that I’ve done a less than thorough job of reconnaissance before jumping
    to active scanning only to later hit a wall. That’s when I find that circling
    back to the recon phase and finding some juicy nuggets is the key to success.
  prefs: []
  type: TYPE_NORMAL
- en: One pentest I did years ago stands out in my memories above the rest. I was
    pentesting a simple web page with a login form. Nothing else was in scope. I wasn’t
    given any credentials. If I managed to find working credentials or bypass the
    login form, it was game over.
  prefs: []
  type: TYPE_NORMAL
- en: I thoroughly attacked the login form for three days and had nothing to show
    for it. That’s when I circled back to reconnaissance. I ended up finding that
    the company had a GitHub account with some public repositories. One of those repositories
    contained credentials hidden in old commits. The credentials had been removed,
    but Git maintains versioning and history, which allowed me to pull them out and
    use them. After logging in and being redirected, I found myself in complete control
    of a financial application.
  prefs: []
  type: TYPE_NORMAL
- en: Every type of pentest depends on doing research before attacking the target.
    The most successful physical pentest I’ve done was successful because we researched
    our target company employees and found high-resolution photos of employee events
    on social media, which helped us to create very convincing clones of their badges.
    While our badges wouldn’t open doors with electronic badge readers, together with
    our confidence and pretext (the story we told the employees to explain why we
    were visiting), we convinced employees to give us access. On a wireless pentest
    of the same company, we were able to access their employee wireless network from
    the parking lot because we first checked their social media and websites and used
    Bash to make a wordlist of words and terms to use for password cracking.
  prefs: []
  type: TYPE_NORMAL
- en: OSINT is the process of collecting and analyzing information from publicly available
    sources to produce actionable intelligence. This type of intelligence gathering
    leverages data from various media, including the internet, social networks, public
    records, and news reports. OSINT can aid in a wide range of activities, from national
    security to cybersecurity, providing valuable insights without the need for illicit
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of OSINT lies in its ability to offer a comprehensive view of
    a target’s available information, which can be critical in both offensive and
    defensive security measures. For security pentests, OSINT helps identify potential
    vulnerabilities, gather details about the target’s infrastructure, and understand
    the organizational and personal behaviors that might be exploited by malicious
    actors. The insights gained through OSINT enable testers to emulate potential
    real-world attacks more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In preparation for a security pentest, the types of data gathered during OSINT
    include domain and IP address information, employee details, email addresses,
    social media profiles, document metadata, network configurations, and software
    versions. This information helps build a detailed profile of the target, uncovering
    entry points that might be exploited for unauthorized access or data breaches.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll dive in by learning how to use Bash scripting to
    format usernames and passwords. These skills will be very useful in various pentesting
    scenarios, such as phishing and password spraying.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting usernames and email addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few scenarios in pentesting where you’ll need to enumerate usernames
    and email addresses. You may need them for phishing, password spraying, or enumerating
    valid accounts.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to follow along while you perform this exercise, go to [https://hunter.io](https://hunter.io)
    and register for a free account. This is a website for finding company employee
    names and email addresses. After logging in to your free account, click the drop-down
    arrow beside your name in the top-right corner and then click on **API** in the
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Selecting API from the hunter.io menu](image/B22229_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Selecting API from the hunter.io menu
  prefs: []
  type: TYPE_NORMAL
- en: 'On this page, you’ll find example commands for various types of API searches.
    Under **Domain Search** , click the **Copy** button. Enter the following command
    in your terminal, substituting **[redacted]** with your own API key :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the URL, you can see **domain=stripe.com** . Obviously, you will want to
    change the domain to match your target.
  prefs: []
  type: TYPE_NORMAL
- en: Critical
  prefs: []
  type: TYPE_NORMAL
- en: Stripe is used as an example in this text only because the [hunter.io](http://hunter.io)
    website API page included it as an example. *Do not* hack anyone if you don’t
    have written permission. Not only is it illegal and unethical, but you’ll probably
    end up in prison when you get caught.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, **cat** the text file to the terminal so we can get a look at the output
    format. The first level of JSON data is **data** , as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – JSON first-level data](image/B22229_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – JSON first-level data
  prefs: []
  type: TYPE_NORMAL
- en: The absolute simplest **jq** filter is **jq .** . This filter takes its input
    and produces the same value as the output. The data that we want to access is
    nested under **data** . Therefore, our **jq** query will start with **.data[]**
    . Enter the following command and see that everything contained in **data** is
    output, **cat employees.txt | jq -r '.data[]'** . The **-r** argument simply tells
    **jq** to output raw data without escapes and quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the information nested under **data** , you’ll find that employee
    email addresses, names, and positions are nested under **emails** . Building on
    our earlier query, the next command will be **cat employees.txt | jq -r ''.data.emails[]''**
    . Do you notice a pattern here? When you want to access nested data using **jq**
    , start with a **.** symbol and the first field you want to access, followed by
    square brackets, **.first_level[]** . If you want to access data nested one level
    deeper, use **.first_level.second_level[]** . In this particular case, we want
    to access the **value** (email address), **first_name** , **last_name** , and
    **position** fields, which are nested under **.data.emails[]** . Therefore, our
    **jq** query wi ll be **.data.emails[] | [.value, .first_name, .last_name, .position]**
    , as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Our jq query to access email addresses and employee information](image/B22229_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Our jq query to access email addresses and employee information
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the information we need, the next step is to get it into a
    format that’s easier to work with, such as **tab-separated values** ( **TSV**
    ). Let’s check the manual for **jq** to find out how to make this transformation.
    Enter the **man jq** command in your terminal. The **jq** program has many options,
    but if you keep scrolling far enough, you’ll find a section named **Format strings
    and escaping** . In this section, we find that **Comma-Separated Values** ( **CSV**
    ) and TSV are **@csv** and **@tsv** . All that’s needed now is to pipe the previous
    query to **@tsv** , as shown in the following figure. Make sure that your pipe
    character and **@tsv** are enclosed inside the single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Our final jq query extracts the needed data](image/B22229_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Our final jq query extracts the needed data
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were authorized to do so and wanted to use this data for password spraying
    a login form on a website, we can guess that most likely their internal Active
    Directory domain user account is named the same as in their email address before
    the domain, **@stripe.com** . However, as a pentester, you will need to know how
    to take first and last names and reformat them in different formats, such as **first.last**
    , **f.last** , **first_last** , and so on. Notice that in the data in *Figure
    8* *.4* , the first and last names are in columns 2 and 3. Let’s create a simple
    one-line script that will build on the previous command and take the first and
    last names and print them as first initial and last name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Formatting usernames as first initial, last name](image/B22229_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Formatting usernames as first initial, last name
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a full explanation of the **awk** command inside single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**awk ''pattern {action}''** : You may remember from [*Chapter 4*](B22229_04.xhtml#_idTextAnchor073)
    that **awk** commands are in the format of pattern and action. The pattern is
    optional. The action is mandatory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**print tolower()** : This may be obvious. It prints the output in all lowercase.
    Inside this **awk** function, we’re printing the first initial of **first_name**
    (second field or **$2** ) followed by the **last_name** (third field or **$3**
    ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(substr($2,1,1)** : Here, we’re making a substring of the data consisting
    of the second field ( **$2** ), **first_name** , starting with the first character
    and ending with the first character ( **1,1** ). If we wanted to use the first
    two characters of the first name, the **substr** command would be **substr($2,1,2)**
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to print the username as **first_last** , use the **awk '{print
    tolower($1 "_" $2)}'** command to insert a specific character between first and
    last names.
  prefs: []
  type: TYPE_NORMAL
- en: As a pentester, you should always use the right tool for the job. Earlier in
    your career, you’re more likely to be running tools made by someone else. These
    tools are frequently written in Python or C languages. When performing OSINT,
    many of the tools are written in Python. Regardless of which tool you use and
    the language it’s written in, eventually, you’ll need to filter and format data
    input or output from your tools. That’s where the concepts in this chapter will
    save you significant time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore using Bash with DNS enumeration to discover
    targets.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bash for DNS enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a pentester, you will typically be provided with a defined scope. The scope
    is what you’re allowed to test. It will usually be provided as a list of IP addresses,
    network addresses, domain names, URLs, or a combination of these. On the other
    hand, you may also be tasked with discovering assets owned by the company.
  prefs: []
  type: TYPE_NORMAL
- en: In my earlier years as a pentester before I got into consulting, I spent a lot
    of time enumerating DNS to discover new assets for a company that was global and
    acquired a lot of smaller companies. I spent months discovering IP addresses,
    applications, and domain names owned by our acquisitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it’s essential to make sure we’re on the same page regarding terminology
    for domain names. We need to quickly cover the difference between top-level domains,
    root domains, and subdomains. I’ll use **www.example.com** for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**com** : This is the **top-level** **domain** ( **TLD** )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**example** : This is the root domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**www** : This is the subdomain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the terminology out of the way, let’s look at the methodology to discover
    additional root domains that are related to a known root domain.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the scope using Bash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section is dedicated to starting with a company’s domain name and discovering
    related assets exposed to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Many companies use Microsoft 365. If a company is enrolled as a Microsoft tenant
    with **Microsoft Defender for Identity** ( **MDI** ), the following script will
    discover the tenant name and enumerate all domains enrolled in the same tenant.
    This has been a very effective way to start with a simple domain name and discover
    related domains owned by the same entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script requires a domain as input. You can find it in this chapter’s folder
    in the GitHub repository as **ch08_check_mdi.sh** . I’m going to split up the
    code into smaller chunks to explain each part as we go. It will be helpful to
    have the script in GitHub open on your computer monitor to compare to the following
    code narrative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we start out with our familiar **shebang** , followed
    by the opening block of the **get_domains** function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we create a **domain** variable from the first command-line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we create the XML body of the HTTP request as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I created the **Simple Object Access Protocol** ( **SOAP**
    ) request body with the input domain, **$1** .
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, I have used command expansion ( **$()** ) to perform
    the HTTP **POST** request using **curl** and store the response in the **response**
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The **body** variable containing the SOAP request body is expanded in the **POST**
    data. The request is sent to the Autodiscover service for Microsoft 365.
  prefs: []
  type: TYPE_NORMAL
- en: The following code checks whether the response is empty ( **-z** , zero-length)
    and exits if true. An **exit** code that’s non-zero indicates that the process
    terminated with an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code parses the XML response to extract domain names using the
    **xmllint** application and stores the result in the **domains** variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The following code exits if no domains are found in the response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we print the found domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The **tr** command substitutes the first value with the second value; in this
    case, a space, **' '** , is replaced with a newline, **'\n'** .
  prefs: []
  type: TYPE_NORMAL
- en: The following code extracts the tenant name from the found domains.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The **tenant** variable is assigned the result of the **domains** variable with
    spaces substituted with a newline ( **tr ' ' '\n'** ). Then, it finds ( **grep**
    ) any line that contains **onmicrosoft.com** . That data is piped to **head -n
    1** , which selects the first line of data, then pipes the result to the **cut**
    command, which essentially splits the data on the period character and selects
    the first field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code exits if no tenant is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code prints the found tenant name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The following code calls the **check_mdi** function with the tenant name. The
    closing brace ends the **get_domains** function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, I declare the **check_mdi** function to identify MDI
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code appends the MDI domain suffix to the tenant name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code runs **dig** to check whether the MDI instance exists for
    the tenant domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It prints a positive message if the MDI instance is found. Otherwise, it prints
    a negative message if no MDI instance is found. The closing brace ends the **check_mdi**
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The following code checks whether the correct number of arguments is provided
    and whether the first argument is **-d** . The logical **or** ( **||** ) operation
    means if the number of command-line arguments is not equal to two, or the first
    argument is not equal to **-d** , then print the usage banner and exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The following code declares the **domain** argument from user input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The following code calls the **get_domains** function with the provided domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script with a well-known domain, you will find a lesser-known
    domain in the output. Essentially, this script helps you cross-reference domains
    owned by the same entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Running check_mdi on the cdw.com domain](image/B22229_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Running check_mdi on the cdw.com domain
  prefs: []
  type: TYPE_NORMAL
- en: The script output shown in the preceding figure demonstrates how our Bash script
    discovered many subdomains related to the target domain, greatly expanding our
    target footprint.
  prefs: []
  type: TYPE_NORMAL
- en: Automating subdomain enumeration with Bash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, I’m going to share some of the Bash functions I keep in my **.bashrc**
    file. I use these functions on external pentests to allow me to quickly perform
    common reconnaissance tasks that I run before port and vulnerability scanning.
    First, I will list the code in small sections and explain them as I go. Finally,
    I’ll show you how I use these functions together to enumerate DNS and the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function is named **mdi** and you’ve already seen it in the **ch08_check_mdi.sh**
    script shown earlier in this chapter. I’m going to include only the part that
    has changed from **ch08_check_mdi.sh** . The example code can be found in the
    **ch08_mdi_function.sh** file in this chapter’s folder in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I start by declaring a function named **mdi** . I nested
    all of the earlier code inside a **while** loop, which reads from standard input
    ( **stdin** ). This is required to read piped input, allowing us to pipe data
    between our functions. The **IFS=** code preserves newlines, which is necessary
    when your input contains multiple lines. You can pipe a single domain name or
    a line-separated list of domain names to this function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function is **rootdomain** . This function takes a subdomain as input
    and returns the root domain. For example, if you provide an input of **www.example.com**
    , the output will be **example.com** . This function is used to take a root domain
    from a subdomain, which I can then send to other functions to find more subdomains.
    The example code can be found in the **ch08_rootdomain_function.sh** file in this
    chapter’s folder in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I first declare the function name, followed by a comment
    explaining the purpose, input, and output of the script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This line starts a **while** loop that reads input line by line. **IFS=** sets
    the **internal field separator** to nothing, which prevents leading/trailing whitespace
    from being trimmed. **read -r** reads a line from standard input into the variable
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This line echoes the current line (subdomain) and pipes it to **awk** . The
    **-F.** option tells **awk** to use the period ( **.** ) as the field separator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This opens the block of the **awk** script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This line splits the current line ( **$0** ) into an array named **parts** using
    the period ( **.** ) as the delimiter. The **n** variable stores the number of
    elements in the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This condition checks whether the domain has at least three parts and whether
    the second-to-last part matches a common second-level domain (e.g., **com** ,
    **net** , **org** , **co** , **gov** , **edu** , **mil** , or **int** ) followed
    by a two-letter country code (e.g., **uk** , **us** , or **de** ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If the condition is true, this line prints the root domain, which consists of
    the third-to-last, second-to-last, and last parts of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This condition checks whether the domain has at least two parts ( e.g., **example.com**
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If the condition is true, this line prints the root domain, which consists of
    the second-to-last and last parts of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If none of the preceding conditions are met (e.g., the input is a single-label
    domain), this line prints the original input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code closes the **if** block, then closes the **awk** block. Notice
    that when the curly bracket closes the **if** block, there is no **fi** keyword
    like a Bash **if** statement. **awk** has a slightly different syntax for **if**
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This closes the **while** loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This bracket closes the function.
  prefs: []
  type: TYPE_NORMAL
- en: The **resolve** function takes a domain name as input and returns an IP address.
    The example code can be found in the **ch08_resolve_function.sh** file in this
    chapter’s folder in the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is the start of the function and a comment that describes what the
    function does: it takes a domain as input and returns its corresponding IP address.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This line starts a **while** loop that reads input line by line. **IFS=** sets
    the internal field separator to nothing, which prevents leading/trailing whitespace
    from being trimmed. **read -r** reads a line from standard input into the variable
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**dig** is a DNS lookup utility. The **+short** option makes the output concise
    by only printing the IP addresses or CNAME records. **$line** is the domain name
    read from input.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**done** closes the **while** loop’s **do** block. **return 0** signifies to
    a calling script or function that the script completed successfully.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **org** function takes an IP address as input and returns the **OrgName**
    value found in the Whois output. This information tells us who owns the network.
    The example code can be found in the **ch08_org_function.sh** file in this chapter’s
    folder in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The start of the function through to the start of the **while** loop is virtually
    the same as in previous scripts. The line beginning with **whois** runs the **whois**
    command using the IP address sent as input to the function, runs **grep** to find
    the line containing **OrgName** , runs the **tr -s ' '** command to squeeze multiple
    spaces into a single space, and then pipes the output to the **cut** command,
    which specifies a space as a delimiter and selects the second field through the
    end of input. The **tr** program is very handy for squeezing multiple spaces into
    a single space, but you can also use it to replace one character with another.
    The **cut** program specifies a delimiter ( **-d** ) followed by the field to
    cut.
  prefs: []
  type: TYPE_NORMAL
- en: The last function ties the other functions together. It performs domain and
    subdomain enumeration and prints subdomains, the IP address, and **OrgName** .
    It will also find any related root domains and enumerate their subdomains if the
    input domain is part of a Microsoft 365 tenant with MDI. This will significantly
    enhance subdomain discovery. I tested the Chaos API alone with a particular domain
    and it returned 553 live subdomains. When I ran this function and used MDI results
    to expand the scope to related domains hosted by the same company, it returned
    3,682 live subdomains.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example code can be found in the **ch08_dnsrecon_function.sh** file in
    this chapter’s folder in the GitHub repository. The script requires a ProjectDiscovery
    Chaos API key ( [https://chaos.projectdiscovery.io/](https://chaos.projectdiscovery.io/)
    ), which can be obtained for free at the time of writing. Chaos is the most complete
    source of DNS data that I’ve found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Print the usage information and exit if one command-line argument is not included.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Check whether the Chaos API key is set in an environment variable. You should
    have a line in your **.bashrc** file that looks like **CHAOS_KEY=[key value]**
    . After you edit your **.bashrc** file to add the API key, you’ll need to make
    it recognized using the **source ~/.** **bashrc** command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, I have declared local variables. It’s not strictly necessary to declare
    the variable ahead of its use, I did so based on personal preference. Declaring
    variables as **local** ensures that their scope is limited to the function in
    which they are defined, which helps to avoid potential conflicts with global variables
    or variables in other functions. This is critical when the variable is in a function
    in your **.bashrc** file to prevent collisions with other variables since these
    functions are available to everything in your Bash shell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, I passed the **domain** variable to the **mdi** function to get the list
    of related domains. Because the **mdi** function is designed to accept input from
    **stdin** ( **echo example.com | mdi** ) instead of being passed as a function
    argument ( **mdi example.com** ), it must be called as shown with three **<**
    characters. In Bash, **<<<** is known as the **here-string** operator. It is used
    to pass a string directly as input to a command, rather than reading from a file
    or standard input. This operator essentially provides a quick way to feed a single
    line of text to a command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If no domains are returned from the **mdi** function, pass the input domain
    directly to the Chaos API and assign the output to the **domains** variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This part pipes the content of the **mdi_result** variable line by line to the
    code inside the **do** / **done** block. The line of data (a domain) is passed
    to the **rootdomain** function. If the line of data is **www.example.com** , this
    function would return **example.com** . It then passes this root domain to the
    Chaos API call and assigns the result to the **chaos_domains** variable. Finally,
    the list of subdomains returned from the API call is appended to the list of domains
    in the **domains** variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This section of code ensures that blank lines are removed ( **grep .** returns
    non-blank lines), removes any wildcard domains ( **grep -v \*** ), and then removes
    duplicates ( **sort -u** ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This code passes each line of data in the **domains** variable to the **do**
    / **done** code block. The **IFS=** part ensures that line endings remain intact.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This code passes each domain in the **domains** variable to the **resolve**
    function, which returns an IP address and stores it in the **ip** variable. If
    the **ip** variable is zero-length, **-z** (the domain name could not be resolved
    to an IP address), it returns **true** and the **continue** keyword short-circuits
    the current iteration of the loop and skips to the next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If the domain name has successfully resolved to an IP address, the data is printed
    as **Domain;IP;Org** . I chose semicolons for the field separator because the
    **org** value may contain spaces and commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **dnsrecon** function is called on the command line as **dnsrecon example.com**
    . The following is an example of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – The dnsrecon function output](image/B22229_08_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – The dnsrecon function output
  prefs: []
  type: TYPE_NORMAL
- en: The output in the preceding figure shows that our Bash script has provided us
    with more targets, and contains information that we can use to determine whether
    the discovered domains are in scope by IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to discuss how web applications use domain names to determine
    which application to serve to a website visitor. This is critical to your success.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bash to identify web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a consultant pentester who is provided a list of IP or network addresses
    by an external customer, you may fall into a bad habit of just testing defined
    IP or network addresses and not performing enough OSINT to discover all domain
    names. I did this myself when I was a junior pentester and have also witnessed
    this from people I have mentored. The reason why this is not ideal is because
    of how web applications behave when requesting a website using an IP address versus
    a domain name.
  prefs: []
  type: TYPE_NORMAL
- en: A web server hosting multiple applications, load balancer, or reverse proxy
    will return the default site when an IP address is in the URL or HTTP **HOST**
    header. Unbeknown to you, there may be additional websites hosted on that IP address
    and you absolutely will miss out on finding vulnerable applications if you don’t
    perform DNS enumeration and test applicable domain names. You can read more about
    the HTTP **HOST** header at [https://portswigger.net/web-security/host-header](https://portswigger.net/web-security/host-header)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a relevant example. OWASP Juice Shop is an intentionally vulnerable
    website. You can find an example hosted at [https://demo.owasp-juice.shop/#/](https://demo.owasp-juice.shop/#/)
    . If you ping that hostname, you see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Pinging OWASP Juice Shop demo](image/B22229_08_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Pinging OWASP Juice Shop demo
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were provided with the IP address **81.169.145.156** in scope and scanned
    that IP and didn’t perform subdomain enumeration, you would visit that site in
    your browser and see **Not Found** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Visiting a website via the IP address](image/B22229_08_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Visiting a website via the IP address
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, I have highlighted the relevant parts for you. I requested
    a web page via the IP address. You may see this response and think that this IP
    address and port aren’t interesting and move on. However, if you visit the domain
    name, you see the following website, which contains many vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – OWASP Juice Shop, a vulnerable web application](image/B22229_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – OWASP Juice Shop, a vulnerable web application
  prefs: []
  type: TYPE_NORMAL
- en: Before you start scanning your scoped IP addresses or network addresses, take
    the time to fully enumerate DNS first using the tools and techniques shown next.
    Then, append the discovered domain names that resolve to the scoped IP addresses
    to the end of your scope file. I can’t stress enough how important this is. It
    could very well be the difference between a zero-finding pentest report (not to
    mention the risk of the customer getting breached due to your oversight) and finding
    high-impact vulnerabilities. If you simply paste the list of network or IP addresses
    into a vulnerability scanner and then think there’s nothing to exploit based on
    the scan results, you will overlook exploitable findings.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a better understanding of how web applications use the **HOST**
    header, in the next section, we’ll examine how to discover the application root
    or subdomains served by a web server on any particular IP address. Having this
    information will be critical to our success when scanning IP or network addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bash for certificate enumeration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I performed this one external network pentest that had many thousands of live
    IP addresses in scope. One of the problems I ran into was that I was given large
    network blocks and needed to take the live IP addresses and discover hostnames
    before I could properly scan the web servers. Remember earlier in this chapter
    where I demonstrated how the web page you see may be different when you request
    the website via IP address versus hostname?
  prefs: []
  type: TYPE_NORMAL
- en: Many thousands of those IP addresses were resolved to random subdomains in DNS,
    and they were usually proxy servers placed in front of a server pool. We also
    knew that the customer was using a **content delivery network** ( **CDN** ) in
    front of their websites, and traffic was filtered by a **web application firewall**
    ( **WAF** ), which blocked attempts to scan the sites. Furthermore, if we requested
    a website via domain name, the domain names resolved to an IP address residing
    on the CDN and the CDN IP addresses were not in scope so we couldn’t attack them.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately for me, the customer wasn’t filtering incoming traffic to allow
    only source IP addresses of the CDN provider. At that point, what I needed to
    do was discover which website was being hosted on each IP address and then override
    DNS so that I could manually map domain names to IP addresses. This would allow
    me to access the web applications directly. I came up with a crafty way to discover
    which websites were hosted on those IP addresses and bypass the CDN WAFs at the
    same time. I found that the Nuclei ( [https://github.com/projectdiscovery/nuclei](https://github.com/projectdiscovery/nuclei)
    ) vulnerability scanner has a template for discovering DNS names associated with
    **Transport Layer Security** ( **TLS** ) certificates.
  prefs: []
  type: TYPE_NORMAL
- en: TLS certificates are digital certificates that authenticate the identity of
    a website and enable an encrypted connection. They contain information about the
    certificate holder, the certificate’s public key, and the digital signature of
    the issuing **certificate authority** ( **CA** ). The TLS **Subject Alternative
    Name** ( **SAN** ) is an extension to the X.509 specification that allows users
    to specify additional hostnames for a single SSL/TLS certificate. This means a
    single certificate can secure multiple domains and subdomains, simplifying certificate
    management and reducing costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Nuclei vulnerability scanner has a scan template that extracts TLS SANs
    from the digital certificate. First, I scanned the list of live IP addresses with
    Nuclei. Here’s an example of using the Nuclei **ssl-dns-names** template to scan
    a network address that was in scope for the Hyatt Hotels bug bounty program (
    [https://hackerone.com/hyatt/policy_scopes](https://hackerone.com/hyatt/policy_scopes)
    ) at the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Scanning a network for TLS certificate SANs](image/B22229_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Scanning a network for TLS certificate SANs
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you add the **-o [filename]** option to the Nuclei scan command seen
    in *Figure 8* *.11* to save the output to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this output, the next step is to clean it up and reformat it
    for our **hosts** file. The **hosts** file is a simple text file that maps hostnames
    to IP addresses. It’s an essential part of the networking stack in any operating
    system, including Linux. You can view the contents of your **hosts** file by entering
    the **cat /** **etc/hosts** command.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, it’s important to understand how DNS works in regard to the
    **hosts** file. On a Linux system, when you use a domain name for network communications,
    your computer must resolve the domain name to an IP address. At a very basic level,
    when you use a domain name to communicate with other hosts over the network, the
    first step is for your computer to check its own hostname for a match. Next, it
    checks for an entry in the **hosts** file. If that doesn’t resolve the hostname,
    it communicates with the DNS server in your network interface configuration. Essentially,
    hardcoding a domain name to an IP address in your **hosts** file overrides DNS.
    Microsoft Windows also uses a **hosts** file for the same purpose, although it’s
    in a different location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the contents of my **hosts** file before making
    any modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – The content of my /etc/hosts file](image/B22229_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – The content of my /etc/hosts file
  prefs: []
  type: TYPE_NORMAL
- en: The **hosts** file entries start on a new line with an IP address, followed
    by either tabs or spaces, followed by one or more domain names. You can use tabs
    or spaces, just be consistent. Now that you understand the **hosts** files, let’s
    move on and learn how to reformat the data from the Nuclei scan for insertion
    into our **hosts** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will take a filename as the only command-line argument and
    output lines you can copy and paste into your **hosts** file. The code is thoroughly
    commented to explain what each part does. The example code can be found in the
    **ch08_nuclei.sh** file in this chapter’s folder in the GitHub repository. I’m
    going to split up the code into smaller chunks to explain each part as we go.
    It will be helpful to have the script in GitHub open on your screen to compare
    to the following code narrative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If a file path isn’t passed on the command line, print usage and abort. It first
    checks whether the number of arguments ( **$#** ) is not equal ( **-ne** ) to
    **1** . If the statement in square brackets is true, then echo the description
    of th e script and usage example and exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, I pipe the file content to the cut command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The **cut** command uses a space as delimiter from the 4th field to the end
    of line. The output is piped to the next command. A backslash ( **\** ) at the
    end of a line continues the command on to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, multi-part (6) sed commands are separated by semi-colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Only the beginning and end of the series of sed commands are enclosed in single
    quotes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s/:443//** : Removes the string **:443** from the input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s/\[//g** : Removes all occurrences of the [ character from the input. The
    **g** at the end means *global* , so it applies the substitution to all matches
    in each line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s/\]//g** : Removes all occurrences of the **]** character from the input
    (global). The **]** character must be escaped ( **\** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s/"//g** : Removes all occurrences of the double quote ( **"** ) character
    from the input (global).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s/,/ /g** : Replaces all occurrences of the comma ( **,** ) character with
    a space (global).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s/ \*\.[^ ]*//g** : This expression typically removes wildcard subdomain
    entries like ***.example.com** (global). It removes any space followed by ***.**
    (escaped) and any sequence of non-space characters. Remember from [*Chapter 4*](B22229_04.xhtml#_idTextAnchor073)
    that the **^** character can have multiple meanings. Outside of square brackets
    it matches the beginning of a word or line. Inside of square brackets it negates
    the following characters. In this case, it’s saying *do not* *match spaces* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**| \** : Finally, the resulting output is piped ( **|** ) to the sort command
    that follows. The backslash ( **\** ) character allows the command to continue
    on the next line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The input is sorted uniquely ( **-u** ), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The data is sorted on the second field through the end of line ( **-k2** ).
    If we did not want to sort on the second field to the end of the line and instead
    wanted to sort only the second field, we would have used **-k2,2** . The numbers
    represent the *start* and *stop* fields, which are delimited with spaces by default.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the output is piped to the next command and the backslash continues the
    command to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code starts an **awk** code block before initializing the **new_line**
    variable as an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last line of the preceding code we start a for loop inside the **awk**
    code block that iterates over all fields in the current record. Here’s a breakdown
    of that line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**i = 1** : Initializes the **i** variable to **1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**i <= NF** : **i** is less than or equal to the number of fields ( **NF**
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**i++** : Increment **i** and repeat the loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code skips any wildcard domains. Wildcard domains are those that
    have an asterisk ( ***** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, if the current value of **i** does not contain an asterisk
    ( ***** ), concatenate it to **new_line** with a space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the closing brace ( **}** ) ends the **for** loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code uses the **sub** function to trim trailing spaces.
    The usage of **sub** is **sub(regex, replacement, target)** . The **target** value
    is optional, and when not included, it defaults to the entire current record (
    **$0** ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code splits **new_line** into an array called **fields** using
    a space as the delimiter, then prints the new line only if it contains more than
    one column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this script is shown in the following figure. If you copy and
    paste the output into your **hosts** file, it will override DNS when resolving
    a hostname:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – The output of the ch08_nuclei_01.sh script](image/B22229_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – The output of the ch08_nuclei_01.sh script
  prefs: []
  type: TYPE_NORMAL
- en: You may ask why I put so much work into making a script to create three lines
    instead of just copying and pasting. Remember, this exercise began as an example
    of a challenge I solved during an external pentest that had thousands of live
    hosts in scope and the script printed hundreds of lines to add to my **hosts**
    file.
  prefs: []
  type: TYPE_NORMAL
- en: After adding the script output to my **hosts** file, when I scan those domain
    names, I can be sure that the names are resolving to the IP address that I choose,
    instead of resolving to the IP address of a CDN protected by a WAF.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bash to format vulnerability scan targets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, you learned about HTTP **HOST** headers, TLS certificate
    SANs, and the **hosts** file. You also learned how to parse a Nuclei scan report
    and format the data for use in your **hosts** file. Related to this theme, you
    may also need to convince your vulnerability scanner to override DNS when scanning
    targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nessus ( [https://www.tenable.com/products/nessus](https://www.tenable.com/products/nessus)
    ) is a vulnerability scanner in common use by system administrators and security
    professionals. On the same pentest where I needed to override DNS and add subdomains
    parsed from a Nuclei scan to my **hosts** file, I needed to accomplish the same
    task for my Nessus scan. I eventually learned that Nessus doesn’t use the **hosts**
    file to resolve domain names. However, I did learn that Nessus does allow you
    to override DNS by specifying targets in the format **server1.example.com[192.168.1.1]**
    . The following code will take the output of the **ch08_nuclei_01.sh** script
    and convert it to the Nessus format. The example code can be found in the **ch08_nessus.sh**
    file in this chapter’s folder in the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This code simply checks to ensure that there is exactly one command-line argument
    passed to the script. If not one argument is entered, print the usage and exit.
    An **exit** code of anything other than zero is considered an error. This is important
    when your script logic must determine whether a previous command or script was
    completed successfully before running the next one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates an array to track unique hostnames.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code reads the file and processes each line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This code reads each line of input and uses **cut** to select the fourth field,
    the IP address. This results in an IP address and port that are separated by a
    colon. The last **cut** statement separates the two, selects the IP address, and
    assigns it to the **ip** variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This line cuts the data into fields separated by spaces and selects the fifth
    field. It then selects the data inside square brackets and assigns it to the **hostnames**
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This line sets the comma as the field separator and reads each hostname into
    the **ADDR** array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This code removes leading and trailing spaces from the hostname. By default,
    **xargs** trims leading and trailing whitespace and reduces any sequence of whitespace
    characters to a single space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code checks whether the first character of the hostname is not
    an asterisk.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This code checks whether the value of the **hostname** variable is not present
    in the **seen_hostnames** array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This code adds the hostname to the **seen_hostnames** array if the preceding
    **if** statement evaluates to **true** (the **hostname** variable value is not
    in the **seen_hostnames** array).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This code prints the hostname and IP in the desired format, then closes the
    **if** / **fi** and **do** / **done** code blocks. The **done < "$1"** code passes
    the command-line argument to the code block as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this script can be copied into a Nessus scan target list. The
    output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – The output of the Nessus script](image/B22229_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – The output of the Nessus script
  prefs: []
  type: TYPE_NORMAL
- en: This will allow you to make Nessus override DNS to scan by hostname resolved
    to the IP address that you specify.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the critical phase of reconnaissance and
    information gathering, focusing on how to discover various assets owned by the
    target organization. This chapter equipped you with the knowledge and tools to
    perform thorough reconnaissance using Bash scripting, which sets the foundation
    for subsequent active assessment stages.
  prefs: []
  type: TYPE_NORMAL
- en: Building on the reconnaissance skills acquired in this chapter, [*Chapter 9*](B22229_09.xhtml#_idTextAnchor241)
    will guide you through the application of Bash scripting in web application pentesting.
    As web applications are often key targets due to their accessibility and potential
    vulnerabilities, this chapter will focus on various techniques to identify, exploit,
    and document security weaknesses in web applications using Bash and related tools.
  prefs: []
  type: TYPE_NORMAL
