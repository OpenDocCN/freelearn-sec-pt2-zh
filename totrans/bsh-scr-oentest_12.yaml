- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network and Infrastructure Pentesting with Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explores how to use Bash for network and infrastructure pentesting.
    We’ll look at how Bash can be a powerful tool for probing network systems, identifying
    vulnerabilities, and simulating attack scenarios. You’ll gain a comprehensive
    understanding of how to use Bash for scanning, enumeration, and vulnerability
    assessment in an internal network environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of network pentesting with Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced network scanning techniques in Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating network services and protocols using Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure vulnerability assessment with Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along, at a minimum, you will need access to a Bash shell. To perform
    the demonstrated exercises, you will need to build the **Game of Active Directory**
    ( **GOAD** ) lab. You can find GOAD at [https://github.com/Orange-Cyberdefense/GOAD](https://github.com/Orange-Cyberdefense/GOAD)
    .
  prefs: []
  type: TYPE_NORMAL
- en: GOAD is an Active Directory exploitation lab. If you’re not familiar with Active
    Directory, it’s a system for managing a large number of related Microsoft Windows
    systems. The default Windows and Active Directory configurations frequently have
    vulnerabilities that can be exploited. There are additional exploitable misconfigurations
    in the lab beyond default settings. The Active Directory vulnerabilities in the
    GOAD lab are frequently found on internal network pentests, making this one of
    the best labs for practice or for testing new pentest tools.
  prefs: []
  type: TYPE_NORMAL
- en: I use Ludus to deploy my GOAD lab. I run a Ludus server, and on the client side
    (my laptop), I use the Ludus client to automate building, starting, and stopping
    my lab environment. Ludus makes it easy to automate lab deployment of complex
    network environments. I have deployed my Ludus range with both GOAD and Vulhub
    templates for a mix of internal network pentesting targets along with a mix of
    known vulnerable web applications. You can read more about Ludus at [https://docs.ludus.cloud](https://docs.ludus.cloud)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Which should you choose, GOAD or Ludus? GOAD must be installed on a Linux system,
    but you can continue to use that Linux system for other uses. The Ludus server
    requires installing it *bare metal* on a computer. After installing Ludus, you
    will not be able to use that computer for anything other than a virtual server.
    If you can, I recommend dedicating a computer to running Ludus and deploying GOAD
    from there. You will need a lab environment throughout your pentesting career,
    and Ludus makes running a lab environment easy.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter10](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter10)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following commands to install the prerequisites in Kali:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Greenbone Community Edition, formerly known as OpenVAS. The hardware
    or virtual hardware minimum requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU** : 2 cores'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAM** : 4 GB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage** : 20 GB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the following command to install and configure Greenbone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a note of the admin account password in the output. Once the setup completes,
    run the following command to ensure everything is in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, if everything went well, you should see this at the end: **It
    seems like your GVM-[version] installation** **is OK.**'
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of network pentesting with Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network pentesting, or pentesting, is a critical practice in cybersecurity.
    It involves simulating attacks on a network to identify vulnerabilities before
    malicious actors can exploit them. Various methodologies guide pentesters through
    this process, ensuring thorough and systematic assessments. Bash scripting, a
    powerful tool in the Unix/Linux environment, plays a significant role in automating
    and enhancing these methodologies. Let’s dive into the core methodologies of network
    pentesting and explore how Bash scripting can be leveraged effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Core methodologies in network pentesting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The core methodologies in network pentesting include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reconnaissance** : Reconnaissance is the initial phase where information
    about the target network is gathered. This can be passive (e.g., searching public
    records) or active (e.g., scanning the network).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Scanning** : In this phase, pentesters use tools to discover live hosts,
    open ports, and services running on the network. This helps in mapping the network
    and identifying potential entry points.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enumeration** : Enumeration involves extracting more detailed information
    from the network, such as user accounts, machine names, and network shares. This
    phase builds on the data gathered during scanning.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exploitation** : Here, pentesters attempt to exploit identified vulnerabilities
    to gain unauthorized access to systems or data. This phase tests the effectiveness
    of security measures in place.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Post-exploitation** : After gaining access, pentesters assess the extent
    of the breach, maintain access, and gather additional information. This phase
    helps in understanding the potential impact of an attack.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reporting** : Finally, pentesters compile their findings into a report, detailing
    vulnerabilities, exploited weaknesses, and recommendations for remediation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We covered reconnaissance in [*Chapter 8*](B22229_08.xhtml#_idTextAnchor213)
    . This chapter will focus on scanning, enumeration, and exploitation. Post-exploitation
    and reporting will follow in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Pentesters need to be able to hyper-focus on attention to detail to be effective.
    Pentests are usually time-boxed, meaning you have limited time between a scheduled
    start and stop date. The value of having Bash scripting skills is the time it
    saves. We want to automate running scanning and enumeration, saving us precious
    time to focus on the details output from our tools. This is where Bash scripting
    is valuable.
  prefs: []
  type: TYPE_NORMAL
- en: During a pentest, we need to run a list of tools. Often, we must chain together
    the output of one tool with the input of another. This process usually involves
    transforming data, as we have seen in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the pentest environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: My first step when starting a network pentest is to create a directory structure
    to hold the data. The top-level directory is the name of the pentest. In this
    case, I’ll call it **bashbook** . Then, I create directories under **bashbook**
    for logs, scans, and loot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Network pentest directory structure example](image/B22229_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Network pentest directory structure example
  prefs: []
  type: TYPE_NORMAL
- en: Under the top-level directory, **bashbook** , I’ll create two files, **scope.txt**
    and **exclusions.txt** . The **scope.txt** file is where I list the IP or network
    addresses I’m authorized to test. The **exclusions.txt** file includes any IP
    addresses or hostnames that are off-limits. This way, if my authorized scope is
    the network address **10.2.10.0/24** but **10.2.10.13** is excluded, I can put
    that address in **exclusions.txt** to ensure I skip that address.
  prefs: []
  type: TYPE_NORMAL
- en: The **logs** directory is where I’ll place a copy of the output of every command
    I run in the terminal. For terminal logging, I’m a huge fan of the **tee** command.
    There are methods to log all command-line activity to a single file, but I personally
    like to append the **tee** command to each command and save individual log files.
    This saves the output to a file that will have a date and time stamp and a meaningful
    filename. If my customer reports an outage and asks me what I was doing, I can
    look in my **logs** directory at the timestamps and provide an answer. Additionally,
    these log files are valuable in case I realize after testing ends that I’ve missed
    a screenshot for the report. I can simply **cat** the log file and take a screenshot.
    These log files will also be used when I need to parse data to discover all affected
    hosts for a report finding. To execute a command and see the output while saving
    the output to a file, use the Bash pipe symbol ( **|** ) between the command and
    **tee** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, I have a meaningful log filename with a timestamp and the output of my
    command for parsing later.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you run another command and pipe it to **tee** and an existing filename,
    the file will be overwritten. To append to a file, use **tee -** **a [filename]**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Using tmux for persistent sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start hacking, I want to introduce you to another shell utility,
    **tmux** . Let’s take a look at the output of the **man** **tmux** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The reason why **tmux** is so important to our work is that pentesters frequently
    work remotely and must connect to or through remote systems to do their work.
    For example, I work 100 percent remotely. When I perform an internal network pentest
    for a customer, I don’t go onsite. I ship a small computer such as an Intel NUC
    or a System76 Meerkat to my customer site. The customer plugs it into the network
    and turns it on. The device then connects to a bastion host on my team’s **network
    demilitarized zone** ( **DMZ** ) using the Wireguard protocol. I then use SSH
    with public and private keys to securely connect to my customer’s internal network
    through my Bastion host.
  prefs: []
  type: TYPE_NORMAL
- en: After establishing my SSH session, I immediately start or resume a **tmux**
    session. You may be disconnected from a remote system while running a scan, or
    worse, after you’ve exploited a system and established a reverse shell. The **tmux**
    program keeps your shell session and running processes alive if you get disconnected.
    Without it, if you run a command and get disconnected from the SSH session, all
    running processes are killed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore how to use **tmux** . First, run **tmux** and start a new session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The session name is not required. You may also start a new session by simply
    entering **tmux** . If you work with others and are sharing a system, it’s a good
    idea to name your session.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our terminal window will have the name of the session and a single default
    window in the lower left-hand corner. The current window is denoted by the addition
    of the asterisk ( ***** ) at the end of the window name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – A new tmux session status line is displayed](image/B22229_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – A new tmux session status line is displayed
  prefs: []
  type: TYPE_NORMAL
- en: '**tmux** may be controlled from an attached client by using a key combination
    of a prefix key, *Ctrl* + *b* by default, followed by a command key. To detach
    from the **tmux** session, enter the key combination *Ctrl* + *b* , *d* . This
    means pressing and holding the *Ctrl* key ( *control* key on macOS keyboards),
    then pressing and releasing the *b* key, then releasing the *Ctrl* key and pressing
    the *d* key. When you reconnect to the SSH session, you reconnect to the session
    by entering **tmux a -t [session name]** . This means **tmux** will attach ( **a**
    ) to a target session ( **-t** ) followed by the session name.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s create a new window by entering *Ctrl* + *b* , *c* .
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – A new window is created in the tmux session](image/B22229_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – A new window is created in the tmux session
  prefs: []
  type: TYPE_NORMAL
- en: '**tmux** is able to rename windows based on the running command. However, if
    you want to manually rename a window, use the *Ctrl* + *b* , *,* (Press *Ctrl*
    + *b* key combination, release the keys, then press the *,* (comma) key) followed
    by the desired name and the *Enter* key. Notice that the current window is now
    named **foo** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The current window is renamed](image/B22229_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – The current window is renamed
  prefs: []
  type: TYPE_NORMAL
- en: To switch between windows, press *Ctrl* + *b* + *n* to switch to the next window
    or *Ctrl* + *b* + *[window number]* to switch to a specific window. **tmux** can
    also split the terminal into multiple panes. To see the default hotkeys, enter
    **man tmux** in your Bash shell. If **tmux** is not already installed, you can
    install it with the **sudo apt update && sudo apt install** **tmux** command.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up our pentest system and are familiar with the basic tools,
    let’s start scanning!
  prefs: []
  type: TYPE_NORMAL
- en: Basic network scanning with Nmap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B22229_06.xhtml#_idTextAnchor148) , you learned how to use
    Bash for very basic port scans. Those concepts are useful in situations where
    you’re in a limited network environment and cannot install standard scanning tools
    such as Nmap. However, a pure Bash port scanner would not be my first choice of
    tool when performing network pentesting scans. Here, we’ll start working with
    Nmap and Masscan.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command is an example of the most basic Nmap scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that the IP address in your GOAD environment may differ from the examples
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the partial output from this scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Partial output from a basic Nmap TCP port scan](image/B22229_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Partial output from a basic Nmap TCP port scan
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have very basic information shown in the preceding figure. The
    output for each port lists services that are the defaults for the port number.
    Since we didn’t use any other scan flags, Nmap used a connect scan ( **-sT** )
    by default, and didn’t perform service fingerprinting, and the output wasn’t saved
    to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous scan showed a default TCP scan. To scan UDP ports, use the **-sU**
    flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the UDP scan can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Partial output from a basic UDP port scan with Nmap](image/B22229_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Partial output from a basic UDP port scan with Nmap
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore more advanced usage in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Fast network scanning with Masscan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another popular port scanner is Masscan, which is an extremely fast port scanner.
    It can scan the whole internet in a matter of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap is more full-featured than Masscan; however, Masscan has the capability
    to perform scans much faster by including a **--rate** option. Yes, Nmap also
    has the ability to tweak scan speed; however, Masscan can be much faster. Be careful
    with this option as you may overwhelm network devices such as routers and switches.
    When you have a *kickoff call* with project stakeholders before the pentest starts,
    you should ask whether you will be scanning through outdated network devices that
    may not be able to withstand high throughput.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic Masscan example can be found in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Partial output of an example Masscan scan](image/B22229_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Partial output of an example Masscan scan
  prefs: []
  type: TYPE_NORMAL
- en: 'On very large networks, I’ll frequently use Masscan to discover a list of live
    hosts, which are then fed to another more advanced scan. The following **masscan**
    command is what I use to discover live hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this down to understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-p 22,445** : On an internal network, every Linux host will have port **22**
    (SSH) exposed, and every Windows host will have port **445** ( SMB) exposed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--open** : We specify **open** because don’t want to see closed or filtered
    ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-oL [outputfile]** : We specify the name of the file to save the results
    in list format. Other possible output formats include JSON, NDJSON, Grepable,
    Binary, XML, and Unicorn.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-iL [inputfile]** : We specify the **scope.txt** file containing the networks
    in scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--rate=5000** : This sends TCP *SYN* packets at a rate of 5,000 packets per
    second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On my lab network running GOAD and Vulhub, the output of my scan looks like
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Masscan host discovery output file content](image/B22229_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Masscan host discovery output file content
  prefs: []
  type: TYPE_NORMAL
- en: Processing scan results with Bash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display only live hosts, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**''** : A single quote character starts and ends the **awk** command block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$1 == "open"** : The first column is the word **open** , as seen in *Figure
    10* *.8* . Remember from [*Chapter 4*](B22229_04.xhtml#_idTextAnchor073) that
    **awk** splits columns on whitespace by default, which includes both spaces and
    tabs. If the columns were separated by tabs, this command would still work. Otherwise,
    include the **-F** option to specify a different field separator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**{ print $4 }** : Print the fourth column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**masscan.lst** : The Masscan output file that we want to parse using this
    command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**| sort -uV** : We pipe the **awk** command output to sort, specifying the
    **sort** options unique ( **-u** ) and version ( **-V** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**> livehosts.txt** : We redirect the output of the preceding commands from
    **stdout** to a file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The **sort -V** (version) option is useful for sorting IP addresses and version
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like the following if you remove the redirect to a file and
    print to **stdout** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Our unique sorted list of live IP addresses](image/B22229_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Our unique sorted list of live IP addresses
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the output in *Figure 10* *.8* (unsorted) to *Figure 10* *.9* (sorted),
    you can see how the **sort -V** option is useful for sorting version numbers,
    IP addresses, or any string that is a combination of numbers separated by periods.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have a list of live hosts, saving you valuable time when scanning very
    large networks.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This wraps up the section on the fundamentals of network pentesting with Bash.
    The foundation created by the concepts in this fundamental section, plus the previous
    work we covered in [*Chapter 6*](B22229_06.xhtml#_idTextAnchor148) on networking
    and basic port scans, will be used in the next section to learn about more advanced
    scanning techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced network scanning techniques in Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will go more in depth, demonstrating some of the most common advanced
    options of Nmap. Then, we’ll follow up with a primer on parsing the report output.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the Nmap scan command I use most of ten for network pentesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-sS** : *SYN* scan, or half-open scan. This sends only the first part of
    the TCP handshake and scans much faster than the default connect ( **-sT** ) scan,
    which completes the TCP three-way handshake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-sV** : A version scan fingerprints the service name and version instead
    of the default, which only prints the default service name associated with the
    port number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-sC** : Runs Nmap scripts against all open ports. The output of these scripts
    frequently reveals important or even exploitable information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-p [port list]** : The list of ports to scan. These are port numbers that
    I have found to be the most common exploitable ports in my experience. If you’re
    scanning a single host or small number of hosts, or you absolutely must find every
    open port, use **-p-** instead, which is shorthand for all ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--open** : Only record open ports; don’t show closed or filtered ports in
    the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-oA [output file]** : The **A** option equates to all formats. If you named
    the output file **nmapquick** , you would find the following three output files
    in the current directory once the scan completes: **nmapquick.nmap** , **nmapquick.gnmap**
    , and **nmapquick.xml** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-iL [input file]** : The file containing the list of IP addresses, network
    addresses, or hostnames to scan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--exclude-file [exclude file]** : The file containing a list of IP addresses,
    network addresses, or hostnames to exclude from your scan. See the *Rules of Engagement*
    document for your pentest to find a list of any hosts to be excluded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the scan output, we examine one of the hosts in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – The output of our scan on one host](image/B22229_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – The output of our scan on one host
  prefs: []
  type: TYPE_NORMAL
- en: The Nmap script output can be seen by the dashed lines and the output they contain
    in the figure. This reveals the hostname and service versions. Additionally, we
    can guess that this is an Active Directory domain controller because it’s running
    Microsoft Windows, and ports **53** , **88** , **3268** , and **3269** are open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scanning can be a trade-off between fast and thorough. For example, in the
    scan that we ran last, which specified a limited number of common ports, the output
    for host **10.2.10.1** shows one open port, as seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Nmap scan output using a limited number of common ports](image/B22229_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Nmap scan output using a limited number of common ports
  prefs: []
  type: TYPE_NORMAL
- en: If we rescan this host using the **-p-** (all ports) option, we find that the
    host actually has seven open ports, some running vulnerable applications. This
    example illustrates the difference between fast and thorough scanning. What I
    normally do when testing small networks is scan all ports. If I’m testing a large
    network, I run one fast scan specifying a limited number of ports, and while I’m
    working through that scan result, I start a second scan running targeting all
    ports, which I expect to take a day or more to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a firm grasp of different port scanning techniques, let’s
    move on to the next section and explore various exploitable network protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating network services and protocols using Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I perform a network packet capture on every internal network pentest. I’m looking
    for the default **Hot Standby Router Protocol** ( **HSRP** ) default password
    of **'cisco'** , DHCPv6 discovering broadcasts without a corresponding offer,
    and broadcast or multicast protocols such as LLMNR, NBT-NS, and MDNS, which can
    yield password hashes or be relayed to crack into other systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be found on this chapter’s GitHub page as **packetcap.sh**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first block of code is the familiar shebang, followed by an **if** statement
    that prints usage information and exits if exactly one argument is not provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This block of code lets the user know what’s happening before running tcpdump
    for two and a half minutes. After **sudo** , the **timeout 150** command preceding
    **tcpdump** runs **tcpdump** for 150 seconds and quits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This block of code detects plaintext HSRP broadcasts using the default **'cisco'**
    password. If you have this password, you can poison the HSRP election process
    and take over as the default router, and execute a **Man-in-the-Middle** ( **MITM**
    ) attack on all traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you detect the default HSRP password in use on a network, I caution you to
    not attempt to execute an MITM attack on it. If you’re not on-site with the system
    running the attack and you lose your network connection, you may cause a denial
    of service to the network and you won’t be there to stop it. This is very risky
    to exploit. It’s best to report it and move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next code block, we start testing for **IP version 6** ( **IPv6** )
    network traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This block of code tests for DHCPv6 traffic. If you see DHCPv6 discover broadcasts
    without a responding offer, the network is likely to be vulnerable to an attack
    where you can run the mitm6 tool and capture password hashes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This block of code runs the *Responder* tool in a subshell so that you won’t
    see the output. Then, it prints anything in the **Responder-Session** log. You
    may see password hashes or plaintext passwords in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figures show the script in action. This shows the start of the
    script output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Starting the network sniffer script](image/B22229_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Starting the network sniffer script
  prefs: []
  type: TYPE_NORMAL
- en: Further down in the output, you see password hashes printed to the screen. This
    is an NTLMv2 password hash, which you should attempt to crack using **hashcat**
    . You can also reconfigure **Responder** and run it again along with **impacket-ntlmrelayx**
    to relay to other systems to run commands or dump credentials.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Responder captures a password hash](image/B22229_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Responder captures a password hash
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s attempt to crack them using **hashcat** . Before running the following
    command, copy and save those hashes to a file. Next, run **hashcat** as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The following figure shows that we cracked one of the password hashes!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Hashcat is used to crack an NTLMv2 password hash](image/B22229_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Hashcat is used to crack an NTLMv2 password hash
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You aren’t limited to only cracking password hashes from these protocols; you
    can also relay them. Search the internet for **relay LLMNR** to find out more
    about the subject.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t overlook these protocols on your network. While they aren’t listening
    services that you can point an exploit at and get a shell, they are *dangerous
    default* protocols that you’re likely to find broadcast on any Windows domain,
    and they are usually the fastest way to exploit systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore using Bash with vulnerabi lity assessment
    and exploitation tools.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure vulnerability assessment with Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assessing infrastructure vulnerabilities is a critical step in maintaining
    network security. With Bash, we can leverage powerful tools to automate network
    host discovery and vulnerability scanning, streamlining the assessment process.
    This section covers two essential techniques: identifying network hosts with NetExec
    and automating vulnerability scans using Greenbone. Each technique offers a practical
    approach to improving your security posture by reducing manual effort while enhancing
    efficiency and accuracy in detecting vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating network hosts with NetExec
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting from an unauthenticated perspective, we will examine TCP port **445**
    since it’s historically had a lot of vulnerabilities and can yield a lot of information.
    We will use the NetExec tool to enumerate network hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s attempt to use an SMB null session to enumerate SMB shares. Run
    the following command, replacing the network address with the a ppropriate address
    for your lab instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**netexec smb** : Here, we specify the protocol for NetExec to use. The **netexec**
    command has multi-protocol support, including SMB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10.2.10.0/24** : The target goes after **netexec** and the protocol. The
    target can be an IP address, hostname, network address, or a file containing targets
    (one per line).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-u a -p ''''** : We specify a random username ( **a** ), followed by a blank
    password ( **''''** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--shares** : This is a **netexec** command to enumerate SMB shares.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Performing SMB null session SMB share enumeration with NetExec.](image/B22229_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Performing SMB null session SMB share enumeration with NetExec.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is a cropped screenshot and doesn’t show the hostname or IP address
    of each system. Without cropping the image, the text would be too small to read.
    Notice where we have read or write permissions in the preceding figure. In this
    case, I recommend taking the time to connect to these SMB shares and look for
    interesting information, such as passwords in files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s attempt to use an SMB null session to enumerate users. Run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference between this and the previous command is we’ve changed
    shares ( **--shares** ) to users ( **--users** ). We check the output and see
    we had no luck enumerating users. Before giving up, let’s r evise the command
    as follows and try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of specifying a username, we’ve used a blank username.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Using an SMB null session to list domain users](image/B22229_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Using an SMB null session to list domain users
  prefs: []
  type: TYPE_NORMAL
- en: So why did one method of specifying an invalid username fail and the other succeed?
    Without going too far off the track of our Bash topic, it’s due to how the libraries
    used in this tool authenticate to Microsoft Windows SMB shares. I’ll leave that
    as an exercise to you. I just want you to be aware of this quirk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these usernames, you can use NetExec to password spray common passwords
    and maybe you’ll get lucky. But do you really need to password spray? Go and take
    another look at *Figure 10* *.16* and check the **Description** column. Do you
    see the password for Samwell Tarly? You would be surprised how often this happens
    on the average corporate network! Many system administrators don’t realize that
    null sessions and unprivileged users can see this information. Let’s test this
    password, as seen in the next figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Testing credentials with NetExec](image/B22229_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Testing credentials with NetExec
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we see that the credentials for Samwell Tarly are authenticated
    to three systems, but this account isn’t an administrator on any of them, otherwise,
    the output would show **Pwn3d!** . There’s a lot more we can do with these credentials.
    I’ll leave it as an exercise for you to run **netexec** with the **--help** and
    **-L** (list modules) options to explore the commands and modules available to
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: If you’re following along in your own GOAD lab, take a look at the **petitpotam**
    SMB module.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll dive into vulnerability scanning from the Bash shell.
  prefs: []
  type: TYPE_NORMAL
- en: Automating vulnerability scanning with Greenbone
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of top vulnerability scan products on the market. All have
    a web interface. However, you should learn how to automate these scans from the
    Bash shell to save yourself valuable time. When I was responsible for enterprise
    vulnerability scanning of a global corporation, I used Bash shell to interface
    with the scanner API to automate as much of my job as I could, including gathering
    statistics for custom reports.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Greenbone Community Edition, formerly known as OpenVAS. If you
    want to follow along in your own lab, you should first review the *Technical requirements*
    section if you have not already installed Greenbone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a scan target as shown here, replac ing the password and network with
    your own values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command can be found in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Creating a scan target in GVM](image/B22229_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Creating a scan target in GVM
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the target ID output from creating a target to cr eate a task for a full
    and fast scan, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command can be found in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – A scan task is created in GVM for demonstration](image/B22229_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – A scan task is created in GVM for demonstration
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the task using the task I D found in the response from the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command can be found in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 10.20 – Starting a task in GVM\uFEFF\uFEFF](image/B22229_10_20.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – Starting a task in GVM
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the task status using the command as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command can be found in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.21 – Demonstrating checking the scan task status](image/B22229_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 – Demonstrating checking the scan task status
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the report using the report ID from the previous command output, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s create a script to automate this process and parse the report.
    The following code can be found in this chapter’s GitHub repository as **ch10_gvm_scan.sh**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding block of code begins with the familiar shebang line. It then checks
    to ensure the user running the script is the **_gvm** user, which is a user created
    during the **gvm** installation process. If not running as this user, the script
    exits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The script will exit if there are less than two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we assign the first argument to the **password** variable,
    and the second argument to the **target_host** variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re simply replacing any **/** character in the target with an underscore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code block creates a target in the GVM system:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses **gvm-cli** to send an XML request to create a target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The target is created with the specified name, host, and port range.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It extracts the target ID from the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If target creation fails (empty **target_id** ), the script exits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code will create a scan task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This section creates a task in the GVM system:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses **gvm-cli** to send an XML request to create a task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task is created with a name, comment, configuration, and the previously
    created target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It extracts the task ID from the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **grep -o ''id="[^"]*"''** command searches for all occurrences of **pattern
    id="[^"]*"** in the input text and outputs only the matching parts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**id="** matches the literal string, **id="**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[^"]*** matches zero or more characters that are not a double quote ( **"**
    ). **[^"]** is a negated character class meaning any character except **"** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**"** matches the closing double quote'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If task creation fails (empty **task_id** ), the script exits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to start the scan, as shown in this code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code starts the scan task using variables captured from previous
    commands and extracts **report_id** from the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(?<=<report_id>).*?(?=</report_id>)** : This is the regular expression that
    is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(?<=<report_id>)** : This is a positive look-behind assertion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(?<=...)** : This syntax specifies a look behind, which ensures that what
    precedes the current position in the string is the specified pattern, **<report_id>**
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<report_id>** : This is the literal string that must precede the match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.*?** : This is a non-greedy match for any character sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.** : This matches any character except a newline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '***?** : This matches zero or more of the preceding elements ( **.** in this
    case), but in a non-greedy (or lazy) manner, meaning it will match as few characters
    as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(?=</report_id>)** : This is a positive look-ahead assertion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(?=...)** : This syntax specifies a look-ahead, which ensures that what follows
    the current position in the string is the specified pattern, **</report_id>**
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**</report_id>** : This is the literal string that must follow the match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next code section continuously checks for task completion every 60 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code starts a **while** loop. The **gvm-cli** command output is
    printed in a line-by-line format by piping it to **xmlstarlet** , then saved to
    the **output** variable. If the output status confirms it’s completed, it breaks
    out of the loop. Otherwise, there is a one-minute pause before the loop repeats.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code block requests the scan results (vulnerabilities) detected
    in the scan task. It pipes the output to **xmlstarlet** to parse the XML content
    and output the most interesting parts. Finally, it sorts based on the sixth column
    ( **severity** ) and prints the data fields with a tab ( **\** **t** ) separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '**xmlstarlet** is a command-line tool for parsing, querying, transforming,
    and editing XML files. It can be used to extract specific data from XML documents,
    modify XML structures, and perform various other XML-related tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sel -t** : This is short for *select* . It indicates that we are using the
    selection sub-command to query XML data. The **-t** stands for *template* . It
    is used to define the output template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-m "//result"** : This stands for *match* . It specifies an XPath expression
    to select nodes from the XML document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**//result** : This XPath expression selects all result elements in the XML
    document, regardless of their location in the hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sort -t''|'' -k6,6nr** : The **-k** option specifies the key (field) to sort
    by, and the **nr** suffix indicates the type of sorting (numerical and reverse
    order).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-k6,6** : This option tells **sort** to use the sixth field as the key for
    sorting. The **6,6** syntax means it should start and stop sorting on the sixth
    field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**awk -F''|'' ''{printf "%s\t%s\t%s\t%s\t%s\n", $1, $2, $3, $4, $5}''** : This
    code determines how the data is printed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-F** : This option tells **awk** to use a specific character as the field
    separator.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**''|''** : The pipe character is specified as the delimiter. This means **awk**
    will consider the text between pipe characters as separate fields.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**{ ... }** : Encloses the action to be performed on each input line.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**printf** : A function in **awk** (and many programming languages) used for
    formatted output.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**"%s\t%s\t%s\t%s\t%s\n"** : This format string tells **printf** to output
    five string fields ( **%s** ), each followed by a tab character ( **\t** ), and
    end the line with a newline character ( **\n** ).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$1, $2, $3, $4, $5** : These are field variables in **awk** . **$1** refers
    to the first field, **$2** to the second field, and so on. Since the field separator
    is a pipe ( **|** ), these variables correspond to the data between the pipes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The script must be run as the **_gvm** user. When we prefix each command with
    **sudo** inside the script, there’s enough time between some of the steps that
    it will prompt you for credentials while you’ve stepped away, unaware that it’s
    waiting for your input. Instead, we’ll run the script with **sudo -u _gvm** prefixed,
    so you’ll need to run the following comma nds to set up directory and file permissions
    before running the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a new directory using the **mkdir** command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The script is copied to the new directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The directory permissions are changed to set user and group permissions to **7**
    . The number **7** for the user and group equates to read (4), write (2), and
    execute (1) ( *4 + 2 + 1 = 7* ), and the other permissions to read (4) and execute
    (1) ( *4 + 1 =* *5* ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the owner is changed recursively to the **kali** user and **_gvm**
    group on the new directory and everything inside the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following figure demonstrates how to run the script and shows the script
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22 – The Greenbone scan script is demonstrated and shows the scan
    results](image/B22229_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 – The Greenbone scan script is demonstrated and shows the scan
    results
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about **gvm-cli** usage at https://docs.greenbone.net/GSM-Manual/gos-22.04/en/gmp.html#starting-a-scan-using-the-command-gvm-cli
    .
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the section where we focused on vulnerability scanning automation.
    Our attention and focus abilities are finite. Always automate the mundane, repeatable
    tasks so you have more time and the ability to focus on carefully reviewing scan
    results for the smallest details to uncover exploitable vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored the topic of using Bash scripting for network pentesting
    and automation. Port scanning was thoroughly explored, from basic command-line
    options through advanced techniques necessary to tune for speed and depth of results.
    We went through the discovery of common network protocols that are frequently
    exploited. Finally, we dived into the automation of network vulnerability scanning
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will focus on post-exploitation privilege escalation techniques
    in a Bash environment. When remote network services are exploited, they commonly
    result in a non-root shell. In [*Chapter 11*](B22229_11.xhtml#_idTextAnchor317)
    , we will dive in and explore how to enumerate Linux systems in a Bash shell to
    escalate our privileges for a complete system takeover.
  prefs: []
  type: TYPE_NORMAL
