- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pentest Reporting with Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explore the role Bash can play in streamlining the **reporting**
    phase of pentesting. As security professionals know, the final report is a critical
    deliverable that communicates findings, risks, and recommendations to stakeholders.
    However, compiling these reports can be time-consuming and prone to inconsistencies.
    We’ll examine how Bash scripting can automate and enhance various aspects of the
    reporting process, from data collection to report generation.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the chapter, we’ll cover techniques for automating data extraction
    from tool outputs, generating preliminary reports, and integrating Bash with other
    reporting tools. You’ll learn how to create scripts that can parse raw data and
    populate report templates.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have a solid foundation in using Bash to
    create efficient, accurate, and professional pentest reports. These skills will
    not only save time but also enhance the quality and consistency of your deliverables,
    allowing you to focus more on analysis and less on manual report compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Automating data collection for reporting with Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and managing pentest data with SQLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Bash with reporting tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter13](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter13)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following commands to install prerequisites on your Kali Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following commands assume that you have Go installed. See [https://go.dev/doc/install](https://go.dev/doc/install)
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With the prerequisites out of the way, it’s time to dive into reporting, every
    pentester’s favorite subject!
  prefs: []
  type: TYPE_NORMAL
- en: Automating data collection for reporting with Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Efficient data collection is a pillar of effective pentesting reporting. This
    section explores how to leverage Bash scripting to automate the gathering and
    organization of critical information from various phases of a pentest.
  prefs: []
  type: TYPE_NORMAL
- en: 'By automating data collection, pentesters can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reduce manual errors in data gathering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standardize the format of collected information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save time on repetitive data extraction tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure consistency across multiple tests and reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll examine techniques for identifying key data points, extracting information
    from tool outputs, cleaning raw data, storing data in a database, and templating
    reports. These methods will help streamline the reporting process and allow testers
    to focus more on analysis and less on data management.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by looking at how to identify and extract the most relevant data
    for pentest reports using Bash.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying key data points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Key data points** are essential pieces of information that provide a comprehensive
    overview of the test findings, vulnerabilities, and overall security posture of
    the target system or network. These data points form the backbone of an effective
    pentest report.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key data points typically include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Executive** **summary data** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total number of vulnerabilities by severity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Key findings and critical issues
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall risk rating
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compliance information** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relevant compliance standards (e.g., PCI DSS and HIPAA)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific compliance violations or gaps
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test metadata** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date and duration of the test
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope of the assessment
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tester information
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools used during the assessment
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Successful attacks** **or exploits** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Description of successful penetration attempts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Data accessed or exfiltrated
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Potential real-world consequences
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vulnerability information** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerability name and description
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Severity rating (e.g., Critical, High, Medium, or Low)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common Vulnerability Scoring System** ( **CVSS** ) score'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Affected systems or components
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical details** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP addresses and hostnames of affected systems
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Port numbers and services running
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Software versions and patch levels
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploit methods or proof of concept
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk assessment** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potential impact of each vulnerability
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Likelihood of exploitation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Business impact analysis
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing artifacts** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screenshots of vulnerabilities or exploits
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Log file excerpts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Command outputs from tools
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remediation information** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recommended fixes or mitigations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Priority of remediation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Estimated effort for remediation
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing and cleaning raw data using Bash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pentest tool’s primary report output formats include plain text files ( **.txt**
    ), **Comma-Separated Values** ( **CSV** ), **Extensible Markup Language** ( **XML**
    ), and **JavaScript Object Notation** ( **JSON** ). Since plain text output isn’t
    organized into any specific format, it won’t be covered in this section and what
    you previously learned about regular expressions in [*Chapter 4*](B22229_04.xhtml#_idTextAnchor073)
    will suffice. The rest of this section will include strategies for parsing the
    other data formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin with CSV data. The best tool in the Bash toolbox for parsing tabular
    data is undoubtedly **awk** . The basic syntax for **awk** is a s follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, please note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pattern** is an optional condition to match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**action** is what to do when the pattern matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**input_file** is the file to process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you can remove the **input_file** variable if you are piping ( **|**
    ) data because awk can accept input from **stdin** or input files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a CSV file with the following content named **scan_results.csv**
    . You can find this file in this chapter’s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how to extract only the IP and P ort columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-F'',''** sets the field separator to a comma.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$1** and **$3** refer to the first and third fields, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**","** prints a comma between the **$1** and **$** **3** fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s how to show only entries with open web ports ( **80** or **443** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a header and a footer to our output, do th e following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the resultant output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we’re adding something new here, let’s review an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: The awk pattern is **awk 'pattern {** **action}' input_file** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pattern is **$3 == 80 || $3 ==** **443** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action is **{print $1 "," $2 "," $** **3}** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **BEGIN** code prints **Open Web Servers:** and goes before the pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **END** code prints **End of list** and goes after the action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s examine an example showing how to calculate statistics. Let’s say we
    have a **vulnerability_scan.csv** file with se verity levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how to count vulnerabilities by severity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-F'',''** : This option sets the field separator to a comma. The option tells
    awk to split each line into fields using commas as delimiters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**''...''** : The single quotes contain the awk program itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NR>1** : This condition checks whether the current record (line) number is
    greater than 1. It effectively skips the first line (header) of the CSV file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**{...}** : This block contains the main processing logic for each line that
    meets the **NR>1** condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gsub(/\r/,"")** : This function globally substitutes ( **gsub** ) any carriage
    return characters ( **\r** ) with an empty string, effectively removing them from
    the line. This helps handle potential Windows-style line endings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**if($3!="")** : This condition checks whether the third field (severity level)
    is empty or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**count[$3]++** : If the condition is **true** , this increments the count
    for the severity level found in the third field. It uses an associative array
    named **count** with the severity level as the key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**END {...}** : This block specifies actions to be performed after processing
    all lines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**for (severity in count)** : This loop iterates over all unique severity levels
    stored as keys in the **count** array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**print severity ": " count[severity]** : For each severity level, this prints
    the severity followed by a colon and space, then the count of occurrences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**vulnerability_scan.csv** : This is the input file that the AWK command processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, this AWK command reads a CSV file, skips the header, removes carriage
    returns, counts the occurrences of each non-empty severity level, and then prints
    out a summary of these counts. It’s designed to handle potential issues such as
    Windows line endings and empty fields, making it more robust for processing real-world
    CSV data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In another example, we may need to combine multiple files. Here we have another
    fil e, **asset_info.csv** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine this with our v ul nerability data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the resultant output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This script first reads **asset_info.csv** into memory, then processes **vulnerability_scan.csv**
    , adding the owner and department information to each line. Let’s look at the
    explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-F'',''** : This option sets the field separator to a comma, which is appropriate
    for CSV files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NR==FNR** : This condition is true only when processing the first file (
    **asset_info.csv** ). **NR** is the current record number across all files, while
    **FNR** is the record number in the current file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**{owner[$1]=$2; dept[$1]=$3; next}** : This block executes for **asset_info.csv**
    :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**owner[$1]=$2** : Creates an associative array, **owner** , where the key
    is the first field (an asset ID) and the value is the second field ( owner name)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dept[$1]=$3** : Creates an associative array, **dept** , where the key is
    the first field and the value is the third field ( department name)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**next** : Skips to the next record without executing th e rest of the script'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**{print $1 "," $2 "," $3 "," owner[$1] "," dept[$1]}** : This block executes
    for **vulnerability_scan.csv** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prints the first three fields from the current line of **vulnerability_scan.csv**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds the owner and department information by looking up the first field (asset
    ID) in the **owner** and **dept** arrays
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**asset_info.csv vulnerability_scan.csv** : These are the input files. **asset_info.csv**
    is processed first, then **vulnerability_scan.csv** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These examples demonstrate how **awk** can be used to process and analyze CSV
    data from pentesting activities. By combining these techniques, you can create
    powerful scripts to automate data parsing and report generation for your pentest
    findings.
  prefs: []
  type: TYPE_NORMAL
- en: Bash provides several tools that can be used to parse XML data. We’ll focus
    on using **xmllint** and **xpath** , which are commonly available on Linux systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s take a look at the structure of our Nmap XML report. The Nmap
    XML file can be found in this chapter’s GitHub repository as **nmap.xml** . The
    following is the abbreviated content of this file, showing the XML nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s extract all the IP addresses from the scan using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I strongly recommend you have the **nmap.xml** file open in GitHub and compare
    it to the following explanation as we step through it.
  prefs: []
  type: TYPE_NORMAL
- en: This command uses XPath to select all **addr** attributes of **address** elements
    that are children of **host** elements and have an **addrtype** of **ipv4** .
    With this information in mind, go back and read the XML data again to see this
    XML structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**//host** : This selects all host elements anywhere in the document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/address** : This selects address elements that are direct children of the
    host elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[@addrtype=''ipv4'']** : This is a predicate that filters for address elements
    where the **addrtype** attribute equals **ipv4** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/@addr** : This selects the **addr** attribute of the matching address elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – The output of the Nmap XML filter](image/B22229_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – The output of the Nmap XML filter
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a more complex filter using two criteria from the Nmap XML data.
    We’ll find all hosts that have port **80** open and are running Microsoft IIS.
    This combines filtering on port status and service information.
  prefs: []
  type: TYPE_NORMAL
- en: 'H ere’s how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – The output of the command](image/B22229_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – The output of the command
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this is as simple as combining multiple XML queries separated
    by **and** . If you want to include ports **80** or **443** , separate them with
    an **or** keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s examine how to parse JSON data. In these examples, I’m using the
    **mapcidr** and **httpx** tools from ProjectDiscovery. My lab network has the
    network address **10.2.10.0/24** . I run the following command to fingerprint
    HTTP/S se rvers on my lab network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The **httpx.json** file can be found in this chapter’s directory in the GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**echo 10.2.10.0/24 |** : This simply sends the **10.2.10.0/24** string into
    the pipeline ( **|** ) and suppresses the program’s banner ( **-silent** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mapcidr -silent |** : This takes the input, expands it into individual IP
    addresses, and passes them into the pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**httpx -silent -j** : This takes the IP addresses passed in as **stdin** input,
    fingerprints any webservers listening on default ports, and prints the output
    in JSON format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following shows the abbreviated output of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing you should do when examining JSON data structures is view the
    hierarchy by passing the data to **jq .** . The following example command uses
    JSON to output all data in the file in a format that’s easier to read to determine
    how the data is structured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The abbreviated output of this command can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – The JSON data structure from httpx](image/B22229_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – The JSON data structure from httpx
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script parses this JSON data and outputs each field, one per
    line. Let’s examine each line of the script to learn how to parse the JSON fields.
    This script can be found in this chapter’s GitHub repository as **ch13_parse_httpx.sh**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – The output of script ch13_parse_httpx.sh](image/B22229_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – The output of script ch13_parse_httpx.sh
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s discuss how to adapt this lesson to any JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify the structure** : First, examine your JSON output to understand
    its structure. Look for the key fields you want to extract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modify the** **parse_json** **function** : Update the function to extract
    the fields specific to your JSON structure. For example, if your JSON has a field
    called **user_name** , you add the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the **echo** statements to print the fields you’ve extracted. If your
    JSON contains nested objects or arrays, you can use more complex **jq** queries.
    Here’s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before examining the preceding code, take a look at *Figure 13* *.3* and find
    the **tech** node. Using **.tech[0]** , we selected and returned the first result
    in the array. If you wanted to return all array results, you would instead use
    **.tech[]** , which is the whole array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are quick tips to help you pa rse nested JSON data with **jq**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: 'For nested objects, use dot notation: **.parent.child** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For arrays, use brackets: **.array[]** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Combine these for deeply nested structures: **.parent.array[].child** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s expand on how to select nested data with examples. Review the following
    JSON data before moving on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s examine some example **jq** queries for this nested structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the parent name: **jq ''.parent.name''**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output: **"** **Family Tree"**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Get direct child’s name: **jq ''.parent.child.name''**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output: **"John"**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Get all sibling names (array traversal): **jq ''.parent.siblings[].child.name''**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output: **"** **Emma" "Michael"**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Get all ages from both direct child and siblings: **jq ''.** **parent.child.age,
    .parent.siblings[].child.age''**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output: **10** **8 12**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Armed with the knowledge needed to parse common pentest tool report formats,
    you’re prepared for the next step. In the next section, you’ll learn how to store
    data parsed from pentest tool reports into SQLite databases.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and managing pentest data with SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is a lightweight, serverless database engine that provides an efficient
    way to store and manage data collected during pentesting. This section explores
    how to leverage SQLite in conjunction with Bash scripting to create a system for
    organizing and querying pentest findings.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLite offers several advantages for pentesters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Portability** : SQLite databases are self-contained files, making them easy
    to transfer and back up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No setup required** : Unlike full-fledged database servers, SQLite doesn’t
    need installation or configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient querying** : SQLite supports SQL, allowing for complex data retrieval
    and analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language integration** : Many programming languages, including Bash through
    command-line tools, can interact with SQLite databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create SQLite databases using Bash commands?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to write scripts that parse tool output and insert data into SQLite tables?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to run queries on SQLite databases to generate report content?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By combining Bash scripting with SQLite, pentesters can create a flexible and
    powerful system for managing test data and streamlining the reporting process.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create an **SQLite3** database to store our Nmap scan results.
    The following script can be found in this chapter’s GitH ub repository as **ch13_create
    _db.sh** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it defines the database name as **pentest_results.db** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it uses a heredoc ( **<<EOF** ) to pass SQL commands to **SQLite3** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it creates a table named **nmap_scans** if it doesn’t already exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, it defines columns for IP address, hostname, port, protocol, service,
    version, scan date, and vulnerability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, let’s create a script that takes an Nmap scan as input and inserts the
    results into our database. The following script can be found in this chapter’s
    GitH ub repository as **ch13_nmap_to_db.sh** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When the script completes, it will print **Data import completed** to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: The **DB_NAME** variable defines the database name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It uses **xmlstarlet** to parse the XML Nmap report, extracting relevant information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It then formats the extracted data with **|** as a delimiter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A **while** loop is used to read the formatted data line by line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each line, it inserts the data into the **nmap_scans** table using **sqlite3**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may have noticed that our database has a field for **vulnerability** , but
    we didn’t insert any data in this field because we were only populating data from
    the Nmap scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'To update an existing record in the **nmap_scans** table to add a vulnerability
    where it was previously NULL, you can use the SQL UPDATE statement. Here’s how
    you can do this using Bash and the Sqlite3 command-line tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the placeholders with your actual data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VULNERABILITY_DESCRIPTION** : The description of the vulnerability you want
    to add.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IP_ADDRESS** : The IP address of the target system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PORT_NUMBER** : The port number where the vulnerability was found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if you want to update the record for the **10.2.10.10** IP on
    port **80** to add an **SQL Injection vulnerability** de scription, you will use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This command will update the vulnerability field for the record that matches
    the specified IP address and port, but only if the vulnerability field is currently
    **NULL** . This ensures you don’t overwrite any existing vulnerability descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to update the vulnerability regardless of whether it’s **NULL**
    or not, you can remove th e **AND vulnerability IS** **NULL** condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have data in our database, let’s create a script to query and display
    the results. The following script can be found in this chapter’s GitHub repository
    as **ch13_read_db.sh** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the output from this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – The database contents](image/B22229_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – The database contents
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an explanation of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DB_NAME="pentest_results.db"** sets a variable with the name of the database
    file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **truncate()** function is defined. It takes two arguments: a string and
    a maximum length. It checks whether the string is longer than the maximum length.
    If it is, it cuts the string short and adds **...** at the end. If not, it pads
    the string with spaces to reach the maximum length. This function helps format
    the output to fit in fixed-width columns.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The script then prints a header row. **printf** is used to format the output.
    **%-15s** means left-align this string and pad it to 15 characters. The **|**
    characters are used to visually separate columns. A line of equal signs is printed
    to separate the header from the data. **printf '=%.0s' {1..109}** prints 109 equal
    signs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The script then queries the database. **sqlite3** is the command to interact
    with the SQLite database. **-separator "|"** tells SQLite to use pipe characters
    ( **|)** to separate columns in its output. The SQL query selects all columns
    from the **nmap_scans** table, ordered by IP address and port.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output of the query is piped into a while loop. **IFS='|** ’ sets the **Internal
    Field Separator** to **|** , which tells the script how to split the input into
    fields. **read -r** reads a line of input and splits it into variables. Inside
    the loop, each field ( **ip** , **hostname** , etc.) is processed by the **truncate**
    function. This ensures each field fits within its designated column width. The
    formatted data is then printed using **printf** . This creates neatly aligned
    columns in the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the loop ends, **Query completed.** is printed to indicate the script
    has finished running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This script takes data from an SQLite database and presents it in a neatly formatted
    table, making it easy to read and analyze the results of network scans.
  prefs: []
  type: TYPE_NORMAL
- en: By using these scriptdatabase andtomate the process of running Nmap scans, storing
    the results in a SQLite3 database, and querying the data for analysis. This approach
    allows for efficient data management and retrieval during pentesting activities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll learn how to extract data from the database and
    integrate it with reporting tools.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Bash with reporting tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a pentest report is both the most important as well as the least liked
    part of any pentest. Customers or system owners never get to see the work you
    do. Their opinion of how well you performed a pentest depends on the quality of
    the report. Pentesters usually dislike reporting because it’s not nearly as fun
    as *popping shells* .
  prefs: []
  type: TYPE_NORMAL
- en: Automating data normalization and report generation can significantly improve
    report quality while reducing time spent on reporting. This section provides Bash
    tools and techniques to streamline your reporting process. While not creating
    a comprehensive pentest report, it offers adaptable examples you can tailor to
    your standards and workflow.
  prefs: []
  type: TYPE_NORMAL
- en: This section will cover the basics of LaTeX, explain how to interact with the
    SQLite3 database using Bash, and demonstrate how to generate a PDF report.
  prefs: []
  type: TYPE_NORMAL
- en: LaTeX is a high-quality typesetting system designed for the production of technical
    and scientific documentation. It is widely used in academia and professional settings
    for creating complex documents with consistent formatting, mathematical equations,
    and cross-references.
  prefs: []
  type: TYPE_NORMAL
- en: 'For pentesters, LaTeX offers several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Consistent formatting across large documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy integration of code snippets and command outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to generate professional-looking reports programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for complex tables and figures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s start by creating a Bash script to query our **SQLite3** database and
    format the results for use in our LaTeX document. The following script can be
    found in this chapter’s GitHub repository as **ch13_generate_report.sh** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**query_db()** : This creates a function to query the database.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**sqlite3 -header -csv $DB_NAME "$1"** : This function executes SQLite queries.
    It uses the **-header** option to include column names and **-csv** to output
    in CSV format.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**escape_latex()** : This function escapes special LaTeX characters to prevent
    compilation errors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ip_addresses=$(query_db "SELECT DISTINCT ip_address FROM nmap_scans WHERE
    vulnerability IS NOT NULL AND vulnerability != '''';" | tail -n +2)** : This query
    fetches all unique IP addresses with vulnerabilities, skipping the header row.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**create_latex_content()** : This function generates the LaTeX document structure.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**for ip in $ip_addresses; do** : This loop processes each IP address, creating
    a subsection for each.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**query_db "SELECT hostname,…** : This nested loop processes each vulnerability
    for a given IP address, formatting it for the LaTeX table.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These commands generate the LaTeX file and compile it into a PDF:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**create_latex_content >** **pentest_report.tex**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pdflatex -** **interaction=nonstopmode pentest_report.tex**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To generate your pente st report, simply run the Bash script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will create a file named **pentest_report.pdf** in your current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows our very simple pentest report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Our simple pentest report PDF](image/B22229_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Our simple pentest report PDF
  prefs: []
  type: TYPE_NORMAL
- en: You can further customize your report by adding more sections, such as an executive
    summary or recommendations, including graphics or charts to visualize data, using
    LaTeX packages for syntax highlighting of code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to add an executive summary, you could modify the **create_latex_content**
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This section explored methods for using Bash scripts to streamline the creation
    of professional pentesting reports. It covered techniques for interfacing Bash
    with document preparation systems such as LaTeX to generate polished PDF reports.
    Adapt the provided methodology to your own standards to streamline your reporting
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on using Bash to streamline the reporting phase of pentesting.
    It covered techniques for automating data collection, organizing findings, and
    generating comprehensive reports. We explored how to extract relevant information
    from tool outputs, parse and clean data, and store it efficiently using SQLite
    databases. We also addressed integrating Bash scripts with reporting tools such
    as LaTeX to create professional PDF reports. By leveraging Bash for these tasks,
    pentesters can significantly reduce the time and effort required for report generation
    while ensuring accuracy and consistency in their findings.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will examine methods for creating Bash scripts that can evade
    detection by endpoint security during pentesting engagements.
  prefs: []
  type: TYPE_NORMAL
