["```\n $ sudo apt update && sudo apt install -y jq curl xmlstarlet\n```", "```\n $ curl -fsSL https://ollama.com/install.sh | sh\n```", "```\n WARNING: No NVIDIA/AMD GPU detected. Ollama will run in CPU-only mode.\n```", "```\n #!/usr/bin/env bash\nresponse=$(curl -s http://127.0.0.1:11434/api/generate -d \"{\n  \\\"model\\\": \\\"llama3.1\\\",\n  \\\"prompt\\\": \\\"Tell me how to exploit MS17-010\\\",\n  \\\"stream\\\": false\n}\")\n# Extract the response field and print it\nanswer=$(echo \"$response\" | jq -r '.response')\n# Output the answer\necho -e \"$answer\"\n```", "```\n #!/usr/bin/env bash\nresponse=$(curl -s http://127.0.0.1:11434/api/generate -d \"{\n  \\\"model\\\": \\\"llama3.1\\\",\n  \\\"system\\\": \\\"You are an assistant to a penetration tester, Steve.   \\\"prompt\\\": \\\"$1\\\",\n  \\\"temperature\\\": 0,\n  \\\"num_ctx\\\": 16384,\n  \\\"stream\\\": false\n}\")\n# Extract the response field and print it\nanswer=$(echo \"$response\" | jq -r '.response')\n# Output the answer\necho -e \"$answer\"\n```", "```\n curl -s https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv | awk -F, '{print $1 \"\\t\" $3 \"\\t\" $6 \"\\t\" $7 \"\\t\" $8}' > searchsploit.csv\n```", "```\n #!/usr/bin/env bash\nURL=\"https://raw.githubusercontent.com/rapid7/metasploit-framework/refs/heads/master/db/modules_metadata_base.json\"\n```", "```\n echo -e \"Name\\tFullname\\tDescription\\tReferences\\tRport\"\n```", "```\n curl -s \"$URL\" | jq -r '\n  to_entries[] |\n  [\n    .value.name,\n    .value.fullname,\n    .value.description,\n    (.value.references | join(\", \")),\n    .value.rport\n  ] | @tsv\n' | awk -F'\\t' 'BEGIN {OFS=\"\\t\"}\n```", "```\n {\n    for (i=1; i<=NF; i++) {\n        # Remove actual newlines\n        gsub(/\\n/, \" \", $i)\n        # Remove \"\\n\" literals\n        gsub(/\\\\n/, \" \", $i)\n        # Remove tabs\n        gsub(/\\t/, \" \", $i)\n        # Remove excessive spaces\n        gsub(/[ \\t]+/, \" \", $i)\n        # Trim leading and trailing spaces\n        sub(/^[ \\t]+/, \"\", $i)\n        sub(/[ \\t]+$/, \"\", $i)\n    }\n    print\n}' > metasploitdb.csv\n```", "```\n #!/usr/bin/env bash\nprint_usage_and_exit() {\n    echo \"Usage: $0 <path_to_gnmap_file>\"\n    echo \"Please provide exactly one argument: a path to an existing Nmap greppable (.gnmap) file.\"     exit 1\n}\n```", "```\n if [ $# -ne 1 ]; then\n    print_usage_and_exit\nfi\n```", "```\n if [ ! -f \"$1\" ]; then\n    echo \"Error: The file '$1' does not exist.\"     print_usage_and_exit\nfi\n```", "```\n echo -e \"IP\\tHostname\\tPort\\tService\\tBanner\"\n```", "```\n sed -n 's/^Host: \\(.*\\) ().*Ports: \\(.*\\)/\\1\\t\\2/p' \"$1\" | \\\n```", "```\n awk -F'\\t' '{\n```", "```\n ip = $1\n```", "```\n gsub(/[()]/, \"\", ip)\n```", "```\n split($2, ports, \", \")\n```", "```\n for (i in ports) {\n```", "```\n split(ports[i], p, \"/\")\n```", "```\n port = p[1]\n        service = p[5]\n        banner = p[7]\n```", "```\n for (j=8; j<=length(p); j++) {\n            if (p[j] != \"\") banner = banner \" \" p[j]\n        }\n```", "```\n gsub(/^ /, \"\", banner)\n        gsub(/ $/, \"\", banner)\n```", "```\n if (service == \"ssl|http\") service = \"https\"\n```", "```\n gsub(/\\?/, \"\", service)\n```", "```\n if (service == \"\") service = \"null\"\n        if (banner == \"\" || banner == \" \") banner = \"null\"\n```", "```\n printf \"%s\\tnull\\t%s\\t%s\\t%s\\n\", ip, port, service, banner\n    }\n}' | sort -n -k3,3 > nmapdata.csv\n```", "```\n     Your job is to take the data submitted to you in chat and compare each Nmap open port and service to your knowledge bases. One knowledge base contains Metasploit modules. The other knowledge base contains The Exploit Database exploits. Review these knowledge bases then compare the question to your knowledge and reply only with any relevant Metasploit modules or exploits. Do not introduce yourself. Ensure that you prepend your output with the port number related to the module or exploit.\n    ```", "```\n #!/usr/bin/env bash\nHOST=\"http://127.0.0.1\"\nAPI_KEY=\"<replace with your API key>\"\nCONVERSATION_ID=\"\"\n```", "```\n print_usage() {\n    cat << EOF\nUsage: $0 <file_path>\nThis script processes a file line by line and sends each line to a RAGFlow chat agent. Arguments:\n    <file_path>    Path to the file to be processed\nExample:\n    $0 /path/to/your/file.txt\nNote: Make sure to set the correct HOST and API_KEY in the script before running. EOF\n}\n```", "```\n if [ $# -eq 0 ]; then\n    print_usage\n    exit 1\nfi\nFILE_PATH=\"$1\"\n```", "```\n if [ ! -f \"$FILE_PATH\" ] || [ ! -r \"$FILE_PATH\" ]; then\n    echo \"Error: File does not exist or is not readable: $FILE_PATH\"\n    print_usage\n    exit 1\nfi\n```", "```\n create_conversation() {\n    local response=$(curl -s -X GET \"${HOST}/v1/api/new_conversation\" \\\n         -H \"Authorization: Bearer ${API_KEY}\" \\\n         -H \"Content-Type: application/json\" \\\n         -d '{\"user_id\": \"pentest_hero\"}')\n    echo $response | jq -r '.data.id'\n}\n```", "```\n send_message() {\n    local message=\"$1\"\n    local escaped_message=$(echo \"$message\" | jq -sR .)\n    local response=$(curl -s -X POST \"${HOST}/v1/api/completion\" \\\n         -H \"Authorization: Bearer ${API_KEY}\" \\\n         -H \"Content-Type: application/json\" \\\n         -d '{\n               \"conversation_id\": \"'\"${CONVERSATION_ID}\"'\",\n               \"messages\": [{\"role\": \"user\", \"content\": '\"${escaped_message}\"'}],\n               \"stream\": false\n             }')\n    if echo \"$response\" | jq -e '.retcode == 102' > /dev/null; then\n        echo \"Error: Conversation not found. Creating new conversation.\"         CONVERSATION_ID=$(create_conversation)\n        send_message \"$message\"  # Retry with new conversation ID\n    else\n        #echo \"Raw response: $response\"\n        echo $response | jq -r '.data.answer // \"No answer found\"'\n    fi\n}\n```", "```\n CONVERSATION_ID=$(create_conversation)\n```", "```\n while IFS= read -r line; do\n    if [[ ! $line =~ \"Ports:\" ]]; then\n        continue\n    fi\n    ip_address=$(echo \"$line\" | awk '{print $2}')\n    hostname=$(echo \"$line\" | awk '{print $3}' | sed 's/[()]//g')\n```", "```\n printf -v separator '%*s' $(tput cols) '' && echo \"${separator// /-}\"\n    echo \"IP address: $ip_address   Hostname: $hostname\"\n    echo \"\"\n    send_message \"$line\"\n    sleep 1  # Add a small delay to avoid overwhelming the API\ndone < \"$FILE_PATH\"\necho \"Finished processing file\"\n```"]