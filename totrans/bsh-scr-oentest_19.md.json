["```\n    $ echo \"Test message\" | mail -s \"Test Subject\" $USER\n    ```", "```\n #!/usr/bin/env bash\nset -euo pipefail\nIFS=$'\\n\\t'\n# Setup logging LOG_FILE=\"/var/log/devsecops_setup.log\"\nSCRIPT_NAME=$(basename \"$0\")\n```", "```\n log_info() {\n    local msg=\"[$(date +'%Y-%m-%d %H:%M:%S')] [INFO] $1\"\n    echo \"$msg\" | tee -a \"$LOG_FILE\"\n}\nlog_error() {\n    local msg=\"[$(date +'%Y-%m-%d %H:%M:%S')] [ERROR] $1\"\n    echo \"$msg\" | tee -a \"$LOG_FILE\" >&2\n}\nlog_warning() {\n    local msg=\"[$(date +'%Y-%m-%d %H:%M:%S')] [WARNING] $1\"\n    echo \"$msg\" | tee -a \"$LOG_FILE\"\n}\n```", "```\n handle_error() {\n    local line_num=$1\n    local error_code=$2\n    log_error \"Error in $SCRIPT_NAME at line $line_num (Exit code: $error_code)\"\n}\ntrap 'handle_error ${LINENO} $?' ERR\ninit_logging() {\n    if [[ ! -f \"$LOG_FILE\" ]]; then\n        touch \"$LOG_FILE\"\n        chmod 644 \"$LOG_FILE\"\n    fi\n    log_info \"Starting setup script execution\"\n    log_info \"Logging to $LOG_FILE\"\n}\n```", "```\n if [[ $EUID -ne 0 ]]; then\n   log_error \"This script must be run as root\"\n   exit 1\nfi\nif ! grep -q \"Kali\" /etc/os-release; then\n    log_error \"This script must be run on Kali Linux\"\n    exit 1\nfi\n```", "```\n install_dev_tools() {\n    log_info \"Installing development tools...\"     export DEBIAN_FRONTEND=noninteractive\n    apt-get update >> \"$LOG_FILE\" 2>&1\n    apt-get install -y \\\n        docker.io \\\n        docker-compose \\\n        openjdk-11-jdk \\\n        maven \\\n        gradle \\\n        python3-venv \\\n        python3-full \\\n        pipx >> \"$LOG_FILE\" 2>&1 || {\n            log_error \"Failed to install development tools\"\n            return 1\n        }\n    pipx ensurepath >> \"$LOG_FILE\" 2>&1\n    export PATH=\"/root/.local/bin:$PATH\"\n```", "```\n install_dep_scanners() {\n    log_info \"Installing dependency scanners...\"     # OWASP Dependency-Check\n    wget https://github.com/jeremylong/DependencyCheck/releases/download/v7.1.1/dependency-check-7.1.1-release.zip\n    unzip dependency-check-7.1.1-release.zip -d /opt/\n    ln -sf /opt/dependency-check/bin/dependency-check.sh /usr/local/bin/dependency-check\n    # Trivy Installation\n    TRIVY_VERSION=$(curl -s https://api.github.com/repos/aquasecurity/trivy/releases/latest | grep '\"tag_name\":' | sed -E 's/.*\"v([^\"]+)\".*/\\1/')\n    wget \"https://github.com/aquasecurity/trivy/releases/download/v${TRIVY_VERSION}/trivy_${TRIVY_VERSION}_Linux-64bit.deb\"\n    dpkg -i trivy.deb\n}\n```", "```\n setup_gitlab_cicd() {\n    docker run --detach \\\n        --hostname gitlab.local \\\n        --publish 443:443 --publish 80:80 --publish 22:22 \\\n        --name gitlab \\\n        --restart always \\\n        --volume /srv/gitlab/config:/etc/gitlab \\\n        --volume /srv/gitlab/logs:/var/log/gitlab \\\n        --volume /srv/gitlab/data:/var/opt/gitlab \\\n        gitlab/gitlab-ce:latest\n    # GitLab Runner installation\n    curl -L \"https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh\" | \\\n        os=debian dist=bullseye bash\n    apt-get install -y gitlab-runner\n}\n```", "```\n create_workspace() {\n    mkdir -p /opt/devsecops/{scripts,tools,reports,pipelines,monitoring}\n    cat > /opt/devsecops/pipelines/example-pipeline.yml <<EOF\nstages:\n  - static-analysis\n  - dependency-check\n  - container-scan\n  - dynamic-scan\n... EOF\n    chown -R \"$SUDO_USER:$SUDO_USER\" /opt/devsecops\n}\n```", "```\n #!/usr/bin/env bash\nset -euo pipefail\nIFS=$'\\n\\t'\nSCAN_DIR=${1:-\".\"}\nREPORT_DIR=\"/opt/devsecops/reports\"\nLOG_FILE=\"/var/log/security_scanner.log\"\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\nREPORT_NAME=\"security_scan_${TIMESTAMP}\"\n```", "```\n # Logging setup\nsetup_logging() {\n    if [[ ! -f \"$LOG_FILE\" ]]; then\n        sudo touch \"$LOG_FILE\"\n        sudo chmod 644 \"$LOG_FILE\"\n    fi\n}\nlog() {\n    local level=$1\n    shift\n    echo \"[$(date +'%Y-%m-%d %H:%M:%S')] [${level}] $*\" | tee -a \"$LOG_FILE\"\n}\n# Error handler\nerror_handler() {\n    local line_num=$1\n    local error_code=$2\n    log \"ERROR\" \"Error occurred in script at line: ${line_num} (Exit code: ${error_code})\"\n}\ntrap 'error_handler ${LINENO} $?' ERR\n```", "```\n # Validation functions\nvalidate_environment() {\n    local required_tools=(\"docker\" \"trivy\" \"dependency-check\" \"bandit\")\n    for tool in \"${required_tools[@]}\"; do\n        if ! command -v \"$tool\" &> /dev/null; then\n            log \"ERROR\" \"Required tool not found: $tool\"\n            return 1\n        fi\n    done\n    if [[ ! -d \"$REPORT_DIR\" ]]; then\n        log \"ERROR\" \"Report directory not found: $REPORT_DIR\"\n        return 1\n    fi\n}\nvalidate_target() {\n    if [[ ! -d \"$SCAN_DIR\" ]]; then\n        log \"ERROR\" \"Invalid target directory: $SCAN_DIR\"\n        return 1\n    fi\n    if [[ ! -r \"$SCAN_DIR\" ]]; then\n        log \"ERROR\" \"Cannot read target directory: $SCAN_DIR\"\n        return 1\n    fi\n}\n```", "```\n perform_sast_scan() {\n    log \"INFO\" \"Starting SAST scan with Bandit\"\n    local output_file=\"${REPORT_DIR}/${REPORT_NAME}_sast.txt\"\n```", "```\n if bandit -r \"$SCAN_DIR\" -f txt -o \"$output_file\"; then\n        log \"INFO\" \"SAST scan completed successfully\"\n        return 0\n    else\n        log \"ERROR\" \"SAST scan did not complete successfully\"\n        return 1\n    fi\n}\n```", "```\n perform_dependency_scan() {\n    log \"INFO\" \"Starting dependency scan\"\n    local output_file=\"${REPORT_DIR}/${REPORT_NAME}_deps\"\n    if dependency-check --scan \"$SCAN_DIR\" --out \"$output_file\" --format ALL; then\n        log \"INFO\" \"Dependency scan completed successfully\"\n        return 0\n    else\n        log \"ERROR\" \"Dependency scan did not complete successfully\"\n        return 1\n    fi\n}\n```", "```\n perform_container_scan() {\n    log \"INFO\" \"Starting container image scan\"\n    local output_file=\"${REPORT_DIR}/${REPORT_NAME}_containers.json\"\n    # Find all Dockerfiles in the target directory\n    while IFS= read -r -d '' dockerfile; do\n        local dir_name\n        dir_name=$(dirname \"$dockerfile\")\n        local image_name\n        image_name=$(basename \"$dir_name\")\n        log \"INFO\" \"Building container from Dockerfile: $dockerfile\"\n        if docker build -t \"scan_target:${image_name}\" \"$dir_name\"; then\n            log \"INFO\" \"Scanning container image: scan_target:${image_name}\"\n            if ! trivy image -f json -o \"$output_file\" \"scan_target:${image_name}\"; then\n                log \"WARNING\" \"Container vulnerabilities found\"\n                return 1\n            fi\n        else\n            log \"ERROR\" \"Failed to build container from $dockerfile\"\n            return 1\n        fi\n    done < <(find \"$SCAN_DIR\" -name \"Dockerfile\" -print0)\n}\n```", "```\n generate_summary() {\n    local summary_file=\"${REPORT_DIR}/${REPORT_NAME}_summary.md\"\n    {\n        echo \"# Security Scan Summary\"\n        echo \"## Scan Information\"\n        echo \"- Date: $(date)\"\n        echo \"- Target: $SCAN_DIR\"\n        echo\n        echo \"## Findings Summary\"\n        echo \"### SAST Scan\"\n        echo \"\\`\\`\\`\"\n        tail -n 10 \"${REPORT_DIR}/${REPORT_NAME}_sast.txt\"\n        echo \"\\`\\`\\`\"\n        echo\n        echo \"### Dependency Scan\"\n        echo \"\\`\\`\\`\"\n        grep -A 5 \"One or more dependencies were identified with known vulnerabilities\" \\\n            \"${REPORT_DIR}/${REPORT_NAME}_deps.txt\" 2>/dev/null || echo \"No critical dependencies found\"\n        echo \"\\`\\`\\`\"\n        echo\n        echo \"### Container Scan\"\n        echo \"\\`\\`\\`\"\n        jq -r '.Results[] | select(.Vulnerabilities != null) | .Vulnerabilities[] | select(.Severity == \"HIGH\" or .Severity == \"CRITICAL\") | \"- \\(.VulnerabilityID): \\(.Title)\"' \\\n            \"${REPORT_DIR}/${REPORT_NAME}_containers.json\" 2>/dev/null || echo \"No container vulnerabilities found\"\n        echo \"\\`\\`\\`\"\n    } > \"$summary_file\"\n    log \"INFO\" \"Summary report generated: $summary_file\"\n}\n```", "```** ), followed by lines of code, and closed out by another line starting with three backticks. Headings are formatted with one or more hash symbols ( **#** ) preceding the heading title. For example, an H1 header would have one, **#** , and an H2 header would have two, **##** , followed by the section title.\n\nFinally, we have the **main** function, which calls the other functions:\n\n```", "```\n\nThe following are example commands for executing this script in your DevSecOps environment:\n\n*   For basic usage, run a scan on the current directory:\n\n    ```", "```\n\n*   Scan a specific project:\n\n    ```", "```\n\n*   Run a scan as part of the CI/CD pipeline:\n\n    ```", "```\n\nThe script integrates with the GitLab CI/CD environment we set up earlier. You can add it to your **.** **gitlab-ci.yml** pipeline:\n\n```", "```\n\nThis script demonstrates key security principles for DevSecOps Bash scripting:\n\n*   Input validation and sanitization\n*   Comprehensive error handling\n*   Detailed logging\n*   Clear output formatting\n*   Integration with standard security tools\n*   CI/CD pipeline compatibility\n\nNow that we have our DevSecOps scanner script, let’s further configure our system with repositories and set up the system to automatically run the scan.\n\n## Creating vulnerable artifacts\n\nBefore we run our scanner script, we need to configure our system with some vulnerable code and Docker containers, which will be the target of our scans.\n\nLet’s go through the vulnerabilities that our scanning script will detect:\n\n*   **SAST vulnerabilities (detectable** **by Bandit)** :\n    *   Use of **subprocess.check_output** with **shell=True** ( command injection)\n    *   Unsafe YAML loading with **yaml.load**\n    *   Unsafe Pickle deserialization\n    *   SQL injection vulnerability in the login route\n    *   Template injection in the home route\n    *   Debug mode enabled in Flask\n*   **Dependency vulnerabilities (detectable by** **OWASP Dependency-Check)** :\n    *   Flask 2.0.1 has known vulnerabilities\n    *   PyYAML 5.3.1 has deserialization vulnerabilities\n    *   Werkzeug 2.0.2 has path traversal vulnerabilities\n    *   Cryptography 3.3.2 has buffer overflow vulnerabilities\n    *   Jinja2 2.11.2 has sandbox escape vulnerabilities\n*   **Container vulnerabilities (detectable** **by Trivy)** :\n    *   The Python **3.8-slim-buster** base image has known CVEs\n    *   OpenSSL **1.1.1d** has multiple CVEs\n    *   Running as the **root** user\n    *   An old version of curl with known vulnerabilities\n\nTo set this up in your GitLab environment, follow these steps:\n\n1.  Authenticate to GitLab:\n    1.  Execute this command to find the GitLab **root** password:\n\n    ```", "```\n\n    1.  Log in to GitLab at **http://localhost** in the DevSecOps virtual machine using **root** for the username and the password found from the previous command.\n2.  Create a new user:\n    1.  Click **Add people** . See *Figure 16* *.1* :\n\n![Figure 16.1 – Adding our first GitLab user account](image/B22229_16_01.jpg) \n\nFigure 16.1 – Adding our first GitLab user account\n\n1.  Specify your new user’s name, username, and email address. Any email address will work. We’re not going to verify the email address.\n2.  Click the **Create** **user** button.\n3.  Set the user’s password: To the right of the username, click the **Edit** button. See *Figure 16* *.2* :\n\n![Figure 16.2 – The location of the button is shown here](image/B22229_16_02.jpg) \n\nFigure 16.2 – The location of the button is shown here\n\n1.  Set the user’s password, confirm the password, and click the **Save** **Changes** button.\n2.  Log in as the user you just created. When you log in, you will be prompted to enter your current password and change it.\n\n1.  Create a **Personal Access** **Token** ( **PAT** ):\n    1.  Navigate to **http://localhost/-/user_settings/personal_access_tokens** .\n    2.  Click **Add** **new token** .\n    3.  Provide a name and expiration date.\n    4.  Select all scope checkboxes and click the **Create** button.\n    5.  Click the button to copy the token:\n\n![Figure 16.3 – Copying your token value](image/B22229_16_03.jpg) \n\nFigure 16.3 – Copying your token value\n\n1.  Save your PAT to a file before continuing.\n\n1.  Create a repository:\n    1.  After logging in, click **Create** **a project** .\n    2.  Click **Create** **blank project** .\n    3.  Enter **vulnerable-flask-app** for the project name.\n    4.  Click the **Create project** button at the bottom.\n2.  Copy project CI/CD runner token (shown in *Figure 16* *.4* ):\n    1.  Navigate to the project’s CI/CD settings.\n    2.  Click the three vertical dots next to the **New project** **runner** button.\n    3.  Copy the token and save it to the file:\n\n![Figure 16.4 – Copying your project runner token](image/B22229_16_04.jpg) \n\nFigure 16.4 – Copying your project runner token\n\n1.  Register the new runner with your token (replace **YOUR_TOKEN** with the actual token you copied). You can find this command in the book’s GitHub repository as **ch16_register_runner.sh** . After running the command, you’ll be prompted for values. You’ll find that the values entered in the command will be the default, so simply press the *Enter* key until complete. Here’s the code of **ch16_register_runner.sh** :\n\n    ```", "```\n\n2.  Set up the scan script:\n    1.  Create a **s cripts** directory if it doesn’t exist:\n\n    ```", "```\n\n    1.  Copy the security scanner to the **scripts** directory: Copy the **ch16_devsecops_scanner.sh** file from GitHub to the direct ory:\n\n    ```", "```\n\n    1.  Make it executable:\n\n    ```", "```\n\n3.  Set up the required permissions:\n    1.  Allow GitLab Runner to access required directories:\n\n    ```", "```\n\n    1.  Restart **gitlab-runner** :\n\n    ```", "```\n\n    1.  Allow access to the Docker socket:\n\n    ```", "```\n\n4.  Clone the repository: Run the following command, replacing **<username>** with your actual GitLab username. You’ll be prompted for your username and password. Use your GitLab username, and paste the PAT that you copied in *Step 5* for the password:\n\n    ```", "```\n\n5.  Add the files: Copy the following files from this chapter’s GitHub directory into the **vulnerable_flask_app** directory:\n    *   **app.py**\n    *   **requirements.txt**\n    *   **Dockerfile**\n    *   **.** **gitlab-ci.yml**\n6.  Configure our Git user:\n    1.  Run this command to set the Git username for this repo sitory, using your GitLab account name:\n\n    ```", "```\n\n    1.  Run this command to set the Git email for this repository, using your GitLab account email address:\n\n    ```", "```\n\n    1.  Issue the following commands to add the **rep orts** directory and track the new files:\n\n    ```", "```\n\n7.  Push to GitLab: Run the following command to push the repository to GitLab, replacing **<youruser>** with the username you created in *Step 2* . You will be prompted for your GitLab username and password. Use the GitLab PA T you generated earlier as the password:\n\n    ```", "```\n\n    Now, every time you push to the repository or create a merge request, the following will happen:\n\n    1.  GitLab CI will automatically trigger the pipeline\n    2.  The security scanner will run against the code base\n    3.  Reports will be available as artifacts in the GitLab UI\n\n    To view the results, follow these steps:\n\n    1.  Go to your GitLab project\n    2.  Click on **Build** in the left sidebar\n    3.  Click on **Jobs** .\n    4.  View the job output and download artifacts\n\n    The following figure shows a sample of the scan output:\n\n![Figure 16.5: The scan report reveals security issues](image/B22229_16_05.jpg) \n\nFigure 16.5: The scan report reveals security issues\n\nThis section introduced you to implementing security checks into a DevSecOps pipeline. In the next section, we’ll explore automated sec urity and health monitoring for DevSecOps.\n\n# Integrating real-time security monitoring with Bash\n\nSecurity monitoring is essential for detecting and responding to threats in DevSecOps environments. While many commercial monitoring solutions exist, Bash scripting provides security specialists with the flexibility to create free custom monitoring systems tailored to their specific needs. By combining standard Linux tools with security-focused applications, you can build monitoring solutions that collect metrics, analyze logs, and alert you to suspicious activities.\n\nLet’s build a monitoring system that watches our DevSecOps environment for security ev ents. This script can be found in GitHub as **ch16_sec_monitor.sh** . Our script will monitor GitLab authentication logs for failed login attempts and send email alerts when a threshold is exceeded. Let’s examine the script, section by section.\n\nFirst, here is the initial setup and configuration:\n\n```", "```\n\nThis section verifies root privileges and sets key variables. The script checks every five minutes for failed logins exceeding a threshold of five attempts. Be sure to change the email address username to your own before running the script. Replace **<user>** with your username.\n\nAs shown here, the alert function handles email notifications:\n\n```", "```\n\nThis function formats and sends email alerts using the local mail system. It includes the count of failures and details about recent attempts.\n\nAs shown here, the main monitoring logic is as follows:\n\n```", "```\n\nThis section checks for the log file’s existence and calculates the time window for monitoring. It converts Unix timestamps to ISO format for log comparison.\n\nThe log analysis portion is demonstrated next:\n\n```", "```\n\nThis code performs the following functions:\n\n1.  Searches for failed login entries\n2.  Uses **jq** to parse the JSON log format\n3.  Filters entries within the time window\n4.  Counts failures and triggers alerts if above the threshold\n\nThe main loop is shown here:\n\n```", "```\n\nThis creates a continuous monitoring cycle, running checks every five minutes. The script never exits unless manually stopped or an error occurs.\n\nAfter repeatedly entering failed login attempts in the GitLab login at **http://localhost/** , I check my mail and find alerts, as shown in the following figure:\n\n![Figure 16.6: An email alert reveals failed login attempts](image/B22229_16_06.jpg) \n\nFigure 16.6: An email alert reveals failed login attempts\n\nThis section demonstrated that you don’t need expensive software to implement security features. In the next section, we’ll explore how to make setting up a fresh Kali Linux instance quick and painless.\n\n# Automating custom Kali Linux builds for pentesting\n\nFor pentesters who perform consulting work for external customers, every project should start with a fresh installation of the operating system, which is typically Kali Linux. There are many ways to deploy Kali:\n\n*   Virtual machines\n*   Docker containers\n*   Cloud images\n*   Bare metal installation on laptops or other devices\n\nThis section will focus on building Kali ISO image installers using Bash scripting. The resulting ISO image will automate the installation of Kali on virtual machines or bare metal. The image file can be connected to a virtual machine or to a laptop or other device using USB storage. From there, you simply boot the system, and your custom image is installed.\n\nYour system will need a few gigabytes of free disk space to create the image. The amount of free disk space needed depends on the options you choose and whether you choose to install all or a subset of packages. To begin building custom Kali Linux ISOs, first, install the required packages and clone the **build** repository using the following commands:\n\n```", "```\n\nThe build process supports two types of images:\n\n*   **Live images** : For running Kali directly from USB without installation. Use the **--live** command-line option with the **build** script.\n*   **Installer images** : For performing customized system installations. Use the **--installer** command-line option with the **build** script.\n\nTo build with different desktop environments, use the **--variant** flag. Here are some examples:\n\n*   Build with the GNOME desktop:\n\n    ```", "```\n\n*   Build with the KDE desktop:\n\n    ```", "```\n\n*   Build with the XFCE desktop (default):\n\n    ```", "```\n\nYou may also want to specify different architectures, for example, x86-64 for Intel/AMD CPUs, or ARM64 for running in a virtual machine on macOS. Specify the target architecture using the **--** **arch** flag:\n\n*   Build for x86-64:\n\n    ```", "```\n\n*   Build for ARM64:\n\n    ```", "```\n\nHere’s a complete automated build script that sets common options. You can find this in the GitHub directory for this chapter as **ch16_build_kali.sh** . Note that this must be run on a Kali Linux system:\n\n```", "```\n\nThe build system offers several customization options:\n\n*   **Package selection** : Edit package lists in **kali-config/variant-*/package-lists/kali.list.chroot** . Default packages come from the **kali-linux-default** metapackage. I highly recommend that you review these options to customize what gets installed. This will affect the resulting ISO image size. You can simply comment or uncomment lines to achieve the desired effect, as shown in the following figure:\n\n![Figure 16.7 – You may comment or uncomment lines to choose metapackages](image/B22229_16_07.jpg) \n\nFigure 16.7 – You may comment or uncomment lines to choose metapackages\n\n*   **File overlays** : Place custom files in **kali-config/common/includes.chroot/** . Files will be copied to corresponding locations in the final image.\n*   **Build parameters** :\n    *   **--distribution** : Specify the Kali version (e.g., **kali-rolling** , **kali-last-snapshot** )\n    *   **--version** : Set a custom version string\n    *   **--subdir** : Define the output directory structure\n    *   **--verbose** : Show detailed build output\n    *   **--debug** : Display maximum debug information\n*   **Preseeding** : You can fully customize and automate the installation process using a preseed file. Kali is based on Debian Linux. You can find Debian documentation on all preseed options at [https://www.debian.org/releases/stable/amd64/apbs01.en.html](https://www.debian.org/releases/stable/amd64/apbs01.en.html) . For guidance on how to use the preseed file for the Kali build process, see step *0x05* at [https://www.kali.org/docs/development/dojo-mastering-live-build/](https://www.kali.org/docs/development/dojo-mastering-live-build/) .\n\nOnce you have customized the build to your needs, including editing variables at the top of the **ch16_build_kali.sh** script, make the script executable and run it.\n\nOnce the build is complete, you can test the built image using QEMU, provided you have at least 20 GB of free disk space. Otherwise, you’ll need to test it on another system. The build process will create an ISO file in the **images/** subdirectory. The exact filename will depend on the build options selected.\n\nCaution\n\nBooting a computer or virtual machine with the resulting installer image will overwrite anything on the disk!\n\nHow can we test drive the new image using QEMU? Let’s take a look at the steps:\n\n1.  Install QEMU:\n\n    ```", "```\n\n2.  Create a test disk:\n\n    ```", "```\n\n3.  Boot the image to a virtual machine:\n\n    ```"]