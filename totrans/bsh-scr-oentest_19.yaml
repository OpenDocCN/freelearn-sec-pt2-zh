- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DevSecOps for Pentesters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**DevSecOps** is a combination of *Development* , *Security* , and *Operations*
    . DevSecOps represents a shift in how organizations approach security in software
    development. Integrating security practices throughout the development life cycle
    leads to the early detection and mitigation of security issues.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore the role of pentesters within a DevSecOps framework.
    We’ll examine how Bash scripting can be used to automate and enhance security
    processes. From integrating security checks into **Continuous Integration/Continuous
    Delivery** ( **CI/CD** ) pipelines to building custom security tools, we’ll cover
    practical techniques that can help pentesters in a DevSecOps setting.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t work in a DevSecOps environment, this chapter still has something
    for you. You may wish to skip ahead to the section on creating custom Kali builds.
    This section will help you to automate the creation of highly customizable Kali
    Linux installation ISO images.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to DevSecOps for pentester s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the CI/CD pipeline with Bash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crafting security-focused Bash scripts for DevSecOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating real-time security monitoring with Bas h
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating custom Kali Linux builds for pentesting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found a t [https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter16](https://github.com/PacktPublishing/Bash-Shell-Scripting-for-Pentesters/tree/main/Chapter16)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will utilize a Kali virtual machine with GitLab and Bash scripts
    for running security checks and monitoring. Configure your Kali Linux virtual
    machine with at least the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 4 GB RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 30 GB storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two virtual CPUs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have a working Kali installation that meets or exceeds the preceding
    specifications, run the **ch16_setup_environment.sh** script found in this chapter’s
    GitHub directory. We’ll review the script later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, configure the system email:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the **ch16_setup_mail.sh** script. This script can be found in the GitHub
    repository directory for this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test sending yourself mail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check your mail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the **mail** command in the terminal
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *Enter* / *Return* key to read a message
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **q** to quit reading a message
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **d** to delete a message
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **h** to show the message list again
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter **q** to quit the mail program
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: With the prerequisites out of the way, let’s dive in !
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to DevSecOps for pentesters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is an introduction and explanation of DevSecOps. By the end of
    this section, you’ll understand the terminology, history, and common tasks for
    integrating security into the development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the intersection of DevOps and security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although DevOps and security may appear separate, they are increasingly merging
    in modern software development. DevOps, focusing on collaboration, automation,
    and continuous delivery, has transformed how organizations handle software development
    and deployment. However, this shift has also introduced new security challenges
    that must be addressed to ensure the integrity and reliability of the software
    being delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional security practices often involved manual testing and reviews, which
    were typically performed at the end of the development cycle. This approach was
    time-consuming and resource-intensive, and often resulted in security issues being
    discovered late in the process. This led to costly fixes and delayed releases.
    With the adoption of DevOps, the focus shifted toward integrating security into
    the development process from the very beginning. This gave rise to the concept
    of **DevSecOps** .
  prefs: []
  type: TYPE_NORMAL
- en: DevSecOps integrates security into every phase of the software development life
    cycle. This fosters a shared responsibility among developers, operations, and
    security teams. By embedding security practices, tools, and automation into DevOps,
    organizations can identify vulnerabilities early, minimize security risks, and
    deliver secure software by design.
  prefs: []
  type: TYPE_NORMAL
- en: With DevSecOps on the rise, pentesters should adjust their methods and use automation
    to match fast development cycles. Integrating security testing into CI/CD pipelines
    allows testers to give ongoing feedback on software security, helping teams quickly
    find and fix vulnerabilities. Additionally, pentesters can support the DevSecOps
    culture by working closely with development and operations teams. Through sharing
    their knowledge and experience, pentesters can instruct teams on secure coding
    techniques, common vulnerabilities, and best practices for secure deployment and
    configuration. This collaborative effort promotes a collective awareness of security
    and contributes to creating a more secure software environment.
  prefs: []
  type: TYPE_NORMAL
- en: In DevSecOps, Bash scripting is an effective tool for automating security tasks
    within the CI/CD pipeline. As a flexible scripting language, Bash enables pentesters
    to write custom scripts for activities such as vulnerability scanning, configuration
    analysis, and automated exploitation. This reduces manual work, streamlines testing
    processes, and ensures consistent security checks across environments.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ll explore the use of Bash scripting to automate
    security tasks within the DevOps workflow. Mastering Bash scripting can help pentesters
    streamline testing processes and enhance organizational security.
  prefs: []
  type: TYPE_NORMAL
- en: Common use cases for Bash in security automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security teams often integrate Bash scripting throughout the DevSecOps life
    cycle to streamline and automate repetitive security tasks. Understanding these
    common tasks helps pentesters identify opportunities for automation in their own
    workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the more common security workflows include these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vulnerability scanning orchestration** : Bash scripts coordinate multiple
    scanning tools to run sequentially or in parallel against target systems. Security
    teams typically automate Nmap port scans, followed by targeted vulnerability scanners
    for detected services. The scripts handle scheduling, parameter configuration,
    and results aggregation. This turns hours of manual scanning into an automated
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous security testing** : In modern development environments, security
    testing runs automatically with each code commit. Bash scripts integrate security
    tools into CI pipelines, scanning application code, dependencies, and container
    images. When vulnerabilities are found, the scripts can fail the build and notify
    the security team through chat platforms or ticketing systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration management** : Infrastructure security relies heavily on proper
    system configuration. Bash scripts verify security baselines across servers, checking
    file permissions, user access, service configurations, and network settings. When
    misconfigurations are detected, scripts can either automatically remediate issues
    or create detailed reports for the operations team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log analysis and monitoring** : Security teams use Bash to process system
    logs, looking for indicators of compromise or suspicious behavior. Scripts parse
    log files, extract relevant data, and trigger alerts based on predefined rules.
    This automated monitoring runs continuously, providing real-time security visibility
    across the infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incident response automation** : During security incidents, time is critical.
    Bash scripts automate initial response actions such as isolating compromised systems,
    collecting forensic data, or blocking malicious IP addresses. This automation
    ensures consistent incident handling and reduces response time from hours to minutes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compliance validation** : Organizations must regularly verify compliance
    with security standards. Bash scripts automate compliance checks against frameworks
    such as CIS Benchmarks or NIST guidelines. The scripts generate compliance reports
    and highlight areas requiring remediation, simplifying the audit process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security tool integration** : Many security tools provide command-line interfaces
    but lack direct integration capabilities. Bash serves as the glue connecting these
    tools into cohesive security workflows. Scripts can chain tools together, transform
    data formats, and create unified reporting interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment hardening** : Security teams use Bash to automate the hardening
    of new systems. Scripts apply security patches, configure firewalls, set up intrusion
    detection, and implement access controls. This automation ensures consistent security
    measures across all environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These automation use cases form the foundation for modern security operations.
    In subsequent sections, we’ll explore specific code implementations for some of
    these scenarios, building practical automation solutions for real-world security
    chal lenges.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the CI/CD pipeline with Bash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll cover Bash scripting for setting up our CI/CD test lab
    environment. This will automate the installation of all tools needed for the rest
    of the chapter exercises. This script can be found in GitHub as **ch16_setup_environment.sh**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Initial setup and error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section of the code sets up error-handling behaviors that prevent the
    script from continuing when errors occur. These safety measures help catch problems
    early and prevent cascading failures that could leave the system in an inconsistent
    state. As usual, the code starts with the familiar **shebang** line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This section establishes core script behaviors. The **set** command configures
    important safety features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-e** : Exits on any error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-u** : Treats unset variables as errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-o pipefail** : Returns an error if any command in a pipeline fails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The internal field separator ( **IFS** ) is set to newline and tab characters,
    preventing word splitting on spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the log file can be found at **/var/log/devsecops_setup.log** . If
    the script fails, examine the end of the log file.
  prefs: []
  type: TYPE_NORMAL
- en: Logging functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Proper logging is essential for debugging and auditing script execution. These
    functions create a standardized logging system that records all significant events
    during the installation process, making it easier to track down issues and verify
    successful execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These functions implement structured logging:'
  prefs: []
  type: TYPE_NORMAL
- en: Each function accepts a message parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Messages are timestamped using **date** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**tee -a** writes to both the log file and standard output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Error messages are directed to stderr using **>&2** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Error handler and initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When things go wrong in a script, providing clear error messages helps users
    understand and fix problems. This section establishes error-handling routines
    and initializes the logging system, ensuring that all script activities are properly
    tracked, and errors are caught and reported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The error-handling system uses the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **trap** to catch errors. A trap is a mechanism that allows you to specify
    a command or series of commands to be executed when the shell receives a specified
    signal or condition. To catch errors, you can use the **trap** command with the
    **ERR** signal, which triggers when a command within a script returns a non-zero
    exit status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **handle_error** function receives the line number and exit code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**init_logging** creates the log file if needed and sets permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before installing software or making system changes, we need to verify that
    the script is running in the correct environment. The following code ensures the
    script runs with proper permissions and on the intended operating system, preventing
    potential issues from incorrect execution conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following checks ensure proper execution conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Verifies root privileges by checking the effective user ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confirms the system is Kali Linux by checking the OS information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development tools installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A DevSecOps environment requires various development tools and languages. This
    section installs core development dependencies including Docker, Java, and Python
    tools that will be needed for building and testing applications securely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a breakdown of this code block:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets up non-interactive package installation by setting an environment variable.
    This prevents the package manager from prompting you during the installation process:
    **export DEBIAN_FRONTEND=noninteractive** .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updates package lists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installs development tools using **apt-get** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configures Python package management with **pipx** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updates the **PATH** to include local binaries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Security tools installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Security scanning tools are essential for identifying vulnerabilities in code
    and dependencies. This section installs specialized security tools that help identify
    potential vulnerabilities in application dependencies and container images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a breakdown of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloads and installs **OWASP Dependency-Check**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetches the latest Trivy version from the GitHub API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Downloads and installs the Trivy package
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: OWASP Dependency-Check scans software dependency versions for vulnerabilities.
    Trivy scans Git repositories, filesystems, and containers for vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab CI/CD setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section installs and configures GitLab and GitLab Runner to provide a
    simple CI/CD platform for automated security testing and deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code block does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploys GitLab using Docker with persistent storage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maps necessary ports for web and SSH access
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installs GitLab Runner for CI/CD capabilities
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Workspace creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A well-organized workspace helps maintain order in security testing projects.
    This section creates a structured directory layout and provides example configurations
    to help users get started with their DevSecOps practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function performs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a directory structure for DevSecOps work
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets up an example pipeline configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjusts ownership of workspace files
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The script uses several shell scripting best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: Consistent error handling and logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modular function design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper permission management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Careful dependency installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container-based service deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This script creates a simple DevSecOps learning environment that leverages Kali
    Linux’s pre-installed security tools while adding the necessary components. The
    environment allows you to practice security automation, continuous testing, and
    monitoring in an isolated setting.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll explore using Bash scripting to perform security
    tests once code is checked into GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting security-focused Bash scripts for DevSecOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll review the code for a Bash scanner script that we’ll
    integrate into the CI/CD pipeline. First, I’ll create and review the scanner script.
    Then I’ll demonstrate how to integrate it into the pipeline for automated scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the scan script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating secure and maintainable Bash scripts requires careful attention to
    defensive coding practices, proper error handling, and thorough logging. Let’s
    build a security scanning script that leverages our DevSecOps environment to demonstrate
    these principles.
  prefs: []
  type: TYPE_NORMAL
- en: This script can be found in GitHub as **ch16_devsecops_scanner.sh** . Let’s
    break down this script into its core components and examine each section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll look at the script initialization and safety measures. The purpose
    of this section is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: En ables strict error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevents word splitting issues with filenames containing spaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables are defined with clear names and defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script uses timestamped report names to prevent overwriting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s examine the code in depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The **set -euo pipefail** command is used to enhance the robustness of shell
    scripts by modifying how errors are handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-e** : Causes the script to exit immediately if any command within it exits
    with a non-zero status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-u** : Treats unset variables as an error and causes the script to exit with
    an error'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**-o pipefail** : Ensures that the script exits with a non-zero status if any
    command within a pipeline fails, not just the last command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These options combined help in catching errors early and making scripts more
    reliable.
  prefs: []
  type: TYPE_NORMAL
- en: The **IFS=$'\n\t'** line sets the IFS delimiter as newlines and tabs to prevent
    word splitting issues with filenames containing spaces.
  prefs: []
  type: TYPE_NORMAL
- en: The **SCAN_DIR=${1:-"."}** line assigns the **SCAN_DIR** variable with the value
    of the first positional parameter ( **$1** ) if it exists. If **$1** is not provided,
    it defaults to **"."** , which represents the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s examine the logging functions. The purpose of this section is to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a consistent logging format with timestamps and log levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write logs to both the console and log file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement error trapping to catch and log all script failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set appropriate file permissions for the log file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s examine the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The **setup_logging()** function checks whether a log file exists, and if it
    doesn’t, it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates it using **sudo touch** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets permissions to **644** (owner can read/write, others can only read).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **[[ ! -f "$LOG_FILE" ]]** test checks whether the file does *not* ( **-!**
    ) exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **log()** function is a versatile logging utility. This function performs
    the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes a log level as the first argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uses **shift** to remove the level, leaving the remaining arguments as the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a timestamp using **date** with the format **YYYY-MM-DD HH:MM:SS** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uses **tee -a** to both display *and* append to the log file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**$*** combines all remaining arguments into the message.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The error handling setup is explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**error_handler** takes line number and error code as arguments.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uses the **log** function to record errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **trap** command catches any **ERR** ( error) signals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**${LINENO}** is a special variable containing the current line number.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**$?** contains the last command’s exit code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The validation functions ensure the environment is properly configured. The
    purpose of this section is to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check for required security tools before starting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate directory permissions and existence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return clear error messages for missing prerequisites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s examine the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The **validate_environment** function creates an array of **required_tools**
    and ensures they are found in the path. The **validate_target** function ensures
    that the directory to be scanned exists. Finally, it checks permissions to ensure
    the scan directory can be read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scanning functions implement the core security checks. The purpose of this
    section includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring each scan type is isolated in its own function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using appropriate tools from our DevSecOps environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing proper error handling and logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating structured output files for reporting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s dive into the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re simply logging a status message and setting the **output_file**
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we run a scan with **bandit** . Bandit is a **Static
    Application Security Testing** ( **SAST** ) tool that checks for vulnerabilities
    in Python code. Then, it sets the return code based on success or failure from
    the **bandit** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **perform_dependency_scan** function, we run **dependency-check** to
    test for known vulnerabilities in software dependencies and log a message based
    on the return code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The **perform_container_scan** function scans Docker container images for security
    vulnerabilities. It finds all Dockerfiles in a directory, builds container images
    from them, and uses Trivy (a vulnerability scanner) to check each image for security
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code block is responsible for generating the report summary,
    and includes the main function, which con trols the flow of code execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the results processing function, **generate_summary** , and **main**
    functions are executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **generate_summary** function performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a Markdown-formatted summary report
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extracts key findings from each scan type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uses **tail** to show the most recent SAST findings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Searches for critical dependency vulnerabilities using **grep**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parses container scan JSON using **jq** to show high and critical severity issues
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provides fallback messages when no issues are found
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Redirects all output to a single summary file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code generates the report in Markdown format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The only thing you haven’t already seen in the preceding code is the Markdown
    formatting. In Markdown, code blocks are started using a line starting with three
    backticks ( **[PRE17]
  prefs: []
  type: TYPE_NORMAL
- en: main() {
  prefs: []
  type: TYPE_NORMAL
- en: local exit_code=0
  prefs: []
  type: TYPE_NORMAL
- en: setup_logging
  prefs: []
  type: TYPE_NORMAL
- en: log "INFO" "Starting security scan of $SCAN_DIR"
  prefs: []
  type: TYPE_NORMAL
- en: validate_environment || exit 1
  prefs: []
  type: TYPE_NORMAL
- en: validate_target || exit 1
  prefs: []
  type: TYPE_NORMAL
- en: '# Create scan-specific report directory'
  prefs: []
  type: TYPE_NORMAL
- en: mkdir -p "${REPORT_DIR}/${REPORT_NAME}"
  prefs: []
  type: TYPE_NORMAL
- en: '# Perform scans'
  prefs: []
  type: TYPE_NORMAL
- en: perform_sast_scan || exit_code=$((exit_code + 1))
  prefs: []
  type: TYPE_NORMAL
- en: perform_dependency_scan || exit_code=$((exit_code + 1))
  prefs: []
  type: TYPE_NORMAL
- en: perform_container_scan || exit_code=$((exit_code + 1))
  prefs: []
  type: TYPE_NORMAL
- en: generate_summary
  prefs: []
  type: TYPE_NORMAL
- en: 'log "INFO" "Security scan completed with exit code: $exit_code"'
  prefs: []
  type: TYPE_NORMAL
- en: return $exit_code
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: $ ./security_scanner.sh
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ./security_scanner.sh /path/to/project
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ./security_scanner.sh "$CI_PROJECT_DIR"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'security_scan:'
  prefs: []
  type: TYPE_NORMAL
- en: 'stage: test'
  prefs: []
  type: TYPE_NORMAL
- en: 'script:'
  prefs: []
  type: TYPE_NORMAL
- en: '- /path/to/security_scanner.sh .   artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '- /opt/devsecops/reports/'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: $ sudo docker exec -it gitlab grep 'Password:' /etc/gitlab/initial_root_password
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sudo gitlab-runner register \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --url "http://localhost" \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --registration-token "your_token_here" \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --description "docker-runner" \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --executor "docker" \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --docker-image "docker:dind" \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --docker-privileged \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --docker-volumes "/cache" \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --docker-volumes "/opt/devsecops:/opt/devsecops:rw" \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --docker-volumes "/var/run/docker.sock:/var/run/docker.sock" \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --docker-network-mode "host" \
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --clone-url "http://localhost"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ sudo mkdir -p /opt/devsecops/scripts
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ sudo cp ch16_devsecops_scanner.sh /opt/devsecops/scripts/security_scanner.sh
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ sudo chmod +x /opt/devsecops/scripts/security_scanner.sh
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ sudo chown -R gitlab-runner:gitlab-runner /opt/devsecops
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ sudo chmod -R 755 /opt/devsecops
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ sudo systemctl restart gitlab-runner
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ sudo usermod -aG docker gitlab-runner
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ git clone http://localhost/<username>/vulnerable-flask-app.git
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ git config user.name "Your Name"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ git config user.email "your.email@example.com"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ mkdir -p reports
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ touch reports/.gitkeep
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ git add .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ git commit -m "Initial commit of vulnerable application"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ git remote add origin http://localhost/<youruser>/vulnerable-flask-app.git
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ git push -u origin main
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '#!/usr/bin/env bash'
  prefs: []
  type: TYPE_NORMAL
- en: if [[ $EUID -ne 0 ]]; then
  prefs: []
  type: TYPE_NORMAL
- en: echo "This script must be run as root"
  prefs: []
  type: TYPE_NORMAL
- en: exit 1
  prefs: []
  type: TYPE_NORMAL
- en: fi
  prefs: []
  type: TYPE_NORMAL
- en: THRESHOLD=5
  prefs: []
  type: TYPE_NORMAL
- en: CHECK_INTERVAL=300  # 5 minutes
  prefs: []
  type: TYPE_NORMAL
- en: ALERT_EMAIL="<user>@devsecops.local"
  prefs: []
  type: TYPE_NORMAL
- en: GITLAB_LOG="/srv/gitlab/logs/gitlab-rails/application_json.log"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: send_alert() {
  prefs: []
  type: TYPE_NORMAL
- en: local failed_count=$1
  prefs: []
  type: TYPE_NORMAL
- en: local recent_failures=$2
  prefs: []
  type: TYPE_NORMAL
- en: 'echo "WARNING: $failed_count failed login attempts in the last 5 minutes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time: $(date)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recent failures:'
  prefs: []
  type: TYPE_NORMAL
- en: $recent_failures" | mail -s "GitLab Security Alert - Failed Logins" "$ALERT_EMAIL"
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: monitor_failed_logins() {
  prefs: []
  type: TYPE_NORMAL
- en: if [ ! -f "$GITLAB_LOG" ]; then
  prefs: []
  type: TYPE_NORMAL
- en: 'echo "Error: GitLab log file not found at $GITLAB_LOG"'
  prefs: []
  type: TYPE_NORMAL
- en: exit 1
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: local current_time=$(date +%s)
  prefs: []
  type: TYPE_NORMAL
- en: local window_start=$((current_time - CHECK_INTERVAL))
  prefs: []
  type: TYPE_NORMAL
- en: local window_start_iso=$(date -u -d "@$window_start" +"%Y-%m-%dT%H:%M:%S")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: local recent_failures=$(grep "Failed Login:" "$GITLAB_LOG" | while read -r line;
    do
  prefs: []
  type: TYPE_NORMAL
- en: log_time=$(echo "$line" | jq -r '.time' | cut -d'.' -f1)
  prefs: []
  type: TYPE_NORMAL
- en: if [[ "$log_time" > "$window_start_iso" ]]; then
  prefs: []
  type: TYPE_NORMAL
- en: echo "$line"
  prefs: []
  type: TYPE_NORMAL
- en: fi
  prefs: []
  type: TYPE_NORMAL
- en: done)
  prefs: []
  type: TYPE_NORMAL
- en: local failed_count=$(echo "$recent_failures" | grep -c "Failed Login:")
  prefs: []
  type: TYPE_NORMAL
- en: if [ "$failed_count" -gt "$THRESHOLD" ]; then
  prefs: []
  type: TYPE_NORMAL
- en: send_alert "$failed_count" "$(echo "$recent_failures" | jq -r '.message')"
  prefs: []
  type: TYPE_NORMAL
- en: fi
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: while true; do
  prefs: []
  type: TYPE_NORMAL
- en: monitor_failed_logins
  prefs: []
  type: TYPE_NORMAL
- en: sleep "$CHECK_INTERVAL"
  prefs: []
  type: TYPE_NORMAL
- en: done
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: $ sudo apt update
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo apt install -y git live-build simple-cdd cdebootstrap curl
  prefs: []
  type: TYPE_NORMAL
- en: $ git clone https://gitlab.com/kalilinux/build-scripts/live-build-config.git
  prefs: []
  type: TYPE_NORMAL
- en: $ cd live-build-config
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: $ ./build.sh --variant gnome --verbose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ./build.sh --variant kde --verbose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ./build.sh --variant xfce --verbose
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ./build.sh --verbose --arch amd64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ./build.sh --verbose --arch arm64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '#!/usr/bin/env bash'
  prefs: []
  type: TYPE_NORMAL
- en: Set build parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DESKTOP="gnome"  # Options: gnome, kde, xfce'
  prefs: []
  type: TYPE_NORMAL
- en: 'ARCH="amd64"     # Options: amd64, arm64'
  prefs: []
  type: TYPE_NORMAL
- en: VERSION="custom-1.0"
  prefs: []
  type: TYPE_NORMAL
- en: 'BUILD_TYPE="installer"  # Options: installer, live'
  prefs: []
  type: TYPE_NORMAL
- en: Create custom password configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: mkdir -p kali-config/common/includes.chroot/etc/live/config
  prefs: []
  type: TYPE_NORMAL
- en: echo 'LIVE_USER_DEFAULT_GROUPS="audio cdrom dialout floppy video plugdev netdev
    powerdev scanner bluetooth kali"' > kali-config/common/includes.chroot/etc/live/config/user-setup
  prefs: []
  type: TYPE_NORMAL
- en: echo 'LIVE_USER_PASSWORD=kali' >> kali-config/common/includes.chroot/etc/live/config/user-setup
  prefs: []
  type: TYPE_NORMAL
- en: Launch build with all parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ./build.sh \
  prefs: []
  type: TYPE_NORMAL
- en: --verbose \
  prefs: []
  type: TYPE_NORMAL
- en: --variant ${DESKTOP} \
  prefs: []
  type: TYPE_NORMAL
- en: --arch ${ARCH} \
  prefs: []
  type: TYPE_NORMAL
- en: --version ${VERSION} \
  prefs: []
  type: TYPE_NORMAL
- en: --${BUILD_TYPE}
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: $ sudo apt install -y qemu qemu-system-x86 ovmf
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ qemu-img create -f qcow2 /tmp/kali.img 20G
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: qemu-system-x86_64 -enable-kvm -drive if=virtio,aio=threads,cache=unsafe,format=qcow2,file=/tmp/kali-test.hdd.img
    -cdrom images/kali-custom-image.iso -boot once=d
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '```'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can read more about the process of creating custom Kali images at [https://gitlab.com/kalilinux/build-scripts/live-build-config](https://gitlab.com/kalilinux/build-scripts/live-build-config)
    .
  prefs: []
  type: TYPE_NORMAL
- en: As a consultant, I start new projects with a different customer as often as
    every week. Each customer gets a fresh virtual machine to prevent the cross-contamination
    of data between customers. The build process outlined in this section makes it
    easy to quickly create a new Kali image customized for your needs and preferences.
    If you rely on different tool sets for different types of pentests, simply make
    a copy of the **ch16_build_kali.sh** script and customize the choice of packages
    and metapackages to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a simple DevSecOps environment using
    Bash scripting on Kali Linux. The Bash scripts demonstrated essential patterns
    for secure shell scripting including proper error handling, logging, input validation,
    and environment verification. You saw how to integrate multiple security tools
    including OWASP Dependency-Check and Trivy. You also learned how to create simple
    (and free) automated security monitoring Bash scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Through the scripts, you learned about professional logging practices, modular
    function design, and proper system setup validation. The examples covered real-world
    security considerations such as running as **root** safely, checking prerequisites,
    handling errors gracefully, and creating clean workspaces with appropriate permissions.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this book, you should now have a thorough understanding of how
    to integrate Bash into your pentesting workflow. In Bash, there are many ways
    to accomplish any particular task. I’ve been careful to show the most straightforward
    way in my examples and avoided complexity as much as possible to make this subject
    easier to learn. Please create an *issue* in the book’s GitHub repository if any
    of the code isn’t working or needs further explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for reading!
  prefs: []
  type: TYPE_NORMAL
