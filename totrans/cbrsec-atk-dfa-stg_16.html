<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Log Analysis</h1>
                </header>
            
            <article>
                
<p>In <a href="b0ad8ba7-b36c-4f99-bf90-f67f89256170.xhtml"><span class="ChapterrefPACKT">Chapter 13</span></a>, <em>Investigating an Incident,</em> you learned about the investigation process, and some techniques for finding the right information while investigating an issue. However, to investigate a security issue, it is often necessary to review multiple logs from different vendors and different devices. Although each vendor might have some custom fields in the log, the reality is that, once you learn how to read logs, it becomes easier to switch vendors and just focus on deltas for that vendor. While there are many tools that will automate log aggregation, such as a SIEM solution, there will be scenarios in which you need to manually analyze a log in order to figure out the root cause.</p>
<p>In this chapter, we are going cover the following topics:</p>
<ul>
<li>Data correlation</li>
<li>Operating system logs</li>
<li>Firewall log</li>
<li>Web server logs</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Data correlation</h1>
                </header>
            
            <article>
                
<p>There is no doubt that the majority of organizations will be using some sort of SIEM solution to concentrate all of their logs in one single location, and using a custom query language to search throughout the logs. While this is the current reality, as a security professional, you still need to know how to navigate throughout different events, logs, and artifacts to perform deeper investigations. Many times, the data obtained from the SIEM will be useful in identifying the threat, the threat actors, and narrowing down the compromised systems but, in some circumstances, this is not enough; you need to find the root cause and eradicate the threat.</p>
<p>For this reason, every time that you perform data analysis, it is important to think about how the pieces of the puzzle will be working together.</p>
<p>The following diagram shows an example of this data correlation approach to review logs:</p>
<div class="packt_figure">
<div class="CDPAlignCenter CDPAlign"><img height="319" width="502" src="assets/71ec888d-00e7-425c-910f-c055b2c78714.png"/></div>
</div>
<p>Let's see how this flowchart works:</p>
<ol>
<li>The investigator starts reviewing indications of compromise in the operating system's logs. Many suspicious activities were found in the OS and, after reviewing a Windows prefetch file, it is possible to conclude that a suspicious process started a communication with an external entity. It is now time to review the firewall logs in order to verify more information about this connection.</li>
<li>The firewall logs reveal that the connection between the workstation and the external website was established using TCP on port <kbd>443</kbd> and that it was encrypted.</li>
<li>During this communication, a callback was initiated from the external website to the internal web server. It's time to review the web server log files.</li>
<li>The investigator continues the data correlation process by reviewing the IIS logs located in this web server. He finds out that the adversary tried a SQL injection attack against this web server.</li>
</ol>
<p>As you can see from this flowchart, there is a logic behind which logs to access, what information you are looking for, and most importantly, how to look at all this data in a contextualized manner.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Operating system logs</h1>
                </header>
            
            <article>
                
<p>The types of logs available in an operating system may vary; in this book, we will focus on core logs that are relevant from a security perspective. We will use Windows and Linux operating systems to demonstrate that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Windows logs</h1>
                </header>
            
            <article>
                
<p>In a Windows operating system, the most relevant security-related logs are accessible via Event Viewer. In <a href="b0ad8ba7-b36c-4f99-bf90-f67f89256170.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 13</span></a>, <em>Investigating an Incident</em>, we spoke about the most common events that should be reviewed during an investigation. While the events can be easily located in Event Viewer, you can also obtain the individual files at <kbd>Windows\System32\winevt\Logs,</kbd> as shown in the following screenshot:</p>
<div class="packt_figure">
<div class="CDPAlignCenter CDPAlign"><img src="assets/043c3b2b-92a6-402f-80aa-5d10bf6d0abb.png"/></div>
</div>
<p>However, log analysis in an operating system is not necessarily limited to the logging information provided by the OS, especially in Windows. There are other sources of information that you could use, including prefetch files (Windows Prefetch). These files contain relevant information regarding process execution. They can be useful when trying to understand if a malicious process was executed and which actions were done by that first execution.</p>
<p>In Windows 10, you also have <kbd>OneDrive</kbd> logs (<kbd>C:\Users\&lt;USERNAME&gt;\AppData\Local\Microsoft\OneDrive\logs</kbd>), which can be useful. If you are investigating data extraction, this could be a good place to look to verify if any wrongdoing was carried out. Review the <kbd>SyncDiagnostics.log</kbd> for more information.</p>
<div class="packt_infobox">To parse Windows Prefetch files, use this Python script at <a href="https://github.com/PoorBillionaire/Windows-Prefetch-Parser"><span class="URLPACKT">//github.com/PoorBillionaire/Windows-Prefetch-Parser</span></a>.</div>
<p>Another important file location is where Windows stores the user mode crash dump files, which is <kbd>C:\Users\&lt;username&gt;\AppData\Local\CrashDumps</kbd>. These crash dump files are important artifacts that can be used to identify potential malware in the system.</p>
<p>One common type of attack that can be exposed in a dump file is the code injection attack. This happens when there is an insertion of executable modules into running processes or threads. This technique is mostly used by malware to access data and to hide or prevent its removal (for example, persistence). It is important to emphasize that legitimate software developers may occasionally use code injection techniques for non-malicious reasons, such as modifying an existing application.</p>
<p>To open these dump files you need a debugger, such as <em>WinDbg</em> (<a href="http://www.windbg.org"><span class="URLPACKT">http://www.windbg.org</span></a>) and you need the proper skills to navigate through the dump file to identify the root cause of the crash. If you don't have those skills, you can also use <em>Instant Online Crash Analysis</em> (<a href="http://www.osronline.com"><span class="URLPACKT">http://www.osronline.com</span></a>).</p>
<p>The results that follow are a brief summary of the automated analyses from using this online tool (the main areas to follow up are in bold):</p>
<pre>TRIAGER: Could not open triage file : e:dump_analysisprogramtriageguids.ini, error 2 
TRIAGER: Could not open triage file : e:dump_analysisprogramtriagemodclass.ini, error 2 
GetUrlPageData2 (WinHttp) failed: 12029. 
*** The OS name list needs to be updated! Unknown Windows version: 10.0 *** 
 
FAULTING_IP:  
eModel!wil::details::ReportFailure+120 
00007ffe`be134810 cd29            int     29h 
 
EXCEPTION_RECORD:  ffffffffffffffff -- (.exr 0xffffffffffffffff) 
ExceptionAddress: 00007ffebe134810 (eModel!wil::details::ReportFailure+0x0000000000000120) <br/><strong>ExceptionCode: c0000409 (Stack buffer overflow</strong>)<br/>ExceptionFlags: 00000001 
NumberParameters: 1 
Parameter[0]: 0000000000000007 <br/><br/><strong>PROCESS_NAME: MicrosoftEdge.exe</strong></pre>
<p><kbd>EXCEPTION_CODE: (NTSTATUS) 0xc0000409</kbd>: </p>
<p>The system detected an overrun of a stack-based buffer in this application. This overrun could potentially allow a malicious user to gain control of this application.</p>
<pre>EXCEPTION_PARAMETER1:  0000000000000007 
 
NTGLOBALFLAG:  0 
 
APPLICATION_VERIFIER_FLAGS:  0 
 
FAULTING_THREAD:  0000000000003208 
 
BUGCHECK_STR:  APPLICATION_FAULT_STACK_BUFFER_OVERRUN_MISSING_GSFRAME_SEHOP <br/><strong><br/>PRIMARY_PROBLEM_CLASS: STACK_BUFFER_OVERRUN_SEHOP<br/><br/><br/></strong>DEFAULT_BUCKET_ID:  STACK_BUFFER_OVERRUN_SEHOP 
 
LAST_CONTROL_TRANSFER:  from 00007ffebe1349b0 to 00007ffebe134810 
 
STACK_TEXT:   
000000d4`dc4fa910 00007ffe`be1349b0 : ffffffff`ffffffec 00007ffe`df5e0814 000000d4`dc4fc158 000002bb`a1d20820 : eModel!wil::details::ReportFailure+0x120 
000000d4`dc4fbe50 00007ffe`be0fa485 : 00000000`00000000 00007ffe`df5ee52e 000002bb`ac0f5101 00007ffe`be197771 : eModel!wil::details::ReportFailure_Hr+0x44 
000000d4`dc4fbeb0 00007ffe`be0fd837 : 000002bb`ab816b01 00000000`00000000 00000000`00010bd8 000002bb`00000000 : eModel!wil::details::in1diag3::FailFast_Hr+0x29 
000000d4`dc4fbf00 00007ffe`be12d7dd : 00000000`00010bd8 00000000`00000000 00000000`80070001 000000d4`dc4ffa60 : eModel!FailFastOnReparenting+0xf3 
000000d4`dc4ffc00 00007ffe`be19e5b8 : 000002bb`ab816b20 00000000`00000000 00000000`00000000 000002bb`a16b7bb8 : eModel!SetParentInBrokerInternal+0x40b5d 
000000d4`dc4ffc40 00007ffe`be19965c : 00000000`00000000 000002bb`ac0f51f0 000002bb`ac0f51f4 000002bb`ac0f50c0 : eModel!CTabWindowManager::_AttemptFrameFastShutdown+0x118 
000000d4`dc4ffc90 00007ffe`be19634e : 000002bb`c0061b00 000000d4`dc4ffd00 00007ffe`be0a9e00 00000000`00000001 : eModel!CTabWindowManager::CloseAllTabs+0x6c 
000000d4`dc4ffcd0 00007ffe`be114a0b : 00000000`00000000 00007ffe`be0a9ed0 000002bb`c0061b00 000002bb`c0061b00 : eModel!CBrowserFrame::_OnClose+0x106 
000000d4`dc4ffd50 00007ffe`be07676e : 00000000`00000000 00000000`00000000 00000000`00000000 000002bb`c00711f0 : eModel!CBrowserFrame::FrameMessagePump+0x6e63b 
000000d4`dc4ffe30 00007ffe`be076606 : 000002bb`00032401 000002bb`c0061b00 000000d4`dc4fff50 000002bb`c00711f0 : eModel!_BrowserThreadProc+0xda 
000000d4`dc4ffeb0 00007ffe`be0764a9 : 00000000`00000001 000002bb`c0071218 000000d4`dc4fff50 00000000`00000000 : eModel!_BrowserNewThreadProc+0x56 
000000d4`dc4ffef0 00007ffe`dea68364 : 000002bb`aae03cd0 00000000`00000000 00000000`00000000 00000000`00000000 : eModel!SHOpenFolderWindow+0xb9 
000000d4`dc4fff60 00007ffe`e13470d1 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : kernel32!BaseThreadInitThunk+0x14 
000000d4`dc4fff90 00000000`00000000 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000000 : ntdll!RtlUserThreadStart+0x21 </pre>
<p>In this crash analysis done by Instant Online Crash Analysis, we have an overrun of a stack-based buffer in Microsoft Edge. Now, you can correlate this log (the day that the crash occurred) with other information available in Event Viewer (security and application logs) to verify if there was any suspicious process running that could have potentially gained access to this application. Remember that, in the end, you need to perform data correlation to have more tangible information regarding a specific event and its culprit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linux logs</h1>
                </header>
            
            <article>
                
<p>In Linux, there are many logs that you can use to look for security-related information. One of the main ones is the <kbd>auth.log</kbd>, located under <kbd>/var/log</kbd>, which contains all authentication related events.</p>
<p>Here is an example of this log:</p>
<pre>Nov  5 11:17:01 kronos CRON[3359]: pam_unix(cron:session): session opened for user root by (uid=0) 
Nov  5 11:17:01 kronos CRON[3359]: pam_unix(cron:session): session closed for user root 
Nov  5 11:18:55 kronos gdm-password]: pam_unix(gdm-password:auth): conversation failed 
Nov  5 11:18:55 kronos gdm-password]: pam_unix(gdm-password:auth): auth could not identify password for [root] 
Nov  5 11:19:03 kronos gdm-password]: gkr-pam: unlocked login keyring 
Nov  5 11:39:01 kronos CRON[3449]: pam_unix(cron:session): session opened for user root by (uid=0) 
Nov  5 11:39:01 kronos CRON[3449]: pam_unix(cron:session): session closed for user root 
Nov  5 11:39:44 kronos gdm-password]: pam_unix(gdm-password:auth): conversation failed 
Nov  5 11:39:44 kronos gdm-password]: pam_unix(gdm-password:auth): auth could not identify password for [root] 
Nov  5 11:39:55 kronos gdm-password]: gkr-pam: unlocked login keyring 
Nov  5 11:44:32 kronos sudo:     root : TTY=pts/0 ; PWD=/root ; USER=root ; COMMAND=/usr/bin/apt-get install smbfs 
Nov  5 11:44:32 kronos sudo: pam_unix(sudo:session): session opened for user root by root(uid=0) 
Nov  5 11:44:32 kronos sudo: pam_unix(sudo:session): session closed for user root 
Nov  5 11:44:45 kronos sudo:     root : TTY=pts/0 ; PWD=/root ; USER=root ; COMMAND=/usr/bin/apt-get install cifs-utils 
Nov  5 11:46:03 kronos sudo:     root : TTY=pts/0 ; PWD=/root ; USER=root ; COMMAND=/bin/mount -t cifs //192.168.1.46/volume_1/temp 
Nov  5 11:46:03 kronos sudo: pam_unix(sudo:session): session opened for user root by root(uid=0) 
Nov  5 11:46:03 kronos sudo: pam_unix(sudo:session): session closed for user root </pre>
<p>The preceding logs were collected from a Kali distribution; RedHat and CentOS will store similar information at <kbd>/var/log/secure</kbd>. If you want to review only failed login attempts, use the logs from <kbd>var/log/faillog</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Firewall logs</h1>
                </header>
            
            <article>
                
<p>The firewall log format varies according to the vendor; however, there are some core fields that will be there regardless of the platform. When reviewing the firewall logs, you must a focus on primarily answering the following questions:</p>
<ul>
<li>Who started the communication <span>(source IP)</span>?</li>
<li>Where is the destination of that communication<span> (destination IP)</span>?</li>
<li>What type of application is trying to reach the destination<span> (transport protocol and port)</span>?</li>
<li>Was the connection allowed or denied by the firewall?</li>
</ul>
<p>The following code is an example of the <kbd>Check Point</kbd> firewall log; in this case, we are hiding the destination IP for privacy purposes:</p>
<pre>"Date","Time","Action","FW.Name","Direction","Source","Destination","Bytes","Rules","Protocol" 
"datetime=26Nov2017","21:27:02","action=drop","fw_name=Governo","dir=inbound","src=10.10.10.235","dst=XXX.XXX.XXX.XXX","bytes=48","rule=9","proto=tcp/http" 
"datetime=26Nov2017","21:27:02","action=drop","fw_name=Governo","dir=inbound","src=10.10.10.200","dst=XXX.XXX.XXX.XXX","bytes=48","rule=9","proto=tcp/http" 
"datetime=26Nov2017","21:27:02","action=drop","fw_name=Governo","dir=inbound","src=10.10.10.2","dst=XXX.XXX.XXX.XXX","bytes=48","rule=9","proto=tcp/http" 
"datetime=26Nov2017","21:27:02","action=drop","fw_name=Governo","dir=inbound","src=10.10.10.8","dst=XXX.XXX.XXX.XXX","bytes=48","rule=9","proto=tcp/http" </pre>
<p>In this example, rule number 9 was the one that processed all these requests and dropped all connection attempts from <kbd>10.10.10.8</kbd> to a specific destination. Now, using the same reading skills, let's review a <kbd>NetScreen</kbd> firewall log:</p>
<pre>Nov  2 13:55:46 fire01 fire00: NetScreen device_id=fire01  [Root]system-notification-00257(traffic): start_time="2016-00-02 13:55:45" duration=0 policy_id=119 service=udp/port:7001 proto=17 src zone=Trust dst zone=Untrust action=Deny sent=0 rcvd=0 src=192.168.2.10 dst=8.8.8.8 src_port=3036 dst_port=7001 </pre>
<p>One important difference between the Check Point and the NetScreen firewall logs is how they log information about the transport protocol. In the Check Point log, you will see that the <kbd>proto</kbd> field contains the transport protocol and the application (in the above case, HTTP). The <span>NetScreen</span> log shows similar information in the <kbd>service</kbd> and <kbd>proto</kbd> fields. As you can see, there are small changes, but the reality is that, once you are comfortable reading a firewall log from one vendor, others will be easier to understand.</p>
<p>You can also use a Linux machine as a firewall by leveraging <kbd>iptable</kbd>s. Here is an example of what the <kbd>iptables.log</kbd> looks like:</p>
<pre># cat /var/log/iptables.log 
Nov  6 10:22:36 cnd kernel: PING YuriDio IN=eth3 OUT= MAC=d8:9d:67:cd:b2:14 SRC=192.168.1.10 DST=192.168.1.88 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=0 DF PROTO=ICMP TYPE=8 CODE=0 ID=1007 SEQ=2 </pre>
<p>If you need to review Windows Firewall, look for the <kbd>pfirewall.log</kbd> log file at <kbd>C:\Windows\System32\LogFiles\Firewall</kbd>. This log has the following format:</p>
<pre>#Version: 1.5 
#Software: Microsoft Windows Firewall 
#Time Format: Local 
#Fields: date time action protocol src-ip dst-ip src-port dst-port size tcpflags tcpsyn tcpack tcpwin icmptype icmpcode info path 
 
2017-12-22 07:38:54 ALLOW TCP 169.254.211.124 169.254.211.124 63863 4369 0 - 0 0 0 - - - SEND 
2017-12-22 07:38:54 ALLOW TCP 169.254.211.124 169.254.211.124 63863 4369 0 - 0 0 0 - - - RECEIVE 
2017-12-22 07:38:55 ALLOW UDP 169.254.125.142 169.254.255.255 138 138 0 - - - - - - - SEND 
2017-12-22 07:38:55 ALLOW UDP 169.254.211.124 169.254.255.255 138 138 0 - - - - - - - SEND 
2017-12-22 07:38:55 ALLOW UDP 192.168.1.47 192.168.1.255 138 138 0 - - - - - - - SEND </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Web server logs</h1>
                </header>
            
            <article>
                
<p>When reviewing web server logs, pay particular attention to the web servers that have web applications interacting with SQL databases. The IIS Web Server log files are located at <kbd>\WINDOWS\system32\LogFiles\W3SVC1</kbd> and they are <kbd>.log</kbd> files that can be opened using Notepad. You can also use Excel or Microsoft Log Parser to open this file and perform basic queries.</p>
<div class="packt_infobox">You can download Log Parser from <a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659"><span class="URLPACKT">https://www.microsoft.com/en-us/download/details.aspx?id=24659</span></a>.</div>
<p>When reviewing the IIS log, pay close attention to the <kbd>cs-uri-query</kbd> and <kbd>sc-statu<em>s</em></kbd> fields. These fields will show details about the HTTP requests that were performed. If you use Log Parser, you can perform a query against the log file to quickly identify if the system experienced a SQL injection attack. Here is an example:</p>
<pre><strong>logparser.exe -i:iisw3c -o:Datagrid -rtp:100 "select date, time, c-ip, cs-uri-stem, cs-uri-query, time-taken, sc-status from C:wwwlogsW3SVCXXXexTEST*.log where cs-uri-query like '%CAST%'".</strong>  </pre>
<p>Here is an example of a potential output with the keyword CAST located in the <kbd>cs-uri-query</kbd> field:</p>
<pre>80 POST  /pages/Users/index.asp  ID=UT-47-TP-M17';DECLARE%20@S%20NVARCHAR(4000);SET%30@S=CAST(0x4400);EXEC(@S);--|31|80040e32|Timeout_expired     500 </pre>
<p>Notice that, in this case, the error code was <kbd>500</kbd> (internal server error); in other words, the server was not able to fulfil the request. When you see this type of activity in your IIS log, you should take action to enhance your protection on this web server; one alternative is to add a WAF.</p>
<p>If you are reviewing an Apache log file, the access log file is located at <kbd>/var/log/apache2/access.log</kbd> and the format is also very simple to read, as you can see in the following example:</p>
<pre>192.168.1.10 - - [07/Dec/2017:15:35:19 -0800] "GET /public/accounting HTTP/1.1" 200 6379 
192.168.1.10 - - [07/Dec/2017:15:36:22 -0800] "GET /docs/bin/main.php 200 46373 
192.168.1.10 - - [07/Dec/2017:15:37:27 -0800] "GET /docs HTTP/1.1" 200 4140 </pre>
<p>If you are looking for a particular record, you can also use the <kbd>cat</kbd> command in Linux, as follows:</p>
<pre><strong>#cat /var/log/apache2/access.log | grep -E "CAST"</strong>  </pre>
<div class="packt_infobox">Another alternative is to use apache-scalp tool, which you can download from <a href="https://code.google.com/archive/p/apache-scalp" target="_blank">https://code.google.com/archive/p/apache-scalp</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">References</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">iptables: <a href="https://help.ubuntu.com/community/IptablesHowTo" target="_blank">https://help.ubuntu.com/community/IptablesHowTo</a></li>
<li class="mce-root">Log Parser: <a href="https://logrhythm.com/blog/a-technical-analysis-of-wannacry-ransomware/" target="_blank">https://logrhythm.com/blog/a-technical-analysis-of-wannacry-ransomware/</a></li>
<li class="mce-root">SQL Injection Finder: <a href="http://wsus.codeplex.com/releases/view/13436" target="_blank">http://wsus.codeplex.com/releases/view/13436</a></li>
<li class="mce-root">SQL Injection Cheat Sheet: <a href="https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/" target="_blank">https://www.netsparker.com/blog/web-security/sql-injection-cheat-sheet/</a></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned about the importance of data correlation while reviewing logs in different locations. You also read about relevant security-related logs in Windows and Linux.</p>
<p>Next, you learned how to read firewall logs using Check Point, NetScreen, iptables, and Windows Firewall as examples.</p>
<p>At the end of this chapter, you learned about web server logs, using IIS and Apache as examples.</p>
<p>As you finish reading this chapter, and this book, it's time to step back and reflect on this cybersecurity journey. It is very important to take the theory that you learned here, aligned with the practical examples that were used throughout this book, and apply it to your environment or to your customer's environment. While there is no such thing as one size fits all in cybersecurity, the lessons learned here can be used as a foundation for your future work. The threat landscape is changing constantly and, by the time we finished writing this book, a new vulnerability was discovered. Probably, by the time you have finished reading this book, another one has been discovered. It's for this reason that the foundation of knowledge is so important, because it will assist you in rapidly absorbing new challenges and applying security principles to remediate threats. Stay safe!</p>


            </article>

            
        </section>
    </body></html>