<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer120">
			<h1 id="_idParaDest-424"><em class="italic"><a id="_idTextAnchor437"/>Chapter 13</em>: Hacking Web Servers and Web Apps</h1>
			<p>The purpose of hacking web servers and web apps is to search for and discover potential vulnerabilities. It helps us identify important upgrades that are needed for software, thus improving security and helping us recognize and respond to any malicious activity. Additionally, with so much being transacted online including shopping, banking, and communications, web apps give us an additional resource to gain access to a person's login credentials, private messages, and financial information.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Why web servers create security issues</li>
				<li>Types of architectures</li>
				<li>Threats to both servers and applications </li>
				<li>The vulnerabilities of web APIs, web shells, and webhooks</li>
				<li>Detecting web server hacking attempts</li>
			</ul>
			<p>Let's begin by discussing why web servers create security issues for us.</p>
			<h1 id="_idParaDest-425"><a id="_idTextAnchor438"/>Why web servers create security issues</h1>
			<p>It's important to understand that web applications and servers are not inherently secure. The fact is <a id="_idIndexMarker2013"/>that they were never designed to be secure – they were designed for functionality and to provide a service. The responsibility for making them safe rests with us, as system administrators, coders, and security professionals.</p>
			<p>This is why attackers turn their attention to web servers and web application-level attacks – because a web server that hosts web applications is accessible from anywhere over the internet. This makes web servers an attractive target. Poorly configured web servers can create vulnerabilities in even the most carefully designed firewall systems. Attackers can exploit poorly configured web servers with known vulnerabilities to compromise the security of web applications. Furthermore, web servers with known vulnerabilities can harm the security of an organization, even if the web applications they host are secure.</p>
			<p>Every open port on a web server is an entry point for a possible attack, especially if it hosts applications <a id="_idIndexMarker2014"/>that use protocols such as HTTP and FTP. The operating system must protect the application from <strong class="bold">Denial-of-Service</strong> (<strong class="bold">DOS</strong>) attacks by ensuring that processes have sufficient resources to function properly. The real problem <a id="_idIndexMarker2015"/>with these operating system security features is that they can be used against the application. Adding add-ons, plugins, and their configurations on top of the OS and its applications creates a perfect storm for attackers.</p>
			<p>Before you start trying to hack a web server, it's important to understand how they work.</p>
			<p>There are <a id="_idIndexMarker2016"/>three main components to a web server:</p>
			<ul>
				<li>The web server software, which is what we want to attack.</li>
				<li>The website content/files, which need to be in a certain format for the web server to access and read them.</li>
				<li>The operating system itself.</li>
			</ul>
			<p>Every web server essentially works the same way; it receives a request from a user and then tries to find the file they want. Then, it reads the file and sends it to the user so that they can see it.</p>
			<p>Every web server has a piece of software behind it called an HTTP daemon/service/server. The name varies, depending on the server. Apache/httpd is a popular HTTP <a id="_idIndexMarker2017"/>daemon for Linux-based servers, while <strong class="bold">Internet Information Server</strong> (<strong class="bold">IIS</strong>) is a popular one for Windows servers.</p>
			<p>HTTP daemons essentially run in the background and receive requests from users on port <strong class="source-inline">80</strong> by default. So, every time you type <a href="http://facebook.com">facebook.com</a> into your browser, your computer is sending a request to the Facebook web server to find out the files it needs to display for you to see the page.</p>
			<p>The process of finding these files is called mapping URLs/domains to certain directories on the server, indexing, and so on. Then, when a user tries to access a file, it maps the filename onto the corresponding path that has been mapped to that URL.</p>
			<p>These web servers <a id="_idIndexMarker2018"/>also contain security features, such as limiting the amount of physical memory it can access for each process, preventing unauthorized code execution, and ensuring certain file types are not allowed to be executed.</p>
			<p>Now, let's discuss the components of a web server.</p>
			<h2 id="_idParaDest-426"><a id="_idTextAnchor439"/>Components of a web server</h2>
			<p>First, we <a id="_idIndexMarker2019"/>have the <strong class="bold">document root</strong>. This directory is where <a id="_idIndexMarker2020"/>all the web content/files are stored. For example, if you have an <strong class="source-inline">images</strong> directory inside your document root, all the images can be accessed from <a href="http://wayne-technologies.net/images/">http://wayne-technologies.net/images/</a>.</p>
			<p>When a user requests a page using a URL, such as <strong class="source-inline">wayne-technologies.net/</strong>, it maps that URL onto the document root and then searches the folder for a file that matches that URL. This is called mapping URLs to files and folders. If it finds a match, it sends the contents of this file back to the user so that they can see it.</p>
			<p>If no matching file is found, an index document such as the default page, or <strong class="source-inline">index.php</strong>, will be searched for and sent back if found.</p>
			<p>If no index document is present, the server will typically return a <strong class="source-inline">404</strong> error to the user, saying that it can't find what they're looking for. A redirect may also be returned, telling them to look somewhere else for this file/content.</p>
			<p>Second, we have the <strong class="bold">server root</strong>. This is the directory tree's top-level root directory, including the server's configuration <a id="_idIndexMarker2021"/>and error, executable, and log files. It consists of the <a id="_idIndexMarker2022"/>server's implementation code. Typically, the server root consists of four files. One file is dedicated to the server's implementation code, while the remaining three are subdirectories – that is, <strong class="source-inline">conf</strong>, <strong class="source-inline">-logs</strong>, and <strong class="source-inline">-cgi-bin</strong> – that contain configuration data, logs, and executables, respectively.</p>
			<p>Third, there's the <strong class="bold">virtual document tree</strong>. In addition to the physical directory tree that stores <a id="_idIndexMarker2023"/>content, a virtual document tree is <a id="_idIndexMarker2024"/>maintained by HTTP daemon software. The purpose of the virtual tree is to map URLs onto files stored in the server's filesystem; for <a id="_idIndexMarker2025"/>example, it may associate <a id="_idIndexMarker2026"/>the <strong class="source-inline">http://wayne-technologies.net/images</strong> URL with an actual directory named <strong class="source-inline">/var/www/images</strong> on the server's filesystem.</p>
			<p>Fourth, we have <strong class="bold">virtual hosting</strong>. This is where you may host multiple domains/websites <a id="_idIndexMarker2027"/>on one web server. For example, you could have your <a id="_idIndexMarker2028"/>main domain, <a href="http://www.wayne-technologies.net">www.wayne-technologies.net</a>, and then to add another site, you would have to create a subdomain such as <strong class="source-inline">blog.wayne-technologies.net</strong> that points to the same document root directory to keep everything separate under one roof. Using this method, you could also host an unlimited number of sites on one web server. However, keep in mind that each subdomain will need unique passwords/credentials to prevent unauthorized access.</p>
			<p>Fifth, we have the <strong class="bold">web proxy</strong>. A web proxy is a domain that acts as an intermediary between your <a id="_idIndexMarker2029"/>computer and the website you are trying to <a id="_idIndexMarker2030"/>access. When you type in an address, it goes through the proxy DNS server, which then forwards the request to your requested website's IP address. The response is sent back through the proxy server so that it cannot be traced back to you. Web proxies are used to help mask/hide your IP address, and anyone attempting to trace the request back to you will come up with a different IP.</p>
			<p>Next, we will talk about the different types of architecture yo<a id="_idTextAnchor440"/>u may experience.</p>
			<h1 id="_idParaDest-427"><a id="_idTextAnchor441"/>Types of architecture</h1>
			<p>Web server architecture is the overall layout of a web server. It gives an attacker an idea of how they can prepare for and deploy an attack. Let's discuss the most common web server architectures you may encounter.</p>
			<h3>IIS web server architecture</h3>
			<p>Let's take a look at the typical architecture of a web server and its applications, as shown in the <a id="_idIndexMarker2031"/>following diagram. This is based on <a id="_idIndexMarker2032"/>an open source architecture. As you can see, a lot of moving parts and components are involved in supporting an application. A web server is designed to host multiple sites on one system, which <a id="_idIndexMarker2033"/>adds to the complexity. Did <a id="_idIndexMarker2034"/>your <em class="italic">hacker red flag</em> just go up? It should have. Anytime we talk about complexity, it means more areas to make mistakes, overlook settings, or miss an attack vector:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="Images/B17486_13_01.jpg" alt="Figure 13.1 – A typical open source architecture for a web server and its applications&#13;&#10;" width="569" height="336"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – A typical open source architecture for a web server and its applications</p>
			<h3>Open source web server architecture</h3>
			<p>The three most <a id="_idIndexMarker2035"/>popular open source web servers<a id="_idIndexMarker2036"/> are <strong class="bold">Apache httpd</strong>, <strong class="bold">Nginx</strong>, and <strong class="bold">lighttpd</strong>. Their principal components are as follows:</p>
			<ul>
				<li>Apache, which is <a id="_idIndexMarker2037"/>designed to <a id="_idIndexMarker2038"/>be a secure, efficient, and <a id="_idIndexMarker2039"/>extensible server</li>
				<li>MySQL, which is ideal for storing data</li>
				<li>PHP, which is a widely used, general-purpose scripting language that is especially suited for web development and can interact with MySQL to retrieve and store data</li>
			</ul>
			<p>Let's look into some of the challenges the Microsoft world gives us next.</p>
			<h3>Microsoft</h3>
			<p>Microsoft's <strong class="bold">Internet Information System</strong> (<strong class="bold">IIS</strong>) is the most widely used web server software in the world, boasting <a id="_idIndexMarker2040"/>over 800 million downloads. IIS is flexible, secure, and <a id="_idIndexMarker2041"/>easy to host using HTTP/HTTPS, FTP, RTSP, SMTP, and much more. Microsoft uses application pools, which are an extremely useful part of IIS. They allow the administrator to set different resource limits for applications running on port <strong class="source-inline">80</strong>, or any other port you wish.</p>
			<p>But why should you care about setting up user accounts and application pools? There are many reasons why an administrator may want to establish individual identities or set up application pools to run independent versions of the same website.</p>
			<p>For instance, imagine that you run a very busy web server with two separate websites on it – one dedicated to your business and another that's a marketing site for a client's new product release. It would be ideal if each site ran under its credentials and had an application pool. The business <a id="_idIndexMarker2042"/>website would require more processes, while the marketing site may need additional memory and processor speeds to handle large quantities of traffic. On a traditional server, these requirements would conflict and cause problems. With IIS and application pools, you can easily configure user accounts and resource allocations for each site with specifications without them affecting each other.</p>
			<h4>What about security? </h4>
			<p>Listen, I'm not trying to <a id="_idIndexMarker2043"/>tell you that Microsoft's IIS is unhackable – far from it. Its history <a id="_idIndexMarker2044"/>is quite sorted when it comes to being hacked, but it's come a long way.</p>
			<p>Application pools for running websites have default settings that mimic the original Windows Server 2003 version of IIS. Unless the administrator changes it, there are no anonymous users (which is what hackers want), and no direct access to the webroot (we'll talk about this in a second). With application pools, you can set up an anonymous user with limited rights, or create another restricted account, as we mentioned previously for your marketing site. This way, if one website is breached, there's no chance that a hacker could get into the other one because they're running under completely different security settings… in theory. Again, there are a plethora of attack vectors out there that have Microsoft pretty busy patching IIS, but the same can be said about Linux and Apache.</p>
			<p>Let's learn more about why web servers are compromised.</p>
			<h2 id="_idParaDest-428"><a id="_idTextAnchor442"/>Why are web servers compromised?</h2>
			<p>The most common <a id="_idIndexMarker2045"/>reasons for attackers to compromise a web server are as follows:</p>
			<ul>
				<li>Web servers are often used as attack launch points for attacking other applications.</li>
				<li>When an attacker compromises one system on the network, they can often use that system's access privileges to move around freely and gain access to additional systems <a id="_idIndexMarker2046"/>that may host sensitive data. This is known as <strong class="bold">privilege escalation</strong>.</li>
				<li>Attackers are often able to use vulnerabilities in the web server's software to compromise the system because it's easy for developers to make mistakes when writing code, or they may leave backdoors and debug options open. Attackers can use these vulnerabilities and configuration errors to take control of a system.</li>
			</ul>
			<p>Now, let's talk about adding web apps and how to do so more securely.</p>
			<h2 id="_idParaDest-429"><a id="_idTextAnchor443"/>Adding web apps</h2>
			<p>Web applications are becoming more and more vulnerable to more sophisticated threats and attack <a id="_idIndexMarker2047"/>vectors, which makes them less safe. In this section, we will teach you about web applications and attack vectors, and how to protect an organization's information from them. Web application hacking is a common method most attackers use to get into a system.</p>
			<p>The best protection against web application hacking is to not have a vulnerable or insecure website. You can do this by evaluating the code and design practices before deploying your site.</p>
			<p>A great example of why you need to secure code before deploying is what happened with Yahoo! Voices. The developers did not escape the input before inserting it into the database. As a result, a hacker was able to gain access to more than 450,000 unpublished articles on the website.</p>
			<p>Now, let's look at some of the threats to web servers and applications.</p>
			<h1 id="_idParaDest-430"><a id="_idTextAnchor444"/>Threats to both servers and applications</h1>
			<p>What types of attacks <a id="_idIndexMarker2048"/>can be launched at these technologies? Well, first, let's <a id="_idIndexMarker2049"/>start with web servers.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You'll see some similarities in the attacks that are used to target both web servers and web applications as one can create a vector for the other.</p>
			<h2 id="_idParaDest-431"><a id="_idTextAnchor445"/>Web server attacks</h2>
			<p>When it comes to <a id="_idIndexMarker2050"/>the servers themselves, attackers can launch attacks against web servers using any of the following methods:</p>
			<ul>
				<li><strong class="bold">Denial of Service</strong> (<strong class="bold">DoS</strong>): By launching a DoS/DDoS assault on a web server, an attacker attempts <a id="_idIndexMarker2051"/>to bring the service down or make it inaccessible to legitimate users. A DoS/DDoS assault on a web server is frequently directed at high-profile web servers, including bank servers, credit card payment gateways, and even root name servers.</li>
				<li><strong class="bold">Brute-force attacks</strong>: Here, an attacker attempts to use combinations of usernames and <a id="_idIndexMarker2052"/>passwords until one of them is found to be valid; these often result in a dictionary attack.</li>
				<li><strong class="bold">DNS server hijacking</strong>: This occurs when an attacker hacks a DNS server and modifies its mapping <a id="_idIndexMarker2053"/>settings to redirect users' requests to the attacker's rogue server. As a result, when a user enters a genuine URL into a browser, the settings redirect the user to the attacker's bogus site.</li>
				<li><strong class="bold">DNS amplification attacks</strong>: For this attack, the attacker spoofs a DNS request from a target <a id="_idIndexMarker2054"/>and sends it to another open DNS resolver. The targeted DNS server will now send a large DNS response to the forged IP address of the victim. This can result in a large number of data packets being sent to the victim's system and can overload and shut down the system.</li>
				<li><strong class="bold">Directory traversal</strong>: This attack consists of an attacker obtaining access to a hidden directory on <a id="_idIndexMarker2055"/>a web server, bypassing normal access restrictions, and exposing data that shouldn't be allowed to be accessed.</li>
				<li><strong class="bold">Man-in-the-middle</strong>: This method is where an attacker intercepts communications <a id="_idIndexMarker2056"/>between two systems without either of them knowing. The attacker intercepts the communication and can view or edit it before passing it back to the systems.</li>
				<li><strong class="bold">Phishing attacks</strong>: This is an attack in which the attacker sets up a fake website to <a id="_idIndexMarker2057"/>trick users into entering sensitive data, such as passwords and credit card information.</li>
				<li><strong class="bold">SQL injection</strong>: This is a type of attack where an attacker attempts to access information from <a id="_idIndexMarker2058"/>a database on a web server, which would normally be disallowed. However, if the web developer did not use parameterized queries when communicating with the database, it leaves the system vulnerable.</li>
			</ul>
			<p><strong class="bold">Session initiation protocol</strong> (<strong class="bold">SIP</strong>) and <strong class="bold">real-time protocol</strong> (<strong class="bold">RTP</strong>) are used for <a id="_idIndexMarker2059"/>communication by <strong class="bold">Voice over Internet Protocol</strong> (<strong class="bold">VoIP</strong>) systems <a id="_idIndexMarker2060"/>and are also vulnerable <a id="_idIndexMarker2061"/>to this attack.</p>
			<ul>
				<li><strong class="bold">HTTP response-splitting attack</strong>: This is a web-based attack in which the attacker deceives the server by injecting new lines and arbitrary code into response <a id="_idIndexMarker2062"/>headers. The attacker manipulates the input parameter and cleverly builds a request header that prompts the server to return two answers. By inserting header response data into the input field, the attacker makes a single request appear as two requests. Each request is then responded to by the web server. The attacker can provide malicious <a id="_idIndexMarker2063"/>data to a vulnerable application, which then stores it in an HTTP response header.</li>
				<li><strong class="bold">Web cache poisoning attack</strong>: This makes the intermediate web cache source less reliable <a id="_idIndexMarker2064"/>because of web cache poisoning. In this attack, an attacker changes the cached content for a random URL that has malware on it. When requesting the required URL through the web cache, unaware users may mistakenly utilize the misidentified content rather than the genuine and secure material. The attacker causes the web server's cache to be purged of actual cache content and asks it to store a specially crafted request. As a result, all the users on the web server's cache will receive harmful content until the servers purge the web cache. Web cache poisoning attacks are possible if the web server and application have HTTP response-splitting flaws.</li>
				<li><strong class="bold">Secure shell </strong>(<strong class="bold">SSH</strong>)<strong class="bold"> brute-force attack</strong>: Attackers use the SSH protocol to make an encrypted SSH tunnel between two hosts so that they can send unencrypted <a id="_idIndexMarker2065"/>data over an unprotected network. Most of the time, SSH runs on TCP port <strong class="source-inline">22</strong>. Attackers will scan SSH servers using bots. Once the credentials have been discovered, attackers will use this powerful new host as a base station to target internal systems and/or scan for vulnerabilities on auxiliary servers.</li>
				<li><strong class="bold">Server-side request forgery </strong>(<strong class="bold">SSRF</strong>)<strong class="bold"> attacks</strong>: Attackers use SSRF flaws to send crafted requests to internal or backend servers through public web servers. These flaws come from the functions in an application being misused on public <a id="_idIndexMarker2066"/>web servers. Internal servers are usually put in place by firewalls to keep unwanted traffic from getting into the network. SSRF flaws can allow attackers to send crafted requests from public web servers and connect to internal or backend servers directly.</li>
			</ul>
			<p>Now, let's look at some common web server vulnerabilities.</p>
			<h3>Common web server vulnerabilities</h3>
			<p>Web servers may be configured with unnecessary features and services that create potential <a id="_idIndexMarker2067"/>security holes. This could include files containing sensitive information, such as configuration files and scripts containing database names, user IDs, and passwords.</p>
			<p>Some of the most common misconfigurations include the following:</p>
			<ul>
				<li>File and directory permissions that have been set up incorrectly or that allow unauthorized access to sensitive data</li>
				<li>Default usernames and passwords that haven't been updated from their default settings, allowing anyone who knows it to access the system without a password</li>
				<li>Unused services or accounts being enabled, which may have been left by mistake or by previous attackers</li>
				<li>Unnecessary features being enabled, which may have been installed for testing or development purposes and never removed after the site was put into production</li>
				<li>Poorly chosen passwords by administrators, allowing potential attackers to successfully guess administrative credentials, giving them unrestricted access to the web server itself</li>
			</ul>
			<h2 id="_idParaDest-432"><a id="_idTextAnchor446"/>Authorization attacks</h2>
			<p>Here, the attacker finds a legitimate account with limited privileges, then logs in as that user, and gradually <a id="_idIndexMarker2068"/>escalates privileges to access protected resources. Attackers then manipulate the HTTP requests to subvert the application authorization schemes by modifying input fields related to the user ID, username, access group, cost, filenames, file identifiers, and more.</p>
			<h3>HTTP request tampering</h3>
			<p>HTTP request tampering is when <a id="_idIndexMarker2069"/>someone tampers <a id="_idIndexMarker2070"/>with the information in a client request by changing the values within the URL to falsify data or steal user information. This can be used to fool users into providing sensitive information or to spoof entire pages, giving an attacker access to privileges that they would not normally have.</p>
			<p>Most of the time, HTTP <a id="_idIndexMarker2071"/>request tampering is used to change hidden <a id="_idIndexMarker2072"/>values in a URL, such as <strong class="source-inline">HTTP_AUTHORIZATION</strong>, or cookies that have been sent to the server with the request. The most common types of attacks that are dealt with include <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>) or <strong class="bold">man-in-the-middle</strong> (<strong class="bold">MITM</strong>) attacks, in which the attacker is intercepting requests and sending different values in each request. When these are done correctly, the server will assume that the attacker has access to these values (to make things easier for users), when it's just the attacker talking.</p>
			<p>Authorization attacks <a id="_idIndexMarker2073"/>are very easy to prevent by <a id="_idIndexMarker2074"/>using HTTPS and other security measures. HTTPS encrypts the data being transferred, which prevents MITM attacks from intercepting requests to change information. Authentication will always be present when you're using HTTPS, so XSS or cookie injection is nearly impossible with encryption. Authentication can also be used to prevent invalid token manipulation, as tokens are usually encrypted before being sent to the server.</p>
			<p>The most important step to take is verifying the authenticity of all the requests that are sent from a user, which can be achieved by requiring authentication for sensitive pages and checking that all the other requests have valid tokens attached. This will stop any type of HTTP request tampering attacks before they begin.</p>
			<h3>Cookie parameter tampering</h3>
			<p>Cookie parameter tampering is when someone tampers with the information that's sent in a cookie from <a id="_idIndexMarker2075"/>the client to the server by <a id="_idIndexMarker2076"/>changing the values within a single cookie or multiple cookies. This can be used to fool users into providing sensitive data or to steal user information. Most of the time, this attack deals with manipulating session cookies, which are usually encrypted and unique for each user session. In most cases, the attacker is intercepting requests and sending different values in each request, specifically targeting the cookie that was used to access a protected service. </p>
			<p>Burp Suite (<a href="https://portswigger.net">https://portswigger.net</a>) is a great <a id="_idIndexMarker2077"/>tool to use to test your servers and apps for these types of attacks.</p>
			<p>Next, let's look at the potential threats to web applications.</p>
			<h2 id="_idParaDest-433"><a id="_idTextAnchor447"/>Web application attacks</h2>
			<p>Even if a web server has been set up securely or is protected by network security measures such <a id="_idIndexMarker2078"/>as firewalls, a poorly written web application or the web server itself could give an attacker a way into the web server's security. An attacker can use many different types of attacks on web applications that aren't secure to get into the web server's security.</p>
			<h3>SQL injection attacks</h3>
			<p>SQL injection attacks occur when a developer does not properly validate their user input before <a id="_idIndexMarker2079"/>passing it into a database. An attacker <a id="_idIndexMarker2080"/>can inject SQL commands into the input and gain access to sensitive information on the server, such as usernames and passwords.</p>
			<p>To avoid this flaw, developers should always escape their user input with special escaping methods so that the input cannot affect the query:</p>
			<pre class="source-code">SELECT * FROM users WHERE UserID=2302 or 1=1</pre>
			<p>The <strong class="source-inline">or 1=1</strong> expression returns a value of <strong class="source-inline">TRUE</strong>, which can be used to get all the user IDs from the database. An attacker finds a flaw in a web application and uses it to get around normal security measures and get direct access to valuable data. When hackers try to do SQL injection attacks from things such as the web browser's address bar or form fields, queries, or searches, the hacker can get information that's not meant for them. Various commands can be used to modify data, delete massive amounts of data, or even create accounts within a web application.</p>
			<p>To avoid SQL injection attacks, it is necessary to securely store web application data. The web application data should have correct character types to avoid SQL injection attacks. Also, SQL injection attacks can be prevented by using one of the most basic secure programming techniques – parameterized queries. However, they are still vulnerable to SQL injection attacks because folks don't use prepared statements. Prepared statements are the most secure way to prevent SQL injection attacks.</p>
			<p>A prepared statement is an approach that helps prevent SQL injection attacks because it makes the web application explicitly indicate where user input goes in the statement. Many frameworks have adopted this method of <a id="_idIndexMarker2081"/>preventing SQL injections, so <a id="_idIndexMarker2082"/>developers don't have to worry about it.</p>
			<p>However, there are still some web applications and developers that don't use prepared statements and can be vulnerable to SQL injection attacks, so be aware.</p>
			<h3>Other web application attacks</h3>
			<p>Let's look at some other types of web application attacks you can use:</p>
			<ul>
				<li><strong class="bold">DNS rebinding attacks</strong>: This is when the hacker tries to fool the web browser's <a id="_idIndexMarker2083"/>DNS system into looking up an IP address that is not correct. This forces your browser to bypass the firewall and gives the hacker access.</li>
				<li><strong class="bold">Cookie snooping</strong>: These attacks occur when the hacker steals your authentication <a id="_idIndexMarker2084"/>to a website by sniffing cookies. Cookies are often sent back and forth during HTTP requests, so they contain lots of important information about what someone has done on a website. If any of that information is sensitive (such as the session ID or user identification), then it can be used to log in to that website remotely. </li>
				<li><strong class="bold">Cookie tampering</strong>: In this attack, the attacker manipulates cookies as they travel to a browser <a id="_idIndexMarker2085"/>from a web server. In other words, an attacker can change the cookie's values before it reaches the user's browser. If the altered cookie has any unauthorized privileges associated with it, then the attacker gains those privileges when performing malicious tasks.</li>
				<li><strong class="bold">Obfuscation application</strong>: Attackers are usually very careful and ensure they hide their attacks <a id="_idIndexMarker2086"/>and stay out of the way. <strong class="bold">Intrusion detection systems</strong> (<strong class="bold">IDSs</strong>) keep an eye out for signs of well-known attacks, which <a id="_idIndexMarker2087"/>forces attackers to come up with <a id="_idIndexMarker2088"/>new ways to stay unnoticed. This type of attack involves the attacker encrypting the attack to look like something else.</li>
				<li><strong class="bold">Parameter/form tampering</strong>: This is a type of malicious intrusion in which an attacker exploits <a id="_idIndexMarker2089"/>web applications <a id="_idIndexMarker2090"/>that include parameters to authenticate users. This includes form fields for user login names and passwords.</li>
				<li><strong class="bold">Cross-site scripting</strong> (<strong class="bold">XSS</strong>): This is a security flaw that's present in some web applications that allows attackers to gain unauthorized access to the victim's system. Attackers <a id="_idIndexMarker2091"/>can exploit this vulnerability by injecting <a id="_idIndexMarker2092"/>malicious scripts into HTML forms or by enticing the vulnerable site's visitors to click on an attacker-supplied link.</li>
				<li><strong class="bold">Session hijacking</strong>: This is a type of attack in which an attacker steals another user's session <a id="_idIndexMarker2093"/>ID and takes over their authenticated session. By taking control of the victim's browsing session, the attackers can gain access to the victim's account information without knowing their login credentials.</li>
				<li><strong class="bold">Unvalidated input attacks</strong>: These are created so that an attacker can submit data to the frontend <a id="_idIndexMarker2094"/>of a web application. The backend database can't handle this information, leading to unintended behavior within the application.</li>
				<li><strong class="bold">Directory traversal/command execution</strong>: This is another web server attack where <a id="_idIndexMarker2095"/>attackers exploit web servers that can't properly sanitize input. If the attack is successful, it allows attackers to read sensitive files, list directory contents, write files, and run arbitrary commands on the underlying system.</li>
				<li><strong class="bold">Denial of service attacks</strong>: This is an attack in which a malicious party tries to make a <a id="_idIndexMarker2096"/>machine or network resource unavailable for <a id="_idIndexMarker2097"/>users. For example, they could try to send too many requests to a service, such as a web server. Attackers could also try to send malicious packets that will <a id="_idIndexMarker2098"/>tie up resources <a id="_idIndexMarker2099"/>or cause the system or application to fail.</li>
				<li><strong class="bold">SQL injection</strong>: This is <a id="_idIndexMarker2100"/>just like what we saw for web server <a id="_idIndexMarker2101"/>attacks.</li>
				<li><strong class="bold">XSS attacks</strong>: Here, the attacker tricks someone into viewing a page containing a malicious script. When <a id="_idIndexMarker2102"/>the user accesses <a id="_idIndexMarker2103"/>this URL, the browser renders the page containing the malicious scripts, which could send requests to other applications or embed malicious code in pages.</li>
				<li><strong class="bold">Buffer overflow attacks</strong>: This attack occurs when an application tries to put more <a id="_idIndexMarker2104"/>data into a buffer than it can hold. This causes the excess data to spill out, corrupting other data in the process. Buffer overflows are frequently exploited by attackers.</li>
				<li><strong class="bold">Source code disclosure</strong>: This attack occurs when an attacker gains access to the source code <a id="_idIndexMarker2105"/>or other information that could help them exploit vulnerabilities in the system. This threat occurs during product development, maintenance, and testing.</li>
				<li><strong class="bold">Cross-site request forgery attacks</strong>: This attack forces an end user to execute unwanted actions on a web application that they're currently authenticated <a id="_idIndexMarker2106"/> in. The most common example of this is forcing users to make purchases or transfer funds.</li>
				<li><strong class="bold">Command injection attacks</strong>: This is an attack in which an attacker injects unauthorized <a id="_idIndexMarker2107"/>commands into a command line that will run under the privileges of the user running them. If successful, attackers could gain access to operating system functions or download sensitive information.</li>
				<li><strong class="bold">Credential stuffing attacks</strong>: Credential stuffing is the process of trying stolen credentials (usernames/passwords) on multiple websites. Most credential stuffing attacks <a id="_idIndexMarker2108"/>are unsuccessful, but it can be worthwhile to monitor for this type of activity as users often use the same password on different sites. This could allow an attacker to gain access to other systems that were not part of the original <a id="_idTextAnchor448"/>attack.</li>
			</ul>
			<p>Now, let's learn more about the vulnerabilities of web APIs, web shells, and webhooks.</p>
			<h1 id="_idParaDest-434"><a id="_idTextAnchor449"/>The vulnerabilities of web APIs, web shells, and webhooks</h1>
			<p>It is important to understand and be familiar with the vulnerabilities of web APIs, web shells, and webhooks. Recognizing best practices will help you provide greater security.</p>
			<h2 id="_idParaDest-435"><a id="_idTextAnchor450"/>Web APIs</h2>
			<p>One of the most important parts of a website is its web <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>). The API takes data from a server and makes it compatible with another server. This way, other programs can read the information that would otherwise <a id="_idIndexMarker2109"/>be difficult to access. With the help of an API, computer applications can perform actions on websites, such as posting comments. However, the API must be secure and not vulnerable to security concerns such as XSS.</p>
			<p>Some of the most popular APIs are as follows:</p>
			<ul>
				<li><strong class="bold">SOAP API</strong>: This is a <a id="_idIndexMarker2110"/>standard that's used by Microsoft and uses the <strong class="bold">Web Services Description Language</strong> (<strong class="bold">WSDL</strong>). WSDL is an XML language that contains information <a id="_idIndexMarker2111"/>about how to communicate with a web server.</li>
				<li><strong class="bold">REST API</strong>: REST stands <a id="_idIndexMarker2112"/>for <strong class="bold">Representational State Transfer</strong>. This type of API is more of <a id="_idIndexMarker2113"/>a software architectural style rather than an actual standard. It doesn't include WSDL but does use HTTP methods (<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, and so on) to communicate with web servers.</li>
				<li><strong class="bold">XML-RPC</strong>: This is like the SOAP API in that XML-RPC is an interface rather than a specification. It is <a id="_idIndexMarker2114"/>created <a id="_idIndexMarker2115"/>using HTTP requests with XML supplied as the data format.</li>
				<li><strong class="bold">JSON-PRC</strong>: This is a <a id="_idIndexMarker2116"/>modern web <a id="_idIndexMarker2117"/>API standard that uses <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) for its <a id="_idIndexMarker2118"/>data format and HTTP requests for communication.</li>
			</ul>
			<p>Recent years have seen a huge rise in the use of web-based APIs to support different types of devices, such as mobile devices and loT devices. APIs are often used by these devices to communicate with backend web servers. To make these web-based APIs easier for people to use, developers often cut corners on security. This makes online web services more vulnerable to attacks. Attackers use a variety of methods to find and exploit flaws in these APIs. The attackers who want to get into an API have to figure out what API technologies are used, what security standards are used, and where they can attack.</p>
			<p>Now, let's discuss some API security best practices.</p>
			<h3>Best practices for API security</h3>
			<p>You should utilize the same strategies that work for web applications. In addition, you should set <a id="_idIndexMarker2119"/>up a rate-limiting system to ensure an attacker can't make requests more frequently than legitimate users. You may also want to monitor your logs for requests from bots and scrapers as this could indicate attempts at gathering additional information on your application or website.</p>
			<p>Here are some key points to help you out:</p>
			<ul>
				<li>Use HTTPS for encryption.</li>
				<li>Use IP-based whitelists to gain access to APIs.</li>
				<li>Monitor and review logs.</li>
				<li>Parameterize statements in SQL queries.</li>
				<li>Use quotas and throttling against your API.</li>
				<li>Limit the request body and length of your API.</li>
			</ul>
			<p>It's also important <a id="_idIndexMarker2120"/>to understand security standards. Let's discuss some of these standards next.</p>
			<h3>Web API security standards</h3>
			<p>APIs, like any other software, have security flaws. They adhere to standards such as OAuth and SSL but include numerous vulnerabilities that attackers can use. If any of these standards <a id="_idIndexMarker2121"/>are configured incorrectly, hackers can exploit them. Often, the developers of web applications don't think about the consequences of using security flaws in their API. For example, they'll use session IDs to identify users and allow access to information on their website or server without realizing how easy it is for hackers to reroute fraudulent traffic through an authorized user's connection. Administrators must check for security standards such as SSL when they're testing their web applications for vulnerabilities. They should also review XSS and SQL injection attacks to prevent future attacks on that API.</p>
			<p>Now, let's talk more about web shells and webhooks.</p>
			<h2 id="_idParaDest-436"><a id="_idTextAnchor451"/>Web shells</h2>
			<p>A web shell is a backdoor on a website or server that allows attackers access via HTTP/HTTPS. It can <a id="_idIndexMarker2122"/>allow an attacker to upload and download files, execute system commands, modify server settings, view source code, and do other things. It's typically used to make the website or server more secure or easier to use by the administrators of that website or server. These types of shells are usually uploaded through vulnerabilities in the web application.</p>
			<h3>Preventing the installation of a web shell</h3>
			<p>An attacker can send a series of requests to install a web shell on the server. The payload for this <a id="_idIndexMarker2123"/>attack would look something like <strong class="source-inline">http://kali:1337/index.php?install_shell=1&amp;language=../../../../../etc/passwd%00</strong>.</p>
			<p>To prevent this, make sure that the application has a strong input validation layer that is aware of the different types of above-the-fold input payloads. Note that this only prevents the installation <a id="_idIndexMarker2124"/>of a web shell – it does not prevent an attacker from viewing any file on the system if they have been granted access to do so by another vulnerability.</p>
			<p>The following is an example of preventing the installation of a web shell:</p>
			<pre class="source-code">if (preg_match('/../../../../etc/passwd/', $_GET['install_shell']) ) {</pre>
			<pre class="source-code">    // don't allow shell to be installed for this user }.</pre>
			<h2 id="_idParaDest-437"><a id="_idTextAnchor452"/>Webhooks</h2>
			<p>Webhooks provide a communication channel between two web APIs. This allows one API to receive <a id="_idIndexMarker2125"/>notifications from another, so information can be exchanged without a direct connection. Webhooks are a little harder to detect because the source of the data isn't always clear unless it's a POST request or uses a similar type of identifier. These types of requests may bring attention to your web application if you're not expecting them or if you don't know what to do with them.</p>
			<p>Many developers do not understand that webhooks require security, just like any other API endpoint: it is easy to make mistakes by doing what appears to be the right thing for a specific case, which can leave systems exposed to various attacks. These include MITM, replay, and arbitrary code execution attacks. The risk of attacks is higher when the webhooks are exposed to third parties, such as mobile applications or other outside services. It may be possible to blacklist certain IP addresses that appear to be performing these types of attacks, and implementing CAPTCHAs on your login pages will also help.</p>
			<h1 id="_idParaDest-438"><a id="_idTextAnchor453"/>Detecting web server hacking attempts</h1>
			<p>There are several <a id="_idIndexMarker2126"/>ways you can find out if your web server has been compromised.</p>
			<p>The first way is to monitor the logs from the web server. A good practice is to have more than one log file, but it's even better if they're monitored and sent to a separate system so that if something happens on the current web server, the logs will still be available. </p>
			<p>Another way to <a id="_idIndexMarker2127"/>do this is to audit ports on the web server. Make sure that all the open ports are accounted for and do not return any strange responses.</p>
			<p>You should also look at traffic between the web server and users. If you see abnormally large requests or file downloads, this could be an indication of hacking attempts. </p>
			<h3>Some other ways to protect your web servers/apps</h3>
			<p>The <strong class="source-inline">machine.config</strong> file specifies the resources that are available on the web server, including <a id="_idIndexMarker2128"/>access to files, directories, and registry keys. Restrict <a id="_idIndexMarker2129"/>access to these resources to prevent any kind of false file uploads and other dangerous requests.</p>
			<p>You should also make sure all your other applications are up to date to ensure they're patched against any vulnerabilities that may have been found in them.</p>
			<p>Next, secure any certificates that are used for your keys. This is the easiest way to protect your keys. If you don't need them, remove them. If possible, restrict the permission of user accounts on the server. This will keep an attacker from gaining local administrator access.</p>
			<p>Also, look into implementing secure coding practices. If your web pages aren't built securely, then hackers will be able to exploit that weakness and gain access to the system.</p>
			<p>Finally, install security patches for your operating system and other applications as soon as they become available. The longer you wait, the more opportunities your system will have to be compromised. Patch management is an important part of secure computing.</p>
			<p>Now, let's look at web application security testing.</p>
			<h2 id="_idParaDest-439"><a id="_idTextAnchor454"/>Web application security testing</h2>
			<p>Web application security testing is done to assess the performance and security of the apps you have <a id="_idIndexMarker2130"/>in place. These types of tests should be scheduled regularly to ensure the app can handle a variety of different attacks.</p>
			<p>Here are some tips on <a id="_idIndexMarker2131"/>how to get started with your web application security testing:</p>
			<ul>
				<li>Identify what you hope to learn by conducting the tests.</li>
				<li>Identify which performance and security issues are the most important for your project.</li>
				<li>Create an attack plan before you start the testing process.</li>
				<li>Perform the tests you have planned out.</li>
				<li>Review the results of your testing and develop a plan for fixing any performance or security issues.</li>
				<li>Perform source code reviews.</li>
				<li>Evaluate the encoding schemes.</li>
			</ul>
			<p>For more details on this topic, check out OWASP's <em class="italic">Testing Guide</em> at <a href="https://owasp.org/www-project-web-security-testing-guide">https://owasp.org/www-project-web-security-testing-guide</a>.</p>
			<p>At this point, I should mention that one of the best tools for testing the security of your web servers and their apps is Metasploit. Metasploit is an open source penetration testing software that allows users to find vulnerabilities in systems and networks and creates exploits for those vulnerabilities. This tool is a framework, which means that it is a platform that allows users to easily create custom tools and uses modules for different exploits.</p>
			<p>Various things make Metasploit popular among the hacking community: it is free and has an immense library of user-generated scripts, modules, and modularization. You can also create modules.</p>
			<p>Although the CEH exam doesn't cover a lot of information about the modules and plugins for Metasploit, I highly suggest that you learn about this awesome tool for your career. My recommendation would be <em class="italic">Metasploit 5.0 for Beginners – Second Edition</em>, from <em class="italic">Packt Publishing</em> (<a href="https://www.packtpub.com/product/metasploit-5-0-for-beginners-second-edition/9781838982669">https://www.packtpub.com/product/metasploit-5-0-for-beginners-second-edition/9781838982669</a>).</p>
			<p>There are so many attack tricks and tips you should be aware of for the real world. A whole book could <a id="_idIndexMarker2132"/>be written about web server/application hacking. However, our goal here was to cover the information you'll need to know for the exam.</p>
			<h1 id="_idParaDest-440"><a id="_idTextAnchor455"/>Summary</h1>
			<p>In this chapter, we discussed ways you can hack web servers and web apps. This allows you to discover existing and potential vulnerabilities. Then, we discussed why web servers and web apps create security issues. We talked about some of the different types of architectures you may experience and looked at some of the threats the wireless world presents us with. After that, we covered some attacks you can use for web application attacks. We covered some of the specifics and vulnerabilities of web APIs, web shells, and webhooks. Finally, we discussed some of the ways we can detect web server hacking attempts and prevent or limit what attackers can do.</p>
			<p>In the next chapter, we'll dive into hacking the <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) (or, as I like to say, Internet of THREATS) and <strong class="bold">Operational Technology</strong> (<strong class="bold">OT</strong>).</p>
			<h1 id="_idParaDest-441"><a id="_idTextAnchor456"/>Questions</h1>
			<p>As we conclude, here is a list of questions for you to test your knowledge regarding this chapter's material. You will find the answers in the <em class="italic">Assessments</em> section of the <em class="italic">Appendix</em>:</p>
			<ol>
				<li value="1">A web application is best described by which of the following?<ol><li>Code designed to be run client-side </li><li>Database SQL code</li><li>Web service targeting</li><li>Code designed to be run server-side</li></ol></li>
				<li>What is used to store session information? <ol><li>A cookie</li><li>A directory</li><li>A snoop</li><li>A file</li></ol></li>
				<li>The _________ scripting language is used on the client side.<ol><li>PHP</li><li>JavaScript</li><li>ASP.NET</li><li>ASP</li></ol></li>
				<li>Which of the following is used to access content that is not located in a website's root directory?<ol><li>Directory traversal</li><li>Brute force</li><li>SQL injection</li><li>Port scanning</li></ol></li>
			</ol>
		</div>
	</div></body></html>