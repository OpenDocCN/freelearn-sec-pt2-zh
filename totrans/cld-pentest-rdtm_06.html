<html><head></head><body>
		<div id="_idContainer026">
			<h1 id="_idParaDest-102" class="chapter-number"><a id="_idTextAnchor101"/>6</h1>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Pentesting Containerized Applications in AWS</h1>
			<p>One of the most common use cases for cloud networks is the deployment of containerized applications. Over the course of your career as a cloud pentester, the likelihood that you’ll need to test in containerized environments is <span class="No-Break">very high.</span></p>
			<p>The popular containerization platforms, Docker and Kubernetes, operate the same way within their containerization systems regardless of whether they’re deployed in AWS, GCP, Azure, or any other cloud platform. However, the way AWS, GCP, and Azure interface with Docker and Kubernetes is a little bit different in <span class="No-Break">each instance.</span></p>
			<p>Think of it this way. A slice of buttered toast is the same slice of buttered toast whether it’s served on a ceramic dish, an aluminum dish, or a paper dish. The toast will taste the same, and you will eat it the same way regardless of what kind of dish it’s served on. But after you eat the toast, the way you clean or dispose of the dish will <span class="No-Break">be different.</span></p>
			<p>Hopefully, that makes sense! Well, it will make more sense once you’ve read <span class="No-Break">this chapter.</span></p>
			<p>In this chapter, I will explain <span class="No-Break">the following:</span></p>
			<ul>
				<li>How <span class="No-Break">containerization works</span></li>
				<li>How Docker works <span class="No-Break">in AWS</span></li>
				<li>How Kubernetes works <span class="No-Break">in AWS</span></li>
				<li>Docker and Kubernetes pentesting techniques <span class="No-Break">in AWS</span></li>
			</ul>
			<p>Let’s <span class="No-Break">get started!</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Technical requirements</h1>
			<p>The wonderful thing about using AWS, whether for containerization or anything else, is that we get to use the computing power of Amazon’s infrastructure. That means you don’t need a really high-end workstation to do any of the exercises in this chapter. All you need is <span class="No-Break">the following:</span></p>
			<ul>
				<li>A modern desktop or laptop PC running Windows, macOS, or a common Linux distribution such as Ubuntu or Debian. A MacBook or a Windows 11 OEM PC with at least 4 GB of RAM <span class="No-Break">works great.</span></li>
				<li>A well-supported web browser such as Safari 15 or later, Microsoft Edge 83 or later, Mozilla Firefox 105 or later, or Google Chrome 115 <span class="No-Break">or later.</span></li>
				<li>A reliable <span class="No-Break">internet connection.</span></li>
			</ul>
			<p>Check out the following video to view the Code in <span class="No-Break">Action: </span><a href="https://bit.ly/46VJSp3"><span class="No-Break">https://bit.ly/46VJSp3</span></a></p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>How containerization works</h1>
			<p>First, there were <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>). VMs run inside a host operating<a id="_idIndexMarker446"/> system, and the host operating system<a id="_idIndexMarker447"/> is what runs directly on computer hardware. As far as the host operating system is concerned, the VM is simply an application it’s running that has been allocated a certain amount of memory (RAM) and a certain amount of disk space in the form of a virtual disk. VMware and Oracle VirtualBox both make virtualization clients that you can easily run and install on a Windows, Mac, or Linux PC. With those virtualization clients, you can make a VM that runs most versions of Windows, macOS, Linux, <span class="No-Break">or Unix.</span></p>
			<p>There is a plethora of use cases for VMs. My background is in cybersecurity, so the use case I’m most familiar with is malware testing. I can safely execute malware in a VM without harming the host operating system or its hardware. That’s because the VM assures that the virtual operating system is “sandboxed” from the host operating system. In a worst-case scenario where the malware in my virtual operating system makes my virtual operating system impossible to boot properly, I can go into my host operating system to uninstall the VM and delete its virtual disk. Then, I can make a new VM and start all <span class="No-Break">over again.</span></p>
			<p>An analogy I often hear about host computers and VMs is “a computer and its pet computer.” But basically, the host operating system just treats the VM as any other sort <span class="No-Break">of application.</span></p>
			<p>Virtualization has been possible in computing for a lot longer than people often think. The earliest cases of computer virtualization were found in the late 1960s and early 1970s on IBM mainframe computers. Timesharing systems were common on mainframes and minicomputers of the era because people didn’t own their own computers until PCs <span class="No-Break">were invented.</span></p>
			<p>Until the advent of PCs, all computers were shared with multiple people. IBM invented virtualization techniques so that multiple users in a timesharing system could have a layer of abstraction from the CPU, memory, and disk storage. Each user could have their own virtualized computer that could allocate the host computer’s real hardware resources without affecting what the other users were doing on the same <span class="No-Break">host computer.</span></p>
			<p>As with everything else in computer technology, over the past few decades, virtualization has gotten better and better. <em class="italic">Containerization is a similar concept to VMs, but it’s not exactly the same thing.</em> However, progress in the development of virtualization technology is what made the invention of <span class="No-Break">containerization possible.</span></p>
			<p>In a nutshell, containerization is similar to VMs, <em class="italic">but much more lightweight</em>. If a VM is a house made of bricks, wood, stone, or concrete, a container is a tent that can quickly be erected and taken down <span class="No-Break">as needed.</span></p>
			<p>VMs can be created and removed as needed. But installing and removing a VM isn’t an instantaneous process. To install a macOS VM on my Windows PC with Oracle VirtualBox, I still need to go through macOS’s installation process for each new macOS VM. That takes at least multiple minutes <span class="No-Break">each time.</span></p>
			<p>Docker and Kubernetes<a id="_idIndexMarker448"/> are both containerization orchestration platforms. Docker and Kubernetes have their own systems for allocating hardware resources, load balancing, and process isolation. Setting up a Docker or Kubernetes containerization orchestration system for the first time does take several minutes for installation and configuration. However, once the Docker or Kubernetes containerization orchestration system is ready, containers can be deployed and removed very quickly. And if your AWS services give you enough disk space and network bandwidth, you could possibly run hundreds of containers under the same orchestration platform at any <span class="No-Break">given time.</span></p>
			<p>Your cloud application will immediately benefit from the scalability and efficiency containerization gives it. In typical cloud containerization deployments, containers are deployed and removed constantly according to an application’s needs at any given time. Sometimes, an individual container may only exist for a few days <span class="No-Break">or less.</span></p>
			<p>Docker was the first containerization platform to become widely popular. Docker debuted in 2013, and it made containerization easier than ever for developers, enterprises, and hobbyists alike. The Kubernetes team was inspired by Docker, and the first version of Kubernetes was released <span class="No-Break">in 2014.</span></p>
			<p>VMs can run on PCs, server machines, and in cloud environments alike. But although applications such as Docker Desktop make it possible to test multi-container applications locally, containerization was really made for <span class="No-Break">the cloud.</span></p>
			<p>Cloud platforms<a id="_idIndexMarker449"/> such as AWS, Azure, and GCP provide organizations with hardware and networking scalability because Amazon, Microsoft, and Google operate lots of massive data centers on every part of the globe (except for Antarctica) that contain millions of server machines and really high-capacity networking infrastructure. If an organization needs the capacity of a dozen server machines one day and several hundred server machines the next, Amazon, Microsoft, and Google can provide it almost instantly for the right amount of money. No hardware resources are wasted, and the allocation of hardware resources can be responsive <span class="No-Break">and dynamic.</span></p>
			<p>Thus, containerization is designed to work in the context of cloud environments. The cloud platform allocates hardware resources at the macro level, and the containerization platform allocates hardware resources at the <span class="No-Break">micro level.</span></p>
			<p>Developers really like containerization because they can design their software to run inside a particular container configuration without having to worry about <span class="No-Break">hardware compatibility.</span></p>
			<p>A container bundles application code with simply the dependencies, libraries, and configuration files it needs to run, whereas if they developed their code for a VM or a host computer, they’d have to worry about the operating system. And if their code was designed to run directly on a host computer, they’d have to know its CPU and hardware specifications. When done properly, containerization saves developers a lot of frustration. So, their time and energy can be focused on making the application better rather than having to waste time troubleshooting hardware and operating <span class="No-Break">system problems.</span></p>
			<p>It’s possible to use AWS without containerization. In the previous chapter, I installed a Linux operating system directly in AWS in order to produce that chapter’s <em class="italic">Code In Action</em> videos. When I used Prowler, it was vulnerability scanning a very simple Linux-in-AWS setup. If an AWS customer just needs one or a few servers that they’ll maintain on a constant basis, simply using an operating system directly in AWS can fulfill <span class="No-Break">their needs.</span></p>
			<p>However, many AWS customers<a id="_idIndexMarker450"/> need to deploy applications that could have thousands—or sometimes even hundreds of thousands—of users at any given time. In those situations, containerization is by far the most practical choice. Cloud platforms help make containerization possible. So, as a pentester, it’s important that you understand how to pentest Docker and Kubernetes <span class="No-Break">deployments effectively.</span></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>How Docker works in AWS</h1>
			<p>The layers in a Docker<a id="_idIndexMarker451"/> containerization system look like this, from the bottom<a id="_idIndexMarker452"/> to <span class="No-Break">the top:</span></p>
			<ul>
				<li>AWS, Azure, or GCP is the <span class="No-Break">cloud platform.</span></li>
				<li>The cloud platform runs a service, such as <strong class="bold">Amazon Elastic Container Service</strong> (<strong class="bold">Amazon ECS</strong>), that supports the Docker host. The Docker host is a server, and the administrator <a id="_idIndexMarker453"/>administrates it through their Docker client on their <span class="No-Break">local computer.</span></li>
				<li>The Docker host runs the Docker daemon, which manages Docker images. The daemon can also download images from the Docker Registry. The registry can be the remote public Docker Hub or the organization’s own private registry. The daemon also handles <span class="No-Break">API requests.</span></li>
				<li>Docker images are instructions for creating Docker containers. Containers are generated from <span class="No-Break">the images.</span></li>
			</ul>
			<p>Here’s an example of what a Docker architecture <span class="No-Break">looks like:</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B18672_06_01.jpg" alt="Figure 6.1 – Docker architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Docker architecture</p>
			<p>Docker deployments in AWS use <strong class="bold">Amazon Elastic Compute Cloud</strong> (<strong class="bold">Amazon EC2</strong>) because that’s the main<a id="_idIndexMarker454"/> <span class="No-Break">compute platform.</span></p>
			<p>Amazon ECS is the primary service<a id="_idIndexMarker455"/> to run Docker in AWS, regardless of the size and scale<a id="_idIndexMarker456"/> of your Docker deployment. Amazon ECS is the service you’ll be working with directly. It handles the Amazon EC2 work <span class="No-Break">for you.</span></p>
			<p>There are two common ways to install Docker <span class="No-Break">in AWS:</span></p>
			<ul>
				<li>If you prefer<a id="_idIndexMarker457"/> to install Docker with the help of a <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>), you can do so with AWS’s <span class="No-Break">web application.</span></li>
				<li>Alternatively, if you prefer to work with a <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) as much as possible or if you’d like<a id="_idIndexMarker458"/> to use Docker Desktop to test your containerization system locally in addition to deploying it on AWS, you can use the Docker Compose CLI to install Docker in AWS. You may need to install the Docker Compose <a id="_idIndexMarker459"/>plugin if it’s not already included in your version of Docker Desktop. Read the instructions in <em class="italic">Docker Docs</em> <span class="No-Break">at </span><a href="https://docs.docker.com/compose/install/"><span class="No-Break">https://docs.docker.com/compose/install/</span></a><span class="No-Break">.</span></li>
			</ul>
			<p>Whichever way you choose to install Docker, you can still use your choice of compatible GUI and CLI applications<a id="_idIndexMarker460"/> to use, administrate, and configure your <span class="No-Break">Docker</span><span class="No-Break"><a id="_idIndexMarker461"/></span><span class="No-Break"> deployment.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Installing a Docker cluster in AWS with Amazon ECS</h2>
			<p>First, I’ll walk you through installing<a id="_idIndexMarker462"/> a Docker cluster<a id="_idIndexMarker463"/> through AWS’s web <span class="No-Break">application GUI:</span></p>
			<ol>
				<li>Step one is to launch the Amazon ECS first-run wizard. Log in to your AWS account through your web browser, and the wizard will make launching Amazon ECS and deploying <span class="No-Break">Docker easy.</span></li>
				<li>In AWS’s web interface, I like to navigate between different AWS services and applications by searching for them by name with the search bar on the top AWS application menu. Search for <strong class="source-inline">Amazon ECS</strong>, click on <strong class="bold">Elastic Container Service</strong>, and you’ll get to the correct <span class="No-Break">screen quickly.</span></li>
				<li>On the right side, there’s a white box that says <strong class="bold">Deploy your containerized applications</strong>. Click on the orange <strong class="bold">Get </strong><span class="No-Break"><strong class="bold">started</strong></span><span class="No-Break"> button.</span></li>
				<li>You’ll be presented with a page that says <strong class="bold">Clusters</strong>. Click on the orange button in the top-right corner that says <span class="No-Break"><strong class="bold">Create cluster</strong></span><span class="No-Break">.</span></li>
				<li>Under <strong class="bold">Cluster configuration</strong>, give your cluster a name. I chose <strong class="source-inline">AWS-Docker-Test</strong>, but you can choose any name you’d like <span class="No-Break">that’s valid.</span></li>
				<li>Under <strong class="bold">Networking</strong>, leave the default <strong class="bold">virtual private cloud</strong> (<strong class="bold">VPC</strong>), subnets, and namespace<a id="_idIndexMarker464"/> as <span class="No-Break">they are.</span></li>
				<li>Under <strong class="bold">Infrastructure</strong>, leave the default <strong class="bold">AWS Fargate (serverless)</strong> setting as it is. That’s the easiest<a id="_idIndexMarker465"/> way to have Amazon ECS<a id="_idIndexMarker466"/> allocate the hardware resources for your <span class="No-Break">Docker deployment.</span></li>
				<li>Likewise, leave the <strong class="bold">Monitoring</strong> and <strong class="bold">Tags</strong> sections as they are. In the lower-right corner, click on the orange <span class="No-Break"><strong class="bold">Create</strong></span><span class="No-Break"> button.</span><p class="list-inset">A blue bar will appear near the top that says cluster creation is in process. It could take a few minutes. If all goes well, the blue bar will become green and say that the cluster was created successfully. If not, repeat the steps I walked you through and try again. When I tested the cluster creation process myself, my first attempt returned a red bar that said the creation process failed. But on my second attempt, I <span class="No-Break">was successful.</span></p></li>
				<li>Now that your cluster was created successfully, you can see the name of your new cluster in the list. Click on the name of <span class="No-Break">your cluster.</span></li>
				<li>You’ll be taken to a new page with the name of your cluster (<strong class="source-inline">AWS-Docker-Test</strong>, in my case) at the top. The first section underneath says <strong class="bold">Cluster overview</strong>, and the next section has six tabs: <strong class="bold">Services</strong>, <strong class="bold">Tasks</strong>, <strong class="bold">Infrastructure</strong>, <strong class="bold">Metrics</strong>, <strong class="bold">Scheduled tasks</strong>, and <strong class="bold">Tags</strong>. Under the <strong class="bold">Services</strong> tab, click on the orange <strong class="bold">Create</strong> button in the <span class="No-Break">upper-right corner.</span></li>
				<li>On the next page, leave all the default settings in the <strong class="bold">Environment</strong> section. In the <strong class="bold">Deployment configuration</strong> section, leave <strong class="bold">Service</strong> as the application type. Under that, you’ll see a <strong class="bold">Task definition</strong> area where it says <strong class="bold">Select an existing task definition</strong>. To create a new task definition, go to <strong class="bold">Task definitions</strong>, and click on <strong class="bold">Go to </strong><span class="No-Break"><strong class="bold">Task definitions</strong></span><span class="No-Break">.</span></li>
				<li>A new page will load<a id="_idIndexMarker467"/> in a new tab in your web<a id="_idIndexMarker468"/> browser. On the <strong class="bold">Task definitions</strong> page, click on the orange <strong class="bold">Create new task definition</strong> button in the upper-right corner. Under <strong class="bold">Configure task definition and containers</strong>, give your task definition family a name. I chose <strong class="source-inline">Docker-Test-Task-Definition</strong> because I’m so imaginative. But you can create whatever name <span class="No-Break">you’d like.</span></li>
				<li>Under <strong class="bold">Container – 1</strong>, name your container (I chose <strong class="source-inline">Docker-Container-Test</strong>). You will also need to enter an image URI (go to <a href="https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/docker-custom-images-tag.html">https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/docker-custom-images-tag.html</a> in the AWS documentation to learn<a id="_idIndexMarker469"/> how to select a base image URI if you need help). In my case, I’m using Amazon’s <strong class="source-inline">us-east-1</strong> data center. So, my image URI is <strong class="source-inline">711395599931.dkr.ecr.us-east-1.amazonaws.com/spark/emr-6.10.0:latest</strong>. Leave all the other default settings as they are. Click on the orange <strong class="bold">Create</strong> button in the <span class="No-Break">lower-right corner.</span></li>
				<li>Under <strong class="bold">Family</strong>, enter your new task definition name (mine is <strong class="source-inline">Docker-Test-Task-Definition</strong>). Leave <strong class="bold">Revision</strong> as is. Create a new name under <strong class="bold">Service name</strong>. I chose <strong class="source-inline">Docker-Test-Service</strong>. Leave all the other default settings as they are. Click on the orange <strong class="bold">Create</strong> button in the <span class="No-Break">lower-right corner.</span></li>
			</ol>
			<p>The deployment<a id="_idIndexMarker470"/> of your new service may take a few minutes, as indicated<a id="_idIndexMarker471"/> in the blue notification at the top of your screen. All services deployed the way I showed you with Amazon ECS use Docker by default. So, you’re making a new <span class="No-Break">Docker instance.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>Deploying Docker with Docker Desktop</h2>
			<p>The other main way to deploy Docker<a id="_idIndexMarker472"/> in Amazon ECS is to use Docker Desktop. If that’s the way you’d prefer, you’ll first need to install Docker Desktop on your local computer. Docker Desktop is an application that’s used to run Docker CLI commands. To install it, follow the <span class="No-Break">next steps:</span></p>
			<ol>
				<li>Visit <a href="https://docs.docker.com/desktop/install/mac-install/">https://docs.docker.com/desktop/install/mac-install/</a> to install it on Mac, or visit <a href="https://docs.docker.com/desktop/install/windows-install/">https://docs.docker.com/desktop/install/windows-install/</a> to install it on Windows. You may<a id="_idIndexMarker473"/> also need to install the Docker Compose plugin in Docker Desktop if it’s not already included. There are instructions in <em class="italic">Docker Docs</em> (<a href="https://docs.docker.com/compose/install/">https://docs.docker.com/compose/install/</a>). If your local computer uses a Linux operating system, you’ll need to install<a id="_idIndexMarker474"/> the Docker Compose CLI for Linux <span class="No-Break">here: </span><a href="https://docs.docker.com/cloud/ecs-integration/#install-the-docker-compose-cli-on-linux"><span class="No-Break">https://docs.docker.com/cloud/ecs-integration/#install-the-docker-compose-cli-on-linux</span></a><span class="No-Break">.</span></li>
				<li>Log in to your AWS account <a id="_idIndexMarker475"/>through your web browser. You’ll need to make sure that your AWS credentials have access to certain AWS <strong class="bold">Identity and Access Management</strong> (<strong class="bold">IAM</strong>) permissions. See the AWS documentation<a id="_idIndexMarker476"/> on managing permissions (<a href="https://aws.amazon.com/iam/features/manage-permissions/">https://aws.amazon.com/iam/features/manage-permissions/</a>) if you need more help with this. If you only have your root account, you will need to create a new IAM account that has the permissions listed next. These are the permissions<a id="_idIndexMarker477"/> your credentials <span class="No-Break">will need:</span><ul><li><span class="No-Break"><strong class="source-inline">application-autoscaling:*</strong></span></li><li><span class="No-Break"><strong class="source-inline">cloudformation:*</strong></span></li><li><span class="No-Break"><strong class="source-inline">ec2:AuthorizeSecurityGroupIngress</strong></span></li><li><span class="No-Break"><strong class="source-inline">ec2:CreateSecurityGroup</strong></span></li><li><span class="No-Break"><strong class="source-inline">ec2:CreateTags</strong></span></li><li><span class="No-Break"><strong class="source-inline">ec2:DeleteSecurityGroup</strong></span></li><li><span class="No-Break"><strong class="source-inline">ec2:DescribeRouteTables</strong></span></li><li><span class="No-Break"><strong class="source-inline">ec2:DescribeSecurityGroups</strong></span></li><li><span class="No-Break"><strong class="source-inline">ec2:DescribeSubnets</strong></span></li><li><span class="No-Break"><strong class="source-inline">ec2:DescribeVpcs</strong></span></li><li><span class="No-Break"><strong class="source-inline">ec2:RevokeSecurityGroupIngress</strong></span></li><li><span class="No-Break"><strong class="source-inline">ecs:CreateCluster</strong></span></li><li><span class="No-Break"><strong class="source-inline">ecs:CreateService</strong></span></li><li><span class="No-Break"><strong class="source-inline">ecs:DeleteCluster</strong></span></li><li><span class="No-Break"><strong class="source-inline">ecs:DeleteService</strong></span></li><li><span class="No-Break"><strong class="source-inline">ecs:DeregisterTaskDefinition</strong></span></li><li><span class="No-Break"><strong class="source-inline">ecs:DescribeClusters</strong></span></li><li><span class="No-Break"><strong class="source-inline">ecs:DescribeServices</strong></span></li><li><span class="No-Break"><strong class="source-inline">ecs:DescribeTasks</strong></span></li><li><span class="No-Break"><strong class="source-inline">ecs:ListAccountSettings</strong></span></li><li><span class="No-Break"><strong class="source-inline">ecs:ListTasks</strong></span></li><li><span class="No-Break"><strong class="source-inline">ecs:RegisterTaskDefinition</strong></span></li><li><span class="No-Break"><strong class="source-inline">ecs:UpdateService</strong></span></li><li><span class="No-Break"><strong class="source-inline">elasticloadbalancing:*</strong></span></li><li><span class="No-Break"><strong class="source-inline">iam:AttachRolePolicy</strong></span></li><li><span class="No-Break"><strong class="source-inline">iam:CreateRole</strong></span></li><li><span class="No-Break"><strong class="source-inline">iam:DeleteRole</strong></span></li><li><span class="No-Break"><strong class="source-inline">iam:DetachRolePolicy</strong></span></li><li><span class="No-Break"><strong class="source-inline">iam:PassRole</strong></span></li><li><span class="No-Break"><strong class="source-inline">logs:CreateLogGroup</strong></span></li><li><span class="No-Break"><strong class="source-inline">logs:DeleteLogGroup</strong></span></li><li><span class="No-Break"><strong class="source-inline">logs:DescribeLogGroups</strong></span></li><li><span class="No-Break"><strong class="source-inline">logs:FilterLogEvents</strong></span></li><li><span class="No-Break"><strong class="source-inline">route53:CreateHostedZone</strong></span></li><li><span class="No-Break"><strong class="source-inline">route53:DeleteHostedZone</strong></span></li><li><span class="No-Break"><strong class="source-inline">route53:GetHealthCheck</strong></span></li><li><span class="No-Break"><strong class="source-inline">route53:GetHostedZone</strong></span></li><li><span class="No-Break"><strong class="source-inline">route53:ListHostedZonesByName</strong></span></li><li><span class="No-Break"><strong class="source-inline">servicediscovery:*</strong></span></li></ul></li>
				<li>Now, you’ll need to run some commands<a id="_idIndexMarker478"/> at the Docker Compose CLI. Start with <span class="No-Break">this command:</span><pre class="source-code">
<strong class="bold">docker context create ecs &lt;name of your ECS context&gt;</strong></pre><p class="list-inset">The following will print on <span class="No-Break">your screen:</span></p><pre class="source-code"><strong class="bold">? Create a Docker context using:  [Use arrows to move, type to filter]</strong>
<strong class="bold">  An existing AWS profile</strong>
<strong class="bold">  AWS secret and token credentials</strong>
<strong class="bold">&gt; AWS environment variables</strong></pre></li>				<li>Select <strong class="bold">AWS environment variables</strong>. Follow the onscreen instructions to configure your ECS context to retrieve AWS credentials. With that, you can now view your Docker context with <span class="No-Break">this command:</span><pre class="source-code">
<strong class="bold">docker context ls</strong></pre></li>				<li>You can now deploy and manage your Docker containerization in Amazon ECS with the <strong class="source-inline">docker </strong><span class="No-Break"><strong class="source-inline">compose</strong></span><span class="No-Break"> command.</span></li>
			</ol>
			<p>A guide to Docker Compose CLI commands<a id="_idIndexMarker479"/> and configuration help can be found on the <em class="italic">Docker Docs</em> website (<a href="https://docs.docker.com/cloud/ecs-integration/">https://docs.docker.com/cloud/ecs-integration/</a>). I strongly recommend referring to the Docker command-line guide<a id="_idIndexMarker480"/> as well (<a href="https://docs.docker.com/engine/reference/commandline/cli/">https://docs.docker.com/engine/reference/commandline/cli/</a>). But I personally prefer the other Docker deployment method that completely uses AWS’s web <span class="No-Break">application GUI.</span></p>
			<p>Refer to the AWS documentation<a id="_idIndexMarker481"/> if you ever need to delete your <span class="No-Break">Docker cluster:</span></p>
			<p><a href="https://docs.aws.amazon.com/AmazonECS/latest/userguide/delete_cluster-new-console.html"><span class="No-Break">https://docs.aws.amazon.com/AmazonECS/latest/userguide/delete_cluster-new-console.html</span></a></p>
			<p>It’s also possible to remove Docker<a id="_idIndexMarker482"/> containers when you’re not using them anymore. This command (at the Docker CLI) will remove your Docker container and its volumes (<strong class="bold">data storage units</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="bold">DSUs</strong></span><span class="No-Break">):</span></p>
			<pre class="console">
docker rm --volumes &lt;name of docker container&gt;</pre>			<p>So, Docker is one way to deploy<a id="_idIndexMarker483"/> containerized applications in AWS. Kubernetes is the other way, and it builds upon Docker’s system. But setting it up works differently, as you <span class="No-Break">will see.</span></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>How Kubernetes works in AWS</h1>
			<p>The layers in a Kubernetes<a id="_idIndexMarker484"/> containerization system<a id="_idIndexMarker485"/> look like this, from the bottom to <span class="No-Break">the top:</span></p>
			<ul>
				<li>AWS, Azure, or GCP is the <span class="No-Break">cloud platform.</span></li>
				<li>The cloud platform runs a service, such as <strong class="bold">Amazon Elastic Kubernetes Service</strong> (<strong class="bold">Amazon EKS</strong>), which supports the <span class="No-Break">control</span><span class="No-Break"><a id="_idIndexMarker486"/></span><span class="No-Break"> plane.</span></li>
				<li>The next layer is the control plane, which is managed by Kubernetes. This is the root of <span class="No-Break">the cluster.</span></li>
				<li>The control plane deploys Pods according to changing network application metrics that the cloud administrator can define. Pods are deployed to be able to manage the needs of your Kubernetes application at any given time. For instance, more users<a id="_idIndexMarker487"/> and more bandwidth consumption usually result<a id="_idIndexMarker488"/> in <span class="No-Break">more Pods.</span></li>
				<li>Pods <span class="No-Break">deploy containers.</span></li>
			</ul>
			<p>Here’s a sample diagram of <span class="No-Break">Kubernetes architecture:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B18672_06_03.jpg" alt="Figure 6.2 – Kubernetes architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Kubernetes architecture</p>
			<p>Kubernetes Deployments in AWS use Amazon EC2 because that’s the main compute platform. It’s possible to manage Kubernetes directly in Amazon EC2. But more often, organizations choose to use Amazon EKS as an interface with Amazon EC2. It spares administrators the hassle of having to manage <strong class="source-inline">etcd</strong> <span class="No-Break">and instances.</span></p>
			<p>All the AWS Kubernetes examples I use in this book assume that Amazon EKS is <span class="No-Break">being used.</span></p>
			<p>The simplest way to create a Kubernetes<a id="_idIndexMarker489"/> containerization system<a id="_idIndexMarker490"/> with an Amazon EKS cluster is to use AWS’s web application. It’s also possible to launch a cluster at the AWS CLI, but I found it took a lot of extra time to set up IAM and JSON configuration files. If you’d prefer<a id="_idIndexMarker491"/> to use the command line, there’s a guide in the AWS documentation here: <a href="https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html">https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html</a>. But I presume you’re just setting up an environment to practice pentesting. So, launching an EKS cluster through the AWS web interface with all of the default settings should suffice for that purpose. Follow the <span class="No-Break">next steps:</span></p>
			<ol>
				<li>Log in to your AWS account through <a href="http://aws.amazon.com">aws.amazon.com</a> in your web browser. In the top menu search bar, enter <strong class="source-inline">EKS</strong> or <strong class="source-inline">Elastic Kubernetes Service</strong>. There will be a link to open the Amazon EKS interface. Alternatively, you may see a white box on the right side of your screen that says <strong class="bold">Add cluster</strong> for you to <span class="No-Break">click on.</span></li>
				<li>You’ll immediately be taken to the <strong class="bold">Clusters</strong> page. Click on the orange <strong class="bold">Create cluster</strong> button in the top-right corner and select <strong class="bold">Create</strong> from the drop-down menu. Alternatively, you may need to click on the drop-down menu that says <strong class="bold">Create</strong> and click on <span class="No-Break"><strong class="bold">Create Clusters</strong></span><span class="No-Break">.</span></li>
				<li>Now, you’re on the <strong class="bold">Configure cluster</strong> page. Enter an original name for your cluster. Choose whatever you’d like. I chose <strong class="source-inline">EKS-Pentest</strong>. Leave the default Kubernetes version. Choose a cluster service role from the drop-down menu. If there’s no cluster service role<a id="_idIndexMarker492"/> to choose from, follow the Amazon EKS user guide instructions (<a href="https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html#create-service-role">https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html#create-service-role</a>) on how to make an AWS IAM role with EKS <span class="No-Break">cluster permissions.</span></li>
				<li>Leave the rest of the defaults as they are and click on the orange <strong class="bold">Next</strong> button in the <span class="No-Break">lower-right corner.</span></li>
				<li>On the next page, there are <strong class="bold">Networking</strong> settings to configure. Leave <strong class="bold">VPC</strong>, <strong class="bold">Subnets</strong>, <strong class="bold">Security groups</strong>, and <strong class="bold">IP address</strong> at their default settings. Leave <strong class="bold">Cluster endpoint access</strong> as public and click on the orange <strong class="bold">Next</strong> button in the <span class="No-Break">lower-right corner.</span></li>
				<li>On the <strong class="bold">Configure logging</strong> page, set the control plane to log <strong class="bold">API server</strong>, <strong class="bold">Audit</strong>, <strong class="bold">Authenticator</strong>, <strong class="bold">Controller manager</strong>, and <strong class="bold">Scheduler</strong>. For pentesting and red team purposes, more logging is always best! Click on the orange <strong class="bold">Next</strong> button in the <span class="No-Break">lower-right corner.</span></li>
				<li>Leave the Amazon EKS<a id="_idIndexMarker493"/> add-ons as the defaults. They include CoreDNS, Amazon<a id="_idIndexMarker494"/> VPC CNI, and <strong class="source-inline">kube-proxy</strong>. Click on the orange <strong class="bold">Next</strong> button in the <span class="No-Break">lower-right corner.</span></li>
				<li>Leave the default versions for the add-ons. Click on the orange <strong class="bold">Next</strong> button in the <span class="No-Break">lower-right corner.</span></li>
				<li>Review all of your configurations and click on the orange <strong class="bold">Create</strong> button in the <span class="No-Break">lower-right corner.</span><p class="list-inset">You will see a blue notification bar at the top of your screen that says your cluster is being created. It may take a few minutes. When you see a green notification bar, your Kubernetes cluster has been <span class="No-Break">created. Congratulations!</span></p></li>
			</ol>
			<p>If you ever need<a id="_idIndexMarker495"/> to delete your Kubernetes cluster, refer to the AWS<a id="_idIndexMarker496"/> <span class="No-Break">documentation</span><span class="No-Break"><a id="_idIndexMarker497"/></span><span class="No-Break"> here:</span></p>
			<p><a href="https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html"><span class="No-Break">https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html</span></a></p>
			<p>So, we’ve now set up Docker and Kubernetes containerization systems in AWS. Now, it’s time to <span class="No-Break">pentest them.</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Docker and Kubernetes pentesting techniques in AWS</h1>
			<p>In the previous chapter, I walked<a id="_idIndexMarker498"/> you through using Prowler<a id="_idIndexMarker499"/> to pentest AWS deployments. I’ll show you some scripts and vulnerability<a id="_idIndexMarker500"/> checks you can execute to find Docker and Kubernetes<a id="_idIndexMarker501"/> vulnerabilities with a few different tools. But first, it’s worthwhile mentioning here that Prowler can be executed from a Docker instance! You can use Prowler from Docker containers to help pentest your organization’s entire AWS network. <em class="italic">Running Prowler from Docker isn’t just for vulnerability </em><span class="No-Break"><em class="italic">assessing Docker.</em></span></p>
			<p>The same Prowler CLI commands from the previous chapter can be used when you run Prowler <span class="No-Break">from Docker.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Installation in Docker</h2>
			<p>Here’s how to install Prowler<a id="_idIndexMarker502"/> <span class="No-Break">from Docker:</span></p>
			<ol>
				<li>Make sure that Docker Desktop is installed on your local computer. Find the Docker Desktop<a id="_idIndexMarker503"/> Windows, Mac, and Linux clients <span class="No-Break">here: </span><a href="https://docs.docker.com/get-docker/"><span class="No-Break">https://docs.docker.com/get-docker/</span></a><span class="No-Break">.</span></li>
				<li>Have your AWS credentials ready. You can verify them by logging in to your AWS account from your web browser. On the top menu bar, look at the far-right drop-down menu with your username. Click on <strong class="bold">Security credentials</strong> to navigate to the correct AWS IAM page. At the top, it should say <strong class="bold">My security credentials (root user)</strong>. Make a note of your AWS account ID, access key ID, and secret <span class="No-Break">access key.</span></li>
				<li>Navigate to AWS CloudShell by looking at the top menu bar. Launch it by clicking on the Command Prompt-looking icon that’s to the left of the <span class="No-Break">bell icon.</span></li>
				<li>At the AWS CloudShell CLI, enter <strong class="source-inline">pwd</strong> in order to verify your home directory path. You may need to use the <strong class="source-inline">ls</strong> (list files and folders) command and <strong class="source-inline">cd</strong> (change directory) command to find your <span class="No-Break">home directory.</span></li>
				<li>Enter the following commands<a id="_idIndexMarker504"/> to install and configure Prowler inside of a Docker container. Make sure that you enter your AWS access keys into <span class="No-Break">the script:</span><pre class="source-code">
<strong class="bold">docker run -ti --rm -v /your/local/dir/prowler-output:/home/prowler/output \</strong>
<strong class="bold">export AWS_ACCESS_KEY_ID="ASXXXXXXX"</strong>
<strong class="bold">export AWS_SECRET_ACCESS_KEY="XXXXXXXXX"</strong>
<strong class="bold">export AWS_SESSION_TOKEN="XXXXXXXXX"</strong>
<strong class="bold">--name prowler \</strong>
<strong class="bold">--env AWS_ACCESS_KEY_ID \</strong>
<strong class="bold">--env AWS_SECRET_ACCESS_KEY \</strong></pre><p class="list-inset">Replace <strong class="source-inline">/your/local/dir</strong> with the path of your home directory. Enter your access key ID and secret access key after each <strong class="source-inline">\</strong> <span class="No-Break">instance.</span></p></li>			</ol>
			<p>If you need help generating an <strong class="source-inline">AWS_SESSION_TOKEN</strong> instance, consider using <span class="No-Break">this guide:</span></p>
			<p><a href="https://www.websitebuilderinsider.com/how-do-i-get-my-aws-session-token/#:~:text=To%20get%20your%20session%20token,best%20to%20contact%20AWS%20support"><span class="No-Break">https://www.websitebuilderinsider.com/how-do-i-get-my-aws-session-token/#:~:text=To%20get%20your%20session%20token,best%20to%20contact%20AWS%20support</span></a></p>
			<p>Prowler will install in your Docker instance, and you should now be able to execute Prowler from the Docker Compose CLI in Docker Desktop. All of the Prowler commands from the previous chapter will work here. Also, please familiarize yourself with Docker commands with this guide from <em class="italic">Docker </em><span class="No-Break"><em class="italic">Docs</em></span><span class="No-Break">: </span><a href="https://docs.docker.com/engine/reference/commandline/cli/"><span class="No-Break">https://docs.docker.com/engine/reference/commandline/cli/</span></a><span class="No-Break">.</span></p>
			<p>There is a simple automated pentest script by Vishnu Nair that you can use for both real-world pentesting and for trying out for educational purposes. I recommend giving it a try! It can be found in Docker <span class="No-Break">Hub (</span><a href="https://hub.docker.com/r/vishnunair/pentest"><span class="No-Break">https://hub.docker.com/r/vishnunair/pentest</span></a><span class="No-Break">).</span></p>
			<p>Because I was just<a id="_idIndexMarker505"/> trying it out, I decided to run Vishnu Nair’s script in the <strong class="bold">Play With Docker</strong> (<strong class="bold">PWD</strong>) (<a href="https://labs.play-with-docker.com/">https://labs.play-with-docker.com/</a>) simulation. PWD offers a “<em class="italic">simple, interactive and fun playground</em>” to experiment with Docker in its own VMs that you can execute from your web browser. But of course, Vishnu Nair’s script will work in real Docker <span class="No-Break">instances too.</span></p>
			<p>Vishnu Nair’s automated pentest automatically executes dozens of modules including (but not limited to) Nmap, Uniscan, TheHarvester, XSSStrike, Dirb, SSLScan, and DNSmap. Then, it prints results both on screen and in the <strong class="source-inline">/src</strong> folder inside of <span class="No-Break">the container.</span></p>
			<p>It’s such a simple script—one of the most user-friendly<a id="_idIndexMarker506"/> automated vulnerability scanners for containers I have <span class="No-Break">ever used.</span></p>
			<p>Here are the commands <span class="No-Break">to use:</span></p>
			<ol>
				<li>First, create a <span class="No-Break">Docker volume:</span><pre class="source-code">
<strong class="bold">docker volume create pentest-reports</strong></pre></li>				<li>Then, download <span class="No-Break">the script:</span><pre class="source-code">
<strong class="bold">docker run -d --name pentest -d -v pentest-reports:/src vishnunair/pentest:latest</strong></pre></li>				<li>Execute it <span class="No-Break">like so:</span><pre class="source-code">
<strong class="bold">docker exec -it pentest bash</strong>
<strong class="bold">./pentest.sh -d &lt;domain name of your container here&gt;</strong></pre><p class="list-inset">The scan results will print on <span class="No-Break">your screen.</span></p></li>				<li>Find your Docker volumes in the <strong class="source-inline">/var/lib/docker/volumes</strong> path. You may need to use the <strong class="source-inline">cd</strong> command to navigate <span class="No-Break">to it.</span></li>
				<li>Then, find your scan<a id="_idIndexMarker507"/> report with <span class="No-Break">this command:</span><pre class="source-code">
<strong class="bold">docker volume inspect pentest-reports</strong></pre></li>			</ol>
			<p>On <span class="No-Break">to Kubernetes!</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Installation in Kubernetes</h2>
			<p>Aqua Security’s <strong class="source-inline">kube-bench</strong> is an automated<a id="_idIndexMarker508"/> script that runs vulnerability scans based on the <strong class="bold">Center for Internet Security</strong> (<strong class="bold">CIS</strong>) Kubernetes Benchmark (<a href="https://www.cisecurity.org/benchmark/kubernetes">https://www.cisecurity.org/benchmark/kubernetes</a>). The Benchmark includes a list of checks<a id="_idIndexMarker509"/> in <span class="No-Break">these categories:</span></p>
			<ul>
				<li><span class="No-Break">Control-plane components</span></li>
				<li><span class="No-Break"><strong class="source-inline">etcd</strong></span></li>
				<li><span class="No-Break">Control-plane configuration</span></li>
				<li><span class="No-Break">Worker nodes</span></li>
				<li><span class="No-Break">Policies</span></li>
			</ul>
			<p>There are multiple ways to run <strong class="source-inline">kube-bench</strong> (<a href="https://github.com/aquasecurity/kube-bench/blob/main/docs/running.md">https://github.com/aquasecurity/kube-bench/blob/main/docs/running.md</a>), including as a Kubernetes<a id="_idIndexMarker510"/> Job with a YAML file. In this chapter, I created an <strong class="bold">Azure Kubernetes Service</strong> (<strong class="bold">AKS</strong>) cluster for Kubernetes. So, let’s try running <span class="No-Break"><strong class="source-inline">kube-bench</strong></span><span class="No-Break"> there:</span></p>
			<ol>
				<li>First, make sure <strong class="source-inline">kubectl-node-shell</strong> is installed in your EKS cluster by following the GitHub instructions <span class="No-Break">here: </span><a href="https://github.com/kvaps/kubectl-node-shell"><span class="No-Break">https://github.com/kvaps/kubectl-node-shell</span></a><span class="No-Break">.</span></li>
				<li>While at the AWS CLI with Docker installed, run the <span class="No-Break"><strong class="source-inline">kube-bench</strong></span><span class="No-Break"> script:</span><pre class="source-code">
<strong class="bold">docker run --rm -v `pwd`:/host docker.io/aquasec/kube-bench:latest install</strong>
<strong class="bold">./kube-bench</strong></pre></li>				<li>Your benchmark check results will be printed on screen, and you should also find a report in the <strong class="source-inline">/src</strong> folder of <span class="No-Break">your container.</span><p class="list-inset">Refer to the <strong class="source-inline">kube-bench</strong> documentation if you need troubleshooting <span class="No-Break">help: </span><a href="https://github.com/aquasecurity/kube-bench/tree/main/docs"><span class="No-Break">https://github.com/aquasecurity/kube-bench/tree/main/docs</span></a><span class="No-Break">.</span></p></li>
			</ol>
			<p class="callout-heading">Tip</p>
			<p class="callout">Here’s a tip for trying all of the Docker and Kubernetes pentest tools and scripts mentioned in this book. You know how I started this chapter with an analogy about the cloud platform (AWS, Azure, GCP) being like a dish and the containerization orchestration platform (Docker, Kubernetes) being like a piece of <span class="No-Break">buttered toast?</span></p>
			<p class="callout">The AWS (<a href="B18672_05.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>), Azure (<a href="B18672_08.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>), and GCP (<a href="B18672_11.xhtml#_idTextAnchor197"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>) pentests are specific to those cloud platforms. But the Docker and Kubernetes pentest tools and scripts mentioned in this chapter, <a href="B18672_09.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, and <a href="B18672_12.xhtml#_idTextAnchor215"><span class="No-Break"><em class="italic">Chapter 12</em></span></a> can be run in any Docker or Kubernetes instance regardless of the <span class="No-Break">cloud platform.</span></p>
			<p>So, there are a lot more useful pentest<a id="_idIndexMarker511"/> tools and scripts for Docker and Kubernetes further on in <span class="No-Break">this book!</span></p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor112"/>Summary</h1>
			<p>Cloud platforms such as AWS, Azure, and GCP are popular because they offer organizations lots of scalability in their massive <span class="No-Break">data centers.</span></p>
			<p>Containerization orchestrated by Docker or Kubernetes takes full advantage of cloud infrastructure by helping organizations manage hardware and software resources better for their networked applications. Containers use virtualization but are much more lightweight and portable than VMs. You will almost definitely be working with containerization as a <span class="No-Break">cloud pentester.</span></p>
			<p>In AWS, Docker is usually run through Amazon ECS, and Kubernetes with Amazon EKS. They’re both interfaces for <span class="No-Break">Amazon EC2.</span></p>
			<p>Docker and Kubernetes pentesting scripts and benchmarks are interchangeable between <span class="No-Break">cloud platforms.</span></p>
			<p>Now that we’ve deployed VMs and containerized applications in AWS and pentested them, we will move on to Microsoft Azure in the <span class="No-Break">next chapter.</span></p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor113"/>Further reading</h1>
			<p>To learn more about the topics covered in this chapter, you can visit the <span class="No-Break">following links:</span></p>
			<ul>
				<li>Docker on <span class="No-Break">AWS: </span><a href="https://aws.amazon.com/docker/"><span class="No-Break">https://aws.amazon.com/docker/</span></a></li>
				<li>Kubernetes on <span class="No-Break">AWS: </span><a href="https://aws.amazon.com/kubernetes/"><span class="No-Break">https://aws.amazon.com/kubernetes/</span></a></li>
				<li>Docker CLI <span class="No-Break">guide: </span><a href="https://docs.docker.com/engine/reference/commandline/cli/"><span class="No-Break">https://docs.docker.com/engine/reference/commandline/cli/</span></a></li>
				<li>PWD test <span class="No-Break">lab: </span><a href="https://www.docker.com/play-with-docker/"><span class="No-Break">https://www.docker.com/play-with-docker/</span></a></li>
			</ul>
		</div>
	

		<div id="_idContainer027" class="Content">
			<h1 id="_idParaDest-115" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor114"/>Part 3:Pentesting Microsoft Azure</h1>
			<p>Azure is Microsoft’s own cloud platform, and it’s been popular with businesses of all kinds for over 15 years. In this part, we will learn about Azure’s various software-as-a-service, platform-as-a-service, and infrastructure-as-a-service applications. We will deploy our own Azure instance in which to test our pentesting skills. We will use Microsoft Defender for Cloud to check the security posture of our Azure deployment. We will also try out some pentesting tools in Azure, step by step. Then, we’ll deploy Docker and Kubernetes containers and test those <span class="No-Break">as well.</span></p>
			<p>This section has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18672_07.xhtml#_idTextAnchor115"><em class="italic">Chapter 7</em></a>, <em class="italic">Security Features in Azure</em></li>
				<li><a href="B18672_08.xhtml#_idTextAnchor141"><em class="italic">Chapter 8</em></a>, <em class="italic">Pentesting Azure Features through Serverless Applications and Tools</em></li>
				<li><a href="B18672_09.xhtml#_idTextAnchor159"><em class="italic">Chapter 9</em></a>, <em class="italic">Pentesting Containerized Applications in Azure</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer028">
			</div>
		</div>
		<div>
			<div id="_idContainer029" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>