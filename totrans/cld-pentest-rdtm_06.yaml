- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pentesting Containerized Applications in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common use cases for cloud networks is the deployment of containerized
    applications. Over the course of your career as a cloud pentester, the likelihood
    that you’ll need to test in containerized environments is very high.
  prefs: []
  type: TYPE_NORMAL
- en: The popular containerization platforms, Docker and Kubernetes, operate the same
    way within their containerization systems regardless of whether they’re deployed
    in AWS, GCP, Azure, or any other cloud platform. However, the way AWS, GCP, and
    Azure interface with Docker and Kubernetes is a little bit different in each instance.
  prefs: []
  type: TYPE_NORMAL
- en: Think of it this way. A slice of buttered toast is the same slice of buttered
    toast whether it’s served on a ceramic dish, an aluminum dish, or a paper dish.
    The toast will taste the same, and you will eat it the same way regardless of
    what kind of dish it’s served on. But after you eat the toast, the way you clean
    or dispose of the dish will be different.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, that makes sense! Well, it will make more sense once you’ve read
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will explain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How containerization works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Docker works in AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Kubernetes works in AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker and Kubernetes pentesting techniques in AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The wonderful thing about using AWS, whether for containerization or anything
    else, is that we get to use the computing power of Amazon’s infrastructure. That
    means you don’t need a really high-end workstation to do any of the exercises
    in this chapter. All you need is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern desktop or laptop PC running Windows, macOS, or a common Linux distribution
    such as Ubuntu or Debian. A MacBook or a Windows 11 OEM PC with at least 4 GB
    of RAM works great.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A well-supported web browser such as Safari 15 or later, Microsoft Edge 83 or
    later, Mozilla Firefox 105 or later, or Google Chrome 115 or later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reliable internet connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to view the Code in Action: [https://bit.ly/46VJSp3](https://bit.ly/46VJSp3)'
  prefs: []
  type: TYPE_NORMAL
- en: How containerization works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, there were **virtual machines** (**VMs**). VMs run inside a host operating
    system, and the host operating system is what runs directly on computer hardware.
    As far as the host operating system is concerned, the VM is simply an application
    it’s running that has been allocated a certain amount of memory (RAM) and a certain
    amount of disk space in the form of a virtual disk. VMware and Oracle VirtualBox
    both make virtualization clients that you can easily run and install on a Windows,
    Mac, or Linux PC. With those virtualization clients, you can make a VM that runs
    most versions of Windows, macOS, Linux, or Unix.
  prefs: []
  type: TYPE_NORMAL
- en: There is a plethora of use cases for VMs. My background is in cybersecurity,
    so the use case I’m most familiar with is malware testing. I can safely execute
    malware in a VM without harming the host operating system or its hardware. That’s
    because the VM assures that the virtual operating system is “sandboxed” from the
    host operating system. In a worst-case scenario where the malware in my virtual
    operating system makes my virtual operating system impossible to boot properly,
    I can go into my host operating system to uninstall the VM and delete its virtual
    disk. Then, I can make a new VM and start all over again.
  prefs: []
  type: TYPE_NORMAL
- en: An analogy I often hear about host computers and VMs is “a computer and its
    pet computer.” But basically, the host operating system just treats the VM as
    any other sort of application.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization has been possible in computing for a lot longer than people often
    think. The earliest cases of computer virtualization were found in the late 1960s
    and early 1970s on IBM mainframe computers. Timesharing systems were common on
    mainframes and minicomputers of the era because people didn’t own their own computers
    until PCs were invented.
  prefs: []
  type: TYPE_NORMAL
- en: Until the advent of PCs, all computers were shared with multiple people. IBM
    invented virtualization techniques so that multiple users in a timesharing system
    could have a layer of abstraction from the CPU, memory, and disk storage. Each
    user could have their own virtualized computer that could allocate the host computer’s
    real hardware resources without affecting what the other users were doing on the
    same host computer.
  prefs: []
  type: TYPE_NORMAL
- en: As with everything else in computer technology, over the past few decades, virtualization
    has gotten better and better. *Containerization is a similar concept to VMs, but
    it’s not exactly the same thing.* However, progress in the development of virtualization
    technology is what made the invention of containerization possible.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, containerization is similar to VMs, *but much more lightweight*.
    If a VM is a house made of bricks, wood, stone, or concrete, a container is a
    tent that can quickly be erected and taken down as needed.
  prefs: []
  type: TYPE_NORMAL
- en: VMs can be created and removed as needed. But installing and removing a VM isn’t
    an instantaneous process. To install a macOS VM on my Windows PC with Oracle VirtualBox,
    I still need to go through macOS’s installation process for each new macOS VM.
    That takes at least multiple minutes each time.
  prefs: []
  type: TYPE_NORMAL
- en: Docker and Kubernetes are both containerization orchestration platforms. Docker
    and Kubernetes have their own systems for allocating hardware resources, load
    balancing, and process isolation. Setting up a Docker or Kubernetes containerization
    orchestration system for the first time does take several minutes for installation
    and configuration. However, once the Docker or Kubernetes containerization orchestration
    system is ready, containers can be deployed and removed very quickly. And if your
    AWS services give you enough disk space and network bandwidth, you could possibly
    run hundreds of containers under the same orchestration platform at any given
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Your cloud application will immediately benefit from the scalability and efficiency
    containerization gives it. In typical cloud containerization deployments, containers
    are deployed and removed constantly according to an application’s needs at any
    given time. Sometimes, an individual container may only exist for a few days or
    less.
  prefs: []
  type: TYPE_NORMAL
- en: Docker was the first containerization platform to become widely popular. Docker
    debuted in 2013, and it made containerization easier than ever for developers,
    enterprises, and hobbyists alike. The Kubernetes team was inspired by Docker,
    and the first version of Kubernetes was released in 2014.
  prefs: []
  type: TYPE_NORMAL
- en: VMs can run on PCs, server machines, and in cloud environments alike. But although
    applications such as Docker Desktop make it possible to test multi-container applications
    locally, containerization was really made for the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud platforms such as AWS, Azure, and GCP provide organizations with hardware
    and networking scalability because Amazon, Microsoft, and Google operate lots
    of massive data centers on every part of the globe (except for Antarctica) that
    contain millions of server machines and really high-capacity networking infrastructure.
    If an organization needs the capacity of a dozen server machines one day and several
    hundred server machines the next, Amazon, Microsoft, and Google can provide it
    almost instantly for the right amount of money. No hardware resources are wasted,
    and the allocation of hardware resources can be responsive and dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, containerization is designed to work in the context of cloud environments.
    The cloud platform allocates hardware resources at the macro level, and the containerization
    platform allocates hardware resources at the micro level.
  prefs: []
  type: TYPE_NORMAL
- en: Developers really like containerization because they can design their software
    to run inside a particular container configuration without having to worry about
    hardware compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: A container bundles application code with simply the dependencies, libraries,
    and configuration files it needs to run, whereas if they developed their code
    for a VM or a host computer, they’d have to worry about the operating system.
    And if their code was designed to run directly on a host computer, they’d have
    to know its CPU and hardware specifications. When done properly, containerization
    saves developers a lot of frustration. So, their time and energy can be focused
    on making the application better rather than having to waste time troubleshooting
    hardware and operating system problems.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to use AWS without containerization. In the previous chapter,
    I installed a Linux operating system directly in AWS in order to produce that
    chapter’s *Code In Action* videos. When I used Prowler, it was vulnerability scanning
    a very simple Linux-in-AWS setup. If an AWS customer just needs one or a few servers
    that they’ll maintain on a constant basis, simply using an operating system directly
    in AWS can fulfill their needs.
  prefs: []
  type: TYPE_NORMAL
- en: However, many AWS customers need to deploy applications that could have thousands—or
    sometimes even hundreds of thousands—of users at any given time. In those situations,
    containerization is by far the most practical choice. Cloud platforms help make
    containerization possible. So, as a pentester, it’s important that you understand
    how to pentest Docker and Kubernetes deployments effectively.
  prefs: []
  type: TYPE_NORMAL
- en: How Docker works in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The layers in a Docker containerization system look like this, from the bottom
    to the top:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS, Azure, or GCP is the cloud platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cloud platform runs a service, such as **Amazon Elastic Container Service**
    (**Amazon ECS**), that supports the Docker host. The Docker host is a server,
    and the administrator administrates it through their Docker client on their local
    computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker host runs the Docker daemon, which manages Docker images. The daemon
    can also download images from the Docker Registry. The registry can be the remote
    public Docker Hub or the organization’s own private registry. The daemon also
    handles API requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker images are instructions for creating Docker containers. Containers are
    generated from the images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of what a Docker architecture looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Docker architecture](image/B18672_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Docker architecture
  prefs: []
  type: TYPE_NORMAL
- en: Docker deployments in AWS use **Amazon Elastic Compute Cloud** (**Amazon EC2**)
    because that’s the main compute platform.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon ECS is the primary service to run Docker in AWS, regardless of the size
    and scale of your Docker deployment. Amazon ECS is the service you’ll be working
    with directly. It handles the Amazon EC2 work for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common ways to install Docker in AWS:'
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer to install Docker with the help of a **graphical user interface**
    (**GUI**), you can do so with AWS’s web application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, if you prefer to work with a **command-line interface** (**CLI**)
    as much as possible or if you’d like to use Docker Desktop to test your containerization
    system locally in addition to deploying it on AWS, you can use the Docker Compose
    CLI to install Docker in AWS. You may need to install the Docker Compose plugin
    if it’s not already included in your version of Docker Desktop. Read the instructions
    in *Docker Docs* at [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whichever way you choose to install Docker, you can still use your choice of
    compatible GUI and CLI applications to use, administrate, and configure your Docker
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Docker cluster in AWS with Amazon ECS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, I’ll walk you through installing a Docker cluster through AWS’s web
    application GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: Step one is to launch the Amazon ECS first-run wizard. Log in to your AWS account
    through your web browser, and the wizard will make launching Amazon ECS and deploying
    Docker easy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In AWS’s web interface, I like to navigate between different AWS services and
    applications by searching for them by name with the search bar on the top AWS
    application menu. Search for **Amazon ECS**, click on **Elastic Container Service**,
    and you’ll get to the correct screen quickly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the right side, there’s a white box that says **Deploy your containerized
    applications**. Click on the orange **Get** **started** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll be presented with a page that says **Clusters**. Click on the orange
    button in the top-right corner that says **Create cluster**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Cluster configuration**, give your cluster a name. I chose **AWS-Docker-Test**,
    but you can choose any name you’d like that’s valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Networking**, leave the default **virtual private cloud** (**VPC**),
    subnets, and namespace as they are.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Infrastructure**, leave the default **AWS Fargate (serverless)** setting
    as it is. That’s the easiest way to have Amazon ECS allocate the hardware resources
    for your Docker deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Likewise, leave the **Monitoring** and **Tags** sections as they are. In the
    lower-right corner, click on the orange **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A blue bar will appear near the top that says cluster creation is in process.
    It could take a few minutes. If all goes well, the blue bar will become green
    and say that the cluster was created successfully. If not, repeat the steps I
    walked you through and try again. When I tested the cluster creation process myself,
    my first attempt returned a red bar that said the creation process failed. But
    on my second attempt, I was successful.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that your cluster was created successfully, you can see the name of your
    new cluster in the list. Click on the name of your cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You’ll be taken to a new page with the name of your cluster (**AWS-Docker-Test**,
    in my case) at the top. The first section underneath says **Cluster overview**,
    and the next section has six tabs: **Services**, **Tasks**, **Infrastructure**,
    **Metrics**, **Scheduled tasks**, and **Tags**. Under the **Services** tab, click
    on the orange **Create** button in the upper-right corner.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next page, leave all the default settings in the **Environment** section.
    In the **Deployment configuration** section, leave **Service** as the application
    type. Under that, you’ll see a **Task definition** area where it says **Select
    an existing task definition**. To create a new task definition, go to **Task definitions**,
    and click on **Go to** **Task definitions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new page will load in a new tab in your web browser. On the **Task definitions**
    page, click on the orange **Create new task definition** button in the upper-right
    corner. Under **Configure task definition and containers**, give your task definition
    family a name. I chose **Docker-Test-Task-Definition** because I’m so imaginative.
    But you can create whatever name you’d like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Container – 1**, name your container (I chose **Docker-Container-Test**).
    You will also need to enter an image URI (go to [https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/docker-custom-images-tag.html](https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/docker-custom-images-tag.html)
    in the AWS documentation to learn how to select a base image URI if you need help).
    In my case, I’m using Amazon’s **us-east-1** data center. So, my image URI is
    **711395599931.dkr.ecr.us-east-1.amazonaws.com/spark/emr-6.10.0:latest**. Leave
    all the other default settings as they are. Click on the orange **Create** button
    in the lower-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Family**, enter your new task definition name (mine is **Docker-Test-Task-Definition**).
    Leave **Revision** as is. Create a new name under **Service name**. I chose **Docker-Test-Service**.
    Leave all the other default settings as they are. Click on the orange **Create**
    button in the lower-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The deployment of your new service may take a few minutes, as indicated in the
    blue notification at the top of your screen. All services deployed the way I showed
    you with Amazon ECS use Docker by default. So, you’re making a new Docker instance.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Docker with Docker Desktop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other main way to deploy Docker in Amazon ECS is to use Docker Desktop.
    If that’s the way you’d prefer, you’ll first need to install Docker Desktop on
    your local computer. Docker Desktop is an application that’s used to run Docker
    CLI commands. To install it, follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Visit [https://docs.docker.com/desktop/install/mac-install/](https://docs.docker.com/desktop/install/mac-install/)
    to install it on Mac, or visit [https://docs.docker.com/desktop/install/windows-install/](https://docs.docker.com/desktop/install/windows-install/)
    to install it on Windows. You may also need to install the Docker Compose plugin
    in Docker Desktop if it’s not already included. There are instructions in *Docker
    Docs* ([https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)).
    If your local computer uses a Linux operating system, you’ll need to install the
    Docker Compose CLI for Linux here: [https://docs.docker.com/cloud/ecs-integration/#install-the-docker-compose-cli-on-linux](https://docs.docker.com/cloud/ecs-integration/#install-the-docker-compose-cli-on-linux).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log in to your AWS account through your web browser. You’ll need to make sure
    that your AWS credentials have access to certain AWS **Identity and Access Management**
    (**IAM**) permissions. See the AWS documentation on managing permissions ([https://aws.amazon.com/iam/features/manage-permissions/](https://aws.amazon.com/iam/features/manage-permissions/))
    if you need more help with this. If you only have your root account, you will
    need to create a new IAM account that has the permissions listed next. These are
    the permissions your credentials will need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**application-autoscaling:***'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cloudformation:***'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ec2:AuthorizeSecurityGroupIngress**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ec2:CreateSecurityGroup**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ec2:CreateTags**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ec2:DeleteSecurityGroup**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ec2:DescribeRouteTables**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ec2:DescribeSecurityGroups**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ec2:DescribeSubnets**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ec2:DescribeVpcs**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ec2:RevokeSecurityGroupIngress**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecs:CreateCluster**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecs:CreateService**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecs:DeleteCluster**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecs:DeleteService**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecs:DeregisterTaskDefinition**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecs:DescribeClusters**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecs:DescribeServices**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecs:DescribeTasks**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecs:ListAccountSettings**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecs:ListTasks**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecs:RegisterTaskDefinition**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ecs:UpdateService**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**elasticloadbalancing:***'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iam:AttachRolePolicy**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iam:CreateRole**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iam:DeleteRole**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iam:DetachRolePolicy**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**iam:PassRole**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**logs:CreateLogGroup**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**logs:DeleteLogGroup**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**logs:DescribeLogGroups**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**logs:FilterLogEvents**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**route53:CreateHostedZone**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**route53:DeleteHostedZone**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**route53:GetHealthCheck**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**route53:GetHostedZone**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**route53:ListHostedZonesByName**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**servicediscovery:***'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, you’ll need to run some commands at the Docker Compose CLI. Start with
    this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following will print on your screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Select **AWS environment variables**. Follow the onscreen instructions to configure
    your ECS context to retrieve AWS credentials. With that, you can now view your
    Docker context with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now deploy and manage your Docker containerization in Amazon ECS with
    the **docker** **compose** command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A guide to Docker Compose CLI commands and configuration help can be found on
    the *Docker Docs* website ([https://docs.docker.com/cloud/ecs-integration/](https://docs.docker.com/cloud/ecs-integration/)).
    I strongly recommend referring to the Docker command-line guide as well ([https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)).
    But I personally prefer the other Docker deployment method that completely uses
    AWS’s web application GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the AWS documentation if you ever need to delete your Docker cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.aws.amazon.com/AmazonECS/latest/userguide/delete_cluster-new-console.html](https://docs.aws.amazon.com/AmazonECS/latest/userguide/delete_cluster-new-console.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to remove Docker containers when you’re not using them anymore.
    This command (at the Docker CLI) will remove your Docker container and its volumes
    (**data storage units**, or **DSUs**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, Docker is one way to deploy containerized applications in AWS. Kubernetes
    is the other way, and it builds upon Docker’s system. But setting it up works
    differently, as you will see.
  prefs: []
  type: TYPE_NORMAL
- en: How Kubernetes works in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The layers in a Kubernetes containerization system look like this, from the
    bottom to the top:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS, Azure, or GCP is the cloud platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cloud platform runs a service, such as **Amazon Elastic Kubernetes Service**
    (**Amazon EKS**), which supports the control plane.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next layer is the control plane, which is managed by Kubernetes. This is
    the root of the cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The control plane deploys Pods according to changing network application metrics
    that the cloud administrator can define. Pods are deployed to be able to manage
    the needs of your Kubernetes application at any given time. For instance, more
    users and more bandwidth consumption usually result in more Pods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pods deploy containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a sample diagram of Kubernetes architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Kubernetes architecture](image/B18672_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Kubernetes architecture
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Deployments in AWS use Amazon EC2 because that’s the main compute
    platform. It’s possible to manage Kubernetes directly in Amazon EC2\. But more
    often, organizations choose to use Amazon EKS as an interface with Amazon EC2\.
    It spares administrators the hassle of having to manage **etcd** and instances.
  prefs: []
  type: TYPE_NORMAL
- en: All the AWS Kubernetes examples I use in this book assume that Amazon EKS is
    being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to create a Kubernetes containerization system with an Amazon
    EKS cluster is to use AWS’s web application. It’s also possible to launch a cluster
    at the AWS CLI, but I found it took a lot of extra time to set up IAM and JSON
    configuration files. If you’d prefer to use the command line, there’s a guide
    in the AWS documentation here: [https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html](https://docs.aws.amazon.com/eks/latest/userguide/getting-started.html).
    But I presume you’re just setting up an environment to practice pentesting. So,
    launching an EKS cluster through the AWS web interface with all of the default
    settings should suffice for that purpose. Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your AWS account through [aws.amazon.com](http://aws.amazon.com) in
    your web browser. In the top menu search bar, enter **EKS** or **Elastic Kubernetes
    Service**. There will be a link to open the Amazon EKS interface. Alternatively,
    you may see a white box on the right side of your screen that says **Add cluster**
    for you to click on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll immediately be taken to the **Clusters** page. Click on the orange **Create
    cluster** button in the top-right corner and select **Create** from the drop-down
    menu. Alternatively, you may need to click on the drop-down menu that says **Create**
    and click on **Create Clusters**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you’re on the **Configure cluster** page. Enter an original name for your
    cluster. Choose whatever you’d like. I chose **EKS-Pentest**. Leave the default
    Kubernetes version. Choose a cluster service role from the drop-down menu. If
    there’s no cluster service role to choose from, follow the Amazon EKS user guide
    instructions ([https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html#create-service-role](https://docs.aws.amazon.com/eks/latest/userguide/service_IAM_role.html#create-service-role))
    on how to make an AWS IAM role with EKS cluster permissions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the rest of the defaults as they are and click on the orange **Next**
    button in the lower-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next page, there are **Networking** settings to configure. Leave **VPC**,
    **Subnets**, **Security groups**, and **IP address** at their default settings.
    Leave **Cluster endpoint access** as public and click on the orange **Next** button
    in the lower-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Configure logging** page, set the control plane to log **API server**,
    **Audit**, **Authenticator**, **Controller manager**, and **Scheduler**. For pentesting
    and red team purposes, more logging is always best! Click on the orange **Next**
    button in the lower-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the Amazon EKS add-ons as the defaults. They include CoreDNS, Amazon VPC
    CNI, and **kube-proxy**. Click on the orange **Next** button in the lower-right
    corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the default versions for the add-ons. Click on the orange **Next** button
    in the lower-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review all of your configurations and click on the orange **Create** button
    in the lower-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see a blue notification bar at the top of your screen that says your
    cluster is being created. It may take a few minutes. When you see a green notification
    bar, your Kubernetes cluster has been created. Congratulations!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you ever need to delete your Kubernetes cluster, refer to the AWS documentation
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html](https://docs.aws.amazon.com/eks/latest/userguide/delete-cluster.html)'
  prefs: []
  type: TYPE_NORMAL
- en: So, we’ve now set up Docker and Kubernetes containerization systems in AWS.
    Now, it’s time to pentest them.
  prefs: []
  type: TYPE_NORMAL
- en: Docker and Kubernetes pentesting techniques in AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, I walked you through using Prowler to pentest AWS deployments.
    I’ll show you some scripts and vulnerability checks you can execute to find Docker
    and Kubernetes vulnerabilities with a few different tools. But first, it’s worthwhile
    mentioning here that Prowler can be executed from a Docker instance! You can use
    Prowler from Docker containers to help pentest your organization’s entire AWS
    network. *Running Prowler from Docker isn’t just for vulnerability* *assessing
    Docker.*
  prefs: []
  type: TYPE_NORMAL
- en: The same Prowler CLI commands from the previous chapter can be used when you
    run Prowler from Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Installation in Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s how to install Prowler from Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that Docker Desktop is installed on your local computer. Find the
    Docker Desktop Windows, Mac, and Linux clients here: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have your AWS credentials ready. You can verify them by logging in to your AWS
    account from your web browser. On the top menu bar, look at the far-right drop-down
    menu with your username. Click on **Security credentials** to navigate to the
    correct AWS IAM page. At the top, it should say **My security credentials (root
    user)**. Make a note of your AWS account ID, access key ID, and secret access
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to AWS CloudShell by looking at the top menu bar. Launch it by clicking
    on the Command Prompt-looking icon that’s to the left of the bell icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the AWS CloudShell CLI, enter **pwd** in order to verify your home directory
    path. You may need to use the **ls** (list files and folders) command and **cd**
    (change directory) command to find your home directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following commands to install and configure Prowler inside of a Docker
    container. Make sure that you enter your AWS access keys into the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace **/your/local/dir** with the path of your home directory. Enter your
    access key ID and secret access key after each **\** instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you need help generating an **AWS_SESSION_TOKEN** instance, consider using
    this guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.websitebuilderinsider.com/how-do-i-get-my-aws-session-token/#:~:text=To%20get%20your%20session%20token,best%20to%20contact%20AWS%20support](https://www.websitebuilderinsider.com/how-do-i-get-my-aws-session-token/#:~:text=To%20get%20your%20session%20token,best%20to%20contact%20AWS%20support)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prowler will install in your Docker instance, and you should now be able to
    execute Prowler from the Docker Compose CLI in Docker Desktop. All of the Prowler
    commands from the previous chapter will work here. Also, please familiarize yourself
    with Docker commands with this guide from *Docker* *Docs*: [https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/).'
  prefs: []
  type: TYPE_NORMAL
- en: There is a simple automated pentest script by Vishnu Nair that you can use for
    both real-world pentesting and for trying out for educational purposes. I recommend
    giving it a try! It can be found in Docker Hub ([https://hub.docker.com/r/vishnunair/pentest](https://hub.docker.com/r/vishnunair/pentest)).
  prefs: []
  type: TYPE_NORMAL
- en: Because I was just trying it out, I decided to run Vishnu Nair’s script in the
    **Play With Docker** (**PWD**) ([https://labs.play-with-docker.com/](https://labs.play-with-docker.com/))
    simulation. PWD offers a “*simple, interactive and fun playground*” to experiment
    with Docker in its own VMs that you can execute from your web browser. But of
    course, Vishnu Nair’s script will work in real Docker instances too.
  prefs: []
  type: TYPE_NORMAL
- en: Vishnu Nair’s automated pentest automatically executes dozens of modules including
    (but not limited to) Nmap, Uniscan, TheHarvester, XSSStrike, Dirb, SSLScan, and
    DNSmap. Then, it prints results both on screen and in the **/src** folder inside
    of the container.
  prefs: []
  type: TYPE_NORMAL
- en: It’s such a simple script—one of the most user-friendly automated vulnerability
    scanners for containers I have ever used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the commands to use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a Docker volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, download the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute it like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The scan results will print on your screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Find your Docker volumes in the **/var/lib/docker/volumes** path. You may need
    to use the **cd** command to navigate to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, find your scan report with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On to Kubernetes!
  prefs: []
  type: TYPE_NORMAL
- en: Installation in Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aqua Security’s **kube-bench** is an automated script that runs vulnerability
    scans based on the **Center for Internet Security** (**CIS**) Kubernetes Benchmark
    ([https://www.cisecurity.org/benchmark/kubernetes](https://www.cisecurity.org/benchmark/kubernetes)).
    The Benchmark includes a list of checks in these categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Control-plane components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**etcd**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control-plane configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worker nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are multiple ways to run **kube-bench** ([https://github.com/aquasecurity/kube-bench/blob/main/docs/running.md](https://github.com/aquasecurity/kube-bench/blob/main/docs/running.md)),
    including as a Kubernetes Job with a YAML file. In this chapter, I created an
    **Azure Kubernetes Service** (**AKS**) cluster for Kubernetes. So, let’s try running
    **kube-bench** there:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure **kubectl-node-shell** is installed in your EKS cluster by
    following the GitHub instructions here: [https://github.com/kvaps/kubectl-node-shell](https://github.com/kvaps/kubectl-node-shell).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While at the AWS CLI with Docker installed, run the **kube-bench** script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your benchmark check results will be printed on screen, and you should also
    find a report in the **/src** folder of your container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refer to the **kube-bench** documentation if you need troubleshooting help:
    [https://github.com/aquasecurity/kube-bench/tree/main/docs](https://github.com/aquasecurity/kube-bench/tree/main/docs).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a tip for trying all of the Docker and Kubernetes pentest tools and scripts
    mentioned in this book. You know how I started this chapter with an analogy about
    the cloud platform (AWS, Azure, GCP) being like a dish and the containerization
    orchestration platform (Docker, Kubernetes) being like a piece of buttered toast?
  prefs: []
  type: TYPE_NORMAL
- en: The AWS ([*Chapter 5*](B18672_05.xhtml#_idTextAnchor080)), Azure ([*Chapter
    8*](B18672_08.xhtml#_idTextAnchor141)), and GCP ([*Chapter 11*](B18672_11.xhtml#_idTextAnchor197))
    pentests are specific to those cloud platforms. But the Docker and Kubernetes
    pentest tools and scripts mentioned in this chapter, [*Chapter 9*](B18672_09.xhtml#_idTextAnchor159),
    and [*Chapter 12*](B18672_12.xhtml#_idTextAnchor215) can be run in any Docker
    or Kubernetes instance regardless of the cloud platform.
  prefs: []
  type: TYPE_NORMAL
- en: So, there are a lot more useful pentest tools and scripts for Docker and Kubernetes
    further on in this book!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud platforms such as AWS, Azure, and GCP are popular because they offer organizations
    lots of scalability in their massive data centers.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization orchestrated by Docker or Kubernetes takes full advantage of
    cloud infrastructure by helping organizations manage hardware and software resources
    better for their networked applications. Containers use virtualization but are
    much more lightweight and portable than VMs. You will almost definitely be working
    with containerization as a cloud pentester.
  prefs: []
  type: TYPE_NORMAL
- en: In AWS, Docker is usually run through Amazon ECS, and Kubernetes with Amazon
    EKS. They’re both interfaces for Amazon EC2.
  prefs: []
  type: TYPE_NORMAL
- en: Docker and Kubernetes pentesting scripts and benchmarks are interchangeable
    between cloud platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve deployed VMs and containerized applications in AWS and pentested
    them, we will move on to Microsoft Azure in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics covered in this chapter, you can visit the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker on AWS: [https://aws.amazon.com/docker/](https://aws.amazon.com/docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubernetes on AWS: [https://aws.amazon.com/kubernetes/](https://aws.amazon.com/kubernetes/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker CLI guide: [https://docs.docker.com/engine/reference/commandline/cli/](https://docs.docker.com/engine/reference/commandline/cli/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PWD test lab: [https://www.docker.com/play-with-docker/](https://www.docker.com/play-with-docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 3:Pentesting Microsoft Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure is Microsoft’s own cloud platform, and it’s been popular with businesses
    of all kinds for over 15 years. In this part, we will learn about Azure’s various
    software-as-a-service, platform-as-a-service, and infrastructure-as-a-service
    applications. We will deploy our own Azure instance in which to test our pentesting
    skills. We will use Microsoft Defender for Cloud to check the security posture
    of our Azure deployment. We will also try out some pentesting tools in Azure,
    step by step. Then, we’ll deploy Docker and Kubernetes containers and test those
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18672_07.xhtml#_idTextAnchor115), *Security Features in Azure*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18672_08.xhtml#_idTextAnchor141), *Pentesting Azure Features
    through Serverless Applications and Tools*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18672_09.xhtml#_idTextAnchor159), *Pentesting Containerized
    Applications in Azure*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
