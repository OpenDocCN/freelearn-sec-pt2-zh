<html><head></head><body>
		<div id="_idContainer049">
			<h1 id="_idParaDest-160" class="chapter-number"><a id="_idTextAnchor159"/>9</h1>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor160"/>Pentesting Containerized Applications in Azure</h1>
			<p>In the previous chapter, we went through the process of setting up a Microsoft Azure environment for us to practice pentesting and vulnerability scanning in. We then deployed a <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>), learned some PowerShell commands, and conducted some scans with some applications using Bash, while in the Azure Cloud <span class="No-Break">Shell CLI.</span></p>
			<p>Sometimes, organizations simply run their applications in Azure from ordinary Windows and Linux VMs. However, very often, organizations need a highly scalable cloud configuration where application components can be launched and shut down quickly and responsively. That’s especially true in DevOps applications, and that’s where <em class="italic">containerization</em> <span class="No-Break">comes in.</span></p>
			<p>Because a lot of companies use containerization in their Azure networks, it’s important for you to learn how to pentest them. That’s what this chapter is <span class="No-Break">all about.</span></p>
			<p>In this chapter, I will explain what containerization is, why containerization is used, and how containerization works in general. We will also discuss how Docker and Kubernetes work in Azure, along with the pentesting techniques to <span class="No-Break">test them.</span></p>
			<p>The following topics will be covered in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>How <span class="No-Break">containerization works</span></li>
				<li>Docker and Kubernetes pentesting techniques <span class="No-Break">in Azure</span></li>
			</ul>
			<p>So, let’s get <span class="No-Break">into it!</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor161"/>Technical requirements</h1>
			<p>We will work with Microsoft’s infrastructure. Massive Azure data centers will do the bulk of the computer processing work for the exercises in this chapter. So, fortunately, you don’t need to have a top-of-the-line workstation. You will need <span class="No-Break">the following:</span></p>
			<ul>
				<li>A <span class="No-Break">web browser</span></li>
				<li>A desktop or <span class="No-Break">laptop PC</span></li>
				<li>An Android or <span class="No-Break">iPhone mobile</span></li>
				<li>A good, reliable <span class="No-Break">internet connection</span></li>
			</ul>
			<p>Check out the following video to view the Code in <span class="No-Break">Action: </span><a href="https://bit.ly/3QmGlKX"><span class="No-Break">https://bit.ly/3QmGlKX</span></a></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>How containerization works</h1>
			<p><strong class="bold">VMs</strong> are <a id="_idIndexMarker760"/>simulated computers. Instead of directly <a id="_idIndexMarker761"/>running on PC or server machine hardware, a VM imitates all of the hardware components that are needed to run an operating system. So, one physical computer can run several simulated computers, and each simulated computer runs as if it were an application in a hypervisor in a host operating system, or in a hypervisor that runs directly on <span class="No-Break">the hardware.</span></p>
			<p>You can use an application on your own PC, such as Oracle VirtualBox or VMware Workstation Player, to work as a hypervisor for your VMs. All you need is a disk image file of an operating system you’d like to run in your VM and configure it in your hypervisor. The operating systems don’t have to match your host operating system, and very often, they don’t. I could run a Kali Linux VM on my Windows 11 PC. You could run a Windows 11 VM on your MacBook. And I could run a macOS VM on my Ubuntu <span class="No-Break">Linux desktop.</span></p>
			<p>However, it does take a few minutes to set up a VM, as we did in <a href="B18672_08.xhtml#_idTextAnchor141"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, and when you set up a VM, a disk image of the entire operating system needs to <span class="No-Break">be used.</span></p>
			<p>It’s also possible to run a VM on a cloud platform, as we did in the previous chapter. Even though I used Microsoft’s computers and not my own to run the VM, it still took a few minutes to set one up on Azure. Also, a conventional VM on a cloud platform is functionally similar to a VM on your own computer; the entire operating system <span class="No-Break">is used.</span></p>
			<p>Running a VM like that on a cloud platform works great when a company wants to keep the same VM running for months at a time or longer. Running a simple web server on a cloud platform is a great use case <span class="No-Break">for that.</span></p>
			<p>However, nowadays, DevOps and CI/CD application development methodologies make it possible for companies to deploy dynamic applications that need to scale rapidly. These applications can have backends that are radically different from one day to another, reponding to whatever the current production network needs are at any <span class="No-Break">given moment.</span></p>
			<p><em class="italic">Containers</em> are a really precise way to deploy virtualization. A <strong class="bold">container</strong> contains only the operating <a id="_idIndexMarker762"/>system components that are needed to run a small part of a much larger application. Individual containers can have a lifespan of just a few days, or even just a <span class="No-Break">few hours.</span></p>
			<p><em class="italic">Docker</em> and <em class="italic">Kubernetes</em> are the two commonly used containerization orchestration platforms companies use today. A containerization orchestration platform will automatically launch and kill containers without needing direct human interaction. These platforms manage how containers are deployed and also handle the load balancing within the virtualized hardware, allocating hardware resources such as CPU and memory only when they <span class="No-Break">are needed.</span></p>
			<p>Cloud platforms have made containerized applications possible for companies and other sorts of enterprises. Microsoft has massive hardware and networking capacity in its various Azure data centers around the world. So, if a containerized application needs a capacity of 1,000 machines one day, 200 the next, and 2,000 the following day, Azure makes it possible so the company doesn’t have to deploy and decommission all of those machines on their <span class="No-Break">own premises.</span></p>
			<p>You will very likely be<a id="_idIndexMarker763"/> expected to pentest Docker- and Kubernetes-based applications <span class="No-Break">in Azure.</span></p>
			<p>As AWS has its own ways of managing Docker and Kubernetes, so does Azure. Therefore, let’s learn <span class="No-Break">about that.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/>How Docker works in Azure</h2>
			<p>You can launch a <a id="_idIndexMarker764"/>Docker <a id="_idIndexMarker765"/>instance in Azure from your local computer using Docker Desktop, or directly from the Azure CLI. Docker Desktop requires you to install the Docker Desktop application on your computer (<a href="https://docs.docker.com/cloud/aci-integration/">https://docs.docker.com/cloud/aci-integration/</a>), but it’s also possible to launch a Docker instance directly from Azure Cloud Shell (a way to access the Azure CLI) in your web browser. Personally, I prefer the latter option. That’s probably the most convenient way if you just want to launch Docker in the simplest way possible for testing purposes. If you were to launch Docker for a specialized business purpose and have more control over it, Docker Desktop may be the <span class="No-Break">better option.</span></p>
			<p>Let’s work from Azure Cloud Shell and use one of the Docker images Azure makes available by default (it’s also possible to acquire or create your own Docker images, but that’s not necessary for the exercises in this book; a Docker image is like a disk image used in conventional VMs but specialized for <span class="No-Break">a container):</span></p>
			<ol>
				<li>Log in to the Azure account we set up in the previous chapter, from your <span class="No-Break">web browser.</span><p class="list-inset">The native way to deploy Docker in Azure is to use Azure Container Instances, which is a serverless service. There is technically a server, but Azure manages it, not you! That’s what will be running in the background while you follow <span class="No-Break">these instructions.</span></p></li>
				<li>From the blue menu bar at the top of the web page, go to the first icon to the right of the search bar. It should look something <span class="No-Break">like </span><span class="No-Break"><strong class="bold">&gt;_</strong></span><span class="No-Break">.</span></li>
				<li>Click on it to <a id="_idIndexMarker766"/>launch <a id="_idIndexMarker767"/>Azure Cloud Shell. From there, we’ll work in Bash instead of PowerShell because that’s what the pentesting tools in this chapter use. Choose <strong class="bold">Bash</strong> from the top bar of the Azure Cloud <span class="No-Break">Shell screen.</span></li>
				<li>Then, make sure you have the necessary version of the Azure CLI. Input the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">az version</strong></pre><p class="list-inset">As long as you’ve got version 2.0.55 or later, you’re good to go. I have version 2.50.0, so I don’t need to upgrade. If you do need to upgrade, input <span class="No-Break">the following:</span></p><pre class="source-code"><strong class="bold">az upgrade</strong></pre></li>				<li>Containers in<a id="_idIndexMarker768"/> Azure <a id="_idIndexMarker769"/>use a resource group in order to manage Azure’s resources for your purposes. Let’s set one up. Input <span class="No-Break">this command:</span><pre class="source-code">
<strong class="bold">az group create --name &lt;resourceGroupNameOfYourChoiceHere&gt; --location eastus</strong></pre><p class="list-inset"><strong class="source-inline">eastus</strong> can be replaced by whichever Azure data center region name you’d like. For instance, you could choose <strong class="source-inline">canadacentral</strong>, <strong class="source-inline">brazilsouth</strong>, or <strong class="source-inline">westus</strong> if <span class="No-Break">you want.</span></p></li>				<li>Then, we need to<a id="_idIndexMarker770"/> create <a id="_idIndexMarker771"/>a container! For the purposes of the exercises in this chapter, using one of Microsoft’s default Docker container images is fine. Do so with <span class="No-Break">this command:</span><pre class="source-code">
<strong class="bold">az container create --resource-group &lt;resourceGroupNameOfYourChoiceHere&gt; --name mycontainer --image mcr.microsoft.com/azuredocs/aci-helloworld --dns-name-label &lt;dns-name-label-of-your-choice-here&gt; --ports 80</strong></pre><p class="list-inset">Make sure that the name of your resource group is the same name you created in the <span class="No-Break">previous command.</span></p></li>				<li>Now, you can<a id="_idIndexMarker772"/> verify <a id="_idIndexMarker773"/>your container’s status to see whether all that worked! Enter <span class="No-Break">this command:</span><pre class="source-code">
<strong class="bold">az container show --resource-group &lt;resourceGroupNameOfYourChoiceHere&gt; --name mycontainer --query "{FQDN:ipAddress.fqdn,ProvisioningState:provisioningState}" --out table</strong></pre><p class="list-inset">If all of that worked, something like this will be printed on the <span class="No-Break">command line:</span></p><pre class="source-code">FQDN                                         ProvisioningState
---------------------------------            -------------------
aci-demo.eastus.azurecontainer.io            Succeeded</pre><p class="list-inset">If not, start all over again from the <strong class="source-inline">create resource group</strong> command. Now, we have a <a id="_idIndexMarker774"/>Docker<a id="_idIndexMarker775"/> instance running that we can test our pentesting skills <span class="No-Break">in! Congratulations!</span></p></li>			</ol>
			<p>There’s just one last command that’s very useful to pentest your new Docker instance. A lot of the vulnerability data we can mention in a pentest report comes from logging. You can use the following command to pull container <span class="No-Break">instance logs:</span></p>
			<pre class="console">
az container logs --resource-group &lt;resourceGroupNameOfYourChoiceHere&gt; --name mycontainer</pre>			<p>You will get a message on the command line that says <strong class="source-inline">listening on port 80</strong> (the TCP/IP port for HTTP), and eventually, you will see HTTP <strong class="source-inline">GET</strong> requests displayed on the command line as they are made for your Docker instance from your computer or other computers on <span class="No-Break">the internet.</span></p>
			<p>You can remove<a id="_idIndexMarker776"/> your <a id="_idIndexMarker777"/>Docker container with <span class="No-Break">this command:</span></p>
			<pre class="console">
docker rm &lt;name of folder with container here&gt;</pre>			<p>Now, let’s move on <span class="No-Break">to Kubernetes.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor164"/>How Kubernetes works in Azure</h2>
			<p>Azure has<a id="_idIndexMarker778"/> services<a id="_idIndexMarker779"/> that are specifically designed to deploy Kubernetes! Azure Kubernetes Service (<a href="https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes">https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes</a>) makes deploying Kubernetes containerization on Azure’s <span class="No-Break">platform easy.</span></p>
			<p>Kubernetes is the most popular containerization orchestration platform today. However, here’s a fact that may confuse some newcomers – Kubernetes expands on some of the technologies that were pioneered by Docker. It’s also possible to run Docker containers in Kubernetes! So, Docker and Kubernetes are often intertwined in enterprise DevOps and CI/CD applications that run in <span class="No-Break">the cloud.</span></p>
			<p>In the previous section, we deployed a purely Docker-based containerization system, with Azure’s serverless Azure Container Instances service running in the background to support it all. Now, we will deploy containerization in Azure <span class="No-Break">Kubernetes Service.</span></p>
			<p>Kubernetes has a very particular architecture (as discussed in <a href="B18672_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break">).</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Kubernetes architecture is the same regardless of the <span class="No-Break">cloud platform.</span></p>
			<p>At the base of a Kubernetes deployment is the control plane. That’s the parent of everything else that runs on top of it. It features an API server to manage connections to external applications, and a controller manager. We will give it commands through <em class="italic">kubectl</em>, the <span class="No-Break">Kubernetes CLI.</span></p>
			<p>The control plane’s children are <em class="italic">Nodes</em>. They share compute, network, and storage resources. The children of Nodes are <em class="italic">Pods</em>, and the children of Pods are the <em class="italic">individual containers</em>. So, think of it this way – containers are the great-grandparents <span class="No-Break">of containers.</span></p>
			<p>Containers are the most dynamic component; they change most frequently. They’re generated responsively from container images, according to whatever an application needs at the time. They <a id="_idIndexMarker780"/>contain only the configuration files, libraries, and<a id="_idIndexMarker781"/> dependencies that are required for the code they execute to run. That’s because the Nodes handle the load balancing of hardware resources, and the control plane has ultimate control over everything and is also the gateway to systems outside of your Kubernetes <span class="No-Break">containerization system.</span></p>
			<p>If you want to sound like you’re a real Kubernetes expert, call it <em class="italic">K8s</em>. That’s the nickname Kubernetes developers and administrators have given it. However, I prefer to call it by its <span class="No-Break">formal name.</span></p>
			<p>Okay, let’s deploy Kubernetes in our Azure network! We can use it for pentesting later in <span class="No-Break">this chapter:</span></p>
			<ol>
				<li>First, we need to launch Azure Cloud Shell again. From the blue menu bar at the top of the web page, go to the first icon to the right of the search bar. It should look something <span class="No-Break">like </span><span class="No-Break"><strong class="bold">&gt;_</strong></span><span class="No-Break">.</span></li>
				<li>Click on it to launch Azure Cloud Shell. From there, we’ll work in Bash instead of PowerShell. Choose <strong class="bold">Bash</strong> from the top bar of the Azure Cloud <span class="No-Break">Shell screen.</span></li>
				<li>Then, make sure you have the right version of the Azure CLI. Use <span class="No-Break">this command:</span><pre class="source-code">
<strong class="bold">az –version</strong></pre><p class="list-inset">As long as you <a id="_idIndexMarker782"/>have<a id="_idIndexMarker783"/> version 2.0.55 or later, you’re good to go. Otherwise, enter <span class="No-Break">this command:</span></p><pre class="source-code"><strong class="bold">az upgrade</strong></pre><p class="list-inset">While working with Kubernetes at the Azure CLI, I learned that I needed to<a id="_idTextAnchor165"/> create a service principal with access to my container registry first so that everything else would <span class="No-Break">work properly.</span></p></li>				<li>Copy this script, and paste it into a text editor, such as Notepad. Replace where it says <strong class="source-inline">$containerRegistry</strong> with a name of your choice (e.g., <strong class="source-inline">acrKim</strong>). Replace <strong class="source-inline">$servicePrincipal</strong> with <a id="_idIndexMarker784"/>a name of your <a id="_idIndexMarker785"/>choice (<span class="No-Break">e.g., </span><span class="No-Break"><strong class="source-inline">KIM_KUBERNETES</strong></span><span class="No-Break">):</span><pre class="source-code">
 #!/bin/bash
 # This script requires Azure CLI version 2.25.0 or later. Check version with `az --version`.
 # Modify for your environment.
 # ACR_NAME: The name of your Azure Container Registry
 ACR_NAME=$containerRegistry
 # SERVICE_PRINCIPAL_NAME: Must be unique within your AD tenant
 SERVICE_PRINCIPAL_NAME=$servicePrincipal
 # Obtain the full registry ID
 ACR_REGISTRY_ID=$(az acr show --name $ACR_NAME --query "id" --output tsv)
 # echo $registryId
 # Create the service principal with rights scoped to the registry.
 # Default permissions are for docker pull access. Modify the '--role'
 # argument value as desired:
 # acrpull:   pull only
 # acrpush:   push and pull
 # owner:    push, pull, and assign roles
 PASSWORD=$(az ad sp create-for-rbac --name $SERVICE_PRINCIPAL_NAME --scopes $ACR_REGISTRY_ID --role acrpull --query "password" --output tsv)
 USER_NAME=$(az ad sp list --display-name $SERVICE_PRINCIPAL_NAME --query "[].appId" --output tsv)
 # Output the service principal's credentials; use these in your services and
 # applications to authenticate to the container registry.
 echo "Service principal ID: $USER_NAME"
 echo "Service principal password: $PASSWORD"</pre></li>				<li>If yours<a id="_idIndexMarker786"/> won’t be <a id="_idIndexMarker787"/>thrown away soon, change your password to something complex with a lot of <span class="No-Break">random characters.</span><p class="list-inset">Now, we can <a id="_idIndexMarker788"/>finally <a id="_idIndexMarker789"/>deploy our Kubernetes cluster! Replace <strong class="source-inline">kimAKSCluster</strong> with a cluster name of your choice. Replace <strong class="source-inline">acrKim</strong> with the ACR name you used in the <strong class="source-inline">ACR_REGISTRY_ID=$(az acr show --name $acrKim --query "id" --output tsv)</strong> line of the <span class="No-Break">previous script:</span></p><pre class="source-code">
<strong class="bold">az aks create \</strong>
<strong class="bold">    --resource-group myResourceGroup \</strong>
<strong class="bold">    --name kimAKSCluster \</strong>
<strong class="bold">    --node-count 2 \</strong>
<strong class="bold">    --generate-ssh-keys \</strong>
<strong class="bold">    --attach-acr acrKim</strong></pre></li>				<li>After a few minutes, a JSON output will display confirmation of the metrics of your Azure Kubernetes <span class="No-Break">Service deployment.</span><p class="list-inset">The<a id="_idIndexMarker790"/> Kubernetes<a id="_idIndexMarker791"/> CLI, otherwise known as <em class="italic">kubectl</em>, is already installed in Azure <span class="No-Break">Cloud Shell.</span></p></li>
				<li>Then, we need to connect to our Kubernetes cluster with kubectl. Enter the following command, but replace <strong class="source-inline">myResourceGroup</strong> with the resource group name you used previously, and replace <strong class="source-inline">kimAKSCluster</strong> with the cluster name you <span class="No-Break">used previously:</span><pre class="source-code">
<strong class="bold">az aks get-credentials --resource-group myResourceGroup --name kimAKSCluster</strong></pre></li>				<li>Now, we can<a id="_idIndexMarker792"/> verify<a id="_idIndexMarker793"/> that everything worked and our Nodes are running. Input <span class="No-Break">this command:</span><pre class="source-code">
<strong class="bold">kubectl get nodes</strong></pre></li>			</ol>
			<p>Now, we have a vanilla Docker instance in Azure using Azure Container Instances, and a basic Kubernetes<a id="_idIndexMarker794"/> instance <a id="_idIndexMarker795"/>using Azure <span class="No-Break">Kubernetes Service.</span></p>
			<p>In the following section, we’ll run some vulnerability scans and pentest scripts in those instances. This is the <span class="No-Break">fun stuff!</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor166"/>Docker and Kubernetes pentesting techniques in Azure</h1>
			<p>Let’s explore<a id="_idIndexMarker796"/> some tools to pentest containers<a id="_idIndexMarker797"/> <span class="No-Break">in Azure.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor167"/>kube-hunter</h2>
			<p>The first pentesting <a id="_idIndexMarker798"/>application we’ll try is <strong class="source-inline">kube-hunter</strong> by Aqua Security on GitHub. The introduction in the kube-hunter <strong class="source-inline">README</strong> file at <a href="https://github.com/aquasecurity/kube-hunter/blob/main/README.md">https://github.com/aquasecurity/kube-hunter/blob/main/README.md</a> states <span class="No-Break">the following:</span></p>
			<p><em class="italic">“kube-hunter hunts for security weaknesses in Kubernetes clusters. The tool was developed to increase awareness and visibility for security issues in Kubernetes environments. You should NOT run kube-hunter on a Kubernetes cluster that you </em><span class="No-Break"><em class="italic">don’t own!”</em></span></p>
			<p>Absolutely! That’s why we set up our own Kubernetes cluster in our own Azure services in this chapter. When you’re actually doing paid work as a pentester, you will need signed legal permission from the company that owns the Azure network and <span class="No-Break">Kubernetes instance.</span></p>
			<p>There are lots of different kinds of scans you can do with kube-hunter. First, let’s install it. Then, we’ll run a <span class="No-Break">quick scan.</span></p>
			<p>Let’s clone the <strong class="source-inline">git</strong> repository for kube-hunter with this command in Bash within Azure <span class="No-Break">Cloud Shell:</span></p>
			<pre class="console">
git clone https://github.com/aquasecurity/kube-hunter.git</pre>			<p>Now, we’ll install <span class="No-Break">its</span><span class="No-Break"><a id="_idIndexMarker799"/></span><span class="No-Break"> dependencies:</span></p>
			<pre class="console">
cd ./kube-hunter
pip install -r requirements.txt</pre>			<p>kube-hunter is a Python application, so we can launch it with <span class="No-Break">this command:</span></p>
			<pre class="console">
python3 kube_hunter</pre>			<p>There’s another installation method that I like to use. It uses the <strong class="source-inline">pip</strong> repositories. <span class="No-Break">Try this:</span></p>
			<pre class="console">
pip install kube-hunter</pre>			<p>And if you installed kube-hunter that way, you could launch it with <span class="No-Break">this command:</span></p>
			<pre class="console">
kube-hunter</pre>			<p>You can also run kube-hunter while specifying a certain log level. Try <span class="No-Break">this command:</span></p>
			<pre class="console">
kube-hunter --active --log WARNING</pre>			<p>That will output the <strong class="source-inline">WARNING</strong> level logs. Those are the events you should really pay attention to, which <a id="_idIndexMarker800"/>can be very useful to mention in your pentest report. Alternatively, you can output <strong class="source-inline">DEBUG</strong> logs with <span class="No-Break">this command:</span></p>
			<pre class="console">
kube-hunter --active --log DEBUG</pre>			<p>The default when you launch kube-hunter is to log <strong class="source-inline">INFO</strong>-level events. If you changed the logging to <strong class="source-inline">WARNING</strong> or <strong class="source-inline">DEBUG</strong> and you’d like to switch back to <strong class="source-inline">INFO</strong>, use <span class="No-Break">this command:</span></p>
			<pre class="console">
kube-hunter --active --log INFO</pre>			<p>As we’re working in our own Kubernetes instance for educational purposes, feel free to play around with the different <span class="No-Break">logging options.</span></p>
			<p>When you run a quick scan with the <strong class="source-inline">kube-hunter</strong> command, this is what will output at the <span class="No-Break">command line:</span></p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B18672_09_013.jpg" alt="Figure 9.1 – Running kube-hunter in Azure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Running kube-hunter in Azure</p>
			<p>So, then, you enter <strong class="source-inline">1</strong>, <strong class="source-inline">2</strong>, or <strong class="source-inline">3</strong> for the type of scanning you’d like to execute. If you use options <strong class="source-inline">1</strong> or <strong class="source-inline">3</strong>, you will need to enter IP addresses at the <span class="No-Break">following prompt.</span></p>
			<p>I often forget about the IP addresses that I use with my Azure instance when I’m playing around. We’re in Bash, so<a id="_idIndexMarker801"/> the simplest way to check your IP addresses in Azure is with <span class="No-Break">this command:</span></p>
			<pre class="console">
ifconfig</pre>			<p>Something like this should output at the <span class="No-Break">command line:</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B18672_09_015.jpg" alt="Figure 9.2 – The ifconfig command in Azure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The ifconfig command in Azure</p>
			<p>Yes, I know the character <strong class="source-inline">X</strong> isn’t used in IPv4 or IPv6 IP addresses. I replaced some of the characters in my IP addresses for the sake of operational security. You can never be <span class="No-Break">too careful!</span></p>
			<p>You can also install and run kube-hunter inside Docker containers! Install kube-hunter in Docker with <span class="No-Break">this command:</span></p>
			<pre class="console">
docker run -it --rm --network host aquasec/kube-hunter</pre>			<p>By default, kube-hunter <a id="_idIndexMarker802"/>outputs the logs from all of your scans through an entity called <strong class="source-inline">stdout</strong>. Therefore, you can find your logs through the Azure <span class="No-Break">Monitor interface:</span></p>
			<ol>
				<li>Go back to your Azure account interface <span class="No-Break">at </span><a href="https://portal.azure.com"><span class="No-Break">portal.azure.com</span></a><span class="No-Break">.</span></li>
				<li>At the blue menu bar at the top, enter <strong class="source-inline">Monitor</strong> in the <span class="No-Break">search bar.</span></li>
				<li>On the left-hand side, there’s a list of sections under <strong class="bold">Monitor</strong>, such as <strong class="bold">Overview</strong> and <strong class="bold">Activity log</strong>. Click on <span class="No-Break"><strong class="bold">Activity log</strong></span><span class="No-Break">.</span><p class="list-inset">The following screen will show your logs <span class="No-Break">like this:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B18672_09_016.jpg" alt="Figure 9.3 – Activity log in Azure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Activity log in Azure</p>
			<p>Your actions in<a id="_idIndexMarker803"/> kube-hunter will be recorded there. My actions produced a lot of entries named <strong class="bold">List Storage Account Keys</strong>. That’s the sort of sensitive information kube-hunter was <span class="No-Break">looking for!</span></p>
			<p>Explore the kube-hunter documentation (<a href="https://aquasecurity.github.io/kube-hunter/">https://aquasecurity.github.io/kube-hunter/</a>) to find out other things you <span class="No-Break">can do.</span></p>
			<p>Now, let’s <span class="No-Break">try </span><span class="No-Break"><em class="italic">kdigger</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor168"/>kdigger</h2>
			<p><strong class="bold">kdigger</strong> is a multipurpose<a id="_idIndexMarker804"/> Kubernetes pentesting tool. It’s capable of <em class="italic">digging</em> around in your Kubernetes instance to see which entities it can find. Of course, being able to fingerprint and enumerate a containerization deployment is a very dangerous ability for a cyber threat actor to have, as they’ll then know how to proceed with <span class="No-Break">their attacks.</span></p>
			<p>The data you acquire from using kdigger can also be used to conduct better-informed pentests <span class="No-Break">in Kubernetes.</span></p>
			<p>kdigger can also be used for fuzzing. That means inputting invalid, unexpected, or random data into an application to see whether it’s breakable. If the application is designed to validate inputs and handle exceptions in code, it won’t be susceptible to fuzzing attacks. To learn how to use kdigger for fuzzing and other possibilities, check out their <span class="No-Break">documentation: </span><a href="https://github.com/quarkslab/kdigger"><span class="No-Break">https://github.com/quarkslab/kdigger</span></a><span class="No-Break">.</span></p>
			<p>Let’s install kdigger and do <span class="No-Break">some digging.</span></p>
			<p>Depending on your configuration, you may find one of these two installation methods <span class="No-Break">works best:</span></p>
			<ul>
				<li>The first method is the default Git <span class="No-Break">source technique:</span><pre class="source-code">
<strong class="bold">git clone https://github.com/quarkslab/kdigger</strong>
<strong class="bold">cd kdigger</strong></pre><p class="list-inset">Then, you need to move your binary into a working directory in <span class="No-Break">your path:</span></p><pre class="source-code"><strong class="bold">sudo install kdigger &lt;/usr/local/bin or enter your path name here&gt;</strong></pre><p class="list-inset">That method will require you to remember your <span class="No-Break"><strong class="source-inline">sudo</strong></span><span class="No-Break"> password.</span></p></li>				<li>This simpler installation method <span class="No-Break">uses </span><span class="No-Break"><strong class="source-inline">go</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">go install github.com/quarkslab/kdigger@main</strong></pre></li>			</ul>
			<p>Now, let’s give kdigger <span class="No-Break">a try!</span></p>
			<p>Navigate to the directory where your Pods are and where kdigger is installed. When I get lost in Bash, I enter this command to list the contents of my <span class="No-Break">current directory:</span></p>
			<pre class="console">
ls</pre>			<p>And then I enter this<a id="_idIndexMarker805"/> command to change to the directory that I’m <span class="No-Break">looking for:</span></p>
			<pre class="console">
cd go/bin</pre>			<p>When you’re in the directory that kdigger is installed in, you can do a general scan with a very <span class="No-Break">simple command:</span></p>
			<pre class="console">
 ./kdigger dig all</pre>			<p>For me, this is what was outputted at the command line. I have replaced some characters in the DNS names and IP addresses with <strong class="source-inline">X</strong> for operational <span class="No-Break">security reasons:</span></p>
			<pre class="console">
; &lt;&lt;&gt;&gt; DiG 9.16.33 &lt;&lt;&gt;&gt;
;; global options: +cmd
;; Got answer:
;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 33463
;; flags: qr rd ra; QUERY: 1, ANSWER: 13, AUTHORITY: 0, ADDITIONAL: 27
;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1224
;; QUESTION SECTION:
;.                              IN      NS
;; ANSWER SECTION:
.                       7048    IN      NS      XXX.net.
.                       7048    IN      NS      XXX.net.
.                       7048    IN      NS      XXX.net.
.                       7048    IN      NS      XXX.net.
.                       7048    IN      NS      XXX.net.
.                       7048    IN      NS      XXX.net.
.                       7048    IN      NS      XXX.net.
.                       7048    IN      NS      XXX.net.
.                       7048    IN      NS      XXX.net.
.                       7048    IN      NS      XXX.net.
.                       7048    IN      NS      XXX.net.
.                       7048    IN      NS      XXX.net.
.                       7048    IN      NS      XXX.net.
;; ADDITIONAL SECTION:
XXX.net.     1461    IN      A       198.XX.X.X
XXX.net.     1461    IN      AAAA    2001:503:XXXXX
XXX.net.     1461    IN      A       192.58.XX.XX
XXX.net.     1461    IN      AAAA    2001:503:XXXXX
XXX.net.     1461    IN      A       192.XXX.XX.XX
XXX.net.     1461    IN      AAAA    2001:XXXXX
XXX.net.     1461    IN      A       199.X.XX.XX
XXX.net.     1461    IN      AAAA    2001:XXX
;; Query time: 0 msec
;; SERVER: 168.63.129.16#53(168.XX.XXX.XX)
;; WHEN: Fri Jul 28 21:56:48 UTC 2023
;; MSG SIZE  rcvd: 824</pre>			<p>If you want to scan all the buckets, <span class="No-Break">try this:</span></p>
			<pre class="console">
dig all</pre>			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span xml:lang="en-GB">You can mention any</span><span xml:lang="en-GB"><a id="_idIndexMarker806"/></span><span xml:lang="en-GB"> exposed Kubernetes entities that kdigger found in your pentest report.</span></p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor169"/>Summary</h1>
			<p>Organizations often deploy containerization on their cloud platforms because it is a very responsive and dynamic way to use virtualization to implement rapidly scalable and ever-evolving applications, using DevOps or <span class="No-Break">CI/CD methodologies.</span></p>
			<p>A container contains just the parts of an operating system that are required to execute the code it processes. The load balancing and managing of hardware resources are done by the parent, grandparent, or great-grandparent of the containers within the <span class="No-Break">containerization platform.</span></p>
			<p>Now, we know how to deploy Docker and Kubernetes containerization instances in Azure and test them for security vulnerabilities. Docker and Kubernetes are two of the most used containerization platforms. Kubernetes basically extends Docker’s features further and can even work with Docker images <span class="No-Break">and containers.</span></p>
			<p>In the following chapter, I’ll introduce you to Google Cloud Platform and its <span class="No-Break">various services.</span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor170"/>Further reading</h1>
			<p>To learn more about the topics covered in this chapter, you can visit the <span class="No-Break">following links:</span></p>
			<ul>
				<li><em class="italic">Deploy a container instance in Azure using the Azure </em><span class="No-Break"><em class="italic">CLI</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/azure/container-instances/container-instances-quickstart&#13;"><span class="No-Break">https://learn.microsoft.com/en-us/azure/container-instances/container-instances-quickstart</span></a></li>
				<li><em class="italic">What is Azure Kubernetes </em><span class="No-Break"><em class="italic">Service?</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes&#13;"><span class="No-Break">https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes</span></a></li>
				<li><em class="italic">kube-hunter </em><span class="No-Break"><em class="italic">documentation</em></span><span class="No-Break">: </span><a href="https://aquasecurity.github.io/kube-hunter/&#13;"><span class="No-Break">https://aquasecurity.github.io/kube-hunter/</span></a></li>
				<li><em class="italic">kdigger </em><span class="No-Break"><em class="italic">documentation</em></span><span class="No-Break">: </span><a href="https://github.com/quarkslab/kdigger"><span class="No-Break">https://github.com/quarkslab/kdigger</span></a></li>
			</ul>
		</div>
	

		<div id="_idContainer050" class="Content">
			<h1 id="_idParaDest-171" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor171"/>Part 4:Pentesting GCP</h1>
			<p><strong class="bold">GCP</strong> is <strong class="bold">Google’s Cloud Platform</strong>! However, those in the know use the acronym. In this part, we will learn about GCP’s various software-as-a-service, platform-as-a-service, and infrastructure-as-a-service applications. We will deploy our own GCP instance in which to test our pentesting skills. We will use Security Command Center to check the security posture of our GCP deployment. We will also try out some pentesting tools in GCP, step by step. Then, we’ll deploy Docker and Kubernetes containers and test those <span class="No-Break">as well.</span></p>
			<p>This section has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18672_10.xhtml#_idTextAnchor172"><em class="italic">Chapter 10</em></a>, <em class="italic">Security Features in GCP</em></li>
				<li><a href="B18672_11.xhtml#_idTextAnchor197"><em class="italic">Chapter 11</em></a>, <em class="italic">Pentesting GCP Features through Serverless Applications and Tools</em></li>
				<li><a href="B18672_12.xhtml#_idTextAnchor215"><em class="italic">Chapter 12</em></a>, <em class="italic">Pentesting Containerized Applications in GCP</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer051">
			</div>
		</div>
		<div>
			<div id="_idContainer052" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>