- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pentesting Containerized Applications in Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we went through the process of setting up a Microsoft
    Azure environment for us to practice pentesting and vulnerability scanning in.
    We then deployed a **virtual machine** (**VM**), learned some PowerShell commands,
    and conducted some scans with some applications using Bash, while in the Azure
    Cloud Shell CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, organizations simply run their applications in Azure from ordinary
    Windows and Linux VMs. However, very often, organizations need a highly scalable
    cloud configuration where application components can be launched and shut down
    quickly and responsively. That’s especially true in DevOps applications, and that’s
    where *containerization* comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Because a lot of companies use containerization in their Azure networks, it’s
    important for you to learn how to pentest them. That’s what this chapter is all
    about.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will explain what containerization is, why containerization
    is used, and how containerization works in general. We will also discuss how Docker
    and Kubernetes work in Azure, along with the pentesting techniques to test them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How containerization works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker and Kubernetes pentesting techniques in Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let’s get into it!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will work with Microsoft’s infrastructure. Massive Azure data centers will
    do the bulk of the computer processing work for the exercises in this chapter.
    So, fortunately, you don’t need to have a top-of-the-line workstation. You will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A desktop or laptop PC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Android or iPhone mobile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good, reliable internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to view the Code in Action: [https://bit.ly/3QmGlKX](https://bit.ly/3QmGlKX)'
  prefs: []
  type: TYPE_NORMAL
- en: How containerization works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**VMs** are simulated computers. Instead of directly running on PC or server
    machine hardware, a VM imitates all of the hardware components that are needed
    to run an operating system. So, one physical computer can run several simulated
    computers, and each simulated computer runs as if it were an application in a
    hypervisor in a host operating system, or in a hypervisor that runs directly on
    the hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use an application on your own PC, such as Oracle VirtualBox or VMware
    Workstation Player, to work as a hypervisor for your VMs. All you need is a disk
    image file of an operating system you’d like to run in your VM and configure it
    in your hypervisor. The operating systems don’t have to match your host operating
    system, and very often, they don’t. I could run a Kali Linux VM on my Windows
    11 PC. You could run a Windows 11 VM on your MacBook. And I could run a macOS
    VM on my Ubuntu Linux desktop.
  prefs: []
  type: TYPE_NORMAL
- en: However, it does take a few minutes to set up a VM, as we did in [*Chapter 8*](B18672_08.xhtml#_idTextAnchor141),
    and when you set up a VM, a disk image of the entire operating system needs to
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to run a VM on a cloud platform, as we did in the previous
    chapter. Even though I used Microsoft’s computers and not my own to run the VM,
    it still took a few minutes to set one up on Azure. Also, a conventional VM on
    a cloud platform is functionally similar to a VM on your own computer; the entire
    operating system is used.
  prefs: []
  type: TYPE_NORMAL
- en: Running a VM like that on a cloud platform works great when a company wants
    to keep the same VM running for months at a time or longer. Running a simple web
    server on a cloud platform is a great use case for that.
  prefs: []
  type: TYPE_NORMAL
- en: However, nowadays, DevOps and CI/CD application development methodologies make
    it possible for companies to deploy dynamic applications that need to scale rapidly.
    These applications can have backends that are radically different from one day
    to another, reponding to whatever the current production network needs are at
    any given moment.
  prefs: []
  type: TYPE_NORMAL
- en: '*Containers* are a really precise way to deploy virtualization. A **container**
    contains only the operating system components that are needed to run a small part
    of a much larger application. Individual containers can have a lifespan of just
    a few days, or even just a few hours.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Docker* and *Kubernetes* are the two commonly used containerization orchestration
    platforms companies use today. A containerization orchestration platform will
    automatically launch and kill containers without needing direct human interaction.
    These platforms manage how containers are deployed and also handle the load balancing
    within the virtualized hardware, allocating hardware resources such as CPU and
    memory only when they are needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud platforms have made containerized applications possible for companies
    and other sorts of enterprises. Microsoft has massive hardware and networking
    capacity in its various Azure data centers around the world. So, if a containerized
    application needs a capacity of 1,000 machines one day, 200 the next, and 2,000
    the following day, Azure makes it possible so the company doesn’t have to deploy
    and decommission all of those machines on their own premises.
  prefs: []
  type: TYPE_NORMAL
- en: You will very likely be expected to pentest Docker- and Kubernetes-based applications
    in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: As AWS has its own ways of managing Docker and Kubernetes, so does Azure. Therefore,
    let’s learn about that.
  prefs: []
  type: TYPE_NORMAL
- en: How Docker works in Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can launch a Docker instance in Azure from your local computer using Docker
    Desktop, or directly from the Azure CLI. Docker Desktop requires you to install
    the Docker Desktop application on your computer ([https://docs.docker.com/cloud/aci-integration/](https://docs.docker.com/cloud/aci-integration/)),
    but it’s also possible to launch a Docker instance directly from Azure Cloud Shell
    (a way to access the Azure CLI) in your web browser. Personally, I prefer the
    latter option. That’s probably the most convenient way if you just want to launch
    Docker in the simplest way possible for testing purposes. If you were to launch
    Docker for a specialized business purpose and have more control over it, Docker
    Desktop may be the better option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s work from Azure Cloud Shell and use one of the Docker images Azure makes
    available by default (it’s also possible to acquire or create your own Docker
    images, but that’s not necessary for the exercises in this book; a Docker image
    is like a disk image used in conventional VMs but specialized for a container):'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Azure account we set up in the previous chapter, from your web
    browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The native way to deploy Docker in Azure is to use Azure Container Instances,
    which is a serverless service. There is technically a server, but Azure manages
    it, not you! That’s what will be running in the background while you follow these
    instructions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the blue menu bar at the top of the web page, go to the first icon to the
    right of the search bar. It should look something like **>_**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on it to launch Azure Cloud Shell. From there, we’ll work in Bash instead
    of PowerShell because that’s what the pentesting tools in this chapter use. Choose
    **Bash** from the top bar of the Azure Cloud Shell screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, make sure you have the necessary version of the Azure CLI. Input the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As long as you’ve got version 2.0.55 or later, you’re good to go. I have version
    2.50.0, so I don’t need to upgrade. If you do need to upgrade, input the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Containers in Azure use a resource group in order to manage Azure’s resources
    for your purposes. Let’s set one up. Input this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**eastus** can be replaced by whichever Azure data center region name you’d
    like. For instance, you could choose **canadacentral**, **brazilsouth**, or **westus**
    if you want.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we need to create a container! For the purposes of the exercises in this
    chapter, using one of Microsoft’s default Docker container images is fine. Do
    so with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure that the name of your resource group is the same name you created
    in the previous command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you can verify your container’s status to see whether all that worked!
    Enter this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If all of that worked, something like this will be printed on the command line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If not, start all over again from the **create resource group** command. Now,
    we have a Docker instance running that we can test our pentesting skills in! Congratulations!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There’s just one last command that’s very useful to pentest your new Docker
    instance. A lot of the vulnerability data we can mention in a pentest report comes
    from logging. You can use the following command to pull container instance logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You will get a message on the command line that says **listening on port 80**
    (the TCP/IP port for HTTP), and eventually, you will see HTTP **GET** requests
    displayed on the command line as they are made for your Docker instance from your
    computer or other computers on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can remove your Docker container with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s move on to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: How Kubernetes works in Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure has services that are specifically designed to deploy Kubernetes! Azure
    Kubernetes Service ([https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes](https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes))
    makes deploying Kubernetes containerization on Azure’s platform easy.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is the most popular containerization orchestration platform today.
    However, here’s a fact that may confuse some newcomers – Kubernetes expands on
    some of the technologies that were pioneered by Docker. It’s also possible to
    run Docker containers in Kubernetes! So, Docker and Kubernetes are often intertwined
    in enterprise DevOps and CI/CD applications that run in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we deployed a purely Docker-based containerization
    system, with Azure’s serverless Azure Container Instances service running in the
    background to support it all. Now, we will deploy containerization in Azure Kubernetes
    Service.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes has a very particular architecture (as discussed in [*Chapter 6*](B18672_06.xhtml#_idTextAnchor101)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes architecture is the same regardless of the cloud platform.
  prefs: []
  type: TYPE_NORMAL
- en: At the base of a Kubernetes deployment is the control plane. That’s the parent
    of everything else that runs on top of it. It features an API server to manage
    connections to external applications, and a controller manager. We will give it
    commands through *kubectl*, the Kubernetes CLI.
  prefs: []
  type: TYPE_NORMAL
- en: The control plane’s children are *Nodes*. They share compute, network, and storage
    resources. The children of Nodes are *Pods*, and the children of Pods are the
    *individual containers*. So, think of it this way – containers are the great-grandparents
    of containers.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are the most dynamic component; they change most frequently. They’re
    generated responsively from container images, according to whatever an application
    needs at the time. They contain only the configuration files, libraries, and dependencies
    that are required for the code they execute to run. That’s because the Nodes handle
    the load balancing of hardware resources, and the control plane has ultimate control
    over everything and is also the gateway to systems outside of your Kubernetes
    containerization system.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to sound like you’re a real Kubernetes expert, call it *K8s*. That’s
    the nickname Kubernetes developers and administrators have given it. However,
    I prefer to call it by its formal name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let’s deploy Kubernetes in our Azure network! We can use it for pentesting
    later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to launch Azure Cloud Shell again. From the blue menu bar at
    the top of the web page, go to the first icon to the right of the search bar.
    It should look something like **>_**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on it to launch Azure Cloud Shell. From there, we’ll work in Bash instead
    of PowerShell. Choose **Bash** from the top bar of the Azure Cloud Shell screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, make sure you have the right version of the Azure CLI. Use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As long as you have version 2.0.55 or later, you’re good to go. Otherwise,
    enter this command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While working with Kubernetes at the Azure CLI, I learned that I needed to create
    a service principal with access to my container registry first so that everything
    else would work properly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Copy this script, and paste it into a text editor, such as Notepad. Replace
    where it says **$containerRegistry** with a name of your choice (e.g., **acrKim**).
    Replace **$servicePrincipal** with a name of your choice (e.g., **KIM_KUBERNETES**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If yours won’t be thrown away soon, change your password to something complex
    with a lot of random characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can finally deploy our Kubernetes cluster! Replace **kimAKSCluster**
    with a cluster name of your choice. Replace **acrKim** with the ACR name you used
    in the **ACR_REGISTRY_ID=$(az acr show --name $acrKim --query "id" --output tsv)**
    line of the previous script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After a few minutes, a JSON output will display confirmation of the metrics
    of your Azure Kubernetes Service deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Kubernetes CLI, otherwise known as *kubectl*, is already installed in Azure
    Cloud Shell.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we need to connect to our Kubernetes cluster with kubectl. Enter the
    following command, but replace **myResourceGroup** with the resource group name
    you used previously, and replace **kimAKSCluster** with the cluster name you used
    previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can verify that everything worked and our Nodes are running. Input
    this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have a vanilla Docker instance in Azure using Azure Container Instances,
    and a basic Kubernetes instance using Azure Kubernetes Service.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we’ll run some vulnerability scans and pentest scripts
    in those instances. This is the fun stuff!
  prefs: []
  type: TYPE_NORMAL
- en: Docker and Kubernetes pentesting techniques in Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s explore some tools to pentest containers in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: kube-hunter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first pentesting application we’ll try is **kube-hunter** by Aqua Security
    on GitHub. The introduction in the kube-hunter **README** file at [https://github.com/aquasecurity/kube-hunter/blob/main/README.md](https://github.com/aquasecurity/kube-hunter/blob/main/README.md)
    states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“kube-hunter hunts for security weaknesses in Kubernetes clusters. The tool
    was developed to increase awareness and visibility for security issues in Kubernetes
    environments. You should NOT run kube-hunter on a Kubernetes cluster that you*
    *don’t own!”*'
  prefs: []
  type: TYPE_NORMAL
- en: Absolutely! That’s why we set up our own Kubernetes cluster in our own Azure
    services in this chapter. When you’re actually doing paid work as a pentester,
    you will need signed legal permission from the company that owns the Azure network
    and Kubernetes instance.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of different kinds of scans you can do with kube-hunter. First,
    let’s install it. Then, we’ll run a quick scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s clone the **git** repository for kube-hunter with this command in Bash
    within Azure Cloud Shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’ll install its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'kube-hunter is a Python application, so we can launch it with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s another installation method that I like to use. It uses the **pip**
    repositories. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you installed kube-hunter that way, you could launch it with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run kube-hunter while specifying a certain log level. Try this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That will output the **WARNING** level logs. Those are the events you should
    really pay attention to, which can be very useful to mention in your pentest report.
    Alternatively, you can output **DEBUG** logs with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The default when you launch kube-hunter is to log **INFO**-level events. If
    you changed the logging to **WARNING** or **DEBUG** and you’d like to switch back
    to **INFO**, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we’re working in our own Kubernetes instance for educational purposes, feel
    free to play around with the different logging options.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run a quick scan with the **kube-hunter** command, this is what will
    output at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Running kube-hunter in Azure](image/B18672_09_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Running kube-hunter in Azure
  prefs: []
  type: TYPE_NORMAL
- en: So, then, you enter **1**, **2**, or **3** for the type of scanning you’d like
    to execute. If you use options **1** or **3**, you will need to enter IP addresses
    at the following prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'I often forget about the IP addresses that I use with my Azure instance when
    I’m playing around. We’re in Bash, so the simplest way to check your IP addresses
    in Azure is with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Something like this should output at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The ifconfig command in Azure](image/B18672_09_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – The ifconfig command in Azure
  prefs: []
  type: TYPE_NORMAL
- en: Yes, I know the character **X** isn’t used in IPv4 or IPv6 IP addresses. I replaced
    some of the characters in my IP addresses for the sake of operational security.
    You can never be too careful!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also install and run kube-hunter inside Docker containers! Install
    kube-hunter in Docker with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, kube-hunter outputs the logs from all of your scans through an
    entity called **stdout**. Therefore, you can find your logs through the Azure
    Monitor interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to your Azure account interface at [portal.azure.com](https://portal.azure.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the blue menu bar at the top, enter **Monitor** in the search bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left-hand side, there’s a list of sections under **Monitor**, such as
    **Overview** and **Activity log**. Click on **Activity log**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screen will show your logs like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Activity log in Azure](image/B18672_09_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Activity log in Azure
  prefs: []
  type: TYPE_NORMAL
- en: Your actions in kube-hunter will be recorded there. My actions produced a lot
    of entries named **List Storage Account Keys**. That’s the sort of sensitive information
    kube-hunter was looking for!
  prefs: []
  type: TYPE_NORMAL
- en: Explore the kube-hunter documentation ([https://aquasecurity.github.io/kube-hunter/](https://aquasecurity.github.io/kube-hunter/))
    to find out other things you can do.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s try *kdigger*.
  prefs: []
  type: TYPE_NORMAL
- en: kdigger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**kdigger** is a multipurpose Kubernetes pentesting tool. It’s capable of *digging*
    around in your Kubernetes instance to see which entities it can find. Of course,
    being able to fingerprint and enumerate a containerization deployment is a very
    dangerous ability for a cyber threat actor to have, as they’ll then know how to
    proceed with their attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: The data you acquire from using kdigger can also be used to conduct better-informed
    pentests in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'kdigger can also be used for fuzzing. That means inputting invalid, unexpected,
    or random data into an application to see whether it’s breakable. If the application
    is designed to validate inputs and handle exceptions in code, it won’t be susceptible
    to fuzzing attacks. To learn how to use kdigger for fuzzing and other possibilities,
    check out their documentation: [https://github.com/quarkslab/kdigger](https://github.com/quarkslab/kdigger).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s install kdigger and do some digging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your configuration, you may find one of these two installation
    methods works best:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method is the default Git source technique:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you need to move your binary into a working directory in your path:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That method will require you to remember your **sudo** password.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This simpler installation method uses **go**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s give kdigger a try!
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the directory where your Pods are and where kdigger is installed.
    When I get lost in Bash, I enter this command to list the contents of my current
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And then I enter this command to change to the directory that I’m looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’re in the directory that kdigger is installed in, you can do a general
    scan with a very simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For me, this is what was outputted at the command line. I have replaced some
    characters in the DNS names and IP addresses with **X** for operational security
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to scan all the buckets, try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can mention any exposed Kubernetes entities that kdigger found in your pentest
    report.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Organizations often deploy containerization on their cloud platforms because
    it is a very responsive and dynamic way to use virtualization to implement rapidly
    scalable and ever-evolving applications, using DevOps or CI/CD methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: A container contains just the parts of an operating system that are required
    to execute the code it processes. The load balancing and managing of hardware
    resources are done by the parent, grandparent, or great-grandparent of the containers
    within the containerization platform.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know how to deploy Docker and Kubernetes containerization instances
    in Azure and test them for security vulnerabilities. Docker and Kubernetes are
    two of the most used containerization platforms. Kubernetes basically extends
    Docker’s features further and can even work with Docker images and containers.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, I’ll introduce you to Google Cloud Platform and its
    various services.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics covered in this chapter, you can visit the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Deploy a container instance in Azure using the Azure* *CLI*: [https://learn.microsoft.com/en-us/azure/container-instances/container-instances-quickstart](https://learn.microsoft.com/en-us/azure/container-instances/container-instances-quickstart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*What is Azure Kubernetes* *Service?*: [https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes](https://learn.microsoft.com/en-us/azure/aks/intro-kubernetes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*kube-hunter* *documentation*: [https://aquasecurity.github.io/kube-hunter/](https://aquasecurity.github.io/kube-hunter/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*kdigger* *documentation*: [https://github.com/quarkslab/kdigger](https://github.com/quarkslab/kdigger)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 4:Pentesting GCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GCP** is **Google’s Cloud Platform**! However, those in the know use the
    acronym. In this part, we will learn about GCP’s various software-as-a-service,
    platform-as-a-service, and infrastructure-as-a-service applications. We will deploy
    our own GCP instance in which to test our pentesting skills. We will use Security
    Command Center to check the security posture of our GCP deployment. We will also
    try out some pentesting tools in GCP, step by step. Then, we’ll deploy Docker
    and Kubernetes containers and test those as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18672_10.xhtml#_idTextAnchor172), *Security Features in GCP*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18672_11.xhtml#_idTextAnchor197), *Pentesting GCP Features
    through Serverless Applications and Tools*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18672_12.xhtml#_idTextAnchor215), *Pentesting Containerized
    Applications in GCP*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
