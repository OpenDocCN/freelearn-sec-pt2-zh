<html><head></head><body>
		<div id="_idContainer079">
			<h1 id="_idParaDest-215" class="chapter-number"><a id="_idTextAnchor215"/>12</h1>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor216"/>Pentesting Containerized Applications in GCP</h1>
			<p>If the organization you work for engages in DevOps or CI/CD application development, there’s an excellent chance that they have Docker or Kubernetes clusters in GCP. Let’s learn how to <span class="No-Break">pentest them.</span></p>
			<p>In this chapter, I will explain what containerization is, why containerization is used, and how containerization works in general. We’ll learn how Docker and Kubernetes work in GCP and how to use Trivy with Docker- and Kubernetes-based applications <span class="No-Break">in GCP.</span></p>
			<p>In this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>How <span class="No-Break">containerization works</span></li>
				<li>How Docker works <span class="No-Break">in GCP</span></li>
				<li>How Kubernetes works <span class="No-Break">in GCP</span></li>
				<li>Docker and Kubernetes pentesting techniques <span class="No-Break">in GCP</span></li>
			</ul>
			<p>So, let’s explore containerization <span class="No-Break">in GCP!</span></p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor217"/>Technical requirements</h1>
			<p>We will work with Microsoft’s infrastructure. Massive Azure data centers will do the bulk of the computer processing work for the exercises in this chapter. So, fortunately, you don’t need to have a top-of-the-line workstation. You will need <span class="No-Break">the following:</span></p>
			<ul>
				<li>A <span class="No-Break">web browser</span></li>
				<li>A desktop or <span class="No-Break">laptop PC</span></li>
				<li>An Android or <span class="No-Break">iPhone mobile</span></li>
				<li>A good, reliable <span class="No-Break">internet connection</span></li>
			</ul>
			<p>Check out the following video to view the Code in Action:  <a href="https://bit.ly/404CEg8"><span class="No-Break">https://bit.ly/404CEg8</span></a></p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor218"/>How containerization works</h1>
			<p>Virtualization in computing is all about software simulating the functions of hardware. For example, my laptop is one computer. But on my computer, I can run software that pretends to be <a id="_idIndexMarker999"/>several different computers at the same time. (Thank goodness I expanded the RAM in my laptop to 64 GB, because each of those simulated computers could need 4 GB of memory!) The CPU, RAM, disk drive, and I/O device interfaces for each of those computers are simulated in the software. The software uses my laptop’s real CPU, RAM, disk drive, and I/O interfaces and allocates their capacity to make several imaginary computers. When operating systems and applications are installed in those imaginary computers, as far as the operating systems and applications know, they are each running on their own <span class="No-Break">physical computer.</span></p>
			<p>There are two common ways to deploy virtualization on cloud networks—VMs <span class="No-Break">and containers.</span></p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor219"/>VMs</h2>
			<p>VMs are simulated computers, as I described in my example. Instead of directly running on PC or <a id="_idIndexMarker1000"/>server machine hardware, a VM imitates all of the hardware components that are needed to run an operating system. In this model, my laptop runs a hypervisor that acts as a layer between the VMs and my <span class="No-Break">physical computer.</span></p>
			<p>You can use an application on your own PC, such as Oracle VirtualBox or VMware Workstation Player, to work as a hypervisor for your VMs. All you need is a disk image file of an operating system you’d like to run in your VM, and then to configure it in your hypervisor. The operating systems don’t have to match your host operating system, and very often they don’t. I could run a Kali Linux VM on my Windows 11 PC. You could run a Windows 11 VM on your MacBook. And I could run a macOS VM on my Kubuntu <span class="No-Break">Linux desktop.</span></p>
			<p>VMs can also be run on cloud platforms such as GCP. Then, the virtualized computer is running on one of Google’s computers, not on a computer you can physically touch on your own premises. VMs are a common use case for GCP, and they’re a good solution when a company wants to run single computers on GCP for a long time, such as to use as a web server or an email server. A lot of the websites you visit every day are hosted on VMs run on cloud platforms such <span class="No-Break">as GCP!</span></p>
			<p>But VMs aren’t the best option when companies deploy massive dynamic applications, such as with DevOps or CI/CD methodologies that require them to be very scalable and responsive. The amount of computer processing power, memory, and network bandwidth a DevOps or CI/CD application <a id="_idIndexMarker1001"/>requires could halve one day and double the next, whereas you can’t grow or shrink a VM’s hardware capacity as quickly or to the same extent. The hardware resources allocated to a VM are <span class="No-Break">relatively static.</span></p>
			<p><span class="No-Break">Enter containerization.</span></p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor220"/>Containers</h2>
			<p>Docker and Kubernetes are two containerization orchestration platforms commonly used by <a id="_idIndexMarker1002"/>companies today. A containerization orchestration platform will automatically launch and kill containers without needing direct human interaction. These platforms manage how containers are deployed, and also handle the load balancing within the virtualized hardware, allocating hardware resources such as CPU and memory only as much as <span class="No-Break">is needed.</span></p>
			<p>Cloud platforms have made containerized applications possible for companies and other sorts of enterprises. Google has massive computer networks and computer hardware resources in its various data centers around the world, a lot of which is dedicated to deploying GCP to its business customers all over <span class="No-Break">the world.</span></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor221"/>How Docker works in GCP</h1>
			<p>Docker isn’t the first containerization technology to exist, but it’s probably the first to be widely used <a id="_idIndexMarker1003"/>by companies and organizations around the world. It also serves as the foundation for Kubernetes, the other popular way to deploy containers. Docker <a id="_idIndexMarker1004"/>and Kubernetes aren’t competitors like Coca-Cola and Pepsi. Rather, Kubernetes is kind of a fork of Docker, like comparing Debian Linux to Ubuntu Linux (which is based <span class="No-Break">on Debian).</span></p>
			<p>Here’s the basic architecture of a Docker containerization orchestration system (you can refer to <a href="B18672_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> for the <span class="No-Break">architecture diagram).</span></p>
			<p>The Docker host <a id="_idIndexMarker1005"/>runs directly on your computer or on the computer you manage on a cloud service (such as <strong class="bold">Google Compute Engine</strong>, or <strong class="bold">GCE</strong>). In the Docker host, the Docker daemon stores Docker images and makes and manages containers based on those images. Docker images are very much like disk image ISO files for operating systems that you can use to make VMs. In fact, many Docker images are made with ordinary operating systems such as Ubuntu Linux. However, the images and their containers may not have all of the operating system components, but only as much as is needed to run your <span class="No-Break">containerized application.</span></p>
			<p>The Docker host connects to a registry, which is usually (but not always) hosted on an external network that’s most often the internet. The registry makes Docker images available for your Docker host to download. The registry also maintains those images and updates them like any other internet-hosted software, kind of like a <span class="No-Break">Git repository.</span></p>
			<p>Finally, a Docker client running in a place such as your GCP console or on your endpoint in Docker <a id="_idIndexMarker1006"/>Desktop is where you can execute commands to your Docker daemon (under the umbrella of your Docker host) in order to manage it. That’s how <a id="_idIndexMarker1007"/>you send instructions to your Docker containerization orchestration system. We will be executing commands that way to a Docker system in <span class="No-Break">this chapter.</span></p>
			<p>The default way to deploy a Docker containerization system in GCP uses Cloud Build to simplify the Docker build steps, and Cloud Run to help run containerized apps, all while your Docker host runs <span class="No-Break">in GCE.</span></p>
			<p>Here’s Google’s <a id="_idIndexMarker1008"/>description of Cloud <span class="No-Break">Build (</span><a href="https://cloud.google.com/build"><span class="No-Break">https://cloud.google.com/build</span></a><span class="No-Break">):</span></p>
			<p class="author-quote">“<em class="italic">Cloud Build scales up and down with no infrastructure to set up, upgrade, or scale. Run builds in a fully managed environment in Google Cloud with connectivity to your own private network</em>.”</p>
			<p>Cloud Build is a system that runs in the background when you deploy Docker containerization in GCP in the usual way. It spares developers the tedium of having to manage the servers that run your <span class="No-Break">Docker containers.</span></p>
			<p>And here’s Google’s <a id="_idIndexMarker1009"/>description of Cloud <span class="No-Break">Run (</span><a href="https://cloud.google.com/run/docs/overview/what-is-cloud-run"><span class="No-Break">https://cloud.google.com/run/docs/overview/what-is-cloud-run</span></a><span class="No-Break">):</span></p>
			<p class="author-quote">“<em class="italic">Cloud Run allows developers to spend their time writing their code, and very little time operating, configuring, and scaling their Cloud Run service. You don’t have to create a cluster or manage infrastructure in order to be productive with Cloud Run</em>.”</p>
			<p>Cloud Run is another system that runs in the background when you deploy Docker containerization in the usual way in GCP. It spares developers from having to tweak the computer processing configurations that execute their <span class="No-Break">Docker containers.</span></p>
			<p>Now that we’ve looked at Docker in GCP, it’s time to learn about how Kubernetes works <span class="No-Break">in GCP.</span></p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor222"/>How Kubernetes works in GCP</h1>
			<p>Kubernetes can <a id="_idIndexMarker1010"/>be used to deploy containerized applications <a id="_idIndexMarker1011"/>in AWS and Azure. In <em class="italic">Chapters 6</em> and <em class="italic">9</em>, I walked you through deploying Kubernetes on those platforms, and we pentested them. But GCP is arguably the home of Kubernetes. <span class="No-Break">Here’s why.</span></p>
			<p>Kubernetes was originally developed by a team at Google. The Kubernetes project was announced by Google cloud computing specialist Eric Brewer in 2014 (<a href="https://web.archive.org/web/20150910171929/http:/www.wired.com/2014/06/google-kubernetes">https://web.archive.org/web/20150910171929/http:/www.wired.com/2014/06/google-kubernetes</a>). Kubernetes was inspired by some of the containerization innovations pioneered by Docker. But Kubernetes was mainly influenced by Borg (<a href="https://web.archive.org/web/20160701040235/http:/www.wired.com/2015/06/google-kubernetes-says-future-cloud-computing/">https://web.archive.org/web/20160701040235/http:/www.wired.com/2015/06/google-kubernetes-says-future-cloud-computing/</a>), which was proprietary in-house cloud computing middleware that Google wanted to keep for its own purposes. Borg helps to run the backend for Gmail, Google Search, Google Maps, and a number of other popular <span class="No-Break">Google services.</span></p>
			<p>Google’s Joe Beda, Brendan Burns, Brian Grant, Tim Hockin, and Craig McLuckie conceived of Kubernetes as being an open source platform that could be used for many of the same use cases Google deployed for Borg internally. By July 2015, the first version of Kubernetes was publicly released. By 2017, big tech companies and software developers including Red Hat (IBM), VMware, Docker, Inc., Microsoft Azure, and AWS all announced <a id="_idIndexMarker1012"/>support for it. That’s the beauty of <strong class="bold">open source software</strong> (<strong class="bold">OSS</strong>) and open standards! And just as some organizations have multi-cloud networks that integrate services from AWS, Azure, and GCP, some organizations have both Docker and Kubernetes <span class="No-Break">containerized applications.</span></p>
			<p>Here’s the basic architecture of a Kubernetes containerization orchestration system (you can refer to <a href="B18672_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> for the <span class="No-Break">architecture diagram).</span></p>
			<p>The control plane supports the entire containerization system and works as the vector between <a id="_idIndexMarker1013"/>your Kubernetes-based network and the cloud platform, such as <strong class="bold">Google Kubernetes Engine</strong> (<strong class="bold">GKE</strong>) in GCP. The control plane contains <a id="_idIndexMarker1014"/>a handful of components, including those <span class="No-Break">listed here:</span></p>
			<ul>
				<li><strong class="source-inline">etcd</strong> is a key-value store. It maintains data about all of <span class="No-Break">your clusters.</span></li>
				<li>Pods run with the support of nodes, and <strong class="source-inline">kube-scheduler</strong> assigns nodes to newly <span class="No-Break">created Pods.</span></li>
				<li><strong class="source-inline">kube-apiserver</strong> manages the Kubernetes API. So, it helps your Kubernetes-based application <a id="_idIndexMarker1015"/>integrate with external applications. It’s also where <strong class="source-inline">kubectl</strong> (<strong class="bold">ctl</strong> stands for <strong class="bold">command-line tool</strong>) connects to in order to send commands to your <span class="No-Break">Kubernetes system.</span></li>
				<li><strong class="source-inline">kube-controller-manager</strong> runs controller processes. There are controllers for maintaining nodes, controllers for executing scheduled jobs (such as “back up these files every day at 6 p.m.”), controllers to generate links between <a id="_idIndexMarker1016"/>services and Pods, and controllers to create <a id="_idIndexMarker1017"/>service accounts. Pods and nodes will be explained later in <span class="No-Break">this section.</span></li>
				<li><strong class="source-inline">cloud-controller-manager</strong> connects your Kubernetes network to your cloud provider’s APIs. In GCP, <strong class="source-inline">cloud-controller-manager</strong> usually interfaces <span class="No-Break">with GKE.</span></li>
				<li><em class="italic">Nodes</em> are the <a id="_idIndexMarker1018"/>control plane’s children. There could be 2 nodes, 20 nodes, or many different numbers of nodes according to what your application needs at any given time. Each node contains a kubelet. The kubelet is a node agent that registers the node with the API server using a hostname or another sort of identifier specific to the <span class="No-Break">cloud provider.</span></li>
				<li><em class="italic">Pods</em> are the <a id="_idIndexMarker1019"/>children of nodes, which also makes Pods the grandchildren of the control plane. The kubelet in each node defines the nodes according to a PodSpec, which is written as a YAML or JSON file. It helps to know that YAML is similar in some ways to HTML, and JSON was created for use with JavaScript—two technologies that were developed for the web. YAML and JSON files can be viewed in a text editor, and sometimes they only have a few lines of code. The vulnerability scans you’ll be running as a pentester and in your red team engagements will sometimes scan YAML and JSON files depending on the situation. But you don’t need to know how to write your own YAML or JSON files for the purposes of <span class="No-Break">this book.</span></li>
			</ul>
			<p>Each Pod has a container runtime in which your containers run. Containers are made from container images that are like the ISO disk images of operating systems that are used in VMs. But a Kubernetes container image will have just the operating system components <a id="_idIndexMarker1020"/>that are needed to execute the code that it’ll process. There are many default container images that can be used, and also, container <a id="_idIndexMarker1021"/>images are sometimes custom-made for a particular company and <span class="No-Break">its application.</span></p>
			<p>Finally, the nodes (which contain Pods) interface with a load balancer, which helps manage the hardware and network resources that are needed at any given time. The load balancer also provides an interface between your Kubernetes-based application and your <span class="No-Break">end users.</span></p>
			<p>As a cloud pentester, it helps to know that both the load balancer and the API servers can be vectors for cyber attacks on your Kubernetes application! The load balancer is most often subject to cyber attacks from an Ingress, north-south direction between your cloud and external networks, and the API servers are more often subject to attacks from an east-west direction between components within your cloud network. Sometimes, cyber attacks enter from the public internet through the ingress route and then travel between parts of a cloud network using lateral movement that may involve privilege escalation. That’s kind of like a burglar breaking into a department store’s jewelry department and then moving on to the fragrances <span class="No-Break">and cosmetics.</span></p>
			<p>The entire Kubernetes containerization system is called a cluster. Some organizations may deploy multiple clusters. But no matter how many clusters an organization uses, each cluster <a id="_idIndexMarker1022"/>is composed of a control plane, nodes, and Pods, in the order of bottom <span class="No-Break">to top.</span></p>
			<p>GKE (<a href="https://cloud.google.com/kubernetes-engine">https://cloud.google.com/kubernetes-engine</a>) is a GCP service that’s specially designed to run Kubernetes-based applications. It automates cluster and node management and how hardware resources are provisioned through the load balancer. The vast majority of the time, organizations both large and small will prefer to run Kubernetes applications in GCP <span class="No-Break">through GKE.</span></p>
			<p>The beauty of cloud computing and containerization is that applications can be made to be very scalable, dynamic, and efficient with hardware resources. A lot of the drudgery of application deployment and network management can be automated. So, it’s natural that organizations will prefer to use GKE so that they aren’t burdened with server management tasks. A containerized application in the cloud can literally double and halve within days. There should always be just as much computing power and bandwidth as <a id="_idIndexMarker1023"/>is needed at any given time, and containers <a id="_idIndexMarker1024"/>sometimes only have a lifespan <span class="No-Break">of hours.</span></p>
			<p>It’s no wonder that cloud computing has revolutionized how all kinds of organizations of all sizes and in all industries deploy applications through the internet. However, the containerized applications that organizations deploy through the cloud can be just as attractive targets to cyber attackers as VMs deployed through the cloud. They interface with the internet, which provides an access route for attackers. And they can contain sensitive information that can make cyber criminals a lot of money, such as sensitive <span class="No-Break">financial data.</span></p>
			<p>Your job as a cloud pentester is to make sure you discover how an attacker could harm your client’s cloud networks before an attacker tries to do it. That way, the company you work for can improve its <span class="No-Break">security accordingly.</span></p>
			<p>So, in the final set of hands-on pentesting exercises in this book, let’s get into pentesting Docker and Kubernetes <span class="No-Break">in GCP!</span></p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor223"/>Docker and Kubernetes pentesting techniques in GCP</h1>
			<p>Now that <a id="_idIndexMarker1025"/>we understand Docker and Kubernetes, let’s <a id="_idIndexMarker1026"/>deploy them in GCP. Then, we’ll pentest them. First, let’s <a id="_idIndexMarker1027"/>deploy the Docker <a id="_idIndexMarker1028"/>and Kubernetes clusters that we’ll practice <span class="No-Break">pentesting in.</span></p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor224"/>Deploying Docker</h2>
			<p>We will use basic default Docker container images in our Docker deployment because we’re not <a id="_idIndexMarker1029"/>doing anything fancy with it; we’re just trying out our pentesting tools! Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>The simplest way for us to deploy a Docker cluster in GCP is to start with Cloud Run. Use your web browser to log in to the Google Cloud account we set up in <a href="B18672_11.xhtml#_idTextAnchor197"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>. Once you’re in the GCP web console, go to <a href="https://console.cloud.google.com/run">https://console.cloud.google.com/run</a> to use <span class="No-Break">Cloud Run.</span><p class="list-inset">The Cloud Run screen should look something <span class="No-Break">like this:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B18672_12_01.jpg" alt="Figure 12.1 – Cloud Run panel in the GCP console"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Cloud Run panel in the GCP console</p>
			<ol>
				<li value="2">Click on <strong class="bold">+CREATE SERVICE</strong> at the top, just underneath the top menu bar. You’ll see a screen that looks <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B18672_12_02.jpg" alt="Figure 12.2 – Creating a Cloud Run service in GCP to run Docker"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Creating a Cloud Run service in GCP to run Docker</p>
			<p class="list-inset">We will be <a id="_idIndexMarker1030"/>using as many defaults as possible just to create a basic Docker environment to try our pentesting tools in. In situations where you may want to deploy a particular type of application with Docker containers, you may have to use different settings in <span class="No-Break">Cloud Run.</span></p>
			<p class="list-inset">To keep it simple, these are the options I chose for my Docker deployment in <span class="No-Break">Cloud Run:</span></p>
			<ul>
				<li>At the top where it provides the <strong class="bold">Deploy one revision from an existing container image</strong> and <strong class="bold">Continuously deploy new revisions from a source repository options</strong>, I chose the <span class="No-Break">first option.</span></li>
				<li>Next, instead of entering a container image URL, I clicked on <strong class="bold">TEST WITH A </strong><span class="No-Break"><strong class="bold">SAMPLE CONTAINER</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p class="list-inset">On this screen, I clicked <a id="_idIndexMarker1031"/>on the <strong class="bold">CONTAINER REGISTRY</strong> tab and chose the <strong class="source-inline">hello</strong> demo container. Then, I clicked on <strong class="bold">SELECT</strong> next to the container <span class="No-Break">image URL:</span></p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B18672_12_03.jpg" alt="Figure 12.3 – Choosing a Docker image for our Docker instance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Choosing a Docker image for our Docker instance</p>
			<ul>
				<li>In the <strong class="bold">Service name</strong> field, I entered <strong class="source-inline">crawleydockertest</strong>. I left my default region, which in my case is <strong class="bold">us-central1 (lowa)</strong>. Your default region might be something else. Each region represents a particular Google data center, and it may not even be in <span class="No-Break">your country.</span></li>
				<li>To save money, under <strong class="bold">CPU allocation and pricing</strong>, I chose <strong class="bold">CPU is only allocated during </strong><span class="No-Break"><strong class="bold">request processing</strong></span><span class="No-Break">.</span></li>
				<li>I left the <strong class="bold">Autoscaling</strong> option alone. By default, <strong class="bold">0</strong> is the minimum number of instances and <strong class="bold">100</strong> is the maximum. This sort of setting reflects the scalable nature <a id="_idIndexMarker1032"/>of cloud applications. New instances can be automatically generated according to your <span class="No-Break">application’s needs.</span></li>
				<li>Under <strong class="bold">Ingress control</strong>, I selected <strong class="bold">All</strong>, which will allow direct access to your service from <span class="No-Break">the internet.</span></li>
				<li>Under <strong class="bold">Authentication</strong>, I chose <strong class="bold">Allow unauthenticated invocations</strong>. These options may not be the best practices for cybersecurity, but they make trying out pentesting tools in our Docker application a <span class="No-Break">lot easier.</span></li>
			</ul>
			<ol>
				<li value="3">Finally, I clicked on the blue <strong class="bold">CREATE</strong> button at <span class="No-Break">the bottom.</span><p class="list-inset">Your web console screen will look like this as your service is created. The creation process took about 30 seconds for me; I wasn’t waiting <span class="No-Break">very long:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B18672_12_04.jpg" alt="Figure 12.4 – Creating a service for our Docker instance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Creating a service for our Docker instance</p>
			<p>Now that our <a id="_idIndexMarker1033"/>Docker environment has been created in GCP, it’s time to make a <span class="No-Break">Kubernetes environment!</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor225"/>Deploying Kubernetes</h2>
			<p>It’s possible to deploy Kubernetes in Cloud Shell or in some other CLI. But I prefer to use the web <a id="_idIndexMarker1034"/>console for deploying services and to use the CLI for pentesting tools. Follow the next steps to <span class="No-Break">deploy Kubernetes:</span></p>
			<ol>
				<li>While logged in to GCP from the web and in the web console, go <span class="No-Break">to </span><a href="https://console.cloud.google.com/projectselector2/home/dashboard"><span class="No-Break">https://console.cloud.google.com/projectselector2/home/dashboard</span></a><span class="No-Break">.</span></li>
				<li>For the time being, leave the project selector you just opened in one web browser tab. Open <strong class="bold">Enable access to APIs</strong> in another tab while using this <span class="No-Break">link: </span><a href="https://console.cloud.google.com/flows/enableapi?apiid=artifactregistry.googleapis.com,container.googleapis.com"><span class="No-Break">https://console.cloud.google.com/flows/enableapi?apiid=artifactregistry.googleapis.com</span></a><span class="No-Break">.</span><p class="list-inset">You will <a id="_idIndexMarker1035"/>see a screen <span class="No-Break">like this:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B18672_12_05.jpg" alt="Figure 12.5 – Enabling the required API access for Kubernetes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Enabling the required API access for Kubernetes</p>
			<ol>
				<li value="3">Click on <strong class="bold">Confirm project</strong>. <strong class="bold">Enable APIs</strong> will transition and say that you’re about to enable <strong class="bold">Artifact Registry API</strong> and <strong class="bold">Kubernetes Engine API</strong>. That’s exactly what we want to do. Click <span class="No-Break">on </span><span class="No-Break"><strong class="bold">ENABLE</strong></span><span class="No-Break">.</span></li>
				<li>You may have to wait a few moments for your enabling of those APIs to process. I was surprised that this took more time than creating my Docker test container. But when that’s done, go back to your web browser tab with the project selector dashboard. That’ll look something <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B18672_12_06.jpg" alt="Figure 12.6 – Selecting a project in GCP for our Kubernetes instance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Selecting a project in GCP for our Kubernetes instance</p>
			<ol>
				<li value="5">Click on <a id="_idIndexMarker1036"/>a project. Make note of your project ID; it should be something similar to <strong class="source-inline">blissful-axiom-115916</strong>, as in the <span class="No-Break">preceding screenshot.</span></li>
				<li>Now, we will do the rest of the work in Cloud Shell in the CLI. Click on the icon that looks like this in the top menu bar on the right-hand <span class="No-Break">side: </span><span class="No-Break"><strong class="bold">&gt;_</strong></span><span class="No-Break">.</span></li>
				<li>First, we’ll make sure that our selected project is the default by entering this at the <span class="No-Break">command line:</span><pre class="source-code">
<strong class="bold">gcloud config set project &lt;your project ID goes here&gt;</strong></pre></li>				<li>Next, we’ll create a default autopilot Kubernetes cluster with this command. If the region you set up earlier isn’t <strong class="source-inline">us-central1</strong>, then change it to the name of <span class="No-Break">your region:</span><pre class="source-code">
<strong class="bold">gcloud container clusters create-auto hello-cluster \</strong>
<strong class="bold">    --location=us-central1</strong></pre><p class="list-inset">As you can see in the <em class="italic">Code in Action</em> video of this exercise, it may take a few minutes for your cluster to be created. Be patient! Thankfully the command line in Cloud Shell will show you what’s going on while <span class="No-Break">you wait.</span></p></li>				<li>After the several-minute process of creating your Kubernetes cluster is done, you next need to <a id="_idIndexMarker1037"/>create authentication credentials for your cluster. This will make <strong class="source-inline">kubectl</strong> (the program you use to manage your Kubernetes cluster at the command line) ready to use your new cluster. Just be sure to change <strong class="source-inline">us-central1</strong> to the name of your region if <span class="No-Break">it’s different:</span><pre class="source-code">
<strong class="bold">gcloud container clusters get-credentials hello-cluster \</strong>
<strong class="bold">   --location us-central1</strong></pre></li>				<li>Next, we’re going to create an application deployment in our new Kubernetes cluster with the following command. The directory path after <strong class="source-inline">image=</strong> is our default <strong class="source-inline">hello</strong> Kubernetes container image for testing purposes. If you want to do something specific with Kubernetes in GCP at some point after reading this book, you can modify the command to use a different <span class="No-Break">container image:</span><pre class="source-code">
<strong class="bold">kubectl create deployment hello-server \</strong>
<strong class="bold">    --image=us-docker.pkg.dev/google-samples/containers/gke/hello-app:1.0</strong></pre></li>				<li>Now, we need to set up the load balancer so that we can expose our deployment to the internet. We will be accessing our Kubernetes deployment through the internet in order to pentest it, so this step is <span class="No-Break">absolutely necessary:</span><pre class="source-code">
<strong class="bold">kubectl expose deployment hello-server \</strong>
<strong class="bold">    --type LoadBalancer \</strong>
<strong class="bold">    --port 80 \</strong>
<strong class="bold">    --target-port 8080</strong></pre></li>				<li>Finally, we need to run some checks to make sure our new Kubernetes Deployment is ready to use. First, let’s inspect <span class="No-Break">the Pods:</span><pre class="source-code">
<strong class="bold">kubectl get pods</strong></pre><p class="list-inset">The command line should show a <span class="No-Break"><strong class="source-inline">hello-server</strong></span><span class="No-Break"> Pod.</span></p></li>				<li>Now, we’ll <span class="No-Break">inspect </span><span class="No-Break"><strong class="source-inline">hello-server</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">kubectl get service hello-server</strong></pre></li>				<li>Copy the external IP that prints at the <span class="No-Break">command line.</span></li>
				<li>In a new web browser tab, enter <strong class="source-inline">http://&lt;your external IP here&gt;</strong> in the address bar and <span class="No-Break">hit </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li>
				<li>My external <a id="_idIndexMarker1038"/>connection to my Kubernetes Deployment was slow. But it eventually worked. I got an error in Firefox that warned me that the destination was HTTP and not HTTPS. I clicked the button to go to the HTTP site, and my screen showed this. <span class="No-Break">It worked!</span></li>
			</ol>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B18672_12_07.jpg" alt="Figure 12.7 – Viewing the IP address for our Kubernetes Deployment in a web browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Viewing the IP address for our Kubernetes Deployment in a web browser</p>
			<p>Now that we have both a working Docker environment and a working Kubernetes environment in GCP, it’s time to use those environments to try out some <span class="No-Break">pentesting tools.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor226"/>Trivy</h2>
			<p>Trivy (<a href="https://github.com/aquasecurity/trivy">https://github.com/aquasecurity/trivy</a>) is a pentesting tool that’s developed by Aqua Security <a id="_idIndexMarker1039"/>and available on GitHub. It’s a security scanner that can find vulnerabilities in filesystems, VM images, and AWS. But it can also be used to scan Docker and <span class="No-Break">Kubernetes images.</span></p>
			<p>Trivy can be run from Red Hat and CentOS, Arch Linux, and macOS. The installation instructions for all supported platforms can be found here: <a href="https://aquasecurity.github.io/trivy/v0.44/getting-started/installation/">https://aquasecurity.github.io/trivy/v0.44/getting-started/installation/</a>. The Linux VM I have running in my GCP deployment is based on Debian, so I’ll use the Debian <span class="No-Break">installation instructions:</span></p>
			<pre class="console">
wget https://github.com/aquasecurity/trivy/releases/download/v0.44.1/
trivy_0.44.1_Linux-64bit.deb
sudo dpkg -i trivy_0.44.1_Linux-64bit.deb</pre>			<p>Now that we have Trivy installed on our Linux VM in GCP, let’s try a couple of basic container scanning exercises. Trivy users and developers have a wide range of container pentesting tutorials on their website (<a href="https://aquasecurity.github.io/trivy/v0.45/tutorials/overview/">https://aquasecurity.github.io/trivy/v0.45/tutorials/overview/</a>) if you’d like to try <span class="No-Break">some others.</span></p>
			<p>Let’s try looking for misconfigurations in how I configured my Docker image. Remember—misconfigurations are security vulnerabilities that can be exploited by cyber attackers! Follow the <span class="No-Break">next steps:</span></p>
			<ol>
				<li>I used GCP’s default <strong class="source-inline">hello</strong> test Docker image to build my Docker containers. This is its name <span class="No-Break">and address:</span><pre class="source-code">
us-docker.pkg.dev/cloudrun/container/hello</pre></li>				<li>You will need to verify the name and address of the image you used. In your GCP console, search for <strong class="source-inline">Cloud Run</strong>. You will then see a screen <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B18672_12_08.jpg" alt="Figure 12.8 – Viewing our Docker instance in the Cloud Run interface"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Viewing our Docker instance in the Cloud Run interface</p>
			<ol>
				<li value="3">I clicked on <a id="_idIndexMarker1040"/>the name of my Docker cluster, which in my case <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">crawleydockertest</strong></span><span class="No-Break">.</span><p class="list-inset">Then, I clicked on the <strong class="bold">YAML</strong> tab to see the YAML file that was used to build my Docker cluster. Where it says <strong class="source-inline">image:</strong> is where I found the name and address of the Docker image that I used. You can find yours the <span class="No-Break">same way:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B18672_12_09.jpg" alt="Figure 12.9 – Viewing the YAML file that was used to create my Docker cluster"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Viewing the YAML file that was used to create my Docker cluster</p>
			<ol>
				<li value="4">Now, let’s <a id="_idIndexMarker1041"/>run <span class="No-Break">the scan:</span><pre class="source-code">
<strong class="bold">trivy image --image-config-scanners config &lt;insert image location and name here&gt;</strong></pre><p class="list-inset">My Docker image was found, and it was very misconfigured! Here are the results <span class="No-Break">I got:</span></p></li>			</ol>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B18672_12_010.jpg" alt="Figure 12.10 – Trivy scan output"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – Trivy scan output</p>
			<p>You could <a id="_idIndexMarker1042"/>use this sort of data in your pentest report if you were conducting a <span class="No-Break">real pentest.</span></p>
			<p>Now, let’s try Trivy to conduct a pentest against my Kubernetes cluster <span class="No-Break">in GCP:</span></p>
			<ol>
				<li>First, I found that I had to expose my Kubernetes cluster again in order for Trivy to be able to <span class="No-Break">scan it:</span><pre class="source-code">
<strong class="bold">kubectl expose deployment hello-server \</strong>
<strong class="bold">    --type LoadBalancer \</strong>
<strong class="bold">    --port 80 \</strong>
<strong class="bold">    --target-port 8080</strong></pre></li>				<li>Then, I inspected <span class="No-Break">the Pods:</span><pre class="source-code">
<strong class="bold">kubectl get pods</strong></pre></li>				<li>Now, here’s a Trivy command that conducted a very thorough scan of my <span class="No-Break">Kubernetes cluster:</span><pre class="source-code">
<strong class="bold">trivy k8s -n kube-system --report summary all –timeout 1500s</strong></pre><p class="list-inset">After a few <a id="_idIndexMarker1043"/>minutes in the Cloud Shell CLI, I got a very detailed summary that I could use in a <span class="No-Break">pentest report:</span></p></li>			</ol>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B18672_12_011.jpg" alt="Figure 12.11 – Trivy scan vulnerability report"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – Trivy scan vulnerability report</p>
			<p>Trivy is a lot of fun <span class="No-Break">to explore!</span></p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor227"/>Summary</h1>
			<p>In this chapter, we learned which services manage containerization in GCP. We deployed our own Docker and Kubernetes clusters. Then, we conducted a security assessment <span class="No-Break">with Trivy.</span></p>
			<p>The default way to deploy a Docker containerization system in GCP uses Cloud Build to simplify the Docker build steps and Cloud Run to help run containerized apps, all while your Docker host runs <span class="No-Break">in GCE.</span></p>
			<p>The simplest way to deploy Kubernetes in GCP is to <span class="No-Break">use GKE.</span></p>
			<p>Trivy is a third-party pentesting application that has lots of great features for vulnerability scanning both Docker and <span class="No-Break">Kubernetes deployments.</span></p>
			<p>In the next and final chapter, I’ll quiz you on what we’ve learned in the previous 12 chapters. Plus, I’ll give you tips for writing and signing pentesting contracts, more tips for writing pentest reports, and introduce you to cloud and pentesting-related certifications that may make you more employable as a <span class="No-Break">cloud pentester.</span></p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor228"/>Further reading</h1>
			<p>To learn more about the topics covered in this chapter, you can visit the <span class="No-Break">following links:</span></p>
			<ul>
				<li><em class="italic">Google Cloud </em><span class="No-Break"><em class="italic">Run</em></span><span class="No-Break">: </span><a href="https://cloud.google.com/run&#13;"><span class="No-Break">https://cloud.google.com/run</span></a></li>
				<li><em class="italic">Google Cloud </em><span class="No-Break"><em class="italic">Build</em></span><span class="No-Break">: </span><a href="https://cloud.google.com/build&#13;"><span class="No-Break">https://cloud.google.com/build</span></a></li>
				<li><span class="No-Break"><em class="italic">GKE</em></span><span class="No-Break">: </span><a href="https://cloud.google.com/kubernetes-engine&#13;"><span class="No-Break">https://cloud.google.com/kubernetes-engine</span></a></li>
				<li><em class="italic">Google Cloud documentation on deploying containers to Cloud </em><span class="No-Break"><em class="italic">Run</em></span><span class="No-Break">: </span><a href="https://cloud.google.com/run/docs/deploying&#13;"><span class="No-Break">https://cloud.google.com/run/docs/deploying</span></a></li>
				<li><em class="italic">Google Cloud documentation on deploying Kubernetes applications in </em><span class="No-Break"><em class="italic">GKE</em></span><span class="No-Break">: </span><a href="https://cloud.google.com/kubernetes-engine/docs/deploy-app-cluster&#13;"><span class="No-Break">https://cloud.google.com/kubernetes-engine/docs/deploy-app-cluster</span></a></li>
				<li><span class="No-Break"><em class="italic">Trivy</em></span><span class="No-Break">: </span><a href="https://github.com/aquasecurity/trivy"><span class="No-Break">https://github.com/aquasecurity/trivy</span></a></li>
			</ul>
		</div>
	</body></html>