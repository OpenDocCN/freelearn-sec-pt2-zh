<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Unsanitized Data &amp;#x2013; An XSS Case Study</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Cross-Site Scripting</strong> (<strong>XSS</strong>) is a vulnerability caused by exceptions built into the browser's same-origin policy restricting how assets (images, style sheets, and JavaScript) are loaded from external sources.</p>
<p class="mce-root">Consistently appearing in the OWASP Top-10 survey of web-application vulnerabilities, XSS has the potential to be a very damaging, persistent exploit that affects large sections of the target site's user base. It can also be difficult to stamp out, especially in sites that have large attack surfaces, with many form inputs, logins, discussion threads, and so on, to secure.</p>
<p class="mce-root">This chapter will cover the browser mechanisms that create the opportunity for XSS, the different varieties of XSS (persistent, reflected, DOM-based, and so on), how to test for it, and a full example of an XSS vulnerability <span>–</span> from discovering the bug to submitting a report about it.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Overview of XSS</li>
<li>Testing for XSS</li>
<li><span>An end-to-end example of </span>XSS</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical Requirements</h1>
                </header>
            
            <article>
                
<p>In this section, we'll continue to configure and use tools from our macOS Terminal command line. We'll also be using Burp Suite, the Burp extension XSS Validator, and information from the SecLists GitHub repository (<a href="https://github.com/SecLists">https://github.com/SecLists</a>) to power our malicious XSS snippet submissions. When we use a browser normally or in conjunction with Burp, we'll continue to use Chrome (<kbd>66.0.3359.139</kbd>). Using the XSS Validator extension will require us to install Phantomjs, a scriptable headless browser.</p>
<div class="packt_infobox">Please download Phantomjs from the official Phantomjs download page: <a href="http://phantomjs.org/download.html">http://phantomjs.org/download.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A Quick Overview of XSS – The Many Varieties of XSS</h1>
                </header>
            
            <article>
                
<p>XSS is a weakness inherent in the single-origin policy. The single-origin policy is a security mechanism that's been adopted by every modern browser and only allows pages to load from the same domain as the page doing the loading. But there are exceptions to allow for pages to load third-party assets <span>– </span>most web pages load external JavaScript, CSS, or images <span>– </span>and this is the vector through which XSS occurs.</p>
<p>When a browser is loading the <kbd>src</kbd> attribute on an HTML tag, it's executing the code that attribute is pointing to. It doesn't have to be a file <span>– </span>it can just be code included in the attribute string. And it's not just the <kbd>src</kbd> attribute that can execute JavaScript.</p>
<p>The following is an example of an XSS testing snippet. It uses the <kbd>onmouseover</kbd> attribute to execute a JavaScript <kbd>alert()</kbd> as a classic XSS canary:</p>
<pre>&lt;a onmouseover="alert(document.location)" href="#"&gt;snippet text&lt;/a&gt;</pre>
<p><kbd>document.location</kbd> is included as a way of easily referencing the exact URL where the XSS is occurring.</p>
<p>The snippet we just referenced is an example of stored or persistent XSS because the <kbd>&lt;a&gt;</kbd> tag with malicious JavaScript would be inserted via a form input as part of a comment or general text field, and then stored in the web app's database, where it could be retrieved and viewed by other users looking at that page. Then, when someone hovered over that element, its <kbd>onmouseover</kbd> event would trigger the execution of the malicious XSS code.</p>
<p class="mce-root"/>
<p>Reflected XSS is when the injected script is reflected off of the target server through a page of search results, an error message, or an other message made up in part by the user's input. Reflected XSS can be very damaging because it leverages the trust of the server the code is being reflected from.</p>
<p>There's also DOM-based XSS, a more specialized type of the attack that relies on a user being supplied a hacker-generated link containing an XSS payload, which will prompt the user's browser to open the link, echoing back the payload as it constructs the DOM, and executes the code.</p>
<p>Although stored/persistent XSS, reflected XSS, and DOM-based XSS are all possible groupings of XSS varieties, another way of thinking about the different types of XSS is dividing the bug into client XSS and server XSS. In this framework, there are both stored and reflected types for both the client and server variations: Server XSS occurs when unverified user data is supplied by the server, either through a request (reflected XSS) or stored locations (stored XSS), while client XSS is just the execution of unverified code in the client, from the same locations.</p>
<p>We'll cover a mix of techniques for detecting XSS, some of which will apply only to specific types, others to a wider variety of attacks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing for XSS – Where to Find It, How to Verify It</h1>
                </header>
            
            <article>
                
<p>There are several great methods for discovering XSS. We'll start with a tool we've already begun using in preparing for an engagement, diving into some new parts of Burp and an XSS-related Burp extension.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Burp Suite and XSS Validator</h1>
                </header>
            
            <article>
                
<p>One problem with automated and semi-automated solutions for XSS is distinguishing signal from noise. To do that, a useful Burp plugin, XSS Validator, runs a PhantomJS-powered web server to receive the results of Burp queries and looks for a string injected into the <kbd>alert()</kbd> call embedded within the applied XSS snippets. It provides a clean way of culling the results of your XSS submissions to absolute confirmed vulnerabilities.</p>
<p class="mce-root"/>
<p>The easiest way to download the XSS Validator Burp extension is through the Bapp store. Just navigate to the store from the <span class="packt_screen">Extension</span> tab within Burp Suite and select the extension from the marketplace (needless to say, it's free). You can also install the extension manually by following the instructions in the XSS Validator GitHub documentation.</p>
<p>In addition to installing the extension, during your actual testing, you'll need to run the server parsing incoming Burp requests. If you clone the XSS Validator git repo, you can navigate to the <kbd>xss-validator</kbd> directory and start the <kbd>xss.js</kbd> script. You can then bootstrap the server and set it to run as a detached background process in one easy line:</p>
<pre>phantomjs xss.js &amp;</pre>
<p>With the XSS Validator server and Burp Suite running (<kbd>boostrap_burp</kbd>), navigate to the specific form input you'd like to test for XSS. As a way of demonstrating the tool on a proven testing ground, we're going to test a form input on the <span class="packt_screen">Web Scanner Test Site</span> (<kbd>webscantest.com</kbd>) that's been designed to be susceptible to XSS:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/883eb253-141e-4399-a9ca-f5ba32540414.png"/></div>
<p>After arriving on the page <span>–</span> with our Burp <span class="packt_screen">Proxy <span class="packt_screen">Intercept</span></span> feature turned off so that we don't have to manually forward all the traffic on the way there <span>–</span> we enter something recognizable into the form fields we're testing:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/47a734fd-eafa-46d2-8ef0-8c899d4cf34e.png"/></div>
<p>Now we want to navigate back to our Burp Suite GUI and turn <span class="packt_screen">Intercept</span> back on before we submit:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1e61c0a5-2bb6-4fed-9622-e6ddbce1d8e2.png"/></div>
<p>Now when we submit, you should see the browser favicon indicate a submission without anything changing on the form. If you go back to Burp, you'll see you've intercepted the form's <kbd>POST</kbd> request (note that if you have other tabs open, you might see that the Burp proxy has intercepted requests from those pages, and has to forward them):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/17130b62-b3cd-4c61-b8d4-d81cda0b497c.png"/></div>
<p>We want to send this request over to the Burp intruder feature, where we can do more to manipulate the <kbd>POST</kbd> data. To do that, right-click on the request and click <span class="packt_screen">Send to Intruder</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5b6c5325-133d-40d2-a1c9-2ff7d96f79e4.png"/></div>
<p>Once you're at the <span class="packt_screen">Intruder</span> window, go to the <span class="packt_screen">Positions</span> tab where you can see the <kbd>POST</kbd> request parameters and cookie IDs already selected as <span class="packt_screen">Payload Positions</span>. Let's go ahead and leave these defaults and move over to the <span class="packt_screen">Payloads</span> tab to choose what we'll be filling these input with. In order to integrate with the XSS Validator extension, we need to make changes to these first three payload-related settings, as follows:</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Payload Sets</h1>
                </header>
            
            <article>
                
<p>For the second drop-down, <span class="packt_screen">Payload Type</span>, select the <span class="packt_screen">Extension-generated</span> option.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Payload Options</h1>
                </header>
            
            <article>
                
<p>When you click <span class="packt_screen"><span class="packt_screen">Select</span> generator...</span>, you'll open a modal where you can select <span class="packt_screen"><span class="packt_screen"><span class="packt_screen">XSS Validator</span> Payloa</span>ds</span> as your selected generator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Payload Processing</h1>
                </header>
            
            <article>
                
<p>Here you'll want to add a rule, choosing <span class="packt_screen">Invoke Burp extension</span> as the rule type and then XSS Validator as the processor:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/14f52966-e892-4a81-8d76-abb9069d9860.png"/></div>
<p>After you've made all these selections, your app's GUI should look like the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1623ec0d-c8fa-4f6b-9289-20a792bc4317.png" style=""/></div>
<p>We need to make one more setting change before we can start our attack. If you head over to the <span class="packt_screen">xssValidator</span> tab, you'll see a random string generated in the <span class="packt_screen">Grep Phrase</span> field, and you might also spot the bullet point explaining that <span class="packt_screen">Successful attacks will be denoted by the presence of the <em>Grep Phrase</em></span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/269239c1-2bbf-482d-8b1d-7091eab35aa9.png" style=""/></div>
<p>We want to add that grep phrase into the <span class="packt_screen">Grep - Match</span> section in the <span class="packt_screen">Options</span> tab so that, when we're viewing our attack results, we can see a checkbox indicating whether our phrase turned up in an attack response:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c84b0785-1734-4bfd-ab95-ba08fd45a838.png"/></div>
<p>Once that phrase has been added, we're ready to start our attack. Click the <span class="packt_screen">start attack</span> button in the top-right of the <span class="packt_screen">Options</span> (and every other) view.</p>
<p>After clicking the button, you should see an attack window pop up and start to self-populate with the results of the XSS snippet submissions:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/64e3a8d5-d639-40f1-b54e-b4eb4d7f2fbb.png"/></div>
<p>And voila! We can see the presence of our grep phrase, meaning that our submissions have been a success, for several of the tag/attribute combinations generated by the XSS Validator submissions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">XSS – An End-To-End Example</h1>
                </header>
            
            <article>
                
<p>Throughout this book, we look at bugs on deliberately-vulnerable teaching sites as well as live applications belonging to real companies <span>– </span>that way, we can see vulnerabilities as they exist in the wild while also having sections where you can follow along at home.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">XSS in Google Gruyere</h1>
                </header>
            
            <article>
                
<p>This next part takes place on <strong>Google Gruyere</strong>, an XSS laboratory operated by Google that explains different aspects of XSS alongside appropriately vulnerable form input:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ae7435df-8fe7-4cae-b7bb-ff75dfdf5f01.png"/></div>
<p>Google Gruyere is based loosely on a social network, such as Instagram or Twitter, where different users can share public snippets just like the former site's 280-word text blocks. Beyond the obvious, advertising of the service as being susceptible to XSS, there are small pieces of text, similar to what you'd find in real applications, hinting at areas of vulnerability. Some or limited support of HTML in a specific form is always a chance that the filters put in place by the site's developers to allow formatting markup, such as <kbd>&lt;p&gt;&lt;/p&gt;</kbd>, <kbd>&lt;b&gt;&lt;/b&gt;</kbd>, and <kbd>&lt;br/&gt;</kbd>, while keeping out scary stuff, such as <kbd>&lt;script&gt;&lt;/script&gt;</kbd>, will fail to sanitize your specially-crafted snippet.</p>
<p>Going through the submission form to create a <span class="packt_screen">New Snippet</span> (after setting up an account), we can try to probe at the outer edges of the sanitizing process. Let's try using a script that even the most naive filter should capture:</p>
<pre>&lt;script&gt;alert(1)&lt;/script&gt;</pre>
<p>A plain script tag, without any obfuscation, escape characters, or exotic attributes, is a pretty slow pitch, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/db1457db-d2ee-453a-a0af-eb5fdba48344.png" style=""/></div>
<p class="CDPAlignLeft CDPAlign">When we look at the result of the submission, no <kbd>alert()</kbd> window is displayed and there's nothing to else to trigger the execution of the code, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a205c796-133c-4571-9f3b-4bd5857d97b1.png" style=""/></div>
<p>The filter undoubtedly has some holes in it, but it does function at the most basic level by stripping out the <kbd>&lt;script&gt;</kbd> tags. Going through the XSS snippet lists we have in our <kbd>Seclists</kbd> repository, we find another one to try, ensuring the HTML tag is likely to be included in a form input meant to allow formatting code:</p>
<pre>&lt;a onmouseover="alert(document.cookie)"&gt;xxs link&lt;/a&gt; </pre>
<p><kbd>document.cookie</kbd> is a glimpse of our proposed attack scenario and a simple piece of data to surface via <kbd>alert()</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c981488e-7fc0-43fb-95ac-9079d0aff2a3.png"/></div>
<p>Going through the submission process again, we receive a different response. Success! Our strategy, using a boring formatting tag to Trojan-horse a malicious payload contained in its attribute, worked, and we now have a confirmed vulnerability to report:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c6441d53-db6e-4469-981e-8c9949664ce5.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gathering Report Information</h1>
                </header>
            
            <article>
                
<p>There's a lot of information that we'll need about the vulnerability we've discovered, info that will be necessary or useful across submission platforms and styles.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Category</h1>
                </header>
            
            <article>
                
<p>Very simply, this is the category the bug falls into. In our case, it is Persistent XSS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Timestamps</h1>
                </header>
            
            <article>
                
<p>If you're using an automated or just code-based solution to touch the target, taking timestamps is a must <span>–</span> the more accurate the better. If, like us just now, you manually entered a malicious snippet, simply the time after the discovery will suffice. Giving the time of discovery in UTC will save the developer who is fielding the report from doing a mental timezone conversion before analyzing logs, usages charts, and other monitoring tools.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URL</h1>
                </header>
            
            <article>
                
<p>This is the URL of the vulnerability. When executing test, code such as <kbd>alert()</kbd>, sometimes it can be useful to alert a location (for example, <kbd>alert(document.location)</kbd>). This way, in a single screenshot, you can convey both preliminary proof of the bug and its location in the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Payload</h1>
                </header>
            
            <article>
                
<p>The XSS snippet we used to successfully execute JavaScript will go here. In the case of SQLi, a successful password attack, or any number of other payload-based attacks, that data would be required as well. If you trip on multiple payload types in one discovery, you should mention however many illustrate the general sanitation rules being misapplied:</p>
<pre>&lt;a onmouseover="alert(document.cookie)"&gt;xxs link&lt;/a&gt; </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Methodology</h1>
                </header>
            
            <article>
                
<p>If you discovered the bug using a particular tool, tell them (and don't use a scanner if they explicitly said not to!). It can help the team fielding your report validate your finding if they use something similar and can incorporate that into reproducing the issue. In this case, we would just say that we submitted the snippet and verified the bug manually.<br/>
<br/>
It's also useful to list some basic info about the environment in which the vulnerability was discovered: your operating system, browser type and version (plus any add-ons or extensions if they're relevant), and any miscellaneous information you think is relevant (for example, was it discovered in an incognito window? If using <kbd>curl</kbd>, Postman, or another tool, did you use any particular headers?).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Instructions to Reproduce</h1>
                </header>
            
            <article>
                
<p>Making sure your instructions are clear enough for the person that evaluated your report is, along with the actual payload, the most important information you can provide. A screenshot of the vulnerability (for example, the alert window) is great evidence, but could easily fall short of winning you a payout if the issue can't be reproduced.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Attack Scenario</h1>
                </header>
            
            <article>
                
<p>Coming up with a good attack scenario isn't as necessary as the previous data points, but can be a great method for increasing the bug's severity and boosting your payout.</p>
<p>For this attack, we'll highlight the extent of the damage beyond just the Gruyere app. If an attacker could execute arbitrary JavaScript from a stored XSS bug, they could exfiltrate sensitive cookies, such as those for authenticating financial apps (banks, brokers, and crypto traders) or social networks (Twitter, Facebook, Instagram), which could in turn be used for identity theft, credit card fraud, and other cyber crimes.</p>
<p>Here's how our report will look:</p>
<pre>CATEGORY: Persistent / Stored XSS<br/><br/>TIME: 1:12 AM (1:12) UTC<br/><br/>URL: https://google-gruyere.appspot.com/09809809887686765654654/newsnippet.gtl<br/><br/>PAYLOAD: &lt;a onmouseover="alert(document.cookie)"&gt;xxs link&lt;/a&gt;<br/><br/>METHODOLOGY: XSS payload submitted manually <br/><br/>INSTRUCTIONS TO REPRODUCE:<br/><br/>1. Navigate to "New Snippet" submission page<br/>2. Enter the XSS payload into the "New Snippet" form.<br/>3. Click "Submit" and create a new snippet.<br/>4. The malicious XSS contained in the payload is executed whenever someone hovers over the snippet with that link.<br/><br/>ATTACK SCENARIO:<br/>With a persistent XSS vulnerability to exploit, a malicious actor could exfiltrate sensitive cookies to steal the identity of Gruyere's users, impersonating them both in the app and in whatever other accounts they are logged into at the time of the XSS script's execution.</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter covered the different types of XSS attacks, understanding the anatomy of an XSS snippet, and extending Burp Suite with XSS Validator to confirm successful injection attempts. We also look at using Google Gruyere as a teaching aide and testing ground, and reported an XSS vulnerability from start to finish, including how to document your report and a sample submission.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are the different principle types of XSS?</li>
<li>Which XSS varieties are most dangerous/impactful?</li>
<li>What's the value of XSS Validator as an extension?</li>
<li>What does the <kbd>phantomjs</kbd> server do?</li>
<li>How do you select payloads for fuzzing in Burp Intruder?</li>
<li>What are the most important things to include about XSS in your submission report?</li>
<li>What's a worst-case attack scenario for a hacker who's found an XSS bug to exploit?</li>
<li>Why is including an attack scenario in your report submission important?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further Reading</h1>
                </header>
            
            <article>
                
<p>You can find out more about some of the topics we have discussed in this chapter at:</p>
<ul>
<li><strong>XSS Filter Evasion Cheat Sheet</strong>: <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet</a></li>
<li><strong>XSS Challenges</strong>: <a href="https://xss-quiz.int21h.jp/">https://xss-quiz.int21h.jp/</a></li>
<li><strong>XSS Game</strong>: <a href="https://xss-game.appspot.com">https://xss-game.appspot.com</a></li>
</ul>


            </article>

            
        </section>
    </body></html>