- en: Unsanitized Data &#x2013; An XSS Case Study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Site Scripting** (**XSS**) is a vulnerability caused by exceptions
    built into the browser''s same-origin policy restricting how assets (images, style
    sheets, and JavaScript) are loaded from external sources.'
  prefs: []
  type: TYPE_NORMAL
- en: Consistently appearing in the OWASP Top-10 survey of web-application vulnerabilities,
    XSS has the potential to be a very damaging, persistent exploit that affects large
    sections of the target site's user base. It can also be difficult to stamp out,
    especially in sites that have large attack surfaces, with many form inputs, logins,
    discussion threads, and so on, to secure.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover the browser mechanisms that create the opportunity for
    XSS, the different varieties of XSS (persistent, reflected, DOM-based, and so
    on), how to test for it, and a full example of an XSS vulnerability – from discovering
    the bug to submitting a report about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An end-to-end example of XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll continue to configure and use tools from our macOS Terminal
    command line. We'll also be using Burp Suite, the Burp extension XSS Validator,
    and information from the SecLists GitHub repository ([https://github.com/SecLists](https://github.com/SecLists))
    to power our malicious XSS snippet submissions. When we use a browser normally
    or in conjunction with Burp, we'll continue to use Chrome (`66.0.3359.139`). Using
    the XSS Validator extension will require us to install Phantomjs, a scriptable
    headless browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please download Phantomjs from the official Phantomjs download page: [http://phantomjs.org/download.html](http://phantomjs.org/download.html).'
  prefs: []
  type: TYPE_NORMAL
- en: A Quick Overview of XSS – The Many Varieties of XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: XSS is a weakness inherent in the single-origin policy. The single-origin policy
    is a security mechanism that's been adopted by every modern browser and only allows
    pages to load from the same domain as the page doing the loading. But there are
    exceptions to allow for pages to load third-party assets – most web pages load
    external JavaScript, CSS, or images – and this is the vector through which XSS
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: When a browser is loading the `src` attribute on an HTML tag, it's executing
    the code that attribute is pointing to. It doesn't have to be a file – it can
    just be code included in the attribute string. And it's not just the `src` attribute
    that can execute JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an XSS testing snippet. It uses the `onmouseover`
    attribute to execute a JavaScript `alert()` as a classic XSS canary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`document.location` is included as a way of easily referencing the exact URL
    where the XSS is occurring.'
  prefs: []
  type: TYPE_NORMAL
- en: The snippet we just referenced is an example of stored or persistent XSS because
    the `<a>` tag with malicious JavaScript would be inserted via a form input as
    part of a comment or general text field, and then stored in the web app's database,
    where it could be retrieved and viewed by other users looking at that page. Then,
    when someone hovered over that element, its `onmouseover` event would trigger
    the execution of the malicious XSS code.
  prefs: []
  type: TYPE_NORMAL
- en: Reflected XSS is when the injected script is reflected off of the target server
    through a page of search results, an error message, or an other message made up
    in part by the user's input. Reflected XSS can be very damaging because it leverages
    the trust of the server the code is being reflected from.
  prefs: []
  type: TYPE_NORMAL
- en: There's also DOM-based XSS, a more specialized type of the attack that relies
    on a user being supplied a hacker-generated link containing an XSS payload, which
    will prompt the user's browser to open the link, echoing back the payload as it
    constructs the DOM, and executes the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although stored/persistent XSS, reflected XSS, and DOM-based XSS are all possible
    groupings of XSS varieties, another way of thinking about the different types
    of XSS is dividing the bug into client XSS and server XSS. In this framework,
    there are both stored and reflected types for both the client and server variations:
    Server XSS occurs when unverified user data is supplied by the server, either
    through a request (reflected XSS) or stored locations (stored XSS), while client
    XSS is just the execution of unverified code in the client, from the same locations.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll cover a mix of techniques for detecting XSS, some of which will apply
    only to specific types, others to a wider variety of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for XSS – Where to Find It, How to Verify It
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several great methods for discovering XSS. We'll start with a tool
    we've already begun using in preparing for an engagement, diving into some new
    parts of Burp and an XSS-related Burp extension.
  prefs: []
  type: TYPE_NORMAL
- en: Burp Suite and XSS Validator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One problem with automated and semi-automated solutions for XSS is distinguishing
    signal from noise. To do that, a useful Burp plugin, XSS Validator, runs a PhantomJS-powered
    web server to receive the results of Burp queries and looks for a string injected
    into the `alert()` call embedded within the applied XSS snippets. It provides
    a clean way of culling the results of your XSS submissions to absolute confirmed
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to download the XSS Validator Burp extension is through the
    Bapp store. Just navigate to the store from the Extension tab within Burp Suite
    and select the extension from the marketplace (needless to say, it's free). You
    can also install the extension manually by following the instructions in the XSS
    Validator GitHub documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to installing the extension, during your actual testing, you''ll
    need to run the server parsing incoming Burp requests. If you clone the XSS Validator
    git repo, you can navigate to the `xss-validator` directory and start the `xss.js`
    script. You can then bootstrap the server and set it to run as a detached background
    process in one easy line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the XSS Validator server and Burp Suite running (`boostrap_burp`), navigate
    to the specific form input you''d like to test for XSS. As a way of demonstrating
    the tool on a proven testing ground, we''re going to test a form input on the
    Web Scanner Test Site (`webscantest.com`) that''s been designed to be susceptible
    to XSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/883eb253-141e-4399-a9ca-f5ba32540414.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After arriving on the page – with our Burp Proxy Intercept feature turned off
    so that we don''t have to manually forward all the traffic on the way there –
    we enter something recognizable into the form fields we''re testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/47a734fd-eafa-46d2-8ef0-8c899d4cf34e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we want to navigate back to our Burp Suite GUI and turn Intercept back
    on before we submit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1e61c0a5-2bb6-4fed-9622-e6ddbce1d8e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now when we submit, you should see the browser favicon indicate a submission
    without anything changing on the form. If you go back to Burp, you''ll see you''ve
    intercepted the form''s `POST` request (note that if you have other tabs open,
    you might see that the Burp proxy has intercepted requests from those pages, and
    has to forward them):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/17130b62-b3cd-4c61-b8d4-d81cda0b497c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We want to send this request over to the Burp intruder feature, where we can
    do more to manipulate the `POST` data. To do that, right-click on the request
    and click Send to Intruder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5b6c5325-133d-40d2-a1c9-2ff7d96f79e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you''re at the Intruder window, go to the Positions tab where you can
    see the `POST` request parameters and cookie IDs already selected as Payload Positions.
    Let''s go ahead and leave these defaults and move over to the Payloads tab to
    choose what we''ll be filling these input with. In order to integrate with the
    XSS Validator extension, we need to make changes to these first three payload-related
    settings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Payload Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the second drop-down, Payload Type, select the Extension-generated option.
  prefs: []
  type: TYPE_NORMAL
- en: Payload Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you click Select generator..., you'll open a modal where you can select
    XSS Validator Payloads as your selected generator.
  prefs: []
  type: TYPE_NORMAL
- en: Payload Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here you''ll want to add a rule, choosing Invoke Burp extension as the rule
    type and then XSS Validator as the processor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/14f52966-e892-4a81-8d76-abb9069d9860.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After you''ve made all these selections, your app''s GUI should look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1623ec0d-c8fa-4f6b-9289-20a792bc4317.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to make one more setting change before we can start our attack. If
    you head over to the xssValidator tab, you''ll see a random string generated in
    the Grep Phrase field, and you might also spot the bullet point explaining that
    Successful attacks will be denoted by the presence of the *Grep Phrase*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/269239c1-2bbf-482d-8b1d-7091eab35aa9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We want to add that grep phrase into the Grep - Match section in the Options
    tab so that, when we''re viewing our attack results, we can see a checkbox indicating
    whether our phrase turned up in an attack response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c84b0785-1734-4bfd-ab95-ba08fd45a838.png)'
  prefs: []
  type: TYPE_IMG
- en: Once that phrase has been added, we're ready to start our attack. Click the
    start attack button in the top-right of the Options (and every other) view.
  prefs: []
  type: TYPE_NORMAL
- en: 'After clicking the button, you should see an attack window pop up and start
    to self-populate with the results of the XSS snippet submissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/64e3a8d5-d639-40f1-b54e-b4eb4d7f2fbb.png)'
  prefs: []
  type: TYPE_IMG
- en: And voila! We can see the presence of our grep phrase, meaning that our submissions
    have been a success, for several of the tag/attribute combinations generated by
    the XSS Validator submissions.
  prefs: []
  type: TYPE_NORMAL
- en: XSS – An End-To-End Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, we look at bugs on deliberately-vulnerable teaching sites
    as well as live applications belonging to real companies – that way, we can see
    vulnerabilities as they exist in the wild while also having sections where you
    can follow along at home.
  prefs: []
  type: TYPE_NORMAL
- en: XSS in Google Gruyere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This next part takes place on **Google Gruyere**, an XSS laboratory operated
    by Google that explains different aspects of XSS alongside appropriately vulnerable
    form input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae7435df-8fe7-4cae-b7bb-ff75dfdf5f01.png)'
  prefs: []
  type: TYPE_IMG
- en: Google Gruyere is based loosely on a social network, such as Instagram or Twitter,
    where different users can share public snippets just like the former site's 280-word
    text blocks. Beyond the obvious, advertising of the service as being susceptible
    to XSS, there are small pieces of text, similar to what you'd find in real applications,
    hinting at areas of vulnerability. Some or limited support of HTML in a specific
    form is always a chance that the filters put in place by the site's developers
    to allow formatting markup, such as `<p></p>`, `<b></b>`, and `<br/>`, while keeping
    out scary stuff, such as `<script></script>`, will fail to sanitize your specially-crafted
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going through the submission form to create a New Snippet (after setting up
    an account), we can try to probe at the outer edges of the sanitizing process.
    Let''s try using a script that even the most naive filter should capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A plain script tag, without any obfuscation, escape characters, or exotic attributes,
    is a pretty slow pitch, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/db1457db-d2ee-453a-a0af-eb5fdba48344.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we look at the result of the submission, no `alert()` window is displayed
    and there''s nothing to else to trigger the execution of the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a205c796-133c-4571-9f3b-4bd5857d97b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The filter undoubtedly has some holes in it, but it does function at the most
    basic level by stripping out the `<script>` tags. Going through the XSS snippet
    lists we have in our `Seclists` repository, we find another one to try, ensuring
    the HTML tag is likely to be included in a form input meant to allow formatting
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`document.cookie` is a glimpse of our proposed attack scenario and a simple
    piece of data to surface via `alert()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c981488e-7fc0-43fb-95ac-9079d0aff2a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Going through the submission process again, we receive a different response.
    Success! Our strategy, using a boring formatting tag to Trojan-horse a malicious
    payload contained in its attribute, worked, and we now have a confirmed vulnerability
    to report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c6441d53-db6e-4469-981e-8c9949664ce5.png)'
  prefs: []
  type: TYPE_IMG
- en: Gathering Report Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a lot of information that we'll need about the vulnerability we've discovered,
    info that will be necessary or useful across submission platforms and styles.
  prefs: []
  type: TYPE_NORMAL
- en: Category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very simply, this is the category the bug falls into. In our case, it is Persistent
    XSS.
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're using an automated or just code-based solution to touch the target,
    taking timestamps is a must – the more accurate the better. If, like us just now,
    you manually entered a malicious snippet, simply the time after the discovery
    will suffice. Giving the time of discovery in UTC will save the developer who
    is fielding the report from doing a mental timezone conversion before analyzing
    logs, usages charts, and other monitoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the URL of the vulnerability. When executing test, code such as `alert()`,
    sometimes it can be useful to alert a location (for example, `alert(document.location)`).
    This way, in a single screenshot, you can convey both preliminary proof of the
    bug and its location in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Payload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The XSS snippet we used to successfully execute JavaScript will go here. In
    the case of SQLi, a successful password attack, or any number of other payload-based
    attacks, that data would be required as well. If you trip on multiple payload
    types in one discovery, you should mention however many illustrate the general
    sanitation rules being misapplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you discovered the bug using a particular tool, tell them (and don't use
    a scanner if they explicitly said not to!). It can help the team fielding your
    report validate your finding if they use something similar and can incorporate
    that into reproducing the issue. In this case, we would just say that we submitted
    the snippet and verified the bug manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also useful to list some basic info about the environment in which the
    vulnerability was discovered: your operating system, browser type and version
    (plus any add-ons or extensions if they''re relevant), and any miscellaneous information
    you think is relevant (for example, was it discovered in an incognito window?
    If using `curl`, Postman, or another tool, did you use any particular headers?).'
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to Reproduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making sure your instructions are clear enough for the person that evaluated
    your report is, along with the actual payload, the most important information
    you can provide. A screenshot of the vulnerability (for example, the alert window)
    is great evidence, but could easily fall short of winning you a payout if the
    issue can't be reproduced.
  prefs: []
  type: TYPE_NORMAL
- en: Attack Scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coming up with a good attack scenario isn't as necessary as the previous data
    points, but can be a great method for increasing the bug's severity and boosting
    your payout.
  prefs: []
  type: TYPE_NORMAL
- en: For this attack, we'll highlight the extent of the damage beyond just the Gruyere
    app. If an attacker could execute arbitrary JavaScript from a stored XSS bug,
    they could exfiltrate sensitive cookies, such as those for authenticating financial
    apps (banks, brokers, and crypto traders) or social networks (Twitter, Facebook,
    Instagram), which could in turn be used for identity theft, credit card fraud,
    and other cyber crimes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how our report will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the different types of XSS attacks, understanding the anatomy
    of an XSS snippet, and extending Burp Suite with XSS Validator to confirm successful
    injection attempts. We also look at using Google Gruyere as a teaching aide and
    testing ground, and reported an XSS vulnerability from start to finish, including
    how to document your report and a sample submission.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the different principle types of XSS?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which XSS varieties are most dangerous/impactful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the value of XSS Validator as an extension?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `phantomjs` server do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you select payloads for fuzzing in Burp Intruder?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the most important things to include about XSS in your submission report?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's a worst-case attack scenario for a hacker who's found an XSS bug to exploit?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is including an attack scenario in your report submission important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more about some of the topics we have discussed in this chapter
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '**XSS Filter Evasion Cheat Sheet**: [https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XSS Challenges**: [https://xss-quiz.int21h.jp/](https://xss-quiz.int21h.jp/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XSS Game**: [https://xss-game.appspot.com](https://xss-game.appspot.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
