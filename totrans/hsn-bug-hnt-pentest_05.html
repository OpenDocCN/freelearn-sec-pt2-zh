<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">SQL, Code Injection, and Scanners</h1>
                </header>
            
            <article>
                
<p>Code injection is when unvalidated data is added (injected) into a vulnerable program and executed. Injection can occur in SQL, NoSQL, LDAP, XPath, NoSQL, XML parsers, and even through SMTP headers.</p>
<p>The XSS vulnerabilities discussed in the previous chapter are also examples of code injection. When an unsanitized HTML tag with malicious code in its attribute is added to a web application's database via a comment thread or discussion board submission, that code is injected into the application and executed when other users view that same comment or discussion.</p>
<p>For the purposes of this chapter though, we're going to focus on detecting and preventing code injection attacks related to databases—SQL and NoSQL, respectively. We'll cover how to use CLI tools to test a form input for SQLi vulnerabilities, how to use similar techniques for NoSQLi, scanning for both SQLi and other injection attacks, and best practices for avoiding damage to your target's database.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>SQLi and other code injection attacks</li>
<li>Testing for SQLi with <kbd>sqlmap</kbd></li>
<li>Trawling for bugs</li>
<li>Scanning for SQLi with Arachni</li>
<li>NoSQL injection</li>
<li><span>An end-to-end example of </span>SQLi</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical Requirements</h1>
                </header>
            
            <article>
                
<p>For this chapter, in addition to our existing Burp and Burp Proxy integration with Chrome (<kbd>66.0.3359.139</kbd>), we'll also be using <kbd>sqlmap</kbd>, a CLI tool for detecting SQL- and NoSQL-based injections. <kbd>sqlmap</kbd> can be installed using Homebrew with <kbd>brew install sqlmap</kbd> and is also available as a Python module installable via <kbd>pip</kbd>. <kbd>sqlmap</kbd> is a popular tool, so there should be an installation path for you whatever your system.</p>
<p>We'll also be using Arachni as our go-to scanner. Though noisy, scanners can be indispensable for the appropriate situation, and are great at flushing out otherwise hard-to-detect bugs. Arachni is an excellent choice because it's open source, multi-threaded, extensible via plugins, and has a great CLI that allows it to be worked into other automated workflows. Arachni is easy to install; you can install it as a gem (<kbd>gem install arachni</kbd>) or you can simply download the official packages straight from the installation site.</p>
<div class="packt_infobox">Please install Arachni from the site's <span class="packt_screen">Download</span> page at <a href="http://www.arachni-scanner.com/download/#Mac-OSX">http://www.arachni-scanner.com/download/#Mac-OSX.</a></div>
<p>After you've installed it, if you've downloaded the packages for the appropriate system, you'll want to move them to wherever is appropriate within your system.</p>
<p>Then you can create a symlink (symbolic link) so that all the <kbd>arachni</kbd> CLI packages will be available within your path (fill in the correct path to your <kbd>arachni</kbd> installation):</p>
<pre><strong>sudo ln -s /Path/to/arachni-1.5.1-0.5.12/bin/arachni* /usr/local/bin</strong></pre>
<p>You might find that, after you symlink your <kbd>arachni</kbd> executables to your path, you receive the following error:</p>
<pre><strong>/usr/local/bin/arachni: line 3: /usr/local/bin/readlink_f.sh: No such file or directory</strong><br/><strong>/usr/local/bin/arachni: line 4: readlink_f: command not found</strong><br/><strong>/usr/local/bin/arachni: line 4: ./../system/setenv: No such file or directory</strong></pre>
<p>If you receive this error, simply symlink, copy, or move the <kbd>readlink_f.sh</kbd> script from your <kbd>arachni</kbd> installation's <kbd>bin</kbd> directory to your own path. In this case, we'll symlink it:</p>
<pre><strong>sudo ln -s /Path/to/arachni-1.5.1-0.5.12/bin/readlink_f.sh /usr/local/bin/readline_f.sh</strong></pre>
<p class="mce-root"/>
<p>Now when we use <kbd>arachni</kbd> later in the chapter, we can invoke it directly, as opposed to having to type the full path each time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SQLi and Other Code Injection Attacks – Accepting Unvalidated Data</h1>
                </header>
            
            <article>
                
<p>SQLi is a rather old vulnerability. It's been two decades since the first public disclosures of the attack started appearing in 1998, detailed in publications such as Phrack, but it persists, often in critically damaging ways. SQLi vulnerabilities can allow an attacker to read sensitive data, update database information, and sometimes even issue OS commands. As OWASP succinctly states, the "flaw depends on the fact that SQL makes no real distinction between the control and data planes." This means that SQL commands can modify both the data they contain and parts of the underlying system running the software, so when the access prerequisites for a feature such as sqlmap's <kbd>--os-shell</kbd> flag are present, a SQLi flaw can be used to issue system commands.</p>
<p>Many tools and design patterns exist for preventing SQLi. But the pressure of getting new applications to market and iterating quickly on features means that SQLi-vulnerable inputs don't get audited, and the procedures to prevent the bug are never put into place.</p>
<p>As a vulnerability endemic to one of the most common languages for database development and as an easily detected, easily exploited, and richly rewarded bug, SQLi is a worthy subject for study.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A Simple SQLi Example</h1>
                </header>
            
            <article>
                
<p>Let's look at how SQLi breaks down into actual code.</p>
<p>Take a look at the following query, where the value of <kbd>$id</kbd> would be input supplied by the user:</p>
<pre><strong>SELECT title, author FROM posts WHERE id=$id</strong></pre>
<p>One common SQLi technique is to input data that can change the context or logic of the SQL statement's execution. Because that <kbd>$id</kbd> value is being inserted directly—with no data sanitization, removal of dangerous code, or data type transformation—the SQL statement is dynamic, and subject to tampering.</p>
<p>Let's make a change that will affect the execution of the statement:</p>
<pre><strong>SELECT title, author FROM posts WHERE id=10 OR 1=1</strong></pre>
<p>In this case, <kbd>10 OR 1=1</kbd> is the user-supplied data. By modifying the <kbd>WHERE</kbd> clause, the user can alter the logic of the developer-supplied part of the executed example. The preceding example is pretty innocuous, but if the statement asked for account information from a user table, or a part of the database associated with privileges, instead of just information about a blog post, that could represent a way to seriously damage the application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing for SQLi With Sqlmap – Where to Find It and How to Verify It</h1>
                </header>
            
            <article>
                
<p><kbd>sqlmap</kbd> is a popular CLI tool for detecting and exploiting SQLi vulnerabilities. Since we're only interested in discovering those bugs, we're less interested in the weaponization, except for brainstorming possible attack scenarios for report submissions.<br/>
<br/>
The simplest use of <kbd>sqlmap</kbd> is using the <kbd>-u</kbd> flag to target the parameters being passed in a specific URL. Using <kbd>webscantest.com</kbd> again as our example target, we can test the parameters in a form submission specifically vulnerable to <kbd>GET</kbd> requests:</p>
<pre><strong>sqlmap -u "http://webscantest.com/datastore/search_get_by_id.php?id=3"</strong></pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8afa3f4a-8dd8-4939-a2bd-c30605d6ac17.png"/></div>
<p>As <kbd>sqlmap</kbd> begins probing the parameters passed in the target URL, it will prompt you to answer several questions about the direction and scope of the attack:</p>
<pre><strong>it looks like the back-end DBMS is 'MySQL'. Do you want to skip test payloads specific for other DBMSes? [Y/n]</strong></pre>
<p>If you can successfully identify the backend through your own investigations, it's a good idea to say yes here, just to reduce any possible noise in the report.</p>
<p>You should also get a question about what <kbd>risk</kbd> level of input values you're willing to tolerate:</p>
<pre><strong>for the remaining tests, do you want to include all tests for 'MySQL' extending provided level (1) and risk (1) values?</strong></pre>
<p><kbd>sqlmap</kbd>, as a tool designed to both detect SQLi vulnerabilities and exploit them, needs to be handled with care. Unless you're testing against a sandboxed instance, completely independent from all production systems, you should go with the lower risk-level settings. Using the lowest risk level ensures that <kbd>sqlmap</kbd> will test the form with malicious SQL inputs designed to cause the database to sleep or enumerate hidden information—and not corrupt data or compromise authentication systems. Because of the sensitivity of the information and processes contained in the targeted SQL database, it's important to tread carefully with vulnerabilities associated with backend systems.</p>
<p class="mce-root"/>
<p>Once <kbd>sqlmap</kbd> runs through its range of test inputs, it will prompt you to ask about targeting other parameters. Once you've run through all the parameters passed in the targeted URL, <kbd>sqlmap</kbd> will print out a report of all the vulnerabilities discovered:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2983a87b-790c-4600-b6fc-58604df95930.png"/></div>
<p>Success! There are a few vulnerabilities related to the <kbd>id</kbd> parameter, including a pair of blind SQLi vulnerabilities (where the results of the injection are not directly visible in the GUI) and error- and <kbd>UNION</kbd>-based inputs—all confirmed by the documentation on <kbd>webscantest.com</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Trawling for Bugs – Using Google Dorks and Python for SQLi Discovery
</h1>
                </header>
            
            <article>
                
<p> </p>
<p>Using <kbd>sqlmap</kbd> requires a URL to target—one that will contain testable parameters. This next technique can be used to target specific applications and form inputs—like <kbd>sqlmap</kbd> does—or to simply return a list of sites susceptible to SQLi vulnerabilities.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Google Dorks for SQLi</h1>
                </header>
            
            <article>
                
<p>Using Google Dorks—sometimes called Google hacking—means employing specially-crafted search queries to get search engines to return sites susceptible to SQLi and other vulnerabilities. The name Google dork refers to a hapless employee misconfiguring their site and exposing sensitive corporate information online.</p>
<p>Here are a few examples of common Google Dorks for discovering instances of SQLi:</p>
<pre><strong>inurl:index.php?id=</strong><br/><strong>inurl:buy.php?category=</strong><br/><strong>inurl:pageid=</strong><br/><strong>inurl:page.php?file=</strong></pre>
<p>You can see the queries are designed to return results, where the sites discovered are at least theoretically susceptible to SQLi (because of the sites' URL structure). The basic form of a dork is <kbd>search_method:domain/dork</kbd>, where the <kbd>search_method</kbd> and dork are calibrated to look for a specific type of vulnerability and <kbd>domain</kbd> is used for when you'd like to target a specific application. For example, here's a dork designed to return insecure CCTV feeds:</p>
<pre><strong>intitle:”EvoCam” inurl:”webcam.html”</strong></pre>
<p>This dork doesn't target a particular URL; it's simply looking for any site where the page's title contains <kbd>Evocam</kbd> and the page's URL contains <kbd>webcam.html</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating a Dork</h1>
                </header>
            
            <article>
                
<p>While browsing a small security site, I find the following dork, listed on the company's Bugtraq section (the title of the company featured in the <kbd>intext</kbd> field has been changed):</p>
<pre><strong>inurl:index.jsp? intext:"some company title"</strong></pre>
<p>This dork, though it doesn't have a target URL, does focus on a particular company via the <kbd>intext</kbd> search filter. For the <kbd>inurl</kbd> value, <kbd>jsp</kbd> is the file extension for JSP, a web application framework for Java servlets. <kbd>jsp</kbd> is a little old—it was Sun Microsystems' response to Microsoft's <strong><span>Active Server Pages</span></strong> (<strong><span>ASP</span></strong>) in 1999—but like so much tech, is still employed in legacy industries, small businesses, and small <kbd>dev</kbd> shops.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>When we use this dork to search Google, our first result returns a URL containing <kbd>index.jsp?</kbd>:</p>
<pre><strong>http://www.examplesite.com/index.jsp?idPagina=12</strong></pre>
<p>We can see the site is making a <kbd>GET</kbd> request, passing a parameter identifying the page visited (<kbd>idPagina</kbd>). Let's check that and see if it's vulnerable, which we can do by passing the URL to <kbd>sqlmap</kbd>.</p>
<pre><strong>sqlmap -u "http://www.examplesite.com/index.jsp?idPagina=12"</strong></pre>
<p>This is a valid <kbd>sqlmap</kbd> command. The cool thing about the tool is that it also supports an option for Dorks, <kbd>-g</kbd>, making it also possible to pass a string of the dork you'd like to search (instead of doing the search manually):</p>
<pre><strong>sqlmap -g 'inurl:index.jsp? intext:"some company title"'</strong></pre>
<p>In this instance, <kbd>sqlmap</kbd> will use that dork to search Google and then take the results from the first page and analyze them one-by-one, prompting you each time to ask if you want to analyze the URL, skip it, or quit.</p>
<p>Taking the results from just the first search result—the one we targeted directly by passing the URL to <kbd>sqlmap</kbd> via <kbd>-u</kbd>—we can see both time-based and error-based SQLi vulnerabilities:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/37a4adc5-ef18-4b4f-bab4-df80f05c375b.png"/></div>
<p class="mce-root"/>
<p>Time-based SQLi is when <kbd>SLEEP()</kbd> or another similar function is called to inject a delay into the query being processed. This delay, combined with conditionals and other logic, is then used to extract information from a database by slowly enumerating resources. If your payload produces a delay, you can infer your condition evaluated to <kbd>true</kbd> and the assumptions you made are correct. Doing this enough can expose sensitive information to determined attackers. As an attack, time-based SQLi is very noisy. The impact on application logs is relatively small, but repeated use of time-based SQLi will cause large CPU consumption spikes, easily detectable by an attentive sysadmin or SRE.</p>
<p>If we take the payload from the <kbd>sqlmap</kbd> time-based results (<kbd>12 RLIKE SLEEP(5)</kbd>) and plug it into the <kbd>idPagina</kbd> URL parameter, we find it's successful! The page takes longer to load as our <kbd>SLEEP(5)</kbd> command is not sanitized and gets mistakenly executed by the application's SQL server. This is a bona fide bug.</p>
<p>Error-based SQLi is also returned as a vector for <kbd>idPagina</kbd>. Error-based SQLi is when a SQL command can be made to expose sensitive database information through error messages. Again, let's use this payload as the <kbd>idPagina</kbd> URL parameter and enter it all into the browser:</p>
<p>We're successful! The page returns a table ID. Exposing sensitive database info more than meets the threshold for a valid SQLi vulnerability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scanning for SQLi With Arachni</h1>
                </header>
            
            <article>
                
<p>As we mentioned in the <em>Technical requirements</em> section, <kbd>arachni</kbd> is our weapon of choice for SQLi scanners because it's open source, extensible, multi-threaded, and can be used from a CLI that plays nicely with other forms of automation.</p>
<p class="mce-root"/>
<p>After installing <kbd>arachni</kbd> as per the requirements (and symlinking your installation's <kbd>arachni</kbd> executable), you'll be able to access the <kbd>arachni</kbd> CLI in your <kbd>$PATH</kbd>. Let's look at Arachni's help message to explore some of the options available:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b6fd496f-2a04-44e9-94c5-863b47f9b0a6.png"/></div>
<p>This is a truncated version of the output. Arachni has so many options there are too many to reprint here. But certain CLI options are useful for extending Arachni's functionality and creating more sophisticated workflows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Going Beyond Defaults</h1>
                </header>
            
            <article>
                
<p>Like many scanners, <kbd>arachni</kbd> can be point-and-click almost to a fault. Though no extra arguments are required to start spidering a URL from the command-line, there are several critical options we should be aware of to get better functionality.</p>
<pre><strong>--timeout</strong></pre>
<p class="mce-root"/>
<p>When you set <kbd>arachni</kbd> loose on a URL it spins up multiple threads that start bombarding the target with the malicious snippets and exploratory requests all scanners use to flush out interesting behavior. If you're going too quickly though and get hit by a WAF throttling your traffic, you might find some or all of those threads hanging, sometimes indefinitely. The <kbd>--timeout</kbd> parameter allows you to pass as an argument to specify how long <kbd>arachni</kbd> should wait before shutting down and compiling a report based on the collected data.</p>
<pre><strong>--checks</strong></pre>
<p>By default, when you target a URL, without passing any extra information, you'll be applying every check <kbd>arachni</kbd> has in its system. But sometimes you might want to exclude some lower-priority warnings—<kbd>arachni</kbd>, for example, will warn you when a company email is exposed publicly, but usually that's not an issue if the email is a corporate handle or meant to otherwise be customer-facing. Some forms of data leakage are important, but for most companies this is not one of them. You also might want to exclude noisy checks that would put too much of a load on the target server or network architecture.</p>
<p>The <kbd>checks</kbd> option takes as its arguments the checks you should include and exclude, with the splat character <kbd>*</kbd> operating as its usual stand-in for all options and excluded checks indicated by the use of a minus sign (<kbd>-</kbd>).</p>
<pre><strong>--scope-include-subdomains</strong></pre>
<p>This switch does just what it sounds like—it tells <kbd>arachni</kbd> that, when it spiders a URL, it's free to follow any links it finds to that site's subdomains.</p>
<pre><strong>--plugin 'PLUGIN:OPTION=VALUE,OPTION2=VALUE2'</strong></pre>
<p>The <kbd>plugin</kbd> option allows us to pass environment variables that an <kbd>arachni</kbd> plugin might depend on (authentication tokens for SaaS variables, configuration settings, SMTP usernames and passwords, and so on).</p>
<pre><strong>--http-request-concurrency MAX_CONCURRENCY</strong></pre>
<p>Arachni's ability to keep its HTTP requests in check is critical to ensuring a target server isn't overwhelmed with traffic. Even if scans are allowed under the terms of engagement for a specific target range, they'll typically set a speed limit for the scanner to prevent the equivalent of a DoS attack. And regardless, turning your request concurrency down can ensure you don't get hit by a WAF. The default for the scanner's <kbd>MAX_CONCURRENCY</kbd> is <kbd>20</kbd> HTTP requests/second.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing a Wrapper Script</h1>
                </header>
            
            <article>
                
<p>Just as we wrote our <kbd>bootstrap_burp.sh</kbd> script as a convenient wrapper around the longer command initializing Burp's <kbd><span>JAR</span> </kbd>file, so that we don't have to type the full path and all our options each time we start the application, we can do the same for <kbd>arachni</kbd>. Putting together all of the options we've just covered (except for <kbd>--plugins</kbd>), this is what our script looks like. We'll call it <kbd>ascan.sh</kbd>:</p>
<pre><strong>#!/bin/sh</strong><br/><br/><strong>arachni $1 \</strong><br/><strong>    --checks=*,-emails* \</strong><br/><strong>    --scope-include-subdomains \</strong><br/><strong>    --timeout 1:00:00 \</strong><br/><strong>    --http-request-concurrency 10</strong></pre>
<p>Like <kbd>bootstrap_burp.sh</kbd>, we can make it executable through a simple <kbd>chmod u+x ascan.sh</kbd> and add it into our path by using <kbd>sudo ln -s /Path/to/ascan.sh /usr/local/bin/ascan</kbd>.</p>
<p>The timeout is admittedly long, to accommodate the longer hangups that occur with a smaller request pool, as well as the extended waiting necessary because of time-based SQLi calls.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">NoSQL Injection – Injecting Malformed MongoDB Queries</h1>
                </header>
            
            <article>
                
<p class="mce-root">According to OWASP, there are over 150 varieties of NoSQL database available for use in web applications. We're going to take a look specifically at MongoDB, the most widely-used, open source, unstructured NoSQL database, to illustrate how injection can work across a variety of toolsets.</p>
<p class="mce-root">The MongoDB API usually expects BSON data (binary JSON) constructed using a secure BSON query construction tool. But in certain cases, MongoDB can also accept unserialized JSON and JavaScript expressions—like in the case of the <kbd>$where</kbd> operator.<br/>
It's usually used—like the SQL <kbd>WHERE</kbd> operator—as a filter:</p>
<pre><strong>db.myCollection.find( { $where: "this.foo == this.baz" } );</strong></pre>
<p class="mce-root"/>
<p>You can get more complicated with the expression, of course. Ultimately, if the data is not properly sanitized, the MongoDB <kbd>$where</kbd> clause is capable of inserting and executing entire scripts written in JavaScript. Unlike SQL, which is declarative and somewhat limited as a language, MongoDB's NoSQL support for sophisticated JavaScript conditionals opens it up to exploits served by the language's full range of features.</p>
<p>You can see patterns to how this type of vulnerability is commonly exploited. On GitHub and other code-sharing sites, you can find lists enumerating different malicious MongoDB <kbd>$where</kbd> inputs, like this one: <a href="https://github.com/cr0hn/nosqlinjection_wordlists">github.com/cr0hn/nosqlinjection_wordlists</a>.<a href="https://github.com/cr0hn/nosqlinjection_wordlists"/></p>
<p>Some inputs are designed as <strong>Denial-of-Service </strong>(<strong>DoS</strong>)<strong> </strong>and resource consumption attacks:</p>
<pre><strong>';sleep(5000); ';it=new%20Date();do{pt=new%20Date();}while(pt-it&lt;5000);</strong></pre>
<p>While some aim for password discovery:</p>
<pre><strong>' &amp;&amp; this.password.match(/.*/)//+%00</strong></pre>
<p>Another vector for code injection within MongoDB is available within PHP implementations. Since <kbd>$where</kbd> is not only a MongoDB reserved word, but valid PHP, an attacker can potentially submit code into a query by creating a <kbd>$where</kbd> variable.</p>
<p>But regardless of the implementation, these attacks all rely on the same principle as general injection attacks—unsanitized data being mistaken for and executed as an application command.</p>
<p>As MongoDB shows, the principle of malformed input changing the logic of a developer's code is a problem that extends well beyond SQL or any other specific language, framework, or tool.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">SQLi – An End-to-End Example</h1>
                </header>
            
            <article>
                
<p>Returning to <kbd>arachni</kbd>, let's point it at <kbd>webscantest.com/datastore</kbd> and see what we find, kicking it off with a scan: <a href="http://webscantest.com/datastore/">https://webscantest.com/datastore</a>.</p>
<p>After running the scan (which will take a while), <kbd>arachni</kbd> will print out the results to the console and generate an <kbd>AFR </kbd>file. The <kbd><span>AFR</span></kbd>extension stands for Arachni Framework Report and is what <kbd>arachni</kbd> uses to store scan results. That <kbd><span>AFR</span> </kbd>file can then be converted to HTML, JSON, XML, or another document format:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c2635c71-9df0-48bb-9956-ea82e2d5435b.png"/></div>
<p>We can immediately see there's a vulnerability to explore in greater detail here. This is a good opportunity to use the HTML version of the report, which takes advantage of the browser to visualize the entire scan results.<br/>
<br/>
When you want to analyze the results of your scan, you can generate a zipped HTML file using the <kbd>arachni_reporter</kbd> executable:</p>
<pre><strong>arachni_reporter some_report.afr --reporter=html:outfile=my_report.html.zip</strong></pre>
<p>It's important to specify the outfile as zipped HTML, because that's the format the <kbd>arachni_reporter</kbd> will use to create it. If you leave off the <kbd>zip</kbd> suffix and just try to open the resulting HTML file, your browser will show a long stream of unformatted, unintelligible special characters.</p>
<p>The following is what you get when you unzip and view the file in a browser:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ba370d1c-3ae5-4718-bcd9-52caf9f6c3bb.png" style=""/></div>
<p>Arachni shows us a nice overview of the issues discovered. Drilling down, we can find a few instances of SQLi. Let's look at one of the timing issues:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d9af206c-59bd-43c3-96e2-54280b6ee224.png" style=""/></div>
<p>Scrolling past some of the explanatory text and remediation guidance, we can see the payload and affected URLs, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8034b465-9d93-4c8b-8de4-1dfedb3f8e23.png"/></div>
<p>Now we can write our report.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gathering Report Information</h1>
                </header>
            
            <article>
                
<p>Let's walk through the info we need to write our report.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Category</h1>
                </header>
            
            <article>
                
<p>This is a time-based SQL injection attack.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Timestamps</h1>
                </header>
            
            <article>
                
<p>For our timestamp, we can provide an estimate.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URL</h1>
                </header>
            
            <article>
                
<p>The vulnerability's URL is provided clearly in the <kbd>arachni</kbd> report:</p>
<pre><strong>http://webscantest.com/datastore/search_by_id.php</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Payload</h1>
                </header>
            
            <article>
                
<p>The SQLi payload is listed prominently in both the console and HTML reports under injected seed:</p>
<pre><strong>sleep(16000/1000);</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Methodology</h1>
                </header>
            
            <article>
                
<p>Again, only use a scanner if you're authorized to! We would report this finding as coming from version <kbd>1.5.1</kbd> of Arachni.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Instructions to Reproduce</h1>
                </header>
            
            <article>
                
<p>Rather than simply pointing to <kbd>arachni</kbd>, we want to list the steps to manually recreate the vulnerability we're reporting. In this case, that will be navigating to the form on the affected page, entering the payload, and hitting <span class="packt_screen">Submit</span>. There's no encoding, DOM manipulation, or other tricks required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Attack Scenario</h1>
                </header>
            
            <article>
                
<p>When a SQL database suffers from a time-based injection attack, that vulnerability allows an attacker to enumerate information available in a database through the tactical use of expressions and the SQLi-induced pause. An attack could exfiltrate business or payment data, sensitive tokens/authentication credentials, or any number of other critical pieces of information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Final Report</h1>
                </header>
            
            <article>
                
<p>Let's use this information to format our submission:</p>
<pre><strong>CATEGORY: Blind SQLi (time-based)</strong><br/><br/><strong>TIME: 2018-06-18 3:23 AM (3:23) UTC</strong><br/><br/><strong>URL: http://webscantest.com/datastore/search_by_id.php</strong><br/><br/><strong>PAYLOAD: sleep(16000/1000);</strong><br/><br/><strong>METHODOLOGY: Vulnerability detected with Arachni scanner, v. 1.5.1-0.5.12</strong><br/><br/><strong>INSTRUCTIONS TO REPRODUCE:</strong><br/><br/><strong>1. Navigate to "/search_by_id.php"</strong><br/><strong>2. Enter the SQLi payload into the search form.</strong><br/><strong>3. Submit the query.</strong><br/><strong>4. The time-based SQLi code will cause a delay in the SQL thread execution.</strong><br/><br/><strong>ATTACK SCENARIO:</strong><br/><strong>With a time-based SQL injection vulnerability to exploit, a malicious actor could use the time-delay combined with SQL expressions to enumerate sensitive information—authentication credentials, payment data, DB information, and more.</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter covered the fundamentals of SQL and NoSQL injection, using <kbd>sqlmap</kbd> to test a target host URL, the value of Google Dorks for both application-targeted and general vulnerability analysis, and reporting a SQLi bug properly, from detection to submission.</p>
<p>In the next chapter, we'll discuss cross-site request forgery (CSRF), how to create (and automate) CSRF PoCs, where CSRF occurs, validating a CSRF vulnerability, strategies for reporting the bug, and more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What are blind SQLi, error-based SQLi, and time-based SQLi?</li>
<li>What are some of the dangers of trying to detect SQLi vulnerabilities using aggressive string inputs?</li>
<li>What's a Google dork? How did it get its name?</li>
<li>What command-line options are particularly useful for the <kbd>arachni</kbd> CLI?</li>
<li>How do you generate a report from an Arachni Framework Report (<kbd><span>AFR</span></kbd>) file?</li>
<li>What are some injection vectors in MongoDB?</li>
<li>What's the value of being able to make a SQL thread sleep?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further Reading</h1>
                </header>
            
            <article>
                
<p class="mce-root">You can find out more about some of the topics we have discussed in this chapter at:</p>
<ul>
<li>Arachni GitHub Page: <a href="https://github.com/Arachni/arachni">https://github.com/Arachni/arachni</a></li>
<li>Exploit DB: <a href="https://ww.exploit-db.com">https://ww.exploit-db.com</a></li>
<li>GoogleDorking: <a href="http://www.google-dorking.com">http://www.google-dorking.com</a></li>
</ul>


            </article>

            
        </section>
    </body></html>