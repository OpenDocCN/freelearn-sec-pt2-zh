- en: SQL, Code Injection, and Scanners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code injection is when unvalidated data is added (injected) into a vulnerable
    program and executed. Injection can occur in SQL, NoSQL, LDAP, XPath, NoSQL, XML
    parsers, and even through SMTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: The XSS vulnerabilities discussed in the previous chapter are also examples
    of code injection. When an unsanitized HTML tag with malicious code in its attribute
    is added to a web application's database via a comment thread or discussion board
    submission, that code is injected into the application and executed when other
    users view that same comment or discussion.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this chapter though, we're going to focus on detecting and
    preventing code injection attacks related to databases—SQL and NoSQL, respectively.
    We'll cover how to use CLI tools to test a form input for SQLi vulnerabilities,
    how to use similar techniques for NoSQLi, scanning for both SQLi and other injection
    attacks, and best practices for avoiding damage to your target's database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLi and other code injection attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing for SQLi with `sqlmap`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trawling for bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning for SQLi with Arachni
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An end-to-end example of SQLi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, in addition to our existing Burp and Burp Proxy integration
    with Chrome (`66.0.3359.139`), we'll also be using `sqlmap`, a CLI tool for detecting
    SQL- and NoSQL-based injections. `sqlmap` can be installed using Homebrew with
    `brew install sqlmap` and is also available as a Python module installable via
    `pip`. `sqlmap` is a popular tool, so there should be an installation path for
    you whatever your system.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also be using Arachni as our go-to scanner. Though noisy, scanners can
    be indispensable for the appropriate situation, and are great at flushing out
    otherwise hard-to-detect bugs. Arachni is an excellent choice because it's open
    source, multi-threaded, extensible via plugins, and has a great CLI that allows
    it to be worked into other automated workflows. Arachni is easy to install; you
    can install it as a gem (`gem install arachni`) or you can simply download the
    official packages straight from the installation site.
  prefs: []
  type: TYPE_NORMAL
- en: Please install Arachni from the site's Download page at [http://www.arachni-scanner.com/download/#Mac-OSX.](http://www.arachni-scanner.com/download/#Mac-OSX)
  prefs: []
  type: TYPE_NORMAL
- en: After you've installed it, if you've downloaded the packages for the appropriate
    system, you'll want to move them to wherever is appropriate within your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you can create a symlink (symbolic link) so that all the `arachni` CLI
    packages will be available within your path (fill in the correct path to your
    `arachni` installation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You might find that, after you symlink your `arachni` executables to your path,
    you receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you receive this error, simply symlink, copy, or move the `readlink_f.sh`
    script from your `arachni` installation''s `bin` directory to your own path. In
    this case, we''ll symlink it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now when we use `arachni` later in the chapter, we can invoke it directly, as
    opposed to having to type the full path each time.
  prefs: []
  type: TYPE_NORMAL
- en: SQLi and Other Code Injection Attacks – Accepting Unvalidated Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLi is a rather old vulnerability. It's been two decades since the first public
    disclosures of the attack started appearing in 1998, detailed in publications
    such as Phrack, but it persists, often in critically damaging ways. SQLi vulnerabilities
    can allow an attacker to read sensitive data, update database information, and
    sometimes even issue OS commands. As OWASP succinctly states, the "flaw depends
    on the fact that SQL makes no real distinction between the control and data planes."
    This means that SQL commands can modify both the data they contain and parts of
    the underlying system running the software, so when the access prerequisites for
    a feature such as sqlmap's `--os-shell` flag are present, a SQLi flaw can be used
    to issue system commands.
  prefs: []
  type: TYPE_NORMAL
- en: Many tools and design patterns exist for preventing SQLi. But the pressure of
    getting new applications to market and iterating quickly on features means that
    SQLi-vulnerable inputs don't get audited, and the procedures to prevent the bug
    are never put into place.
  prefs: []
  type: TYPE_NORMAL
- en: As a vulnerability endemic to one of the most common languages for database
    development and as an easily detected, easily exploited, and richly rewarded bug,
    SQLi is a worthy subject for study.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple SQLi Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at how SQLi breaks down into actual code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following query, where the value of `$id` would be input
    supplied by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: One common SQLi technique is to input data that can change the context or logic
    of the SQL statement's execution. Because that `$id` value is being inserted directly—with
    no data sanitization, removal of dangerous code, or data type transformation—the
    SQL statement is dynamic, and subject to tampering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a change that will affect the execution of the statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `10 OR 1=1` is the user-supplied data. By modifying the `WHERE`
    clause, the user can alter the logic of the developer-supplied part of the executed
    example. The preceding example is pretty innocuous, but if the statement asked
    for account information from a user table, or a part of the database associated
    with privileges, instead of just information about a blog post, that could represent
    a way to seriously damage the application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for SQLi With Sqlmap – Where to Find It and How to Verify It
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`sqlmap` is a popular CLI tool for detecting and exploiting SQLi vulnerabilities.
    Since we''re only interested in discovering those bugs, we''re less interested
    in the weaponization, except for brainstorming possible attack scenarios for report
    submissions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest use of `sqlmap` is using the `-u` flag to target the parameters
    being passed in a specific URL. Using `webscantest.com` again as our example target,
    we can test the parameters in a form submission specifically vulnerable to `GET`
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/8afa3f4a-8dd8-4939-a2bd-c30605d6ac17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As `sqlmap` begins probing the parameters passed in the target URL, it will
    prompt you to answer several questions about the direction and scope of the attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you can successfully identify the backend through your own investigations,
    it's a good idea to say yes here, just to reduce any possible noise in the report.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also get a question about what `risk` level of input values you''re
    willing to tolerate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`sqlmap`, as a tool designed to both detect SQLi vulnerabilities and exploit
    them, needs to be handled with care. Unless you''re testing against a sandboxed
    instance, completely independent from all production systems, you should go with
    the lower risk-level settings. Using the lowest risk level ensures that `sqlmap`
    will test the form with malicious SQL inputs designed to cause the database to
    sleep or enumerate hidden information—and not corrupt data or compromise authentication
    systems. Because of the sensitivity of the information and processes contained
    in the targeted SQL database, it''s important to tread carefully with vulnerabilities
    associated with backend systems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `sqlmap` runs through its range of test inputs, it will prompt you to
    ask about targeting other parameters. Once you''ve run through all the parameters
    passed in the targeted URL, `sqlmap` will print out a report of all the vulnerabilities
    discovered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2983a87b-790c-4600-b6fc-58604df95930.png)'
  prefs: []
  type: TYPE_IMG
- en: Success! There are a few vulnerabilities related to the `id` parameter, including
    a pair of blind SQLi vulnerabilities (where the results of the injection are not
    directly visible in the GUI) and error- and `UNION`-based inputs—all confirmed
    by the documentation on `webscantest.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Trawling for Bugs – Using Google Dorks and Python for SQLi Discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `sqlmap` requires a URL to target—one that will contain testable parameters.
    This next technique can be used to target specific applications and form inputs—like
    `sqlmap` does—or to simply return a list of sites susceptible to SQLi vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Google Dorks for SQLi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Google Dorks—sometimes called Google hacking—means employing specially-crafted
    search queries to get search engines to return sites susceptible to SQLi and other
    vulnerabilities. The name Google dork refers to a hapless employee misconfiguring
    their site and exposing sensitive corporate information online.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of common Google Dorks for discovering instances of
    SQLi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the queries are designed to return results, where the sites discovered
    are at least theoretically susceptible to SQLi (because of the sites'' URL structure).
    The basic form of a dork is `search_method:domain/dork`, where the `search_method`
    and dork are calibrated to look for a specific type of vulnerability and `domain`
    is used for when you''d like to target a specific application. For example, here''s
    a dork designed to return insecure CCTV feeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This dork doesn't target a particular URL; it's simply looking for any site
    where the page's title contains `Evocam` and the page's URL contains `webcam.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Validating a Dork
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While browsing a small security site, I find the following dork, listed on
    the company''s Bugtraq section (the title of the company featured in the `intext`
    field has been changed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This dork, though it doesn't have a target URL, does focus on a particular company
    via the `intext` search filter. For the `inurl` value, `jsp` is the file extension
    for JSP, a web application framework for Java servlets. `jsp` is a little old—it
    was Sun Microsystems' response to Microsoft's **Active Server Pages** (**ASP**)
    in 1999—but like so much tech, is still employed in legacy industries, small businesses,
    and small `dev` shops.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use this dork to search Google, our first result returns a URL containing
    `index.jsp?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can see the site is making a `GET` request, passing a parameter identifying
    the page visited (`idPagina`). Let's check that and see if it's vulnerable, which
    we can do by passing the URL to `sqlmap`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a valid `sqlmap` command. The cool thing about the tool is that it
    also supports an option for Dorks, `-g`, making it also possible to pass a string
    of the dork you''d like to search (instead of doing the search manually):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, `sqlmap` will use that dork to search Google and then take
    the results from the first page and analyze them one-by-one, prompting you each
    time to ask if you want to analyze the URL, skip it, or quit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking the results from just the first search result—the one we targeted directly
    by passing the URL to `sqlmap` via `-u`—we can see both time-based and error-based
    SQLi vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/37a4adc5-ef18-4b4f-bab4-df80f05c375b.png)'
  prefs: []
  type: TYPE_IMG
- en: Time-based SQLi is when `SLEEP()` or another similar function is called to inject
    a delay into the query being processed. This delay, combined with conditionals
    and other logic, is then used to extract information from a database by slowly
    enumerating resources. If your payload produces a delay, you can infer your condition
    evaluated to `true` and the assumptions you made are correct. Doing this enough
    can expose sensitive information to determined attackers. As an attack, time-based
    SQLi is very noisy. The impact on application logs is relatively small, but repeated
    use of time-based SQLi will cause large CPU consumption spikes, easily detectable
    by an attentive sysadmin or SRE.
  prefs: []
  type: TYPE_NORMAL
- en: If we take the payload from the `sqlmap` time-based results (`12 RLIKE SLEEP(5)`)
    and plug it into the `idPagina` URL parameter, we find it's successful! The page
    takes longer to load as our `SLEEP(5)` command is not sanitized and gets mistakenly
    executed by the application's SQL server. This is a bona fide bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Error-based SQLi is also returned as a vector for `idPagina`. Error-based SQLi
    is when a SQL command can be made to expose sensitive database information through
    error messages. Again, let''s use this payload as the `idPagina` URL parameter
    and enter it all into the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: We're successful! The page returns a table ID. Exposing sensitive database info
    more than meets the threshold for a valid SQLi vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for SQLi With Arachni
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the *Technical requirements* section, `arachni` is our weapon
    of choice for SQLi scanners because it's open source, extensible, multi-threaded,
    and can be used from a CLI that plays nicely with other forms of automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing `arachni` as per the requirements (and symlinking your installation''s
    `arachni` executable), you''ll be able to access the `arachni` CLI in your `$PATH`.
    Let''s look at Arachni''s help message to explore some of the options available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b6fd496f-2a04-44e9-94c5-863b47f9b0a6.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a truncated version of the output. Arachni has so many options there
    are too many to reprint here. But certain CLI options are useful for extending
    Arachni's functionality and creating more sophisticated workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Going Beyond Defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like many scanners, `arachni` can be point-and-click almost to a fault. Though
    no extra arguments are required to start spidering a URL from the command-line,
    there are several critical options we should be aware of to get better functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When you set `arachni` loose on a URL it spins up multiple threads that start
    bombarding the target with the malicious snippets and exploratory requests all
    scanners use to flush out interesting behavior. If you're going too quickly though
    and get hit by a WAF throttling your traffic, you might find some or all of those
    threads hanging, sometimes indefinitely. The `--timeout` parameter allows you
    to pass as an argument to specify how long `arachni` should wait before shutting
    down and compiling a report based on the collected data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: By default, when you target a URL, without passing any extra information, you'll
    be applying every check `arachni` has in its system. But sometimes you might want
    to exclude some lower-priority warnings—`arachni`, for example, will warn you
    when a company email is exposed publicly, but usually that's not an issue if the
    email is a corporate handle or meant to otherwise be customer-facing. Some forms
    of data leakage are important, but for most companies this is not one of them.
    You also might want to exclude noisy checks that would put too much of a load
    on the target server or network architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The `checks` option takes as its arguments the checks you should include and
    exclude, with the splat character `*` operating as its usual stand-in for all
    options and excluded checks indicated by the use of a minus sign (`-`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This switch does just what it sounds like—it tells `arachni` that, when it spiders
    a URL, it's free to follow any links it finds to that site's subdomains.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `plugin` option allows us to pass environment variables that an `arachni`
    plugin might depend on (authentication tokens for SaaS variables, configuration
    settings, SMTP usernames and passwords, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Arachni's ability to keep its HTTP requests in check is critical to ensuring
    a target server isn't overwhelmed with traffic. Even if scans are allowed under
    the terms of engagement for a specific target range, they'll typically set a speed
    limit for the scanner to prevent the equivalent of a DoS attack. And regardless,
    turning your request concurrency down can ensure you don't get hit by a WAF. The
    default for the scanner's `MAX_CONCURRENCY` is `20` HTTP requests/second.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Wrapper Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as we wrote our `bootstrap_burp.sh` script as a convenient wrapper around
    the longer command initializing Burp''s `JAR` file, so that we don''t have to
    type the full path and all our options each time we start the application, we
    can do the same for `arachni`. Putting together all of the options we''ve just
    covered (except for `--plugins`), this is what our script looks like. We''ll call
    it `ascan.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Like `bootstrap_burp.sh`, we can make it executable through a simple `chmod
    u+x ascan.sh` and add it into our path by using `sudo ln -s /Path/to/ascan.sh
    /usr/local/bin/ascan`.
  prefs: []
  type: TYPE_NORMAL
- en: The timeout is admittedly long, to accommodate the longer hangups that occur
    with a smaller request pool, as well as the extended waiting necessary because
    of time-based SQLi calls.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL Injection – Injecting Malformed MongoDB Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to OWASP, there are over 150 varieties of NoSQL database available
    for use in web applications. We're going to take a look specifically at MongoDB,
    the most widely-used, open source, unstructured NoSQL database, to illustrate
    how injection can work across a variety of toolsets.
  prefs: []
  type: TYPE_NORMAL
- en: The MongoDB API usually expects BSON data (binary JSON) constructed using a
    secure BSON query construction tool. But in certain cases, MongoDB can also accept
    unserialized JSON and JavaScript expressions—like in the case of the `$where`
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s usually used—like the SQL `WHERE` operator—as a filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can get more complicated with the expression, of course. Ultimately, if
    the data is not properly sanitized, the MongoDB `$where` clause is capable of
    inserting and executing entire scripts written in JavaScript. Unlike SQL, which
    is declarative and somewhat limited as a language, MongoDB's NoSQL support for
    sophisticated JavaScript conditionals opens it up to exploits served by the language's
    full range of features.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see patterns to how this type of vulnerability is commonly exploited.
    On GitHub and other code-sharing sites, you can find lists enumerating different
    malicious MongoDB `$where` inputs, like this one: [github.com/cr0hn/nosqlinjection_wordlists](https://github.com/cr0hn/nosqlinjection_wordlists).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some inputs are designed as **Denial-of-Service** (**DoS**)and resource consumption
    attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'While some aim for password discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Another vector for code injection within MongoDB is available within PHP implementations.
    Since `$where` is not only a MongoDB reserved word, but valid PHP, an attacker
    can potentially submit code into a query by creating a `$where` variable.
  prefs: []
  type: TYPE_NORMAL
- en: But regardless of the implementation, these attacks all rely on the same principle
    as general injection attacks—unsanitized data being mistaken for and executed
    as an application command.
  prefs: []
  type: TYPE_NORMAL
- en: As MongoDB shows, the principle of malformed input changing the logic of a developer's
    code is a problem that extends well beyond SQL or any other specific language,
    framework, or tool.
  prefs: []
  type: TYPE_NORMAL
- en: SQLi – An End-to-End Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Returning to `arachni`, let''s point it at `webscantest.com/datastore` and
    see what we find, kicking it off with a scan: [https://webscantest.com/datastore](http://webscantest.com/datastore/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the scan (which will take a while), `arachni` will print out
    the results to the console and generate an `AFR` file. The `AFR`extension stands
    for Arachni Framework Report and is what `arachni` uses to store scan results.
    That `AFR` file can then be converted to HTML, JSON, XML, or another document
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2635c71-9df0-48bb-9956-ea82e2d5435b.png)'
  prefs: []
  type: TYPE_IMG
- en: We can immediately see there's a vulnerability to explore in greater detail
    here. This is a good opportunity to use the HTML version of the report, which
    takes advantage of the browser to visualize the entire scan results.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to analyze the results of your scan, you can generate a zipped
    HTML file using the `arachni_reporter` executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It's important to specify the outfile as zipped HTML, because that's the format
    the `arachni_reporter` will use to create it. If you leave off the `zip` suffix
    and just try to open the resulting HTML file, your browser will show a long stream
    of unformatted, unintelligible special characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what you get when you unzip and view the file in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ba370d1c-3ae5-4718-bcd9-52caf9f6c3bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Arachni shows us a nice overview of the issues discovered. Drilling down, we
    can find a few instances of SQLi. Let''s look at one of the timing issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d9af206c-59bd-43c3-96e2-54280b6ee224.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Scrolling past some of the explanatory text and remediation guidance, we can
    see the payload and affected URLs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8034b465-9d93-4c8b-8de4-1dfedb3f8e23.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we can write our report.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering Report Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's walk through the info we need to write our report.
  prefs: []
  type: TYPE_NORMAL
- en: Category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a time-based SQL injection attack.
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our timestamp, we can provide an estimate.
  prefs: []
  type: TYPE_NORMAL
- en: URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The vulnerability''s URL is provided clearly in the `arachni` report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Payload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SQLi payload is listed prominently in both the console and HTML reports
    under injected seed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, only use a scanner if you're authorized to! We would report this finding
    as coming from version `1.5.1` of Arachni.
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to Reproduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than simply pointing to `arachni`, we want to list the steps to manually
    recreate the vulnerability we're reporting. In this case, that will be navigating
    to the form on the affected page, entering the payload, and hitting Submit. There's
    no encoding, DOM manipulation, or other tricks required.
  prefs: []
  type: TYPE_NORMAL
- en: Attack Scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a SQL database suffers from a time-based injection attack, that vulnerability
    allows an attacker to enumerate information available in a database through the
    tactical use of expressions and the SQLi-induced pause. An attack could exfiltrate
    business or payment data, sensitive tokens/authentication credentials, or any
    number of other critical pieces of information.
  prefs: []
  type: TYPE_NORMAL
- en: Final Report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use this information to format our submission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the fundamentals of SQL and NoSQL injection, using `sqlmap`
    to test a target host URL, the value of Google Dorks for both application-targeted
    and general vulnerability analysis, and reporting a SQLi bug properly, from detection
    to submission.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss cross-site request forgery (CSRF), how to
    create (and automate) CSRF PoCs, where CSRF occurs, validating a CSRF vulnerability,
    strategies for reporting the bug, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are blind SQLi, error-based SQLi, and time-based SQLi?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the dangers of trying to detect SQLi vulnerabilities using
    aggressive string inputs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's a Google dork? How did it get its name?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command-line options are particularly useful for the `arachni` CLI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you generate a report from an Arachni Framework Report (`AFR`) file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some injection vectors in MongoDB?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the value of being able to make a SQL thread sleep?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more about some of the topics we have discussed in this chapter
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arachni GitHub Page: [https://github.com/Arachni/arachni](https://github.com/Arachni/arachni)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exploit DB: [https://ww.exploit-db.com](https://ww.exploit-db.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GoogleDorking: [http://www.google-dorking.com](http://www.google-dorking.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
