- en: CSRF and Insecure Session Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cross-Site Request Forgery** (**CSRF**) is when an attacker takes advantage
    of a logged-in user''s authenticated state to execute malicious application requests
    and change the user''s app in harmful ways. Because the attacker can''t see the
    result of any attack, it''s usually less about exfiltrating information and more
    about exploiting the app''s capabilities (for example, making the user of a mobile
    payment system send money to the wrong person). There''s often a strong social
    engineering aspect involved: phishing and other techniques are used to get a user
    to click on the link that will kick off a malicious request and act as the CSRF
    attack vector.'
  prefs: []
  type: TYPE_NORMAL
- en: CSRF is often possible because authentication credentials or cookies meant for
    one part of an application mistakenly allow access to another. An example would
    be that while you're logged into PayPal or another payment app, you click on a
    link sent to you in a chat session. The link executes code that takes the authentication
    cookie you have in your browser to make an (authenticated) request sending money
    to the attacker. Unlike XSS, the danger isn't that you'll send sensitive information
    to the attacker, allowing them to impersonate or defraud you later;  instead,
    the danger is a direct consequence of the actions you're allowed to take as a
    logged-in user of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Many frameworks (Spring, Joomla, and Django) have their own solutions for preventing
    CSRF, which usually consist of tying a cookie's authentication ability to a specific
    in-app action. But, despite CSRF's status as a solved problem, it persists as
    a recurring bug in the annual OWASP Top-10 surveys. Like SQLi, CSRF is a simple-but-damaging
    vulnerability that endures largely because of the tension in software development
    between security and productivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Mechanics of CSRF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools to use for finding and validating CSRF vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering, validating, and reporting on CSRF vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we'll be using Burp Suite and—for our everyday web browsing
    and proxy—Chrome (`66.0.3359.139`). We'll once again be employing Python 3.6.5
    and the standard macOS version of shell (`sh`) for scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Building and Using CSRF PoCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CSRF proof of concept is just a short HTML snippet that, when executed by
    a user, will take advantage of the weak CSRF defence and change the application
    state in unexpected or unwanted ways, validating the vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CSRF PoC Code Snippet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the basis for building a CSRF PoC snippet, let''s go back to a form on the
    deliberately-vulnerable web app, `webscantest.com`, that''s vulnerable to both
    XSS and CSRF:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f06d3b4b-5385-4cee-8b16-efb698a731f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can fill in the values for our form, entering the information for one
    `William` `Private Mandella` `Mandella`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/89b33017-93ea-44cb-8fca-1dea49657bb0.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to build our CSRF PoC, it can be helpful to see the form as an HTTP
    action, so we can grab the type of data-encoding, HTTP verb, and form-field information
    all at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to view that request, make sure you''re viewing the page in a browser
    connected to your Burp Proxy and then turn the intercept feature on from within
    the Proxy tab. Clicking Submit, you should see the form hang as the Burp Proxy
    intercepts (and holds onto) the form''s HTTP `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d84b9b57-a399-459d-9a9d-95b15028e072.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From this, we can deduce all the necessary parts of our CSRF PoC. Let''s take
    a look at the code and then break down the rationale behind each tag and attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can see the form's `enctype` attribute is pulled directly from the intercepted
    request—`method` and the URL value for the `action` attributes too. In fact, this
    entire snippet is simply a reverse-engineered expression of the submission in
    HTML. We know what HTTP request the form created – now we've written the code
    to produce that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: This code imitates the form on the original `webscantest.com` page. But in the
    case of a real, malicious CSRF attack, the attacker probably wouldn't want to
    just trigger an exact duplicate of an ordinary request the user had already made.
    More likely, they'd alter it for their own purposes – switching financial routing
    numbers, changing account passwords, or altering some other piece of critical
    information.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the form fields might not be as ripe for exploitation, but the
    principal holds for more dangerous situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s still have a little fun by promoting `Private Mandella` to his rightful
    rank of major. Here''s the altered code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But if the intent is to deceive the target of the CSRF attack into doing what
    we want – unwittingly changing Mandella''s rank – why are we showing them? Why
    offer the user a chance to see or manipulate the `nick` input field at all? See
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this last snippet, we've changed the name of the `other-nick` input field
    with the `nick` label our hapless user is expecting, while making the real `nick`
    input hidden—which contains our secret value, the rank we think the major deserves.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, when you're creating a CSRF PoC as part of a bug-report submission,
    you want to make sure you're not actually changing or modifying sensitive information
    (such as a password or transaction amount), though it can be useful to make a
    small alteration in order to illustrate the possible impact of the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Validating Your CSRF PoC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've created a basic CSRF PoC, we can go about applying it to prove
    the presence of a CSRF vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our PoC snippet is extremely simple. We just open it as a local file
    in our browser and submit the form we''ve coded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/93b3182f-9213-49de-979f-b279b1a9f2f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Here's what our PoC looks like opened in Chrome. There's no CSS making it pretty
    – our HTML snippet is as bare bones as it gets – but in the case of a CSRF vulnerability
    being exploited in the wild, most of the fields would probably be hidden anyway,
    with either a fake form to get the user to make the submission, or a way of automatically
    submitting the form on page load. Note that in the `nick` field, we have `Private
    Mandella`—our decoy data in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s submit the form to see whether we can successfully forge the cross-site
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d150e526-88ae-462c-abf7-4f067e38dd04.png)'
  prefs: []
  type: TYPE_IMG
- en: Request forged! We've been redirected to a success screen indicating the `POST`
    request generated from our local form has been accepted! Also, critically, we
    can see our hidden field containing the real value for the `nick` input tag was
    the value accepted as formerly Private, which is now Major Mandella's nick.
  prefs: []
  type: TYPE_NORMAL
- en: This example might still seem fairly innocuous – messing with part of a username
    – but the ability to change a user's application state by altering their form
    data is serious. Even altering a username can actually be a clever way of stealing
    an account – if the affected application didn't allow password retrieval using
    only an account-linked email, the victim of the attack might not be able to resolve
    their authentication problems.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your CSRF PoC Programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than manually constructing a PoC just by eyeballing the intercepted HTTP
    request in our Burp proxy tab, it would be awfully nice if we had a script that
    could take the information we need as a series of input (from either a CLI argument,
    a web scraper, or another source).
  prefs: []
  type: TYPE_NORMAL
- en: Let's do it. With just a little Python, we can make a short script that painlessly
    formats our info into a CSRF PoC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining the data we''ll need to build the PoC. We''ll start
    defining those variables right after we set up our interpreter in our new `csrf_poc_generator.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This structure – strings for the basic `form` tag attributes and a `fields`
    list of dictionaries with all the information we need to build the different form
    fields – is simple enough as a starting point, while also allowing some basic
    capabilities. Specifically, the abilities to add an arbitrary amount of form fields
    and to add new attributes to make new form objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now we just need some logic to take this data and create the necessary HTML
    markup. Thankfully, the HTML parser we used in [Chapter 3](23759e04-8982-41fd-b936-580865a51439.xhtml),
    *Preparing for an Engagement* to extract the JavaScript from a page we were crawling
    for vulnerabilities – Beautiful Soup – can also be used to create markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s the code creating our outermost `html` tag that will wrap
    our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we''re just instantiating the HTML document as a single closed
    `html` tag. To insert a child element, we use this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Following each line of the script, we grab a reference to that root `html` element,
    create a new tag for the `form` that will be our CSRF PoC, then append that form
    tag as a child element to its `html` parent.
  prefs: []
  type: TYPE_NORMAL
- en: Using the module this way illustrates its advantages over plain string manipulation—we
    don't have to constantly break up and nest successive elements and the `append()`
    syntax also makes it easier to loop through and nest multiple children (which
    will come in handy).
  prefs: []
  type: TYPE_NORMAL
- en: 'With that structure in mind, we need to build the markup for the last (and
    most important) part of the PoC—the form fields. We''ll leverage the fact that
    we can nest multiple children in a loop and that we have our form field data stored
    in an enumerable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code gives us the right number of input, but of course we still need logic
    to add `type`, `name`, and other attributes. Note that, since we don''t need to
    latter retrieve the variable references for the tags we''re creating, we can go
    ahead and overwrite them with each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be wondering: why not just add another argument to the `new_tag()`
    call in order to address the input''s `name` and `type` in a single line?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `field_tag[''name''] = field[''name'']` line is an admittedly inelegant
    solution to the fact that `name` is a reserved keyword in Beautiful Soup. That
    means we need to use a part of the API that lets us define the attribute using
    a string, which this method does. Our final addition to complete the basic structure
    of the form is a submit `input` field. We can achieve that in two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the result of those additional changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To take this further, we need to extend our use of attributes, and finally use
    the other variables (such as `action` and `method`) we defined earlier. We can
    do that while also adding a `label` tag for each appropriate `input` field.
  prefs: []
  type: TYPE_NORMAL
- en: We can also extend our initial data structure to accompany some changes. Let's
    say we want to add a `value` attribute to each `input` (as we have in our other
    PoC). We can do that simply by adding an extra field in the dictionary for each
    form field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what it looks like when we put it all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you're familiar with Python, you'll notice the logic is wrapped in a function
    and then bootstrapped in the `if __name__ == "__main__"` conditional so that we
    get the expected behavior when we run the script from the command line (the HTML
    is printed to `STDOUT`). At the same time, we can build other Python modules that
    import the `generate_poc()` function without side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this generates the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It looks pretty much like the code we initially wrote from eyeballing the intercepted
    Burp request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to try it out! If we save this file, change Mandella''s rank again (making
    him a General), and open it in our browser, we can submit it to see whether our
    foray into meta-programming was a success:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/082c2992-dd79-4b31-8ccb-8449109b5062.png)'
  prefs: []
  type: TYPE_IMG
- en: Success! Based on a few simple data points, our code generated the code to prove
    this vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to complete this script. As previously mentioned, the initial
    variables could be populated by command-line arguments, data pulled from a site,
    or a simple application form. The preceding script is a good starting point for
    any of those approaches.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF – An End-to-End Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take another look at a CSRF vulnerability on `webscantest.com`. Here''s
    the form we''ll be testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/68f5b43b-7d59-4fee-ac76-3d2682f3a18b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Simple enough. Fire up the Burp proxy and make sure the Intercept feature is
    on, let''s fill in the form with a nice test value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dcaafd6e-2165-4ec4-82e9-2d95682ec700.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As a sidenote, Cyan is really cool – in the subtractive color system, Cyan
    is a primary color and can be created by removing red from white light. Let''s
    submit this form and then check back with Burp to see the intercepted request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7bdcadc4-9b31-4fe3-b72b-69a2d889c00e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'OK, noting the important information – the HTTP request method, the form encoding,
    the field data, and so on – let''s take a look at what happens when we turn Intercept
    off and allow the `POST` request to resolve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4bdd4353-82f1-497e-8c2b-8d862e3751ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Here's what a successful submission looks like. Critically for us, we can see
    what value the form submitted through the success message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s feed this information into our `csrf_poc_generator.py` script, making
    a few small changes where our important variables are declared so that we can
    pass them as command-line arguments. With those changes, here''s the new version
    of the top part of our script – notice the new `sys` and `ast` packages, and how
    we''re using `ast` to parse a text representation of a Python list into the actual
    data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of our script is exactly the same. Now we can pass our critical information
    from the command line. Passing the field information right now is a little ungainly,
    but in the future, we could have it read from a generated JSON file or other data
    source (such as a web scraper). Here''s what our one-liner currently looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is what the PoC it outputs looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what it looks like when we open it in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f54a1333-3434-4c1c-9688-155dce4da3e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Strictly speaking, this CSRF PoC does what we need it to: it illustrates that
    we can forge form requests that originate from our own sources. But to make it
    just a tiny bit more black hat (and show the bounty program a hint of how the
    vulnerability could be exploited), let''s add some hidden-field chicanery.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our snippet looks like as it changes the visible form field to
    a dummy value and creates a second hidden field that contains our actual payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the malicious part – where we're populating the property the
    web app will actually consume – that we're submitting Peasoup as the user's favorite
    color. The depths of our depravity know no bounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pretending to be a hapless user, when we open our snippet in the browser, we
    don''t see any red flags (on the surface). If we opened our `dev` tools and started
    inspecting the hidden field element, it would be a different story:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cddb7a90-63f4-4858-8c9a-28ab9b88fe00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go ahead and submit the form using our true favorite color: the visually
    beautiful and scientifically curious Cyan. What will the PoC return us? See the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fed35a19-6a69-4b5b-9328-78aa0fcb34f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Peasoup – the ugliest and most cursed of colors. But more importantly for us,
    the success message shows our PoC has proved what it set out to do. After we do
    one more refactoring pass – putting the command-line argument parsing in the `if
    __name__ == "__main__":` bootstrapping conditional, where it belongs – and adding
    a PEP8-compatible function docstring, this is what our `csrf_poc_generator.py`
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With our script all cleaned up and the vulnerability successfully proven, now
    we can write our report.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering Report Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's walk through the info we need to write our report.
  prefs: []
  type: TYPE_NORMAL
- en: Category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a CSRF `POST` method attack.
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our timestamp, we can use an approximate time for when we first submitted
    our CSRF PoC.
  prefs: []
  type: TYPE_NORMAL
- en: URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our case, the vulnerable URL is simply the target of the `POST` action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Payload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the PoC snippet we evil-ed up, the dastardly data alteration we made was
    forcing our user to select Peasoup as their favorite color. That's what we'll
    include as our Payload value.
  prefs: []
  type: TYPE_NORMAL
- en: Methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our PoC was generated programmatically based on information taken from the intercepted
    form's HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to Reproduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our instructions to reproduce, we can simply provide our CSRF PoC and list
    the very simple manual steps involved in submitting the forged form request.
  prefs: []
  type: TYPE_NORMAL
- en: Attack Scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the form where we've detected our vulnerability doesn't seem to be
    that critical (an individual's favorite color is not codeword-clearance-level
    information), the ability to change an individual's account information through
    unwanted application state changes is a serious flaw.
  prefs: []
  type: TYPE_NORMAL
- en: Final Report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use this information to format our submission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of **Cross-Site Request Forgery** (**CSRF**)
    as a vulnerability, created and validated a CSRF PoC, created a CSRF PoC programmatically,
    and successfully documented the vulnerability for a bug-report submission. Hopefully,
    you've also come away with a sense of why the bug can be so severe, and a few
    attack scenarios you can use for a future impact report.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is CSRF?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's one possible attack scenario for a malicious actor who discovers a CSRF
    vulnerability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the typical structure of a CSRF PoC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you use a CSRF PoC to validate a vulnerability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the advantage of using BeautifulSoup to generate HTML, as opposed to
    raw string manipulation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of CSRF attack did we engage in for our end-to-end example?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kind of CSRF markup would a malicious actor use? How would it differ from
    our PoCs? How would it be similar?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more about some of the topics we have discussed in this chapter
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Additional CSRF test vulnerabilities**: [http://webscantest.com/csrf/](http://webscantest.com/csrf/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
