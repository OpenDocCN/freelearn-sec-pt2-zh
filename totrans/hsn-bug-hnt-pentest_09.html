<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Framework and Application-Specific Vulnerabilities</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>Identifying a framework or application-specific vulnerability, including Known Component Vulnerabilities (identified by their CVE designation, which we'll discuss later), is a tricky business.</span></p>
<p class="mce-root">It's a universal stipulation of bug bounty programs that companies don't reward the same vulnerability twice—the first researcher to disclose a vulnerability is the only one that's rewarded. This goes hand in hand with the fact that companies usually won't reward already publicly disclosed bugs within two weeks of the discovery of the original zero-day (like everyone, they need time to deploy a patch), and they aren't interested in vendor-level vulnerabilities in third-party libraries. This might seem like a waste of time, then, except if we take two important points into consideration.</p>
<p>The cost of adoption is low. Since known component vulnerabilities are, well, known, it's much easier to build a tool to reliably find them, as opposed to less defined weaknesses in the architecture or logic of an application that require stepping through a UI manually. As with our example with Retire.js in <a href="23759e04-8982-41fd-b936-580865a51439.xhtml">Chapter 3</a>, <span><em>Preparing for an Engagement</em></span>,<span> </span>where we built a short set of scripts for detecting and reporting on client-side vulnerabilities in things like insecure jQuery libraries, it's a lightweight step that can be incorporated into any environment where we have access to the client-side source.</p>
<p>Understanding security posture is important. The term security posture is shorthand for the general capability of an application or network to prevent, detect, and respond to attacks. If you open up your diagnostic tools and see right away that there are several critical reported vulnerabilities in either the framework, language version, or a vendor service, that can tell you a lot about the security practices at that company. If so many low-hanging fruit are within reach, is their bounty program still young? Do they have an established policy for security life cycle management? If there's a path to an attack scenario from the discovered vulnerabilities—great!—but even if that's not the case, the information is valuable, for what it telegraphs might be lurking just beneath the surface.</p>
<p>It's all about the attack scenario. This is the most essential point: most guidelines for KCVs get thrown out the window in the face of a valid attack scenario. Companies aren't interested in contributing a patch upstream just to improve the jQuery attack surface—that's a lot of time spent validating, communicating about, and fixing a vulnerability ultimately on behalf of another organization. But if you can convince them that this affects their business, it can provoke a change (contributing a patch, updating the component, switching to a different solution for that service) that will trigger your reward.</p>
<p>This chapter will explain how to:</p>
<ul>
<li>Integrate known component vulnerability scanning into your Burp-based workflow</li>
<li>Use tools to find application-specific problems in software like WordPress, Django, and Ruby on Rails</li>
<li>Take a component-specific vulnerability from discovery, to validation, to submission</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical Requirements</h1>
                </header>
            
            <article>
                
<p>In this section, we'll be working with Burp and some of its extensions to set up KCV detection automatically. We'll also be relying on our usual browser setup to act as the Burp proxy. We'll also be using WPScan as both a CLI and a Burp extension.</p>
<p>The WPScan CLI comes with a variety of install options. Once again, we'll be using the container software Docker to download and run the <kbd>wpscan</kbd> CLI from within the context of a custom execution context packaged with everything it needs. Docker allows us to port this workflow anywhere we can install Docker, meaning that we don't need to worry about OS-specific behavior. And because Docker caches the WPScan CLI image, we can use it with only a marginal performance hit over a native installation.</p>
<p>Assuming that Docker is installed, to pull down the latest WPScan CLI image, simply run this quick command:</p>
<pre><strong>docker pull wpscanteam/wpscan</strong></pre>
<p>Then you have all the dependencies necessary to access the CLI using the <kbd>docker run</kbd> command to bootstrap <kbd>wpscan</kbd>. Here's an example one-liner straight from Docker Hub image's documentation:</p>
<pre><strong>docker run -it --rm wpscanteam/wpscan -u https://yourblog.com [options]</strong></pre>
<p>For testing purposes, the same team behind WPScan also provides a deliberately vulnerable WordPress install, which is similarly run off of a Docker container. To build the image locally, clone the GitHub repository (<a href="https://github.com/wpscanteam/VulnerableWordPress">https://github.com/wpscanteam/VulnerableWordPress</a>) and navigate into its root directory. Then, run the following commands:</p>
<pre><strong>docker build --rm -t wpscan/vulnerablewordpress .</strong><br/><strong>docker run --name vulnerablewordpress -d -p 80:80 -p 3306:3306 wpscan/vulnerablewordpress</strong></pre>
<p>Now, you should have a WordPress installation ready to be set up at <kbd>localhost:80</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/36ee790f-3b09-4a6a-bd74-cf867ac1a47b.png"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Known Component Vulnerabilities and CVEs – A Quick Refresher</h1>
                </header>
            
            <article>
                
<p>The <strong>Common Vulnerabilities and Exposures</strong> (<span><strong>CVE</strong>) </span>system describes itself as a dictionary that provides definitions for publicly disclosed vulnerabilities and disclosures. Its goal is to make it easier to share cybersecurity-related data across groups and technologies, understanding that the benefit of open coordination outweighs the risk of publicly advertising valid attacks. It's useful to keep in mind that CVE is a method for linking vulnerability databases and not a vulnerability database itself. That said, you'll often find CVE IDs to links to CVE information pages integrated into tools designed to detect known vulnerabilities. CVE entries are even built into the U.S National Vulnerability Database.</p>
<p>The structure of a CVE ID is direct: the identifier consists of the year plus a four digit (or more) integer. Until early 2015, CVE identifiers could only have a unique integer up to four digits long, but because that limits the total number of assignable IDs to 9,999 a year, it had to be expanded, and now can be of any length.</p>
<p>In addition to its ID, each CVE also typically comes packaged with certain information:</p>
<ul>
<li>An indication of whether the CVE has an entry or candidate status</li>
<li>A brief description of the vulnerability or exposure</li>
<li>Any appropriate references (for example, vulnerability reports, advisories from the OVAL-ID)</li>
</ul>
<p>OVAL-IDs are the unique identifiers that distinguish OVAL definitions. From the OVAL website:</p>
<div class="packt_quote">OVAL definitions are standardized, machine-readable tests written in the <strong>Open Vulnerability and Assessment Language</strong> (<strong>OVAL</strong>®) that check computer systems for the presence of software vulnerabilities, configuration issues, programs, and patches.</div>
<p>OVAL definition tests, like CVEs, are an attempt to coordinate an open, transparent system for standardizing pentesting vocabulary, and allow for more sharing between ethical hackers and their tools.</p>
<p>This quick introduction/refresher should come in handy the next time that you use any number of tools that leverage CVE as their primary security reference.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WordPress – Using WPScan</h1>
                </header>
            
            <article>
                
<p>According to WordPress, their framework powers 31% of all sites. The open-source CMS-for-everything is a titan, providing the basic engine for hobbyist and commercial sites alike, from everything to your uncle's blog to the White House landing page. As such, it's an incredibly large target for pentesters and hackers everywhere. WordPress, with its myriad of plugins and configuration options, provides a large attack surface that, often managed by administrators with little technical experience, can be tricky to secure. Every shoddily-coded plugins, monkey-patched pieces of WP core, or ancient installations can be the foothold necessary for an attacker to deface or compromise a WP site.</p>
<p>WPScan functionality comes packaged in a few different tools. For our purposes, the most important are the containerized Docker command-line interface and the Burp extension.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WPScan as a Dockerized CLI</h1>
                </header>
            
            <article>
                
<p>The advantage of using WPScan as a Dockerized CLI is that we can still take full advantage of the CLI—allowing us to embed the script in a larger automation setup—while not having to worry about dependency management issues like keeping our Ruby version up-to-date. We can even write a simple wrapper around the <kbd>docker run</kbd> command so that we don't need to enter so much boilerplate every time we use the script.</p>
<p>For example, if we create a shell script called <kbd>wpscan.sh</kbd> and call our Docker command, passing in the <kbd>"$@"</kbd> character so that all of our flags and command-line arguments get passed through the shell script to the <kbd>docker</kbd> command, this is what we come up with:</p>
<pre><strong>#!/bin/sh</strong><br/><br/><strong>docker run -it --rm wpscanteam/wpscan "$@"</strong></pre>
<p>Then, we can make our wrapper script executable with <kbd>chmod</kbd>, and <kbd>symlink</kbd> it to our <kbd>/usr/local/bin</kbd> so that we can access it in our <kbd>$PATH</kbd>:</p>
<pre><strong>chmod u+x /Full/path/to/wpscan.sh</strong><br/><strong>sudo ln -s /Full/path/to/wpscan.sh /usr/local/bin/wpscan</strong></pre>
<p>Done. Now, we can call the CLI script via our <kbd>wpscan</kbd> wrapper using the same syntax as if we had installed WPScan as a gem, but without having to keep track of which Ruby version we'd installed the gem to, or having to make sure that we had <kbd>ffi</kbd> or any other dependency libraries installed:</p>
<pre><strong>wpscan --help</strong></pre>
<p class="mce-root"/>
<p>Checking our options by passing our <kbd>wpscan</kbd> wrapper the <kbd>--help</kbd> flag, here's what we see:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c39b1612-a162-4323-9387-b54a69e323b7.png" style=""/></div>
<p>Now, in order to test out this functionality, let's bootstrap our vulnerable WordPress instance. If you followed the instructions in our <em>Technical requirements</em> section, you should already have a WP instance ready to set up on <kbd>localhost:80</kbd>. After selecting our language of choice, you should be taken to a form for basic information about your site (your site title, admin superuser username, notification email, and so on):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cac735c5-07dd-469c-959a-21dd05e08722.png"/></div>
<p class="mce-root">Filling that out, you'll be redirected to a success page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/071ddc82-40f9-4776-8b2b-26a77fb14754.png"/></div>
<p class="mce-root"/>
<p>Once you've logged in for the first time, navigate over to the plain <kbd>localhost:80</kbd> and view the actual home page of your WP site:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/21fa78f8-01a3-43f5-b280-7fcba4a74224.png"/></div>
<p>Keep in mind that you can't ping <kbd>localhost:80</kbd> from <kbd>wpscan</kbd> because it's executing from inside the Docker container. In order to feed our Dockerized WP instance to our Dockerized WPScanning service, we need to use the URL of the Docker container running WordPress.</p>
<p>We can find the Docker host IP by using <kbd>docker ps</kbd> to find the container ID of the Docker process running WP. We can then run <kbd>docker inspect &lt;CONTAINER_ID&gt;</kbd> to return some JSON with the IP address. For us, that IP address is <kbd>172.17.0.2</kbd>. Then, we run this command to scan our vulnerable WordPress site. If we were targeting a site on the public internet, we could simply skip this step:</p>
<pre><strong>wpscan --url 172.17.0.2:80</strong></pre>
<p>Running the preceding command, this is what the output of our scan looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/aaf079be-e99d-40f2-88cf-b725c362af17.png"/></div>
<p>You can immediately see several findings worth following up—<kbd>Interesting entry from robots.txt: http://172.17.0.2/super-secret-admin-page/</kbd> seems particularly interesting, considering that enticing URI. But if we continue down the list of vulnerabilities, we will be able to see several config files. Looking for authentication credentials, hidden directories, and other goodies, we navigate to one of the exposed config files, <kbd>wp-config.txt</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/549b7b47-07f7-4d46-96a4-2187d9d5edd7.png"/></div>
<p>And we find exactly what we're looking for! With site-level admin keys and all of our salt hashes, we have discovered the cryptographic keys to the kingdom.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Burp and WPScan</h1>
                </header>
            
            <article>
                
<p>One of the advantages of using the Burp extension method of applying WPScan is that it makes it easier to integrate the scanner within the larger Burp tool set. If you're relying heavily on manually flagging pages as in-scope, for example, you can have WPScan piggyback on that information to ensure that you're consistently staying on target throughout the engagement.<br/>
<br/>
Setting up WPScan to integrate with Burp is easy. The first thing you need to do is navigate to the <span class="packt_screen"><span class="packt_screen">BApp</span> Store</span> to download the extension:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/305a223b-7bba-4296-956c-650500cceb9c.png"/></div>
<p>You can also load extensions manually by selecting the extension file (it can be in either Java, Python, or Ruby) from within the manual install modal:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/89381698-4fc1-44f5-9c8e-107eb52d56e0.png" style=""/></div>
<p>You might find that you need to install the environment for the extension. Setting up each language is easy: in the case of Python, we follow the link to the Jython (a Python interpreter implemented in Java) home page and follow the installation instructions. Then, in our <span class="packt_screen">Options</span> section of the <span class="packt_screen">Extender</span> Tab, we can add the path to the Jython <kbd>jar</kbd> file:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8788dc79-53cd-47b6-b455-89ed70c66684.png" style=""/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Now, we can download the WPScanner extension from the <span class="packt_screen">BApp Store</span>. It should be as easy as clicking the install button:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ef6169c1-a690-4e2e-a509-27451293f27c.png" style=""/></div>
<p>Once it's finished installing, we should see a <span class="packt_screen">WordPress Scanner</span> tab. If we click on it, we will be able to see settings and output panels, ready for analysis:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/410b4cbf-b233-4ddd-9bca-c6596d2559db.png" style=""/></div>
<p class="mce-root"/>
<p>The WPScanner extension piggybacks on the passive analysis Burp does as you browse through a site using your proxy browser. After clicking through a couple of pages, viewing our sample post, and opening the comment submission field of our vulnerable WP instance, we can see that our issues list has already been populated with several vulnerabilities:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fef8ccc2-67dd-4fab-b416-31a44eee6568.png"/></div>
<p>Going through the issue list, we can see that we get a short category description and several links to blogs, GitHub pull requests, and security references with more information. We also get the path to the vulnerability, the severity, and a confidence level in the finding.</p>
<p>Perusing this list, we can see several varieties of XSS. Investigating further, let's try an <kbd>svg</kbd> tag-related vulnerability in the comment submission field, probing another part of the site's content sanitation functionality—we know that the WP instance is vulnerable, of course, but we are still working through the location and nature of the bugs. Here's our snippet:</p>
<pre>&lt;svg/onload=alert(document.location.origin)&gt;</pre>
<p>After we submit it, we see the page hang for a bit, and then eventually.</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2b0e7096-3767-4b54-9d3f-4a3e24d6590e.png"/></div>
<p>Our testing paid off. Although in this case we knew we'd find something if we dug deep enough, tools like WPScan can provide valuable, application-specific context and leads for further investigation, without adding a heavy new tool or difficult-to-integrate testing system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ruby on Rails – Rubysec Tools and Tricks</h1>
                </header>
            
            <article>
                
<p>There are several options for analyzing Ruby and Ruby-on-Rails applications, some of which are specific to Rails and others that can be applied more generally to similar applications (such as apps that are also RESTful, MVC, CRUD-oriented, primarily server-side, and so on).</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploiting RESTful MVC Routing Patterns</h1>
                </header>
            
            <article>
                
<p>Because Rails is so opinionated toward RESTful MVC patterns applied to CRUD apps, the URL routing structure is often easy to intuit. Understanding the <kbd>/resource/action</kbd> and <kbd>/resource/{identifier}/action</kbd> patterns allows an attacker to play around with potentially dangerous paths like <kbd>/users/{identifier}/update</kbd> that can be inferred from simple observation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking the Version for Particular Weaknesses</h1>
                </header>
            
            <article>
                
<p>As an application framework, Rails, like all popular software, has gotten waves of security updates over the years, addressing critical issues like handling SQL injection from within Active Record, or extending the CSRF protection scheme to include more basic request types. But because the barrier to building a Rails application is so low, and the language and framework are so productivity-friendly, Rails apps are often spun up quickly. And since Rails is a common small business/prototyping solution that is nevertheless often pressed into mature production service, there's a healthy amount of legacy Rails code out there. That combination of a quickly-assembled architecture with expectations of longevity, exacerbated by the plug-n-play nature of Rails scaffolding (entire CRUD apps can be created with just a few opinionated commands) means that Rails can be particularly susceptible to vulnerabilities caused by misconfigurations or unsafe defaults.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing Cookie Data and Authentication</h1>
                </header>
            
            <article>
                
<p>Rails makes it very easy to store potentially secure information as cookies, and is therefore more susceptible to leaking potential information through cookies that are encoded, but it's (critically) not encrypted.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Django – Strategies for the Python App</h1>
                </header>
            
            <article>
                
<p>Django, as a common framework for quickly building CRUD-style apps that's been successfully implemented in a dynamically-typed language designed for developer productivity, naturally suffers many of the same pitfalls as Rails and shares many of the same weaknesses. Django also holds a strong opinion about RESTful, MVC-centric URL routing, allowing for the same URL hacking discussed in the preceding section. That said, Django provides a lot of great, global protections for common vulnerabilities like CSRF, XSS, and injection attacks out-of-the-box.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking for DEBUG = True</h1>
                </header>
            
            <article>
                
<p>It's a forehead-slapping mistake, but still a common one—leaving the Django developer-level logging on in production. Shipping an app with the <kbd>DEBUG</kbd> setting enabled allows for a few problems to crop up, including comprehensive error tracebacks that can expose sensitive pages or data. If you suspect that <kbd>DEBUG</kbd> has been enabled on the target Django application, try generating an error to trigger the display of a harmful traceback. Leaving the <kbd>DEBUG</kbd> setting enabled is so common that, earlier this year, a single researcher conducted an investigation and within a week had discovered 28,165 Django apps with the setting enabled (<a href="https://www.bleepingcomputer.com/news/security/misconfigured-django-apps-are-exposing-secret-api-keys-database-passwords/">https://www.bleepingcomputer.com/news/security/misconfigured-django-apps-are-exposing-secret-api-keys-database-passwords/</a>). If it seems as if the damage you can to do with access to the debugging information is strictly limited, consider that, in 2018, a researcher was able to use the debug information from an unsecured Sentry server belonging to Facebook to get RCE. The payout was $5,000—a lower-than-usual-amount because the server was sandboxed and could not access user data (<a href="https://blog.scrt.ch/2018/08/24/remote-code-execution-on-a-facebook-server/">https://blog.scrt.ch/2018/08/24/remote-code-execution-on-a-facebook-server/</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Probing the Admin Page</h1>
                </header>
            
            <article>
                
<p>Django ships with a default admin page that is also often foregone in favor of a third-party plugin or other admin-related extension. If the default admin page has been neglected or the admin integration is incomplete, it can provide a fruitful attack surface to test and explore.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter covered the basics of the CVE vulnerability identification system, how to build workflows around discovering WordPress, Ruby on Rails, or Django-related vulnerabilities, and why known vulnerability detection, despite all the caveats, can still be worth integrating into your security practice. You should be moving forward with a better understanding of the role application-specific vulnerabilities play in the security ecosystem and be confident building application-specific testing processes, where appropriate, into Burp-based, script-based, or any number of other workflow strategies.</p>
<p>In the next chapter, we will cover the critical information that should be included in every report, optional information, the importance of including detailed steps to reproduce the bug, and how to write a good attack scenario.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What does CVE stand for? What is it?</li>
<li>What makes WordPress such an attractive target for hackers?</li>
<li>What are the advantages of using a CLI versus Burp extension for your WPScan functionality? How about vice versa?</li>
<li>What are some good methods for finding Ruby on Rails-specific bugs?</li>
<li>What are some advantages to using Docker for your pentesting tools?</li>
<li>What does OVAL stand for? What is an OVAL definition?</li>
<li>What are some issues that you should be on the lookout for when testing a Django application?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further Reading</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>You can find out more about some of the topics we have discussed in this chapter at:</strong></p>
<ul>
<li class="mce-root"><strong>WordPress Official Site</strong>: <a href="https://wordpress.org/">https://wordpress.org/ </a></li>
<li class="mce-root"><strong>CVE FAQ</strong>: <a href="https://cve.mitre.org/about/faqs.html">https://cve.mitre.org/about/faqs.html</a>.</li>
<li class="mce-root"><strong>OVAL Home page</strong>: <a href="https://oval.mitre.org/repository/about/overview.html">https://oval.mitre.org/repository/about/overview.html</a>.</li>
<li class="mce-root"><strong>WPScan Home page</strong>: <a href="https://wpscan.org/">https://wpscan.org/</a>.</li>
<li><strong>OWASP Ruby on Rails Cheatsheet</strong>: <a href="https://www.owasp.org/index.php/Ruby_on_Rails_Cheatsheet">https://www.owasp.org/index.php/Ruby_on_Rails_Cheatsheet</a>.<a href="https://wpscan.org/"/></li>
<li><strong>The Official Rails Security Guide</strong>: <a href="https://guides.rubyonrails.org/security.html">https://guides.rubyonrails.org/security.html</a>.</li>
</ul>


            </article>

            
        </section>
    </body></html>