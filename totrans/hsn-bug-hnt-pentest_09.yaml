- en: Framework and Application-Specific Vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identifying a framework or application-specific vulnerability, including Known
    Component Vulnerabilities (identified by their CVE designation, which we'll discuss
    later), is a tricky business.
  prefs: []
  type: TYPE_NORMAL
- en: It's a universal stipulation of bug bounty programs that companies don't reward
    the same vulnerability twice—the first researcher to disclose a vulnerability
    is the only one that's rewarded. This goes hand in hand with the fact that companies
    usually won't reward already publicly disclosed bugs within two weeks of the discovery
    of the original zero-day (like everyone, they need time to deploy a patch), and
    they aren't interested in vendor-level vulnerabilities in third-party libraries.
    This might seem like a waste of time, then, except if we take two important points
    into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: The cost of adoption is low. Since known component vulnerabilities are, well,
    known, it's much easier to build a tool to reliably find them, as opposed to less
    defined weaknesses in the architecture or logic of an application that require
    stepping through a UI manually. As with our example with Retire.js in [Chapter
    3](23759e04-8982-41fd-b936-580865a51439.xhtml), *Preparing for an Engagement*,  where
    we built a short set of scripts for detecting and reporting on client-side vulnerabilities
    in things like insecure jQuery libraries, it's a lightweight step that can be
    incorporated into any environment where we have access to the client-side source.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding security posture is important. The term security posture is shorthand
    for the general capability of an application or network to prevent, detect, and
    respond to attacks. If you open up your diagnostic tools and see right away that
    there are several critical reported vulnerabilities in either the framework, language
    version, or a vendor service, that can tell you a lot about the security practices
    at that company. If so many low-hanging fruit are within reach, is their bounty
    program still young? Do they have an established policy for security life cycle
    management? If there's a path to an attack scenario from the discovered vulnerabilities—great!—but
    even if that's not the case, the information is valuable, for what it telegraphs
    might be lurking just beneath the surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s all about the attack scenario. This is the most essential point: most
    guidelines for KCVs get thrown out the window in the face of a valid attack scenario.
    Companies aren''t interested in contributing a patch upstream just to improve
    the jQuery attack surface—that''s a lot of time spent validating, communicating
    about, and fixing a vulnerability ultimately on behalf of another organization.
    But if you can convince them that this affects their business, it can provoke
    a change (contributing a patch, updating the component, switching to a different
    solution for that service) that will trigger your reward.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will explain how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrate known component vulnerability scanning into your Burp-based workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use tools to find application-specific problems in software like WordPress,
    Django, and Ruby on Rails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a component-specific vulnerability from discovery, to validation, to submission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be working with Burp and some of its extensions to set
    up KCV detection automatically. We'll also be relying on our usual browser setup
    to act as the Burp proxy. We'll also be using WPScan as both a CLI and a Burp
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: The WPScan CLI comes with a variety of install options. Once again, we'll be
    using the container software Docker to download and run the `wpscan` CLI from
    within the context of a custom execution context packaged with everything it needs.
    Docker allows us to port this workflow anywhere we can install Docker, meaning
    that we don't need to worry about OS-specific behavior. And because Docker caches
    the WPScan CLI image, we can use it with only a marginal performance hit over
    a native installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that Docker is installed, to pull down the latest WPScan CLI image,
    simply run this quick command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you have all the dependencies necessary to access the CLI using the `docker
    run` command to bootstrap `wpscan`. Here''s an example one-liner straight from
    Docker Hub image''s documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For testing purposes, the same team behind WPScan also provides a deliberately
    vulnerable WordPress install, which is similarly run off of a Docker container.
    To build the image locally, clone the GitHub repository ([https://github.com/wpscanteam/VulnerableWordPress](https://github.com/wpscanteam/VulnerableWordPress))
    and navigate into its root directory. Then, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you should have a WordPress installation ready to be set up at `localhost:80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/36ee790f-3b09-4a6a-bd74-cf867ac1a47b.png)'
  prefs: []
  type: TYPE_IMG
- en: Known Component Vulnerabilities and CVEs – A Quick Refresher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Common Vulnerabilities and Exposures** (**CVE**) system describes itself
    as a dictionary that provides definitions for publicly disclosed vulnerabilities
    and disclosures. Its goal is to make it easier to share cybersecurity-related
    data across groups and technologies, understanding that the benefit of open coordination
    outweighs the risk of publicly advertising valid attacks. It's useful to keep
    in mind that CVE is a method for linking vulnerability databases and not a vulnerability
    database itself. That said, you'll often find CVE IDs to links to CVE information
    pages integrated into tools designed to detect known vulnerabilities. CVE entries
    are even built into the U.S National Vulnerability Database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of a CVE ID is direct: the identifier consists of the year plus
    a four digit (or more) integer. Until early 2015, CVE identifiers could only have
    a unique integer up to four digits long, but because that limits the total number
    of assignable IDs to 9,999 a year, it had to be expanded, and now can be of any
    length.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to its ID, each CVE also typically comes packaged with certain
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: An indication of whether the CVE has an entry or candidate status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief description of the vulnerability or exposure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any appropriate references (for example, vulnerability reports, advisories from
    the OVAL-ID)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OVAL-IDs are the unique identifiers that distinguish OVAL definitions. From
    the OVAL website:'
  prefs: []
  type: TYPE_NORMAL
- en: OVAL definitions are standardized, machine-readable tests written in the **Open
    Vulnerability and Assessment Language** (**OVAL**®) that check computer systems
    for the presence of software vulnerabilities, configuration issues, programs,
    and patches.
  prefs: []
  type: TYPE_NORMAL
- en: OVAL definition tests, like CVEs, are an attempt to coordinate an open, transparent
    system for standardizing pentesting vocabulary, and allow for more sharing between
    ethical hackers and their tools.
  prefs: []
  type: TYPE_NORMAL
- en: This quick introduction/refresher should come in handy the next time that you
    use any number of tools that leverage CVE as their primary security reference.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress – Using WPScan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to WordPress, their framework powers 31% of all sites. The open-source
    CMS-for-everything is a titan, providing the basic engine for hobbyist and commercial
    sites alike, from everything to your uncle's blog to the White House landing page.
    As such, it's an incredibly large target for pentesters and hackers everywhere.
    WordPress, with its myriad of plugins and configuration options, provides a large
    attack surface that, often managed by administrators with little technical experience,
    can be tricky to secure. Every shoddily-coded plugins, monkey-patched pieces of
    WP core, or ancient installations can be the foothold necessary for an attacker
    to deface or compromise a WP site.
  prefs: []
  type: TYPE_NORMAL
- en: WPScan functionality comes packaged in a few different tools. For our purposes,
    the most important are the containerized Docker command-line interface and the
    Burp extension.
  prefs: []
  type: TYPE_NORMAL
- en: WPScan as a Dockerized CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The advantage of using WPScan as a Dockerized CLI is that we can still take
    full advantage of the CLI—allowing us to embed the script in a larger automation
    setup—while not having to worry about dependency management issues like keeping
    our Ruby version up-to-date. We can even write a simple wrapper around the `docker
    run` command so that we don't need to enter so much boilerplate every time we
    use the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we create a shell script called `wpscan.sh` and call our Docker
    command, passing in the `"$@"` character so that all of our flags and command-line
    arguments get passed through the shell script to the `docker` command, this is
    what we come up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can make our wrapper script executable with `chmod`, and `symlink`
    it to our `/usr/local/bin` so that we can access it in our `$PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Done. Now, we can call the CLI script via our `wpscan` wrapper using the same
    syntax as if we had installed WPScan as a gem, but without having to keep track
    of which Ruby version we''d installed the gem to, or having to make sure that
    we had `ffi` or any other dependency libraries installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking our options by passing our `wpscan` wrapper the `--help` flag, here''s
    what we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c39b1612-a162-4323-9387-b54a69e323b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in order to test out this functionality, let''s bootstrap our vulnerable
    WordPress instance. If you followed the instructions in our *Technical requirements*
    section, you should already have a WP instance ready to set up on `localhost:80`.
    After selecting our language of choice, you should be taken to a form for basic
    information about your site (your site title, admin superuser username, notification
    email, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cac735c5-07dd-469c-959a-21dd05e08722.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Filling that out, you''ll be redirected to a success page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/071ddc82-40f9-4776-8b2b-26a77fb14754.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you''ve logged in for the first time, navigate over to the plain `localhost:80`
    and view the actual home page of your WP site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/21fa78f8-01a3-43f5-b280-7fcba4a74224.png)'
  prefs: []
  type: TYPE_IMG
- en: Keep in mind that you can't ping `localhost:80` from `wpscan` because it's executing
    from inside the Docker container. In order to feed our Dockerized WP instance
    to our Dockerized WPScanning service, we need to use the URL of the Docker container
    running WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find the Docker host IP by using `docker ps` to find the container ID
    of the Docker process running WP. We can then run `docker inspect <CONTAINER_ID>`
    to return some JSON with the IP address. For us, that IP address is `172.17.0.2`.
    Then, we run this command to scan our vulnerable WordPress site. If we were targeting
    a site on the public internet, we could simply skip this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding command, this is what the output of our scan looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aaf079be-e99d-40f2-88cf-b725c362af17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can immediately see several findings worth following up—`Interesting entry
    from robots.txt: http://172.17.0.2/super-secret-admin-page/` seems particularly
    interesting, considering that enticing URI. But if we continue down the list of
    vulnerabilities, we will be able to see several config files. Looking for authentication
    credentials, hidden directories, and other goodies, we navigate to one of the
    exposed config files, `wp-config.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/549b7b47-07f7-4d46-96a4-2187d9d5edd7.png)'
  prefs: []
  type: TYPE_IMG
- en: And we find exactly what we're looking for! With site-level admin keys and all
    of our salt hashes, we have discovered the cryptographic keys to the kingdom.
  prefs: []
  type: TYPE_NORMAL
- en: Burp and WPScan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of using the Burp extension method of applying WPScan
    is that it makes it easier to integrate the scanner within the larger Burp tool
    set. If you're relying heavily on manually flagging pages as in-scope, for example,
    you can have WPScan piggyback on that information to ensure that you're consistently
    staying on target throughout the engagement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting up WPScan to integrate with Burp is easy. The first thing you need
    to do is navigate to the BApp Store to download the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/305a223b-7bba-4296-956c-650500cceb9c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also load extensions manually by selecting the extension file (it can
    be in either Java, Python, or Ruby) from within the manual install modal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/89381698-4fc1-44f5-9c8e-107eb52d56e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You might find that you need to install the environment for the extension.
    Setting up each language is easy: in the case of Python, we follow the link to
    the Jython (a Python interpreter implemented in Java) home page and follow the
    installation instructions. Then, in our Options section of the Extender Tab, we
    can add the path to the Jython `jar` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8788dc79-53cd-47b6-b455-89ed70c66684.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can download the WPScanner extension from the BApp Store. It should
    be as easy as clicking the install button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ef6169c1-a690-4e2e-a509-27451293f27c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once it''s finished installing, we should see a WordPress Scanner tab. If we
    click on it, we will be able to see settings and output panels, ready for analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/410b4cbf-b233-4ddd-9bca-c6596d2559db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The WPScanner extension piggybacks on the passive analysis Burp does as you
    browse through a site using your proxy browser. After clicking through a couple
    of pages, viewing our sample post, and opening the comment submission field of
    our vulnerable WP instance, we can see that our issues list has already been populated
    with several vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fef8ccc2-67dd-4fab-b416-31a44eee6568.png)'
  prefs: []
  type: TYPE_IMG
- en: Going through the issue list, we can see that we get a short category description
    and several links to blogs, GitHub pull requests, and security references with
    more information. We also get the path to the vulnerability, the severity, and
    a confidence level in the finding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perusing this list, we can see several varieties of XSS. Investigating further,
    let''s try an `svg` tag-related vulnerability in the comment submission field,
    probing another part of the site''s content sanitation functionality—we know that
    the WP instance is vulnerable, of course, but we are still working through the
    location and nature of the bugs. Here''s our snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After we submit it, we see the page hang for a bit, and then eventually.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2b0e7096-3767-4b54-9d3f-4a3e24d6590e.png)'
  prefs: []
  type: TYPE_IMG
- en: Our testing paid off. Although in this case we knew we'd find something if we
    dug deep enough, tools like WPScan can provide valuable, application-specific
    context and leads for further investigation, without adding a heavy new tool or
    difficult-to-integrate testing system.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby on Rails – Rubysec Tools and Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several options for analyzing Ruby and Ruby-on-Rails applications,
    some of which are specific to Rails and others that can be applied more generally
    to similar applications (such as apps that are also RESTful, MVC, CRUD-oriented,
    primarily server-side, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting RESTful MVC Routing Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because Rails is so opinionated toward RESTful MVC patterns applied to CRUD
    apps, the URL routing structure is often easy to intuit. Understanding the `/resource/action`
    and `/resource/{identifier}/action` patterns allows an attacker to play around
    with potentially dangerous paths like `/users/{identifier}/update` that can be
    inferred from simple observation.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the Version for Particular Weaknesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an application framework, Rails, like all popular software, has gotten waves
    of security updates over the years, addressing critical issues like handling SQL
    injection from within Active Record, or extending the CSRF protection scheme to
    include more basic request types. But because the barrier to building a Rails
    application is so low, and the language and framework are so productivity-friendly,
    Rails apps are often spun up quickly. And since Rails is a common small business/prototyping
    solution that is nevertheless often pressed into mature production service, there's
    a healthy amount of legacy Rails code out there. That combination of a quickly-assembled
    architecture with expectations of longevity, exacerbated by the plug-n-play nature
    of Rails scaffolding (entire CRUD apps can be created with just a few opinionated
    commands) means that Rails can be particularly susceptible to vulnerabilities
    caused by misconfigurations or unsafe defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Cookie Data and Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rails makes it very easy to store potentially secure information as cookies,
    and is therefore more susceptible to leaking potential information through cookies
    that are encoded, but it's (critically) not encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Django – Strategies for the Python App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django, as a common framework for quickly building CRUD-style apps that's been
    successfully implemented in a dynamically-typed language designed for developer
    productivity, naturally suffers many of the same pitfalls as Rails and shares
    many of the same weaknesses. Django also holds a strong opinion about RESTful,
    MVC-centric URL routing, allowing for the same URL hacking discussed in the preceding
    section. That said, Django provides a lot of great, global protections for common
    vulnerabilities like CSRF, XSS, and injection attacks out-of-the-box.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for DEBUG = True
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's a forehead-slapping mistake, but still a common one—leaving the Django
    developer-level logging on in production. Shipping an app with the `DEBUG` setting
    enabled allows for a few problems to crop up, including comprehensive error tracebacks
    that can expose sensitive pages or data. If you suspect that `DEBUG` has been
    enabled on the target Django application, try generating an error to trigger the
    display of a harmful traceback. Leaving the `DEBUG` setting enabled is so common
    that, earlier this year, a single researcher conducted an investigation and within
    a week had discovered 28,165 Django apps with the setting enabled ([https://www.bleepingcomputer.com/news/security/misconfigured-django-apps-are-exposing-secret-api-keys-database-passwords/](https://www.bleepingcomputer.com/news/security/misconfigured-django-apps-are-exposing-secret-api-keys-database-passwords/)).
    If it seems as if the damage you can to do with access to the debugging information
    is strictly limited, consider that, in 2018, a researcher was able to use the
    debug information from an unsecured Sentry server belonging to Facebook to get
    RCE. The payout was $5,000—a lower-than-usual-amount because the server was sandboxed
    and could not access user data ([https://blog.scrt.ch/2018/08/24/remote-code-execution-on-a-facebook-server/](https://blog.scrt.ch/2018/08/24/remote-code-execution-on-a-facebook-server/)).
  prefs: []
  type: TYPE_NORMAL
- en: Probing the Admin Page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django ships with a default admin page that is also often foregone in favor
    of a third-party plugin or other admin-related extension. If the default admin
    page has been neglected or the admin integration is incomplete, it can provide
    a fruitful attack surface to test and explore.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the basics of the CVE vulnerability identification system,
    how to build workflows around discovering WordPress, Ruby on Rails, or Django-related
    vulnerabilities, and why known vulnerability detection, despite all the caveats,
    can still be worth integrating into your security practice. You should be moving
    forward with a better understanding of the role application-specific vulnerabilities
    play in the security ecosystem and be confident building application-specific
    testing processes, where appropriate, into Burp-based, script-based, or any number
    of other workflow strategies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the critical information that should be included
    in every report, optional information, the importance of including detailed steps
    to reproduce the bug, and how to write a good attack scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does CVE stand for? What is it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What makes WordPress such an attractive target for hackers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of using a CLI versus Burp extension for your WPScan
    functionality? How about vice versa?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some good methods for finding Ruby on Rails-specific bugs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some advantages to using Docker for your pentesting tools?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does OVAL stand for? What is an OVAL definition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some issues that you should be on the lookout for when testing a Django
    application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**You can find out more about some of the topics we have discussed in this
    chapter at:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WordPress Official Site**: [https://wordpress.org/](https://wordpress.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CVE FAQ**: [https://cve.mitre.org/about/faqs.html](https://cve.mitre.org/about/faqs.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OVAL Home page**: [https://oval.mitre.org/repository/about/overview.html](https://oval.mitre.org/repository/about/overview.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WPScan Home page**: [https://wpscan.org/](https://wpscan.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OWASP Ruby on Rails Cheatsheet**: [https://www.owasp.org/index.php/Ruby_on_Rails_Cheatsheet](https://www.owasp.org/index.php/Ruby_on_Rails_Cheatsheet).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Official Rails Security Guide**: [https://guides.rubyonrails.org/security.html](https://guides.rubyonrails.org/security.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
