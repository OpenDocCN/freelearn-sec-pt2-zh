- en: Attacks Outside the Local Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter mainly focuses on implementing attacks on the external network.
    For that, we need to know what port forwarding is, so in this chapter, we are
    going to get an idea of what we need to do to access the victim's machine through
    the router. Until now, we have been focusing on internal backdoors; now we are
    going to look at external backdoors. We will then look at the concept of IP forwarding,
    which plays another important part in attacking from outside the local network.
    We are also going to look at examples to gain a clear understanding of this concept,
    wherein we will hook our system to the external BeEF browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External backdoors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP forwarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External BeEF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port forwarding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned about a number of methods to gain full control over
    computers. We have seen how to do this using server-side attacks, client-side
    attacks, and social engineering as well. All of the attacks that we've done so
    far have been inside the network, and we've chosen to do that for convenience.
    That doesn't mean that these attacks only work inside the network; in fact, all
    of these attacks work outside the network as well. The only thing is that we need
    to configure our network in a way that allows incoming connections from the internet
    from outside our local network. We can use BeEF, we can use the backdoors, and
    we can also use server-side attacks—all the attacks that we have done so far,
    except for the special cases. The only thing that we want to keep in mind is that
    we want to configure the router to handle reverse connections properly, and direct
    them to the Kali machine. Now we will be focusing on that aspect and seeing how
    it would work and how to configure the router to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s learn how to set up a default network. We''ve seen a similar
    diagram to the following in [Chapter 5](bc4346fc-ed68-40d5-b1c7-7f3dd0f5af76.xhtml),
    *Pre-Connection Attacks*, and in the following diagram, we can see that we have
    the **ROUTER**, we have the **CLIENTS** that are connected to the **ROUTER**,
    and then we have the **ROUTER** that is connected to the **INTERNET**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c345d6ca-a6d4-4cbd-995d-0fd91b25e785.png)'
  prefs: []
  type: TYPE_IMG
- en: We mentioned before that none of the **CLIENTS** (all devices inside the network), don't
    have an internet connection; they can only access the **INTERNET** through the
    **ROUTER**. Whenever they want to request something, or they want to go to a website—for
    example, if they want to go to Google—the device would send a request to the **ROUTER**,
    then the **ROUTER** would go to the **INTERNET**, which is going to receive Google.com,
    and the response would be sent back to the **ROUTER**, then the **ROUTER** would
    forward that response to the device that requested it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, inside the network, each device has its own private IP. We can see in the
    preceding diagram that there are some IPs are written in red, and these only exist
    within the network; that''s why we call them private IPs, because outside the
    network these IPs are not visible. Once we are in, we can see that the router
    has two IPs: it has a private IP in red, which is accessible by all the devices
    in the network and is only used inside the network; and it also has a public IP,
    which is in green, and is accessible through the **INTERNET**. The IP that is
    highlighted in green is the IP that Google sees. If we actually go to Google,
    or to any other website, they see an IP address but they won''t see our private
    IP address; they''ll actually see the IP address of the **ROUTER** because the
    **ROUTER** is the device that''s actually making the requests, not the machine.
    All the requests made by these devices on the same network will all appear as
    if they''re coming from the same machine, or from the same IP. Again, this is
    because the only device that has access to the **INTERNET** is the **ROUTER**;
    none of the other devices do.'
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, or, if we think about it, in all the attacks that we do, the
    main thing we want is to get a reverse connection. Even when we're using the BeEF
    browser, we actually get a connection on port `3000`, which is the port that the
    BeEF is working on, and when we're using our backdoors, we actually receive a
    connection on the port that we specify when we make the backdoor. When we want
    to send that backdoor to somewhere outside our network, the first thing we have
    to keep in mind is that our local IP is not going to be visible. What we have
    to do is use the public IP, the IP of the router. To know the router's IP, we
    just have to go on Google, and then type in `whats my IP` in the search bar. Google
    will return the IP address of the router, and that IP will be the same from all
    the machines in the same network.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are connected through a wireless card. When we launch the command, we
    will see that we are not using a NAT connection, we are using an external wireless
    card that's connected to the home network. Therefore, all the devices in our wireless
    network at home will have the same IP. Again, that's because they all use the
    same router, so they're all connected to the same network. We will be using this
    IP in our backdoor, we're going to send the backdoor to a person that exists on
    the internet, that person is going to run that backdoor, and that backdoor is
    going to use a reverse connection. It's then going to try to connect back to the
    router on port `8080`, for example, if we chose that port in the backdoor. Once
    the router gets a request for port `8080`, it won't know what to do with it, because
    the router is not listening to port `8080`, and this request will not tell the
    router where it wants to go. All we need to do is configure the router to tell
    it that we want to forward the port `8080` to the Kali machine whenever we get
    a request from it. We are just using `8080` as an example, but we can do it for
    any port that we are listening on, whether it's `8080`, `444`, or `3000` for BeEF.
  prefs: []
  type: TYPE_NORMAL
- en: The main idea is that we want to use our real IP outside the network. Whenever
    we run any attack in previous chapters and even in future chapters, if we want
    to run that attack on the internet, on someone who doesn't exist on our home network,
    then we first of all make sure we use the public IP, and also make sure we configure
    the router to forward requests on the port that we're listening to on the Kali
    machine. We're going to see how to do that in the next section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: External backdoors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this part, we are going to study how to create a backdoor. The only difference
    is that we''re going to set the IP to the public IP instead of the local IP, and
    we''re going to create a backdoor exactly the same way that we used to create
    it when we were hacking devices in the same network. For this, we are going to
    use **Veil-Evasion**, and we are going to do the same steps used in [Chapter 12](a7a11e6d-7bc7-4c55-9b61-b698d2156e37.xhtml),
    *Client-Side Attacks*. We can use the `list` command to see what options we have
    we are going to use number `9`, it''s the exact same payload that we used in our
    previous example in [Chapter 12](a7a11e6d-7bc7-4c55-9b61-b698d2156e37.xhtml),
    *Client-Side Attacks*, the `reverse_http` payload. We''re going to use command `9`,
    and we can see the options by using the `options` command. As shown in the following
    screenshot, we can see that the `LPORT` is set to `8080` by default, and we will
    keep that the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c335df0d-3152-4158-8738-b392460a1b40.png)'
  prefs: []
  type: TYPE_IMG
- en: The only thing that we are going to change is the `LHOST`, and in the previous
    sections when we were receiving connections on our own computer we used to set
    it to the local IP `192.168.0.11`, because that's the IP that the devices use
    inside the network; but whenever we want to do things on the outside the network,
    we want to use the real IP, because these internal IPs are not visible to computers
    outside the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to use the IP that we see on Google, so when we type in `whats
    my IP` in Google search, we will get the IP as `89.100.145.189`; we''re going
    to use that as the `LHOST` in our backdoor, and we are going to launch the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to make sure everything is set up properly, use the `info` command. Once
    we launch the `info` command, we will see that the port is `8080` and we''re using
    the public IP `89.100.145.189`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9d7c10a0-bd8d-4e8f-a425-ea3918189146.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the most important step, and then we''re going to use the `generate`
    command to generate the backdoor like we did in previous chapters, and we''re
    just going to name the backdoor `backdoor.exe`. Hit *Enter*, and that will generate
    our payload for us. The path of the payload can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c9ef009f-1eed-40f6-9380-8d78d70e7983.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As usual, we are going to copy the backdoor in our Apache server `/var/www/html`
    directory using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also see how to download this backdoor from the internet from outside
    the network. Now all we have to do is listen for incoming connections using the
    multi-handler, we''ve done that before again in [Chapter 12](a7a11e6d-7bc7-4c55-9b61-b698d2156e37.xhtml),
    *Client-Side Attacks*. While we are going to listen to the multi-handler we are
    going to listen on our local IP, so we are not going to listen on the external/global
    IP, we are going to listen on the local because we can''t listen on the external,
    we are in the network and we only have control over current Kali machine. In the
    Kali machine we will be listening on port `8080`, and in the external device the
    backdoor will try to connect to the backdoor, the step after that will be we''ll
    set up IP forwarding to allow router to forward port `8080` to the Kali machine.
    But first we need to listen on port `8080` in the Kali machine, and we''re going
    to do that using the multi/handler using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Metasploit Framework using the `msfconsole` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to use `exploit/multi/handler`, using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the payload to `windows/meterpreter/reverse_http`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''re going to set the `LPORT` to `8080`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `LHOST`, the listening host, to our private IP. We are going to do set
    LHOST to `192.168.0.11`. The command is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to run `show options` to make sure everything is done properly.
    We can see in the following screenshot that the `LPORT` is set to `8080`, and
    the local host is set to `192.168.0.11`, and we''re using a payload of `windows/meterpreter/reverse_http`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/fbf59059-db3f-432a-aec4-41c69f6b1c07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Start `handler` by running the `exploit` command. As we can see in the following
    screenshot, `exploit` is ready on our private IP, and it''s listening for connections
    on port `8080`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/48fb4776-9ed0-49b4-a8b6-adaade8c925b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, we did the two main steps: we created a backdoor, and the backdoor
    will give us connections back based on the real IP address; and we''re listening
    on port `8080` in our local machine, the Kali machine. When the target person
    executes the backdoor on the internet, the backdoor will try to connect to IP
    `192.168.0.11` on port `8080`. The only problem now is the gateway, which is the
    router; it doesn''t have port `8080` open, when it receives the connection, it''s
    not going to know what to do with it. We need to configure the router to tell
    it that whenever we get a connection on port `8080`, we want it to be redirected
    to our Kali machine. We can do that in two ways, and we''re going to talk about
    them in the next forthcoming sections.'
  prefs: []
  type: TYPE_NORMAL
- en: IP forwarding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, in this part, we''ll learn how to configure the router so that it forwards
    incoming connections to the Kali machine. This will mean we can receive reverse
    connections, we can hook people to the BeEF browser, and launch attacks outside
    the network the same way that we used to launch them inside the network. To get
    to the router settings, usually the routers IP is the first IP in the subnet,
    our IP was `192.168.0.11`, usually, the router is the first one, so it will be
    `192.168.0.1`. Also, another way to get it is to type in `route -n` command, and
    that will show us where the gateway is. As we can see in the following screenshot,
    the gateway is at `192.168.0.1`. The following is the local IP address of the
    router:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6626e746-0230-4950-8ed0-69a6038c32cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''re going to browse the IP `192.168.0.1` in our browser. To do so, just
    type the address in the address bar and hit *Enter*, and as we can see in the
    following screenshot, we have our router settings, and we have to log in with
    the username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c91fb5fa-825b-4429-86b2-c40412a6b9a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the router settings might look different from router to router, but the
    names are usually the same. First of all, we will usually have to log in, and
    we either have a default username and password, or we will see them on a sticker
    behind or underneath the router itself. Once we are logged in we can see the control
    panel, and again it might look different for everyone, but we want to look for
    something called IP forwarding. For some, it''s under the ADVANCED option. Go
    to ADVANCED, and then to FORWARDING, and as we can see in the following screenshot
    we can set up our IP forwarding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d902ea3e-f6de-4ced-99c1-b94c3cc0b28e.png)Ip forwarding set up'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for something called IP forwarding; we have actually seen them on some
    routers called *virtual network* , but we want to look for something that allows
    us to set up rules to redirect ports inside the network. The port that we''re
    listening on is port `8080`, so that''s the port that we picked in the handler,
    that''s the port that we picked in the backdoor, and that''s the port that we
    want to get the connection on. Therefore, the public port is going to be `8080`,
    and again the target port is `8080`, and the target IP address is the IP address
    that''s listening on the port, so this is the IP address of the Kali machine where
    we have our handlers running. Therefore the IP address of our Kali machine right
    here is `192.168.0.11`, and we can even cross-check it from the result of the `ifconfig` command.
    We are going to enter the returned IP from `ifconfig` command in the Target IP
    Address textbox in our router settings—that''s the rule that we want to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/768a9cbb-8cd6-475b-89f7-65d8c714fa88.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up IPs and the ports
  prefs: []
  type: TYPE_NORMAL
- en: Click on Save, and the rule will be saved, whenever the router gets a request
    for port `8080`, it will know that it's going to forward that request to the Kali
    machine and the router will not cut the connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, we''ve set up a proper route now. The first thing we did is we created
    a backdoor, we used the real IP in the backdoor, we didn''t use the private IP,
    so we didn''t use the `192.168.0.11`, we used the real IP. We''re going to send
    that backdoor to a device in a different network. That device is going to run
    the backdoor, the backdoor will try to connect back on the real IP to the router,
    but the router will know exactly what to do with this, because we just set up
    a rule telling the router to forward any request that it gets on port `8080` to
    the Kali machine. We actually want to set up a rule for port `80`; this is the
    port that the Apache server runs on, and we want to enable that so that we can
    download the backdoor from the target computer. We are going to add a rule for
    port `80`, and again this is going to be the same machine, the Kali machine. We''re
    going enter port `80` and we''re going to save this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/967184e6-cf76-4d4c-8bca-0c529a152e2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring the Ip table
  prefs: []
  type: TYPE_NORMAL
- en: This will allow us to download the backdoor because we placed the backdoor in
    the `/var/www/html` directory, meaning we are actually going to be able to access
    our web server in Kali and download the backdoor from outside the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Now start our Apache web server and go to a Windows machine, and that Windows
    machine is going to be connected to a completely different network, and we're
    going to download the file from there. If we go and check our IP, we will see
    it has a different external public IP. So, we are just going to look for what
    our IP is on Google. The IP is `109.125.19.76`, which is completely different
    to the IP of the Kali machine that we used. These are two completely separate
    devices connected to different networks, and now we are going to access our Apache
    web server and download the backdoor, and normally without IP forwarding we wouldn't
    be able to do that. First, to access the backdoor, we are going to get the IP
    of the Kali machine. We called our backdoor `backdoor.exe`, therefore we are just
    going to open a browser on the Windows machine and, inside the URL bar, enter
    `192.168.0.11/backdoor.exe`. After hitting *Enter*, we will be able to download
    the backdoor, and this actually tells us that IP forwarding has been set up correctly,
    because without that, we wouldn't be able to access our web server and download
    the backdoor, so we are actually accessing the web server in Kali as if it's a
    normal website, like we can actually host fake web pages, we can host websites,
    anything we want right now on our Apache server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to run the backdoor on a Windows machine, and we''ll see if
    that''ll give us a reverse connection on our Kali machine, which is on a completely
    different network. As we can see in the following screenshot, we got a reverse
    Meterpreter shell, and that shell is coming from an external IP address into our
    internal IP address to the Kali machine, and right now we can control the target
    computer and do all the attacks that we did in the post-connection attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e486f3d6-a51c-4662-a172-96354c29d152.png)'
  prefs: []
  type: TYPE_IMG
- en: External BeEF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now lets look at another example on hooking people to the BeEF when they exist
    outside our network. So again, we're going to have the example against the same
    Windows machine that's in a completely different network, and we'll see how we
    can hook that machine to the BeEF. We're going to start the BeEF browser with
    just one click on the BeEF framework icon. We will go to log in with the username `beef`,
    and password is `beef` as well. Now, we're going to use the same basic `hook`
    method that we did before in [Chapter 13](ed4df884-d2d6-4c71-a1a4-28e4a508ed19.xhtml),
    *Client-Side Attacks - Social Engineering*, so in that method we need to get the
    script code, and we did this before - it has the same procedure, and we placed
    the script in our Apache web server, we placed it in an HTML page, which was in
    the Apache web home `/var/www/html` directory. We are going to open the `index.html`
    file and then open the text editor, and paste the code inside `index.html`, which
    we got from the BeEF Terminal. The only thing that we want to change all instances
    where we used to use our normal IP with our external IP so that people, when they
    try to connect, they'll actually be able to find our computer, because if we use
    the internal IP they won't be able to connect. We are going to use the IP that
    we saw on Google when we typed in `whats my IP`, and save the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have done that we need to enable port `3000`, which is the port that
    the BeEF works on. We need to tell the router, again in the IP forwarding settings,
    to forward any requests that we get on port `3000` to our Kali machine, which
    is at `192.168.0.11`. Now, go to the Windows machine and we''re going to go to
    our website, which is basically the external IP of our Kali machine. This will
    run `index.html` automatically, and we should be hooked to the BeEF as soon as
    we browse to the IP. As we can see in the following screenshot, we have got a
    Windows machine hooked and it''s using Firefox 5.0, and now we can run all the
    commands that the BeEF allows us to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/674927a4-3265-4b0d-8f06-f69cff64b04f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s just throw an alert and see if it works. As we can see in the following
    screenshot, it just says BeEF Alert Dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/348b1e9d-c279-43e4-a7b4-831a208fcdc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''re just going to execute it to make sure that everything is working properly.
    As we can see in the following screenshot that we are hooked to a machine that
    exists in a completely different network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/eb68f1f4-ea61-457d-b8a2-c245910c8be1.png)'
  prefs: []
  type: TYPE_IMG
- en: Again all we have to do is use the external IP address. Whenever we are sending
    it outside the network, use the IP that we see when we type in `what's our IP`
    on Google. When we are on our own machine, use the local IP and make sure we configure
    the router to redirect the port that we are listening on to the Kali machine,
    to the IP address, and to the private IP address of the Kali machine.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to using IP forwarding, we can set the Kali machine as a DMZ
    host. Now, not all routers support DMZ, that's why we didn't show it from the
    start; but if it supports it, we can use it. What DMZ does is it's basically IP
    forwarding, but it forwards all ports. So, if we put the IP address of the Kali
    machine in here, the router is going to get a request for any port, it'll forward
    that request to the Kali machine, regardless of what port it is. Therefore with
    port forwarding, we actually select which ports we want to forward to Kali; with
    DMZ, it will forward all the ports to the IP that we put in here. Now and again,
    both of these methods can be used to allow devices on different networks to access
    our computer, so we can receive connections, we can allow them to access a website
    if we are hosting a website on our web server, we can allow them to access fake
    websites, and we can allow them to access the BeEF, the hook, or anything where
    we are listening on a port we can use this method to allow people to access it
    if the people exist on a completely different network than our own network.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we majorly focused on how we can attack the external network
    and to implement this attack. We studied a few fundamentals such as port forwarding,
    which means redirecting the request from one port to the other. We even studied
    external backdoors and also how to exploit them, and we saw they are not different
    to internal backdoors. Then, moving ahead to another aspect of attacking the network,
    we learned about IP forwarding, wherein we saw how to determine the path through
    which the packet flows. We also implemented real-life examples to see how this
    works. In the next chapter, we are going to look at techniques to access the victim's
    system even after they are not running software on their system.
  prefs: []
  type: TYPE_NORMAL
