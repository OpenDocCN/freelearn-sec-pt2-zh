- en: Cross-Site Scripting Vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In both this and the following chapter, we're going to study a vulnerability
    called **cross-site scripting** (**XSS**) so that we know how to discover XSS
    vulnerabilities. But we will start off by learning about XSS attacks and XSS vulnerabilities.
    Then we will exploit the reflected vulnerability of XSS. Later, we will be looking
    at stored XSS, which is another vulnerability of XSS, and also try to launch an
    attack. Then we will look into exploiting XSS, and at the end of the chapter,
    we will learn how you can protect yourself against these vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflected XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stored XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XSS BeEF exploitation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XSS protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's learn more about XSS. This type of vulnerability allows an attacker
    to inject JavaScript into a page. JavaScript is a programming language, and using
    this vulnerability, an attacker would be able to execute code written in JavaScript
    into a certain page, such as a website. JavaScript is a client-side language,
    so when the code is executed, it will be executed on the client, on the user,
    the person who is browsing the web page. It's not going to be executed on the
    server, so even if our code results in us getting a reverse shell, the shell will
    be coming from the user who is browsing the page, not from the website. So any
    code we write in JavaScript will be exploited or will run on the target user—on
    the people who see the web pages—and not on the web server. So, the web server
    is only going to be used as a means of executing or delivering the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main types of XSS vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Persistent or stored**:Stored XSS gets stored in the database. The code that
    we inject will be stored in the database or the page so that every time any person
    views that page, our code will be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reflected**: With reflected XSS, the code will only be executed when the
    target user runs a specific URL that is crafted or written by us. So we will be
    manipulating some sort of URL and sending it to a target, and when the target
    runs that URL, the code will be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DOM-based**:DOM-based XSS results from JavaScript code that is written on
    the client, so the code will actually be interpreted and run on the client side
    without having any communication with the web server. This could be very dangerous
    because sometimes web servers apply security and filtration measures to check
    for XSS, but with DOM-based XSS, the code never gets sent to the web server. This
    means that the code would be interpreted and run on the web browser without even
    interacting with the web server, and will be present in websites that update their
    content without refreshing. We''ve all used websites where we enter our username,
    for example, and it loads straight away without having to check with the web server,
    or perhaps we enter some sort of a string and it performs a search without communicating
    with the web server; whatever the process, some websites perform functions without
    communicating with their web server. If we are able to inject into these kinds
    of website, then such injections will not be validated, and they will be executed
    straight away and bypass all validations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflected XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's learn how to discover these kinds of vulnerabilities. The method is very
    similar to SQL injection. First, you browse through your target and try to inject into
    any textbox or URL that looks similar. Whenever you see a URL with parameters,
    try to inject `something=something` as parameters, or try to inject into textboxes.
    Let's have a look at a reflected XSS example. These are the non-persistent, non-stored
    vulnerabilities where we have to actually send the code to the target, and once
    the target runs the code, it will be executed on their machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at our DVWA website and log into it. Inside the DVWA Security tab
    on the left-hand side of the following screenshot, we are going to set the Script
    Security to low:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/53b3d31a-fbe1-4083-87f3-bfbb5f18f950.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the following screenshot, we can enter your name in the textbox,
    and it''s just going to say Hello zaid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d666a75d-9dbc-43d2-9273-60798bf780d3.png)'
  prefs: []
  type: TYPE_IMG
- en: This is obviously just an example, but the idea is that you can inject into
    textboxes. Also, if we have a look at the URL `10.0.2.15/dvwa/vulnerabilities/xss-r/?name=zaid`,
    we can see that it is using the `GET` method, so we can inject into the URL as
    well. Let us start the D-pad and try to inject XSS code on it and see whether
    the JavaScript code will be executed. We are using a very simple script, the `<script></script>`
    tag. There are a lot of ways of discovering these kinds of vulnerabilities and
    a lot of ways to bypass filters, but for now, we're just having a look at a basic
    example where we can inject a normal script and write `<script>alert("XSS")</script>`—which
    is just a function that gives an alert—to give it a textbox. Then we are going
    to click on Submit and see whether this code will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the following screenshot, instead of saying Hello zaid, it
    says Hello; and our code has been executed, and it produces a XSS popup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d653c35e-ce6b-44e4-b036-be92c37746a5.png)'
  prefs: []
  type: TYPE_IMG
- en: If we have a look at the URL `10.0.2.15/dvwa/vulnerabilities/xss-r/?name=<script>alert("XSS")<%2fscripts>#`,
    we can see that it actually already did it for us. But if we copy and paste this
    URL on a notepad, we can see the script in the `name` parameter, and some CSS
    scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, all of the characters are just HTML escape characters, and if we
    send the URL to anybody, then the code will be executed on the machine of whoever
    views the URL, and it's going to display a popup saying XSS. Let's see how we
    can also inject through the URL. Just to show the whole idea, we will use the
    URL `10.0.2.15/dvwa/vulnerabilities/xss-r/?name=<script>alert("XSS")</scripts>#`.
    If we press *Enter*, the code will be executed. We can copy the URL and send it
    to a certain person, and once they run that code, the code will be executed on
    their machine.
  prefs: []
  type: TYPE_NORMAL
- en: Stored XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's have a look at a stored XSS example. Stored XSS is very similar to
    reflected XSS—it allows you to inject JavaScript code into the browser. The code
    is executed on the users that visit the page. The only difference is that, with
    reflected XSS, we have to send the URL to our target, so the target has to actually
    click on a URL for the exploit to run. With stored XSS, the code will be stored
    into the database—that is, into the page—so that every time a person runs that
    page, they will see our code and our code will be executed, so we won't need to
    interact with any users or send them anything. Therefore, this could be much more
    dangerous than reflected XSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s have a look at this. Click on the XSS stored tab on the left. We
    will see a page, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3a1400c6-efbd-4e0b-8198-8d791d4c0434.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The page only allows us to add a message to the system. Now we are going to
    enter `zaid` in the Name textbox. We''re just going to do a normal test to begin
    with. We''re going to enter `message body` in the Message textbox, and then we
    are going to click on the Sign Guestbook button. We can see in the following screenshot
    that zaid added a message called message body:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fbe20ebe-7788-4d83-893a-dd96de40bb2b.png)'
  prefs: []
  type: TYPE_IMG
- en: So, if we switch to a different DVWA machine in a different place and go to
    the XSS stored tab, we will be able see that there are two entries. The entries
    will be loaded from the database, and they contain the entries in that database.
    If we managed to inject code instead of a message, then the code will run on the
    machine of whoever runs this page without us even needing to send that person
    any code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to inject into the DVWA that is running in the Kali environment.
    Let''s enter the Name as `zaid`. We are going to try to enter our code in the
    Message textbox. We will enter it as `<script>`, and we are going to use the exact
    same test code that we used in the previous section, just a message saying `XSS`.
    Again, very basic code, but it serves for the purposes of this attack. We''re
    going to make the code say `alert("XSS")`, and then we are going to click on Sign
    Guestbook button. So the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see that we get XSS displayed in the pop-up alert, but the real magic
    happens when a normal person accesses the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a6ba38aa-68ff-43d4-ad21-035f003f6fc9.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's assume that DVWA is just a normal website and people are just coming to
    browse it. Once they go to the XSS stored tab on the website, the JavaScript code
    will be executed on their system from the website. The code will come from the
    website and will be executed on each user that visits the page. Again, we're just
    implementing a proof-of-concept here; in the next sections, we'll see how to further
    exploit this kind of vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: XSS BeEF exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We haven't yet seen a good way of exploiting XSS vulnerabilities; all we have
    done so far is inject a very simple code that displays an alert on the screen
    saying that this website is vulnerable. What we are going to do now is something
    more advanced. We want to control the victims and do stuff on the target computers,
    on the people that visit the vulnerable pages where we have injected our code.
    We're going to use the BeEF browser to do this. We had a look at BeEF in previous
    chapters. What we're going to do here is use the BeEF hook URL and inject it into
    the stored XSS page so that everybody who visits that page will be hooked to BeEF.
    Then, we'll be able to run all the commands that BeEF allows us to run on the
    target computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start BeEF. If we look at the online browsers, we have no victims at
    the moment. So, in order to hook victims to this framework and gain access to
    the functionality of BeEF, we need to inject a particular script instead of the
    alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `IP` in the preceding code with your current IP. Remember in the
    previous sections, we were injecting an `alert` script into the URL, or into the
    XSS stored page. In this example, we''re going to be injecting a script that hooks the
    target onto our BeEF browser so that we can exploit them. We are going to copy
    the preceding script and then we are going to go to our DVWA website. We are just
    going to make sure that the security is set to low in DVWA''s Security tab. Start
    the BeEF browser on Kali machine. Go to the DVWA website and under the XSS stored
    tab, we''re are going to enter the Name as `beef`, and we''ll enter the Message
    as the hook URL that we got from the BeEF Terminal. Again will need to modify
    the IP address in the hook URL to our own IP address. So, instead of just the
    IP address of the website, we are going to enter our own IP address, which is
    `10.0.2.15`. Now, the site wont let us add any more characters because the Message
    field is configured in a way that doesn''t allow more than a certain number of
    characters. Instead, we can bypass this very easily by right-clicking and selecting
    the Inspect Element option from the drop-down menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1755d2bf-5710-49e1-83db-4d3555723b5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we are going to modify `maxlength`, setting it to `500` instead of `50`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e125725d-5f0e-475b-9475-586d643deb47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can add more characters. We are going to close the Inspect Element dialog box
    and set the IP to `10.0.2.15`, which is our current IP. We are then going to click
    the Sign Guestbook button, and this should make it work. Now, if we go to our
    target, which is our Linux computer that has been hooked as a target, it can be
    seen to the left of the BeEF window in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f5544af3-7062-4322-8202-dab94ba33f9f.png)'
  prefs: []
  type: TYPE_IMG
- en: Obviously, this is not our target; it is just us who are looking at the site,
    and the hook has been executed on our browser. Our target is actually the Windows
    device, or any person who is going to be visiting this XSS stored page. Because
    this is a stored XSS, just like we explained, the code will be executed on the
    machine of any person who visits the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we go back to BeEF browser, we should see the Windows device, and we
    will be able to see that it''s shown up in the Online Browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d4a646fe-e889-4e15-a485-8895b0b057e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So we have basically hooked the Windows device, and we can now run the large
    number of functions that BeEF allows us to use. Next, we are going to click on
    our target and go to the Commands tab. Right now, we just want to run a specific
    command, which is just an `alert` command like we were using before, just to confirm
    that everything is working. We are going to use `Create Alert Dialog`, and we
    can set the Alert text as anything we want. We are going to leave it as `BeEF
    Alert Dialog`, and we will just click on Execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aacf0a05-3d0d-4b00-9d77-7069d8a8755f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we go on our target computer, we can see that the alert dialog is working,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9dcf4af4-852f-42eb-8f9c-6d152297f18d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, anybody who browses our target website—the vulnerable website—will get
    hooked to  BeEF, and we can then run all the commands that we've been looking
    at. So, all the commands that we see in the client-side attacks—such as gaining
    full access using a fake notification bar, getting a screenshot, injecting a keylogger—can
    be used on any person who visits the vulnerable page because we injected our hook
    into that page, not into the browser. Our hook is a part of the page, so every
    time the page is loaded by anyone, they will be hooked to the BeEF browser.
  prefs: []
  type: TYPE_NORMAL
- en: XSS protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s talk about how we can prevent XSS vulnerabilities. These vulnerabilities
    exist because whenever a user enters something into a textbox or a parameter,
    that input is displayed in the HTML, so it''s treated as if it''s part of the
    page. Therefore, if there is JavaScript in it, the code is executed. To prevent
    this exploit, the best thing to do is to try and minimize the usage of untrusted
    input. Given this exploit, we should try to minimize occasions where the user
    inputs something or where something is input from parameters. Also, make sure
    that we always escape whatever is going to be displayed or used in the HTML page,
    because XSS can not only be injected into places where things are displayed on
    the page, but it can also be injected into parameters of certain elements of the
    HTML page. Escaping means that we convert each of the characters shown in the
    following screenshot to what they would be represented by in HTML. We can do this
    using our own script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/784a3cc8-ef24-4130-aaa6-7cc10852440b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s see how it happens. Starting from the vulnerable web page that we
    are using, let''s go to the XXS stored page. Let''s inspect the element that is
    highlighted in the following screenshot, which is where we injected our alert,
    and if we right-click and go to Inspect Element in the drop-down menu, it will
    show us the HTML of the highlighted element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4bc67cd7-c726-490b-a543-5d08755fb6fa.png)'
  prefs: []
  type: TYPE_IMG
- en: If we scan through it, we will see that we have the Name, which is zaid, and
    then the other input, which is the Message. It's a script, and what the script
    does is displays an alert which says XSS, so it's exactly what we injected into
    it when we made the comment. So, every time we run this page, this piece of code
    gets executed. We need to make sure that every time a user enters something, and
    every time something is displayed on a page or is used somewhere in the elements
    of the page (even the `id` parameter, for example, is a parameter of the `<div>` tag,
    but it isn't displayed), then it can be injected as well. Hackers can try to inject
    hooks into the parameters—they can try to inject hooks into the image attributes,
    for example, make an image and inject a hook into the source or the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try an example where every time a user's input is used anywhere on the
    page—even if we don't see it—we make sure that we escape that input and ensure
    that it does not contain any code, and if the input does contain any code, that
    it's converted to an equivalent that will not be run. It's converted to its HTTP
    equivalent so that we see `alert` in the message. We see the message as a script
    `alert` of an XSS vulnerability, but it will never be executed on the target person
    when they run it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as a user, to prevent ourselves from being victim of an XSS attack, the
    URL coming to us will probably look like the URL of a trusted website; for example,
    let's say that we work in a company that had an XSS vulnerability. We log into
    our company and the code gets executed on our machine. Once this happens, there
    isn't much we can do, so we need to be careful beforehand. With BeEF, we saw that
    in order to exploit the vulnerabilities, we showed, for example, a fake update
    to the target computer. So if we get a message stating that there is an update,
    we should go to the actual website of the software that (apparently) needs updating
    to check. So, if the Firefox browser states that there is an update for its software,
    go to the Firefox website and see whether there is actually an update, and if
    there is, download it from that website—don't download it from the notification
    that's received. Also, make sure to download it from an HTTPS website. Once we
    download it, we can inspect and check it the same way that we've seen before in
    order to make sure that there are no backdoors or anything in it. We can also
    check the `md5sum` to make sure that the file hasn't been manipulated while it
    was being downloaded, the same as we did with the fake Facebook login when we
    were using BeEF. So, whenever we are told that we have been logged out and are
    asked to log back in again, ignore the request and go to Facebook, make sure it's
    using HTTPS, and then log in to Facebook. Always try to be careful when notifications
    pop up telling you that you need to do things—always be aware, and never trust
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about XSS attacks, which can be described as vulnerabilities
    that are found on web applications. We also learned that there are three major
    types of XSS vulnerabilities—the reflected and stored. We looked at the reflected
    vulnerability and used the DVWA website to launch this attack. We also learned
    about the stored XSS vulnerability, and even practically implemented it. Then,
    in the exploitation section, we performed an advanced attack where we controlled
    the victim's machine. Finally, we learned how to protect ourselves from these
    vulnerabilities. In the next chapter, we are going to be learning about a tool
    called ZAP.
  prefs: []
  type: TYPE_NORMAL
