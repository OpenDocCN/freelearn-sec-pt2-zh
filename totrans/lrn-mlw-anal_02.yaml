- en: Static Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static analysis is the technique of analyzing the suspect file without executing
    it. It is an initial analysis method that involves extracting useful information
    from the suspect binary to make an informed decision on how to classify or analyze
    it and where to focus your subsequent analysis efforts. This chapter covers various
    tools and techniques to extract valuable information from the suspect binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the malware's target architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fingerprinting the malware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning the suspect binary with anti-virus engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting strings, functions, and metadata associated with the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying the obfuscation techniques used to thwart analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classifying and comparing the malware samples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These techniques can reveal different information about the file. It is not
    required to follow all these techniques, and they need not be followed in the
    order presented. The choice of techniques to use depends on your goal and the
    context surrounding the suspect file.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Determining the File Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During your analysis, determining the file type of a suspect binary will help
    you identify the malware's target operating system (Windows, Linux, and so on)
    and architecture (32-bit or 64-bit platforms). For example, if the suspect binary
    has a file type of *Portable Executable* (*PE*), which is the file format for
    Windows executable files (`.exe`, `.dll`, `.sys`, `.drv`, `.com`, `.ocx`, and
    so on), then you can deduce that the file is designed to target the Windows operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Most Windows-based malware are executable files ending with extensions such
    as `.exe`, `.dll`, `.sys`, and so on. But relying on file extensions alone is
    not recommended. File extension is not the sole indicator of file type. Attackers
    use different tricks to hide their file by modifying the file extension and changing
    its appearance to trick users into executing it. Instead of relying on file extension,
    *File signature* can be used to determine the file type.
  prefs: []
  type: TYPE_NORMAL
- en: A *file signature* is a unique sequence of bytes that is written to the file's
    header. Different files have different signatures, which can be used to identify
    the type of file. The Windows executable files, also called *PE files* (such as
    the files ending with `.exe`, `.dll`, `.com`, `.drv`, `.sys`, and so on), have
    a file signature of `MZ` or hexadecimal characters `4D 5A` in the first two bytes
    of the file.
  prefs: []
  type: TYPE_NORMAL
- en: A handy resource for determining the file signatures of different file types
    based on their extension is available at [http://www.filesignatures.net/](http://www.filesignatures.net/).
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 Identifying File Type Using Manual Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The manual method of determining the file type is to look for the *file signature*
    by opening it in a hex editor. A *hex editor* is a tool that allows an examiner
    to inspect each byte of the file; most hex editors provide many functionalities
    that help in the analysis of a file. The following screenshot shows the file signature
    of `MZ` in the first two bytes when an executable file is opened with the *HxD
    hex editor* ([https://mh-nexus.de/en/hxd/](https://mh-nexus.de/en/hxd/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00013.jpeg)You have many options when it comes to choosing hex
    editors for Windows; these hex editors offer different features. For a list and
    comparison of various hex editors, refer to this link: [https://en.wikipedia.org/wiki/Comparison_of_hex_editors](https://en.wikipedia.org/wiki/Comparison_of_hex_editors).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux systems, to look for the file signature, the `xxd` command can be
    used, which generates a hex dump of the file as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 1.2 Identifying File Type Using Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other convenient method of determining the file type is to use file identification
    tools. On Linux systems, this can be achieved using the *file* utility. In the
    following example, the file command was run on two different files. From the output,
    it can be seen that even though the first file does not have any extension, it
    is detected as a 32-bit executable file (`PE32`) and the second file is a 64-bit
    (`PE32+`) executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On Windows, *CFF Explorer*, part of *Explorer Suite* ([http://www.ntcore.com/exsuite.php](http://www.ntcore.com/exsuite.php)),
    can be used to determine the file type; it is not just limited to determining
    file type. It is also a great tool for inspecting executable files (both 32-bit
    and 64-bit) and allows you to examine the PE internal structure, modify fields,
    and extract resources.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 Determining File Type Using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, the `python-magic` module can be used to determine the file type.
    The installation of this module on Ubuntu Linux VM was covered in [Chapter 1](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485), *Introduction
    to Malware Analysis.* On Windows, to install the `python-magic` module, you can
    follow the procedure mentioned at [https://github.com/ahupp/python-magic](https://github.com/ahupp/python-magic).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `python-magic` is installed, the following commands can be used in
    the script to determine the file type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate the use of detecting file type, let''s take an example of a
    file that was made to look like a *Word document* by changing the extension from
    `.exe` to `.doc.exe`. In this case, attackers took advantage of the fact that,
    by default, *"Hide extension for known file types*" is enabled in the *"Windows
    folder view options"*; this option prevents the file extension from being displayed
    to the user. The following screenshot shows the appearance of the file with *"Hide
    extension for known file types*" enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Opening the file in the *CFF Explorer* reveals that it is a 32-bit executable
    file and not a word document, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 2\. Fingerprinting the Malware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fingerprinting involves generating the cryptographic hash values for the suspect
    binary based on its file content. The cryptographic hashing algorithms such as *MD5*,
    *SHA1* or *SHA256* are considered the de facto standard for generating file hashes
    for the malware specimens. The following list outlines the use of cryptographic
    hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying a malware specimen based on filename is ineffective because the
    same malware sample can use different filenames, but the cryptographic hash that
    is calculated based on the file content will remain the same. Hence, a cryptographic
    hash for your suspect file serves as a unique identifier throughout the course
    of analysis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During dynamic analysis, when malware is executed, it can copy itself to a different
    location or drop another piece of malware. Having the cryptographic hash of the
    sample can help in identifying whether the newly dropped/copied sample is the
    same as the original sample or a different one. This information can assist you
    in deciding whether the analysis needs to be performed on a single sample or multiple
    samples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File hash is frequently used as an indicator to share with other security researchers
    to help them identify the sample.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File hash can be used to determine whether the sample has been previously detected
    by searching online or searching the database of multi Anti-virus scanning service
    like *VirusTotal*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1 Generating Cryptographic Hash Using Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On a Linux system, file hashes can be generated using the `md5sum`, `sha256sum`,
    and `sha1sum` utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows, various tools for generating file hashes can be found online. *HashMyFiles*
    ([http://www.nirsoft.net/utils/hash_my_files.html](http://www.nirsoft.net/utils/hash_my_files.html)) is
    one such tool that generates hash values for single or multiple files, and it
    also highlights identical hashes with same colors. In the following screenshot,
    it can be seen that `log.exe` and `bunny.exe` are the same samples based on their
    hash values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00016.jpeg)You can get a list and comparison of various hashing
    tools here: [https://en.wikipedia.org/wiki/Comparison_of_file_verification_software](https://en.wikipedia.org/wiki/Comparison_of_file_verification_software#Program_hash_function_support).
    Feel free to choose the ones that best suit your needs after a careful review.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Determining Cryptographic Hash in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python, it is possible to generate file hashes using the `hashlib` module,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 3\. Multiple Anti-Virus Scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scanning the suspect binary with multiple anti-virus scanners helps in determining
    whether malicious code signatures exist for the suspect file. The signature name
    for a particular file can provide additional information about the file and its
    capabilities. By visiting the respective antivirus vendor websites or searching
    for the signature in search engines, you can yield further details about the suspect
    file. Such information can help in your subsequent investigation and can reduce
    the analysis time.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Scanning the Suspect Binary with VirusTotal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*VirusTotal* ([http://www.virustotal.com](http://www.virustotal.com)) is a
    popular web-based malware scanning service. It allows you to upload a file, which
    is then scanned with various anti-virus scanners, and the scan results are presented
    in real time on the web page. In addition to uploading files for scanning, the
    VirusTotal web interface provides you the ability to search their database using
    *hash*, *URL*, *domain, or IP address*. VirusTotal offers another useful feature
    called *VirusTotal Graph*, built on top of the VirusTotal dataset. Using VirusTotal
    Graph, you can visualize the relationship between the file that you submit and
    its associated indicators such as *domains*, *IP addresses*, and *URLs*. It also
    allows you to pivot and navigate over each indicator; this feature is extremely
    useful if you want to quickly determine the indicators associated with a malicious
    binary. For more information on *VirusTotal Graph*, refer to the documentation:
    [https://support.virustotal.com/hc/en-us/articles/115005002585-VirusTotal-Graph](https://support.virustotal.com/hc/en-us/articles/115005002585-VirusTotal-Graph).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the detection names for a malware binary, and
    it can be seen that the binary was scanned with 67 Anti-virus engines; 60 of them
    detected this binary as malicious. If you wish to use the *VirusTotal Graph* on
    the binary to visualize indicator relationships, just click on the VirusTotal
    Graph icon and sign in with your VirusTotal (community) account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00017.jpeg)VirusTotal offers different private (paid) services
    ([https://support.virustotal.com/hc/en-us/articles/115003886005-Private-Services](https://support.virustotal.com/hc/en-us/articles/115003886005-Private-Services)),
    which allow you to perform threat hunting and download samples submitted to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Querying Hash Values Using VirusTotal Public API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: VirusTotal also provides scripting capabilities via its public API ([https://www.virustotal.com/en/documentation/public-api/](https://www.virustotal.com/en/documentation/public-api/));
    it allows you to automate file submission, retrieve file/URL scan reports, and
    retrieve domain/IP reports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a Python script that demonstrates the use of VirusTotal''s
    public API. This script takes the hash value (*MD5/SHA1/SHA256*) as input and
    queries the VirusTotal database. To use the following script, you need to use
    a *Python 2.7.x* version; you must be connected to the internet and must have
    a VirusTotal public API key (which can be obtained by signing up for a *VirusTotal*
    account). Once you have the API key, just update the `api_key` variable with your
    API key:'
  prefs: []
  type: TYPE_NORMAL
- en: The following script and most of the scripts written in this book are used to
    demonstrate the concept; they do not perform input validation or error handling.
    If you wish to use them for production, you should consider modifying the script
    to follow the best practices mentioned here: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding script by giving it an MD5 hash of a binary shows the
    antivirus detections and the signature names for the binary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The other alternative is to use PE analysis tools such as *pestudio* ([https://www.winitor.com/](https://www.winitor.com/))
    or *PPEE* ([https://www.mzrst.com/](https://www.mzrst.com/)). Upon loading the
    binary, the hash value of the binary is automatically queried from the VirusTotal
    database and the results are displayed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00018.jpeg)Online scanners such as *VirSCAN* ([http://www.virscan.org/](http://www.virscan.org/)),
    *Jotti Malware Scan* ([https://virusscan.jotti.org/](https://virusscan.jotti.org/)),
    and *OPSWAT''s Metadefender* ([https://www.metadefender.com/#!/scan-file](https://www.metadefender.com/#!/scan-file))
    allow you to scan a suspect file with multiple anti-virus scanning engines, and
    some of them also allow you to do hash lookups.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few factors/risks to consider when scanning a binary with Anti-Virus
    scanners or when submitting a binary to online anti-virus scanning services:'
  prefs: []
  type: TYPE_NORMAL
- en: If a suspect binary does not get detected by the Anti-Virus scanning engines,
    it does not necessarily mean that the suspect binary is safe. These anti-virus
    engines rely on signatures and heuristics to detect malicious files. The malware
    authors can easily modify their code and use obfuscation techniques to bypass
    these detections, because of which some of the anti-virus engines might fail to
    detect the binary as malicious.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you upload a binary to a public site, the binary you submit may be shared
    with third parties and vendors. The suspect binary may contain sensitive, personal,
    or proprietary information specific to your organization, so it is not advisable
    to submit a binary that is part of a confidential investigation to public anti-virus
    scanning services. Most web-based anti-virus scanning services allow you to search
    their existing database of scanned files using cryptographic hash values (MD5,
    SHA1, or SHA256); so an alternative to submitting the binary is to search based
    on the cryptographic hash of the binary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you submit a binary to the online antivirus scanning engines, the scan
    results are stored in their database, and most of the scan data is publicly available
    and can be queried later. Attackers can use the search feature to query the hash
    of their sample to check whether their binary has been detected. Detection of
    their sample may cause the attackers to change their tactics to avoid detection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4\. Extracting Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings are ASCII and Unicode-printable sequences of characters embedded within
    a file. Extracting strings can give clues about the program functionality and
    indicators associated with a suspect binary. For example, if a malware creates
    a file, the *filename* is stored as a string in the binary. Or, if a malware resolves
    a *domain name* controlled by the attacker, then the domain name is stored as
    a string. Strings extracted from the binary can contain references to filenames,
    URLs, domain names, IP addresses, attack commands, registry keys, and so on. Although
    strings do not give a clear picture of the purpose and capability of a file, they
    can give a hint about what malware is capable of doing.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 String Extraction Using Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To extract strings from a suspect binary, you can use the strings utility on
    Linux systems. The s*trings* command, by default, extracts the ASCII strings that
    are at least four characters long. With the `-a` option it is possible to extract
    strings from the entire file. The following ASCII strings extracted from the malicious
    binary show reference to an *IP address.* This indicates that when this malware
    is executed, it probably establishes a connection with that IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, the *ASCII* strings extracted from a malware called
    *Spybot* give an indication of its *DOS* and *Key logging* capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Malware specimens also use *Unicode* (2 bytes per character) strings. To get
    useful information from the binary, sometimes you need to extract both *ASCII*
    and *Unicode* strings. To extract Unicode strings using the *strings* command,
    use the `-el `option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the malware sample did not reveal unusual *ASCII*
    strings, but extracting the *Unicode* strings showed references to the *domain
    name*, and the *Run registry key* (which is frequently used by malware to survive
    the reboot); and it also highlights a malware''s possible capability to add a
    program to the firewall whitelist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: On Windows, *pestudio* ([https://www.winitor.com](https://www.winitor.com))
    is a handy tool that displays both ASCII and Unicode strings. pestudio is an excellent
    PE analysis tool for performing initial malware assessment of a suspect binary,
    and is designed to retrieve various pieces of useful information from a PE executable.
    Various other features of this tool will be covered in subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows some of the *ASCII* and *Unicode* strings listed
    by pestudio; it assists you by highlighting some of the notable strings in the
    blacklisted column, which allows you to focus on the interesting strings in the
    binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00019.jpeg)The *strings* utility ported to Windows by Mark Russinovich
    ([https://technet.microsoft.com/en-us/sysinternals/strings.aspx](https://technet.microsoft.com/en-us/sysinternals/strings.aspx))
    and *PPEE* ([https://www.mzrst.com/](https://www.mzrst.com/)) are some of the
    other tools that can be used to extract both ASCII and Unicode strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Decoding Obfuscated Strings Using FLOSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the times, malware authors use simple string obfuscation techniques
    to avoid detection. In such cases, those obfuscated strings will not show up in
    the strings utility and other string extraction tools. *FireEye Labs Obfuscated
    String Solver* (*FLOSS*) is a tool designed to identify and extract obfuscated
    strings from malware automatically. It can help you determine the strings that
    malware authors want to hide from string extraction tools. *FLOSS* can also be
    used just like the strings utility to extract human-readable strings (ASCII and
    Unicode). You can download *FLOSS* for Windows or Linux from [https://github.com/fireeye/flare-floss](https://github.com/fireeye/flare-floss).
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, running a *FLOSS* standalone *binary* on a malware
    specimen not only extracted the human-readable strings but also decoded the obfuscated
    strings and extracted *stack strings* missed by the strings utility and other
    string extraction tools. The following output shows reference to an *executable*,
    *Excel file*, and *Run registry key:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you are only interested in the *decoded/stack strings* and want to exclude
    the static strings (ASCII and Unicode) from the FLOSS output, then provide it
    the `–-no-static-strings` switch. Detailed information about the workings of FLOSS
    and its various usage options is available at [https://www.fireeye.com/blog/threat-research/2016/06/automatically-extracting-obfuscated-strings.html](https://www.fireeye.com/blog/threat-research/2016/06/automatically-extracting-obfuscated-strings.html).
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Determining File Obfuscation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though string extraction is an excellent technique to harvest valuable
    information, often malware authors obfuscate or armor their malware binary. Obfuscation
    is used by malware authors to protect the inner workings of the malware from security
    researchers, malware analysts, and reverse engineers. These obfuscation techniques
    make it difficult to detect/analyze the binary; extracting the strings from such
    binary results in very fewer strings, and most of the strings are obscure. Malware
    authors often use programs such as *Packers* and *Cryptors* to obfuscate their
    file to evade detection from security products such as anti-virus and to thwart
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Packers and Cryptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *Packer* is a program that takes the executable as input, and it uses compression
    to obfuscate the executable's content. This obfuscated content is then stored
    within the structure of a new executable file; the result is a new executable
    file (packed program) with obfuscated content on the disk. Upon execution of the
    packed program, it executes a decompression routine, which extracts the original
    binary in memory during runtime and triggers the execution.
  prefs: []
  type: TYPE_NORMAL
- en: A *Cryptor* is similar to a *Packer,* but instead of using compression, it uses
    encryption to obfuscate the executable's content, and the encrypted content is
    stored in the new executable file. Upon execution of the encrypted program, it
    runs a decryption routine to extract the original binary in the memory and then
    triggers the execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the concept of file obfuscation, let''s take an example of a
    malware sample called *Spybot* (not packed); extracting strings from *Spybot*
    show, references to suspicious executable names and IP addresses, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The Spybot sample was then run through a popular packer *UPX* ([https://upx.github.io/](https://upx.github.io/)),
    which resulted in a new packed executable file (`spybot_packed.exe`). The following
    command output shows the size discrepancy between the original and the packed
    binary.UPX uses compression, because of which the size of the packed binary is
    lower than the original binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the strings command on the packed binary shows obscured strings and
    does not reveal much valuable information; this is one of the reasons why attackers
    obfuscate their files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: UPX is a common packer, and many times you will come across malware samples
    packed with UPX. In most cases, it is possible to unpack the sample using the `-d`option*. *An
    example command is `upx -d -o spybot_unpacked.exe spybot_packed.exe` .
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Detecting File Obfuscation Using Exeinfo PE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most legitimate executables do not obfuscate content, but some executables may
    do it to prevent others from examining their code. When you come across a sample
    that is packed, there is a high chance of it being malicious. To detect packers
    on Windows, you can use a freeware tool such as *Exeinfo PE* ([http://exeinfo.atwebpages.com/](http://exeinfo.atwebpages.com/));
    it has an easy-to-use GUI. At the time of writing this book, it uses more than
    4,500 signatures (stored in `userdb.txt` in the same directory) to detect various
    compilers, packers, or cryptors utilized to build the program. In addition to
    detecting Packers, another interesting feature of *Exeinfo PE* is that it gives
    information/references on how to unpack the sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading the packed *Spybot* malware sample into *Exeinfo PE* shows that it
    is packed with UPX, and it also gives a hint on which command to use to decompress
    the obfuscated file; this can make your analysis much easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00020.jpeg)Other CLI and GUI tools that can help you with packer
    detections include *TrID *([http://mark0.net/soft-trid-e.html](http://mark0.net/soft-trid-e.html)),
    *TRIDNet* ([http://mark0.net/soft-tridnet-e.html](http://mark0.net/soft-tridnet-e.html)),
    *Detect It Easy *([http://ntinfo.biz/](http://ntinfo.biz/)), *RDG Packer Detector*
    ([http://www.rdgsoft.net/](http://www.rdgsoft.net/)), *packerid.py* ([https://github.com/sooshie/packerid](https://github.com/sooshie/packerid)),
    and *PEiD* ([http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml](http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml)).'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Inspecting PE Header Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows executables must conform to the *PE/COFF (Portable Executable/Common
    Object File Format)*. The PE file format is used by the Windows executable files
    (such as `.exe`, `.dll`, `.sys`, `.ocx`, and `.drv`) and such files are generally
    called *Portable Executable (PE)* files. The PE file is a series of structures
    and sub-components that contain the information required by the operating system
    to load it into memory.
  prefs: []
  type: TYPE_NORMAL
- en: When an executable is compiled, it includes a header (PE header), which describes
    its structure. When the binary is executed, the operating system loader reads
    the information from the PE header and then loads the binary content from the
    file into the memory. The PE header contains information such as where the executable
    needs to be loaded into memory, the address where the execution starts, the list
    of libraries/functions on which the application relies on, and the resources used
    by the binary. Examining the PE header yields a wealth of information about the
    binary, and its functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book does not cover the basics of PE file structure. However, the concepts
    that are relevant to malware analysis will be covered in the following sub-sections;
    various resources can help in understanding the PE file structure. The following
    are some of the great resources for understanding the PE file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '*An In-Depth Look into the Win32 Portable Executable File Format - Part 1:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part1](http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part1)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*An In-Depth Look into the Win32 Portable Executable File Format - Part 2:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part2](http://www.delphibasics.info/home/delphibasicsarticles/anin-depthlookintothewin32portableexecutablefileformat-part2)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*PE Headers and structures:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf](http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*PE101 - A Windows Executable Walkthrough:*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/corkami/pics/blob/master/binary/pe101/pe101.pdf](https://github.com/corkami/pics/blob/master/binary/pe101/pe101.pdf)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can get a clear understanding of the PE file format by loading a suspect
    file into PE analysis tools. The following are the some of the tools that allow
    you to examine and modify the PE structure and its sub-components:'
  prefs: []
  type: TYPE_NORMAL
- en: '*CFF Explorer:* [http://www.ntcore.com/exsuite.php](http://www.ntcore.com/exsuite.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PE Internals:* [http://www.andreybazhan.com/pe-internals.html](http://www.andreybazhan.com/pe-internals.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PPEE(puppy):* [https://www.mzrst.com/](https://www.mzrst.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PEBrowse Professional:* [http://www.smidgeonsoft.prohosting.com/pebrowse-pro-file-viewer.html](http://www.smidgeonsoft.prohosting.com/pebrowse-pro-file-viewer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subsequent sections will cover some of the important PE file attributes
    that are useful for malware analysis. A tool such as *pestudio* ([https://www.winitor.com](https://www.winitor.com))
    or *PPEE (puppy***: **[https://www.mzrst.com/](https://www.mzrst.com/)) can assist
    you with exploring interesting artifacts from the PE file.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Inspecting File Dependencies and Imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, malware interacts with the file, registry, network, and so on. To perform
    such interactions, malware frequently depends on the functions exposed by the
    operating system. Windows exports most of its functions, called *Application Programming
    Interfaces (API),* required for these interactions in *Dynamic Link Libary (DLL)*
    files. Executables import and call these functions typically from various DLLs
    that provide different functionality. The functions that an executable imports
    from other files (mostly DLLs) are called *imported functions* (or *imports*)*.*
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a malware executable wants to create a file on disk, on Windows,
    it can use an API `CreateFile()`, which is exported in `kernel32.dll`. To call
    the API, it first has to load `kernel32.dll` into its memory and then call the
    `CreateFile()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the DLLs that a malware relies upon and the API functions that it
    imports from the DLLs can give an idea about the functionality and capability
    of malware and what to anticipate during its execution. The file dependencies
    in Windows executables are stored in the import table of the PE file structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the *spybot* sample was loaded in pestudio. Clicking
    on the libraries button in pestudio displays all the DLL files the executable
    depends on and the number of imported functions imported from each DLL. These
    are the DLL files that will be loaded into the memory when the program is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the imports button in pestudio displays the API functions imported
    from those DLLs. In the following screenshot, the malware imports network-related
    API functions (such as `connect`, `socket`, `listen`, `send`, and so on) from
    `wsock32.dll`, indicating that the malware, upon execution, will most likely connect
    to the Internet or perform some network activity. pestudio highlights the API
    functions that are frequently used by malwares in the blacklisted column. In subsequent
    chapters, the techniques to inspect API functions will be covered in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes, malware can load a DLL explicitly during runtime using API calls
    such as `LoadLibrary()` or `LdrLoadDLL()`, and it can resolve the function address
    using the `GetProcessAdress()` API. Information about the DLLs loaded during runtime
    will not be present in the import table of the PE file and therefore will not
    be displayed by the tools.
  prefs: []
  type: TYPE_NORMAL
- en: Information about an API function and what it does can be determined from *MSDN
    (Microsoft Developer Network)*. Enter the API name in the search bar ([https://msdn.microsoft.com/en-us/default.aspx](https://msdn.microsoft.com/en-us/default.aspx))
    to get detailed information about the API.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to determining the malware functionality, imports can help you detect
    whether a malware sample is obfuscated. If you come across a malware with very
    few imports, then it is a strong indication of a packed binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate that, let''s compare the imports between the *unpacked sample
    of spybot* and the *packed spybot sample*. The following screenshot shows 110
    imports in the unpacked spybot sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, the *packed sample* of spybot shows only 12 imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes you might want to use Python to enumerate DLL files and imported
    functions (probably to work with a large number of files); this can be done using
    Ero Carerra''s *pefile* module ([https://github.com/erocarrera/pefile](https://github.com/erocarrera/pefile)).
    The installation of the *pefile* module on Ubuntu Linux VM was covered in [Chapter
    1](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485), *Introduction to Malware
    Analysis.* If you are using any other operating system, then it can be installed
    using pip (`pip install pefile`). The following Python script demonstrates the
    use of the *pefile* module to enumerate the DLLs and the imported API functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the result of running the preceding script against the `spybot_packed.exe`
    sample; from the output, you can see the list of DLLs and imported functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 6.2  Inspecting Exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The executable and DLL can export functions, which can be used by other programs.
    Typically, a DLL exports functions (*exports*) that are imported by the executable.
    A DLL cannot run on its own and depends on a host process for executing its code.
    An attacker often creates a DLL that exports functions containing malicious functionality.
    To run the malicious functions within the DLL, it is somehow made to be loaded
    by a process that calls these malicious functions. DLLs can also import functions
    from other libraries (DLLs) to perform system operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting the exported functions can give you a quick idea of the DLL''s capabilities.
    In the following example, loading a DLL associated with malware called *Ramnit*
    in pestudio shows its exported functions, giving an indication of its capabilities.
    When a process loads this DLL, at some point, these functions will be called to
    perform malicious activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00025.jpeg)Export function names may not always give an idea
    of a malware''s capabilities. An attacker may use random or fake export names
    to mislead your analysis or to throw you off track.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, the exported functions can be enumerated using the *pefile module*,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 6.3  Examining PE Section Table And Sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The actual content of the PE file is divided into sections. The sections are
    immediately followed by the PE header. These sections represent either *code*
    or *data* and they have in-memory attributes such as read/write. The section representing
    code contains instructions that will be executed by the processor, whereas the
    section containing data can represent different types of data, such as read/write
    program data (global variables), import/export tables, resources, and so on. Each
    section has a distinct name that conveys the purpose of the section. For example,
    a section with name `.text` indicates code and has an attribute of `read-execute`;
    a section with name `.data` indicates global data and has an attribute of `read-write`.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the compilation of the executable, consistent section names are added
    by the compilers. The following table outlines some of the common sections in
    a PE file:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Section Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `.text` or `CODE` | Contains executable code. |'
  prefs: []
  type: TYPE_TB
- en: '| `.data` or `DATA` | Typically Contains read/write data and global variables.
    |'
  prefs: []
  type: TYPE_TB
- en: '| .`rdata` | Contains read-only data. Sometimes it also contains import and
    export information.  |'
  prefs: []
  type: TYPE_TB
- en: '| `.idata` | If present, contains the import table. If not present, then the
    import information is stored in `.rdata` section. |'
  prefs: []
  type: TYPE_TB
- en: '| `.edata` | If present, contains export information. If not present, then
    the export information is found in `.rdata` section. |'
  prefs: []
  type: TYPE_TB
- en: '| `.rsrc` | This section contains the resources used by the executable such
    as icons, dialogs, menus, strings, and so on. |'
  prefs: []
  type: TYPE_TB
- en: These section names are mainly for humans and are not used by the operating
    system, which means it is possible for an attacker or an obfuscation software
    to create sections with different names. If you come across section names that
    are not common, then you should treat them with suspicion, and further analysis
    is required to confirm maliciousness.
  prefs: []
  type: TYPE_NORMAL
- en: Information about these sections (such as section name, where to find the section,
    and its characteristics) is present in the *section table* in the PE header. Examining
    a section table will give information about the section and its characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you load an executable in *pestudio* and click on sections, it displays
    the section information extracted from the section table and its attributes (read/write and
    so on). The next screenshot from pestudio shows the section information for an
    executable, and some relevant fields from the screenshot are explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Names | Displays section names. In this case, the executable contains four
    sections (`.text`, `.data`, `.rdata` and `.rsrc`). |'
  prefs: []
  type: TYPE_TB
- en: '| Virtual-Size | Indicates the size of the section when loaded into memory.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Virtual-Address | This is the relative virtual address (that is, offset from
    the base address of the executable) where the section can be found in memory.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Raw-size | Indicates the size of the section on the disk. |'
  prefs: []
  type: TYPE_TB
- en: '| Raw-data | Indicates the offset in the file where the section can be found.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Entry-point | This is the RVA (relative virtual address) where the code starts
    executing. In this case, the entry point is in the `.text` section, which is normal. 
    |'
  prefs: []
  type: TYPE_TB
- en: '![](../images/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Examining the section table can also help in identifying any anomaly in the
    PE file. The following screenshot shows the section names of a malware packed
    with UPX; the malware sample contains the following discrepancies:'
  prefs: []
  type: TYPE_NORMAL
- en: The section names do not contain common sections added by the compiler (such
    as `.text`, `.data`, and so on) but contain section names `UPX0` and `UPX1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entry point is in the `UPX1` section, indicating that execution will start
    in this section (decompression routine).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, `raw-size` and the `virtual-size` should be almost equal, but small
    differences are normal due to section alignment. In this case, `raw-size` is `0`,
    indicating that this section will not take up space on the disk, but `virtual-size`
    specifies that, in memory, it takes up more space (around `127 kb`). This is a
    strong indication of a packed binary. The reason for this discrepancy is that
    when a packed binary is executed, the decompression routine of the packer will
    copy decompressed data or instructions into the memory during runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../images/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following Python script demonstrates the use of the *pefile* module to
    display the section and its characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after running the preceding Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*pescanner* by Michael Ligh and Glenn P. Edwards is an excellent tool to detect
    suspicious PE files based on the PE file attributes; it uses heuristics instead
    of using signatures and can help you identify packed binaries even if there are
    no signatures for it. A copy of the script can be downloaded from [https://github.com/hiddenillusion/AnalyzePE/blob/master/pescanner.py](https://github.com/hiddenillusion/AnalyzePE/blob/master/pescanner.py).'
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Examining the Compilation Timestamp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PE header contains information that specifies when the binary was compiled;
    examining this field can give an idea of when the malware was first created. This
    information can be useful in building a timeline of the attack campaign. It is
    also possible that an attacker modifies the timestamp to prevent an analyst from
    knowing the actual timestamp. A compile timestamp can sometimes be used to classify
    suspicious samples. The following example shows a malware binary whose timestamp
    was modified to a future date in 2020\. In this case, even though the actual compilation
    timestamp could not be detected, such characteristics can help you identify anomalous
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Python, you can determine the compile timestamp using the following Python
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: All Delphi binaries have a compile timestamp set to June 19, 1992, making it
    hard to detect the actual compile timestamp. If you are investigating a malware
    binary set to this date, there is a high possibility that you are looking at Delphi
    binary. The blog post at a [http://www.hexacorn.com/blog/2014/12/05/the-not-so-boring-land-of-borland-executables-part-1/](http://www.hexacorn.com/blog/2014/12/05/the-not-so-boring-land-of-borland-executables-part-1/) gives
    information on how it may be possible to get the compilation timestamp from a
    Delphi binary.
  prefs: []
  type: TYPE_NORMAL
- en: 6.5 Examining PE Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The resources required by the executable file such as icons, menu, dialog, and
    strings are stored in the resource section (`.rsrc`) of an executable file. Often, attackers
    store information such as additional binary, and decoy documents, configuration
    data in the resource section, so examining the resource can reveal valuable information
    about a binary. The resource section also contains version information that can
    reveal information about the origin, company name, program author details, and
    copyright information.
  prefs: []
  type: TYPE_NORMAL
- en: '*Resource Hacker* ([http://www.angusj.com/resourcehacker/](http://www.angusj.com/resourcehacker/))
    is a great tool to examine, view, and extract the resource from a suspect binary.
    Let''s take an example of binary that looks like an Excel file on the disk (notice
    how the file extension is changed to `.xls.exe`), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Loading a malicious binary in resource hacker shows three resources (*Icon*,
    *Binary,* and *Icon Group*). The malware specimen uses the icon of Microsoft Excel
    (to give the appearance of an excel sheet):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The executable also contains binary data; one of them has a file signature
    of `D0 CF 11 E0 A1 B1 1A E1`. This sequence of bytes represents the file signature
    for a Microsoft Office document file. The attackers, in this case, stored a decoy
    excel sheet in the resource section. Upon execution, the malware is executed in
    the background, and this decoy excel sheet is displayed to the user as a diversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To save the binary to disk, right-click on the resource that you want to extract
    and click on Save Resource to a *.bin file as shown in the following screenshot.
    In this case, the resource was saved as `sample.xls`*. *The following screenshot
    shows the decoy excel sheet that will be displayed to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Just by exploring the contents of the resource section, a lot can be learned
    about the malware characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 7. Comparing And Classifying The Malware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During your malware investigation, when you come across a malware sample, you
    may want to know whether the malware sample belongs to a particular malware family
    or if it has characteristics that match with the previously analyzed samples.
    Comparing the suspect binary with previously analyzed samples or the samples stored
    in a public or private repository can give an understanding of the malware family,
    its characteristics, and the similarity with the previously analyzed samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'While cryptographic hashing (*MD5/SHA1/SHA256*) is a great technique to detect
    identical samples, it does not help in identifying similar samples. Very often,
    malware authors change minute aspects of malware, which changes the hash value
    completely. The following sections describe some of the techniques that can help
    in comparing and classifying the suspect binary:'
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Classifying Malware Using Fuzzy Hashing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Fuzzy hashing* is a great method to compare files for similarity. *ssdeep*
    ([http://ssdeep.sourceforge.net](http://ssdeep.sourceforge.net)) is a useful tool
    to generate the fuzzy hash for a sample, and it also helps in determining percentage
    similarity between the samples. This technique is useful in comparing a suspect
    binary with the samples in a repository to identify the samples that are similar;
    this can help in identifying the samples that belong to the same malware family
    or the same actor group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use *ssdeep* to calculate and compare fuzzy hashes. Installation of
    *ssdeep* on Ubuntu Linux VM was covered in [Chapter 1](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485), To
    determine a fuzzy hash of a sample, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate the use of fuzzy hashing, let''s take an example of a directory
    consisting of three malware samples. In the following output, you can see that
    all three files have completely different MD5 hash values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The pretty matching mode (`-p` option) in ssdeep can be used to determine percentage
    similarity. From the following output, out of the three samples, two samples have
    99% similarity, suggesting that these two samples probably belong to the same
    malware family:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As demonstrated in the preceding example, cryptographic hashes were not helpful
    in determining the relationship between the samples, whereas the fuzzy hashing
    technique identified the similarity between the samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have a directory containing many malware samples. In that case, it
    is possible to run `ssdeep` on directories and subdirectories containing malware
    samples using the recursive mode (`-r`) as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also match a suspect binary with a list of file hashes. In the following
    example, the ssdeep hashes of all the binaries were redirected to a text file
    (`all_hashes.txt`), and then the suspect binary (`blab.exe`) is matched with all
    the hashes in the file. From the following output, it can be seen that the suspect
    binary (`blab.exe`) is identical to `jnas.exe` (100% match) and has 99% similarity
    with `aiggs.exe`. You can use this technique to compare any new file with the
    hashes of previously analyzed samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python, the fuzzy hash can be computed using *python-ssdeep* ([https://pypi.python.org/pypi/ssdeep/3.2](https://pypi.python.org/pypi/ssdeep/3.2)).
    The installation of the *python-ssdeep* module on Ubuntu Linux VM was covered
    in [Chapter 1](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485), *Introduction
    to Malware Analysis*. To calculate and compare fuzzy hashes, the following commands
    can be used in the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 7.2 Classifying Malware Using Import Hash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Import Hashin*g is another technique that can be used to identify related
    samples and the samples used by the same threat actor groups. *Import hash* (or
    *imphash*) is a technique in which hash values are calculated based on the library/imported
    function (API) names and their particular order within the executable. If the
    files were compiled from the same source and in the same manner, those files would
    tend to have the same *imphash* value. During your malware investigation, if you
    come across samples that have the same imphash values, it means that they have
    the same import address table and are probably related.'
  prefs: []
  type: TYPE_NORMAL
- en: For detailed information on import hashing, and how it can be used to track
    threat actor groups, read [https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html](https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you load an executable into *pestudio*, it calculates the imphash as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Python, imphash can be generated using the *pefile* module. The following
    Python script takes the sample as input and calculates its imphash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output as a result of running the preceding script against a malware sample
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You should also take a look at [http://blog.jpcert.or.jp/2016/05/classifying-mal-a988.html](http://blog.jpcert.or.jp/2016/05/classifying-mal-a988.html)
    which covers details of using import API and the fuzzy hashing technique (impfuzzy)
    to classify malware samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the use of import hashing, let''s take the example of two samples
    from the same threat actor group. In the following output, the samples have different
    cryptographic hash values (MD5), but the impash of these samples are identical;
    this indicates that they were probably compiled from the same source and in the
    same manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Files having the same *imphash* does not necessarily mean they are from the
    same threat group; you might have to correlate information from various sources
    to classify your malware. For example, it is possible that the malware samples
    were generated using a common builder kit that is shared among groups; in such
    cases, samples might have the same *imphash.*
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Classifying Malware Using Section Hash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to import hashing, section hashing can also help in identifying related
    samples. When an executable is loaded in *pestudio*, it calculates the *MD5* of
    each section (`.text`, `.data`, `.rdata`, and so on.). To view the section hashes,
    click on sections as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Python, pefile module can be used to determine the sections hashes as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When you are analyzing a malware sample, you should consider generating the
    fuzzy hash, imphash, and section hashes for the malicious binary and store them
    in a repository; that way, when you come across a new sample, it can be compared
    with these hashes to determine similarity.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Classifying Malware Using YARA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A malware sample can contain many strings or binary indicators; recognizing
    the strings or binary data that are unique to a malware sample or a malware family
    can help in malware classification. Security researchers classify malware based
    on the unique strings and the binary indicators present in the binary. Sometimes,
    malware can also be classified based on general characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: '*YARA* ([http://virustotal.github.io/yara/](http://virustotal.github.io/yara/))
    is a powerful malware identification and classification tool. Malware researchers
    can create YARA rules based on textual or binary information contained within
    the malware specimen. These YARA rules consist of a set of strings and a Boolean
    expression, which determines its logic. Once the rule is written, you can use
    those rules to scan files using the YARA utility or you can use `yara-python`
    to integrate with your tools. This book does not cover all the details on writing
    yara rules but it includes enough information, and its use to get you started.
    For details on writing YARA rules, read the YARA documentation ([http://yara.readthedocs.io/en/v3.7.0/writingrules.html](http://yara.readthedocs.io/en/v3.7.0/writingrules.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.1 Installing YARA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can download and install *YARA* from ([http://virustotal.github.io/yara/](http://virustotal.github.io/yara/)).
    Installation of YARA on Ubuntu Linux VM was covered in [Chapter 1](part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485),* Introduction
    to Malware Analysis*. If you would like to install YARA on any other operating
    system then refer to the installation documentation: [http://yara.readthedocs.io/en/v3.3.0/gettingstarted.html](http://yara.readthedocs.io/en/v3.3.0/gettingstarted.html)
  prefs: []
  type: TYPE_NORMAL
- en: 7.4.2 YARA Rule Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once installed, the next step is to create YARA rules; these rules can be generic
    or very specific, and they can be created using any text editor. To understand
    the YARA rule syntax, let''s take an example of a simple YARA rule that looks
    for suspicious strings in any file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The YARA rule consists of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rule identifier:* This is a name that describes the rule (`suspicious_strings`
    in the preceding example). The rule identifiers can contain any alphanumeric character
    and the underscore character, but the first character cannot be a digit. The rule
    identifiers are case-sensitive and cannot exceed 128 characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*String Definition:* This is the section where the strings (text, hexadecimal,
    or regular expressions) that will be part of the rule are defined. This section
    can be omitted if the rule does not rely on any strings. Each string has an identifier
    consisting of a `$` character followed by a sequence of alphanumeric characters
    and underscores. From the preceding rule, think of `$a`, `$b`, and `$c` as variables
    containing values. These variables are then used in the condition section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Condition Section:* This is not an optional section, and this is where the
    logic of the rule resides. This section must contain a Boolean expression that
    specifies the condition under which the rule will match or not match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.4.3 Running YARA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have the rule ready, the next step is to use the yara utility to scan
    the files using the YARA rules. In the preceding example, the rule looked for
    three suspicious strings (defined in `$a`, `$b` and `$c`), and based on the condition,
    the rule matched if any of the three strings is present in a file. The rule was
    saved as `suspicious.yara`, and running the yara against a directory containing
    malware samples returned two malware samples matching the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding YARA rule, by default, will match on ASCII strings, and it performs
    the case-sensitive match. If you want the rule to detect both ASCII and Unicode
    (wide character) strings, then you specify the `ascii` and `wide` modifier next
    to string. The `nocase` modifier will perform a case-insensitive match (that is,
    it will match Synflooding, synflooding, sYnflooding, and so on). The modified
    rule to implement case-insensitive match and to look for ASCII and Unicode strings
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding rule detected the two executable files containing ASCII
    strings, and it also identified a document (`test.doc`) containing Unicode strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding rule matches any file containing those ASCII and Unicode strings.
    The document (`test.doc`) that it detected was a legitimate document that had
    those strings in its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your intention is to look for strings in an executable file, you can create
    a rule as shown below. In the following rule, the `$mz`* at* `0` in the condition
    specifies YARA to look for the signature `4D 5A` (first two bytes of PE file)
    at the beginning of the file; this ensures that the signature triggers only for
    PE executable files. Text strings are enclosed in double quotes, whereas hex strings
    are enclosed in curly braces as in the `$mz` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, running the preceding rule only detected the executable files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 7.4.4 Applications of YARA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take another example of the sample that was previously used in *Section
    6.5*, *Examining PE resources*. The sample (`5340.exe`) stored a decoy excel document
    in its resource section; some malware programs store a decoy document to present
    it to the user upon execution. The following YARA rule detects an executable file
    containing an embedded Microsoft Office document in it. The rule will trigger
    if the hex string is found at an offset greater than `1024` bytes in the file
    (this skips the PE header), and the `filesize` specifies the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding yara rule detected only the sample that contained the
    embedded excel document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example detects a malware sample called *9002 RAT* using the
    serial number of its digital certificate. RAT 9002 used a digital certificate
    with a serial number `45 6E 96 7A 81 5A A5 CB B9 9F B8 6A CA 8F 7F 69` ([https://blog.cylance.com/another-9002-trojan-variant](https://blog.cylance.com/another-9002-trojan-variant)).
    The serial number can be used as a signature to detect samples that have the same
    digital certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the rule detected all samples with the same digital certificate, and
    all of these samples turned out to be *RAT 9002* samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'YARA rules can also be used to detect packers. In *Section 5*, *Determining
    file obfuscation*, we looked at how to detect packers using the *Exeinfo PE* tool.
    *Exeinfo PE* uses signatures stored in a plain text file called `userdb.txt`.
    The following is an example signature format used by *Exeinfo PE* to detect the *UPX*
    packer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ep_only=true` in the preceding signature means that *Exeinfo PE* should
    only check for the signature at the program''s address of the entry point (which
    is where the code starts executing). The preceding signature can be converted
    to a YARA rule. The new versions of YARA support the *PE* module, which allows
    you to create rules for PE files by using attributes and features of the PE file
    format. If you are using newer versions of YARA, the Exeinfo PE signature can
    be translated to a YARA rule as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using older versions of YARA (which do not have support for the
    PE module), then use the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, running a yara rule on the samples directory detected the samples that
    were packed with UPX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding method, all the packer signatures in Exeinfo PE's `userdb.txt`
    can be converted to YARA rules.
  prefs: []
  type: TYPE_NORMAL
- en: '*PEiD* is another tool that detects packers (this tool is no longer supported);
    it stores the signature in a text file, `UserDB.txt`. Python scripts *peid_to_yara.py*
    written by Matthew Richard (part of Malware Analyst''s Cookbook) and Didier Steven''s
    peid*-*userdb*-to-yara-rules.py* ([https://github.com/DidierStevens/DidierStevensSuite/blob/master/peid-userdb-to-yara-rules.py](https://github.com/DidierStevens/DidierStevensSuite/blob/master/peid-userdb-to-yara-rules.py))
    convert `UserDB.txt` signatures to YARA rules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'YARA can be used to detect patterns in any file. The following YARA rule detects
    communication of different variants of the *Gh0stRAT* malware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding rule on a directory containing network packet captures
    (pcaps), detecting the GhostRAT pattern in some of the pcaps as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After you analyze the malware, you can create signatures to identify its components;
    the following code shows an example YARA rule to detect the driver and the DLL
    components of *Darkmegi Rootkit*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding rule was created after analyzing a single sample of *Darkmegi*;
    however, running the preceding rule on a directory containing malware samples
    detected all the *Darkmegi* rootkit samples matching the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: YARA is a powerful tool; creating YARA rules to scan a repository of known samples
    can identify and classify samples having same characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: The strings that you use in the rule might create false positives. It is a good
    idea to test your signatures against known good files and also to think of situations
    that might trigger false positives. To write sound YARA rules, read [https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/](https://www.bsk-consulting.de/2015/02/16/write-simple-sound-yara-rules/).
    For generating YARA rules, you might consider using Florian Roth's *yarGen* ([https://github.com/Neo23x0/yarGen](https://github.com/Neo23x0/yarGen))
    or Joe Security's YARA rule generator ([https://www.yara-generator.net/](https://www.yara-generator.net/)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static analysis is the first step in malware analysis; it allows you to extract
    valuable information from the binary and helps in comparing and classifying the
    malware samples. This chapter introduced you to various tools and techniques,
    using which different aspects of malware binary can be determined without executing
    it. In the next chapter, *Dynamic Analysis*, you will learn how to determine the
    behavior of malware by executing it within an isolated environment.
  prefs: []
  type: TYPE_NORMAL
