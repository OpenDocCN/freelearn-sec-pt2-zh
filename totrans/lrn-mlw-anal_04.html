<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Assembly Language and Disassembly Primer</h1>
                
            
            <article>
                
<p class="calibre2">Static analysis and dynamic analysis are great techniques to understand the basic functionality of malware, but these techniques do not provide all the required information regarding the malware's functionality. Malware authors write their malicious code in a high-level language, such as C or C++, which is compiled to an executable <span class="calibre7">using a compiler</span>. During your investigation, you will only have the malicious executable, without its source code. To gain a deeper understanding of a malware's inner workings and to understand the critical aspects of a malicious binary, code analysis needs to be performed.</p>
<p class="calibre2">This chapter will cover the concepts and skills required to perform code analysis. For a better understanding of the subject, this chapter will make use of relevant concepts from both C programming and assembly language programming. To understand the concepts covered in this chapter, you are expected to have a basic programming knowledge (preferably C programming). If you are not familiar with basic programming concepts, start with an introductory programming book (you can refer to the additional resources provided at the end of this chapter) and return to this chapter afterward.</p>
<p class="calibre2">The following topics will be covered from a code analysis (reverse engineering) perspective:</p>
<ul class="calibre11">
<li class="calibre12">Computer basics, memory, and the CPU</li>
<li class="calibre12">Data transfer, arithmetic, and bitwise operations</li>
<li class="calibre12">Branching and looping</li>
<li class="calibre12">Functions and stack</li>
<li class="calibre12">Arrays, strings, and structures</li>
<li class="calibre12">Concepts of the x64 architecture</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1. Computer Basics</h1>
                
            
            <article>
                
<p class="calibre2">A computer is a machine that processes information. All of the information in the computer is represented in <em class="calibre17">bits</em>. A bit is an individual unit that can take either of the two values <kbd class="calibre13">0</kbd> or <kbd class="calibre13">1</kbd>. The collection of bits can represent a number, a character, or any other  piece of information.</p>
<p class="calibre2"><strong class="calibre5">Fundamental data types</strong>:</p>
<p class="calibre2">A group of <kbd class="calibre13">8</kbd> bits makes a <em class="calibre17">byte</em>. A single byte is represented as two hexadecimal digits, and each hexadecimal digit is <kbd class="calibre13">4</kbd> bits in size and called a <em class="calibre17">nibble</em>. For example, the binary number <kbd class="calibre13">01011101</kbd> translates to <kbd class="calibre13">5D</kbd> in hexadecimal. The digit <kbd class="calibre13">5</kbd> (<kbd class="calibre13">0101</kbd>) and digit <kbd class="calibre13">D</kbd> (<kbd class="calibre13">1101</kbd>) are the <kbd class="calibre13">nibbles</kbd>:</p>
<div class="cdpaligncenter"><img src="../images/00060.gif" class="calibre62"/></div>
<p class="calibre2"><span class="calibre7">Apart from bytes, there are other data types, such as a </span><kbd class="calibre13">word</kbd><span class="calibre7">, which is <kbd class="calibre13">2</kbd> bytes (</span><kbd class="calibre13">16 bits</kbd><span class="calibre7">) in size, a </span><kbd class="calibre13">double word (dword)</kbd> <span class="calibre7">is <kbd class="calibre13">4</kbd> bytes (</span><kbd class="calibre13">32 bits</kbd><span class="calibre7">), and a </span><kbd class="calibre13">quadword (qword)</kbd> <span class="calibre7">is <kbd class="calibre13">8</kbd> bytes (</span><kbd class="calibre13">64 bits</kbd><span class="calibre7">) in size:</span></p>
<div class="cdpaligncenter"><img src="../images/00061.jpeg" class="calibre63"/></div>
<p class="calibre2"><strong class="calibre5">Data Interpretation</strong>:</p>
<p class="calibre2">A byte, or sequence of bytes, can be interpreted differently. For example, <kbd class="calibre13">5D</kbd> can represent the binary number <kbd class="calibre13">01011101</kbd>, or the decimal number <kbd class="calibre13">93</kbd>, or the character <kbd class="calibre13">]</kbd>. The byte <kbd class="calibre13">5D</kbd> can also represent a machine instruction, <kbd class="calibre13">pop ebp</kbd>.</p>
<p class="calibre2">Similarly, the sequence of two bytes <kbd class="calibre13">8B EC</kbd> (<kbd class="calibre13">word</kbd>) can represent <kbd class="calibre13">short int 35820</kbd> or a machine instruction, <kbd class="calibre13">mov ebp,esp</kbd>.</p>
<p class="calibre2">The double word (<kbd class="calibre13">dword</kbd>) value <kbd class="calibre13">0x010F1000</kbd> can be interpreted as an integer value <kbd class="calibre13">17764352</kbd>, or a memory address. It's all a matter of interpretation, and what a byte or sequence of bytes means depends on how it is used.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.1 Memory</h1>
                
            
            <article>
                
<p class="calibre2">The <em class="calibre17">main memory (RAM)</em> stores the code (machine code) and data for the computer. A computer's main memory is an array of bytes (sequence of bytes in hex format), with each byte labeled with a unique number, known as its <em class="calibre17">address</em>. The first address starts at <kbd class="calibre13">0</kbd>, and the last address depends on the hardware and software in use. The addresses and values are represented in hexadecimal:</p>
<div class="cdpaligncenter"><img src="../images/00062.jpeg" class="calibre64"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.1.1 How Data Resides In Memory</h1>
                
            
            <article>
                
<p class="calibre2">In memory, the data is stored in the <em class="calibre17">little-endian</em> format; that is, a low-order byte is stored at the lower address, and subsequent bytes are stored in successively higher addresses in the memory:</p>
<div class="cdpaligncenter"><img src="../images/00063.jpeg" class="calibre65"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.2 CPU</h1>
                
            
            <article>
                
<p class="calibre2">The <em class="calibre17">Central Processing Unit (CPU)</em> executes instructions (also called <em class="calibre17">machine instructions</em>). The instructions that the CPU executes are stored in the memory as a sequence of bytes. While executing the instructions, the required data (which is also stored as a sequence of bytes) is fetched from memory.</p>
<p class="calibre2">The CPU itself contains a small collection of memory within its chip, called the <em class="calibre17">register set</em>. The registers are used to store values fetched from memory during execution.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.2.1 Machine Language</h1>
                
            
            <article>
                
<p class="calibre2">Each CPU has a set of instructions that it can execute. The instructions that the CPU executes make up the CPU’s machine language. These machine instructions are stored in the memory as a sequence of bytes that is fetched, interpreted, and executed by the CPU. </p>
<p class="calibre2">A <em class="calibre17">compiler</em> is a program that translates programs written in a programming language (like C or C++) into the machine language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.3 Program Basics</h1>
                
            
            <article>
                
<p class="calibre2">In this section, you will learn what happens during the compilation process and program execution, and how various computer components interact with each other while the program executes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.3.1 Program Compilation</h1>
                
            
            <article>
                
<p class="calibre2">The following list outlines the executable compilation process:</p>
<ol class="calibre14">
<li value="1" class="calibre12">The source code is written in a high-level language, such as C or C++.</li>
<li value="2" class="calibre12">The source code of the program is run through the compiler. The compiler then translates the statements written in a high-level language into an intermediate form called an <em class="calibre19">object file</em> or <em class="calibre19">machine code</em>, which is not human-readable and is meant for execution by the processor. </li>
<li value="3" class="calibre12">The object code is then passed through the linker. The linker links the object code with the required libraries (DLLs) to produce an executable that can be run on a system:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00064.jpeg" class="calibre66"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.3.2 Program On Disk</h1>
                
            
            <article>
                
<p class="calibre2">Let's try to understand how a compiled program appears on the disk, with an example. Let's take an example of a simple C program that prints a string to the screen:</p>
<pre class="calibre18">#include &lt;stdio.h&gt;<br class="title-page-name"/>int main() {<br class="title-page-name"/>   char *string = "This is a simple program"; <br class="title-page-name"/>   printf("%s",string);<br class="title-page-name"/>   return 0;<br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre7">The above program was passed through a compiler to generate an executable file (</span><kbd class="calibre13">print_string.exe</kbd><span class="calibre7">). </span>Opening the compiled executable file in the PE Internals tool (<a href="http://www.andreybazhan.com/pe-internals.html" class="calibre10">http://www.andreybazhan.com/pe-internals.html</a>) displays the five sections (<kbd class="calibre13">.text</kbd>, <kbd class="calibre13">.rdata</kbd>, <kbd class="calibre13">.data</kbd>, <kbd class="calibre13">.rsrc</kbd>, and <kbd class="calibre13">.reloc</kbd>) generated by the compiler. Information about the sections was provided in <a href="part0032.html#UGI00-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 2</a>, <em class="calibre17"><span class="calibre7">Static Analysis</span>.</em> Here, we will mainly focus on two sections: <kbd class="calibre13">.text</kbd> and <kbd class="calibre13">.data</kbd>. The content of the <kbd class="calibre13">.data</kbd> section is shown in the following screenshot:</p>
<div class="cdpaligncenter"><img src="../images/00065.jpeg" class="calibre67"/></div>
<p class="calibre2">In the preceding screenshot, you can see that the string <kbd class="calibre13">This is a simple program</kbd>, which we used in our program, is stored in the <kbd class="calibre13">.data</kbd> section at the file offset <kbd class="calibre13">0x1E00</kbd>. This string is not a code, but it is the data required by the program. In the same manner, the <kbd class="calibre13">.rdata</kbd> section contains read-only data and sometimes contains <em class="calibre17">import/export</em> information. The <kbd class="calibre13">.rsrc</kbd> section contains resources used by the executable. </p>
<p class="calibre2">The content of the <kbd class="calibre13">.text</kbd> section is shown in the following screenshot:</p>
<div class="cdpaligncenter"><img src="../images/00066.gif" class="calibre68"/></div>
<p class="calibre2">The sequence of bytes (<kbd class="calibre13">35</kbd> bytes to be specific) displayed in the <kbd class="calibre13">.text</kbd> section (starting from the file offset <kbd class="calibre13">0x400</kbd>) is the <em class="calibre17">machine code</em>. The source code that we had written was translated into machine code (or machine language program) by the compiler. The machine code is not easy for humans to read, but the processor (CPU) knows how to interpret those sequences of bytes. The machine code contains instructions that will be executed by the processor. The compiler segregated the data and the code in different sections on the disk. For the sake of simplicity, we can think of an executable as containing code (<kbd class="calibre13">.text</kbd>) and data (<kbd class="calibre13">.data</kbd>, <kbd class="calibre13">.rdata</kbd>, and so on):</p>
<div class="cdpaligncenter"><img src="../images/00067.jpeg" class="calibre69"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.3.3 Program In Memory</h1>
                
            
            <article>
                
<p class="calibre2">In the previous section, we examined the structure of the executable on the disk. Let's try to understand what happens when an executable is loaded into the memory. When the executable is double-clicked, a process memory is allocated by the operating system, and the executable is loaded into the allocated memory by the operating system loader. The following simplified memory layout should help you to visualize the concept; note that the structure of the executable on the disk is similar to the structure of the executable in the memory:</p>
<div class="cdpaligncenter"><img src="../images/00068.jpeg" class="calibre70"/></div>
<p class="calibre2">In the preceding diagram, the heap is used for dynamic memory allocation during program execution, and its contents can vary. The stack is used for storing the local variables, function arguments, and the return address. You will learn about the stack in detail in later sections.</p>
<div class="packt_infobox">The memory layout shown previously is greatly simplified, and the positions of components may be in any order. The memory also contains various <em class="calibre22">Dynamic Link Libraries (DLLs)</em>, which are not shown in the preceding diagram, to keep it simple. You will learn about the process memory in detail in the upcoming chapters.</div>
<p class="calibre2">Now, let's go back to our compiled executable (<kbd class="calibre13">print_string.exe</kbd>) and load it into the memory. The executable was opened in the <em class="calibre17">x64dbg</em> debugger, which loaded the executable in the memory (we will be covering <em class="calibre17">x64dbg</em> in a later chapter; for now, we will focus on the structure of the executable in memory). In the following screenshot, you can see that the executable was loaded at the memory address <kbd class="calibre13">0x010F0000</kbd>, and all the sections of the executable were also loaded into the memory. A point to remember is that the memory address that you are looking at is the virtual address, not the physical memory address. The virtual address will eventually be translated into a physical memory address (you will learn more about the virtual and physical address in later chapters):</p>
<div class="cdpaligncenter"><img src="../images/00069.gif" class="calibre41"/></div>
<p class="calibre2">Examining the memory address of the <kbd class="calibre13">.data</kbd> section at <kbd class="calibre13">0x010F3000</kbd> displays the string <kbd class="calibre13">This is a simple program</kbd>.</p>
<div class="cdpaligncenter"><img src="../images/00070.gif" class="calibre41"/></div>
<p class="calibre2">Examining the memory address of the <kbd class="calibre13">.text</kbd> section at <kbd class="calibre13">0x010F1000</kbd> displays the sequence of bytes, which is the machine code.</p>
<div class="cdpaligncenter"><img src="../images/00071.gif" class="calibre41"/></div>
<p class="calibre2">Once the executable that contains the code and data is loaded into the memory, the CPU fetches the machine code from memory, interprets it, and executes it. While executing the machine instructions, the required data will also be fetched from memory. In our example, the CPU fetches the machine code containing the instructions (to print on the screen) from the <kbd class="calibre13">.text</kbd> section, and it fetches the string (data) <kbd class="calibre13">This is a simple program</kbd>, to be printed from the <kbd class="calibre13">.data</kbd> section. The following diagram should help you to visualize the interactions between the CPU and the memory:</p>
<div class="cdpaligncenter"><img src="../images/00072.jpeg" class="calibre71"/></div>
<p class="calibre2">While executing instructions, the program may also interact with the input/output devices. In our example, when the program is executed, the string is printed onto the computer screen (output device). If the machine code had an instruction to receive input, the processor (CPU) would have interacted with the input device (such as the keyboard).</p>
<p class="calibre2">To summarize, the following steps are performed when a program is executed:</p>
<ol class="calibre14">
<li value="1" class="calibre12">The program (which contains code and data) is loaded into the memory.</li>
<li value="2" class="calibre12">The CPU fetches the machine instruction, decodes it, and executes it.</li>
<li value="3" class="calibre12">The CPU fetches the required data from memory; the data can also be written to the memory.</li>
</ol>
<ol start="4" class="calibre14">
<li value="4" class="calibre12">The CPU may interact with the input/output system, as necessary:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00073.jpeg" class="calibre72"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.3.4 Program Disassembly (From Machine code To Assembly code)</h1>
                
            
            <article>
                
<p class="calibre2">As you would expect, machine code contains information about the inner workings of the program. For example, in our program, the machine code included the instructions to print on the screen, but it would be painful for a human to try to understand the machine code (which is stored as a sequence of bytes).</p>
<p class="calibre2">A <em class="calibre17">disassembler/debugger</em> (like <em class="calibre17">IDA Pro</em> or <em class="calibre17">x64dbg</em>) is a program that translates machine code into a low-level code called <em class="calibre17">assembly code (assembly language program)</em>, which can be read and analyzed to determine the workings of a program. The following screenshot shows the machine code (a sequence of bytes in the <kbd class="calibre13">.text</kbd> section) translated into the assembly instructions representing <kbd class="calibre13">13</kbd> executable instructions (<kbd class="calibre13">push ebp</kbd>, <kbd class="calibre13">mov ebp,esp</kbd>, and so on). These translated instructions are called <em class="calibre17">assembly language instructions</em>.</p>
<p class="calibre2">You can see that the assembly instructions are much easier to read than the machine code. Notice how a disassembler translated the byte <kbd class="calibre13">55</kbd> into a readable assembly instruction <kbd class="calibre13">push ebp</kbd>, and the next two bytes <kbd class="calibre13">8B EC</kbd> into <kbd class="calibre13">mov ebp,esp</kbd>; and so on:</p>
<div class="cdpaligncenter"><img src="../images/00074.jpeg" class="calibre73"/></div>
<p class="calibre2">From a code analysis perspective, determining the program's functionality mainly relies on understanding these assembly instructions and how to interpret them.</p>
<p class="calibre2">In the rest of the chapter, you will learn the skills required to understand the assembly code to reverse engineer the malicious binary. In the upcoming sections, you will learn the concepts of x86 assembly language instructions that are essential to perform code analysis; x86, also known as IA-32 (32-bit), is the most popular architecture for PCs. Microsoft Windows runs on an x86 (32-bit) architecture and Intel 64 (x64) architectures. Most malware that you will encounter are compiled for x86 (32 bit) architectures and can run on both 32 bit and 64 bit Windows. At the end of the chapter, you will understand the x64 architecture and the differences between x86 and x64.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2. CPU Registers</h1>
                
            
            <article>
                
<p class="calibre2">As mentioned previously, the CPU contains special storage called <em class="calibre17">registers</em>. The CPU can access data in registers much faster than data in memory, because of which the values fetched from the memory are temporarily stored in these registers to perform operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.1 General-Purpose Registers</h1>
                
            
            <article>
                
<p class="calibre2">The x86 CPU has eight general purpose registers: <kbd class="calibre13">eax</kbd>, <kbd class="calibre13">ebx</kbd>, <kbd class="calibre13">ecx</kbd>, <kbd class="calibre13">edx</kbd>, <kbd class="calibre13">esp</kbd>, <kbd class="calibre13">ebp</kbd>, <kbd class="calibre13">esi</kbd>, and <kbd class="calibre13">edi</kbd>. These registers are 32 bits (4 bytes) in size. A program can access registers as 32-bit (4 bytes), 16-bit (2 bytes), or 8-bit (1 byte) values. The lower 16 bits (2 bytes) of each of these registers can be accessed as <kbd class="calibre13">ax</kbd>, <kbd class="calibre13">bx</kbd>, <kbd class="calibre13">cx</kbd>, <kbd class="calibre13">dx</kbd>, <kbd class="calibre13">sp</kbd>, <kbd class="calibre13">bp</kbd>, <kbd class="calibre13">si</kbd>, and <kbd class="calibre13">di</kbd>. The lower 8 bits (1 byte) of <kbd class="calibre13">eax</kbd>, <kbd class="calibre13">ebx</kbd>, <kbd class="calibre13">ecx</kbd>, and <kbd class="calibre13">edx</kbd> can be referenced as <kbd class="calibre13">al</kbd>, <kbd class="calibre13">bl</kbd>, <kbd class="calibre13">cl</kbd>, and <kbd class="calibre13">dl</kbd>. The higher set of 8 bits can be accessed as <kbd class="calibre13">ah</kbd>, <kbd class="calibre13">bh</kbd>, <kbd class="calibre13">ch</kbd>, and <kbd class="calibre13">dh</kbd>. In the following diagram, the <kbd class="calibre13">eax</kbd> register contains the 4-byte value <kbd class="calibre13">0xC6A93174</kbd>. A program can access the lower 2 bytes (<kbd class="calibre13">0x3174</kbd>) by accessing the <kbd class="calibre13">ax</kbd> register, and it can access the lower byte (<kbd class="calibre13">0x74</kbd>) by accessing the <kbd class="calibre13">al</kbd> register, and the next byte (<kbd class="calibre13">0x31</kbd>) can be accessed by using the <kbd class="calibre13">ah</kbd> register:</p>
<div class="cdpaligncenter"><img src="../images/00075.gif" class="calibre74"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2 Instruction Pointer (EIP)</h1>
                
            
            <article>
                
<p class="calibre2">The CPU has a special register called <kbd class="calibre13">eip</kbd>; it contains the address of the next instruction to execute. When the instruction is executed, the <kbd class="calibre13">eip</kbd> will be pointing to the next instruction in the memory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.3 EFLAGS Register</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre13">eflags</kbd> register is a 32-bit register, and each bit in this register is a <em class="calibre17">flag</em>. The bits in <kbd class="calibre13">EFLAGS</kbd> registers are used to indicate the status of the computations and to control the CPU operations. The flag register is usually not referred to directly, but during the execution of computational or conditional instructions, each flag is set to either <kbd class="calibre13">1</kbd> or <kbd class="calibre13">0</kbd>. Apart from these registers, there are additional registers, which are called <em class="calibre17">segment registers</em> (<kbd class="calibre13">cs</kbd>, <kbd class="calibre13">ss</kbd>, <kbd class="calibre13">ds</kbd>, <kbd class="calibre13">es</kbd>, <kbd class="calibre13">fs</kbd>, and <kbd class="calibre13">gs</kbd>), which keep track of sections in the memory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3. Data Transfer Instructions</h1>
                
            
            <article>
                
<p class="calibre2">One of the basic instructions in the assembly language is the <kbd class="calibre13">mov</kbd> instruction. As the name suggest, this instruction moves data from one location to another (from source to destination). The general form of the <kbd class="calibre13">mov</kbd> instruction is as follows; this is similar to the assignment operation in a high-level language:</p>
<pre class="calibre18">mov dst,src</pre>
<p class="calibre2">There are different variations of the <kbd class="calibre13">mov</kbd> instruction, which will be covered next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.1 Moving a Constant Into Register</h1>
                
            
            <article>
                
<p class="calibre2">The first variation of the <kbd class="calibre13">mov</kbd> instruction is to move a <em class="calibre17">constant (or immediate value)</em> into a register. In the following examples, <kbd class="calibre13">;</kbd> (a semicolon) indicates the start of the comment; anything after the semicolon is not part of the assembly instruction. This is just a brief description to help you understand this concept:</p>
<pre class="calibre18">mov eax,10  <em class="calibre19">; moves 10 into EAX register, same as eax=10</em><br class="title-page-name"/>mov bx,7    <em class="calibre19">; moves 7 in bx register, same as bx=7</em><br class="title-page-name"/>mov eax,64h <em class="calibre19">; moves hex value 0x64 (i.e 100) into EAX</em></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.2 Moving Values From Register To Register</h1>
                
            
            <article>
                
<p class="calibre2">Moving a value from one register to another is done by placing the register names as operands to the <kbd class="calibre13">mov</kbd> instruction:</p>
<pre class="calibre18">mov eax,ebx <em class="calibre19">; moves content of ebx into eax, i.e eax=ebx</em></pre>
<p class="calibre2">Following is an example of two assembly instructions. The first instruction moves the constant value <kbd class="calibre13">10</kbd> into the <kbd class="calibre13">ebx</kbd> register. The second instruction moves the value of <kbd class="calibre13">ebx</kbd> (in other words, <kbd class="calibre13">10</kbd>) into the <kbd class="calibre13">eax</kbd> register; as a result, the <kbd class="calibre13">eax</kbd> register will contain the value <kbd class="calibre13">10</kbd>:</p>
<pre class="calibre18">mov ebx,10  <em class="calibre19">; moves 10 into ebx, ebx = 10</em><br class="title-page-name"/>mov eax,ebx <em class="calibre19">; moves value in ebx into eax, eax = ebx or eax = 10</em></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.3 Moving Values From Memory To Registers</h1>
                
            
            <article>
                
<p class="calibre2">Before looking at the assembly instruction to move a value from the memory to a register, let's try to understand how values reside in the memory. Let's say you have defined a variable in your C program:</p>
<pre class="calibre18">int val = 100;</pre>
<p class="calibre2">The following list outlines what happens during the runtime of the program:</p>
<ol class="calibre14">
<li value="1" class="calibre12">An integer is 4 bytes in length, so the integer <kbd class="calibre13">100</kbd> is stored as a sequence of 4 bytes (<kbd class="calibre13">00 00 00 64</kbd>) in the memory.</li>
<li value="2" class="calibre12">The sequence of four bytes is stored in the <em class="calibre19">little-endian</em> format mentioned previously.</li>
<li value="3" class="calibre12">The integer <kbd class="calibre13">100</kbd> is stored at some memory address. Let's assume that <kbd class="calibre13">100</kbd> was stored at the memory address starting at <kbd class="calibre13">0x403000</kbd>; you can think of this memory address labeled as <kbd class="calibre13">val</kbd>:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00076.gif" class="calibre75"/></div>
<p class="calibre2">To move a value from the memory into a register in assembly language, you must use the address of the value. The following assembly instruction will move the 4 bytes stored at the memory address <kbd class="calibre13">0x403000</kbd> into the register <kbd class="calibre13">eax</kbd>. The square bracket specifies that you want the value stored at the memory location, rather than the address itself:</p>
<pre class="calibre18">mov eax,[0x403000] <em class="calibre19">; eax will now contain 00 00 00 64 (i.e 100)</em></pre>
<p class="calibre2">Notice that in the preceding instruction, you did not have to specify 4 bytes in the instruction; based on the size of the destination register (<kbd class="calibre13">eax</kbd>), it automatically determined how many bytes to move. The following screenshot will help you to understand what happens after executing the preceding instruction:</p>
<div class="cdpaligncenter"><img src="../images/00077.gif" class="calibre76"/></div>
<p class="calibre2">During reverse engineering, you will normally see instructions similar to the ones shown as below. The square brackets may contain a <em class="calibre17">register</em>, <em class="calibre17">a constant added to a register</em>, or <em class="calibre17">a register added to a register</em>. All of the following diagram instructions move values stored at the memory address specified within the square brackets to the register. The simplest thing to remember is that everything within the square brackets represents an address:</p>
<pre class="calibre18">mov eax,[ebx]     <em class="calibre19">; moves value at address specifed by ebx register</em><br class="title-page-name"/>mov eax,[ebx+ecx] <em class="calibre19">; moves value at address specified by ebx+ecx</em><br class="title-page-name"/>mov ebx,[ebp-4]   <em class="calibre19">; moves value at address specified by ebp-4</em></pre>
<p class="calibre2">Another instruction that you will normally come across is the <kbd class="calibre13">lea</kbd> instruction, which stands for <em class="calibre17">load effective address</em>; this instruction will load the address instead of the value:</p>
<pre class="calibre18">lea ebx,[0x403000] <em class="calibre19">; loads the address 0x403000 into ebx</em><br class="title-page-name"/>lea eax, [ebx]     <em class="calibre19">; if ebx = 0x403000, then eax will also contain 0x403000</em></pre>
<p class="calibre2">Sometimes, you will come across instructions like the ones that follow. These instructions are the same as the previously mentioned instructions and transfer data stored in a memory address (specified by <kbd class="calibre13">ebp-4</kbd>) into the register. The <kbd class="calibre13">dword ptr</kbd> just indicates that a 4-byte (<kbd class="calibre13">dword</kbd>) value is moved from the memory address specified by <kbd class="calibre13">ebp-4</kbd> into the <kbd class="calibre13">eax</kbd>:</p>
<pre class="calibre18">mov eax,dword ptr [ebp-4]  <em class="calibre19">; same as mov eax,[ebp-4]</em></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.4 Moving Values From Registers To Memory</h1>
                
            
            <article>
                
<p class="calibre2">You can move a value from a register to memory by swapping operands so that the memory address is on the left-hand side (destination) and the register is on the right-hand side (source):</p>
<pre class="calibre18">mov [0x403000],eax <em class="calibre19">; moves 4 byte value in eax to memory location starting at 0x403000</em><br class="title-page-name"/>mov [ebx],eax   <em class="calibre19">; moves 4 byte value in eax to the memory address specified by ebx</em></pre>
<p class="calibre2">Sometimes, you will come across instructions like those that follow. These instructions move constant values into a memory location; <kbd class="calibre13">dword ptr</kbd> just specifies that a <kbd class="calibre13">dword</kbd> value (4 bytes) is moved into the memory location. Similarly, <kbd class="calibre13">word ptr</kbd> specifies that a <kbd class="calibre13">word</kbd> (2 bytes) is moved into the memory location:</p>
<pre class="calibre18">mov dword ptr [402000],13498h <em class="calibre19">; moves dword value 0x13496 into the address 0x402000</em><br class="title-page-name"/>mov dword ptr [ebx],100   <em class="calibre19">; moves dword value 100 into the address specified by ebx</em><br class="title-page-name"/>mov word ptr [ebx], 100    <em class="calibre19">; moves a word 100 into the address specified by ebx</em></pre>
<p class="calibre2">In the preceding case, if <kbd class="calibre13">ebx</kbd> contained the memory address <kbd class="calibre13">0x402000</kbd>, then the second instruction copies <kbd class="calibre13">100</kbd> as <kbd class="calibre13">00 00 00 64</kbd> (4 bytes) into the memory location starting at the address <kbd class="calibre13">0x402000</kbd>, and the third instruction copies <kbd class="calibre13">100</kbd> as <kbd class="calibre13">00 64</kbd> (2 bytes) into the memory location starting at <kbd class="calibre13">0x40200</kbd>, as shown here:</p>
<div class="cdpaligncenter"><img src="../images/00078.gif" class="calibre77"/></div>
<p class="calibre2"><span class="calibre7">Let's take a look at a simple challenge.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.5 Disassembly Challenge</h1>
                
            
            <article>
                
<p class="calibre2">The following is a disassembled output of a simple C code snippet. Can you figure out what this code snippet does, and can you translate it back to a pseudocode (high-level language equivalent)? Use all of the concepts that you have learned so far to solve the challenge. The answer to the challenge will be covered in the next section, and we will also look at the original C code snippet after we solve this challenge:</p>
<pre class="calibre18">mov dword ptr [ebp-4],1  <span>➊</span><br class="title-page-name"/>mov eax,dword ptr [ebp-4]  ➋<br class="title-page-name"/>mov dword ptr [ebp-8],eax  ➌</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.6 Disassembly Solution</h1>
                
            
            <article>
                
<p class="calibre2">The preceding program copies a value from one memory location to another. At ➊, the program copies a <kbd class="calibre13">dword</kbd> value <kbd class="calibre13">1</kbd> into a memory address (specified by <kbd class="calibre13">ebp-4</kbd>). At ➋, <span class="calibre7">the same value is copied into the</span> <kbd class="calibre13">eax</kbd> <span class="calibre7">register, which is then copied into a different memory address,</span> <kbd class="calibre13">ebp-8</kbd>, at ➌.</p>
<p class="calibre2">The disassembled code might be difficult to understand initially, so let me break it down to make it simple. We know that in a high-level language like C, a variable that you define (for example, <kbd class="calibre13">int val;</kbd>) is just a symbolic name for a memory address (as mentioned previously). Going by that logic, let's identify the memory address references and give them a symbolic name. In the disassembled program, we have two addresses (within square brackets): <kbd class="calibre13">ebp-4</kbd> and <kbd class="calibre13">ebp-8</kbd>. Let's label them and give them symbolic names; let's say, <kbd class="calibre13">ebp-4 = a</kbd> and <kbd class="calibre13">ebp-8 = b</kbd>. Now, the program should look like the one shown here:</p>
<pre class="calibre18">mov dword ptr [a],1     <em class="calibre19">; treat it as mov [a],1</em><br class="title-page-name"/>mov eax,dword ptr [a]   <em class="calibre19">; treat it as mov eax,[a]</em><br class="title-page-name"/>mov dword ptr [b],eax   <em class="calibre19">; treat it as mov [b],eax</em></pre>
<p class="calibre2">In a high-level language, when you assign a value to a variable, let's say <kbd class="calibre13">val = 1</kbd>, the value <kbd class="calibre13">1</kbd> is moved into the address represented by the <kbd class="calibre13">val</kbd> variable. In assembly, this can be represented as <kbd class="calibre13">mov [val], 1</kbd>. In other words, <kbd class="calibre13">val = 1</kbd> in a high-level language is the same as <kbd class="calibre13">mov [val],1</kbd> in assembly. Using this logic, the preceding program can be written into a high-level language equivalent:</p>
<pre class="calibre18">a = 1<br class="title-page-name"/>eax = a<br class="title-page-name"/>b = eax ➍</pre>
<p class="calibre2">Recall that, the registers are used by the CPU for temporary storage. So, let's replace all of the register names with their values on the right-hand side of the <kbd class="calibre13">=</kbd> sign (for example, replace <kbd class="calibre13">eax</kbd> with its value, <kbd class="calibre13">a</kbd>, at ➍). The resultant code is shown here:</p>
<pre class="calibre18">a = 1<br class="title-page-name"/>eax = a ➎<br class="title-page-name"/>b = a</pre>
<p class="calibre2">In the preceding program, the <kbd class="calibre13">eax</kbd> register is used to temporarily hold the value of <kbd class="calibre13">a</kbd>, so we can remove the entry at ➎ (that is remove the entry containing registers on the left side of the <kbd class="calibre13">=</kbd> sign). We are now left with the simplified code shown here:</p>
<pre class="calibre18">a = 1<br class="title-page-name"/>b = a</pre>
<p class="calibre2">In high-level languages, variables have data types. Let's try to determine the data types of these variables: <kbd class="calibre13">a</kbd> and <kbd class="calibre13">b</kbd>. Sometimes, it is possible to determine the data type by understanding how the variables are accessed and used. From the disassembled code, we know that the <kbd class="calibre13">dword</kbd> value (4 bytes) <kbd class="calibre13">1</kbd> was moved into the variable <kbd class="calibre13">a</kbd>, which was then copied to <kbd class="calibre13">b</kbd>. Now that we know these variables are 4 bytes in size, it means that they could be of the type <kbd class="calibre13">int</kbd>, <kbd class="calibre13">float</kbd>, or <kbd class="calibre13">pointer</kbd>.  To determine the exact data type, let's consider the following.</p>
<p class="calibre2">The variables <kbd class="calibre13">a</kbd> and <kbd class="calibre13">b</kbd> cannot be <kbd class="calibre13">float</kbd>, because, from the disassembled code, we know that <kbd class="calibre13">eax</kbd> was involved in the data transfer operation. If it was a floating point value, the floating point registers would have been used, instead of using a general purpose register such as <kbd class="calibre13">eax</kbd>.</p>
<p class="calibre2"><span class="calibre7">The variables </span><kbd class="calibre13">a</kbd><span class="calibre7"> and </span><kbd class="calibre13">b</kbd><span class="calibre7"> cannot be a <kbd class="calibre13">pointer</kbd> in this case, because the value <kbd class="calibre13">1</kbd> is not a valid address. So, we can guess that <kbd class="calibre13">a</kbd> and <kbd class="calibre13">b</kbd> should be of the type <kbd class="calibre13">int</kbd>.</span></p>
<p class="calibre2">Based on these observations, we can now rewrite the program as follows:</p>
<pre class="calibre18">int a;<br class="title-page-name"/>int b;<br class="title-page-name"/><br class="title-page-name"/>a = 1;<br class="title-page-name"/>b = a;</pre>
<p class="calibre2">Now that we have solved the challenge, let's look at the original C code snippet of the disassembled output. The original C code snippet is shown as follows. Compare it with what we determined. Notice how it was possible to build a program similar to the original program (it is not always possible to get the exact C program back), and also, it's now much easier to determine the functionality of the program:</p>
<pre class="calibre18">int x = 1;<br class="title-page-name"/>int y;<br class="title-page-name"/>y = x;</pre>
<p class="calibre2">If you are disassembling a bigger program, it would be hard to label all of the memory addresses. Typically, you will use the features of the disassembler or debugger to rename memory addresses and to perform code analysis. You will learn the features offered by the disassembler and how to use it for code analysis in the next chapter.  When you are dealing with bigger programs, it is a good idea to break the program into small blocks of code, translate it into some high-level language that you are familiar with, and then do the same thing for the rest of the blocks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4. Arithmetic Operations</h1>
                
            
            <article>
                
<p class="calibre2">You can perform addition, subtraction, multiplication, and division in assembly language. A addition and subtraction are performed using the <kbd class="calibre13">add</kbd> and <kbd class="calibre13">sub</kbd> instructions, respectively. These instructions take two operands: <em class="calibre17">destination</em> and <em class="calibre17">source</em>. The <kbd class="calibre13">add</kbd> instruction adds the source and destination and stores the result in the destination. The <kbd class="calibre13">sub</kbd> instruction subtracts the source from the destination operand, and the result is stored in the destination. These instructions set or clear flags in the <kbd class="calibre13">eflags</kbd> register, based on the operation. These flags can be used in the conditional statements. The <kbd class="calibre13">sub</kbd> instruction sets the zero flag, <kbd class="calibre13">(zf)</kbd>, if the result is zero, and the carry flag, <kbd class="calibre13">(cf)</kbd>, if the destination value is less than the source. The following outlines a few variations of these instructions:</p>
<pre class="calibre18">add eax,42      <em class="calibre19">; same as eax = eax+42</em><br class="title-page-name"/>add eax,ebx     <em class="calibre19">; same as eax = eax+ebx</em><br class="title-page-name"/>add [ebx],42    <em class="calibre19">; adds 42 to the value in address specified by ebx</em><br class="title-page-name"/>sub eax, 64h    <em class="calibre19">; subtracts hex value 0x64 from eax, same as eax = eax-0x64</em></pre>
<p class="calibre2">There is a special increment (<kbd class="calibre13">inc</kbd>) and decrement (<kbd class="calibre13">dec</kbd>) instruction, which can be used to add <kbd class="calibre13">1</kbd> or subtract <kbd class="calibre13">1</kbd> from either a register or a memory location:</p>
<pre class="calibre18">inc eax    <em class="calibre19">; same as eax = eax+1</em><br class="title-page-name"/>dec ebx    <em class="calibre19">; same as ebx = ebx-1</em></pre>
<p class="calibre2">Multiplication is done using the <kbd class="calibre13">mul</kbd> instruction. The <kbd class="calibre13">mul</kbd> instruction takes only one operand; that operand is multiplied by the content of either the <kbd class="calibre13">al</kbd>, <kbd class="calibre13">ax</kbd>, or <kbd class="calibre13">eax</kbd> register. The result of the multiplication is stored in either the <kbd class="calibre13">ax</kbd>, <kbd class="calibre13">dx and ax</kbd>, or <kbd class="calibre13">edx and eax</kbd> register.</p>
<p class="calibre2">If the operand of the <kbd class="calibre13">mul</kbd> instruction is <em class="calibre17">8 bits (1 byte)</em>, then it is multiplied by the 8-bit <kbd class="calibre13">al</kbd> register, and the product is stored in the <kbd class="calibre13">ax</kbd> register. If the operand is <em class="calibre17">16 bits (2 bytes)</em>, then it is multiplied with the <kbd class="calibre13">ax</kbd> register, and the product is stored in the <kbd class="calibre13">dx</kbd> and <kbd class="calibre13">ax</kbd> register. If the operand is a <em class="calibre17">32-bit (4 bytes)</em>, then it is multiplied with the <kbd class="calibre13">eax</kbd> register, and the product is stored in the <kbd class="calibre13">edx</kbd> and <kbd class="calibre13">eax</kbd> register. The reason the product is stored in a register double the size is because when two values are multiplied, the output values can be much larger than the input values. The following outlines variations of <kbd class="calibre13">mul</kbd> instructions:</p>
<pre class="calibre18">mul ebx  <em class="calibre19">;ebx is multiplied with eax and result is stored in EDX and EAX</em><br class="title-page-name"/>mul bx   <em class="calibre19">;bx is multiplied with ax and the result is stored in DX and AX</em></pre>
<p class="calibre2">Division is performed using the <kbd class="calibre13">div</kbd> instruction. The <kbd class="calibre13">div</kbd> takes only one operand, which can be either a register or a memory reference. To perform division, you place the dividend (number to divide) in the <kbd class="calibre13">edx and eax</kbd> register, with <kbd class="calibre13">edx</kbd> holding the most significant <em class="calibre17">dword</em>. After the <kbd class="calibre13">div</kbd> instruction is executed, the quotient is stored in <kbd class="calibre13">eax</kbd>, and the remainder is stored in the <kbd class="calibre13">edx</kbd> register:</p>
<pre class="calibre18">div ebx   <em class="calibre19">; divides the value in EDX:EAX by EBX</em></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4.1 Disassembly Challenge</h1>
                
            
            <article>
                
<p class="calibre2">Let's take on another simple challenge. The following is a disassembled output of a simple C program. Can you figure out what this program does, and can you translate it back to a pseudocode?</p>
<pre class="calibre18">mov dword ptr [ebp-4], 16h<br class="title-page-name"/>mov dword ptr [ebp-8], 5<br class="title-page-name"/>mov eax, [ebp-4]<br class="title-page-name"/>add eax, [ebp-8]<br class="title-page-name"/>mov [ebp-0Ch], eax<br class="title-page-name"/>mov ecx, [ebp-4]<br class="title-page-name"/>sub ecx, [ebp-8]<br class="title-page-name"/>mov [ebp-10h], ecx</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4.2 Disassembly Solution</h1>
                
            
            <article>
                
<p class="calibre2">You can read the code line by line and try to determine the program's logic, but it would be easier if you translate it back to some high-level language. To understand the preceding program, let's use the same logic that was covered previously. The preceding code contains four memory references. First, let's label these addresses - <kbd class="calibre13">ebp-4=a</kbd>, <kbd class="calibre13">ebp-8=b</kbd> , <kbd class="calibre13">ebp-0Ch=c</kbd>, and <kbd class="calibre13">ebp-10H=d</kbd>. After labeling the addresses, it translates to the following:</p>
<pre class="calibre18">mov dword ptr [a], 16h<br class="title-page-name"/>mov dword ptr [b], 5<br class="title-page-name"/>mov eax, [a]<br class="title-page-name"/>add eax, [b]<br class="title-page-name"/>mov [c], eax<br class="title-page-name"/>mov ecx, [a]<br class="title-page-name"/>sub ecx, [b]<br class="title-page-name"/>mov [d], ecx</pre>
<p class="calibre2">Now, let's translate the preceding code into a pseudocode (high-level language equivalent). The code will as follows:</p>
<pre class="calibre18">a = 16h    <em class="calibre19">; h represents hexadecmial, so 16h (0x16) is 22 in decimal</em><br class="title-page-name"/>b = 5<br class="title-page-name"/>eax = a<br class="title-page-name"/>eax = eax + b  ➊<br class="title-page-name"/>c = eax  ➊ <br class="title-page-name"/>ecx = a<br class="title-page-name"/>ecx = ecx-b  ➊<br class="title-page-name"/>d = ecx  ➊</pre>
<p class="calibre2">Replacing all of the register names with their corresponding values on the right-hand side of the <kbd class="calibre13">=</kbd> operator (in other words, at ➊), we get the following code:</p>
<pre class="calibre18">a = 22<br class="title-page-name"/>b = 5<br class="title-page-name"/>eax = a  ➋<br class="title-page-name"/>eax = a+b  ➋<br class="title-page-name"/>c = a+b<br class="title-page-name"/>ecx = a  ➋<br class="title-page-name"/>ecx = a-b  ➋<br class="title-page-name"/>d = a-b</pre>
<p class="calibre2">After removing all of the entries containing registers on the left-hand side of the <kbd class="calibre13">=</kbd> sign at ➋ (because registers are used for temporary calculations), we are left with the following code:</p>
<pre class="calibre18">a = 22<br class="title-page-name"/>b = 5<br class="title-page-name"/>c = a+b<br class="title-page-name"/>d = a-b</pre>
<p class="calibre2">Now, we have reduced the eight lines of assembly code to four lines of pseudocode. At this point, you can tell that the code performs addition and subtraction operations and stores the results. You can determine the variable types based on the sizes and how they are used in the code (context), as mentioned earlier. The variables <kbd class="calibre13">a</kbd> and <kbd class="calibre13">b</kbd> are used in addition and subtraction, so these variables have to be of integer data types, and the variables <kbd class="calibre13">c</kbd> and <kbd class="calibre13">d</kbd> store the results of integer addition and subtraction, so it can be guessed that they are also integer types. Now, the preceding code can be written as follows:</p>
<pre class="calibre18">int a,b,c,d;<br class="title-page-name"/>a = 22;<br class="title-page-name"/>b = 5;<br class="title-page-name"/>c = a+b;<br class="title-page-name"/>d = a-b;</pre>
<p class="calibre2">If you are curious about how the original C program of the disassembled output looks, then the following is the original C program to satisfy your curiosity. Notice how we were able to write an assembly code back to its equivalent high-level language:</p>
<pre class="calibre18">int num1 = 22;<br class="title-page-name"/>int num2 = 5;<br class="title-page-name"/>int diff;<br class="title-page-name"/>int sum;<br class="title-page-name"/>sum = num1 + num2;<br class="title-page-name"/>diff = num1 - num2;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">5. Bitwise Operations</h1>
                
            
            <article>
                
<p class="calibre2">In this section, you will learn the assembly instructions that operate on the bits. The bits are numbered starting from the far right; the <em class="calibre17">rightmost bit (least significant bit)</em> has a bit position of <kbd class="calibre13">0</kbd>, and the bit position increases toward the left. The left-most bit is called the <em class="calibre17">most significant bit</em>. The following is an example showing the bits and the bit positions for a byte, <kbd class="calibre13">5D (0101 1101)</kbd>. The same logic applies to a <kbd class="calibre13">word</kbd>, <kbd class="calibre13">dword</kbd>, and <kbd class="calibre13">qword</kbd>:</p>
<div class="cdpaligncenter"><img src="../images/00079.jpeg" class="calibre78"/></div>
<p class="calibre2">One of the bitwise instructions is the <kbd class="calibre13">not</kbd> instruction; it takes only one operand (which serves as both the source and destination) and inverts all of the bits. If <kbd class="calibre13">eax</kbd> contained <kbd class="calibre13">FF FF 00 00 (11111111 11111111 00000000 00000000)</kbd>, then the following instruction would invert all of the bits and store it in the <kbd class="calibre13">eax</kbd> register. As a result, the <kbd class="calibre13">eax</kbd> would contain <kbd class="calibre13">00 00 FF FF (00000000 00000000 11111111 11111111)</kbd>:</p>
<pre class="calibre18">not eax</pre>
<p class="calibre2">The <kbd class="calibre13">and</kbd>, <kbd class="calibre13">or</kbd>, and <kbd class="calibre13">xor</kbd> instructions perform bitwise <kbd class="calibre13">and</kbd>, <kbd class="calibre13">or</kbd>, and <kbd class="calibre13">xor</kbd> operations and store the results in the destination. These operations are similar to <kbd class="calibre13">and (&amp;)</kbd>, <kbd class="calibre13">or (|)</kbd>, and <kbd class="calibre13">xor (^)</kbd> operations in the C or Python programming languages. In the following example, the <kbd class="calibre13">and</kbd> operation is performed on bit <kbd class="calibre13">0</kbd> of the <kbd class="calibre13">bl</kbd> register and the bit <kbd class="calibre13">0</kbd> of <kbd class="calibre13">cl</kbd>, bit <kbd class="calibre13">1</kbd> of <kbd class="calibre13">bl</kbd> and the bit <kbd class="calibre13">1</kbd> of <kbd class="calibre13">cl</kbd>, and so on. The result is stored in the <kbd class="calibre13">bl</kbd> register:</p>
<pre class="calibre18">and bl,cl  <em class="calibre19">; same as bl = bl &amp; cl</em></pre>
<p class="calibre2">In the preceding example, if <kbd class="calibre13">bl</kbd> contained <kbd class="calibre13">5 (0000 0101)</kbd> and <kbd class="calibre13">cl</kbd> contained <kbd class="calibre13">6 (0000 0110)</kbd>, then the result of the <kbd class="calibre13">and</kbd> operation would be <kbd class="calibre13">4 (0000 0100)</kbd>, as shown here:</p>
<pre class="calibre18">                    bl: 0000 0101<br class="title-page-name"/>                    cl: 0000 0110<br class="title-page-name"/>--------------------------------------<br class="title-page-name"/>After and operation bl: 0000 0100</pre>
<p class="calibre2">Similarly, <kbd class="calibre13">or</kbd> and <kbd class="calibre13">xor</kbd> operations are performed on the corresponding bits of the operands. The following shows some of the example instructions:</p>
<pre class="calibre18">or eax,ebx   <em class="calibre19">; same as eax = eax | ebx</em><br class="title-page-name"/>xor eax,eax  <em class="calibre19">; same eax = eax^eax, this operation clears the eax register</em></pre>
<p class="calibre2">The <kbd class="calibre13">shr</kbd> (shift right) and <kbd class="calibre13">shl</kbd> (shift left) instructions take two operands (the destination and the count). The destination can be either a register or a memory reference. The general form is shown as follows. Both of the instructions shift the bits in the destination to the right or left by the number of bits specified by the count operand; these instructions perform the same operations as <kbd class="calibre13">shift left (&lt;&lt;)</kbd> and <kbd class="calibre13">shift right(&gt;&gt;)</kbd> in the C or Python programming languages:</p>
<pre class="calibre18">shl dst,count</pre>
<p class="calibre2">In the following example, the first instruction (<kbd class="calibre13">xor eax, eax</kbd>) clears the <kbd class="calibre13">eax</kbd> register, after which <kbd class="calibre13">4</kbd> is moved into the <kbd class="calibre13">al</kbd> register, and the content of the <kbd class="calibre13">al</kbd> register (which is <kbd class="calibre13">4 (0000 0100)</kbd>) is shifted left by <kbd class="calibre13">2</kbd> bits. As a result of this operation (the two left-most bits are removed, and the two <kbd class="calibre13">0</kbd> bits are appended to the right), after the operation the <kbd class="calibre13">al</kbd> register will contain <kbd class="calibre13">0001 0000</kbd> (which is <kbd class="calibre13">0x10</kbd>):</p>
<pre class="calibre18">xor eax,eax<br class="title-page-name"/>mov al,4 <br class="title-page-name"/>shl al, 2</pre>
<div class="packt_infobox">For detailed information on how bitwise operators work, refer to <a href="https://en.wikipedia.org/wiki/Bitwise_operations_in_C" class="calibre20">https://en.wikipedia.org/wiki/Bitwise_operations_in_C</a> and <a href="https://www.programiz.com/c-programming/bitwise-operators" class="calibre20">https://www.programiz.com/c-programming/bitwise-operators</a>.</div>
<div class="title-page-name">
<p class="calibre2">The <kbd class="calibre13">rol</kbd> (rotate left) and <kbd class="calibre13">ror</kbd> (rotate right) instructions are similar to shift instructions. Instead of removing the shifted bits, as with the shift operation, they are rotated to the other end. Some of the example instructions are shown here:</p>
<pre class="calibre18">rol al,2</pre>
<p class="calibre2">In the preceding example, if <kbd class="calibre13">al</kbd> contained <kbd class="calibre13">0x44 (0100 0100)</kbd>, then the result of the <kbd class="calibre13">rol</kbd> operation would be <kbd class="calibre13">0x11 (0001 0001)</kbd>. </p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6. Branching And Conditionals</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will focus on branching instructions. So far, you have seen instructions that execute sequentially; but many times, your program will need to execute code at a different memory address (like an <kbd class="calibre13">if/else</kbd> statement, looping, functions, and so on). This is achieved by using branching instructions. Branching instructions transfer the control of execution to a different memory address. To perform branching, jump instructions are typically used in the assembly language. There are two kinds of jumps: <em class="calibre17">conditional</em> and <em class="calibre17">unconditional</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6.1 Unconditional Jumps</h1>
                
            
            <article>
                
<p class="calibre2">In an <em class="calibre17">unconditional</em> jump, the jump is always taken. The <kbd class="calibre13">jmp</kbd> instruction tells the CPU to execute code at a different memory address. This is similar to the <kbd class="calibre13">goto</kbd> statement in the C programming language. When the following instruction is executed, the control is transferred to the jump address, and the execution starts from there:</p>
<pre class="calibre18">jmp &lt;jump address&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6.2 Conditional Jumps</h1>
                
            
            <article>
                
<p class="calibre2">In <em class="calibre17">conditional</em> jumps, the control is transferred to a memory address based on some condition. To use a conditional jump, you need instructions that can alter the flags (<em class="calibre17">set</em> or <em class="calibre17">clear</em>). These instructions can be performing an <em class="calibre17">arithmetic</em> operation or a <em class="calibre17">bitwise</em> operation. The x86 instruction provides the <kbd class="calibre13">cmp</kbd> instruction, which subtracts the <em class="calibre17">second operand (source operand)</em> from the <em class="calibre17">first operand (destination operation)</em> and alters the flags without storing the difference in the destination. In the following instruction, if the <kbd class="calibre13">eax</kbd> contained the value <kbd class="calibre13">5</kbd>, then <kbd class="calibre13">cmp eax,5</kbd> would set the zero flag (<kbd class="calibre13">zf=1</kbd>), because the result of this operation is zero:</p>
<pre class="calibre18">cmp eax,5  <em class="calibre19">; subtracts eax from 5, sets the flags but result is not stored</em></pre>
<p class="calibre2">Another instruction that alters the flags without storing the result is the <kbd class="calibre13">test</kbd> instruction. The <kbd class="calibre13">test</kbd> instruction performs a bitwise <kbd class="calibre13">and</kbd> operation and alters the flags without storing the result. In the following instruction, if the value of <kbd class="calibre13">eax</kbd> was zero, then the zero flag would be set (<kbd class="calibre13">zf=1</kbd>), because when you <kbd class="calibre13">and</kbd> <kbd class="calibre13">0</kbd> with <kbd class="calibre13">0</kbd> you get <kbd class="calibre13">0</kbd>:</p>
<pre class="calibre18">test eax,eax <em class="calibre19">; performs and operation, alters the flags but result in not stored</em></pre>
<p class="calibre2">Both <kbd class="calibre13">cmp</kbd> and <kbd class="calibre13">test</kbd> instructions are normally used along with the conditional <kbd class="calibre13">jump</kbd> instruction for decision making. </p>
<p class="calibre2">There are a few variations of conditional jump instructions; the general format is shown here:</p>
<pre class="calibre18">jcc &lt;address&gt;</pre>
<p class="calibre2">The <kbd class="calibre13">cc</kbd> in the preceding format represents conditions. These conditions are evaluated based on the bits in the <kbd class="calibre13">eflags</kbd> register. The following table outlines the different conditional jump instructions, their aliases, and the bits used in the <kbd class="calibre13">eflags</kbd> register to evaluate the condition:</p>
<table border="1" class="calibre46">
<tbody class="calibre47">
<tr class="calibre48">
<td class="calibre79">Instruction</td>
<td class="calibre80">Description</td>
<td class="calibre81">Aliases</td>
<td class="calibre82">Flags</td>
</tr>
<tr class="calibre48">
<td class="calibre79"><kbd class="calibre13">jz</kbd></td>
<td class="calibre80">jump if zero</td>
<td class="calibre81"><kbd class="calibre13">je</kbd></td>
<td class="calibre82"><kbd class="calibre13">zf=1</kbd></td>
</tr>
<tr class="calibre48">
<td class="calibre79"><kbd class="calibre13">jnz</kbd></td>
<td class="calibre80">jump if not zero</td>
<td class="calibre81"><kbd class="calibre13">jne</kbd></td>
<td class="calibre82"><kbd class="calibre13">zf=0</kbd></td>
</tr>
<tr class="calibre48">
<td class="calibre79"><kbd class="calibre13">jl</kbd></td>
<td class="calibre80">jump if less</td>
<td class="calibre81"><kbd class="calibre13">jnge</kbd></td>
<td class="calibre82"><kbd class="calibre13">sf=1</kbd></td>
</tr>
<tr class="calibre48">
<td class="calibre79"><kbd class="calibre13">jle</kbd></td>
<td class="calibre80">jump if less or equal</td>
<td class="calibre81"><kbd class="calibre13">jng</kbd></td>
<td class="calibre82"><kbd class="calibre13">zf=1 or sf=1</kbd></td>
</tr>
<tr class="calibre48">
<td class="calibre79"><kbd class="calibre13">jg</kbd></td>
<td class="calibre80">jump if greater</td>
<td class="calibre81"><kbd class="calibre13">jnle</kbd></td>
<td class="calibre82"><kbd class="calibre13">zf=0 and sf=0</kbd></td>
</tr>
<tr class="calibre48">
<td class="calibre79"><kbd class="calibre13">jge</kbd></td>
<td class="calibre80">jump if greater or equal </td>
<td class="calibre81"><kbd class="calibre13">jnl</kbd></td>
<td class="calibre82"><kbd class="calibre13">sf=0</kbd></td>
</tr>
<tr class="calibre48">
<td class="calibre79"><kbd class="calibre13">jc</kbd></td>
<td class="calibre80">jump if carry</td>
<td class="calibre81"><kbd class="calibre13">jb,jnae</kbd></td>
<td class="calibre82"><kbd class="calibre13">cf=1</kbd></td>
</tr>
<tr class="calibre48">
<td class="calibre79"><kbd class="calibre13">jnc</kbd></td>
<td class="calibre80">jump if not carry</td>
<td class="calibre81"><kbd class="calibre13">jnb,jae</kbd></td>
<td class="calibre82"><kbd class="calibre13"> .</kbd></td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6.3 If Statement</h1>
                
            
            <article>
                
<p class="calibre2">From a reverse engineering perspective, it is important to identify the branching/conditional statements. To do that, it is essential to understand how branching/conditional statements (like <kbd class="calibre13">if, if-else</kbd> and <kbd class="calibre13">if-else if-else</kbd>) are translated into assembly language. Let's look at an example of a simple C program and try to understand how the <kbd class="calibre13">if</kbd> statement is implemented at the assembly level:</p>
<pre class="calibre18">if (x == 0) {<br class="title-page-name"/>   x = 5;<br class="title-page-name"/>}<br class="title-page-name"/>x = 2;</pre>
<p class="calibre2">In the preceding C program, if the condition is true (<kbd class="calibre13">if x==0</kbd>), the code inside the <kbd class="calibre13">if</kbd> block is executed; otherwise, it will skip the <kbd class="calibre13">if</kbd> block and control is transferred to <kbd class="calibre13">x=2</kbd>. Think of a <em class="calibre17">control transfer</em> as a <em class="calibre17">jump</em>. Now, ask yourself: When will the jump be taken? The jump will be taken when <kbd class="calibre13">x</kbd> is not equal to <kbd class="calibre13">0</kbd>. That's exactly how the preceding code is implemented in assembly language (shown as follows); notice that in the first assembly instruction, the <kbd class="calibre13">x</kbd> is compared with <kbd class="calibre13">0</kbd>, and in the second instruction, the jump will be taken to <kbd class="calibre13">end_if</kbd> when <kbd class="calibre13">x</kbd> is not equal to <kbd class="calibre13">0</kbd> (in other words, it will skip <kbd class="calibre13">mov dword ptr [x],5</kbd> and execute <kbd class="calibre13">mov dword, ptr[x],2</kbd>). Notice how the equal to condition (<kbd class="calibre13">==</kbd>) in the C program was reversed to <kbd class="calibre13">not equal to</kbd> (<kbd class="calibre13">jne</kbd>) in the assembly language:</p>
<pre class="calibre18">cmp dword ptr [x], 0<br class="title-page-name"/>jne end_if<br class="title-page-name"/>mov dword ptr [x], 5<br class="title-page-name"/><br class="title-page-name"/>end_if:<br class="title-page-name"/>mov dword ptr [x], 2</pre>
<p class="calibre2">The following screenshot shows the C programming statements and the corresponding assembly instructions:</p>
<div class="cdpaligncenter"><img src="../images/00080.gif" class="calibre83"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6.4 If-Else Statement</h1>
                
            
            <article>
                
<p class="calibre2">Now, let's try to understand how the <kbd class="calibre13">if/else</kbd> statement is translated to assembly language. Let's take an example of the following C code:</p>
<pre class="calibre18">if (x == 0) {<br class="title-page-name"/>    x = 5;<br class="title-page-name"/>}<br class="title-page-name"/>else {<br class="title-page-name"/>    x = 1;<br class="title-page-name"/>}</pre>
<p class="calibre2">In the preceding code, try to determine under what circumstances the jump would be taken (control would be transferred). There are two circumstances: the jump will be taken to the <kbd class="calibre13">else</kbd> block if the <kbd class="calibre13">x</kbd> is not equal to <kbd class="calibre13">0</kbd>, or, if <kbd class="calibre13">x</kbd> is equal to <kbd class="calibre13">0</kbd> (<kbd class="calibre13">if x == 0</kbd>), then after the execution of <kbd class="calibre13">x=5</kbd> (the end of the <kbd class="calibre13">if</kbd> block), a jump will be taken to bypass the <kbd class="calibre13">else</kbd> block, to execute the code after the <kbd class="calibre13">else</kbd> block.</p>
<p class="calibre2">The following is the assembly translation of the C program; notice that in the first line, the value of <kbd class="calibre13">x</kbd> is compared with <kbd class="calibre13">0</kbd>, and the jump (conditional jump) will be taken to the <kbd class="calibre13">else</kbd> block if the <kbd class="calibre13">x</kbd> is not equal to <kbd class="calibre13">0</kbd> (the condition was reversed, as mentioned previously). Before the <kbd class="calibre13">else</kbd> block, notice the unconditional jump to <kbd class="calibre13">end</kbd>. This jump ensures that if <kbd class="calibre13">x</kbd> is equal to <kbd class="calibre13">0</kbd>, after executing the code inside of the <kbd class="calibre13">if</kbd> block, the <kbd class="calibre13">else</kbd> block is skipped and the control reaches the end:</p>
<pre class="calibre18">cmp dword ptr [x], 0<br class="title-page-name"/>jne else<br class="title-page-name"/>mov dword ptr [x], 5<br class="title-page-name"/>jmp end<br class="title-page-name"/><br class="title-page-name"/>else:<br class="title-page-name"/>mov dword ptr [x], 1<br class="title-page-name"/><br class="title-page-name"/>end:</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6.5 If-Elseif-Else Statement</h1>
                
            
            <article>
                
<p class="calibre2">The following is a C code containing <kbd class="calibre13">if-ElseIf-else</kbd> statements:</p>
<pre class="calibre18">if (x == 0) {<br class="title-page-name"/>  x = 5;<br class="title-page-name"/>}<br class="title-page-name"/>else if (x == 1) {<br class="title-page-name"/>  x = 6;<br class="title-page-name"/>}<br class="title-page-name"/>else {<br class="title-page-name"/>  x = 7;<br class="title-page-name"/>}</pre>
<p class="calibre2">From the preceding code, let's try to determine a situation when jumps (control transfers) will be taken. There are two conditional jump points; if <kbd class="calibre13">x</kbd> is not equal to <kbd class="calibre13">0</kbd>, it will jump to the <kbd class="calibre13">else_if</kbd> block, and if <kbd class="calibre13">x</kbd> is not equal to <kbd class="calibre13">1</kbd> (a condition check in <kbd class="calibre13">else if</kbd>), then the jump is taken to <kbd class="calibre13">else</kbd>. There are also two unconditional jumps: inside the <kbd class="calibre13">if</kbd> block after <kbd class="calibre13">x=5</kbd> (the end of the <kbd class="calibre13">if</kbd> block) and inside of the <kbd class="calibre13">else if</kbd> after <kbd class="calibre13">x=6</kbd> (the end of the <kbd class="calibre13">else if</kbd> block). Both of these unconditional jumps skip the <kbd class="calibre13">else</kbd> statement to reach the end.</p>
<p class="calibre2">The following is the translated assembly language showing the conditional and unconditional jumps:</p>
<pre class="calibre18">cmp dword ptr [ebp-4], 0<br class="title-page-name"/>jnz else_if<br class="title-page-name"/>mov dword ptr [ebp-4], 5<br class="title-page-name"/>jmp short end<br class="title-page-name"/><br class="title-page-name"/>else_if:<br class="title-page-name"/> cmp dword ptr [ebp-4], 1<br class="title-page-name"/> jnz else<br class="title-page-name"/> mov dword ptr [ebp-4], 6<br class="title-page-name"/> jmp short end<br class="title-page-name"/><br class="title-page-name"/>else:<br class="title-page-name"/> mov dword ptr [ebp-4], 7<br class="title-page-name"/>end:</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6.6 Disassembly Challenge</h1>
                
            
            <article>
                
<p class="calibre2">The following is the disassembled output of a program; let's translate the following code to its high-level equivalent. Use the techniques and the concepts that you learned previously to solve this challenge:</p>
<pre class="calibre18">mov dword ptr [ebp-4], 1<br class="title-page-name"/>cmp dword ptr [ebp-4], 0<br class="title-page-name"/>jnz loc_40101C<br class="title-page-name"/>mov eax, [ebp-4]<br class="title-page-name"/>xor eax, 2<br class="title-page-name"/>mov [ebp-4], eax<br class="title-page-name"/>jmp loc_401025<br class="title-page-name"/><br class="title-page-name"/>loc_40101C:<br class="title-page-name"/> mov ecx, [ebp-4]<br class="title-page-name"/> xor ecx, 3<br class="title-page-name"/> mov [ebp-4], ecx<br class="title-page-name"/><br class="title-page-name"/>loc_401025:</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6.7 Disassembly Solution</h1>
                
            
            <article>
                
<p class="calibre2">Let's start by assigning the symbolic names to the address (<kbd class="calibre13">ebp-4</kbd>). After assigning the symbolic names to the memory address references, we get the following code:</p>
<pre class="calibre18">mov dword ptr [x], 1<br class="title-page-name"/>cmp dword ptr [x], 0  ➊<br class="title-page-name"/>jnz loc_40101C  ➋<br class="title-page-name"/>mov eax, [x]  ➍<br class="title-page-name"/>xor eax, 2<br class="title-page-name"/>mov [x], eax<br class="title-page-name"/>jmp loc_401025  ➌<br class="title-page-name"/><br class="title-page-name"/>loc_40101C:  <br class="title-page-name"/>mov ecx, [x]  ➎<br class="title-page-name"/>xor ecx, 3  <br class="title-page-name"/>mov [x], ecx   ➏  <br class="title-page-name"/><br class="title-page-name"/>loc_401025:<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">In the preceding code, notice the <kbd class="calibre13">cmp</kbd> and <kbd class="calibre13">jnz</kbd> instructions at ➊ and<span class="calibre7"> ➋</span><span class="calibre7"> (this is a conditional statement) and note that</span> <kbd class="calibre13">jnz</kbd> <span class="calibre7">is the same as</span> <kbd class="calibre13">jne</kbd> <span class="calibre7">(<kbd class="calibre13">jump if not equal to</kbd>). Now that we have identified the conditional statement, let's try to determine what type of conditional statement</span> <span class="calibre7">this is (<kbd class="calibre13">if</kbd>, or <kbd class="calibre13">if/else</kbd>, or <kbd class="calibre13">if/else if/else</kbd>, and so on); to do that, focus on the jumps. The conditional jump at ➋ is taken to</span> <kbd class="calibre13">loc_401010C</kbd>, <span class="calibre7">and before the</span> <kbd class="calibre13">loc_40101C</kbd>, <span class="calibre7">there is an unconditional jump at ➌ to</span> <kbd class="calibre13">loc_401025</kbd><span class="calibre7">. From what we learned previously, this has the characteristics of</span> an <kbd class="calibre13">if-else</kbd> <span class="calibre7">statement. To be precise, the code from ➍ to ➌ is part of the</span> <kbd class="calibre13">if</kbd> <span class="calibre7">block and the code from ➎ to ➏ is part of the</span> <kbd class="calibre13">else</kbd> <span class="calibre7">block. Let's rename</span> <kbd class="calibre13">loc_40101C</kbd> <span class="calibre7">to</span> <kbd class="calibre13">else</kbd> <span class="calibre7">and</span> <kbd class="calibre13">loc_401025</kbd> <span class="calibre7">to</span> <kbd class="calibre13">end</kbd> for better readability<span class="calibre7">:</span></p>
<pre class="calibre18">mov dword ptr [x], 1  ➐<br class="title-page-name"/>cmp dword ptr [x], 0  ➊<br class="title-page-name"/>jnz else  ➋<br class="title-page-name"/>mov eax, [x]  ➍<br class="title-page-name"/>xor eax, 2<br class="title-page-name"/>mov [x], eax  ➑<br class="title-page-name"/>jmp end  ➌<br class="title-page-name"/><br class="title-page-name"/>else:<br class="title-page-name"/>mov ecx, [x]  ➎<br class="title-page-name"/>xor ecx, 3<br class="title-page-name"/>mov [x], ecx  ➏<br class="title-page-name"/>end:</pre>
<p class="calibre2">In the preceding assembly code, <kbd class="calibre13">x</kbd> is assigned a value of <kbd class="calibre13">1</kbd> at ➐; the value of <kbd class="calibre13">x</kbd> is compared with <kbd class="calibre13">0</kbd>, and if it is equal to <kbd class="calibre13">0</kbd> (➊ and ➋), the value of <kbd class="calibre13">x</kbd> is <kbd class="calibre13">xor</kbd> with <kbd class="calibre13">2</kbd>, and the result is stored in <kbd class="calibre13">x</kbd> (➍ to ➑). If <kbd class="calibre13">x</kbd> is not equal to <kbd class="calibre13">0</kbd>, then the value of <kbd class="calibre13">x</kbd> is <kbd class="calibre13">xor</kbd> with <kbd class="calibre13">3</kbd> (➎ to ➏).</p>
<p class="calibre2">Reading the assembly code is slightly tricky, so let's write the preceding code in a high-level language equivalent. We know that ➊ and ➋ is an <kbd class="calibre13">if</kbd> statement, and you can read it as <kbd class="calibre13">jump is taken to else, if x is not equal to 0</kbd> (remember <kbd class="calibre13">jnz</kbd> is an alias for <kbd class="calibre13">jne</kbd>).</p>
<p class="calibre2">If you recall, looking at how the C code was translated to assembly, the condition in the <kbd class="calibre13">if</kbd> statement was reversed when translated to assembly code. Since we are now looking at the assembly code, to write these statements back to a high-level language, you need to reverse the condition. To do that, ask yourself this question,  at <span class="calibre7">➋, </span>when will the jump not be taken?. The jump will not be taken when <kbd class="calibre13">x</kbd> is equal to <kbd class="calibre13">0</kbd>, so you can write the preceding code to a pseudocode, as follows. Note that in the following code, the <kbd class="calibre13">cmp</kbd> and <kbd class="calibre13">jnz</kbd> instruction is translated to an <kbd class="calibre13">if</kbd> statement; also, note how the condition is reversed:</p>
<pre class="calibre18">x = 1<br class="title-page-name"/>if(x == 0)<br class="title-page-name"/>{<br class="title-page-name"/>  eax = x<br class="title-page-name"/>  eax = eax ^ 2  ➒<br class="title-page-name"/>  x = eax  ➒<br class="title-page-name"/>} <br class="title-page-name"/>else {<br class="title-page-name"/> ecx = x<br class="title-page-name"/> ecx = ecx ^ 3  ➒<br class="title-page-name"/> x = ecx  ➒<br class="title-page-name"/>}</pre>
<p class="calibre2">Now that we have identified the conditional statements, next let's replace all of the registers on the right-hand side of the <kbd class="calibre13">=</kbd> operator (at ➒) with their corresponding values. After doing that, we get the following code:</p>
<pre class="calibre18">x = 1<br class="title-page-name"/>if(x == 0)<br class="title-page-name"/>{<br class="title-page-name"/>  eax = x  ➓<br class="title-page-name"/>  eax = x ^ 2  ➓<br class="title-page-name"/>  x = x ^ 2<br class="title-page-name"/>} <br class="title-page-name"/>else {<br class="title-page-name"/>  ecx = x  ➓<br class="title-page-name"/>  ecx = x ^ 3  ➓<br class="title-page-name"/>  x = x ^ 3<br class="title-page-name"/>}</pre>
<p class="calibre2">Removing all of the entries containing the registers on the left-hand side of the <kbd class="calibre13">=</kbd> operator (at ➓), we get the following code:</p>
<pre class="calibre18">x = 1;<br class="title-page-name"/>if(x == 0)<br class="title-page-name"/>{<br class="title-page-name"/>  x = x ^ 2;<br class="title-page-name"/>} <br class="title-page-name"/>else {<br class="title-page-name"/>  x = x ^ 3;<br class="title-page-name"/>}</pre>
<p class="calibre2">If you are curious, the following is the original C program of the disassembled output used in the disassembly challenge; compare it with what we got in the preceding code snippet. As you can see, we were able to reduce multiple lines of assembly code back to their high-level language equivalent. Now, the code is much easier to understand, as compared to reading the assembly code:</p>
<pre class="calibre18">int a = 1;<br class="title-page-name"/>if (a == 0) <br class="title-page-name"/>{<br class="title-page-name"/>    a = a ^ 2;<br class="title-page-name"/>}<br class="title-page-name"/>else {<br class="title-page-name"/>    a = a ^ 3;<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">7. Loops</h1>
                
            
            <article>
                
<p class="calibre2">Loops execute a block of code until some condition is met. The two most common types of loops are <kbd class="calibre13">for</kbd> and <kbd class="calibre13">while</kbd>. The jumps and conditional jumps that you have seen so far have been jumping forward. The loops jump backward. First, let's understand the functionality of a <kbd class="calibre13">for</kbd> loop. The general form of a <kbd class="calibre13">for</kbd> loop is shown here:</p>
<pre class="calibre18">for (initialization; condition; update_statement ) {<br class="title-page-name"/>    block of code<br class="title-page-name"/>}</pre>
<p class="calibre2">Here's how the <kbd class="calibre13">for</kbd> statement works. The <kbd class="calibre13">initialization</kbd> statement is executed only once, after which the <kbd class="calibre13">condition</kbd> is evaluated; if the condition is true, the block of code inside the <kbd class="calibre13">for</kbd> loop is executed, and then the <kbd class="calibre13">update_statement</kbd> is executed.</p>
<p class="calibre2">A <kbd class="calibre13">while</kbd> loop is the same as a <kbd class="calibre13">for</kbd> loop. In <kbd class="calibre13">for</kbd>, the <kbd class="calibre13">initialization</kbd>, <kbd class="calibre13">condition</kbd>, and <kbd class="calibre13">update_statment</kbd> are specified together, whereas in a <kbd class="calibre13">while</kbd> loop, the <kbd class="calibre13">initialization</kbd> is kept separate from the <kbd class="calibre13">condition</kbd> check, and the <kbd class="calibre13">update_statement</kbd> is specified inside the loop. The general form of a <kbd class="calibre13">while</kbd> loop is shown here:</p>
<pre class="calibre18">initialization<br class="title-page-name"/>while (condition)<br class="title-page-name"/>{<br class="title-page-name"/>    block of code<br class="title-page-name"/>    update_statement<br class="title-page-name"/>}</pre>
<p class="calibre2">Let's try to understand how the loop is implemented at the assembly level with the help of the following code snippet from a simple C program:</p>
<pre class="calibre18">int i;<br class="title-page-name"/>for (i = 0; i &lt; 5; i++) {<br class="title-page-name"/>}</pre>
<p class="calibre2">The preceding code can be written using a <kbd class="calibre13">while</kbd> loop, as shown here:</p>
<pre class="calibre18">int i = 0;<br class="title-page-name"/>while (i &lt; 5) { <br class="title-page-name"/>    i++;<br class="title-page-name"/>}</pre>
<p class="calibre2">We know that a jump is used to implement conditionals and loops, so let's think in terms of jumps. In the <kbd class="calibre13">while</kbd> and <kbd class="calibre13">for</kbd> loops, let's try to determine all the situations when the jumps will be taken. In both cases, when <kbd class="calibre13">i</kbd> becomes greater than or equal to <kbd class="calibre13">5</kbd>, a jump will be taken, which will transfer the control outside of the loop (in other words, after the loop). When <kbd class="calibre13">i</kbd> is less than <kbd class="calibre13">5</kbd>, the code inside the <kbd class="calibre13">while</kbd> loop is executed and <span class="calibre7">after </span><kbd class="calibre13">i++</kbd> backward jump will be taken, to check the condition.</p>
<p class="calibre2">This is how the preceding code is implemented in assembly language (shown as follows). In the following assembly code, at ➊, notice a backward jump to an address (labeled as <kbd class="calibre13">while_start</kbd>); this indicates a loop. Inside of the loop, the condition is checked at ➋ and ➌ by using <kbd class="calibre13">cmp</kbd> and <kbd class="calibre13">jge</kbd> (jump if greater than or equal to) instructions; here, the code is checking if <kbd class="calibre13">i</kbd> is greater than or equal to <kbd class="calibre13">5</kbd>. If this condition is met, then the jump is taken to <kbd class="calibre13">end</kbd> (outside of the loop). Notice how the <kbd class="calibre13">less than</kbd> (<kbd class="calibre13">&lt;</kbd>) condition in C programming is reversed to <kbd class="calibre13">greater than or equal to</kbd> (<kbd class="calibre13">&gt;=</kbd>) at ➌, using the <kbd class="calibre13">jge</kbd> instruction. The initialization is performed at ➍, where <kbd class="calibre13">i</kbd> is assigned the value of <kbd class="calibre13">0</kbd>:</p>
<pre class="calibre18">  mov [i],0  ➍<br class="title-page-name"/><br class="title-page-name"/>while_start:<br class="title-page-name"/>  cmp [i], 5  ➋<br class="title-page-name"/>  jge end  ➌<br class="title-page-name"/>  mov eax, [i]<br class="title-page-name"/>  add eax, 1<br class="title-page-name"/>  mov [i], eax<br class="title-page-name"/>  jmp while_start  ➊<br class="title-page-name"/>end:</pre>
<p class="calibre2">The following diagram shows the C programming statements and the corresponding assembly instructions:</p>
<div class="cdpaligncenter"><img src="../images/00081.gif" class="calibre84"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">7.1 Disassembly Challenge</h1>
                
            
            <article>
                
<p class="calibre2">Let's translate the following code into its high-level equivalent. Use the techniques and the concepts that you have learned so far to solve this challenge:</p>
<pre class="calibre18"> mov dword ptr [ebp-8], 0<br class="title-page-name"/> mov dword ptr [ebp-4], 0<br class="title-page-name"/><br class="title-page-name"/>loc_401014:<br class="title-page-name"/> cmp dword ptr [ebp-4], 4<br class="title-page-name"/> cmp dword ptr [ebp-4], 4<br class="title-page-name"/> jge loc_40102E<br class="title-page-name"/> mov eax, [ebp-8]<br class="title-page-name"/> add eax, [ebp-4]<br class="title-page-name"/> mov [ebp-8], eax<br class="title-page-name"/> mov ecx, [ebp-4]<br class="title-page-name"/> add ecx, 1<br class="title-page-name"/> mov [ebp-4], ecx<br class="title-page-name"/> jmp loc_401014<br class="title-page-name"/><br class="title-page-name"/>loc_40102E:</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">7.2 Disassembly Solution</h1>
                
            
            <article>
                
<p class="calibre2">The preceding code consists of two memory addresses (<kbd class="calibre13">ebp-4</kbd> and <kbd class="calibre13">ebp-8</kbd>); let's rename <kbd class="calibre13">ebp-4</kbd> to <kbd class="calibre13">x</kbd> and <kbd class="calibre13">ebp-8</kbd> to <kbd class="calibre13">y</kbd>. The modified code is shown here:</p>
<pre class="calibre18"> mov dword ptr [y], 1<br class="title-page-name"/> mov dword ptr [x], 0<br class="title-page-name"/><br class="title-page-name"/>loc_401014:<br class="title-page-name"/> cmp dword ptr [x], 4  ➋<br class="title-page-name"/> jge loc_40102E  ➌ <br class="title-page-name"/> mov eax, [y]<br class="title-page-name"/> add eax, [x]<br class="title-page-name"/> mov [y], eax<br class="title-page-name"/> mov ecx, [x]  ➎<br class="title-page-name"/> add ecx, 1<br class="title-page-name"/> mov [x], ecx  ➏<br class="title-page-name"/> jmp loc_401014 ➊ <br class="title-page-name"/><br class="title-page-name"/>loc_40102E:  ➍</pre>
<p class="calibre2">In the preceding code, at ➊, there is a backward jump to <kbd class="calibre13">loc_401014</kbd>, indicating a loop; so, let's rename <kbd class="calibre13">loc_401014</kbd> to <kbd class="calibre13">loop</kbd>. At ➋ and ➌, there is a condition check for the variable <kbd class="calibre13">x</kbd> (using <kbd class="calibre13">cmp</kbd> and <kbd class="calibre13">jge</kbd>); the code is checking whether <kbd class="calibre13">x</kbd> is greater than or equal to <kbd class="calibre13">4</kbd>. If the condition is met, it will jump outside of the loop to <kbd class="calibre13">loc_40102E</kbd> (at ➍). The value of <kbd class="calibre13">x</kbd> is incremented to <kbd class="calibre13">1</kbd> (from ➎ to<span class="calibre7"> ➏), which is the update statement. Based on all of this information, it can be deduced that</span> <kbd class="calibre13">x</kbd> <span class="calibre7">is the loop variable that controls the loop. Now, we can write the preceding code to a high-level language equivalent; but to do that, remember that we need to reverse the condition from</span> <kbd class="calibre13">jge</kbd>  (<kbd class="calibre13">jump if greater than or equal to</kbd>) <span class="calibre7">to</span> <kbd class="calibre13">jump if less than</kbd><span class="calibre7">. After the changes, the code looks as follows:</span></p>
<pre class="calibre18">y = 1<br class="title-page-name"/>x = 0<br class="title-page-name"/>while (x&lt;4) {<br class="title-page-name"/>eax = y<br class="title-page-name"/>eax = eax + x  ➐<br class="title-page-name"/>y = eax  ➐<br class="title-page-name"/>ecx = x<br class="title-page-name"/>ecx = ecx + 1  ➐<br class="title-page-name"/>x = ecx  ➐<br class="title-page-name"/>}</pre>
<p class="calibre2">Replacing all of the registers on the right-hand side of the <kbd class="calibre13">=</kbd> operator (at ➐) with their previous values, we get the following code:</p>
<pre class="calibre18">y = 1<br class="title-page-name"/>x = 0<br class="title-page-name"/>while (x&lt;4) {<br class="title-page-name"/>eax = y  ➑<br class="title-page-name"/>eax = y + x  ➑<br class="title-page-name"/>y = y + x<br class="title-page-name"/>ecx = x  ➑<br class="title-page-name"/>ecx = x + 1  ➑<br class="title-page-name"/>x = x + 1<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, removing all of the entries containing registers on the left-hand side of the <kbd class="calibre13">=</kbd> sign (at ➑<span class="calibre7">), we get the following code:</span></p>
<pre class="calibre18">y = 1;<br class="title-page-name"/>x = 0;<br class="title-page-name"/>while (x&lt;4) {<br class="title-page-name"/>y = y + x;<br class="title-page-name"/>x = x + 1;<br class="title-page-name"/>}</pre>
<p class="calibre2">If you are curious, the following is the original C program of the disassembled output. Compare the preceding code that we determined with the code that follows from the original program; notice how it was possible to reverse engineer and decompile the disassembled output to its original equivalent:</p>
<pre class="calibre18">int a = 1;<br class="title-page-name"/>int i = 0;<br class="title-page-name"/>while (i &lt; 4) {<br class="title-page-name"/>a = a + i;<br class="title-page-name"/>i++;<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">8. Functions</h1>
                
            
            <article>
                
<p class="calibre2">A function is a block of code that performs specific tasks; normally, a program contains many functions. When a function is called, the control is transferred to a different memory address. The CPU then executes the code at that memory address, and it comes back (control is transferred back) after it finishes running the code. The function contains multiple components: a function can take data as input via parameters, it has a body that contains the code it executes, it contains local variables that are used to temporarily store values, and it can output data.</p>
<p class="calibre2">The parameters, local variables, and function flow controls are all stored in an important area of the memory called the <em class="calibre17">stack</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">8.1 Stack</h1>
                
            
            <article>
                
<p class="calibre2">The stack is an area of the memory that gets allocated by the operating system when the thread is created. The stack is organized in a <em class="calibre17">Last-In-First-Out (LIFO)</em> structure, which means that the most recent data that you put in the stack will be the first one to be removed from the stack. You put data (called <em class="calibre17">pushing</em>) onto the stack by using the <kbd class="calibre13">push</kbd> instruction, and you remove data (called <em class="calibre17">popping</em>) from the stack using the <kbd class="calibre13">pop</kbd> instruction. The <kbd class="calibre13">push</kbd> instruction pushes a <em class="calibre17">4-byte</em> value onto the stack, and the <kbd class="calibre13">pop</kbd> instruction pops a <em class="calibre17">4-byte</em> value from the top of the stack. The general forms of the <kbd class="calibre13">push</kbd> and <kbd class="calibre13">pop</kbd> instructions are shown here:</p>
<pre class="calibre18">push source     ; pushes source on top of the stack<br class="title-page-name"/>pop destination ; copies value from the top of the stack to the destination</pre>
<p class="calibre2">The stack grows from higher addresses to lower addresses. This means when a stack is created, the <kbd class="calibre13">esp</kbd> register (also called the <em class="calibre17">stack pointer</em>) points to the top of the stack (higher address), and as you <kbd class="calibre13">push</kbd> data into the stack, the <kbd class="calibre13">esp</kbd> register decrements by <kbd class="calibre13">4</kbd> (<kbd class="calibre13">esp-4</kbd>) to a lower address. When you <kbd class="calibre13">pop</kbd> a value, the <kbd class="calibre13">esp</kbd> increments by <kbd class="calibre13">4</kbd> (<kbd class="calibre13">esp+4</kbd>). Let's look at the following assembly code and try to understand the inner workings of the stack:</p>
<pre class="calibre18">push 3<br class="title-page-name"/>push 4<br class="title-page-name"/>pop ebx<br class="title-page-name"/>pop edx</pre>
<p class="calibre2">Before executing the preceding instructions, the <kbd class="calibre13">esp</kbd> register points to the top of the stack (for example, at address <kbd class="calibre13">0xff8c</kbd>), as shown here:</p>
<div class="cdpaligncenter"><img src="../images/00082.gif" class="calibre85"/></div>
<p class="calibre2">After the first instruction is executed (<kbd class="calibre13">push 3</kbd>), <kbd class="calibre13">ESP</kbd> is decremented by <kbd class="calibre13">4</kbd> (because the <kbd class="calibre13">push</kbd> instruction pushes a <em class="calibre17">4-byte</em> value onto the stack), and the value <kbd class="calibre13">3</kbd> is placed on the stack; now, <kbd class="calibre13">ESP</kbd> points to the top of the stack at <kbd class="calibre13">0xff88</kbd>. After the second instruction (<kbd class="calibre13">push 4</kbd>), <kbd class="calibre13">esp</kbd> is decremented by <kbd class="calibre13">4</kbd>; now, <kbd class="calibre13">esp</kbd> contains <kbd class="calibre13">0xff84</kbd>, which is now the top of the stack. When <kbd class="calibre13">pop ebx</kbd> is executed, the value <kbd class="calibre13">4</kbd> from the top of the stack is moved to the <kbd class="calibre13">ebx</kbd> register, and <kbd class="calibre13">esp</kbd> is incremented by <kbd class="calibre13">4</kbd> (because <kbd class="calibre13">pop</kbd> removes a <em class="calibre17">4-byte</em> value from the stack). So, <kbd class="calibre13">esp</kbd> now points to the stack at <kbd class="calibre13">0xff88</kbd>. Similarly, when the <kbd class="calibre13">pop edx</kbd> instruction is executed, the value <kbd class="calibre13">3</kbd> from the top of the stack is placed in the <kbd class="calibre13">edx</kbd> register, and <kbd class="calibre13">esp</kbd> comes back to its original position at <kbd class="calibre13">0xff8c</kbd>:</p>
<div class="cdpaligncenter"><img src="../images/00083.gif" class="calibre86"/></div>
<p class="calibre2">In the preceding diagram, the values popped from the stack are physically still present in memory, even though they are logically removed. Also, notice how the most recently pushed value (<kbd class="calibre13">4</kbd>) was the first to be removed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">8.2 Calling Function</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre13">call</kbd> instruction in the assembly language can be used to call a function. The general form of the <kbd class="calibre13">call</kbd> looks as follows:</p>
<pre class="calibre18">call &lt;some_function&gt;</pre>
<p class="calibre2">From a code analysis perspective, think of <kbd class="calibre13">some_function</kbd> as an address containing a block of code. When the <kbd class="calibre13">call</kbd> instruction is executed, the control is transferred to <kbd class="calibre13">some_function</kbd> (a block of code), but before that, it stores the address of the next instruction (the instruction following <kbd class="calibre13">call &lt;some_function&gt;</kbd>) by pushing it onto the stack. The address following the <kbd class="calibre13">call</kbd> which is pushed onto the stack is called the <em class="calibre17">return address</em>. Once <kbd class="calibre13">some_function</kbd> finishes executing, the return address that was stored on the stack is popped from the stack, and the execution continues from the popped address.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">8.3 Returning From Function</h1>
                
            
            <article>
                
<p class="calibre2">In assembly language, to return from a function, you use the <kbd class="calibre13">ret</kbd> instruction. This instruction pops the address from the top of the stack; the popped address is placed in the <kbd class="calibre13">eip</kbd> register, and the control is transferred to the popped address.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">8.4 Function Parameters And Return Values</h1>
                
            
            <article>
                
<p class="calibre2">In the <kbd class="calibre13">x86</kbd> architecture, the parameters that a function accepts are pushed onto the stack, and the return value is placed in the <kbd class="calibre13">eax</kbd> register.</p>
<p class="calibre2">In order to understand the function, let's take an example of a simple C program. When the following program is executed, the <kbd class="calibre13">main()</kbd> function calls the <kbd class="calibre13">test</kbd> function and passes two integer arguments: <kbd class="calibre13">2</kbd> and <kbd class="calibre13">3</kbd>. Inside the <kbd class="calibre13">test</kbd> function, the value of arguments is copied to the local variables <kbd class="calibre13">x</kbd> and <kbd class="calibre13">y</kbd>, and the <kbd class="calibre13">test</kbd> returns a value of <kbd class="calibre13">0</kbd> (<kbd class="calibre13">return value</kbd>):</p>
<pre class="calibre18">int test(int a, int b)<br class="title-page-name"/>{ <br class="title-page-name"/>    int x, y; <br class="title-page-name"/>    x = a; <br class="title-page-name"/>    y = b;        <br class="title-page-name"/>    return 0;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>int main()<br class="title-page-name"/>{ <br class="title-page-name"/>   test(2, 3); <br class="title-page-name"/>   return 0; <br class="title-page-name"/>}</pre>
<p class="calibre2">First, let's see how the statements inside the <kbd class="calibre13">main()</kbd> function are translated into assembly instructions:</p>
<pre class="calibre18">push 3  ➊<br class="title-page-name"/>push 2  ➋<br class="title-page-name"/>call test  ➌<br class="title-page-name"/>add esp, 8 ; after test is exectued, the control is returned here<br class="title-page-name"/>xor eax, eax<strong class="calibre1"><br class="title-page-name"/></strong></pre>
<p class="calibre2">The first three instructions, ➊, ➋, and ➌, represent the function call <kbd class="calibre13">test(2,3)</kbd>. The arguments (<kbd class="calibre13">2</kbd> and <kbd class="calibre13">3</kbd>) are pushed onto the stack before the function call in the reverse order (from right to left), and the second argument, <kbd class="calibre13">3</kbd>, is pushed before the first argument, <kbd class="calibre13">2</kbd>. After pushing the arguments, the function, <kbd class="calibre13">test()</kbd>, is called at ➌; as a result, the address of the next instruction, <kbd class="calibre13">add esp,8</kbd>, is pushed onto the stack (this is the <em class="calibre17">return address</em>), and then the control is transferred to the start address of the <kbd class="calibre13">test</kbd> function. Let's assume that before executing the instructions ➊, ➋, ➌, the <kbd class="calibre13">esp</kbd> (stack pointer) was pointing to the top of the stack at the address <kbd class="calibre13">0xFE50</kbd>. The following diagram depicts what happens before and after executing  ➊, ➋, and ➌:</p>
<div class="cdpaligncenter"><img src="../images/00084.gif" class="calibre87"/></div>
<p class="calibre2">Now, let's focus on the <kbd class="calibre13">test</kbd> function, as shown here:</p>
<pre class="calibre18">int test(int a, int b)<br class="title-page-name"/>{ <br class="title-page-name"/>   int x, y; <br class="title-page-name"/>   x = a; <br class="title-page-name"/>   y = b;        <br class="title-page-name"/>   return 0;<br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre7">The following is the assembly translation of the <kbd class="calibre13">test</kbd> function:</span></p>
<pre class="calibre18">push ebp  ➍<br class="title-page-name"/>mov ebp, esp  ➎<br class="title-page-name"/>sub esp, 8  ➑<br class="title-page-name"/>mov eax, [ebp+8]<br class="title-page-name"/>mov [ebp-4], eax<br class="title-page-name"/>mov ecx, [ebp+0Ch]<br class="title-page-name"/>mov [ebp-8], ecx<br class="title-page-name"/>xor eax, eax  ➒<br class="title-page-name"/>mov esp, ebp  ➏<br class="title-page-name"/>pop ebp  ➐<br class="title-page-name"/>ret  ➓</pre>
<p class="calibre2">The first instruction ➍ saves the <kbd class="calibre13">ebp</kbd> (also called the <em class="calibre17">frame pointer</em>) on the stack; this is done so that it can be restored when the function returns. As a result of pushing the value of <kbd class="calibre13">ebp</kbd> onto the stack, the <kbd class="calibre13">esp</kbd> register will be decremented by <kbd class="calibre13">4</kbd>. In the next instruction, at ➎, the value of <kbd class="calibre13">esp</kbd> is copied into <kbd class="calibre13">ebp</kbd>; as a result, both <kbd class="calibre13">esp</kbd> and <kbd class="calibre13">ebp</kbd> point at the top of the stack, shown as follows. The <kbd class="calibre13">ebp</kbd> from now on will be kept at a fixed position, and the application will use <kbd class="calibre13">ebp</kbd> to reference function arguments and the local variables:</p>
<div class="cdpaligncenter"><img src="../images/00085.gif" class="calibre88"/></div>
<p class="calibre2">You will normally find <kbd class="calibre13">push ebp</kbd> and <kbd class="calibre13">mov ebp, esp</kbd> at the start of most functions; these two instructions are called <em class="calibre17">function prologue</em>. These instructions are responsible for setting up the environment for the function. At ➏ and ➐, the two instructions (<kbd class="calibre13">mov esp,ebp</kbd> and <kbd class="calibre13">pop ebp</kbd>) perform the reverse operation of <em class="calibre17">function prologue</em>. These instructions are called <em class="calibre17">function epilogue</em>, and they restore the environment after the function is executed.</p>
<p class="calibre2">At ➑, <kbd class="calibre13">sub esp,8</kbd> further decrements the <kbd class="calibre13">esp</kbd> register. This is done to allocate space for the local variables (<kbd class="calibre13">x</kbd> and <kbd class="calibre13">y</kbd>). Now, the stack looks as follows:</p>
<div class="cdpaligncenter"><img src="../images/00086.gif" class="calibre89"/></div>
<p class="calibre2">Notice that the <kbd class="calibre13">ebp</kbd> is still at a fixed position, and function arguments can be accessed at a positive offset from <kbd class="calibre13">ebp</kbd> (<kbd class="calibre13">ebp + some value</kbd>). The local variables can be accessed at a negative offset from <kbd class="calibre13">ebp</kbd> (<kbd class="calibre13">ebp - some value</kbd>). For example, in the preceding diagram, the first argument (<kbd class="calibre13">2</kbd>) can be accessed at the address <kbd class="calibre13">ebp+8</kbd> (which is the value of <kbd class="calibre13">a</kbd>), and the second argument can be accessed at the address <kbd class="calibre13">ebp+0xc</kbd> (which is the value of <kbd class="calibre13">b</kbd>). The local variables can be accessed at the addresses <kbd class="calibre13">ebp-4</kbd> (local variable <kbd class="calibre13">x</kbd>) and <kbd class="calibre13">ebp-8</kbd> (local variable <kbd class="calibre13">y</kbd>).</p>
<div class="packt_infobox">Most compilers (such as Microsoft Visual C/C++ compiler) make use of fixed <kbd class="calibre42">ebp</kbd> based stack frames to reference the function arguments and the local variables. The GNU compilers (such as gcc) do not use <kbd class="calibre42">ebp</kbd> based stack frames by default, but they make use of a different technique, where the <kbd class="calibre42">ESP</kbd> (stack pointer) register is used to reference the function parameters and local variables.</div>
<p class="calibre2">The actual code inside of the function is between ➑ and <span class="calibre7">➏</span>, which is shown here: </p>
<pre class="calibre18">mov eax, [ebp+8]<br class="title-page-name"/>mov [ebp-4], eax<br class="title-page-name"/>mov ecx, [ebp+0Ch]<br class="title-page-name"/>mov [ebp-8], ecx</pre>
<p class="calibre2"><span class="calibre7">We can rename the argument </span><kbd class="calibre13">ebp+8</kbd><span class="calibre7"> as </span><kbd class="calibre13">a</kbd><span class="calibre7"> and </span><kbd class="calibre13">ebp+0Ch</kbd><span class="calibre7"> as </span><kbd class="calibre13">b</kbd><span class="calibre7">. The address </span><kbd class="calibre13">ebp-4</kbd><span class="calibre7"> can be renamed as the variable </span><kbd class="calibre13">x</kbd><span class="calibre7">, and </span><kbd class="calibre13">ebp-8</kbd><span class="calibre7"> as the variable </span><kbd class="calibre13">y</kbd>, as shown here:</p>
<pre class="calibre18">mov eax, [a]<br class="title-page-name"/>mov [x], eax<br class="title-page-name"/>mov ecx, [b]<br class="title-page-name"/>mov [y], ecx</pre>
<p class="calibre2">Using the techniques covered previously, the preceding statements can be translated to the following pseudocode:</p>
<pre class="calibre18">x = a<br class="title-page-name"/>y = b</pre>
<p class="calibre2">At ➒, <kbd class="calibre13">xor eax,eax</kbd> sets the value of <kbd class="calibre13">eax</kbd> to <kbd class="calibre13">0</kbd>. This is the return value (<kbd class="calibre13">return 0</kbd>). The return value is always stored in the <kbd class="calibre13">eax</kbd> register. The <em class="calibre17">function epilogue</em> instructions at ➏ and ➐ restore the function environment. The instruction <kbd class="calibre13">mov esp,ebp</kbd> at ➏ copies the value of <kbd class="calibre13">ebp</kbd> into <kbd class="calibre13">esp</kbd>; as a result, <kbd class="calibre13">esp</kbd> will point to the address where <kbd class="calibre13">ebp</kbd> is pointing. The <kbd class="calibre13">pop ebp</kbd> at ➐ restores the old <kbd class="calibre13">ebp</kbd> from the stack; after this operation, <kbd class="calibre13">esp</kbd> will be incremented by <kbd class="calibre13">4</kbd>. After the execution of the instructions at ➏ and <span class="calibre7">➐</span>, the stack will look like the one shown here:</p>
<div class="cdpaligncenter"><img src="../images/00087.gif" class="calibre90"/></div>
<p class="calibre2">At ➓, <span class="calibre7">when the</span> <kbd class="calibre13">ret</kbd> <span class="calibre7">instruction is executed, the return address on top of the stack is popped out and placed in the</span> <kbd class="calibre13">eip</kbd> <span class="calibre7">register. Also, the control is transferred to the return address (which is <kbd class="calibre13">add esp,8</kbd> in the</span> <kbd class="calibre13">main</kbd> <span class="calibre7">function). As a result of popping the return address,</span> <kbd class="calibre13">esp</kbd> <span class="calibre7">is incremented by</span> <kbd class="calibre13">4</kbd><span class="calibre7">. </span><span class="calibre7"> At this point, the control is returned to the</span> <kbd class="calibre13">main</kbd> <span class="calibre7">function from the</span> <kbd class="calibre13">test</kbd> function. T<span class="calibre7">he instruction</span> <kbd class="calibre13">add esp,8</kbd> <span class="calibre7">inside of <kbd class="calibre13">main</kbd> cleans up the stack, and the</span> <kbd class="calibre13">esp</kbd> <span class="calibre7">is returned  to its original position (the address</span> <kbd class="calibre13">0xFE50</kbd>, <span class="calibre7">from where we started), as follows. At this point, all of the values on the stack are logically removed, even though they are physically present. This is how the function works:</span></p>
<div class="cdpaligncenter"><img src="../images/00088.gif" class="calibre91"/></div>
<p class="calibre2">In the previous example, the <kbd class="calibre13">main</kbd> function called the <kbd class="calibre13">test</kbd> function and passed the parameters to the <kbd class="calibre13">test</kbd> function by pushing them onto the stack (in the right-to-left order). The <kbd class="calibre13">main</kbd> function is known as the <em class="calibre17">caller</em> (or the <em class="calibre17">calling function</em>) and <kbd class="calibre13">test</kbd> is the <em class="calibre17">callee</em> (or the <em class="calibre17">called functio</em>n). The <kbd class="calibre13">main</kbd> function (caller), after the function call, cleaned up the stack using <kbd class="calibre13">add esp,8</kbd> instruction. This instruction has the effect of removing the parameters that were pushed onto the stack and adjusts the stack pointer (<kbd class="calibre13">esp</kbd>) back to where it was before the function call; such a function is said to be using <kbd class="calibre13">cdecl</kbd> calling convention. The calling convention dictates how the parameters should be passed and who (<em class="calibre17">caller</em> or the <em class="calibre17">callee</em>) is responsible for removing them from the stack once the called function has completed. Most of the compiled C programs typically follow the <kbd class="calibre13">cdecl</kbd> calling convention. In the <kbd class="calibre13">cdecl</kbd> convention, the <em class="calibre17">caller</em> pushes the parameters in the right-to-left order on the stack and the <em class="calibre17">caller</em> itself cleans up the stack after the function call. There are other calling conventions such as <kbd class="calibre13">stdcall</kbd> and <kbd class="calibre13">fastcall</kbd>. In <kbd class="calibre13">stdcall</kbd>, parameters are pushed onto the stack (right-to-left order) by the <em class="calibre17">caller</em> and the <em class="calibre17">callee,</em> (<em class="calibre17">called function</em>) is responsible for cleaning up the stack. Microsoft Windows utilizes the <kbd class="calibre13">stdcall</kbd> convention for the functions (API) exported by the DLL files. In the <kbd class="calibre13">fastcall</kbd> calling convention, first few parameters are passed to a function by placing them in the registers, and any remaining parameters are placed on the stack in right-to-left order and the <em class="calibre17">callee</em> cleans up the stack similar to the <kbd class="calibre13">stdcall</kbd> convention. You will typically see 64-bit programs following the <kbd class="calibre13">fastcall</kbd> calling convention.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9. Arrays And Strings</h1>
                
            
            <article>
                
<p class="calibre2">An array is a list consisting of the same data types. The array elements are stored in contiguous locations in the memory, which makes it easy to access array elements. The following defines an integer array of three elements, and each element of this array occupies 4 bytes in the memory (because an integer is 4 bytes in length):</p>
<pre class="calibre18">int nums[3] = {1, 2, 3}</pre>
<p class="calibre2">The array name <kbd class="calibre13">nums</kbd> is a pointer constant that points to the first element of the array (that is, the array name points to the <kbd class="calibre13">base address</kbd> of the array). In a high-level language, to access the elements of the array, you use the array name along with the <kbd class="calibre13">index</kbd>. For example, you can access the first element using <kbd class="calibre13">nums[0]</kbd>, the second element using <kbd class="calibre13">nums[1]</kbd>, and so on:</p>
<div class="cdpaligncenter"><img src="../images/00089.gif" class="calibre92"/></div>
<p class="calibre2">In assembly language, the address of any element in the array is computed using three things:</p>
<ul class="calibre11">
<li class="calibre12">The base address of the array</li>
<li class="calibre12">The index of the element</li>
<li class="calibre12">The size of each element in the array</li>
</ul>
<p class="calibre2">When you use <kbd class="calibre13">nums[0]</kbd> in a high-level language, it is translated to <kbd class="calibre13">[nums+0*&lt;size_of_each_element_in_bytes&gt;]</kbd>, where <kbd class="calibre13">0</kbd> is the index and <kbd class="calibre13">nums</kbd> represents the base address of the array. From the preceding example, you can access the elements of the integer array (the size of each element is 4 bytes) as shown here:</p>
<pre class="calibre18">nums[0] = [nums+0*4] = [0x4000+0*4] = [0x4000] = 1<br class="title-page-name"/>nums[1] = [nums+1*4] = [0x4000+1*4] = [0x4004] = 2<br class="title-page-name"/>nums[2] = [nums+2*4] = [0x4000+2*4] = [0x4008] = 3</pre>
<p class="calibre2">A general form for the <kbd class="calibre13">nums</kbd> integer array can be represented as follows:</p>
<pre class="calibre18"><br class="title-page-name"/>nums[i] = nums+i*4</pre>
<p class="calibre2">The following shows the general format for accessing the elements of an array:</p>
<pre class="calibre18">[base_address + index * size of element]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9.1 Disassembly Challenge</h1>
                
            
            <article>
                
<p class="calibre2">Translate the following code to its high-level equivalent. Use the techniques and the concepts that you have learned so far to solve this challenge:</p>
<pre class="calibre18">push ebp<br class="title-page-name"/>mov ebp, esp<br class="title-page-name"/>sub esp, 14h<br class="title-page-name"/>mov dword ptr [ebp-14h], 1<br class="title-page-name"/>mov dword ptr [ebp-10h], 2<br class="title-page-name"/>mov dword ptr [ebp-0Ch], 3<br class="title-page-name"/>mov dword ptr [ebp-4], 0<br class="title-page-name"/><br class="title-page-name"/>loc_401022:<br class="title-page-name"/> cmp dword ptr [ebp-4], 3<br class="title-page-name"/> jge loc_40103D<br class="title-page-name"/> mov eax, [ebp-4]<br class="title-page-name"/> mov ecx, [ebp+eax*4-14h]<br class="title-page-name"/> mov [ebp-8], ecx<br class="title-page-name"/> mov edx, [ebp-4]<br class="title-page-name"/> add edx, 1<br class="title-page-name"/> mov [ebp-4], edx<br class="title-page-name"/> jmp loc_401022<br class="title-page-name"/><br class="title-page-name"/>loc_40103D:<br class="title-page-name"/> xor eax, eax<br class="title-page-name"/> mov esp, ebp<br class="title-page-name"/> pop ebp<br class="title-page-name"/> ret</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9.2 Disassembly Solution</h1>
                
            
            <article>
                
<p class="calibre2">In the preceding code, the first two instructions <span class="calibre7">(</span><kbd class="calibre13">push ebp</kbd><span class="calibre7"> and </span><kbd class="calibre13">mov ebp, esp</kbd><span class="calibre7">)</span> represent <em class="calibre17">function prologue</em>. Similarly, the two lines before the last instruction, <kbd class="calibre13">ret</kbd>, represent the <em class="calibre17">function epilogue</em> (<kbd class="calibre13">mov esp,ebp</kbd> and <kbd class="calibre13">pop ebp</kbd>). We know that the <em class="calibre17">function prologue</em> and <em class="calibre17">epilogue</em> are not part of the code, but they are used to set up the environment for the function, and hence they can be removed to simplify the code. The third instruction, <kbd class="calibre13">sub,14h</kbd>, suggests that <kbd class="calibre13">20 (14h)</kbd> bytes are allocated for local variables; we know that this instruction is also not part of the code (it's just used for allocating space for local variables), and can also be ignored. After removing the instructions that are not part of the actual code, we are left with the following:</p>
<pre class="calibre18">1. mov dword ptr [ebp-14h], 1<br class="title-page-name"/>2. mov dword ptr [ebp-10h], 2  ➐<br class="title-page-name"/>3. mov dword ptr [ebp-0Ch], 3  ➑ <br class="title-page-name"/>4. mov dword ptr [ebp-4], 0  ➍<br class="title-page-name"/><br class="title-page-name"/>loc_401022:  ➋<br class="title-page-name"/>5. cmp dword ptr [ebp-4], 3  ➌<br class="title-page-name"/>6. jge loc_40103D  ➌<br class="title-page-name"/>7. mov eax, [ebp-4]<br class="title-page-name"/>8. mov ecx, [ebp+eax*4-14h]  ➏<br class="title-page-name"/>9. mov [ebp-8], ecx<br class="title-page-name"/>10. mov edx, [ebp-4]  ➎<br class="title-page-name"/>11. add edx, 1  ➎ <br class="title-page-name"/>12. mov [ebp-4], edx  ➎<br class="title-page-name"/>13. jmp loc_401022  ➊<br class="title-page-name"/><br class="title-page-name"/>loc_40103D:<br class="title-page-name"/>14. xor eax, eax<br class="title-page-name"/>15. ret</pre>
<p class="calibre2">The backward jump at ➊, to <kbd class="calibre13">loc_401022</kbd>, indicates the loop, and the code between ➊ and ➋ is the part of the loop. Let's identify the <kbd class="calibre13">loop variable</kbd>, the <kbd class="calibre13">loop initialization</kbd>, the <kbd class="calibre13">condition check</kbd>, and the <kbd class="calibre13">update statement</kbd>. The two instructions at ➌ is a condition check that is checking whether the value of <kbd class="calibre13">[ebp-4]</kbd> is <kbd class="calibre13">greater than or equal to</kbd> <kbd class="calibre13">3</kbd>; when this condition is met, a jump is taken outside of the loop. The same variable, <kbd class="calibre13">[ebp-4]</kbd>, is initialized to <kbd class="calibre13"><span><span>0</span></span></kbd> at ➍ before the condition check at ➌, and the variable is incremented using the instructions at ➎. All of these details suggest that <kbd class="calibre13">ebp-4</kbd> is the loop variable, so we can rename <kbd class="calibre13">ebp-4</kbd> as <kbd class="calibre13">i</kbd> (<kbd class="calibre13">ebp-4=i</kbd>).</p>
<p class="calibre2">At ➏, the instruction <kbd class="calibre13">[ebp+eax*4-14h]</kbd> represents array access. Let's try to identify the components of the array (the <kbd class="calibre13">base address</kbd>, <kbd class="calibre13">index</kbd>, and the <kbd class="calibre13">size</kbd> of each element). We know that local variables (including elements of an array) are accessed as <kbd class="calibre13">ebp-&lt;somevalue&gt;</kbd> (in other words, the negative offset from <kbd class="calibre13">ebp</kbd>), so we can rewrite <kbd class="calibre13">[ebp+eax*4-14h]</kbd> as <kbd class="calibre13">[ebp-14h+eax*4]</kbd>. Here, <kbd class="calibre13">ebp-14h</kbd> represents the base address of the array on the stack, <kbd class="calibre13">eax</kbd> represents the <kbd class="calibre13">index</kbd>, and <kbd class="calibre13">4</kbd> is the size of each element of the array. Since <kbd class="calibre13">ebp-14h</kbd> is the base address, which means this address also represents the first element of the array, if we assume the array name is <kbd class="calibre13">val</kbd>, then <kbd class="calibre13">ebp-14h = val[0]</kbd>.</p>
<p class="calibre2">Now that we have determined the first element of the array, let's try to find the other elements. From the array notation,  in this case, we know that the size of each element is <kbd class="calibre13">4</kbd> bytes. So, if <kbd class="calibre13">val[0] = ebp-14h</kbd>, then <kbd class="calibre13">val[1]</kbd> should be at the next highest address, which is <kbd class="calibre13">ebp-10h</kbd>, and <kbd class="calibre13">val[2]</kbd> should be at <kbd class="calibre13">ebp-0Ch</kbd>, and so on. Notice that <kbd class="calibre13">ebp-10h</kbd> and <kbd class="calibre13">ebp-0Ch</kbd> are referenced at ➐ and ➑.<span class="calibre7"> Let's rename </span><kbd class="calibre13">ebp-10h</kbd> <span class="calibre7">as</span> <kbd class="calibre13">val[1]</kbd> <span class="calibre7">and</span> <kbd class="calibre13">ebp-14h</kbd> <span class="calibre7">as</span> <kbd class="calibre13">val[2]</kbd><span class="calibre7">. We still haven't figured out how many elements this array contains. First, let's replace all of the determined values and write the preceding code in a high-level language equivalent. The last two instructions,</span> <kbd class="calibre13">xor eax,eax</kbd> <span class="calibre7">and</span> <kbd class="calibre13">ret</kbd>, <span class="calibre7">can be written as</span> <kbd class="calibre13">return 0</kbd><span class="calibre7">, so the pseudocode now looks as follows:</span></p>
<pre class="calibre18">val[0] = 1<br class="title-page-name"/>val[1] = 2<br class="title-page-name"/>val[2] = 3<br class="title-page-name"/>i = 0<br class="title-page-name"/>while (i&lt;3) <br class="title-page-name"/>{<br class="title-page-name"/>eax = i<br class="title-page-name"/>ecx = [val+eax*4]  ➒<br class="title-page-name"/>[ebp-8] = ecx  ➒<br class="title-page-name"/>edx = i<br class="title-page-name"/>edx = edx + 1  ➒<br class="title-page-name"/>i = edx  ➒<br class="title-page-name"/>}<br class="title-page-name"/>return 0</pre>
<p class="calibre2">Replacing all of the register names on the right-hand side of the <kbd class="calibre13">=</kbd> operator at ➒ with their corresponding values, we will get the following code:</p>
<pre class="calibre18">val[0] = 1<br class="title-page-name"/>val[1] = 2<br class="title-page-name"/>val[2] = 3<br class="title-page-name"/>i = 0<br class="title-page-name"/>while (i&lt;3) <br class="title-page-name"/>{<br class="title-page-name"/>eax = i  ➓<br class="title-page-name"/>ecx = [val+i*4]  ➓<br class="title-page-name"/>[ebp-8] = [val+i*4]<br class="title-page-name"/>edx = i  ➓<br class="title-page-name"/>edx = i + 1  ➓<br class="title-page-name"/>i = i + 1<br class="title-page-name"/>}<br class="title-page-name"/>return 0</pre>
<p class="calibre2">Removing all of the entries containing register names on the left-hand side of the <kbd class="calibre13">=</kbd> operator at ➓, <span class="calibre7">we get the following code:</span></p>
<pre class="calibre18">val[0] = 1<br class="title-page-name"/>val[1] = 2<br class="title-page-name"/>val[2] = 3<br class="title-page-name"/>i = 0<br class="title-page-name"/>while (i&lt;3) <br class="title-page-name"/>{<br class="title-page-name"/>[ebp-8] = [val+i*4]<br class="title-page-name"/>i = i + 1<br class="title-page-name"/>}<br class="title-page-name"/>return 0</pre>
<p class="calibre2">From what we learned previously, when we access an element of the integer array using <kbd class="calibre13">nums[0]</kbd>, it is the same as <kbd class="calibre13">[nums+0*4]</kbd>, and <kbd class="calibre13">nums[1]</kbd> is the same as <kbd class="calibre13">[nums+1*4]</kbd>, which means that the general form of <kbd class="calibre13">nums[i]</kbd> can be represented as <kbd class="calibre13">[nums+i*4]</kbd> that is, <kbd class="calibre13">nums[i] = [nums+i*4]</kbd>. Going by that logic, we can replace <kbd class="calibre13">[val+i*4]</kbd> with <kbd class="calibre13">val[i]</kbd> in the preceding code.</p>
<p class="calibre2">Now, we are left with the address <kbd class="calibre13">ebp-8</kbd> in the preceding code; this could be a local variable, or it could be the fourth element in the array <kbd class="calibre13">val[3]</kbd> (it's really hard to say). If we assume it as a local variable and rename <kbd class="calibre13">ebp-8</kbd> as <kbd class="calibre13">x</kbd> (<kbd class="calibre13">ebp-8=x</kbd>), then the resultant code will look as shown below. From the following code, we can tell that the code probably iterates through each element of the array (using the index variable <kbd class="calibre13"><span><span>i</span></span></kbd>) and assigns the value to the variable <kbd class="calibre13">x</kbd>. From the code, we can gather one extra piece of information: if the index <kbd class="calibre13">i</kbd> was used for iterating through each element of the array, then we can guess that the array probably has three elements (because the index <kbd class="calibre13">i</kbd> takes a maximum value of <kbd class="calibre13">2</kbd> before exiting the loop):</p>
<pre class="calibre18">val[0] = 1<br class="title-page-name"/>val[1] = 2<br class="title-page-name"/>val[2] = 3<br class="title-page-name"/>i = 0<br class="title-page-name"/>while (i&lt;3) <br class="title-page-name"/>{<br class="title-page-name"/>x = val[i]<br class="title-page-name"/>i = i + 1<br class="title-page-name"/>}<br class="title-page-name"/>return 0</pre>
<p class="calibre2">Instead of treating <kbd class="calibre13">ebp-8</kbd> as the local variable <kbd class="calibre13">x</kbd>, if you treat <kbd class="calibre13">ebp-8</kbd> as the array's fourth element (<kbd class="calibre13">ebp-8 = val[3]</kbd>), then the code will be translated to the following. Now, the code can be interpreted differently, that is, the array now has four elements and the code iterates through the first three elements. In every iteration, the value is assigned to the fourth element:</p>
<pre class="calibre18">val[0] = 1<br class="title-page-name"/>val[1] = 2<br class="title-page-name"/>val[2] = 3<br class="title-page-name"/>i = 0<br class="title-page-name"/>while (i&lt;3) <br class="title-page-name"/>{<br class="title-page-name"/>val[3] = val[i]<br class="title-page-name"/>i = i + 1<br class="title-page-name"/>}<br class="title-page-name"/>return 0</pre>
<p class="calibre2">As you might have guessed from the preceding example, it is not always possible to decompile the assembly code to its original form <span class="calibre7">accurately,</span> because of the way the compiler generates code (and also, the code might not have all of the required information). However, this technique should help to determine the program's functionality. The original C program of the disassembled output is shown as follows; notice the similarities between what we determined previously and the original code here:</p>
<pre class="calibre18">int main()<br class="title-page-name"/>{<br class="title-page-name"/>  int a[3] = { 1, 2, 3 };<br class="title-page-name"/>  int b, i;<br class="title-page-name"/>  i = 0;<br class="title-page-name"/>   while (i &lt; 3)<br class="title-page-name"/>   { <br class="title-page-name"/>     b = a[i]; <br class="title-page-name"/>     i++;<br class="title-page-name"/>   }<br class="title-page-name"/>  return 0;<br class="title-page-name"/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9.3 Strings</h1>
                
            
            <article>
                
<p class="calibre2">A string is an array of characters. When you define a string, shown as follows, a <em class="calibre17">null terminator</em> (<em class="calibre17">string terminator</em>) is added at the end of every string. Each element occupies 1 byte of memory (in other words, each ASCII character is 1 byte in length):</p>
<pre class="calibre18">char *str = "Let"</pre>
<p class="calibre2">The string name <kbd class="calibre13">str</kbd> is a pointer variable that points to the first character in the string (in other words, it points to the base address of the character array). The following diagram shows how these characters reside in memory:</p>
<div class="cdpaligncenter"><img src="../images/00090.gif" class="calibre93"/></div>
<p class="calibre2">From the preceding example, you can access the elements of a character array (string), as shown here:</p>
<pre class="calibre18">str[0] = [str+0] = [0x4000+0] = [0x4000] = L<br class="title-page-name"/>str[1] = [str+1] = [0x4000+1] = [0x4001] = e<br class="title-page-name"/>str[2] = [str+2] = [0x4000+2] = [0x4002] = t</pre>
<p class="calibre2">The general form for the character array can be represented as follows:</p>
<pre class="calibre18">str[i] = [str+i]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9.3.1 String Instructions</h1>
                
            
            <article>
                
<p class="calibre2">The x86 family of processors provides string instructions, which operate on strings. These instructions step through the string (character array) and are suffixed with <kbd class="calibre13">b</kbd>, <kbd class="calibre13">w</kbd>, and <kbd class="calibre13">d</kbd>, which indicating the size of data to operate on (<kbd class="calibre13">1</kbd>, <kbd class="calibre13">2</kbd>, or <kbd class="calibre13">4</kbd> bytes). The string instructions make use of the registers <kbd class="calibre13">eax</kbd>, <kbd class="calibre13">esi</kbd>, and <kbd class="calibre13">edi</kbd>. The register <kbd class="calibre13">eax</kbd>, or its sub-registers <kbd class="calibre13">ax</kbd> and <kbd class="calibre13">al</kbd>, are used to hold values. The register <kbd class="calibre13">esi</kbd> acts as the <em class="calibre17">source address register</em> (it holds the address of the source string), and <kbd class="calibre13">edi</kbd> is the <em class="calibre17">destination address register</em> (it holds the address of the destination string).</p>
<p class="calibre2">After performing a string operation, the <kbd class="calibre13">esi</kbd> and <kbd class="calibre13">edi</kbd> registers are either automatically incremented or decremented (you can think of <kbd class="calibre13">esi</kbd> and <kbd class="calibre13">edi</kbd> as source and destination index registers). The <kbd class="calibre13">direction flag (DF)</kbd> in the <kbd class="calibre13">eflags</kbd> register determines whether <kbd class="calibre13">esi</kbd> and <kbd class="calibre13">edi</kbd> should be incremented or decremented. The <kbd class="calibre13">cld</kbd> instruction clears the direction flag (<kbd class="calibre13">df=0</kbd>); if <kbd class="calibre13">df=0</kbd>, then the index registers (<kbd class="calibre13">esi</kbd> and <kbd class="calibre13">edi</kbd>) are incremented. The <kbd class="calibre13">std</kbd> instruction sets the direction flag (<kbd class="calibre13">df=1</kbd>); in such a case, <kbd class="calibre13">esi</kbd> and <kbd class="calibre13">edi</kbd> are decremented.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9.3.2 Moving From Memory To Memory (movsx)</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre13">movsx</kbd> instructions are used to move a sequence of bytes from one memory location to another. The <kbd class="calibre13">movsb</kbd> instruction is used to move <kbd class="calibre13">1</kbd> byte from the address specified by the <kbd class="calibre13">esi</kbd> register to the address specified by the <kbd class="calibre13">edi</kbd> register. The <kbd class="calibre13">movsw, movsd</kbd> instructions move <kbd class="calibre13">2</kbd> and <kbd class="calibre13">4</kbd> bytes from the address specified by the <kbd class="calibre13">esi</kbd> to the address specified by <kbd class="calibre13">edi</kbd>. After the value is moved, the <kbd class="calibre13">esi</kbd> and <kbd class="calibre13">edi</kbd> registers are incremented/decremented by <kbd class="calibre13">1</kbd>, <kbd class="calibre13">2</kbd>, or <kbd class="calibre13">4</kbd> bytes, based on the size of the data item. In the following assembly code, let's assume that the address labeled as <kbd class="calibre13">src</kbd> contained the string <kbd class="calibre13">"Good"</kbd>, followed by a <em class="calibre17">null terminator</em> (<kbd class="calibre13">0x0</kbd>). After executing the first instruction at ➊, <kbd class="calibre13">esi</kbd> will contain the start address of the string <kbd class="calibre13">"Good"</kbd> (in other words, <kbd class="calibre13">esi</kbd> will contain the address of the first character, <kbd class="calibre13">G</kbd>), and the instruction at ➋ <span class="calibre7">will set</span> <kbd class="calibre13">EDI</kbd> <span class="calibre7">to contain the address of a memory buffer (<kbd class="calibre13">dst</kbd>). The instruction at ➌</span><span class="calibre7"> will copy 1 byte (the character <kbd class="calibre13">G</kbd>) from the address specified by</span> <kbd class="calibre13">esi</kbd> <span class="calibre7">to the address specified by</span> <kbd class="calibre13">edi</kbd><span class="calibre7">. After executing the </span><span class="calibre7">instruction at ➌, both</span> <kbd class="calibre13">esi</kbd> <span class="calibre7">and</span> <kbd class="calibre13">edi</kbd> <span class="calibre7">will be incremented by</span> <kbd class="calibre13">1</kbd>, <span class="calibre7">to contain the next address:</span></p>
<pre class="calibre18"> ➊ lea esi,[src] ; "Good",0x0<br class="title-page-name"/> ➋ lea edi,[dst]<br class="title-page-name"/> ➌ movsb</pre>
<p class="calibre2">The following screenshot will help you to understand what happens before and after executing the <kbd class="calibre13">movsb</kbd> instruction at ➌. Instead of <kbd class="calibre13">movsb</kbd>, if <kbd class="calibre13">movsw</kbd> is used, then 2 bytes will be copied from <kbd class="calibre13">src</kbd> to <kbd class="calibre13">dst</kbd>, and <kbd class="calibre13">esi</kbd> and <kbd class="calibre13">edi</kbd> will be incremented by <kbd class="calibre13">2</kbd>:</p>
<div class="cdpaligncenter"><img src="../images/00091.gif" class="calibre94"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9.3.3 Repeat Instructions (rep)</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre13">movsx</kbd> instruction can only copy <kbd class="calibre13">1</kbd>, <kbd class="calibre13">2</kbd>, or <kbd class="calibre13">4</kbd> bytes, but to copy the multi-byte content, the <kbd class="calibre13">rep</kbd> instruction is used, along with the string instruction. The <kbd class="calibre13">rep</kbd> instruction depends on the <kbd class="calibre13">ecx</kbd> register, and it repeats the string instruction the number of times specified by the <kbd class="calibre13">ecx</kbd> register. After the <kbd class="calibre13">rep</kbd> instruction is executed, the value of <kbd class="calibre13">ecx</kbd> is decremented. The following assembly code copies the string <kbd class="calibre13">"Good"</kbd> (along with a <em class="calibre17">null terminator</em>) from <kbd class="calibre13">src</kbd> to <kbd class="calibre13">dst</kbd>:</p>
<pre class="calibre18">lea esi,[src] ; "Good",0x0<br class="title-page-name"/>lea edi,[dst]<br class="title-page-name"/>mov ecx,5<br class="title-page-name"/>rep movsb</pre>
<p class="calibre2">The <kbd class="calibre13">rep</kbd> instruction, when used with the <kbd class="calibre13">movsx</kbd> instruction, is equivalent to the <kbd class="calibre13">memcpy()</kbd> function in C programming. The <kbd class="calibre13">rep</kbd> instruction has multiple forms, which allows early termination, based on the condition that occurs during the execution of the loop. The following table outlines different forms of <kbd class="calibre13">rep</kbd> instructions and their conditions:</p>
<table border="1" class="calibre46">
<tbody class="calibre47">
<tr class="calibre48">
<td class="calibre49">Instruction</td>
<td class="calibre49">Condition</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">rep</kbd></td>
<td class="calibre49">Repeats until <kbd class="calibre13">ecx=0</kbd></td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">repe, repz</kbd></td>
<td class="calibre49">Repeats until <kbd class="calibre13">ecx=0</kbd> or <kbd class="calibre13">ZF=0</kbd></td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">repne, repnz</kbd></td>
<td class="calibre49">Repeat until <kbd class="calibre13">ecx=0</kbd> or <kbd class="calibre13">ZF=1</kbd></td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9.3.4 Storing Value From Register to Memory (stosx)</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre13">stosb</kbd> instruction is used to move a byte from the CPU's <kbd class="calibre13">al</kbd> register to the memory address specified by <kbd class="calibre13">edi</kbd> (the <em class="calibre17">destination index register</em>). Similarly, the <kbd class="calibre13">stosw</kbd> and <kbd class="calibre13">stosd</kbd> instructions move data from <kbd class="calibre13">ax</kbd> (2 bytes) and <kbd class="calibre13">eax</kbd> (4 bytes) to the address specified by <kbd class="calibre13">edi</kbd>. Normally, the <kbd class="calibre13">stosb</kbd> instruction is used along with the <kbd class="calibre13">rep</kbd> instruction to initialize all of the bytes of the buffer to some value. The following assembly code fills the destination buffer with <kbd class="calibre13">5</kbd> double words (<kbd class="calibre13">dword</kbd>), all of them equal to <kbd class="calibre13">0</kbd> (in other words, it initializes <kbd class="calibre13">5*4 = 20</kbd> bytes of memory to <kbd class="calibre13">0</kbd>). The <kbd class="calibre13">rep</kbd> instruction, when used with <kbd class="calibre13">stosb</kbd>, is equivalent to the <kbd class="calibre13">memset()</kbd> function in C programming:</p>
<pre class="calibre18">mov eax, 0<br class="title-page-name"/>lea edi,[dest]<br class="title-page-name"/>mov ecx,5<br class="title-page-name"/>rep stosd</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9.3.5 Loading From Memory to Register (lodsx)</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre13">lodsb</kbd> instruction moves a byte from a memory address specified by <kbd class="calibre13">esi</kbd> (the <em class="calibre17">source index register</em>) to the <kbd class="calibre13">al</kbd> register. Similarly, the <kbd class="calibre13">lodsw</kbd> and <kbd class="calibre13">lodsd</kbd> instructions move 2 bytes and 4 bytes of data from the memory address specified by <kbd class="calibre13">esi</kbd> to the <kbd class="calibre13">ax</kbd> and <kbd class="calibre13">eax</kbd> registers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9.3.6 Scanning Memory (scasx)</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre13">scasb</kbd> instruction is used to search (or scan) for the presence or absence of a byte value in a sequence of bytes. The byte to search for is placed in the <kbd class="calibre13">al</kbd> register, and the memory address (buffer) is placed in the <kbd class="calibre13">edi</kbd> register. The <kbd class="calibre13">scasb</kbd> instruction is mostly used with the <kbd class="calibre13">repne</kbd> instruction (<kbd class="calibre13">repne scasb</kbd>), with <kbd class="calibre13">ecx</kbd> set to the buffer length; this iterates through each byte until it finds the specified byte in the <kbd class="calibre13">al</kbd> register, or until <kbd class="calibre13">ecx</kbd> becomes <kbd class="calibre13">0</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9.3.7 Comparing Values in Memory (cmpsx)</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre13">cmpsb</kbd> instruction is used to compare a byte in the memory address specified by <kbd class="calibre13">esi</kbd> with a byte in the memory address specified by <kbd class="calibre13">edi</kbd>, to determine if they contain the same data. The <kbd class="calibre13">cmpsb</kbd> is normally used with <kbd class="calibre13">repe</kbd> (<kbd class="calibre13">repe cmpsb</kbd>) to compare two memory buffers; in this case, <kbd class="calibre13">ecx</kbd> will be set to the buffer length, and the comparison will continue until <kbd class="calibre13">ecx=0</kbd> or the buffers are not equal.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">10. Structures</h1>
                
            
            <article>
                
<p class="calibre2">A structure groups different types of data together; each element of the structure is called a <em class="calibre17">member</em>. The structure members are accessed using constant offsets. To understand the concept, take a look at the following C program. The <kbd class="calibre13">simpleStruct</kbd> definition contains three member variables (<kbd class="calibre13">a</kbd>,  <kbd class="calibre13">b</kbd>, and <kbd class="calibre13">c</kbd>) of different data types. The <kbd class="calibre13">main</kbd> function defines the structure variable (<kbd class="calibre13">test_stru</kbd>) at ➊,<span class="calibre7"> and the address of the structure variable (</span><kbd class="calibre13">&amp;test_stru</kbd>) is passed as the first argument <span class="calibre7">at ➋</span> to the <kbd class="calibre13">update</kbd> function. <span class="calibre7">Inside of the <kbd class="calibre13">update</kbd> function, the member variables are assigned values:</span></p>
<pre class="calibre18">struct simpleStruct<br class="title-page-name"/>{<br class="title-page-name"/>  int a;<br class="title-page-name"/>  short int b;<br class="title-page-name"/>  char c;<br class="title-page-name"/>};<br class="title-page-name"/><br class="title-page-name"/>void update(struct simpleStruct *test_stru_ptr) {<br class="title-page-name"/> test_stru_ptr-&gt;a = 6;<br class="title-page-name"/> test_stru_ptr-&gt;b = 7;<br class="title-page-name"/> test_stru_ptr-&gt;c = 'A';<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>int main()<br class="title-page-name"/>{<br class="title-page-name"/> struct simpleStruct test_stru;  ➊  <br class="title-page-name"/> update(&amp;test_stru);  ➋<br class="title-page-name"/> return 0;<br class="title-page-name"/>}</pre>
<p class="calibre2">In order to understand how the members of the structures are accessed, let's look at the disassembled output of the <kbd class="calibre13">update</kbd> function. At ➌, the base address of the structure is moved into the <kbd class="calibre13">eax</kbd> register (remember, <kbd class="calibre13">ebp+8</kbd> represents the first argument; in our case, the first argument contains the <kbd class="calibre13">base address</kbd> of the <kbd class="calibre13">structure</kbd>). At this stage, <kbd class="calibre13">eax</kbd> contains the base address of the structure. At ➍, the integer <span class="calibre7">value</span> <kbd class="calibre13">6</kbd> <span class="calibre7">is assigned to the first member by adding the offset</span> <kbd class="calibre13">0</kbd> <span class="calibre7">to the base address (</span><kbd class="calibre13">[eax+0]</kbd> which is the <span class="calibre7">same as</span> <kbd class="calibre13">[eax]</kbd><span class="calibre7">). Because the integer occupies <kbd class="calibre13">4</kbd> bytes, notice at ➎ the</span> <kbd class="calibre13">short int value 7</kbd> <span class="calibre7">(in</span> <kbd class="calibre13">cx</kbd><span class="calibre7">) is assigned to the second member by adding the offset</span> <kbd class="calibre13">4</kbd> <span class="calibre7">to the</span> <kbd class="calibre13">base address</kbd><span class="calibre7">. Similarly, the value</span> <kbd class="calibre13">41h</kbd> <span class="calibre7">(</span><kbd class="calibre13">A</kbd><span class="calibre7">) is assigned to the third member by adding</span> <kbd class="calibre13">6</kbd> <span class="calibre7">to the base address at ➏:</span></p>
<pre class="calibre18">push ebp<br class="title-page-name"/>mov ebp, esp<br class="title-page-name"/>mov eax, [ebp+8]  ➌<br class="title-page-name"/>mov dword ptr [eax], 6  ➍<br class="title-page-name"/>mov ecx, 7<br class="title-page-name"/>mov [eax+4], cx  ➎<br class="title-page-name"/>mov byte ptr [eax+6], 41h  ➏<br class="title-page-name"/>mov esp,ebp<br class="title-page-name"/>pop ebp<br class="title-page-name"/>ret</pre>
<p class="calibre2">From the preceding example, it can be seen that each member of the structure has its own <em class="calibre17">offset</em> and is accessed by adding the <em class="calibre17">constant offset</em> to the <em class="calibre17">base address</em>; so, the general form can be written as follows:</p>
<p class="calibre2"><kbd class="calibre13">[base_address + constant_offset]</kbd></p>
<p class="calibre2">Structures may look very similar to arrays in the memory, but you need to remember a few points to distinguish between them:</p>
<ul class="calibre11">
<li class="calibre12">Array elements always have the same data types, whereas structures need not have the same data types.</li>
<li class="calibre12">Array elements are mostly accessed by a variable offset from the base address (such as <kbd class="calibre13">[eax + ebx]</kbd> or <kbd class="calibre13">[eax+ebx*4]</kbd>), whereas structures are mostly accessed using constant offsets from the base address (for example, <kbd class="calibre13">[eax+4]</kbd>).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">11. x64 Architecture</h1>
                
            
            <article>
                
<p class="calibre2">Once you understand the concepts of x86 architecture, it's much easier to understand x64 architecture. The x64 architecture was designed as an extension to x86 and has a strong resemblance with x86 instruction sets, but there are a few differences that you need to be aware of from a code analysis perspective. This section covers some of the differences in the x64 architecture:</p>
<ul class="calibre11">
<li class="calibre12">The first difference is that the 32-bit (4 bytes) general purpose registers <kbd class="calibre13">eax</kbd>, <kbd class="calibre13">ebx</kbd>, <kbd class="calibre13">ecx</kbd>, <kbd class="calibre13">edx</kbd>, <kbd class="calibre13">esi</kbd>, <kbd class="calibre13">edi</kbd>, <kbd class="calibre13">ebp</kbd>, and <kbd class="calibre13">esp</kbd> are extended to 64 bits (8 bytes); these registers are named <kbd class="calibre13">rax</kbd>, <kbd class="calibre13">rbx</kbd>, <kbd class="calibre13">rcx</kbd>, <kbd class="calibre13">rdx</kbd>, <kbd class="calibre13">rsi</kbd>, <kbd class="calibre13">rdi</kbd>, <kbd class="calibre13">rbp</kbd>, and <kbd class="calibre13">rsp</kbd>. The eight new registers are named <kbd class="calibre13">r8</kbd>, <kbd class="calibre13">r9</kbd>, <kbd class="calibre13">r10</kbd>, <kbd class="calibre13">r11</kbd>, <kbd class="calibre13">r12</kbd>, <kbd class="calibre13">r13</kbd>, <kbd class="calibre13">r14</kbd>, and <kbd class="calibre13">r15</kbd>. As you might expect, a program can access the register as 64-bit (<kbd class="calibre13">RAX</kbd>, <kbd class="calibre13">RBX</kbd>, and so on), 32-bit (<kbd class="calibre13">eax</kbd>, <kbd class="calibre13">ebx</kbd>, etc), 16-bit (<kbd class="calibre13">ax</kbd>, <kbd class="calibre13">bx</kbd>, and so on), or 8-bit (<kbd class="calibre13">al</kbd>, <kbd class="calibre13">bl</kbd>, and so on). For example, you can access the lower half of the <kbd class="calibre13">RAX</kbd> register as <kbd class="calibre13">EAX</kbd> and the lowest word as <kbd class="calibre13">AX.</kbd> You can access the registers <kbd class="calibre13">r8-r15</kbd> as <kbd class="calibre13">byte</kbd>, <kbd class="calibre13">word</kbd>, <kbd class="calibre13">dword</kbd>, or <kbd class="calibre13">qword</kbd> by appending <kbd class="calibre13">b, w, d</kbd> or <kbd class="calibre13">q</kbd> to the register name.</li>
<li class="calibre12">x64 architecture can handle 64-bit (8 bytes) data, and all of the addresses and pointers are 64 bits (8 bytes) in size.</li>
<li class="calibre12">The x64 CPU has a 64-bit instruction pointer <kbd class="calibre13">(rip)</kbd> that contains the address of the next instruction to execute, and it also has a 64-bit flags register <kbd class="calibre13">(rflags)</kbd>, but currently, only the lower 32 bits are used <kbd class="calibre13">(eflags)</kbd>.</li>
<li class="calibre12">The x64 architecture supports <kbd class="calibre13">rip-relative</kbd> addressing. The <kbd class="calibre13">rip</kbd> register can now be used to reference memory locations; that is, you can access data at a location which is at some offset from the current <em class="calibre19">instruction pointer</em>.</li>
<li class="calibre12">Another major difference is that in the x86 architecture, the function parameters are pushed onto the stack as mentioned previously, whereas in the x64 architecture, the first four parameters are passed in the <kbd class="calibre13">rcx</kbd>, <kbd class="calibre13">rdx</kbd>, <kbd class="calibre13">r8</kbd>, and <kbd class="calibre13">r9</kbd> registers, and if the program contains additional parameters they are stored on the stack. Let's look at an example of simple C code (the <kbd class="calibre13">printf</kbd> function); this function takes six parameters:</li>
</ul>
<pre class="calibre18">printf("%d %d %d %d %d", 1, 2, 3, 4, 5);</pre>
<p class="calibre2">The following is the disassembly of the C code compiled for a 32-bit (x86) processor; in this case, all of the parameters are pushed onto the stack (in reverse order), and after the call to <kbd class="calibre13">printf</kbd>,  <kbd class="calibre13">add esp,18h</kbd> is used to clean up the stack. So, it is easy to tell that the <kbd class="calibre13">printf</kbd> function takes six parameters:</p>
<pre class="calibre18">push 5<br class="title-page-name"/>push 4<br class="title-page-name"/>push 3<br class="title-page-name"/>push 2<br class="title-page-name"/>push 1<br class="title-page-name"/>push offset Format ; "%d %d %d %d %d"<br class="title-page-name"/>call ds:printf<br class="title-page-name"/>add esp, 18h</pre>
<p class="calibre2">The following is the disassembly of the C code compiled for a 64-bit (x64) processor. The first instruction, at ➊, allocates <kbd class="calibre13">0x38</kbd> (<kbd class="calibre13">56</kbd> bytes) of space on the stack. The first, second, third, and fourth parameters are stored in the <kbd class="calibre13">rcx, rdx, r8</kbd> and <kbd class="calibre13">r9</kbd> register (before the <kbd class="calibre13">call</kbd> to <kbd class="calibre13">printf</kbd>), at  ➋, ➌, ➍, ➎. The fifth and the sixth parameters are stored on the stack (in the allocated space), using instructions at ➏ and ➐. The <kbd class="calibre13">push</kbd> instruction was not used in this case, making it difficult to determine if the memory address is a <em class="calibre17">local variable</em> or a <em class="calibre17">parameter</em> to the function. In this case, the format string helps to determine the number of parameters passed to the <kbd class="calibre13">printf</kbd> function, but in other cases, it's not that easy:</p>
<pre class="calibre18">sub rsp, 38h  ➊ <br class="title-page-name"/>mov dword ptr [rsp+28h], 5  ➐<br class="title-page-name"/>mov dword ptr [rsp+20h], 4  ➏<br class="title-page-name"/>mov r9d, 3  ➎<br class="title-page-name"/>mov r8d, 2  ➍<br class="title-page-name"/>mov edx, 1  ➌<br class="title-page-name"/>lea rcx, Format ; "%d %d %d %d %d"  ➋<br class="title-page-name"/>call cs:printf</pre>
<div class="packt_infobox">Intel 64 (x64) and IA-32 (x86) architecture consist of many instructions. If you come across an assembly instruction that is not covered in this chapter, you can download the latest Intel architecture manuals from <a href="https://software.intel.com/en-us/articles/intel-sdm" class="calibre20">https://software.intel.com/en-us/articles/intel-sdm</a>, and the instruction set reference (<em class="calibre22">volumes 2A, 2B, 2C, and 2D</em>) can be downloaded from <a href="https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf" target="_blank" class="calibre20">https://software.intel.com/sites/default/files/managed/a4/60/325383-sdm-vol-2abcd.pdf</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">11.1 Analyzing 32-bit Executable On 64-bit Windows</h1>
                
            
            <article>
                
<p class="calibre2">The 64-bit Windows operating system can run a 32-bit executable; to do that, Windows developed a subsystem called <em class="calibre17">WOW64</em> (Windows 32-bit on Windows 64-bit). WOW64 subsystem allows for the execution of 32-bit binaries on 64-bit Windows. When you run an executable, it needs to load the DLLs to call the API functions to interact with the system. The 32-bit executable cannot load 64-bit DLLs (and a 64-bit process cannot load 32-bit DLLs), so Microsoft separated the DLLs for both 32-bit and 64-bit. The 64-bit binaries are stored in the <kbd class="calibre13">\Windows\system32</kbd> directory, and the 32-bit binaries are stored in the <kbd class="calibre13">\Windows\Syswow64</kbd> directory.</p>
<p class="calibre2">The 32-bit applications, when running under 64-bit Windows (Wow64), can behave differently, as compared to how they behave on the native 32-bit Windows. When you are analyzing a 32-bit malware on 64-bit Windows, if you find malware accessing the <kbd class="calibre13">system32</kbd> directory, it is really accessing the <kbd class="calibre13">syswow64</kbd> directory (the operating system automatically redirects it to the <kbd class="calibre13">Syswow64</kbd> directory). If a 32-bit malware (when executed on 64-bit Windows) is writing a file in the <kbd class="calibre13">\Windows\system32</kbd> directory, then you need to check the file in the <kbd class="calibre13">\Windows\Syswow64</kbd> directory. Similarly, access to <kbd class="calibre13">%windir%\regedit.exe</kbd> is redirected to <kbd class="calibre13">%windir%\SysWOW64\regedit.exe</kbd>. The difference in behavior can create confusion during analysis, so it is essential to understand this difference, and to avoid confusion during analysis, it is better to analyze a 32-bit binary in a 32-bit Windows environment.</p>
<div class="packt_infobox">To get an idea of how WOW64 subsystem can impact your analysis, refer to <em class="calibre22">The WOW-Effect </em>by Christian Wojner (<a href="http://www.cert.at/static/downloads/papers/cert.at-the_wow_effect.pdf" target="_blank" class="calibre20">http://www.cert.at/static/downloads/papers/cert.at-the_wow_effect.pdf</a>)</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">12. Additional Resources</h1>
                
            
            <article>
                
<p class="calibre2">The following are some of the additional resources to help you gain a deeper understanding of C programming, x86, and x64 assembly language programming:</p>
<ul class="calibre11">
<li class="calibre12"><em class="calibre19">Learn C:</em> <a href="https://www.programiz.com/c-programming" class="calibre10">https://www.programiz.com/c-programming</a></li>
<li class="calibre12"><em class="calibre19">C Programming Absolute Beginner's Guide</em> by Greg Perry and Dean Miller</li>
<li class="calibre12"><em class="calibre19">x86 Assembly Programming Tutorial</em>: <a href="https://www.tutorialspoint.com/assembly_programming/" class="calibre10">https://www.tutorialspoint.com/assembly_programming/</a></li>
<li class="calibre12">Dr. Paul Carter's <em class="calibre19">PC Assembly Language</em>: <a href="http://pacman128.github.io/pcasm/" class="calibre10">http://pacman128.github.io/pcasm/</a></li>
<li class="calibre12"><em class="calibre19">Introductory Intel x86 - Architecture, Assembly, Applications, and Alliteration</em>: <a href="http://opensecuritytraining.info/IntroX86.html" class="calibre10">http://opensecuritytraining.info/IntroX86.html</a> </li>
<li class="calibre12"><em class="calibre19">Assembly language Step by Step</em> by Jeff Duntemann</li>
<li class="calibre12"><em class="calibre19">Introduction to 64-bit Windows Assembly Programming</em> by Ray Seyfarth</li>
<li class="calibre12"> <em class="calibre19">x86 Disassembly</em>: <a href="https://en.wikibooks.org/wiki/X86_Disassembly" class="calibre10">https://en.wikibooks.org/wiki/X86_Disassembly</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">13. Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, you learned the concepts and techniques required to understand and interpret assembly code. This chapter also highlighted the key differences between the x32 and x64 architectures. The disassembly and decompiling (static code analysis) skills that you learned in this chapter will help you to gain a deeper understanding of how malicious code works, at a low level. In the next chapter, we will look at code analysis tools (disassemblers and debuggers), and you will learn how the various features offered by these tools can ease your analysis and help you inspect the code associated with the malicious binary.</p>


            </article>

            
        </section>
    </body></html>