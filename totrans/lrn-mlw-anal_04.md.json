["```\n#include <stdio.h>\nint main() {\n   char *string = \"This is a simple program\"; \n   printf(\"%s\",string);\n   return 0;\n}\n```", "```\nmov dst,src\n```", "```\nmov eax,10  *; moves 10 into EAX register, same as eax=10*\nmov bx,7    *; moves 7 in bx register, same as bx=7*\nmov eax,64h *; moves hex value 0x64 (i.e 100) into EAX*\n```", "```\nmov eax,ebx *; moves content of ebx into eax, i.e eax=ebx*\n```", "```\nmov ebx,10  *; moves 10 into ebx, ebx = 10*\nmov eax,ebx *; moves value in ebx into eax, eax = ebx or eax = 10*\n```", "```\nint val = 100;\n```", "```\nmov eax,[0x403000] *; eax will now contain 00 00 00 64 (i.e 100)*\n```", "```\nmov eax,[ebx]     *; moves value at address specifed by ebx register*\nmov eax,[ebx+ecx] *; moves value at address specified by ebx+ecx*\nmov ebx,[ebp-4]   *; moves value at address specified by ebp-4*\n```", "```\nlea ebx,[0x403000] *; loads the address 0x403000 into ebx*\nlea eax, [ebx]     *; if ebx = 0x403000, then eax will also contain 0x403000*\n```", "```\nmov eax,dword ptr [ebp-4]  *; same as mov eax,[ebp-4]*\n```", "```\nmov [0x403000],eax *; moves 4 byte value in eax to memory location starting at 0x403000*\nmov [ebx],eax   *; moves 4 byte value in eax to the memory address specified by ebx*\n```", "```\nmov dword ptr [402000],13498h *; moves dword value 0x13496 into the address 0x402000*\nmov dword ptr [ebx],100   *; moves dword value 100 into the address specified by ebx*\nmov word ptr [ebx], 100    *; moves a word 100 into the address specified by ebx*\n```", "```\nmov dword ptr [ebp-4],1  ➊\nmov eax,dword ptr [ebp-4]  ➋\nmov dword ptr [ebp-8],eax  ➌\n```", "```\nmov dword ptr [a],1     *; treat it as mov [a],1*\nmov eax,dword ptr [a]   *; treat it as mov eax,[a]*\nmov dword ptr [b],eax   *; treat it as mov [b],eax*\n```", "```\na = 1\neax = a\nb = eax ➍\n```", "```\na = 1\neax = a ➎\nb = a\n```", "```\na = 1\nb = a\n```", "```\nint a;\nint b;\n\na = 1;\nb = a;\n```", "```\nint x = 1;\nint y;\ny = x;\n```", "```\nadd eax,42      *; same as eax = eax+42*\nadd eax,ebx     *; same as eax = eax+ebx*\nadd [ebx],42    *; adds 42 to the value in address specified by ebx*\nsub eax, 64h    *; subtracts hex value 0x64 from eax, same as eax = eax-0x64*\n```", "```\ninc eax    *; same as eax = eax+1*\ndec ebx    *; same as ebx = ebx-1*\n```", "```\nmul ebx  *;ebx is multiplied with eax and result is stored in EDX and EAX*\nmul bx   *;bx is multiplied with ax and the result is stored in DX and AX*\n```", "```\ndiv ebx   *; divides the value in EDX:EAX by EBX*\n```", "```\nmov dword ptr [ebp-4], 16h\nmov dword ptr [ebp-8], 5\nmov eax, [ebp-4]\nadd eax, [ebp-8]\nmov [ebp-0Ch], eax\nmov ecx, [ebp-4]\nsub ecx, [ebp-8]\nmov [ebp-10h], ecx\n```", "```\nmov dword ptr [a], 16h\nmov dword ptr [b], 5\nmov eax, [a]\nadd eax, [b]\nmov [c], eax\nmov ecx, [a]\nsub ecx, [b]\nmov [d], ecx\n```", "```\na = 16h    *; h represents hexadecmial, so 16h (0x16) is 22 in decimal*\nb = 5\neax = a\neax = eax + b  ➊\nc = eax  ➊ \necx = a\necx = ecx-b  ➊\nd = ecx  ➊\n```", "```\na = 22\nb = 5\neax = a  ➋\neax = a+b  ➋\nc = a+b\necx = a  ➋\necx = a-b  ➋\nd = a-b\n```", "```\na = 22\nb = 5\nc = a+b\nd = a-b\n```", "```\nint a,b,c,d;\na = 22;\nb = 5;\nc = a+b;\nd = a-b;\n```", "```\nint num1 = 22;\nint num2 = 5;\nint diff;\nint sum;\nsum = num1 + num2;\ndiff = num1 - num2;\n```", "```\nnot eax\n```", "```\nand bl,cl  *; same as bl = bl & cl*\n```", "```\n                    bl: 0000 0101\n                    cl: 0000 0110\n--------------------------------------\nAfter and operation bl: 0000 0100\n```", "```\nor eax,ebx   *; same as eax = eax | ebx*\nxor eax,eax  *; same eax = eax^eax, this operation clears the eax register*\n```", "```\nshl dst,count\n```", "```\nxor eax,eax\nmov al,4 \nshl al, 2\n```", "```\nrol al,2\n```", "```\njmp <jump address>\n```", "```\ncmp eax,5  *; subtracts eax from 5, sets the flags but result is not stored*\n```", "```\ntest eax,eax *; performs and operation, alters the flags but result in not stored*\n```", "```\njcc <address>\n```", "```\nif (x == 0) {\n   x = 5;\n}\nx = 2;\n```", "```\ncmp dword ptr [x], 0\njne end_if\nmov dword ptr [x], 5\n\nend_if:\nmov dword ptr [x], 2\n```", "```\nif (x == 0) {\n    x = 5;\n}\nelse {\n    x = 1;\n}\n```", "```\ncmp dword ptr [x], 0\njne else\nmov dword ptr [x], 5\njmp end\n\nelse:\nmov dword ptr [x], 1\n\nend:\n```", "```\nif (x == 0) {\n  x = 5;\n}\nelse if (x == 1) {\n  x = 6;\n}\nelse {\n  x = 7;\n}\n```", "```\ncmp dword ptr [ebp-4], 0\njnz else_if\nmov dword ptr [ebp-4], 5\njmp short end\n\nelse_if:\n cmp dword ptr [ebp-4], 1\n jnz else\n mov dword ptr [ebp-4], 6\n jmp short end\n\nelse:\n mov dword ptr [ebp-4], 7\nend:\n```", "```\nmov dword ptr [ebp-4], 1\ncmp dword ptr [ebp-4], 0\njnz loc_40101C\nmov eax, [ebp-4]\nxor eax, 2\nmov [ebp-4], eax\njmp loc_401025\n\nloc_40101C:\n mov ecx, [ebp-4]\n xor ecx, 3\n mov [ebp-4], ecx\n\nloc_401025:\n```", "```\nmov dword ptr [x], 1\ncmp dword ptr [x], 0  ➊\njnz loc_40101C  ➋\nmov eax, [x]  ➍\nxor eax, 2\nmov [x], eax\njmp loc_401025  ➌\n\nloc_40101C:  \nmov ecx, [x]  ➎\nxor ecx, 3  \nmov [x], ecx   ➏  \n\nloc_401025:\n\n```", "```\nmov dword ptr [x], 1  ➐\ncmp dword ptr [x], 0  ➊\njnz else  ➋\nmov eax, [x]  ➍\nxor eax, 2\nmov [x], eax  ➑\njmp end  ➌\n\nelse:\nmov ecx, [x]  ➎\nxor ecx, 3\nmov [x], ecx  ➏\nend:\n```", "```\nx = 1\nif(x == 0)\n{\n  eax = x\n  eax = eax ^ 2  ➒\n  x = eax  ➒\n} \nelse {\n ecx = x\n ecx = ecx ^ 3  ➒\n x = ecx  ➒\n}\n```", "```\nx = 1\nif(x == 0)\n{\n  eax = x  ➓\n  eax = x ^ 2  ➓\n  x = x ^ 2\n} \nelse {\n  ecx = x  ➓\n  ecx = x ^ 3  ➓\n  x = x ^ 3\n}\n```", "```\nx = 1;\nif(x == 0)\n{\n  x = x ^ 2;\n} \nelse {\n  x = x ^ 3;\n}\n```", "```\nint a = 1;\nif (a == 0) \n{\n    a = a ^ 2;\n}\nelse {\n    a = a ^ 3;\n}\n```", "```\nfor (initialization; condition; update_statement ) {\n    block of code\n}\n```", "```\ninitialization\nwhile (condition)\n{\n    block of code\n    update_statement\n}\n```", "```\nint i;\nfor (i = 0; i < 5; i++) {\n}\n```", "```\nint i = 0;\nwhile (i < 5) { \n    i++;\n}\n```", "```\n  mov [i],0  ➍\n\nwhile_start:\n  cmp [i], 5  ➋\n  jge end  ➌\n  mov eax, [i]\n  add eax, 1\n  mov [i], eax\n  jmp while_start  ➊\nend:\n```", "```\n mov dword ptr [ebp-8], 0\n mov dword ptr [ebp-4], 0\n\nloc_401014:\n cmp dword ptr [ebp-4], 4\n cmp dword ptr [ebp-4], 4\n jge loc_40102E\n mov eax, [ebp-8]\n add eax, [ebp-4]\n mov [ebp-8], eax\n mov ecx, [ebp-4]\n add ecx, 1\n mov [ebp-4], ecx\n jmp loc_401014\n\nloc_40102E:\n```", "```\n mov dword ptr [y], 1\n mov dword ptr [x], 0\n\nloc_401014:\n cmp dword ptr [x], 4  ➋\n jge loc_40102E  ➌ \n mov eax, [y]\n add eax, [x]\n mov [y], eax\n mov ecx, [x]  ➎\n add ecx, 1\n mov [x], ecx  ➏\n jmp loc_401014 ➊ \n\nloc_40102E:  ➍\n```", "```\ny = 1\nx = 0\nwhile (x<4) {\neax = y\neax = eax + x  ➐\ny = eax  ➐\necx = x\necx = ecx + 1  ➐\nx = ecx  ➐\n}\n```", "```\ny = 1\nx = 0\nwhile (x<4) {\neax = y  ➑\neax = y + x  ➑\ny = y + x\necx = x  ➑\necx = x + 1  ➑\nx = x + 1\n}\n```", "```\ny = 1;\nx = 0;\nwhile (x<4) {\ny = y + x;\nx = x + 1;\n}\n```", "```\nint a = 1;\nint i = 0;\nwhile (i < 4) {\na = a + i;\ni++;\n}\n```", "```\npush source     ; pushes source on top of the stack\npop destination ; copies value from the top of the stack to the destination\n```", "```\npush 3\npush 4\npop ebx\npop edx\n```", "```\ncall <some_function>\n```", "```\nint test(int a, int b)\n{ \n    int x, y; \n    x = a; \n    y = b;        \n    return 0;\n}\n\nint main()\n{ \n   test(2, 3); \n   return 0; \n}\n```", "```\npush 3  ➊\npush 2  ➋\ncall test  ➌\nadd esp, 8 ; after test is exectued, the control is returned here\nxor eax, eax\n```", "```\nint test(int a, int b)\n{ \n   int x, y; \n   x = a; \n   y = b;        \n   return 0;\n}\n```", "```\npush ebp  ➍\nmov ebp, esp  ➎\nsub esp, 8  ➑\nmov eax, [ebp+8]\nmov [ebp-4], eax\nmov ecx, [ebp+0Ch]\nmov [ebp-8], ecx\nxor eax, eax  ➒\nmov esp, ebp  ➏\npop ebp  ➐\nret  ➓\n```", "```\nmov eax, [ebp+8]\nmov [ebp-4], eax\nmov ecx, [ebp+0Ch]\nmov [ebp-8], ecx\n```", "```\nmov eax, [a]\nmov [x], eax\nmov ecx, [b]\nmov [y], ecx\n```", "```\nx = a\ny = b\n```", "```\nint nums[3] = {1, 2, 3}\n```", "```\nnums[0] = [nums+0*4] = [0x4000+0*4] = [0x4000] = 1\nnums[1] = [nums+1*4] = [0x4000+1*4] = [0x4004] = 2\nnums[2] = [nums+2*4] = [0x4000+2*4] = [0x4008] = 3\n```", "```\n\nnums[i] = nums+i*4\n```", "```\n[base_address + index * size of element]\n```", "```\npush ebp\nmov ebp, esp\nsub esp, 14h\nmov dword ptr [ebp-14h], 1\nmov dword ptr [ebp-10h], 2\nmov dword ptr [ebp-0Ch], 3\nmov dword ptr [ebp-4], 0\n\nloc_401022:\n cmp dword ptr [ebp-4], 3\n jge loc_40103D\n mov eax, [ebp-4]\n mov ecx, [ebp+eax*4-14h]\n mov [ebp-8], ecx\n mov edx, [ebp-4]\n add edx, 1\n mov [ebp-4], edx\n jmp loc_401022\n\nloc_40103D:\n xor eax, eax\n mov esp, ebp\n pop ebp\n ret\n```", "```\n1\\. mov dword ptr [ebp-14h], 1\n2\\. mov dword ptr [ebp-10h], 2  ➐\n3\\. mov dword ptr [ebp-0Ch], 3  ➑ \n4\\. mov dword ptr [ebp-4], 0  ➍\n\nloc_401022:  ➋\n5\\. cmp dword ptr [ebp-4], 3  ➌\n6\\. jge loc_40103D  ➌\n7\\. mov eax, [ebp-4]\n8\\. mov ecx, [ebp+eax*4-14h]  ➏\n9\\. mov [ebp-8], ecx\n10\\. mov edx, [ebp-4]  ➎\n11\\. add edx, 1  ➎ \n12\\. mov [ebp-4], edx  ➎\n13\\. jmp loc_401022  ➊\n\nloc_40103D:\n14\\. xor eax, eax\n15\\. ret\n```", "```\nval[0] = 1\nval[1] = 2\nval[2] = 3\ni = 0\nwhile (i<3) \n{\neax = i\necx = [val+eax*4]  ➒\n[ebp-8] = ecx  ➒\nedx = i\nedx = edx + 1  ➒\ni = edx  ➒\n}\nreturn 0\n```", "```\nval[0] = 1\nval[1] = 2\nval[2] = 3\ni = 0\nwhile (i<3) \n{\neax = i  ➓\necx = [val+i*4]  ➓\n[ebp-8] = [val+i*4]\nedx = i  ➓\nedx = i + 1  ➓\ni = i + 1\n}\nreturn 0\n```", "```\nval[0] = 1\nval[1] = 2\nval[2] = 3\ni = 0\nwhile (i<3) \n{\n[ebp-8] = [val+i*4]\ni = i + 1\n}\nreturn 0\n```", "```\nval[0] = 1\nval[1] = 2\nval[2] = 3\ni = 0\nwhile (i<3) \n{\nx = val[i]\ni = i + 1\n}\nreturn 0\n```", "```\nval[0] = 1\nval[1] = 2\nval[2] = 3\ni = 0\nwhile (i<3) \n{\nval[3] = val[i]\ni = i + 1\n}\nreturn 0\n```", "```\nint main()\n{\n  int a[3] = { 1, 2, 3 };\n  int b, i;\n  i = 0;\n   while (i < 3)\n   { \n     b = a[i]; \n     i++;\n   }\n  return 0;\n}\n```", "```\nchar *str = \"Let\"\n```", "```\nstr[0] = [str+0] = [0x4000+0] = [0x4000] = L\nstr[1] = [str+1] = [0x4000+1] = [0x4001] = e\nstr[2] = [str+2] = [0x4000+2] = [0x4002] = t\n```", "```\nstr[i] = [str+i]\n```", "```\n ➊ lea esi,[src] ; \"Good\",0x0\n ➋ lea edi,[dst]\n ➌ movsb\n```", "```\nlea esi,[src] ; \"Good\",0x0\nlea edi,[dst]\nmov ecx,5\nrep movsb\n```", "```\nmov eax, 0\nlea edi,[dest]\nmov ecx,5\nrep stosd\n```", "```\nstruct simpleStruct\n{\n  int a;\n  short int b;\n  char c;\n};\n\nvoid update(struct simpleStruct *test_stru_ptr) {\n test_stru_ptr->a = 6;\n test_stru_ptr->b = 7;\n test_stru_ptr->c = 'A';\n}\n\nint main()\n{\n struct simpleStruct test_stru;  ➊  \n update(&test_stru);  ➋\n return 0;\n}\n```", "```\npush ebp\nmov ebp, esp\nmov eax, [ebp+8]  ➌\nmov dword ptr [eax], 6  ➍\nmov ecx, 7\nmov [eax+4], cx  ➎\nmov byte ptr [eax+6], 41h  ➏\nmov esp,ebp\npop ebp\nret\n```", "```\nprintf(\"%d %d %d %d %d\", 1, 2, 3, 4, 5);\n```", "```\npush 5\npush 4\npush 3\npush 2\npush 1\npush offset Format ; \"%d %d %d %d %d\"\ncall ds:printf\nadd esp, 18h\n```", "```\nsub rsp, 38h  ➊ \nmov dword ptr [rsp+28h], 5  ➐\nmov dword ptr [rsp+20h], 4  ➏\nmov r9d, 3  ➎\nmov r8d, 2  ➍\nmov edx, 1  ➌\nlea rcx, Format ; \"%d %d %d %d %d\"  ➋\ncall cs:printf\n```"]