<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Disassembly Using IDA</h1>
                
            
            <article>
                
<p class="calibre2"><em class="calibre17">Code analysis</em> is often used to understand the inner workings of a malicious binary when the source code is unavailable. In the previous chapter, you learned the code analysis skills and techniques to interpret assembly code and to understand a program's functionality; the programs that we used were simple C programs, but when you are dealing with malware, it can contain thousands of lines of code and hundreds of functions, making it difficult to keep track of all of the variables and functions.</p>
<p class="calibre2">Code analysis tools offer various features to simplify code analysis. This chapter will introduce you to one such code analysis tool, named <em class="calibre17">IDA Pro (</em>also known as <em class="calibre17">IDA)</em>. You will learn how to leverage the features of IDA Pro to enhance your disassembly. Before we delve into the features of IDA, let's go over different code analysis tools.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1. Code Analysis Tools</h1>
                
            
            <article>
                
<p class="calibre2">Code analysis tools can be classified based on their functionalities, described below.</p>
<p class="calibre2">A <em class="calibre17">disassembler</em> is a program that translates machine code back to assembly code; it allows you to perform static code analysis. <em class="calibre17">Static code analysis</em> is a technique you can use to interpret the code to understand the program's behavior, without executing the binary.</p>
<p class="calibre2">A <em class="calibre17">debugger</em> is a program which also disassembles the code; apart from that, it allows you to execute the compiled binary in a controlled manner. Using debuggers, you can execute either a single instruction or selected functions, instead of executing the entire program. A Debugger allows you to perform <em class="calibre17">dynamic code analysis,</em> and helps you examine the aspects of the suspect binary while it is running.</p>
<p class="calibre2">A <em class="calibre17">decompiler</em> is a program that translates the machine code into the code in a high-level language (pseudocode). Decompilers can greatly assist you with the reverse engineering process and can simplify your work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2. Static Code Analysis (Disassembly) Using IDA</h1>
                
            
            <article>
                
<p class="calibre2"><em class="calibre17">Hex-Rays IDA Pro</em> is the most powerful and popular commercial disassembler/debugger (<a href="https://www.hex-rays.com/products/ida/index.shtml" target="_blank" class="calibre10">https://www.hex-rays.com/products/ida/index.shtml</a>); it is used by reverse engineers, malware analysts, and vulnerability researchers. IDA can run on various platforms (Windows, Linux, and macOS) and supports analysis of various file formats, including the <em class="calibre17">PE/ELF/Macho-O</em> formats. Apart from the commercial version, IDA is distributed in two other versions: <em class="calibre17">IDA demo version (evaluation version)</em> and <em class="calibre17">IDA Freeware version;</em> both these versions have certain limitations. You can download the <em class="calibre17">freeware version</em> of IDA for non-commercial use from <a href="https://www.hex-rays.com/products/ida/support/download_freeware.shtml" target="_blank" class="calibre10">https://www.hex-rays.com/products/ida/support/download_freeware.shtml</a>. At the time of writing this book, the distributed freeware version is IDA 7.0; it lets you disassemble both 32-bit and 64-bit Windows binary but you will not be able to debug the binary, using the free version. The <em class="calibre17">demo version (evaluation version)</em> of IDA can be requested by filling in a form (<a href="https://out7.hex-rays.com/demo/request" target="_blank" class="calibre10">https://out7.hex-rays.com/demo/request</a>); it lets you disassemble both 32-bit and 64-bit Windows binary, and you can debug 32-bit binary (but not 64-bit binary) with it. Another restriction in the demo version is that you will not able to save the database (covered later in this chapter). Both demo and freeware version lacks <em class="calibre17">IDAPython</em> support. The <em class="calibre17">commercial version</em> of IDA does not lack any functionality and comes with full-year free email support and upgrades.</p>
<p class="calibre2"><span class="calibre7">In this section and later sections, we will look at various features of IDA Pro, and you will learn how to use IDA to perform <em class="calibre17">static code analysis (disassembly)</em>. </span>It is not possible to cover all the features of IDA; only those features that are relevant to malware analysis will be covered in this chapter. If you are interested in gaining a deeper understanding of IDA Pro, it is recommended to the read the book, <em class="calibre17">The IDA Pro Book (2nd Edition)</em> by Chris Eagle. To get a better understanding of IDA, just load a binary and explore various features of IDA while you are reading this section and later sections. Remember the restrictions in various versions of IDA, if you are using the <em class="calibre17">commercial version</em> of IDA, you will be able to explore all the features covered in this book. If you are using the <em class="calibre17">demo version</em> you will be able to explore only the disassembly and debugging (32-bit binary only) features, but you will not be able to test <em class="calibre17">IDAPython</em> scripting capabilities. If you are using the <em class="calibre17">freeware version</em>, you will only be able to try out the disassembly features (no debugging and no IDAPython scripting). <span class="calibre7">I highly recommend using either the </span><em class="calibre17">commercial version</em><span class="calibre7"> or the </span><em class="calibre17">demo version</em><span class="calibre7"> of IDA, using these versions you will be able to try out all/most of the features covered in this book.</span> If you wish to look at an alternate tool for debugging 32-bit and 64-bit binary, you can use <em class="calibre17">x64dbg</em> (an open source x64/x86 debugger), which is covered in the next chapter. With an understanding of different versions of IDA, let'us, now explore its features, and you will understand how it can speed up your reverse engineering and malware analysis tasks. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.1 Loading Binary in IDA</h1>
                
            
            <article>
                
<p class="calibre2">To load an executable, Launch IDA Pro (right-click and select <span class="calibre7">Run as administrator</span>). When you launch IDA, it will briefly display a screen showing your license information; immediately after that, you will be presented with the following screen. Choose <span class="calibre7">New</span> and select the file you wish to analyze. If you select <span class="calibre7">Go</span>, IDA will open the empty workspace. To load a file, you can either drag and drop or click on <span class="calibre7">File</span> | <span class="calibre7">Open</span> and select the file:</p>
<div class="cdpaligncenter"><img src="../images/00092.jpeg" class="calibre95"/></div>
<p class="calibre2">The file that you give to IDA will be loaded into the memory (IDA acts like a Windows loader). To load the file into the memory, IDA determines the best possible loaders, and from the file header, it determines the processor type that should be used during the disassembly process. After you select the file,  IDA shows the loading dialog (as shown in the following screenshot). From the screenshot, it can be seen that IDA determined the appropriate loaders (<kbd class="calibre13">pe.ldw</kbd> and <kbd class="calibre13">dos.ldw</kbd>) and the processor type. The <span class="calibre7">Binary file</span> option (if you are using the IDA demo version, you will not see this option) is used by the IDA to load the files that it does not recognize. You will normally use this option when you are dealing with a shellcode. By default, IDA does not load the <em class="calibre17">PE headers</em> and the <em class="calibre17">resource</em> section in the disassembly. By using the <span class="calibre7">manual load</span> checkbox option, you can manually specify the base address where the executable has to be loaded, and IDA will prompt you on whether you want to load each section, including the PE headers:</p>
<div class="cdpaligncenter"><img src="../images/00093.jpeg" class="calibre96"/></div>
<p class="calibre2">After you click <span class="calibre7">OK</span>, IDA loads the file into memory, and the disassembly engine disassembles the machine code. After the disassembly, IDA performs an initial analysis to identify the compiler, function arguments, local variables, library functions, and their parameters. Once the executable has been loaded, you will be taken to the IDA desktop, showing the disassembled output of the program. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2 Exploring IDA Displays</h1>
                
            
            <article>
                
<p class="calibre2">The IDA desktop integrates the features of many common static analysis tools into a single interface. This section will give you an understanding of the IDA desktop and its various windows. The following screenshot shows the IDA desktop after loading an executable file. The IDA desktop contains multiple tabs (<span class="calibre7">IDA View-A</span><strong class="calibre5">,</strong> <span class="calibre7">Hex View-1</span>, and so on); clicking on each tab brings up a different window. Each window contains different information extracted from the binary. You can also add additional tabs via the<span class="calibre7"> View | Open Subviews</span> menu:</p>
<div class="cdpaligncenter"><img src="../images/00094.jpeg" class="calibre97"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2.1 Disassembly Window</h1>
                
            
            <article>
                
<p class="calibre2">After the executable has been loaded, you will be presented with the disassembly window (also known as the <span class="calibre7">IDA-view</span> window). This is the primary window, and it displays the disassembled code. You will mostly be using this window for analyzing binaries.</p>
<p class="calibre2">IDA can show the disassembled code in two display modes: G<em class="calibre17">raph view</em> and T<em class="calibre17">ext view</em>. <em class="calibre17">Graph view</em> is the default view, and when the disassembly view (<span class="calibre7">IDA-view</span>) is active, you can switch between the graph and text views by pressing the <span class="calibre7">spacebar</span> button.</p>
<p class="calibre2">In the graph view mode, IDA displays only one function at a time, in a flowchart-style graph, and the function is broken down into basic blocks. This mode is useful to quickly recognize <em class="calibre17">branching</em> and <em class="calibre17">looping</em> statements. In the graph view mode, the color and the direction of the arrows indicate the path that will be taken, based on a particular decision. The <em class="calibre17">conditional jumps</em> use <em class="calibre17">green</em> and <em class="calibre17">red</em> arrows; the <em class="calibre17">green</em> arrow indicates that the jump will be taken if the condition is true, and the <em class="calibre17">red</em> arrow indicates that the jump will not be taken (normal flow). The <em class="calibre17">blue</em> arrow is used for an <em class="calibre17">unconditional</em> jump, and the loop is indicated by the upward (backward) <em class="calibre17">blue</em> arrow. In the graph view, the virtual addresses are not displayed by default (this is to minimize the amount of space required to display each basic block). To display virtual address information, click on <span class="calibre7"><span class="calibre7"><span class="calibre7">Options</span></span> | General</span> and enable line prefixes.</p>
<p class="calibre2">The following screenshot shows the disassembly of the <kbd class="calibre13">main</kbd> function in the graph view mode. Notice the conditional check at the addresses <kbd class="calibre13">0x0040100B</kbd> and <kbd class="calibre13">0x0040100F</kbd>. If the condition is true, then the control is transferred to the address <kbd class="calibre13">0x0040101A</kbd> (indicated by a green arrow), and if the condition is false, the control gets transferred to <kbd class="calibre13">0x00401011</kbd> (indicated by a red arrow). In other words, the <em class="calibre17">green arrow</em> indicates jump and the <em class="calibre17">red arrow</em> indicates the normal flow:</p>
<div class="cdpaligncenter"><img src="../images/00095.jpeg" class="calibre98"/></div>
<p class="calibre2">In the <em class="calibre17">text view</em> mode, the entire disassembly is presented in a linear fashion. The following screenshot shows the text view of the same program; the virtual addresses are displayed by default, in the <kbd class="calibre13">&lt;section name&gt;:&lt;virtual address&gt;</kbd> format. The left-hand portion of the text view window is called the <em class="calibre17">arrows window</em>; it is used to indicate the program's nonlinear flow. The <em class="calibre17">dashed arrows</em> represent <kbd class="calibre13">conditional jumps</kbd>, the <em class="calibre17">solid arrows</em> indicate <kbd class="calibre13">unconditional jumps</kbd>, and the <em class="calibre17">backward arrows</em> (arrows facing up) indicate loops:</p>
<div class="cdpaligncenter"><img src="../images/00096.jpeg" class="calibre99"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2.2 Functions Window</h1>
                
            
            <article>
                
<p class="calibre2">The <em class="calibre17">functions window</em> displays all the functions recognized by IDA, and it also shows the virtual address where each function can be found, the size of each function, and various other properties of the function. You can double-click on any of these functions to jump to a selected function. Each function is associated with various flags (such as <kbd class="calibre13">R</kbd>, <kbd class="calibre13">F</kbd>, <kbd class="calibre13">L</kbd>, and so on). You can get more information about these flags in the help file (by pressing <em class="calibre17">F1</em>). One of the useful flags is the <kbd class="calibre13">L</kbd> flag, which indicates that the function is a <em class="calibre17">library function</em>. Library functions are compiler-generated and are not written by a malware author; from a code analysis perspective, we would be interested in analyzing the malware code, not the library code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2.3 Output Window</h1>
                
            
            <article>
                
<p class="calibre2">The <em class="calibre17">output window</em> displays the messages generated by IDA and the IDA plugins. These messages can give information about the analysis of the binary and the various operations that you perform. You can look at the contents of the output window to get an idea of various operations performed by IDA when an executable is loaded.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2.4 Hex View Window</h1>
                
            
            <article>
                
<p class="calibre2">You can click on the <span class="calibre7">Hex View-1</span> tab to display the <em class="calibre17">hex window</em>. The hex window displays a sequence of bytes in a hex dump and the ASCII format. By default, the hex window is synchronized with the disassembly window; this means, when you select any item in the disassembly window, the corresponding bytes are highlighted in the hex window. The hex window is useful to inspect the contents of the memory address.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2.5 Structures Window</h1>
                
            
            <article>
                
<p class="calibre2">Clicking on the <span class="calibre7">Structures</span> tab will bring up the structures window. The structures window lists the layout of the standard data structures used in the program, and it also allows you to create your own data structures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2.6 Imports Window</h1>
                
            
            <article>
                
<p class="calibre2">The <em class="calibre17">imports window</em> lists all of the functions imported by the binary. The following screenshot shows the imported functions and the shared libraries (DLL) from which these functions are imported. Detailed information about imports was covered in <a href="part0032.html#UGI00-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 2</a><em class="calibre17">, Static Analysis</em>:</p>
<div class="cdpaligncenter"><img src="../images/00097.jpeg" class="calibre100"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2.7 Exports Window</h1>
                
            
            <article>
                
<p class="calibre2">The <em class="calibre17">exports window</em> lists all of the exported functions. The exported functions are normally found in the DLLs, so this window can be useful when you are analyzing malicious DLLs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2.8 Strings Window</h1>
                
            
            <article>
                
<p class="calibre2">IDA does not show <em class="calibre17">strings window</em> by default; you can bring up the strings window by clicking on <span class="calibre7">View | Open Subviews | Strings</span> (or <em class="calibre17">Shift </em>+ <em class="calibre17">F12</em>). The strings window displays the list of strings extracted from the binary and the address where these strings can be found. By default, the strings window displays only the <em class="calibre17">null-terminated ASCII strings</em> of at least five characters in length. In <a href="part0032.html#UGI00-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 2</a><em class="calibre17">, Static Analysis</em>, we saw that a malicious binary can use <em class="calibre17">UNICODE strings</em>. You can configure IDA to display different types of strings; to do that, while you are in the strings window, right-click on<strong class="calibre5"> </strong><span class="calibre7">Setup</span> (or <em class="calibre17">Ctrl</em> + <em class="calibre17">U</em>), check <span class="calibre7">Unicode C-style (16 bits),</span> and click <span class="calibre7">OK</span><strong class="calibre5">.</strong>  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2.9 Segments Window</h1>
                
            
            <article>
                
<p class="calibre2">The segments window is available via <span class="calibre7">View</span> | <span class="calibre7">Open Subviews</span> | <span class="calibre7">Segments</span> (or <em class="calibre17">Shift</em> + <em class="calibre17">F7</em>). The segments window lists the sections (<kbd class="calibre13">.text</kbd>, <kbd class="calibre13">.data</kbd>, and so on) in the binary file. The displayed information contains the <em class="calibre17">start address</em>, the <em class="calibre17">end address</em>, and the <em class="calibre17">memory permissions</em> of each section. The start and end address specify the virtual address <span class="calibre7"><span class="calibre7">of each </span></span>section that is mapped into memory during runtime. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.3 Improving Disassembly Using IDA</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will explore various features of IDA, and you will learn how to combine the knowledge you gained in the previous chapter with the capabilities offered by IDA to enhance the disassembly process. Consider the following trivial program, which copies the content of one local variable to another:</p>
<pre class="calibre18">int main()<br class="title-page-name"/>{<br class="title-page-name"/>  int x = 1;<br class="title-page-name"/>  int y;<br class="title-page-name"/>  y = x;<br class="title-page-name"/>  return 0;<br class="title-page-name"/>}</pre>
<p class="calibre2">After compiling the preceding code and loading it in IDA, the program disassembles to the following:</p>
<pre class="calibre18">.text:00401000 ; Attributes: bp-based frame ➊<br class="title-page-name"/>.text:00401000<br class="title-page-name"/>.text:00401000 ; ➋ int __cdecl main(int argc, const char **argv, const char **envp)<br class="title-page-name"/>.text:00401000  ➐ _main proc near<br class="title-page-name"/>.text:00401000<br class="title-page-name"/>.text:00401000    var_8= dword ptr -8  ➌<br class="title-page-name"/>.text:00401000    var_4= dword ptr -4  ➌<br class="title-page-name"/>.text:00401000    argc= dword ptr 8   ➌<br class="title-page-name"/>.text:00401000    argv= dword ptr 0Ch  ➌<br class="title-page-name"/>.text:00401000    envp= dword ptr 10h  ➌<br class="title-page-name"/>.text:00401000<br class="title-page-name"/>.text:00401000    push ebp  ➏<span> </span><span> </span><span> </span><br class="title-page-name"/>.text:00401001    mov ebp, esp  ➏<br class="title-page-name"/>.text:00401003    sub esp, 8  ➏<span><br class="title-page-name"/></span>.text:00401006    mov ➍ [ebp+var_4], 1<br class="title-page-name"/>.text:0040100D    mov eax, [ebp+var_4] ➍<br class="title-page-name"/>.text:00401010    mov ➎ [ebp+var_8], eax<br class="title-page-name"/>.text:00401013    xor eax, eax <br class="title-page-name"/>.text:00401015    mov esp, ebp  ➏<br class="title-page-name"/>.text:00401017    pop ebp  ➏<br class="title-page-name"/>.text:00401018    retn</pre>
<p class="calibre2">When an executable is loaded, IDA performs an analysis on every function that it disassembles to determine the layout of the <em class="calibre17">stack frame</em>. Apart from that, it uses various signatures and runs pattern matching algorithms to determine whether a disassembled function matches any of the signatures known to IDA. At ➊, notice how after performing initial analysis, IDA added a comment (the comment starts with a semicolon), that tells you that an <kbd class="calibre13">ebp</kbd> based stack frame is used; this means that the <kbd class="calibre13">ebp</kbd> register is used to reference the local variables and the function parameters (the details regarding <kbd class="calibre13">ebp</kbd> based stack frames were covered while discussing functions in the previous chapter). At ➋, IDA used its robust detection to identify the function as the <kbd class="calibre13">main</kbd> function and inserted the <kbd class="calibre13">function prototype</kbd> comment. During analysis this feature can be useful to determine, how many parameters are accepted by a function, and their data types.</p>
<p class="calibre2">At ➌<span class="calibre7">, IDA gives you a summary of the stack view; IDA was able to identify the <em class="calibre17">local variables</em> and <em class="calibre17">function arguments</em>. In the <kbd class="calibre13">main</kbd> function, IDA identified two local variables, which are automatically named as <kbd class="calibre13">var_4</kbd> and <kbd class="calibre13">var_8.</kbd> IDA also tells you that <kbd class="calibre13">var_4</kbd> corresponds to the value <kbd class="calibre13">-4</kbd>, and <kbd class="calibre13">var_8</kbd> corresponds to the value <kbd class="calibre13">-8</kbd>. The <kbd class="calibre13">-4</kbd> and <kbd class="calibre13">-8</kbd> specify the offset distance from the <kbd class="calibre13">ebp</kbd> (<em class="calibre17">frame pointer</em>); this is IDA's way of saying that it has replaced <kbd class="calibre13">var_4</kbd> for <kbd class="calibre13">-4</kbd> and <kbd class="calibre13">var_8</kbd> for <kbd class="calibre13">-8</kbd> in the code. Notice the instructions at ➍,and ➎ you can see that IDA replaced the memory reference <kbd class="calibre13">[ebp-4]</kbd> with <kbd class="calibre13">[ebp+var_4]</kbd> and <kbd class="calibre13">[ebp-8]</kbd> with <kbd class="calibre13">[ebp+var_8]</kbd>.</span></p>
<p class="calibre2">If IDA had not replaced the values, then the instructions at ➍, and ➎ would look like the ones shown here, and you'd have to manually label all of these addresses (as covered in the previous chapter). </p>
<pre class="calibre18">.text:00401006    mov dword ptr [ebp-4], 1<br class="title-page-name"/>.text:0040100D    mov eax, [ebp-4]<br class="title-page-name"/>.text:00401010    mov [ebp-8], eax</pre>
<p class="calibre2">The IDA automatically generated <em class="calibre17">dummy names</em> for the variables/arguments and used these names in the code; this saved the manual work of labeling the addresses and made it easy to recognize the local variables and arguments because of the <kbd class="calibre13">var_xxx</kbd> and <kbd class="calibre13">arg_xxx</kbd> prefixes added by IDA. You can now treat the <kbd class="calibre13">[ebp+var_4]</kbd> at ➍ as just <kbd class="calibre13">[var_4]</kbd>, so the instruction <kbd class="calibre13">mov [ebp+var_4],1</kbd> can be treated as <kbd class="calibre13">mov [var_4],1</kbd>, and you can read it as <kbd class="calibre13">var_4</kbd> being assigned the value <kbd class="calibre13">1</kbd> (in other words, <kbd class="calibre13">var_4 = 1</kbd>). Similarly, the instruction <kbd class="calibre13">mov [ebp+var_8],eax</kbd> can be treated as <kbd class="calibre13">mov [var_8],eax</kbd> (in other words, <kbd class="calibre13">var_8 = eax</kbd>); this feature of IDA makes reading assembly code much easier.</p>
<p class="calibre2">The preceding program can be simplified by ignoring <kbd class="calibre13">function prologue</kbd>, <kbd class="calibre13">function epilogue</kbd>, and the instructions used to allocate space for the local variables at ➏. From the concepts covered in the previous chapter, we know that these instructions are just used for setting up the function environment. After the cleanup, we are left with the following code:</p>
<pre class="calibre18">.text:00401006    mov [ebp+var_4], 1<br class="title-page-name"/>.text:0040100D    mov eax, [ebp+var_4]<br class="title-page-name"/>.text:00401010    mov [ebp+var_8], eax<br class="title-page-name"/>.text:00401013    xor eax, eax<br class="title-page-name"/>.text:00401018    retn</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.3.1 Renaming Locations</h1>
                
            
            <article>
                
<p class="calibre2">So far, we have seen how IDA performs analysis on our program and how it adds <em class="calibre17">dummy names</em>. The dummy names are useful, but these names do not tell the purpose of a variable. When analyzing malware, you should change the variable/function names to more meaningful names. To rename a variable or an argument, right-click on the variable name or argument and select <span class="calibre7">rename</span> (or press <em class="calibre17">N</em>); this will bring up the following dialog. After you rename it, IDA will propagate the new name to wherever that item is referenced. You can use the rename feature to give meaningful names to the functions, and variables:</p>
<div class="cdpaligncenter"><img src="../images/00098.jpeg" class="calibre101"/></div>
<p class="calibre2">Changing the name of <kbd class="calibre13">var_4</kbd> to <kbd class="calibre13">x</kbd> and <kbd class="calibre13">var_8</kbd> to <kbd class="calibre13">y</kbd> in the preceding code would result in the new listing shown here:</p>
<pre class="calibre18">.text:00401006    mov [ebp+x], 1<br class="title-page-name"/>.text:0040100D    mov eax, [ebp+x]<br class="title-page-name"/>.text:00401010    mov [ebp+y], eax<br class="title-page-name"/>.text:00401013    xor eax, eax<br class="title-page-name"/>.text:00401018    retn</pre>
<p class="calibre2">You can now translate the preceding instructions to pseudocode (as covered in the previous chapter). To do that, let's make use of the comment feature in IDA.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.3.2 Commenting in IDA</h1>
                
            
            <article>
                
<p class="calibre2">Comments are useful to remind you of something important in the program. To add a regular comment, place the cursor on any line in the disassembly listing, and press the hotkey <em class="calibre17">colon</em> (<em class="calibre17">:</em>), this will bring up the comment entry dialog where you can enter the comments. The following listing shows the comments (starting with <kbd class="calibre13">;</kbd>) describing individual instructions:</p>
<pre class="calibre18">.text:00401006    mov [ebp+x], 1     ; x = 1<br class="title-page-name"/>.text:0040100D    mov eax, [ebp+x]   ; eax = x<br class="title-page-name"/>.text:00401010    mov [ebp+y], eax   ; y = eax<br class="title-page-name"/>.text:00401013    xor eax, eax       ; return 0<br class="title-page-name"/>.text:00401018    retn</pre>
<p class="calibre2">The regular comments are particularly useful for describing a single line (even though you can enter multiple lines), but it would be great if we could group the preceding comments together to describe what the <kbd class="calibre13">main</kbd> function does. IDA offers another type of comments called <em class="calibre17">function comments</em>, which allow you to group comments and display them at the top of the function's disassembly listing. To add a function comment, highlight the function name, such as <kbd class="calibre13">_main</kbd> shown at ➐ in the previous disassembly listing, and press colon (:). The following shows the pseudocode added at the top of the <kbd class="calibre13">_main</kbd> function at ➑ as <span class="calibre7">a result of using a function comment. The pseudocode can now remind you of the function's behavior:</span></p>
<pre class="calibre18">.text:00401000    ; x = 1  ➑<br class="title-page-name"/>.text:00401000    ; y = x  ➑<br class="title-page-name"/>.text:00401000    ; return 0 ➑<br class="title-page-name"/>.text:00401000    ; Attributes: bp-based frame<br class="title-page-name"/>.text:00401000<br class="title-page-name"/>.text:00401000    ; int __cdecl main(int argc, const char **argv, const char **envp)<br class="title-page-name"/>.text:00401000    _main proc near ; CODE XREF: ___tmainCRTStartup+194p</pre>
<p class="calibre2">Now that we have used some of IDA's features to analyze the binary, wouldn't it be nice if there was a way to save the name of the variable and the comments that we added, so that next time, when you load the same binary into IDA, you don't have to follow these steps all over again?. In fact, whatever manipulation was done earlier (like renaming or adding a comment) was done to the database, not to the executable; in the next section, you will learn how easy it is to save the database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.3.3 IDA Database</h1>
                
            
            <article>
                
<p class="calibre2">When an executable is loaded into IDA, it creates a database consisting of five files (whose extensions are <kbd class="calibre13">.id0</kbd>, <kbd class="calibre13">.id1</kbd>, <kbd class="calibre13">.nam</kbd>, <kbd class="calibre13">.id2</kbd>, and <kbd class="calibre13">.til</kbd>) in the working directory. Each of these files stores various information and has a base name that matches the selected executable. These files are archived and compressed into a database file with a <kbd class="calibre13">.idb</kbd> (for 32-bit binary) or <kbd class="calibre13">.i64</kbd> (for 64-bit binary) extension. Upon loading the executable, the database is created and populated with the information from the executable files. The various displays that are presented to you are simply views into the database that gives information in a format that is useful for code analysis. Any modifications that you make <span class="calibre7">(such as <em class="calibre17">renaming</em>, <em class="calibre17">commenting</em>, and so on) </span>are reflected in the views and saved in the database, but these changes do not modify the original executable file. You can save the database by closing IDA; when you close IDA, you will be presented with a <span class="calibre7">Save database</span> dialog, as shown in the following screenshot. The <span class="calibre7">Pack database</span> option (the default option) archives all of the files into a single IDB (<kbd class="calibre13">.idb</kbd>) or i64 (<kbd class="calibre13">.i64</kbd>) file. When you reopen the <kbd class="calibre13">.idb</kbd> or <kbd class="calibre13">.i64</kbd> file, you should be able to see the renamed variables and comments:</p>
<div class="cdpaligncenter"><img src="../images/00099.jpeg" class="calibre102"/></div>
<p class="calibre2">Let's look at another simple program and explore a few more features of IDA. The following program consists of the global variables <kbd class="calibre13">a</kbd> and <kbd class="calibre13">b</kbd>, which are assigned values inside of the <kbd class="calibre13">main</kbd> function. The variables <kbd class="calibre13">x</kbd>, <kbd class="calibre13">y</kbd>, and <kbd class="calibre13">string</kbd> are local variables; <kbd class="calibre13">x</kbd> holds the value of <kbd class="calibre13">a</kbd>, whereas <kbd class="calibre13">y</kbd> and <kbd class="calibre13">string</kbd> hold the addresses:</p>
<pre class="calibre18">int a;<br class="title-page-name"/>char b;<br class="title-page-name"/>int main()<br class="title-page-name"/>{<br class="title-page-name"/>   a = 41;<br class="title-page-name"/>   b = 'A';<br class="title-page-name"/>   int x = a;<br class="title-page-name"/>   int *y = &amp;a;<br class="title-page-name"/>   char *string = "test";<br class="title-page-name"/>   return 0;<br class="title-page-name"/>}</pre>
<p class="calibre2">The program translates to the following disassembly listing. IDA identified three local variables at ➊ and propagated this information in the program. IDA also identified the global variables and assigned names such as <kbd class="calibre13">dword_403374</kbd> and <kbd class="calibre13">byte_403370</kbd>; note how the fixed memory addresses are used to reference the global variables at ➋, ➌, and ➍. The reason for that, is when a variable is defined in the global data area, the address and size of the variables are known to the compiler at compile time. The dummy global variable names assigned by IDA specify the addresses of the variables and what types of data they contain. For example, <kbd class="calibre13">dword_403374</kbd> tells you that the address <kbd class="calibre13">0x403374</kbd> can contain a <kbd class="calibre13">dword</kbd> value (4 bytes); similarly, <kbd class="calibre13">byte_403370</kbd> tells you that <kbd class="calibre13">0x403370</kbd> can hold a single <kbd class="calibre13">byte</kbd> value.</p>
<p class="calibre2">IDA used the <kbd class="calibre13">offset</kbd> keyword at ➎ and ➏ to indicate that addresses of variables are used (rather than the content of the variables), and because addresses are assigned to the local variables <kbd class="calibre13">var_8</kbd> and <kbd class="calibre13">var_C</kbd> at ➎<span class="calibre7"> and ➏</span>, you can tell that <kbd class="calibre13">var_8</kbd> and <kbd class="calibre13">var_C</kbd> hold addresses (<kbd class="calibre13">pointer</kbd> variables). At ➏, IDA assigned the dummy name <kbd class="calibre13">aTest</kbd> to the address containing the string (string variable). This dummy name is generated using the characters of the string, and the string <kbd class="calibre13">"test"</kbd> itself is added as a <kbd class="calibre13">comment</kbd>, to indicate that the address contains the string:</p>
<pre class="calibre18">.text:00401000    var_C= dword ptr -0Ch  ➊ <br class="title-page-name"/>.text:00401000    var_8= dword ptr -8  ➊ <br class="title-page-name"/>.text:00401000    var_4= dword ptr -4  ➊ <br class="title-page-name"/>.text:00401000    argc= dword ptr 8<br class="title-page-name"/>.text:00401000    argv= dword ptr 0Ch<br class="title-page-name"/>.text:00401000    envp= dword ptr 10h<br class="title-page-name"/>.text:00401000<br class="title-page-name"/>.text:00401000    push ebp<br class="title-page-name"/>.text:00401001    mov ebp, esp<br class="title-page-name"/>.text:00401003    sub esp, 0Ch<br class="title-page-name"/>.text:00401006    mov ➋ dword_403374, 29h  <br class="title-page-name"/>.text:00401010    mov ➌ byte_403370, 41h  <br class="title-page-name"/>.text:00401017    mov eax, dword_403374  ➍ <br class="title-page-name"/>.text:0040101C    mov [ebp+var_4], eax<br class="title-page-name"/>.text:0040101F    mov [ebp+var_8], offset dword_403374  ➎ <br class="title-page-name"/>.text:00401026    mov [ebp+var_C], offset aTest ; "test"  ➏<br class="title-page-name"/>.text:0040102D    xor eax, eax<br class="title-page-name"/>.text:0040102F    mov esp, ebp<br class="title-page-name"/>.text:00401031    pop ebp<br class="title-page-name"/>.text:00401032    retn</pre>
<p class="calibre2">So far, in this program, we have seen how IDA helped by performing its analysis and by assigning dummy names to addresses (you can rename these addresses to more meaningful names using the rename option covered previously). In the next few sections, we will see what other features of IDA we can use to further improve the disassembly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.3.4 Formatting Operands</h1>
                
            
            <article>
                
<p class="calibre2">At ➋,<span class="calibre7"> </span>and ➌ in the preceding listing, the <span class="calibre7">operands (<kbd class="calibre13">29h</kbd> and <kbd class="calibre13">41h</kbd>) are represented as</span> hexadecimal <span class="calibre7">constant values, whereas in the source code, we used the decimal value <kbd class="calibre13">41</kbd> and the character <kbd class="calibre13">'A'</kbd>. IDA gives you the ability to reformat constant values as a <kbd class="calibre13">decimal</kbd>, <kbd class="calibre13">octal</kbd>, or <kbd class="calibre13">binary</kbd> values. If the constant falls within the ASCII printable range, then you can also format the constant value as a <kbd class="calibre13">character</kbd>. For example, to change the format of <kbd class="calibre13">41h</kbd>, right-click on the constant value <kbd class="calibre13">(41h)</kbd></span>,<span class="calibre7"> after which you will be presented with different options, as shown in the following screenshot. Choose the ones that suit</span> your <span class="calibre7">needs:</span></p>
<div class="cdpaligncenter"><img src="../images/00100.jpeg" class="calibre103"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.3.5 Navigating Locations</h1>
                
            
            <article>
                
<p class="calibre2">Another great feature of IDA is that it makes navigating to anywhere within a program much easier. When a program is disassembled, IDA labels every location in the program, and double-clicking on the locations will jump the display to the selected location. In the preceding example, you can navigate to any of the named locations (such as <kbd class="calibre13">dword_403374</kbd>, <kbd class="calibre13">byte_403370</kbd>, and <kbd class="calibre13">aTest</kbd>) by double-clicking on them. For example, double-clicking on <kbd class="calibre13">aTest</kbd> at ➏ jumps the display to a virtual address in the <kbd class="calibre13">.data</kbd> section, shown as follows. Notice how IDA labeled the address <kbd class="calibre13">0x00403000</kbd>, containing the string <kbd class="calibre13">"test"</kbd>, as <kbd class="calibre13">aTest</kbd>:</p>
<pre class="calibre18">.data:00403000    aTest db 'test',0  ➐; DATA XREF: _main+26o</pre>
<p class="calibre2">Similarly, double-clicking on the address <kbd class="calibre13">dword_403374</kbd> relocates to the virtual address shown here:</p>
<pre class="calibre18">.data:00403374     dword_403374 dd ?    ➑; DATA XREF: _main+6w <br class="title-page-name"/>.data:00403374                       ➒; _main+17r ... </pre>
<p class="calibre2">IDA keeps track of your navigation history; any time you navigate to a new location and would like to go back to your original position, you can use the navigation buttons. In the preceding example, to go back to the disassembly window, simply use the backward navigation button, as shown in the following screenshot:</p>
<div class="cdpaligncenter"><br class="title-page-name"/>
<img src="../images/00101.jpeg" class="calibre104"/></div>
<p class="calibre2">Sometimes, you will know the exact address you would like to navigate to. To jump to a particular address, click on <span class="calibre7">Jump</span> | <span class="calibre7">Jump to Address</span> (or press the <em class="calibre17">G</em> key); this will bring up the <span class="calibre7">Jump to address</span> dialog. Just specify the address and click on <span class="calibre7">OK</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.3.6 Cross-References</h1>
                
            
            <article>
                
<p class="calibre2">Another way to navigate is by using <em class="calibre17">cross-references</em> (also referred to as <em class="calibre17">Xrefs</em>). The cross-references link relates addresses together. Cross-references can be either <em class="calibre17">data cross-references</em> or <em class="calibre17">code cross-references</em>.</p>
<p class="calibre2">A <em class="calibre17">data cross-reference</em> specifies how the data is accessed within a binary. An example of a data cross-reference is shown at ➐, ➑,<span class="calibre7"> and ➒</span><span class="calibre7">, in the preceding listing. For</span> example<span class="calibre7">, the data cross-references at ➑ </span>tell <span class="calibre7">us that this data is referenced by the instruction which is at the offset <kbd class="calibre13">0x6</kbd>, from the start of</span> the <kbd class="calibre13">_main</kbd> <span class="calibre7">function (in other words, the instruction at ➋). The character <kbd class="calibre13">w</kbd> indicates a <em class="calibre17">write cross-reference</em>; this tells us that the instruction writes content into this memory location (note that <kbd class="calibre13">29h</kbd> is written to this memory location at ➋). The character <kbd class="calibre13">r</kbd> at ➒ indicates a <em class="calibre17">read cross-reference</em>, which tells us that the instruction <kbd class="calibre13">_main+17</kbd> (in other words, the</span> instruction <span class="calibre7">at ➍) reads the content from this memory location. The ellipsis (<kbd class="calibre13">...</kbd>) at ➒ indicates that there are more cross-references, but they could not be displayed because of the display limit. Another type of data cross-reference is an <em class="calibre17">offset cross-reference</em> (indicated by character <kbd class="calibre13">o</kbd>), which indicates that the address of a location is being used, rather than the content. The arrays and strings (character arrays) are accessed using their start addresses, because of which the string data at ➐</span><span class="calibre7"> is marked as an offset</span> cross-reference<span class="calibre7">.</span></p>
<p class="calibre2">A <em class="calibre17">code cross-reference</em> indicates the control flow from one instruction to an another (such as <em class="calibre17">jump</em> or <em class="calibre17">function call</em>). The following displays a simple <kbd class="calibre13">if</kbd> statement in C:</p>
<pre class="calibre18">int x = 0;<br class="title-page-name"/>if (x == 0)<br class="title-page-name"/>{<br class="title-page-name"/>    x = 5;<br class="title-page-name"/>}<br class="title-page-name"/>x = 2;</pre>
<p class="calibre2">The program disassembles to the following listing. At ➊, note how the <kbd class="calibre13">equal to</kbd> (<kbd class="calibre13">==</kbd>) condition from the C code is reversed to <kbd class="calibre13">jnz</kbd> (which is an alias for <kbd class="calibre13">jne</kbd> or <kbd class="calibre13">jump, if not equal</kbd>); this is done to implement the branching from ➊ to ➋. You can read it as <kbd class="calibre13">if var_4 is not equal to 0</kbd>; then, the jump is taken to <kbd class="calibre13">loc_401018</kbd> (which is outside of the <kbd class="calibre13">if</kbd> block). The <em class="calibre17">jump cross-reference</em> comment is shown at the jump target ➌ in the following listing, to indicate that the control is transferred from an instruction, which is at the offset <kbd class="calibre13">0xF</kbd> from the start of the main function (in other words, ➊). The character <kbd class="calibre13">j</kbd> at the end signifies that the control was transferred as a result of the jump. You can simply double-click the cross-reference comment <kbd class="calibre13">(_Main+Fj)</kbd> to change the display to the referencing instruction at ➊:</p>
<pre class="calibre18">.text:00401004    mov [ebp+var_4], 0<br class="title-page-name"/>.text:0040100B    cmp [ebp+var_4], 0<br class="title-page-name"/>.text:0040100F    jnz short loc_401018 ➊<br class="title-page-name"/>.text:00401011    mov [ebp+var_4], 5<br class="title-page-name"/>.text:00401018<br class="title-page-name"/>.text:00401018    loc_401018:  ➌; CODE XREF: _main+Fj<br class="title-page-name"/>.text:00401018    ➋ mov [ebp+var_4], 2</pre>
<p class="calibre2">The preceding listing can be viewed in the graph view mode by pressing the <em class="calibre17">spacebar</em> key. The graph view is especially useful to get a visual representation of <em class="calibre17">branching/looping</em> statements. As mentioned before, the <em class="calibre17">green arrow</em> indicates that the jump is taken (the condition is satisfied), the <em class="calibre17">red arrow</em> indicates that the jump is not taken, and the <em class="calibre17">blue arrow</em> indicates the normal path:</p>
<div class="cdpaligncenter"><img src="../images/00102.jpeg" class="calibre105"/></div>
<p class="calibre2">Now, to understand the <em class="calibre17">function cross-reference</em>, consider the following C code, which calls the <kbd class="calibre13">test()</kbd> function within <kbd class="calibre13">main()</kbd>:</p>
<pre class="calibre18">void test() { }<br class="title-page-name"/>void main() {<br class="title-page-name"/>    test();<br class="title-page-name"/>}</pre>
<p class="calibre2">The following is the disassembly listing of the <kbd class="calibre13">main</kbd> function. The <kbd class="calibre13">sub_401000</kbd> at <span class="calibre7">➊</span> represents the <kbd class="calibre13">test</kbd> function. IDA automatically named the function address with the <kbd class="calibre13">sub_</kbd> prefix, to indicate a <em class="calibre17">subroutine ( Or function)</em>. For example, when you see <kbd class="calibre13">sub_401000</kbd>, you can read it as a subroutine at the address <kbd class="calibre13">0x401000</kbd> (you can also rename it to a more meaningful name). If you wish, you can navigate to the function by double-clicking on the function name:</p>
<pre class="calibre18">.text:00401010    push ebp<br class="title-page-name"/>.text:00401011    mov ebp, esp<br class="title-page-name"/>.text:00401013    call sub_401000 ➊<br class="title-page-name"/>.text:00401018    xor eax, eax</pre>
<p class="calibre2">At the start of the <kbd class="calibre13">sub_401000</kbd> (<kbd class="calibre13">test</kbd> function), a code cross-reference comment was added by IDA, ➋, to indicate that this function, <kbd class="calibre13">sub_401000</kbd>, was called from an instruction which is at the offset <kbd class="calibre13">3</kbd> from the start of the <kbd class="calibre13">_main</kbd> function (that is called from ➊). You can navigate to the <kbd class="calibre13">_main</kbd> function simply by double-clicking <kbd class="calibre13">_main+3p</kbd>. The <kbd class="calibre13">p</kbd> suffix signifies that the control is transferred to the address <kbd class="calibre13">0x401000</kbd> as a result of the <em class="calibre17">function (procedure)</em> call:</p>
<pre class="calibre18">.text:00401000    sub_401000    proc near ➋; CODE XREF: _main+3p<br class="title-page-name"/>.text:00401000                  push ebp<br class="title-page-name"/>.text:00401001                  mov ebp, esp<br class="title-page-name"/>.text:00401003                  pop ebp<br class="title-page-name"/>.text:00401004                  retn<br class="title-page-name"/>.text:00401004    sub_401000    endp</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.3.7 Listing All Cross-References</h1>
                
            
            <article>
                
<p class="calibre2"><em class="calibre17">Cross-references</em> are very useful when analyzing malicious binary. During analysis, if you come across a <em class="calibre17">string</em> or a <em class="calibre17">useful function</em> and if you would like to know how they are used in the code, then you can use cross-references to quickly navigate to the location where the string or function is referenced. Cross-reference comments added by IDA are a great way to navigate between addresses, but there is a display limit (of two entries); as a result, you will not be able to see all of the cross-references. Consider the following data cross-reference at ➊; the <span class="calibre7">ellipsis</span> (<kbd class="calibre13">...</kbd>) <span class="calibre7">indicates that there are more cross-references:</span></p>
<pre class="calibre18">.data:00403374 dword_403374      dd ?          ; DATA XREF: _main+6w <br class="title-page-name"/>.data:00403374                                 ; _main+17r ... ➊</pre>
<p class="calibre2">Suppose that you want to list all of the cross-references; just click on the named location such as <kbd class="calibre13">dword_403374</kbd> and press the <em class="calibre17">X</em> key. This will bring up a window, that lists all the locations where the named location is referenced, as follows. You can double-click on any of these entries to reach the location in the program where the data is used. You can use this technique to find all of the cross-references to a <em class="calibre17">string</em> or <em class="calibre17">function</em>:</p>
<div class="cdpaligncenter"><img src="../images/00103.jpeg" class="calibre106"/></div>
<p class="calibre2">A program normally contains many functions. A single function can be called by single/multiple functions, or it can, in turn, call single or multiple functions. When performing malware analysis, you might be interested in getting a quick overview of a function. In such a case, you can highlight the function name and choose <span class="calibre7">View</span> | <span class="calibre7">Open Subviews</span> | <span class="calibre7">Function Calls</span> to get the function cross-references. The following screenshot shows the function <em class="calibre17">Xrefs</em> for the function <kbd class="calibre13">sub_4013CD</kbd> (from a malware sample). The upper half of the window tells you that the function <kbd class="calibre13">sub_401466</kbd> calls <kbd class="calibre13">sub_4013CD.</kbd> The lower half of the window displays all of the functions that will be called by <kbd class="calibre13">sub_4013CD</kbd>; notice that the lower window displays the API functions (<kbd class="calibre13">CreateFile</kbd> and <kbd class="calibre13">WriteFile</kbd>) that will be called by <kbd class="calibre13">sub_4013CD</kbd>;  based on this information, you can tell that the <kbd class="calibre13">sub_4013CD</kbd> function interacts with the filesystem:</p>
<div class="cdpaligncenter"><img src="../images/00104.jpeg" class="calibre107"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.3.8 Proximity View And Graphs</h1>
                
            
            <article>
                
<p class="calibre2">IDA's graphing options are a great way to visualize cross-references. Apart from the graph view shown previously, you can use the IDA's integrated graphing feature, called <em class="calibre17">proximity view</em>, to display the callgraph of a program. To view the callgraph of the function <kbd class="calibre13">sub_4013CD</kbd> from the previous example, while placing the cursor anywhere inside the function, click <span class="calibre7">View</span> | <span class="calibre7">Open subviews</span> | <span class="calibre7">Proximity browser</span>; this will change the view in the disassembly window to the proximity view, shown as follows. In proximity view, functions and data references are represented as nodes, and the cross-references between them are represented as edges (the lines that connect the nodes). The following graph displays <em class="calibre17">Xrefs to</em> and <em class="calibre17">Xrefs from</em> <kbd class="calibre13">sub_4013CD</kbd>. The parent of <kbd class="calibre13">sub_4013CD</kbd> (which is <kbd class="calibre13">sub_401466</kbd>) represents its calling function, and the functions called by <kbd class="calibre13">sub_4013CD</kbd> are represented as children. You can further drill down the parent/child relationship (<em class="calibre17">Xrefs to and from)</em> by double-clicking the <em class="calibre17">plus</em> icon or by right-clicking on the <em class="calibre17">plus</em> icon and selecting <span class="calibre7"><span class="calibre7">expand</span> node</span>. You can also right-click on the node and use the <span class="calibre7">expand parents/children</span> or <span class="calibre7">collapse parents/children</span> option to expand or collapse parents or children of a node. You can also zoom in and zoom out by using <em class="calibre17">Ctrl</em> + <em class="calibre17">Wheel mouse</em> <em class="calibre17">button</em>. To go back to the disassembly view from the proximity view, just right-click on the background and choose either <span class="calibre7">Graph view</span> or <span class="calibre7">Text view<span class="calibre7">:</span></span></p>
<div class="cdpaligncenter"><img src="../images/00105.jpeg" class="calibre108"/></div>
<p class="calibre2">Apart from the integrated graphing, IDA can also display graphs using third-party graphing applications. To use these graphing options, right-click on the <span class="calibre7">Toolbar area</span> and select <span class="calibre7">Graphs</span>, which will display five buttons in the toolbar area:  </p>
<div class="mce-root1"><img src="../images/00106.gif" class="calibre109"/></div>
<p class="calibre2">You can generate different types of graphs by clicking on any these buttons, but these graphs are not interactive (unlike the integrated graph-based disassembly view and proximity view). The following outlines the functionality of these buttons:</p>
<table border="1" class="calibre46">
<tbody class="calibre47">
<tr class="calibre48">
<td class="calibre110">
<div class="cdpaligncenter"><strong class="calibre1"><img src="../images/00107.gif" class="calibre111"/></strong></div>
</td>
<td class="calibre112">
<p class="mce-root2"><span class="calibre7">I</span><span class="calibre7">t displays the external flow chart of the current function. This resembles IDA's interactive graph view mode of the</span><span class="calibre7"> </span><span class="calibre7">disassembly</span><span class="calibre7"> </span><span class="calibre7">window.</span></p>
<div class="cdpaligncenter"/>
</td>
</tr>
<tr class="calibre48">
<td class="calibre110">
<div class="cdpaligncenter"><strong class="calibre1"><img src="../images/00108.gif" class="calibre41"/></strong></div>
</td>
<td class="calibre112">
<p class="mce-root2"><span class="calibre7">It di</span><span class="calibre7">splays the call graph for the entire program; this can be used to get a quick overview of the hierarchy of the function calls within a program, but if the binary contains too many functions, the graph might be difficult to view, as it can get very large and cluttered.</span></p>
<div class="cdpaligncenter"/>
</td>
</tr>
<tr class="calibre48">
<td class="calibre110">
<div class="cdpaligncenter"><img src="../images/00109.gif" class="calibre41"/></div>
</td>
<td class="calibre112">
<p class="mce-root2"><span class="calibre7">It displays the cross-reference </span><span class="calibre7">to <em class="calibre17">(</em>Xrefs to) a function; this is useful if you want to see the various paths taken by a program to reach a specific function. The following screenshot shows the path taken to reach the <kbd class="calibre13">sub_4013CD</kbd> function:</span></p>
<div class="title-page-name"> <img src="../images/00110.gif" class="calibre113"/>      </div>
</td>
</tr>
<tr class="calibre48">
<td class="calibre110">
<div class="cdpaligncenter"><img src="../images/00111.gif" class="calibre41"/></div>
</td>
<td class="calibre112">
<p class="mce-root2"><span class="calibre7">It displays the cross-references from (Xrefs from) a function; this is useful in order to know all of the functions called by a particular function. The following diagram </span><span class="calibre7">will give you an idea of all of the functions that will be called by <kbd class="calibre13">sub_4013CD</kbd>:</span></p>
<div class="title-page-name">   <img src="../images/00112.gif" class="calibre114"/>  </div>
</td>
</tr>
<tr class="calibre48">
<td class="calibre110">
<div class="cdpaligncenter"><img src="../images/00113.gif" class="calibre41"/></div>
</td>
<td class="calibre112">
<p class="mce-root3"><span class="calibre7">This is the</span><span class="calibre7"> </span><em class="calibre17">User Xref</em><span class="calibre7"> </span><span class="calibre7">button, which allows you to generate custom cross-reference graphs. </span></p>
</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">With an understanding of how to leverage IDA's features to enhance your disassembly, let's move on to the next topic, where you will learn how malware uses the Windows API to interact with the system. You will learn how to get more information about an API function, and how to distinguish and interpret the Windows API from a 32-bit and 64-bit malware.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3. Disassembling Windows API</h1>
                
            
            <article>
                
<p class="calibre2">Malware normally uses <em class="calibre17">Windows API functions</em> (<em class="calibre17">Application Programming Interface)</em> to interact with the operating system (for performing filesystem, process, memory, and network operations). As explained in <a href="part0032.html#UGI00-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 2</a><em class="calibre17">, Static Analysis,</em> and <a href="part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 3</a>, <em class="calibre17">Dynamic Analysis</em>, Windows exports the majority of its functions required for these interactions in <em class="calibre17">Dynamic Link Libary (DLL)</em> files. Executables import and call these API functions from various DLLs, which provide different functionalities. To call the API, the executable process loads the DLL into its memory and then calls the API function. Inspecting the DLLs that a malware relies upon and the API functions that it imports can give an idea of the functionality and capability of the malware. The following table outlines some of the common DLLs, and the functionalities that they implement:</p>
<table border="1" class="calibre46">
<tbody class="calibre47">
<tr class="calibre48">
<td class="calibre49"><strong class="calibre1">DLL</strong></td>
<td class="calibre49"><strong class="calibre1">Description</strong></td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">Kernel32.dll</kbd></td>
<td class="calibre49">This DLL exports functions related to process, memory, hardware, and filesystem operations. Malware imports API functions from these DLLs to carry out filesystem-memory-and process-related operations.</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">Advapi32.dll</kbd></td>
<td class="calibre49">This contains functionality related to service and registry. Malware uses the API functions from this DLL to carry out service-and registry related operations.</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">Gdi32.dll</kbd></td>
<td class="calibre49">It exports functions related to graphics.</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">User32.dll</kbd></td>
<td class="calibre49">It implements functions that create and manipulate Windows user interface components, such as the desktop, windows, menus, message boxes, prompts, and so on. Some malware programs use functions from this DLL for performing DLL injections and for monitoring keyboard (for keylogging) and mouse events.</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">MSVCRT.dll</kbd></td>
<td class="calibre49">It contains implementations of C standard library functions.</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">WS2_32.dll</kbd> and <kbd class="calibre13">WSock32.dll</kbd></td>
<td class="calibre49">They contain functions for communicating on the network. Malware import functions from these DLLs for performing network-related tasks. </td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">Wininet.dll</kbd></td>
<td class="calibre49">It exposes high-level functions to interact with HTTP and FTP protocols.</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">Urlmon.dll</kbd></td>
<td class="calibre49">It is a wrapper around <kbd class="calibre13">WinInet.dll</kbd>, and it is responsible for MIME-type handling and the downloading of web content. Malware downloaders use functions from this DLL for downloading additional malware content. </td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">NTDLL.dll</kbd></td>
<td class="calibre49">It exports Windows Native API functions and acts as the interface between the user mode programs and the kernel. For example, when a program calls API functions in <kbd class="calibre13">kernel32.dll</kbd> (or <kbd class="calibre13">kernelbase.dll</kbd>), the API, in turn, calls short stub in <kbd class="calibre13">ntdll.dll</kbd>. A program typically does not import functions from <kbd class="calibre13">ntdll.dll</kbd> directly; <span><span>the functions in <kbd class="calibre13">ntdll.dll</kbd></span></span> are indirectly imported by DLL such as <kbd class="calibre13">Kernel32.dll</kbd>. Most of the functions in <kbd class="calibre13">ntdll.dll</kbd> are undocumented, and malware authors sometimes import functions from this DLL directly.</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.1 Understanding Windows API</h1>
                
            
            <article>
                
<p class="calibre2">To demonstrate how malware makes use of the Windows API and to help you understand how to get more information about an API, let's look at a malware sample. Loading the malware sample in IDA and inspecting the imported functions in the <span class="calibre7">Imports</span> window show reference to the <kbd class="calibre13">CreateFile</kbd> API function, as shown in the following screenshot:</p>
<div class="cdpaligncenter"><img src="../images/00114.jpeg" class="calibre115"/></div>
<p class="calibre2">Before we determine the location where this API is referenced <span class="calibre7">in the code, l</span>et's try to get more information about the API call. Whenever you encounter a Windows API function (like the one shown in the preceding example), you can learn more about the API function by simply searching for it in the <em class="calibre17">Microsoft Developer Network (MSDN)</em> at <a href="https://msdn.microsoft.com/" class="calibre10">https://msdn.microsoft.com/</a>, or by <em class="calibre17">Googling it</em>. The MSDN documentation gives a description of the API function, its function parameters (their data types), and the return value. The function prototype for <kbd class="calibre13">CreateFile</kbd> (as mentioned in the documentation at <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx" class="calibre10">https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx</a>) is shown in the following snippet. From the documentation, you can tell that this function is used to <em class="calibre17">create</em> or <em class="calibre17">open</em> a file. To understand what file the program creates or opens, you will have to inspect the first parameter (<kbd class="calibre13">lpFilename</kbd>), which specifies the filename. The second parameter (<kbd class="calibre13">dwDesiredAccess</kbd>) specifies the requested access (such as <em class="calibre17">read</em> or <em class="calibre17">write</em> access), and the fifth parameter specifies the action to take on the file (such as creating a new file or opening an existing file):</p>
<pre class="calibre18">HANDLE WINAPI CreateFile(<br class="title-page-name"/>_In_ LPCTSTR lpFileName,<br class="title-page-name"/>_In_ DWORD dwDesiredAccess,<br class="title-page-name"/>_In_ DWORD dwShareMode,<br class="title-page-name"/>_In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,<br class="title-page-name"/>_In_ DWORD dwCreationDisposition,<br class="title-page-name"/>_In_ DWORD dwFlagsAndAttributes,<br class="title-page-name"/>_In_opt_ HANDLE hTemplateFile<br class="title-page-name"/>);</pre>
<p class="calibre2">The Windows API uses <em class="calibre17">Hungarian notation</em> for naming variables. In this notation, the variable is prefixed with an abbreviation of its datatype; this makes it easy to understand the data type of a given variable. In the preceding example, consider the second parameter, <kbd class="calibre13">dwDesiredAccess</kbd>; the <kbd class="calibre13">dw</kbd> prefix specifies that it is of the <kbd class="calibre13">DWORD</kbd> data type. The <kbd class="calibre13">Win32</kbd> API supports many different data types (<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx" class="calibre10">https://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx</a>). The following table outlines some of the relevant data types:</p>
<table border="1" class="calibre46">
<tbody class="calibre47">
<tr class="calibre48">
<td class="calibre49"><strong class="calibre1">Data Type</strong></td>
<td class="calibre49">
<p class="calibre2"><strong class="calibre5">Description</strong></p>
</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">BYTE (b)</kbd></td>
<td class="calibre49">
<p class="calibre2">Unsigned 8-bit value.</p>
</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">WORD (w)</kbd></td>
<td class="calibre49">
<p class="calibre2"><span class="calibre7">U</span>nsigned 16-bit value.</p>
</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">DWORD (dw)</kbd></td>
<td class="calibre49"><span>U</span>nsigned 32-bit value.</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">QWORD (qw)</kbd></td>
<td class="calibre49"><span>U</span>nsigned 64-bit value.</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">Char (c)</kbd></td>
<td class="calibre49">8-bit ANSI character.</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">WCHAR</kbd></td>
<td class="calibre49">16-bit Unicode character.</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">TCHAR</kbd></td>
<td class="calibre49">
<p class="calibre2">Generic character (1-byte ASCII character or wide, 2-byte Unicode character).</p>
</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">Long Pointer (LP)</kbd></td>
<td class="calibre49">
<p class="calibre2">This is a pointer to another data type. For example, <kbd class="calibre13">LPDWORD</kbd> is a pointer to <kbd class="calibre13">DWORD</kbd>, <kbd class="calibre13">LPCSTR</kbd> is a constant string, <kbd class="calibre13">LPCTSTR</kbd> is a const <kbd class="calibre13">TCHAR</kbd> (1-byte ASCII characters, or wide, 2-byte Unicode characters) string, <kbd class="calibre13">LPSTR</kbd> is a non-constant string, and <kbd class="calibre13">LPTSTR</kbd> is a non-constant <kbd class="calibre13">TCHAR</kbd> (ASCII or Unicode) string. Sometimes, you will see <kbd class="calibre13">Pointer (P)</kbd> used instead of <kbd class="calibre13">Long Pointer(LP)</kbd>.</p>
</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><kbd class="calibre13">Handle (H)</kbd></td>
<td class="calibre49">It represents the <kbd class="calibre13">handle</kbd> data type. A handle is a reference to an object. Before a process can access an object (such as a file, registry, process, Mutex, and so on), it must first open a handle to the object. For example, if a process wants to <em class="calibre19">write</em> to a file, the process first calls the API, such as <kbd class="calibre13">CreateFile</kbd>, which returns the <em class="calibre19">handle</em> to the file; the process then uses the handle to write to the file by passing the handle to the <kbd class="calibre13">WriteFile</kbd> API.</td>
</tr>
</tbody>
</table>
<p class="calibre2"> </p>
<p class="calibre2">Apart from the datatypes and variables, the preceding function prototype contains <em class="calibre17">annotations</em>, such as <kbd class="calibre13">_In_</kbd> and <kbd class="calibre13">_Out_</kbd>, which describe how the function uses its <em class="calibre17">parameters</em> and <em class="calibre17">return value</em>. The <kbd class="calibre13">_In_</kbd> specifies that it is an input parameter, and the caller must provide valid parameters for the function to work. The <kbd class="calibre13">_IN_OPT</kbd> specifies that it is an optional input parameter (or it can be <kbd class="calibre13">NULL</kbd>). The <kbd class="calibre13">_Out_</kbd> specifies output parameter; it means that the function will fill in the parameter on return. This convention is useful to know if the API call stores any data in the output parameter after the function call. The <kbd class="calibre13">_Inout_</kbd> object tells you that the parameter both passes values to the function and receives the output from the function.</p>
<p class="calibre2">With an understanding of how to get information about an API from the documentation, let's go back to our malware sample. Using the cross-references to <kbd class="calibre13">CreateFile</kbd>, we can determine that the <kbd class="calibre13">CreateFile</kbd> API is referenced in two functions, <kbd class="calibre13">StartAddress</kbd> and <kbd class="calibre13">start</kbd>, as shown here:</p>
<div class="cdpaligncenter"><img src="../images/00115.jpeg" class="calibre116"/></div>
<p class="calibre2">Double-clicking the first entry in the preceding screenshot jumps the display to the following code in the disassembly window. The following code highlights another great feature of IDA. Upon disassembly, IDA employs a technology called <em class="calibre17">Fast Library Identification and Recognition Technology (FLIRT)</em>, which contains pattern matching algorithms to identify whether the disassembled function is a <em class="calibre17">library</em> or an <em class="calibre17">imported function</em> (a function imported from DLLs). In this case, IDA was able to recognize the disassembled function at ➊ as <span class="calibre7">an imported function, and named it </span><kbd class="calibre13">CreateFileA</kbd><span class="calibre7">. IDA's capability to identify libraries and imported functions is extremely useful, because when you are analyzing malware, you really don't want to waste time reverse engineering a library or import function. IDA also added names of parameters as comments to indicate which parameter was being pushed at each instruction leading up to the</span> <kbd class="calibre13">CreateFileA</kbd> <span class="calibre7">Windows API call:</span></p>
<pre class="calibre18">push  0                   ; hTemplateFile<br class="title-page-name"/>push  80h                 ; dwFlagsAndAttributes<br class="title-page-name"/>push  2  ➍                ; dwCreationDisposition<br class="title-page-name"/>push  0                    ; lpSecurityAttributes<br class="title-page-name"/>push  1                    ; dwShareMode<br class="title-page-name"/>push  40000000h  ➌         ; dwDesiredAccess<br class="title-page-name"/>push  offset FileName  ➋   ; "psto.exe"<br class="title-page-name"/>call  CreateFileA  ➊</pre>
<p class="calibre2">From the preceding disassembly listing, you can tell that malware either <em class="calibre17">creates</em> or <em class="calibre17">opens</em> a file (<kbd class="calibre13">psto.exe</kbd>) that is passed as the first argument (➋) to <span class="calibre7"><kbd class="calibre13">CreateFile</kbd>. From the documentation, you know that the second argument (➌) specifies the requested access (such as <em class="calibre17">read</em> or <em class="calibre17">write</em>). The constant <kbd class="calibre13">40000000h</kbd>, passed as the second argument, represents the symbolic constant <kbd class="calibre13">GENERIC_WRITE</kbd>. Malware authors often use symbolic constants, such as <kbd class="calibre13">GENERIC_WRITE</kbd>, in their source code; but during the compilation</span> process<span class="calibre7">, these constants are replaced with their equivalent values (such as <kbd class="calibre13">40000000h</kbd>), making it difficult to determine whether it is a numeric constant or a symbolic constant. In this case, from the Windows API</span> documentation<span class="calibre7">, we know that the value <kbd class="calibre13">40000000h</kbd> at ➌</span><span class="calibre7"> is a symbolic constant that represents <kbd class="calibre13">GENERIC_WRITE</kbd>.</span> <span class="calibre7">Similarly</span><span class="calibre7">, the value <kbd class="calibre13">2</kbd>, passed as the fifth argument (➍</span>), represents <span class="calibre7">the symbolic name</span> <kbd class="calibre13">CREATE_ALWAYS</kbd><span class="calibre7">; this tells you that malware creates the file.</span></p>
<p class="calibre2">Another feature of IDA is that it maintains a list of standard <em class="calibre17">symbolic constants</em> for the Windows API or the C standard library function. To replace the constant value such as <kbd class="calibre13">40000000h</kbd> at ➌, with the symbolic constant, just right-click on the constant value and choose the <span class="calibre7">Use standard symbolic constant</span> option; this will bring up the window displaying all of the symbolic names for the selected value (in this case, <kbd class="calibre13">40000000h</kbd>), as shown in the following screenshot. You need to select the one that is appropriate; in this case, the appropriate one is <kbd class="calibre13">GENERIC_WRITE</kbd>. In the same manner, you can also replace the constant value <kbd class="calibre13">2</kbd>, passed as the fifth argument, to its symbolic name, <kbd class="calibre13">CREATE_ALWAYS</kbd>:</p>
<div class="cdpaligncenter"><img src="../images/00116.jpeg" class="calibre117"/></div>
<p class="calibre2">After replacing the constants with symbolic names, the disassembly listing is translated to the one shown in the following snippet. The code is now more readable, and from the code, you can tell that malware creates the file <kbd class="calibre13">psto.exe</kbd> on the filesystem. After the functional call, the <em class="calibre17">handle</em> to the file (which can be found in the <kbd class="calibre13">EAX</kbd> register) is returned. The handle to the file returned by this function can be passed to other APIs, such as <kbd class="calibre13">ReadFile()</kbd> or <kbd class="calibre13">WriteFile()</kbd>, to perform subsequent operations:</p>
<pre class="calibre18">push 0                 ; hTemplateFile<br class="title-page-name"/>push 80h               ; dwFlagsAndAttributes<br class="title-page-name"/>push <strong class="calibre1">CREATE_ALWAYS</strong>     ; dwCreationDisposition<br class="title-page-name"/>push 0                 ; lpSecurityAttributes<br class="title-page-name"/>push 1                 ; dwShareMode<br class="title-page-name"/>push <strong class="calibre1">GENERIC_WRITE</strong>     ; dwDesiredAccess<br class="title-page-name"/>push offset FileName   ; "psto.exe"<br class="title-page-name"/>call CreateFileA</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.1.1 ANSI and Unicode API Functions</h1>
                
            
            <article>
                
<p class="calibre2">Windows supports two parallel sets of APIs: one for <em class="calibre17">ANSI strings</em>, and the other for <em class="calibre17">Unicode strings</em>. Many functions that take a string as an argument include an <kbd class="calibre13">A</kbd> or <kbd class="calibre13">W</kbd> at the end of their names, such as <kbd class="calibre13">CreateFileA</kbd>. In other words, t<span class="calibre7">he trailing character can give you an idea of what type of string (ANSI or Unicode) is passed to the function. </span>In the preceding example, the malware calls <kbd class="calibre13">CreateFileA</kbd> to create a file; the trailing character <kbd class="calibre13">A</kbd> specifies that the <kbd class="calibre13">CreateFile</kbd> function takes an ANSI string as input. You will also see malware using APIs such as <kbd class="calibre13">CreateFileW</kbd>; the <kbd class="calibre13">W</kbd> at the end specifies that the function takes a <kbd class="calibre13">Unicode</kbd> string as input. During malware analysis, when you come across a function such as <kbd class="calibre13">CreateFileA</kbd> or <kbd class="calibre13">CreateFileW</kbd>, just remove the trailing <kbd class="calibre13">A</kbd> and <kbd class="calibre13">W</kbd> characters and use <kbd class="calibre13">CreateFile</kbd> to search MSDN for the function documentation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.1.2 Extended API Functions</h1>
                
            
            <article>
                
<p class="calibre2">You will often encounter function names with an <kbd class="calibre13">Ex</kbd> suffix in their names, such as <kbd class="calibre13">RegCreateKeyEx</kbd> (which is an extended version of <kbd class="calibre13">RegCreateKey</kbd>). When Microsoft updates a function that is incompatible with an old function, the updated function has an <kbd class="calibre13">Ex</kbd> suffix added to its name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.2 Windows API 32-Bit and 64-Bit Comparison</h1>
                
            
            <article>
                
<p class="calibre2">Let's look at an example of a 32-bit malware to understand how malware uses multiple API functions to interact with the operating system, and let's also try to understand how to interpret disassembly code to understand the operations performed by the malware. In the following disassembly output, the 32-bit malware calls the <kbd class="calibre13">RegOpenKeyEx</kbd> API to open a handle to the <kbd class="calibre13">Run</kbd> registry key. Since we are dealing with 32-bit malware, all the parameters to the <kbd class="calibre13">RegOpenKeyEx</kbd> API are pushed onto the stack. As per the documentation at <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724897(v=vs.85).aspx" class="calibre10">https://msdn.microsoft.com/en-us/library/windows/desktop/ms724897(v=vs.85).aspx</a>, the output parameter <kbd class="calibre13">phkResult</kbd> is a pointer variable (output parameter is indicated by the <kbd class="calibre13">_Out_</kbd> annotation) that receives the handle to the opened registry key after the function call. Notice that at ➊, the <span class="calibre7">address of <kbd class="calibre13">phkResult</kbd> is copied into the <kbd class="calibre13">ecx</kbd> register, and at ➋, this address is passed as the fif</span>th <span class="calibre7">parameter to the <kbd class="calibre13">RegOpenKeyEx</kbd> API:</span></p>
<pre class="calibre18">lea  ecx, [esp+7E8h+phkResult] ➊<br class="title-page-name"/>push ecx ➋                        ; phkResult<br class="title-page-name"/>push 20006h                       ; samDesired<br class="title-page-name"/>push 0                            ; ulOptions<br class="title-page-name"/>push offset aSoftwareMicros ;Software\Microsoft\Windows\CurrentVersion\Run<br class="title-page-name"/>push HKEY_CURRENT_USER            ; hKey<br class="title-page-name"/><strong class="calibre1">call ds:RegOpenKeyExW</strong></pre>
<p class="calibre2">After the malware opens the handle to the <kbd class="calibre13">Run</kbd> registry key by calling <kbd class="calibre13">RegOpenKeyEx</kbd>, the returned handle (stored in the <kbd class="calibre13">phkResult</kbd> variable ➌) is moved into the <kbd class="calibre13">ecx</kbd> register and then passed as the first parameter ➍ to <kbd class="calibre13">RegSetValueExW</kbd>. From the MSDN documentation for this API, you can tell that the malware uses the <kbd class="calibre13">RegSetValueEx</kbd> API to set a value in the <kbd class="calibre13">Run</kbd> registry key (for persistence). The value that it sets is passed as the second parameter ➎, which is the string <kbd class="calibre13">System</kbd>. The data that it adds to the registry can be determined by examining the fifth parameter ➏, which is passed in the <kbd class="calibre13">eax</kbd> register. From the previous instruction ➐, it can be determined that <kbd class="calibre13">eax</kbd> holds the address of the variable <kbd class="calibre13">pszPath</kbd>. The <kbd class="calibre13">pszPath</kbd> variable is populated with some content during runtime; so, just by looking at the code, it's hard to say what data the malware is adding to the registry key (you can determine that by debugging the malware, which will be covered in the next chapter). But, at this point, by using static code analysis (disassembly), you can tell that malware adds an entry into the registry key for persistence:</p>
<pre class="calibre18">mov   ecx, [esp+7E8h+phkResult] ➌<br class="title-page-name"/>sub   eax, edx<br class="title-page-name"/>sar   eax, 1<br class="title-page-name"/>lea   edx, ds:4[eax*4]<br class="title-page-name"/>push  edx                     ; cbData<br class="title-page-name"/>lea   eax, [esp+7ECh+pszPath] ➐<br class="title-page-name"/>push  eax ➏                  ; lpData<br class="title-page-name"/>push  REG_SZ                 ; dwType<br class="title-page-name"/>push  0                      ; Reserved<br class="title-page-name"/>push  offset ValueName       ; "System" ➎<br class="title-page-name"/>push  ecx ➍ ; hKey<br class="title-page-name"/><strong class="calibre1">call  ds:RegSetValueExW</strong></pre>
<p class="calibre2">After adding the entry to the registry key, the malware closes the handle to the registry key by passing the handle it acquired previously (which was stored in the <kbd class="calibre13">phkResult</kbd> variable) to the <kbd class="calibre13">RegCloseKey</kbd> API function, as shown here:</p>
<pre class="calibre18">mov   edx, [esp+7E8h+phkResult]<br class="title-page-name"/>push  edx                     ; hKey<br class="title-page-name"/><strong class="calibre1">call  esi                     ; RegCloseKey</strong></pre>
<p class="calibre2">The preceding example demonstrates how malware makes use of multiple Windows API functions to add an entry into the registry key, which will allow it to run automatically when the computer reboots. You also saw how malware acquires a handle to an object (such as the registry key) and then shares that handle with other API functions to perform subsequent operations.</p>
<p class="calibre2">When you are looking at the disassembled output of the function from 64-bit malware, it might look different because of the way the parameters are passed in the x64 architecture <span class="calibre7">(this was covered in the previous chapter)</span>. The following is an example of 64-bit malware calling the <kbd class="calibre13">CreateFile</kbd> function. In the previous chapter, while discussing the x64 architecture, you learned that the first four parameters are passed in registers (<kbd class="calibre13">rcx</kbd>,<kbd class="calibre13">rdx</kbd>, <kbd class="calibre13">r8</kbd>, and <kbd class="calibre13">r9</kbd>), and the rest of the parameters are placed on the stack. In the following disassembly, notice how the first parameter (<kbd class="calibre13">lpfilename</kbd>) is passed in the <kbd class="calibre13">rcx</kbd> register at ➊, <span class="calibre7">the second parameter in the <kbd class="calibre13">edx</kbd> register at ➋</span><span class="calibre7">, the third parameter in the</span> <kbd class="calibre13">r8</kbd> <span class="calibre7">register at ➌, and the fourth parameter in the</span> <kbd class="calibre13">r9</kbd> <span class="calibre7">register at ➍. The additional parameters are placed on the stack (notice that there is no <kbd class="calibre13">push</kbd> instruction) using <kbd class="calibre13">mov</kbd> instructions, at ➎</span><span class="calibre7"> and ➏. Notice how IDA was able to recognize the parameters and add a comment next to the instructions. The return value of this function (which is the handle to the file) is moved from the</span> <kbd class="calibre13">rax</kbd> <span class="calibre7">register to the</span> <kbd class="calibre13">rsi</kbd> <span class="calibre7">register at ➐:</span></p>
<pre class="calibre18">xor  r9d, r9d  ➍                           ; lpSecurityAttributes<br class="title-page-name"/>lea  rcx, [rsp+3B8h+FileName] ➊             ; lpFileName<br class="title-page-name"/>lea  r8d, [r9+1] ➌                          ; dwShareMode<br class="title-page-name"/>mov  edx, 40000000h ➋                       ; dwDesiredAccess<br class="title-page-name"/>mov  [rsp+3B8h+dwFlagsAndAttributes], 80h ➏  ; dwFlagsAndAttributes<br class="title-page-name"/>mov  [rsp+3B8h+dwCreationDisposition], 2  ➎  ; lpOverlapped<br class="title-page-name"/><strong class="calibre1">call cs:CreateFileW</strong><br class="title-page-name"/>mov  rsi, rax  ➐</pre>
<p class="calibre2">In the following disassembly listing of <kbd class="calibre13">WriteFile</kbd> API, notice how the file handle which was copied into the <kbd class="calibre13">rsi</kbd> register in the previous API call, is now moved into the <kbd class="calibre13">rcx</kbd> register to pass it as the first parameter to the <kbd class="calibre13">WriteFile</kbd> function at ➑. In the same manner, the other parameters are placed in the register and on the stack, as shown here:</p>
<pre class="calibre18">and  qword ptr [rsp+3B8h+dwCreationDisposition], 0<br class="title-page-name"/>lea  r9,[rsp+3B8h+NumberOfBytesWritten]       ; lpNumberOfBytesWritten<br class="title-page-name"/>lea  rdx, [rsp+3B8h+Buffer]                   ; lpBuffer<br class="title-page-name"/>mov  r8d, 146h                                ; nNumberOfBytesToWrite<br class="title-page-name"/>mov  rcx, rsi ➑                               ; hFile<br class="title-page-name"/><strong class="calibre1">call cs:WriteFile</strong></pre>
<p class="calibre2">From the preceding example, you can see that the malware creates a file and writes some content into the file, but <span class="calibre7">when you are looking at the code statically,</span> it is not clear what file the malware creates or what content it writes to the file. For example, to know the filename created by the program, you need to examine the content of the address specified by the variable <kbd class="calibre13">lpFileName</kbd> (passed as an argument to the <kbd class="calibre13">CreateFile</kbd>); but the <kbd class="calibre13">lpFileName</kbd> variable, in this case, is not hardcoded, and is populated only when the program runs. In the next chapter, you will learn the technique to execute the program in a controlled manner by using a debugger, which allows you to inspect the contents of the variable (memory locations).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4. Patching Binary Using IDA</h1>
                
            
            <article>
                
<p class="calibre2">When performing malware analysis, you may want to modify the binary to change its inner workings or reverse its logic to suit your needs. Using IDA, it is possible to modify the <em class="calibre17">data</em> or <em class="calibre17">instructions</em> of a program. You can perform patching by selecting<span class="calibre7"> </span><span class="calibre7">Edit</span> <span class="calibre7">| Patch program</span> menu,<span class="calibre7"> </span>as shown in the following screenshot. Using the submenu items, you can modify a <em class="calibre17">byte</em>, <em class="calibre17">word</em>, or <em class="calibre17">assembly instructions</em>. A point to remember is that when you are using these menu options on the binary, you are not really modifying the binary; the modification is made to the IDA database. To apply the modification to the original binary, you need to use the <span class="calibre7">Apply patches to input file</span> submenu item:</p>
<div class="cdpaligncenter"><img src="../images/00117.jpeg" class="calibre118"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4.1 Patching Program Bytes</h1>
                
            
            <article>
                
<p class="calibre2">Consider the code excerpt from the 32-bit malware DLL (<em class="calibre17">TDSS<span class="calibre7"> </span>rootkit</em>), which is performing a check to make sure that it is running under<span class="calibre7"> </span><kbd class="calibre13">spoolsv.exe</kbd>. This check is performed using string comparison<span class="calibre7"> </span>at<span class="calibre7"> ➊</span>; if<span class="calibre7"> </span>the string comparison fails, then the code jumps<span class="calibre7"> </span>to end of the function ➋ and<span class="calibre7"> </span>returns from the function. To be specific, this DLL generates malicious behavior only when it is loaded by<span class="calibre7"> </span><kbd class="calibre13">spoolsv.exe</kbd><span class="calibre7">; </span>otherwise, it just returns from the function:</p>
<pre class="calibre18">10001BF2     push offset aSpoolsv_exe  ; "spoolsv.exe"<br class="title-page-name"/>10001BF7     push edi                  ; char *<br class="title-page-name"/>10001BF8     <strong class="calibre1">call _stricmp</strong>  ➊ <br class="title-page-name"/>10001BFD     test eax, eax<br class="title-page-name"/>10001BFF     pop ecx<br class="title-page-name"/>10001C00     pop ecx<br class="title-page-name"/>10001C01     jnz loc_10001CF9<br class="title-page-name"/><br class="title-page-name"/>[REMOVED]<br class="title-page-name"/><br class="title-page-name"/>10001CF9 loc_10001CF9: ➋      ; CODE XREF: DllEntryPoint+10j<br class="title-page-name"/>10001CF9      xor  eax, eax<br class="title-page-name"/>10001CFB      pop  edi<br class="title-page-name"/>10001CFC      pop  esi<br class="title-page-name"/>10001CFD      pop  ebx<br class="title-page-name"/>10001CFE      leave<br class="title-page-name"/>10001CFF      retn 0Ch</pre>
<p class="calibre2">Suppose you want the malicious DLL to generate the behavior<span class="calibre7"> </span>on<span class="calibre7"> </span>any other process, such as<span class="calibre7"> </span><kbd class="calibre13">notepad.exe</kbd>. You can change the hardcoded string from<span class="calibre7"> </span><kbd class="calibre13">spoolsv.exe</kbd><span class="calibre7"> </span>to<span class="calibre7"> </span><kbd class="calibre13">notepad.exe</kbd>. To do that, navigate to the hardcoded address by clicking on<span class="calibre7"> </span><kbd class="calibre13">aSpoolsv_exe</kbd><span class="calibre7">, </span>which will land you<span class="calibre7"> </span>in<span class="calibre7"> </span>the region shown here:</p>
<div class="cdpaligncenter"><img src="../images/00118.jpeg" class="calibre119"/></div>
<p class="calibre2">Now, place your mouse cursor on the variable name (<kbd class="calibre13">aSpoolsv_exe</kbd>). At this point, the hex view window should be synchronized with this address. Now, clicking on the <span class="calibre7">Hex View-1</span> tab displays the hex and ASCII dump of this memory address. To patch the bytes, select<span class="calibre7"> </span><span class="calibre7">Edit</span> | <span class="calibre7">Patch program</span> | <span class="calibre7">Change byte</span><span class="calibre7">; </span>this will bring up the patch bytes dialog shown in the following screenshot. You can modify the original bytes by entering the new byte values in the<span class="calibre7"> </span><span class="calibre7">Values</span> field. The <span class="calibre7">Address</span> field represents the virtual address of the cursor location, and the<span class="calibre7"> </span><span class="calibre7">File offset</span> field<span class="calibre7"> </span>specifies the offset in the file where the bytes reside in the binary. The<span class="calibre7"> </span><span class="calibre7">Original<span class="calibre7"> </span>value</span> field shows the original bytes at the current address; the values in this field do not change, even if you modify the values:</p>
<div class="cdpaligncenter"><img src="../images/00119.jpeg" class="calibre120"/></div>
<p class="calibre2">The modification that you make is applied to the IDA database; to apply the changes to the original executable file, you can select<span class="calibre7"> </span><span class="calibre7">Edit | Patch program | Apply patches</span><span class="calibre7"><span class="calibre7"> </span>to the input file</span>. The following screenshot shows the <span class="calibre7">Apply patches to input file</span> dialog. When you click on<span class="calibre7"> </span><strong class="calibre5">OK,</strong><span class="calibre7"> </span>the changes will be applied to the original file; you can keep a backup of the original file by checking the<span class="calibre7"> </span><span class="calibre7">Create backup</span> option; in that case, it will save your original file with a<span class="calibre7"> </span><kbd class="calibre13">.bak</kbd><span class="calibre7"> </span>extension:</p>
<div class="cdpaligncenter"><img src="../images/00120.jpeg" class="calibre121"/></div>
<p class="calibre2"><span class="calibre7">The preceding example demonstrated patching the bytes; i</span>n the same<span class="calibre7"> </span>manner<span class="calibre7">,</span><span class="calibre7"> </span>you can patch <em class="calibre17">one<span class="calibre7"> </span>word</em> <span class="calibre7">(2-byte) </span>at a time by selecting<span class="calibre7"> </span><span class="calibre7">Edit</span><span class="calibre7"><span class="calibre7"> |</span> </span><span class="calibre7">Patch program</span><span class="calibre7"> </span><span class="calibre7"><span class="calibre7">| </span>Change word</span>. You can also modify bytes from the <em class="calibre17">hex view</em><span class="calibre7"> window, by</span><span class="calibre7"> </span><span class="calibre7">right-clicking</span><span class="calibre7"> </span><span class="calibre7">on a byte and choosing </span><span class="calibre7">Edit</span><span class="calibre7"> (</span><em class="calibre17">F2</em><span class="calibre7">), and you can apply the changes by right-clicking</span><span class="calibre7"> again </span><span class="calibre7">and by choosing </span><span class="calibre7">Apply changes</span><span class="calibre7"> (</span><em class="calibre17">F2</em><span class="calibre7">).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4.2 Patching Instructions</h1>
                
            
            <article>
                
<p class="calibre2">In the previous example, the<span class="calibre7"> <em class="calibre17">TDSS </em></span><em class="calibre17">rootkit</em> DLL performed a check to see if it is running under<span class="calibre7"> </span><kbd class="calibre13">spoolsv.exe</kbd>. We modified the bytes in the program so that the DLL can run under <kbd class="calibre13">notepad.exe</kbd> instead of <kbd class="calibre13">spoolsv.exe</kbd>. What if you wanted to reverse the logic so that DLL can run under any process (other than<span class="calibre7"> </span><kbd class="calibre13">spoolsv.exe</kbd>)? To do that, we can change the<span class="calibre7"> </span><kbd class="calibre13">jnz</kbd><span class="calibre7"> </span>instruction to<span class="calibre7"> </span><kbd class="calibre13">jz</kbd><span class="calibre7"> </span>by selecting<span class="calibre7"> </span><span class="calibre7">Edit</span> | <span class="calibre7">Patch program</span> | <span class="calibre7">Assemble,</span><span class="calibre7"> </span>as shown in the following screenshot. This will reverse the logic and cause the program to return from the function without exhibiting any behavior when the DLL is running under<span class="calibre7"> </span><kbd class="calibre13">spoolsv.exe</kbd>. Whereas when the DLL is running under any other process, it exhibits malicious behavior. After changing the instructions, when you click on<span class="calibre7"> </span><span class="calibre7">OK</span>, the instruction is assembled but the dialog remains open, prompting you to assemble another instruction at the next address. If you do not have any more instructions to assemble, you can click the <span class="calibre7">Cancel</span> button. To make the changes to the original file, select<span class="calibre7"> </span><span class="calibre7">Edit</span> | <span class="calibre7">Patch program</span> | <span class="calibre7">Apply patches to<span class="calibre7"> </span>input<span class="calibre7"> </span>file</span><span class="calibre7"> </span>and follow the steps mentioned previously:</p>
<div class="cdpaligncenter"><img src="../images/00121.jpeg" class="calibre122"/></div>
<p class="calibre2"><span class="calibre7">When you are patching an instruction, care needs to be taken to make sure that the instruction alignment is correct; otherwise, the patched program may exhibit unexpected behavior. If the new instruction is shorter than the instruction you are replacing, then </span><kbd class="calibre13">nop</kbd><span class="calibre7"> instructions can be inserted to keep the alignment intact. If you are assembling a new instruction that is longer than the one that is being replaced, IDA will overwrite the bytes of the subsequent instructions, which may not be the behavior you want:</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">5. IDA Scripting and Plugins</h1>
                
            
            <article>
                
<p class="calibre2">IDA offers scripting capabilities that give you access to the contents of an IDA database. Using the scripting functionality, you can automate some of the common tasks and complex analysis operations. IDA supports two scripting languages: <em class="calibre17">IDC</em>, which is a native, built-in language (with syntax similar to C), and Python scripting through <em class="calibre17">IDAPython</em>. <span class="calibre7">In September 2017, Hex-Rays released a new version of IDAPython API that is compatible with IDA 7.0 and later versions. </span>This section will give you a feel of the scripting capabilities using IDAPython; t<span class="calibre7">he IDAPython scripts demonstrated in this section makes use of the new IDAPython API, which means that if you are using older versions of IDA (lower than IDA 7.0), these scripts will not work.</span> After you have become familiar with IDA and the reverse engineering concepts, you may want to automate tasks the following resources should help you get started with <em class="calibre17">IDAPython </em>scripting:</p>
<ul class="calibre11">
<li class="calibre12"><em class="calibre19">The Beginner’s Guide to IDAPython</em> by Alexander Hanel: <a href="https://leanpub.com/IDAPython-Book" class="calibre10">https://leanpub.com/IDAPython-Book</a></li>
<li class="calibre12"><em class="calibre19">Hex-Rays IDAPython documentation</em>: <a href="https://www.hex-rays.com/products/ida/support/idapython_docs/" class="calibre10">https://www.hex-rays.com/products/ida/support/idapython_docs/</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">5.1 Executing IDA Scripts</h1>
                
            
            <article>
                
<p class="calibre2">Scripts can be executed in different ways. You can execute standalone <em class="calibre17">IDC</em> or <em class="calibre17">IDAPython</em> scripts by choosing <span class="calibre7">File</span> | <span class="calibre7">Script file</span>. If you wish to execute only a few statements instead of creating a script file, you can do that by selecting <span class="calibre7">File</span> | <span class="calibre7">Script Command</span> (<em class="calibre17">Shift</em> + <em class="calibre17">F2</em>), then by choosing the appropriate scripting language (IDC or Python) from the drop-down menu, shown as follows. After running the following script commands, the virtual address of the current cursor location and the disassembly text for the given address are displayed in the output window:</p>
<div class="cdpaligncenter"><img src="../images/00122.jpeg" class="calibre123"/></div>
<p class="calibre2">Another way to execute script commands is by typing the command in the IDA's command line, which is located beneath the <em class="calibre17">output</em> window, as shown here:</p>
<div class="cdpaligncenter"><img src="../images/00123.jpeg" class="calibre124"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">5.2 IDAPython</h1>
                
            
            <article>
                
<p class="calibre2"><em class="calibre17">IDAPython</em> is a set of powerful Python bindings for IDA. It combines the power of Python with the analysis features of IDA, allowing for more powerful scripting capabilities. IDAPython consists of three modules: <kbd class="calibre13">idaapi</kbd>, which provides access to the IDA API; <kbd class="calibre13">idautils</kbd>, which provides high-level utility functions for IDA; and <kbd class="calibre13">idc</kbd>, an IDC compatibility module. Most of the IDAPython functions accept an <em class="calibre17">address</em> as the parameter, and, while reading the IDAPython documentation, you will find that the address is referred to as <kbd class="calibre13">ea</kbd>. Many IDAPython functions return addresses; one common function is <kbd class="calibre13">idc.get_screen_ea()</kbd>, <span class="calibre7">which gets the address of the current cursor location:</span></p>
<pre class="calibre18">Python&gt;<strong class="calibre1">ea = idc.get_screen_ea()</strong><br class="title-page-name"/>Python&gt;<strong class="calibre1">print hex(ea)</strong><br class="title-page-name"/>0x40206a</pre>
<p class="calibre2">The following code snippet shows how you can pass the address returned by <kbd class="calibre13">idc.get_screen_ea()</kbd> to the <kbd class="calibre13">idc.get_segm_name()</kbd> function to determine the name of the segment associated with the address:</p>
<pre class="calibre18">Python&gt;<strong class="calibre1">ea = idc.get_screen_ea()</strong><br class="title-page-name"/>Python&gt;<strong class="calibre1">idc.get_segm_name(ea)</strong><br class="title-page-name"/>.text</pre>
<p class="calibre2">In the following code snippet, the address returned by <kbd class="calibre13">idc.get_screen_ea()</kbd> is passed to <kbd class="calibre13">idc.generate_disasm_line()</kbd> function to generate the disassembly text:</p>
<pre class="calibre18">Python&gt;<strong class="calibre1">ea = idc.get_screen_ea()</strong><br class="title-page-name"/>Python&gt;<strong class="calibre1">idc.generate_disasm_line(ea,0)</strong><br class="title-page-name"/>push ebp</pre>
<p class="calibre2">In the following code, the address returned by the <kbd class="calibre13">idc.get_screen_ea()</kbd> function is passed to <kbd class="calibre13">idc.get_func_name()</kbd> to determine the name of the function associated with the address. <span class="calibre7">For more examples, refer to Alexander Hanel's </span><span class="calibre7"><em class="calibre17">The Beginner’s Guide to</em></span> <em class="calibre17">IDAPython</em> book <span class="calibre7">(<a href="https://leanpub.com/IDAPython-Book" class="calibre10">https://leanpub.com/IDAPython-Book</a>):</span></p>
<pre class="calibre18">Python&gt;<strong class="calibre1">ea = idc.get_screen_ea()</strong><br class="title-page-name"/>Python&gt;<strong class="calibre1">idc.get_func_name(ea)</strong><br class="title-page-name"/>_main</pre>
<p class="calibre2">During malware analysis, often, you will want to know if the malware imports a specific function (or functions), such as <kbd class="calibre13">CreateFile</kbd>, and where in the code the function is called. You can do that by using the <em class="calibre17">cross-references</em> feature covered previously. To give you a feel for IDAPython, the following examples demonstrate how to use IDAPython to check for the presence of the <kbd class="calibre13">CreateFile</kbd> API and to identify cross-references to <kbd class="calibre13">CreateFile</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">5.2.1 Checking The Presence Of CreateFile API</h1>
                
            
            <article>
                
<p class="calibre2">If you recall, upon disassembly, IDA tries to identify whether the disassembled function is a library function or an import function by using pattern matching algorithms. It also derives the list of names from the symbol table; such derived names can be accessed by using the <span class="calibre7">Names</span> <span class="calibre7">window</span> (via <span class="calibre7">View</span> | <span class="calibre7">Open subview</span> | <span class="calibre7">Names</span> or <em class="calibre17">Shift</em> + <em class="calibre17">F4</em>). The <span class="calibre7">Names window</span> contains the list of imported, exported, and library functions, and named data locations. The following screenshot displays the <kbd class="calibre13">CreateFileA</kbd> API functions in the <span class="calibre7">Names window</span>:</p>
<div class="cdpaligncenter"><img src="../images/00124.jpeg" class="calibre125"/></div>
<p class="calibre2">You can also programmatically access the named items. The following IDAPython script checks for the presence of the <kbd class="calibre13">CreateFile</kbd> API function by iterating through each named item:</p>
<pre class="calibre18">import idautils<br class="title-page-name"/>for addr, name in idautils.Names():<br class="title-page-name"/>      if "CreateFile" in name:<br class="title-page-name"/>             print hex(addr),name</pre>
<p class="calibre2">The preceding script calls the <kbd class="calibre13">idautils.Names()</kbd> function, which returns a named item (tuple), containing the <em class="calibre17">virtual address</em> and the <em class="calibre17">name</em>. The named item is iterated and checked for the presence of <kbd class="calibre13">CreateFile</kbd>. Running the preceding script returns the address of the <kbd class="calibre13">CreateFileA</kbd> API, as shown in the following snippet. Since the code for an imported function resides in a shared library (DLL) that will only be loaded during runtime, the address (<kbd class="calibre13">0x407010</kbd>) listed in the following snippet is the virtual address of the associated import table entry (not the address where the code for the <kbd class="calibre13">CreateFileA</kbd> function can be found):</p>
<pre class="calibre18">0x407010      CreateFileA</pre>
<p class="calibre2">Another method to determine the presence of the <kbd class="calibre13">CreateFileA</kbd> function is by using the following code. The <kbd class="calibre13">idc.get_name_ea_simple()</kbd> function returns the virtual address of <kbd class="calibre13">CreateFileA</kbd>. If <kbd class="calibre13">CreateFileA</kbd> does not exist, then it returns a value of <kbd class="calibre13">-1</kbd> (<kbd class="calibre13">idaapi.BADADDR</kbd>):</p>
<pre class="calibre18">import idc<br class="title-page-name"/>import idautils<br class="title-page-name"/><br class="title-page-name"/>ea = idc.get_name_ea_simple("CreateFileA")<br class="title-page-name"/>if ea != idaapi.BADADDR:<br class="title-page-name"/>    print hex(ea), idc.generate_disasm_line(ea,0)<br class="title-page-name"/>else:<br class="title-page-name"/>    print "Not Found"</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">5.2.2 Code Cross-References to CreateFile Using IDAPython</h1>
                
            
            <article>
                
<p class="calibre2">Having identified the reference to the <kbd class="calibre13">CreateFileA</kbd> function, let's try to identify <em class="calibre17">cross-references</em> to (<em class="calibre17">Xrefs to</em>) the <kbd class="calibre13">CreateFileA</kbd> function; this will give us all the addresses where <kbd class="calibre13">CreateFileA</kbd> is called from. The following script builds on the previous script and identifies the cross-references to the <kbd class="calibre13">CreateFileA</kbd> function:</p>
<pre class="calibre18">import idc<br class="title-page-name"/>import idautils<br class="title-page-name"/><br class="title-page-name"/>ea = idc.get_name_ea_simple("CreateFileA")<br class="title-page-name"/>if ea != idaapi.BADADDR:<br class="title-page-name"/>    for ref in idautils.CodeRefsTo(ea, 1):<br class="title-page-name"/>        print hex(ref), idc.generate_disasm_line(ref,0)</pre>
<p class="calibre2">The following is the output generated as a result of running the preceding script. The output displays all of the instructions that call the <kbd class="calibre13">CreateFileA</kbd> API function:</p>
<pre class="calibre18">0x401161   call  ds:CreateFileA<br class="title-page-name"/>0x4011aa   call  ds:CreateFileA<br class="title-page-name"/>0x4013fb   call  ds:CreateFileA<br class="title-page-name"/>0x401c4d   call  ds:CreateFileA<br class="title-page-name"/>0x401f2d   call  ds:CreateFileA<br class="title-page-name"/>0x401fb2   call  ds:CreateFileA</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">5.3 IDA Plugins</h1>
                
            
            <article>
                
<p class="calibre2">IDA plugins greatly enhance the capabilities of IDA, and most of the third-party software that are developed to be used with IDA are distributed in the form of plugins. A commercial plugin that is of great value to a malware analyst and reverse engineer is the <em class="calibre17">Hex-Rays Decompiler</em> (<a href="https://www.hex-rays.com/products/decompiler/" class="calibre10">https://www.hex-rays.com/products/decompiler/</a>). This decompiles the processor code into a human-readable C-like pseudocode, making it easier to read the code, and can speed up your analysis.</p>
<div class="packt_tip">The best place to find some of the interesting plugins is the Hex-Rays plugin contest page at <a href="https://www.hex-rays.com/contests/index.shtml" class="calibre20">https://www.hex-rays.com/contests/index.shtml</a>. You can also find a list of useful IDA plugins at <a href="https://github.com/onethawt/idaplugins-list" class="calibre20">https://github.com/onethawt/idaplugins-list</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6. Summary</h1>
                
            
            <article>
                
<p class="calibre2">This chapter covered <em class="calibre17">IDA Pro</em>: its features, and how to use it to perform static code analysis (disassembly). In this chapter, we also looked at some of the concepts related to the Windows API. Combining the knowledge that you gained from the previous chapter, and utilizing the features offered by IDA, can greatly enhance your reverse engineering and malware analysis capabilities. Even though disassembly allows us to understand what a program does, most variables are not hardcoded and get populated only when a program is executing. In the next chapter, you will learn how to execute malware in a controlled manner with the help of a debugger, and you will also learn how to explore various aspects of a binary while it is executing under a debugger.</p>


            </article>

            
        </section>
    </body></html>