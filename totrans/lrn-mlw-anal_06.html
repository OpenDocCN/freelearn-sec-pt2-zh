<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Debugging Malicious Binaries</h1>
                
            
            <article>
                
<p class="calibre2">Debugging is a technique in which malicious code is executed in a controlled manner. A debugger is a program that gives you the ability to inspect malicious code at a more granular level. It provides full control over the malware's runtime behavior and allows you to execute a <em class="calibre17">single instruction</em>, <em class="calibre17">multiple instructions</em>, or <em class="calibre17">select functions</em> (instead of executing the entire program), while studying the malware's every action.</p>
<p class="calibre2">In this chapter, you will mainly learn the debugging features offered by <em class="calibre17">IDA Pro (commercial disassembler/debugger)</em> and <em class="calibre17">x64dbg (open source x32/x64 debugger)</em>. You will learn about the features offered by these debuggers, and how to use them to inspect the runtime behavior of a program. Depending on the resources available, you will be free to choose either of these debuggers or both, for debugging the malicious binary. When you are debugging a malware, proper care needs to be taken, as you will be running the malicious code on a system. It is highly recommended that you perform any malware debugging in an isolated environment (as covered in <a href="part0020.html#J2B80-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 1</a>, <em class="calibre17"><span class="calibre7">Introduction to Malware Analysis</span></em>). At the end of this chapter, you will also see how to debug a .NET application using a .NET decompiler/debugger, <em class="calibre17">dnSpy</em> (<a href="https://github.com/0xd4d/dnSpy" class="calibre10">https://github.com/0xd4d/dnSpy</a>).</p>
<div class="packt_infobox">Other popular disassemblers/debuggers include <em class="calibre22">radare2</em> (<a href="http://rada.re/r/index.html" class="calibre20">http://rada.re/r/index.html</a>), the <span class="calibre21"><em class="calibre22">WinDbg</em> part of debugging tools for Windows (</span><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/" class="calibre20">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/</a><span class="calibre21">), </span><em class="calibre22">Ollydbg</em> (<a href="http://www.ollydbg.de/version2.html" class="calibre20">http://www.ollydbg.de/version2.html</a>), <em class="calibre22">Immunity Debugger</em> (<a href="https://www.immunityinc.com/products/debugger/" class="calibre20">https://www.immunityinc.com/products/debugger/</a>), <em class="calibre22">Hopper</em> (<a href="https://www.hopperapp.com/" class="calibre20">https://www.hopperapp.com/</a>), and <em class="calibre22">Binary Ninja</em> (<a href="https://binary.ninja/" class="calibre20">https://binary.ninja/</a>).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1. General Debugging Concepts</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre7">Before we delve into the features offered by these debuggers (<em class="calibre17">IDA Pro</em>, <em class="calibre17">x64dbg</em>, and <em class="calibre17">DnSpy</em>), It is essential to understand some of the common features that most debuggers provide. In this section, you will mainly see the general debugging concepts; in the subsequent sections, we will focus on the essential features of <em class="calibre17">IDA Pro</em>, <em class="calibre17">x64dbg,</em> and <em class="calibre17">dnSpy</em>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.1 Launching And Attaching To Processes</h1>
                
            
            <article>
                
<p class="calibre2">Debugging normally begins by selecting the program to debug. There are two ways to debug a program:<span class="calibre7"> </span><em class="calibre17">(a) attach the debugger to a running process,</em> and<span class="calibre7"> </span><em class="calibre17">(b) launch a new process</em>. When you attach the debugger to a running process, you will not be able to control or monitor the process's initial actions, because by the time you have a chance to attach to the process, all of its startup and initialization code will have already been executed. When you attach the debugger to a process, the debugger suspends the process, giving you a chance to inspect the process's resources or set a breakpoint before resuming the process.</p>
<p class="calibre2">On the other hand, launching a new process allows you to monitor or debug every action the process takes, and you will also be able to monitor the process's initial actions. When you start the debugger, the original binary will be executed with the privileges of the user running the debugger. When the process is launched under a debugger, the execution will pause at the <em class="calibre17">program's entry point</em>. A program's entry point is the address of the first instruction that will be executed. In later sections, you will learn how to <em class="calibre17">launch</em> and <em class="calibre17">attach</em> to a process using <em class="calibre17">IDA Pro</em>, <em class="calibre17">x64dbg</em>, and <em class="calibre17">dnSpy</em>.</p>
<div class="packt_infobox">A program's entry point is not necessarily the<span class="calibre21"> </span><kbd class="calibre42">main</kbd><span class="calibre21"> </span>or<span class="calibre21"> </span><kbd class="calibre42">WinMain</kbd><span class="calibre21"> </span>function; before transferring control to<span class="calibre21"> </span><kbd class="calibre42">main</kbd><span class="calibre21"> </span>or<span class="calibre21"> </span><kbd class="calibre42">WinMain</kbd>, the initialization routine (startup routine) is executed. The purpose of the startup routine is to initialize the program's environment before passing control to the <kbd class="calibre42">main</kbd> function. This initialization is designated, by the debuggers, as the entry point of the program.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.2 Controlling Process Execution</h1>
                
            
            <article>
                
<p class="calibre2">A debugger gives you the ability to control/modify the behavior of the process while it is executing. The two important capabilities offered by a debugger<span class="calibre7"> </span>are: <em class="calibre17">(a) the ability to control execution,</em> and<span class="calibre7"> </span><em class="calibre17">(b) the ability to interrupt execution (using breakpoints)</em>. Using a debugger, you can execute one or more instructions (or select functions) before returning control to the debugger. During analysis, you will combine both the debugger's controlled execution and the interruption (breakpoint) feature to monitor a malware's behavior. In this section, you will learn about the common <em class="calibre17">execution control</em> functionalities offered by the debuggers; in later sections, you will learn how to use these features in <em class="calibre17">IDA Pro</em>, <em class="calibre17">x64dbg</em>, and <em class="calibre17">dnSpy.</em></p>
<p class="calibre2">The following are some of the common execution control options provided by the debuggers:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Continue (Run)</strong>:<span> This</span> executes all of the instructions, until a breakpoint is reached or an exception occurs. When you load a malware into a debugger and use the <em class="calibre19">continue (Run)</em> option without setting the breakpoint, it will execute all of the instructions without giving you any control; so, you normally use this option along with breakpoint, to interrupt the program at the breakpoint location.</li>
<li class="calibre12"><strong class="calibre1">Step into and Step over</strong>: Using <em class="calibre19">step into</em> and <em class="calibre19">step over,</em> you can execute a single instruction. After executing the single instruction, the debugger stops, giving you a chance to inspect the process's resources. The difference between <em class="calibre19">step into</em> and <em class="calibre19">step over</em> occurs when you are executing an instruction that calls a function. For example, in the following code, at<span> ➊</span>, there is a call to the function<span> </span><kbd class="calibre13">sub_401000</kbd>. When you use the <em class="calibre19">step into</em> option on this instruction, the debugger will stop at the start of the function (at the address <kbd class="calibre13">0x401000</kbd>), whereas when you use <em class="calibre19">step over</em>, the entire function will be executed, and the debugger will pause at the next instruction,<span> ➋</span> (that is, the address<span> </span><kbd class="calibre13">0x00401018</kbd>). You will normally use <em class="calibre19">step into</em><span> </span>to get inside a function, to understand its inner workings. S<em class="calibre19">tep over</em> is used when you already know what a function does (such as in an API function) and would like to skip over it:</li>
</ul>
<pre class="calibre25">.text:00401010     push  ebp<br class="title-page-name"/>.text:00401011     mov   ebp, esp<br class="title-page-name"/>.text:00401013     call  sub_401000  ➊<br class="title-page-name"/>.text:00401018     xor   eax,eax  ➋</pre>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Execute till Return (Run until return)</strong>:<span> </span>This option allows you to execute all of the instructions in the current function, until it returns. This is useful if you accidentally step into a function (or step into a function that is not interesting) and would like to come out of it. Using this option inside a function will take you to the end of the function (<kbd class="calibre13">ret</kbd> or <kbd class="calibre13">retn</kbd>), after which you can use either the <em class="calibre19">step into</em> or <em class="calibre19">step over</em> option to return to the calling function.</li>
<li class="calibre12"><strong class="calibre1">Run to<span> </span>cursor<span> </span>(Run until selection)</strong>:<span> </span>This allows you to execute instructions until the <em class="calibre19">current cursor location,</em> or until the <em class="calibre19">selected instruction</em> is reached.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.3 Interrupting a Program with Breakpoints</h1>
                
            
            <article>
                
<p class="calibre2">A <em class="calibre17">breakpoint</em> is a debugger feature that allows you to interrupt program execution at a very specific location within a program. Breakpoints can be used to pause the execution at a particular instruction, or when the program calls a function/API function, or when the program reads, writes, or executes from a memory address. You can set multiple breakpoints all over a program, and execution will be interrupted upon reaching any of the breakpoints. Once a breakpoint has been reached, it is possible to monitor/modify various aspects of the process. Debuggers typically allow you to set different types of breakpoints:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Software Breakpoints</strong>: By default, debuggers make use of software breakpoints. Software breakpoints are implemented by replacing the instruction at a breakpoint address with a software breakpoint instruction, such as the<span> </span><kbd class="calibre13">int 3</kbd><span> </span>instruction (having <span>an</span> opcode<span> </span>of<span> </span><kbd class="calibre13">0xCC</kbd>). When a software breakpoint instruction (such as<span> </span><kbd class="calibre13">int 3</kbd>) is executed, the control is transferred to the debugger, which is debugging the interrupted process. The advantage of using software breakpoints is that you can set an unlimited number of breakpoints. The disadvantage is that malware can look for the breakpoint instruction<span> (</span><kbd class="calibre13">int 3</kbd>)<span> </span>and modify it to change the normal operation of an attached debugger.</li>
<li class="calibre12"><strong class="calibre1">Hardware Breakpoints</strong>:<span> A </span>CPU, such as x86, supports hardware breakpoints through the use of the CPU's debug registers, <kbd class="calibre13">DR0 - DR7</kbd>. You can set a maximum of four hardware breakpoints using <kbd class="calibre13">DR0-DR3</kbd>; the other remaining debug registers are used to specify additional conditions on each breakpoint. In the case of hardware breakpoints, no instruction is replaced, but the CPU decides whether the program should be interrupted, based on the values contained within the debug registers.</li>
<li class="calibre12"><strong class="calibre1">Memory Breakpoints</strong>:<span> </span>These breakpoints allow you to pause the execution when an instruction accesses (<em class="calibre19">reads from</em> or <em class="calibre19">writes to</em>) the memory, rather than the execution. This is useful if you want to know when a particular memory is accessed (<em class="calibre19">read</em> or <em class="calibre19">write</em>), and to know which instruction accesses it. For example, if you find an interesting string or data in the memory, you can set a memory breakpoint on that address to determine under what circumstances the memory is accessed.</li>
<li class="calibre12"><strong class="calibre1">Conditional Breakpoints</strong>: Using conditional breakpoints, you can specify the condition that must be satisfied to trigger the breakpoint. If a conditional breakpoint is reached but the condition is not satisfied, the debugger automatically resumes the execution of the program. Conditional breakpoints are not an instruction feature or a CPU feature; they are a feature offered by the debugger. You can therefore specify conditions for both software and hardware breakpoints. When the conditional breakpoint is set, it is the debugger's responsibility to evaluate the conditional expression and determine whether the program needs to be interrupted or not.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.4 Tracing Program Execution</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre7"><em class="calibre17">Tracing</em> is a debugging feature that allows you to record (<em class="calibre17">log</em>) specific events while the process is executing. Tracing gives you detailed execution information on a binary. In later sections, you will learn about the different types of tracing capabilities provided by <em class="calibre17">IDA</em> and <em class="calibre17">x64dbg</em>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2. Debugging a Binary Using x64dbg</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre7"><em class="calibre17">x64dbg</em> (<a href="https://x64dbg.com" class="calibre10">https://x64dbg.com</a>) is an open source debugger. You can use <em class="calibre17">x64dbg</em> to debug both 32-bit and 64-bit applications. It has an easy-to-use GUI and offers various debugging features (<a href="https://x64dbg.com/#features" class="calibre10">https://x64dbg.com/#features</a>).</span></p>
<p class="calibre2"><span class="calibre7">In this section, you will see some of the debugging features offered by <em class="calibre17">x64dbg,</em> and how to use it to debug a malicious binary.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.1 Launching a New Process in x64dbg</h1>
                
            
            <article>
                
<p class="calibre2">In <em class="calibre17">x64dbg</em>, to load an executable, select<span class="calibre7"> </span><span class="calibre7">File | Open</span><span class="calibre7"> </span>and browse to the file that you wish to debug; this will start the process, and the debugger will pause at the <em class="calibre17">System Breakpoint</em>, the <em class="calibre17">TLS callback,</em> or the <em class="calibre17">program entry point</em> function, depending on the configuration settings. You can access the <span class="calibre7">settings</span> dialog by choosing<span class="calibre7"> </span><span class="calibre7">Options | Preferences | Events</span>. The default <span class="calibre7">settings</span> dialog is shown as follows, with the default settings when the executable is loaded. The debugger first breaks in the system function (because the <span class="calibre7">System Breakpoint*</span> option is checked). Next, after you run the debugger, it will pause at the <em class="calibre17">TLS Callback</em> function, if present (because the <span class="calibre7">TLS callbacks*</span> option is checked). This is sometimes useful, because some anti-debugger tricks contain TLS entries that allow malware to execute code before the main application runs. If you further execute the program, the execution pauses at the entry point of the program:</p>
<div class="cdpaligncenter"><img src="../images/00125.jpeg" class="calibre126"/></div>
<p class="calibre2">If you want the execution to pause directly at the <em class="calibre17">program's entry point</em>, then uncheck the <span class="calibre7">System Breakpoint*</span> and <span class="calibre7">TLS Callbacks*</span> options (this configuration should work fine for most malware programs, unless the malware uses anti-debugging tricks). To save the configuration settings, just click the <span class="calibre7">save</span> button. With this configuration, when an executable is loaded, the process starts, and execution is paused at the <em class="calibre17">program's entry point,</em> as shown here:</p>
<div class="cdpaligncenter"><img src="../images/00126.jpeg" class="calibre127"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2 Attaching to an Existing Process Using x64dbg</h1>
                
            
            <article>
                
<p class="calibre2">To attach to an existing process in <em class="calibre17">x64dbg</em>, select<span class="calibre7"> </span><span class="calibre7">File | Attach</span><span class="calibre7"> </span>(or<span class="calibre7"> </span><em class="calibre17">Alt </em>+ <em class="calibre17">A</em>); this will bring up a dialog displaying the running processes, as follows. Choose the process that you wish to debug and click on the<span class="calibre7"> </span><span class="calibre7">Attach</span> button. When the debugger is attached, the process is suspended, giving you time to set breakpoints and inspect the process's resources. When you close the debugger, the attached process will terminate. If you do not want the attached process to terminate, you can detach a process by selecting<span class="calibre7"> </span><span class="calibre7">File | Detach</span><span class="calibre7"> </span>(<em class="calibre17">Ctrl</em> + <em class="calibre17">Alt</em> + <em class="calibre17">F2</em>); this ensures that the attached process is not terminated when you close the debugger:</p>
<div class="cdpaligncenter"><img src="../images/00127.jpeg" class="calibre128"/></div>
<div class="packt_tip">Sometimes, when you try attaching the debugger to a process, you will find that not all of the processes are listed in the dialog. In that case, make sure that you are running the debugger as an<span class="calibre21"> </span><em class="calibre22">administrator; </em>you need to enable the <em class="calibre22">debug privilege</em> settings by selecting<span class="calibre21"> </span><span class="calibre21">Options | Preferences</span><span class="calibre21"> </span>and, in the <span class="calibre21">Engine</span> tab, checking the<span class="calibre21"> </span><span class="calibre21">Enable Debug Privilege</span><span class="calibre21"> </span>option.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.3 x64dbg Debugger Interface</h1>
                
            
            <article>
                
<p class="calibre2">When you load a program in <em class="calibre17">x64dbg</em>, you will be presented with a debugger display, as follows. The debugger display contains multiple tabs; each tab displays different windows. Each window contains different information regarding the debugged binary:</p>
<div class="cdpaligncenter"><img src="../images/00128.jpeg" class="calibre129"/></div>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Disassembly Window (CPU Window)</strong>: This shows the disassembly of all of the instructions of the debugged program. This window presents the disassembly in a linear fashion, and it is synchronized with the current value of the instruction pointer register (<kbd class="calibre13">eip</kbd><span> </span>or<span> </span><kbd class="calibre13">rip</kbd>). The left portion of this window displays an <em class="calibre19">arrow</em> to indicate the program's non-linear flow (such as <em class="calibre19">branching</em> or <em class="calibre19">looping</em>). You can display the control flow graph by pressing<span> the </span><em class="calibre19">G</em><span> </span>hotkey. The control graph is shown as follows; conditional jumps use <em class="calibre19">green</em> and <em class="calibre19">red</em> arrows. The green arrow indicates that the jump will be taken if the condition is true, and the red arrow indicates that the jump will not be taken. The blue arrow is used for unconditional jumps, and a loop is indicated by the upward (backward) blue arrow:</li>
</ul>
<div class="cdpaligncenter"><img src="../images/00129.jpeg" class="calibre130"/></div>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Registers Window</strong>: This window displays the current state of the CPU registers. The value in a register can be modified by double-clicking on the register and entering a new value (you can also right-click and modify the value of a register to <em class="calibre19">zero</em> or <em class="calibre19">increment</em>/<em class="calibre19">decrement</em> the value of the register). You can toggle the flag bits <em class="calibre19">on</em> or <em class="calibre19">off</em> by double-clicking on the values of the flag bits. You cannot change the value of the instruction pointer (<kbd class="calibre13">eip</kbd><span> </span>or<span> </span><kbd class="calibre13">rip</kbd>). As you are debugging the program, the register values can change; the debugger highlights register values with a <em class="calibre19">red color,</em> to indicate a change since the last instruction.</li>
<li class="calibre12"><strong class="calibre1">Stack Window</strong>:<span> </span>The <em class="calibre19">stack view</em> displays the data contents of the process's runtime stack. During malware analysis, you will typically inspect the stack before calling a function, to determine the number of arguments passed to the function and the types of the function arguments (such as <em class="calibre19">integer</em> or <em class="calibre19">character pointer</em>).</li>
<li class="calibre12"><strong class="calibre1">Dump Window</strong>: This displays the standard hex dump of the memory. You can use the dump window to examine the contents of any valid memory address in the debugged process. For example, if a stack location, register, or instruction contains a valid memory location, to examine the memory location, right-click on the address and choose <span>the</span><span> </span><span>Follow </span><span>in</span><span> </span><span>Dump </span><span>option.</span></li>
<li class="calibre12"><strong class="calibre1">Memory Map Window</strong>: You can click on the <span>Memory Map</span> tab to display the contents of the <em class="calibre19">Memory Map</em> <em class="calibre19">window</em>. This provides the layout of the process memory and gives you the details of the allocated memory segments in the process. It is a great way to see where the executables and their sections are loaded in the memory. This window also contains information about the process DLLs and their sections in the memory. You can double-click on any entry to relocate the display to the corresponding memory location:</li>
</ul>
<div class="cdpaligncenter"><img src="../images/00130.jpeg" class="calibre131"/></div>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Symbols Window</strong>: You can click on the <span>Symbols</span> tab to display the contents of the <em class="calibre19">Symbols window</em>. The left pane displays a list of the loaded modules (the executable and its DLLs); clicking on a module entry will display its <em class="calibre19">import</em> and <em class="calibre19">export</em> functions in the right pane, as follows. This window can be useful in determining where the import and export functions reside in the memory:</li>
</ul>
<div class="cdpaligncenter"><img src="../images/00131.jpeg" class="calibre132"/></div>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">References Window</strong>:<span> </span>This window displays the references to the API calls. Clicking on the <span>References</span> tab will not display the references to the API by default. To populate this window, right-click anywhere in the <em class="calibre19">disassembly (CPU)</em> window (with the executable loaded), then select<span> </span><span>Search for | Current Module | Intermodular calls;</span><span> </span>this will populate the <em class="calibre19">references window</em> with the references to all of the API calls in the program. The following screenshot displays references to the multiple API functions; the first entry tells you that at the address<span> </span><kbd class="calibre13">0x00401C4D</kbd><span>, </span>the instruction calls the<span> </span><kbd class="calibre13">CreateFileA</kbd><span> </span>API (which is exported by<span> </span><kbd class="calibre13">Kernel32.dll</kbd>). Double-clicking on the entry will take you to the corresponding address (in this case,<span> </span><kbd class="calibre13">0x00401C4D</kbd>). You can also set a breakpoint at this address; once the breakpoint is hit, you can inspect the parameters passed to the<span> </span><kbd class="calibre13">CreateFileA</kbd><span> </span>function:</li>
</ul>
<div class="cdpaligncenter"><img src="../images/00132.jpeg" class="calibre133"/></div>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Handles Window</strong>: You can click on the<span> </span><span>Handles</span><span> </span>tab to bring up the <em class="calibre19">handles window</em>; to display the contents, right-click inside the handles window and select<strong class="calibre1"><span> </span></strong><span>Refresh</span><span> </span>(or <em class="calibre19">F5</em>). This displays the details of all of the open handles. In the previous chapter, when we discussed the Windows API, you learned that the process can open handles to an object (such as the <em class="calibre19">file</em>, <em class="calibre19">registry</em>, and so on), and these handles can be passed to functions, such as<span> </span><kbd class="calibre13">WriteFile</kbd><span>, </span>to perform subsequent operations. The handles are useful when you are inspecting an API, such as<span> </span><kbd class="calibre13">WriteFile</kbd><span>, </span>that will tell you the object associated with the handle. For example, when debugging a malware sample, it is determined that the<span> </span><kbd class="calibre13">WriteFile</kbd><span> </span>API call accepts a handle value of<span> </span><kbd class="calibre13">0x50</kbd>. Inspecting the handles window shows that the handle value<span> </span><kbd class="calibre13">0x50</kbd><span> </span>is associated with the file<span> </span><kbd class="calibre13">ka4a8213.log</kbd><span>, </span>as shown here:</li>
</ul>
<div class="cdpaligncenter"><img src="../images/00133.jpeg" class="calibre134"/></div>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Threads Window</strong>: This displays the list of threads in the current process. You can right-click on this window and <em class="calibre19">suspend</em> a thread/threads or <em class="calibre19">resume</em> a suspended thread.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.4 Controlling Process Execution Using x64dbg</h1>
                
            
            <article>
                
<p class="calibre2">In S<em class="calibre17">ection 1.2</em>, <em class="calibre17">Controlling Process Execution</em>, we looked at the different execution control features provided by the debuggers. The following table outlines the common execution options and how to access these options in <em class="calibre17">x64dbg</em>:</p>
<table border="1" class="calibre46">
<tbody class="calibre47">
<tr class="calibre48">
<td class="calibre49">Functionality</td>
<td class="calibre49">Hotkey</td>
<td class="calibre49">Menu</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><span>Run</span></td>
<td class="calibre49"><em class="calibre19"><span>F9</span></em></td>
<td class="calibre49"><span><span>Debugger</span> | <span>Run</span></span></td>
</tr>
<tr class="calibre48">
<td class="calibre49"><span>Step into</span></td>
<td class="calibre49"><em class="calibre19"><span>F7</span></em></td>
<td class="calibre49"><span><span>Debugger</span> | <span>Step into</span></span></td>
</tr>
<tr class="calibre48">
<td class="calibre49"><span>Step over</span></td>
<td class="calibre49"><em class="calibre19"><span>F8</span></em></td>
<td class="calibre49"><span><span>Debugger</span> | <span>Step over</span></span></td>
</tr>
<tr class="calibre48">
<td class="calibre49"><span>Run until selection</span></td>
<td class="calibre49"><em class="calibre19"><span>F4</span></em></td>
<td class="calibre49"><span><span>Debugger</span> | <span>Run until selection</span></span></td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.5 Setting a Breakpoint in x64dbg</h1>
                
            
            <article>
                
<p class="calibre2">In <em class="calibre17">x64dbg</em>, you can set a software breakpoint by navigating to the address where you want the program to pause and pressing the<span class="calibre7"> </span><em class="calibre17">F2</em><span class="calibre7"> </span>key (or right-clicking and selecting<span class="calibre7"> </span><span class="calibre7">Breakpoint | Toggle</span>). To set a hardware breakpoint, right-click on the location where you want to set the breakpoint and select<span class="calibre7"> </span><span class="calibre7">Breakpoint | Set Hardware on Execution</span>.</p>
<p class="mce-root4">You can also use hardware breakpoints to break on <em class="calibre17">write</em> or break on<span class="calibre7"> </span><em class="calibre17">read/write</em> (access)<span class="calibre7"> </span>to<span class="calibre7"> </span>a memory location. To set <span class="calibre7">a</span> hardware breakpoint on memory access, in the dump pane, right-click on the desired address and select<span class="calibre7"> </span><span class="calibre7">Breakpoint</span> | <span class="calibre7">Hardware</span>, <span class="calibre7">Access</span>, and then choose the appropriate data type (such as <span class="calibre7">byte</span>, <span class="calibre7">word</span>, <span class="calibre7">dword</span>, or <span class="calibre7">qword</span>), as shown in the following screenshot. In the same manner, you can set the hardware breakpoint on memory write by choosing<span class="calibre7"> the </span><span class="calibre7">Breakpoint</span> | <span class="calibre7">Hardware</span>, <span class="calibre7">Write</span><span class="calibre7"> </span>option:</p>
<div class="cdpaligncenter"><img src="../images/00134.jpeg" class="calibre135"/></div>
<p class="calibre2">In addition to hardware memory breakpoints, you can also set memory breakpoints in the same manner. To do that, in the dump pane, right-click on the desired address and select<span class="calibre7"> </span><span class="calibre7">Breakpoint | Memory, Access</span> (for memory access) or <span class="calibre7">Breakpoint</span> | <span class="calibre7">Memory</span>, <span class="calibre7">Write </span>(for memory write).</p>
<p class="calibre2">To view all of the active breakpoints, just click on the <span class="calibre7">Breakpoints</span> tab; this will list all of the software, hardware, and memory breakpoints in the <span class="calibre7">Breakpoints</span> window. You can also right-click on any instruction inside the <span class="calibre7">Breakpoints</span> window and remove a single breakpoint, or all of the breakpoints.</p>
<div class="packt_infobox">For more information on the options available in <em class="calibre22">x64dbg,</em> refer to the <em class="calibre22">x64dbg</em> online documentation at<span class="calibre21"> </span><a href="http://x64dbg.readthedocs.io/en/latest/index.html" class="calibre20">http://x64dbg.readthedocs.io/en/latest/index.html</a>. You can also access the <em class="calibre22">x64dbg</em> help manual by pressing <em class="calibre22">F1</em> while you are in the <em class="calibre22">x64dbg</em> interface.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.6 Debugging 32-bit Malware</h1>
                
            
            <article>
                
<p class="calibre2">With an understanding of debugging features, let's look at how debugging can help us to understand malware behavior. Consider a code excerpt from a malware sample, where the malware calls the <kbd class="calibre13">CreateFileA</kbd> function to create a file. To determine the name of the file that it creates, you can set a breakpoint at the call to the <kbd class="calibre13">CreateFileA</kbd> function and execute the program until it reaches the breakpoint. When it reaches the breakpoint (that is, before calling <kbd class="calibre13">CreateFileA</kbd>), all of the parameters to the function will be pushed onto the stack; we can then examine the <em class="calibre17">first parameter</em> on the stack to determine the name of the file. In the following screenshot, when the execution is paused at the breakpoint, <em class="calibre17">x64dbg</em> adds a comment (if it's a string) next to the instruction and next to the argument on the stack, to indicate what parameter is being passed to the function. From the screenshot, you can tell that the malware creates an executable file, <kbd class="calibre13">winlogdate.exe</kbd>, in the <kbd class="calibre13">%Appdata%\Microsoft</kbd> directory. You can also get this information by right-clicking on the first argument in the <span class="calibre7">stack window</span> and selecting the follow <span class="calibre7">DWORD in dump</span> option, which displays the contents in the <span class="calibre7">hex window:</span></p>
<div class="cdpaligncenter"><img src="../images/00135.jpeg" class="calibre136"/></div>
<p class="calibre2">After creating the executable file, the malware passes the handle value (<kbd class="calibre13">0x54</kbd>) returned by the<span class="calibre7"> </span><kbd class="calibre13">CreateFile</kbd><span class="calibre7"> </span>as the first parameter to the<span class="calibre7"> </span><kbd class="calibre13">WriteFile</kbd><span class="calibre7">, </span>and writes the executable content (which is passed as the second parameter), as shown here:</p>
<div class="cdpaligncenter"><img src="../images/00136.jpeg" class="calibre137"/></div>
<p class="calibre2">Let's assume that you do not know which object is associated with the handle<span class="calibre7"> </span><kbd class="calibre13">0x54</kbd>, probably because you set a breakpoint directly on<span class="calibre7"> </span><kbd class="calibre13">WriteFile</kbd><span class="calibre7"> </span>without initially setting a breakpoint on<span class="calibre7"> </span><kbd class="calibre13">CreateFile</kbd>. To determine the object that is associated with a handle value, you can look it up in the<span class="calibre7"> </span><span class="calibre7">Handles</span><span class="calibre7"> </span>window. In this case, the handle value<span class="calibre7"> </span><kbd class="calibre13">0x54</kbd><span class="calibre7">, </span>passed as the first parameter to the<span class="calibre7"> </span><kbd class="calibre13">WriteFile</kbd><span class="calibre7">, </span>is associated with<span class="calibre7"> </span><kbd class="calibre13">winlogdate.exe</kbd><span class="calibre7">, </span>as shown here:</p>
<div class="cdpaligncenter"><img src="../images/00137.gif" class="calibre138"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.7 Debugging 64-bit Malware</h1>
                
            
            <article>
                
<p class="calibre2">You will use the same technique to debug a 64-bit malware; the difference is, you will be dealing with <em class="calibre17">extended registers</em>, <em class="calibre17">64-bit memory addresses/pointers</em>, and slightly different <em class="calibre17">calling conventions</em>. If you recall (from <a href="part0088.html#2JTHG0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 4</a>, <em class="calibre17">Assembly Language and Disassembly Primer</em>), a 64-bit code uses the<span class="calibre7"> </span><kbd class="calibre13">FASTCALL</kbd><span class="calibre7"> </span>calling convention and passes the first four parameters to the function in the registers (<kbd class="calibre13">rcx</kbd>, <kbd class="calibre13">rdx</kbd>, <kbd class="calibre13">r8</kbd>, and <kbd class="calibre13">r9</kbd>), and the rest of the parameters are placed on the stack. While debugging the call to a function/API, depending on the parameter you are inspecting, you will have to inspect the <em class="calibre17">register</em> or the <em class="calibre17">stack</em>. The calling convention mentioned previously is applicable to compiler-generated code. An attacker writing code in the assembly language need not follow these rules; as a result, the code can exhibit unusual behavior. When you come across code that is not compiler-generated, a further investigation of the code may be required.</p>
<p class="calibre2">Before we debug a 64-bit malware, let's try to understand the behavior of a 64-bit binary with the following trivial C program, which was compiled for the 64-bit platform using the <em class="calibre17">Microsoft Visual C/C++</em> compiler:</p>
<pre class="calibre18">int main()<br class="title-page-name"/>{<br class="title-page-name"/>  printf("%d%d%d%d%s%s%s", 1, 2, 3, 4, "this", "is", "test");<br class="title-page-name"/>  return 0;<br class="title-page-name"/>}</pre>
<p class="calibre2"><span class="calibre7">In the preceding program, the</span><span class="calibre7"> </span><kbd class="calibre13">printf</kbd><span class="calibre7"> </span><span class="calibre7">function takes eight arguments; this program was compiled and</span> opened in <em class="calibre17">x64dbg</em>, and a breakpoint was set at the<span class="calibre7"> </span><kbd class="calibre13">printf</kbd><span class="calibre7"> </span>function. The following screenshot shows the program, which is paused before the call to the <kbd class="calibre13">printf</kbd> function. In the <span class="calibre7">registers</span> window, you can see that the first four parameters are placed in the <kbd class="calibre13">rcx</kbd>, <kbd class="calibre13">rdx</kbd>, <kbd class="calibre13">r8</kbd>, and <kbd class="calibre13">r9</kbd><span class="calibre7"> </span>registers. When the program calls a function, the function reserves<span class="calibre7"> </span><kbd class="calibre13">0x20</kbd><span class="calibre7"> </span>(<kbd class="calibre13">32</kbd> bytes) of space on the stack (space for four items, each <kbd class="calibre13">8</kbd> bytes in size); this is to make sure that the called function has the necessary space, if it needs to save the register parameters (<kbd class="calibre13">rcx</kbd><span class="calibre7">, </span><kbd class="calibre13">rdx</kbd><span class="calibre7">, </span><kbd class="calibre13">r8</kbd><span class="calibre7">, and </span><kbd class="calibre13">r9</kbd>). This is the reason the next four parameters (the 5<sup class="calibre139">th</sup>, 6<sup class="calibre139">th</sup>, 7<sup class="calibre139">th</sup>, and 8<sup class="calibre139">th</sup> parameters) are placed on the stack, starting from the fifth item (<kbd class="calibre13">rsp+0x20</kbd>). We are showing you this example to give you an idea of how to find the parameters on the stack:</p>
<div class="cdpaligncenter"><img src="../images/00138.jpeg" class="calibre140"/></div>
<p class="calibre2">In the case of a 32-bit function, the stack grows as the arguments are <em class="calibre17">pushed</em>, and shrinks when the items are <em class="calibre17">popped</em>. In a 64-bit function, the stack space is allocated at the beginning of the function, and does not change until the end of the function. The allocated stack space is used to store the local variables and the function parameters. In the preceding screenshot, note how the first instruction,<span class="calibre7"> </span><kbd class="calibre13">sub rsp,48</kbd><span class="calibre7">, </span>allocates<span class="calibre7"> </span><kbd class="calibre13">0x48</kbd> (<kbd class="calibre13">72</kbd>) bytes of space on the stack, after which no stack space is allocated in the middle of the function; also, instead of using<span class="calibre7"> </span><kbd class="calibre13">push</kbd><span class="calibre7"> </span>and<span class="calibre7"> </span><kbd class="calibre13">pop</kbd><span class="calibre7"> </span>instructions, the<span class="calibre7"> </span><kbd class="calibre13">mov</kbd><span class="calibre7"> </span>instructions are used to place the 5<sup class="calibre139">th</sup>, 6<sup class="calibre139">th</sup>, 7<sup class="calibre139">th</sup>, and 8<sup class="calibre139">th</sup> parameters on the stack (highlighted in the preceding screenshot). The lack of<span class="calibre7"> </span><kbd class="calibre13">push</kbd><span class="calibre7"> </span>and<span class="calibre7"> </span><kbd class="calibre13">pop</kbd><span class="calibre7"> </span>instructions makes it difficult to determine the number of parameters accepted by the function, and it is also hard to say whether the memory address is being used as a local variable or a parameter to the function. Another challenge is, if the values are moved into the registers<span class="calibre7"> </span><kbd class="calibre13">rcx</kbd><span class="calibre7"> </span>and<span class="calibre7"> </span><kbd class="calibre13">rdx</kbd><span class="calibre7"> </span>before the function call, it's hard to say whether they are parameters passed to the function, or if they are moved into registers for any other reason.</p>
<p class="calibre2">Even though there are challenges in reverse engineering a 64-bit binary, you should not have too much difficulty analyzing the API calls, because the API documentation tells you the <em class="calibre17">number of function parameters</em>, the <em class="calibre17">data types of the parameters,</em> and what <em class="calibre17">type of data</em> they return. Once you have an idea of where to find the function parameters and the return values, you can set a breakpoint at the API call and inspect its parameters to understand the malware functionality.</p>
<p class="calibre2">Let's look at an example of a 64-bit malware sample that calls<span class="calibre7"> </span><kbd class="calibre13">RegSetValueEx</kbd><span class="calibre7"> </span>to set some value in the<span class="calibre7"> </span>registry. In the following screenshot, the breakpoint is triggered before the call to the<span class="calibre7"> </span><kbd class="calibre13">RegSetValueEx</kbd>. You will need to look at the values in the registers and the stack window (as mentioned previously) to examine the parameters passed to the function; this will help you determine what registry value is set by the malware. In <em class="calibre17">x64dbg</em>, the easiest way to get a quick summary of function parameters is to look at the <span class="calibre7">Default Window</span> (below the <span class="calibre7">registers window</span>), which is highlighted in the following screenshot. You can set a value in the <span class="calibre7">Default window</span> to display the number of parameters. In the following screenshot, the value is set to <kbd class="calibre13">6</kbd>, because from the API documentation (<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724923(v=vs.85).aspx" target="_blank" class="calibre10">https://msdn.microsoft.com/en-us/library/windows/desktop/ms724923(v=vs.85).aspx</a>), you can tell that the<span class="calibre7"> </span><kbd class="calibre13">RegSetValueEx</kbd><span class="calibre7"> </span>API takes <kbd class="calibre13">6</kbd> parameters:</p>
<div class="cdpaligncenter"><img src="../images/00139.jpeg" class="calibre141"/></div>
<p class="calibre2">The first parameter value,<span class="calibre7"> </span><kbd class="calibre13">0x2c</kbd><span class="calibre7">, </span>is the handle to the open registry key. Malware can open a handle to the registry key by calling either the<span class="calibre7"> </span><kbd class="calibre13">RegCreateKey</kbd><span class="calibre7"> </span>or<span class="calibre7"> </span><kbd class="calibre13">RegOpenKey</kbd><span class="calibre7"> </span>API. From the <span class="calibre7">handles</span> window, you can tell that the handle value<span class="calibre7"> </span><kbd class="calibre13">0x2c</kbd><span class="calibre7"> </span>is associated with the registry key shown in the following screenshot. From the handle information, and through inspecting the 1<sup class="calibre139">st,</sup> 2<sup class="calibre139">nd</sup>, and 5<sup class="calibre139">th</sup> parameters, you can tell that malware modifies the registry key,<span class="calibre7"> </span><kbd class="calibre13">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsNT\CurrentVersion\Winlogon\shell</kbd><span class="calibre7">, </span>and adds an entry, <kbd class="calibre13">"explorer.exe,logoninit.exe"</kbd>.<span class="calibre7"> </span>On a clean system, this registry key points to<span class="calibre7"> </span><kbd class="calibre13">explorer.exe</kbd><span class="calibre7"> </span>(the default Windows shell). When the system starts, the<span class="calibre7"> </span><kbd class="calibre13">Userinit.exe</kbd><span class="calibre7"> </span>process uses this value to launch the Windows shell (<kbd class="calibre13">explorer.exe</kbd>). By adding<span class="calibre7"> </span><kbd class="calibre13">logoninit.exe</kbd><span class="calibre7">, </span>along with<span class="calibre7"> </span><kbd class="calibre13">explorer.exe</kbd><span class="calibre7">, the malware </span>makes sure that<span class="calibre7"> </span><kbd class="calibre13">logoninit.exe</kbd><span class="calibre7"> </span>is also launched by<span class="calibre7"> </span><kbd class="calibre13">Userinit.exe</kbd>; this is another type of persistence mechanism used by the malware:</p>
<div class="cdpaligncenter"><img src="../images/00140.jpeg" class="calibre142"/></div>
<p class="calibre2">At this point, you should have an understanding of how to debug a malicious executable to understand its functionality. In the next section, you will learn how to debug a malicious DLL to determine its behavior.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.8 Debugging a Malicious DLL Using x64dbg</h1>
                
            
            <article>
                
<p class="calibre2">In <a href="part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">chapter 3</a>,<em class="calibre17"> Dynamic Analysis</em><span class="calibre7">, you learned techniques to execute a DLL to perform dynamic analysis. In this section, you will use some of the concepts that you learned in <a href="https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=885&amp;action=edit#post_522" class="calibre10">chapter 3</a>,<em class="calibre17"> Dynamic Analysis</em></span>,<span class="calibre7"> to debug a DLL using <em class="calibre17">x64dbg</em>. If you are not already familiar with the dynamic analysis of a DLL, it is highly recommended to read S</span><em class="calibre17">ection 6</em>, <em class="calibre17">Dynamic-Link Library (DLL) Analysis</em>,<span class="calibre7"> from <a href="https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=885&amp;action=edit#post_522" class="calibre10">Chapter 3</a>,<em class="calibre17"> Dynamic Analysis,</em></span><span class="calibre7"> before proceeding further.</span></p>
<p class="calibre2">To debug a DLL, launch <em class="calibre17">x64dbg</em> (preferably with administrator privileges) and load the DLL (via <span class="calibre7">File | Open</span>). When you load the DLL, <em class="calibre17">x64dbg</em> drops an executable (named <span class="calibre7"><kbd class="calibre13">DLLLoader32_xxxx.exe</kbd></span><span class="calibre7">, </span>where<span class="calibre7"> </span><kbd class="calibre13">xxxx</kbd><span class="calibre7"> </span>are random hexadecimal<span class="calibre7"> </span>characters) into the same directory where your DLL is located; this executable acts as a generic host process, which will be used to execute your DLL (in the same manner as<span class="calibre7"> </span><kbd class="calibre13">rundll32.exe</kbd>). After you load the DLL, the debugger may pause at the<span class="calibre7"> </span><kbd class="calibre13">System Breakpoint</kbd>, <kbd class="calibre13">TLS callback</kbd><span class="calibre7">, </span>or<span class="calibre7"> </span><kbd class="calibre13">DLL<span> </span>entry point</kbd><span class="calibre7"> </span>function, depending on the configuration settings (mentioned earlier, in the <em class="calibre17">Launching a New Process in x64dbg</em> section). With the<span class="calibre7"> </span><span class="calibre7">System Breakpoint*</span> and <span class="calibre7">TLS callback*</span><span class="calibre7"> </span>options unchecked, the execution will pause at the <em class="calibre17">DLL's entry point</em> upon loading the DLL, as shown in the following screenshot. Now, you can debug the DLL like any other program:</p>
<div class="cdpaligncenter"><img src="../images/00141.jpeg" class="calibre143"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.8.1 Using rundll32.exe to Debug the DLL in x64dbg</h1>
                
            
            <article>
                
<p class="calibre2">Another effective method is to use <kbd class="calibre13">rundll32.exe</kbd> to debug the DLL (let's suppose that you want to debug a malware DLL named <kbd class="calibre13">rasaut.dll</kbd>). To do so, first load<span class="calibre7"> </span><kbd class="calibre13">rundll32.exe</kbd><span class="calibre7"> </span>from the system32 directory <span class="calibre7">(via</span><span class="calibre7"><span class="calibre7"> </span>File | Open</span><span class="calibre7">) </span>into the debugger, which will pause the debugger at the<span class="calibre7"> </span><kbd class="calibre13">system breakpoint</kbd><span class="calibre7"> </span>or the<span class="calibre7"> </span><kbd class="calibre13">Entry point</kbd><span class="calibre7"> </span>of<span class="calibre7"> </span><kbd class="calibre13">rundll32.exe</kbd><span class="calibre7"> </span>(depending on the settings mentioned earlier). Then, select<span class="calibre7"> </span><span class="calibre7">Debug | Change Command Line</span><span class="calibre7"> </span>and specify the command-line arguments to<span class="calibre7"> </span><kbd class="calibre13">rundll32.exe</kbd><span class="calibre7"> </span>(specify the full path to the DLL and the export function), as follows, and click on<span class="calibre7"> </span><span class="calibre7">OK</span>:</p>
<div class="cdpaligncenter"><img src="../images/00142.jpeg" class="calibre144"/></div>
<p class="calibre2">Next, select the<span class="calibre7"> </span><span class="calibre7">Breakpoints</span><span class="calibre7"> </span>tab, right-click inside the<span class="calibre7"> </span><span class="calibre7">Breakpoints</span><span class="calibre7"> </span>window, and choose<span class="calibre7"> the </span><span class="calibre7">Add DLL<span class="calibre7"> </span>breakpoint</span> option, which will bring up a dialog window prompting you to enter the module name. Enter the DLL name (in this case,<span class="calibre7"> </span><kbd class="calibre13">rasaut.dll</kbd>), shown as follows. This will tell the debugger to break when the DLL (<kbd class="calibre13">rasaut.dll</kbd>) is loaded. After configuring these settings, close the debugger:</p>
<div class="cdpaligncenter"><img src="../images/00143.jpeg" class="calibre145"/></div>
<p class="calibre2">Next, reopen the debugger and load<span class="calibre7"> </span><kbd class="calibre13">rundll32.exe</kbd><span class="calibre7"> </span>again; when you load it again, the previous command-line settings will still be intact. Now, select <span class="calibre7">Debug | Run</span> (<em class="calibre17">F9</em>),<span class="calibre7"> </span>till you break at the entry point of the DLL (you may have to select <span class="calibre7">Run</span> (<em class="calibre17">F9)</em> multiple times, till you reach the DLL entry point). You can keep track of where the execution has paused every time you run<span class="calibre7"> </span>(<em class="calibre17">F9</em>), by looking at the <em class="calibre17">comment</em> next to the <em class="calibre17">breakpoint address. Y</em>ou can also find the same comment next to the <kbd class="calibre13">eip</kbd> register. In the following screenshot, you can see that the execution has paused at the entry point of<span class="calibre7"> </span><kbd class="calibre13">rasaut.dll</kbd>. At this point, you can debug the DLL like any other program. You can also set breakpoints on any function exported by the DLL. You can find the export functions by using the<span class="calibre7"> </span><span class="calibre7">Symbols window</span>; after you have found the desired <em class="calibre17">export</em> function, double-click on it (which will take you to the code of the export function in the disassembly window). Then, set a breakpoint at the desired address:</p>
<div class="cdpaligncenter"><img src="../images/00144.jpeg" class="calibre41"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.8.2 Debugging a DLL in a Specific Process</h1>
                
            
            <article>
                
<p class="calibre2">Sometimes, you may want to debug a DLL that only runs in a specific process (such as <kbd class="calibre13">explorer.exe</kbd>). The procedure is similar to the one covered in the previous section. First, <em class="calibre17">launch the process</em> or <em class="calibre17">attach</em> to the desired host process using x64dbg; this will pause the debugger. Allow the process to run by selecting <span class="calibre7">Debug | Run</span><span class="calibre7"> </span>(<em class="calibre17">F9</em>). Next, select the<span class="calibre7"> </span><span class="calibre7">Breakpoints</span> tab, right-click inside the<span class="calibre7"> </span><span class="calibre7">Breakpoints window</span>,<span class="calibre7"> </span>and select<span class="calibre7"> the </span><span class="calibre7">Add DLL breakpoint</span><span class="calibre7"> </span>option, which will bring up a dialog window prompting you to enter the module name. Enter the DLL name (as covered in the previous section); this will tell the debugger to break when the DLL is loaded. Now, you need to inject the DLL into the host process. This can be done using a tool like<span class="calibre7"> </span><em class="calibre17">RemoteDLL</em> (<a href="https://securityxploded.com/remotedll.php" target="_blank" class="calibre10">https://securityxploded.com/remotedll.php</a>). When the DLL is loaded, the debugger will pause somewhere in<span class="calibre7"> </span><kbd class="calibre13">ntdll.dll</kbd>;<span class="calibre7"> </span>just hit <span class="calibre7">Run</span><span class="calibre7"> </span>(<em class="calibre17">F9</em>)<span class="calibre7"> </span>till you reach the entry point of the injected DLL (you might have to run multiple times before you reach the entry point). You can keep track of where the execution has paused every time you hit <strong class="calibre5">Run</strong><span class="calibre7"> </span>(<em class="calibre17">F9</em>)<span class="calibre7"> </span>by looking at the comment next to the breakpoint address or next to the <kbd class="calibre13">eip</kbd> register, as mentioned in the previous section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.9 Tracing Execution in x64dbg</h1>
                
            
            <article>
                
<p class="calibre2"><em class="calibre17">Tracing</em> allows you to log events while the process is executing. x64dbg supports<span class="calibre7"> </span><em class="calibre17">trace into</em> and<span class="calibre7"> </span><em class="calibre17">trace over</em> conditional tracing options. You can access these options via<span class="calibre7"> </span><span class="calibre7">Trace | Trace into</span> (<em class="calibre17">Ctrl</em>+<em class="calibre17">Alt</em>+<em class="calibre17">F7</em>)<span class="calibre7"> </span>and<span class="calibre7"> </span><span class="calibre7"><strong class="calibre5">Trace | Trace over</strong></span> (<em class="calibre17">Ctrl+Alt+F8</em>). In<span class="calibre7"> </span><em class="calibre17">trace into</em>, the debugger internally traces the program by setting<span class="calibre7"> </span><em class="calibre17">step into</em><span class="calibre7"> </span>breakpoint, until a condition is<span class="calibre7"> </span>satisfied<span class="calibre7"> </span>or the maximum number of steps is reached. In<span class="calibre7"> </span><em class="calibre17">trace over</em>, the debugger traces the program by setting<span class="calibre7"> </span><em class="calibre17">step over</em><span class="calibre7"> </span>breakpoint, until the condition is<span class="calibre7"> </span>satisfied<span class="calibre7"> </span>or the maximum number of steps is reached. The following screenshot shows the <span class="calibre7">Trace into</span> dialog (the same options are provided in the <span class="calibre7">Trace over</span> dialog). To trace the logs, at a minimum, you need to specify the<span class="calibre7"> </span><em class="calibre17">log text</em><span class="calibre7"> </span>and the full path to the log file (via the <span class="calibre7">Log File</span> button) where the trace events will be redirected:</p>
<div class="cdpaligncenter"><img src="../images/00145.jpeg" class="calibre146"/></div>
<p class="calibre2">The following includes brief descriptions of some of the fields:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Breakpoint Condition</strong>: You can specify a condition in this field. This field defaults to a value of<span> </span><kbd class="calibre13">0</kbd><span> </span>(<kbd class="calibre13">false</kbd>). To specify the condition, you need to specify any valid expression (<a href="http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html" class="calibre10">http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html</a>) that evaluates to a non zero value (<kbd class="calibre13">true</kbd>). Expressions that evaluate to non-zero values are considered <kbd class="calibre13">true</kbd>, thereby triggering the breakpoint. The debugger continues tracing by evaluating the provided expression, and stops when the specified condition is satisfied. If the condition is not satisfied, the tracing continues until the <em class="calibre19">maximum trace count</em> is reached.</li>
<li class="calibre12"><strong class="calibre1">Log Text</strong>: This field is used to specify the format that will be used to log the trace events in the log file. The valid formats that can be used in this field are mentioned at<span> </span><a href="http://help.x64dbg.com/en/latest/introduction/Formatting.html" class="calibre10">http://help.x64dbg.com/en/latest/introduction/Formatting.html</a></li>
<li class="calibre12"><strong class="calibre1">Log Condition</strong>: This field defaults to a value of<span> </span><kbd class="calibre13">1</kbd>. You can optionally provide a log condition that will tell the debugger to log an event only when a specific condition is met. The log condition needs to be a valid expression (<a href="http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html" class="calibre10">http://x64dbg.readthedocs.io/en/latest/introduction/Expressions.html</a>).</li>
<li class="calibre12"><strong class="calibre1">Maximum Trace Count</strong>: This fields specifies the maximum step count to trace before the debugger gives up. The default value is set to<span> </span><kbd class="calibre13">50000</kbd>, and you can increase or decrease this value, as required.</li>
<li class="calibre12"><strong class="calibre1">Log File Button</strong>: You can use this button to specify the full path to the log file where the trace logs will be saved.</li>
</ul>
<p class="calibre2">x64dbg does not have specific <em class="calibre17">instruction tracing</em> and <em class="calibre17">function tracing</em> features, but the <em class="calibre17">trace into</em> and <em class="calibre17">trace over</em> options can be used to perform instruction tracing and function tracing. You can control the tracing by adding breakpoints. In the following screenshot, the<span class="calibre7"> </span><kbd class="calibre13">eip</kbd><span class="calibre7"> </span>is pointing at the 1<sup class="calibre139">st</sup> instruction, and a breakpoint is set at the 5<sup class="calibre139">th</sup> instruction. When the tracing has initiated, the debugger starts tracing from the first instruction, and pauses at the breakpoint. If there is no breakpoint, the tracing continues until the program ends, or until the maximum trace count is reached. You can choose <em class="calibre17">trace into</em> if you want to trace the instructions that are inside the function, or <em class="calibre17">trace over</em> to step over the function and trace the rest of the instructions:</p>
<div class="cdpaligncenter"><img src="../images/00146.jpeg" class="calibre147"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.9.1 Instruction Tracing</h1>
                
            
            <article>
                
<p class="calibre2">To perform <em class="calibre17">instruction tracing</em> (for example, <em class="calibre17">trace into</em>) on the previous program, you can use the following settings in the <span class="calibre7">Trace into</span><span class="calibre7"> </span>dialog. As mentioned previously, to capture the trace events in a log file, you need to specify the full path to the log file and the <span class="calibre7">Log Text</span>:</p>
<div class="cdpaligncenter"><img src="../images/00147.jpeg" class="calibre148"/></div>
<p class="calibre2">The <span class="calibre7">Log Text</span> value in the preceding screenshot<span class="calibre7"> (</span><kbd class="calibre13">0x{p:cip} {i:cip}</kbd><span class="calibre7">)</span> is in the string format, which specifies the debugger to log the <em class="calibre17">address</em> and the <em class="calibre17">disassembly</em> of all the traced instructions. The following is the trace log of the program. As a result of choosing the <em class="calibre17"><span class="calibre7">Trace into</span></em><span class="calibre7"> </span>option, the instructions inside the function (<kbd class="calibre13">0xdf1000</kbd>) are also captured (highlighted in the following code). Instruction tracing is useful to get a quick idea of a program's execution flow:</p>
<pre class="calibre18">0x00DF1011      mov ebp, esp<br class="title-page-name"/>0x00DF1013      call 0xdf1000<br class="title-page-name"/><strong class="calibre1">0x00DF1000      push ebp</strong><br class="title-page-name"/><strong class="calibre1">0x00DF1001      mov ebp, esp</strong><br class="title-page-name"/><strong class="calibre1">0x00DF1003      pop ebp</strong><br class="title-page-name"/><strong class="calibre1">0x00DF1004      ret</strong><br class="title-page-name"/>0x00DF1018      xor eax, eax<br class="title-page-name"/>0x00DF101A      pop ebp</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.9.2 Function Tracing</h1>
                
            
            <article>
                
<p class="calibre2">To demonstrate <em class="calibre17">function tracing</em>, consider the program shown in the following screenshot. In this program, the<span class="calibre7"> </span><kbd class="calibre13">eip</kbd><span class="calibre7"> </span>is pointing to the first instruction, the breakpoint is set at the fifth instruction (to stop tracing at this point), and the third instruction calls a function at<span class="calibre7"> </span><kbd class="calibre13">0x311020</kbd>. We can use function tracing to determine what other functions are called by the function (<kbd class="calibre13">0x311020</kbd>):</p>
<div class="cdpaligncenter"><img src="../images/00148.jpeg" class="calibre149"/></div>
<p class="calibre2">To perform function tracing (<span class="calibre7">Trace into</span> was chosen in this case), the following setting is used. This is similar to <em class="calibre17">instruction tracing</em>, except that in the <span class="calibre7">Log Condition</span> field, an expression, telling the debugger to log only the function call is specified:</p>
<div class="cdpaligncenter"><img src="../images/00149.jpeg" class="calibre150"/></div>
<p class="calibre2">The following are the events captured in the log file, as a result of <em class="calibre17">function tracing</em>. From the following<span class="calibre7"> events</span><span class="calibre7">, </span>you can tell that the function<span class="calibre7"> </span><kbd class="calibre13">0x311020</kbd> calls two other functions, at<span class="calibre7"> </span><kbd class="calibre13">0x311000</kbd><span class="calibre7"> </span>and<span class="calibre7"> </span><kbd class="calibre13">0x311010</kbd>:</p>
<pre class="calibre18">0x00311033      call    0x311020<br class="title-page-name"/>0x00311023      call    0x311000<br class="title-page-name"/>0x00311028      call    0x311010</pre>
<p class="calibre2">In the preceding examples, the breakpoints were used to control the tracing. When the debugger reaches the breakpoint, the execution is paused, and the <em class="calibre17">instructions/functions</em> till the breakpoint are logged. When you resume the debugger, the rest of the instructions are executed, but not logged.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.10 Patching in x64dbg</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre7">While performing malware analysis, you may want to modify the binary to change its functionality or reverse its logic to suit your needs.</span> x64dbg allows you to modify data in the memory or instructions of a program. To modify the data in a memory, navigate to the memory address and select the sequence of bytes you want to modify, then right-click and choose<span class="calibre7"> </span><span class="calibre7">Binary | Edit</span> (<em class="calibre17">Ctrl</em> + <em class="calibre17">E</em>),<span class="calibre7"> </span>which will bring up a dialog (shown as follows) that you can use to modify the data as ASCII, UNICODE, or a sequence of hex bytes:</p>
<div class="cdpaligncenter"><img src="../images/00150.jpeg" class="calibre151"/></div>
<p class="calibre2">The following screenshot shows the code excerpt from the <em class="calibre17">TDSS rootkit</em> DLL (this is the same binary that was covered in the previous chapter, in the section <em class="calibre17">Patching the Binary Using IDA</em>). If you recall, this DLL used string comparison to perform a check to ensure that it was running under the<span class="calibre7"> </span><kbd class="calibre13">spoolsv.exe</kbd><span class="calibre7"> </span>process. If the string comparison fails (that is, if the DLL is not running under<span class="calibre7"> </span><kbd class="calibre13">spoolsv.exe</kbd>), then the code jumps to the end of the function and returns from the function without exhibiting malicious behavior. Suppose that you want this binary to run under any process (not just<span class="calibre7"> </span><kbd class="calibre13">spoolsv.exe</kbd>). You can modify the <em class="calibre17">conditional jump</em> instruction (<kbd class="calibre13">JNE<span> </span>tdss.10001Cf9</kbd>) with a<span class="calibre7"> </span><kbd class="calibre13">nop</kbd><span class="calibre7"> </span>instruction, to remove the process restriction. To do that, right-click on the conditional jump instruction and select <span class="calibre7">Assemble</span>, which will bring up the dialog shown as follows, using which you can enter the instructions. Note that, in the screenshot, the <span class="calibre7">fill with NOP's</span> option is checked, to make sure that the instruction alignment is correct:</p>
<div class="cdpaligncenter"><img src="../images/00151.jpeg" class="calibre152"/></div>
<p class="calibre2">After you have modified the data in the memory or the instruction, you can apply the patch to the file by choosing<span class="calibre7"> </span><span class="calibre7">File | Patch file</span>, which will bring up a patches dialog showing all of the modifications made to the binary. Once you are satisfied with the modifications, click on<span class="calibre7"> </span><span class="calibre7">Patch file</span><span class="calibre7"> </span>and save the file:</p>
<div class="cdpaligncenter"><img src="../images/00152.jpeg" class="calibre153"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3. Debugging a Binary Using IDA</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre7">In the previous chapter, we looked at the disassembly features of <em class="calibre17">IDA Pro</em>. In this chapter, you will learn about IDA's debugging capabilities. The commercial version of IDA can debug both 32-bit and 64-bit applications, whereas the demo version only allows you to debug a 32-bit Windows binary. In this section, you will see some of the debugging features offered by IDA Pro, and you will learn how to use it to debug a malicious binary. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.1 Launching a New Process in IDA</h1>
                
            
            <article>
                
<p class="calibre2">There are different ways to launch a new process; one method is to directly launch the debugger, without initially loading the program. To do that, launch IDA (without loading the executable), then select <span class="calibre7">Debugger | Run | Local Windows debugger</span>; this will bring up a dialog where you can choose the file to debug. If the executable takes any parameters, you can specify them in the <span class="calibre7">Parameters</span> field. This method will start a new process, and the debugger will pause the execution at the program's <em class="calibre17">entry point:</em></p>
<div class="cdpaligncenter"><img src="../images/00153.jpeg" class="calibre154"/></div>
<p class="calibre2">The second method of launching a process is to first load the executable in IDA (which performs the initial analysis and displays the disassembled output). First, choose the correct debugger via <span class="calibre7">Debugger | Select debugger</span> (or <em class="calibre17">F9</em>); then, you can place the cursor on the first instruction (or the instruction where you want the execution to pause) and select<span class="calibre7"> </span><span class="calibre7">Debugger | Run to cursor</span> (or <em class="calibre17">F4</em>). This will start a new process, and will execute until the current cursor location (in this case, the breakpoint is automatically set at the current cursor location).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.2 Attaching to an Existing Process Using IDA</h1>
                
            
            <article>
                
<p class="calibre2">The way you attach to a process depends on whether the program has already loaded or not. When a program has not loaded, select<span class="calibre7"> </span><span class="calibre7">Debugger | Attach | Local Windows debugger</span>. This will list all of the running processes. Simply select the process to attach to. After attaching, the process will be paused immediately, giving you the chance to inspect the process's resources and set breakpoints, prior to resuming execution of the process. In this method, IDA will not be able to perform its initial auto-analysis of the binary, because IDA's loader will not get a chance to load the executable image:</p>
<div class="cdpaligncenter"><img src="../images/00154.jpeg" class="calibre155"/></div>
<p class="calibre2">An alternate method of <em class="calibre17">attaching to a process</em> is loading the executable associated with a process into IDA before attaching to that process. To achieve this, load the associated executable using IDA; this allows IDA to perform its initial analysis. Then, select<span class="calibre7"> </span><span class="calibre7"><strong class="calibre5">Debugger</strong> | <strong class="calibre5">Select debugger</strong></span><span class="calibre7"> </span>and check the<span class="calibre7"> </span><span class="calibre7">Local Win32 debugger</span><span class="calibre7"> </span>(or <span class="calibre7">Local Windows debugger</span>) option, and click<span class="calibre7"> </span><span class="calibre7">OK</span>. Then, select<span class="calibre7"> </span><span class="calibre7">Debugger | Attach to process</span><span class="calibre7"> again, </span>and choose the process to attach the debugger.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.3 IDA's Debugger Interface</h1>
                
            
            <article>
                
<p class="calibre2">After you launch the program in the IDA debugger, the process will pause, and the following debugger display will be presented to you:</p>
<div class="cdpaligncenter"><img src="../images/00155.jpeg" class="calibre156"/></div>
<p class="calibre2"><span class="calibre7">When the process is under debugger control, the disassembly toolbar is replaced with the debugger toolbar. This toolbar consists of buttons related to the debugging functionality (such as <em class="calibre17">process control</em> and <em class="calibre17">breakpoint</em>):</span></p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Disassembly Window</strong>:<span> </span>This window is synchronized with the current value of the <em class="calibre19">instruction pointer</em> register (<kbd class="calibre13">eip</kbd><span> </span>or<span> </span><kbd class="calibre13">rip</kbd>). The disassembly windows offer the same functionality that you learned in the previous chapter. You can also switch between the<span> </span><em class="calibre19">graph view</em><span> </span>and the<span> </span><em class="calibre19">text view</em><span> </span>modes by pressing the <em class="calibre19">spacebar</em> key.</li>
<li class="calibre12"><strong class="calibre1">Register Window</strong>:<span> </span>This window displays the current contents of the CPU's general-purpose register. You can right-click a register value and click <span>Modify value</span>, <span>Zero value</span>, <span>Toggle value</span>, <span>Increment</span>, <span>or Decrement value</span>. Toggling a value is particularly useful if you want to change the states of CPU flag bits. If the value of the register is a valid memory location, the <em class="calibre19">right-angle arrow</em> next to the register's value will be active; clicking on this arrow will relocate the view to the corresponding memory location. If you ever find that you have navigated to a different location and would like to go to the location pointed to by the <em class="calibre19">instruction pointer,</em> then just click on the <em class="calibre19">right-angle arrow</em> next to the value of the instruction pointer register (<kbd class="calibre13">eip</kbd> or <kbd class="calibre13">rip</kbd>).</li>
<li class="calibre12"><strong class="calibre1">Stack View</strong>:<span> </span>The <em class="calibre19">stack view</em> displays the data contents of the process's runtime stack. Inspecting the stack before calling a function can yield information about the number of function arguments and the types of function arguments.</li>
<li class="calibre12"><strong class="calibre1">Hex View</strong>: <span>This</span> displays the standard hex dump of the memory. <em class="calibre19">Hex view</em> is useful if you want to display the contents of a valid memory location (contained within a <em class="calibre19">register</em>, a <em class="calibre19">stack</em>, or the <em class="calibre19">instruction</em>).</li>
<li class="calibre12"><strong class="calibre1">Modules View</strong>:<span> This</span> displays the list of modules (<em class="calibre19">executables</em> and their <em class="calibre19">shared libraries</em>) loaded into the process memory. Double-clicking any module in the list displays a list of symbols exported by that module. This is an easy way to navigate to the functions within the loaded libraries.</li>
<li class="calibre12"><strong class="calibre1">Threads<span> V</span>iew</strong>: Displays a list of threads in the current process. You can right-click on this window to <em class="calibre19">suspend a thread</em> or <em class="calibre19">resume a suspended thread</em>.</li>
<li class="calibre12"><strong class="calibre1">Segments Window</strong>: <span>The <em class="calibre19">s</em></span><em class="calibre19">egments window</em> is available via<span> </span><span>View | Open Subviews | Segments</span><span> </span>(or<span> </span><em class="calibre19">Shift</em> + <em class="calibre19">F7</em>). When you are debugging a program, the segments window provides information regarding the allocated memory segments in a process. This window displays the information about where the executable and its sections are loaded in memory. It also contains details on all of the loaded DLLs, and their section information. Double-clicking on any entry will take you to the corresponding memory location in either the <em class="calibre19">disassembly window</em> or the <em class="calibre19">hex window</em>. You can control where the contents of the memory address should be displayed (in the disassembly or hex window); to do that, just place the cursor anywhere in the disassembly or hex window, and then double-click on the entry. Depending on the cursor location, the contents of the memory address will be displayed in the appropriate window:</li>
</ul>
<div class="cdpaligncenter"><img src="../images/00156.jpeg" class="calibre157"/></div>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Imports and Exports Window</strong>: When the process is under debugger control, the <span>Imports</span> and <span>Exports</span> windows are not displayed by default. You can bring up these windows via<span> </span><span>Views | Open subviews</span>. The <span>Imports</span> window lists all of the functions imported by the binary, and the <span>Exports</span> window lists all of the exported functions. The exported functions are normally found in the DLLs, so this window can be particularly useful when you are debugging malicious DLLs.</li>
</ul>
<p class="calibre2">The other IDA windows, explained in the previous chapter, can also be accessed via<span class="calibre7"> </span><span class="calibre7">Views | Open Subviews</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.4 Controlling Process Execution Using IDA</h1>
                
            
            <article>
                
<p class="calibre2">In <em class="calibre17">Section 1.2</em>, <em class="calibre17">Controlling Process Execution</em>, we looked at the different execution control features provided by the debuggers. The following table outlines the common execution control functionalities that you can use in IDA when debugging a program:</p>
<table border="1" class="calibre46">
<tbody class="calibre47">
<tr class="calibre48">
<td class="calibre49">Functionality</td>
<td class="calibre49">Hotkey</td>
<td class="calibre49">Menu Option</td>
</tr>
<tr class="calibre48">
<td class="calibre49"><span>Continue (Run)</span></td>
<td class="calibre49"><em class="calibre19"><span>F9</span></em></td>
<td class="calibre49"><span><span>Debugger</span> | <span>Continue process</span></span></td>
</tr>
<tr class="calibre48">
<td class="calibre49"><span>Step into</span></td>
<td class="calibre49"><em class="calibre19"><span>F7</span></em></td>
<td class="calibre49"><span><span>Debugger</span> | <span>Step into</span></span></td>
</tr>
<tr class="calibre48">
<td class="calibre49"><span>Step over</span></td>
<td class="calibre49"><em class="calibre19"><span>F8</span></em></td>
<td class="calibre49"><span><span>Debugger</span> | <span>Step over</span></span></td>
</tr>
<tr class="calibre48">
<td class="calibre49"><span>Run to cursor</span></td>
<td class="calibre49"><em class="calibre19"><span>F4</span></em></td>
<td class="calibre49"><span><span>Debugger</span> | <span>Run to cursor</span></span></td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.5 Setting a Breakpoint in IDA</h1>
                
            
            <article>
                
<p class="calibre2">To set a software breakpoint in IDA, you can navigate to the location where you want the program to pause, and press the<span class="calibre7"> </span><em class="calibre17">F2<span class="calibre7"> </span></em>key (or right-click and select<span class="calibre7"> </span><span class="calibre7">Add breakpoint</span>). After you set the breakpoint, the addresses where breakpoints are set are highlighted in a red color. You can remove the breakpoint by pressing<span class="calibre7"> </span><em class="calibre17">F2<span class="calibre7"> </span></em>on the line containing the breakpoint.</p>
<p class="calibre2">In the following screenshot, the breakpoint was set at the address<span class="calibre7"> </span><kbd class="calibre13">0x00401013</kbd><span class="calibre7"> </span>(<kbd class="calibre13">call sub_401000</kbd>). To pause the execution at the breakpoint address, first, choose the debugger (such as <span class="calibre7">Local Win32 Debugger</span>), as mentioned previously, and then run the program by selecting<span class="calibre7"> </span><span class="calibre7">Debugger | Start Process</span><span class="calibre7"> </span>(or<span class="calibre7"> the </span><em class="calibre17">F9</em> hotkey). This will execute all of the instructions before reaching the breakpoint, and will pause at the breakpoint address:</p>
<div class="cdpaligncenter"><img src="../images/00157.gif" class="calibre158"/></div>
<p class="calibre2">In IDA, you can set hardware and conditional breakpoints by editing the breakpoint that is already set. To set a hardware breakpoint, right-click on an existing breakpoint and select<span class="calibre7"> </span><span class="calibre7">Edit breakpoint</span>. In the dialog that pops up, check the<span class="calibre7"> </span><span class="calibre7">Hardware</span> checkbox, shown as follows. IDA allows you to set more than four hardware breakpoints, but only four of them will work; the additional hardware breakpoints will be ignored:</p>
<div class="cdpaligncenter"><img src="../images/00158.jpeg" class="calibre159"/></div>
<p class="calibre2">You can use hardware breakpoints to specify whether to <em class="calibre17">break on execute</em> (default), <em class="calibre17">break on write,</em> or <em class="calibre17">break on read/write</em>. The <em class="calibre17">break on write</em><span class="calibre7"> </span>and <em class="calibre17">break on read/write</em> options allow you to create memory breakpoints when the specified memory location is accessed by any instruction. This breakpoint is useful if you want to know when your program accesses a piece of data (read/write) from a memory location. The <em class="calibre17">break on execute</em> option allows you to set a breakpoint when the specified memory location is executed. In addition to specifying a mode, you must also specify a size. A hardware breakpoint's size is combined with its address to form a range of bytes for which the breakpoint may be triggered.</p>
<p class="calibre2">You can set a conditional breakpoint by specifying the condition in the <span class="calibre7">condition</span> field. The condition can be an actual condition, or IDC or IDAPython expressions. You can click on the<span class="calibre7"> </span>...<span class="calibre7"> </span>button next to the condition field, which will open up the editor, where you can use IDC or IDAPython scripting language to evaluate the condition. You can find some examples of setting conditional breakpoints at<span class="calibre7"> </span><a href="https://www.hex-rays.com/products/ida/support/idadoc/1488.shtml" class="calibre10">https://www.hex-rays.com/products/ida/support/idadoc/1488.shtml</a>.</p>
<p class="calibre2">You can view all of the active breakpoints by navigating to<span class="calibre7"> </span><span class="calibre7">Debugger | Breakpoints | Breakpoint List<span class="calibre7"> </span></span>(or<span class="calibre7"> typing </span><em class="calibre17">Ctrl</em> + <em class="calibre17">Alt</em> + <em class="calibre17">B</em>). You can right-click on the breakpoint entry and <em class="calibre17">disable</em> or <em class="calibre17">delete</em> the breakpoint.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.6 Debugging Malware Executables</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will look at how to use IDA to debug a malware binary. Consider the disassembly listing from a 32-bit malware sample. The malware calls the<span class="calibre7"> </span><kbd class="calibre13">CreateFileW</kbd><span class="calibre7"> </span>API to create a file, but, just by looking at the disassembly listing, it is not clear what file the malware creates. From the MSDN documentation for<span class="calibre7"> </span><kbd class="calibre13">CreateFile</kbd>, you can tell that the first parameter to<span class="calibre7"> </span><kbd class="calibre13">CreateFile</kbd><span class="calibre7"> </span>will contain the name of the file; also, the suffix<span class="calibre7"> </span><kbd class="calibre13">W</kbd><span class="calibre7"> </span>in the<span class="calibre7"> </span><kbd class="calibre13">CreateFile</kbd><span class="calibre7"> </span>specifies that the name of the file is a UNICODE string (details regarding the API were covered in the previous chapter). To determine the name of the file, we can set a breakpoint at the address where the call to the<span class="calibre7"> </span><kbd class="calibre13">CreateFileW</kbd> ➊ is made, and then<span class="calibre7"> </span>run the program (<em class="calibre17">F9</em>) till it reaches the breakpoint. When it reaches the breakpoint (before calling<span class="calibre7"> </span><kbd class="calibre13">CreateFileW</kbd>), all of the parameters to the function will be pushed onto the stack, so we can examine the first parameter on the stack to determine the name of the file. After the call to<span class="calibre7"> </span><kbd class="calibre13">CreateFileW</kbd><span class="calibre7">, </span>the handle to the file will be returned in the<span class="calibre7"> </span><kbd class="calibre13">eax</kbd><span class="calibre7"> </span>register, which is copied into the<span class="calibre7"> </span><kbd class="calibre13">esi</kbd><span class="calibre7"> </span>register at ➋:</p>
<pre class="calibre18"><br class="title-page-name"/>.text:00401047     push  0          ; hTemplateFile<br class="title-page-name"/>.text:00401049     push  80h        ; dwFlagsAndAttributes<br class="title-page-name"/>.text:0040104E     push  2          ; dwCreationDisposition<br class="title-page-name"/>.text:00401050     push  0          ; lpSecurityAttributes<br class="title-page-name"/>.text:00401052     push  0          ; dwShareMode<br class="title-page-name"/>.text:00401054     push  40000000h  ; dwDesiredAccess<br class="title-page-name"/>.text:00401059     lea  edx, [esp+800h+Buffer]<br class="title-page-name"/>.text:00401060     push  edx        ; lpFileName<br class="title-page-name"/>.text:00401061  ➊ <strong class="calibre1">call  ds:CreateFileW</strong> <br class="title-page-name"/>.text:00401067     mov  esi, eax ➋</pre>
<p class="calibre2">In the following screenshot, the execution is paused at the call to the<span class="calibre7"> </span><kbd class="calibre13">CreateFileW</kbd><span class="calibre7"> </span>(as a result of setting the breakpoint and running the program). The first parameter to the function is the address (<kbd class="calibre13">0x003F538</kbd>) of the UNICODE string (<kbd class="calibre13">filename</kbd>). You can use the <span class="calibre7">Hex-View</span> window in IDA to inspect the contents of any valid memory location. Dumping the contents of the first argument, by right-clicking on the address<span class="calibre7"> </span><kbd class="calibre13">0x003F538</kbd><span class="calibre7"> </span>and choosing<span class="calibre7"> the </span><span class="calibre7">Follow in hex dump</span><span class="calibre7"> </span>option, displays the filename in the <span class="calibre7">Hex-View</span> window, shown as follows. In this case, the malware is creating a file,<span class="calibre7"> </span><kbd class="calibre13">SHAMple.dat</kbd><span class="calibre7">, </span>in the<span class="calibre7"> </span><kbd class="calibre13">C:\Users\test\AppData\Local\Temp</kbd><span class="calibre7"> </span>directory:</p>
<div class="cdpaligncenter"><img src="../images/00159.jpeg" class="calibre41"/></div>
<p class="calibre2">The malware, after creating the file, passes the file handle as the first argument to the<span class="calibre7"> </span><kbd class="calibre13">WriteFile</kbd><span class="calibre7"> </span>function. This indicates that the malware writes some content to the file<span class="calibre7"> </span><kbd class="calibre13">SHAmple.dat</kbd>. To determine what content it writes to the file, you can inspect the second argument to the<span class="calibre7"> </span><kbd class="calibre13">WriteFile</kbd><span class="calibre7"> </span>function. In this case, it is writing the string<span class="calibre7"> </span><kbd class="calibre13">FunFunFun</kbd><span class="calibre7"> </span>to the file, as shown in the following screenshot. If the malware is writing executable content to the file, you will also be able to see it using this method:</p>
<div class="cdpaligncenter"><img src="../images/00160.jpeg" class="calibre41"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.7 Debugging a Malicious DLL Using IDA</h1>
                
            
            <article>
                
<p class="calibre2">In <a href="part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 3</a>, <em class="calibre17">Dynamic Analysis</em><span class="calibre7">, you learned the techniques to execute a DLL to perform dynamic analysis. In this section, you will use some of the concepts that you learned in </span><a href="part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 3</a>, <em class="calibre17">Dynamic Analysis</em>,<span class="calibre7"> to debug a DLL using IDA. If you not familiar with dynamic analysis of a DLL, it is highly recommended to read <em class="calibre17">S</em></span><em class="calibre17">ection 6</em>, <em class="calibre17">Dynamic-Link Library (DLL) Analysis,</em><span class="calibre7"> from <a href="https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=885&amp;action=edit#post_522" class="calibre10">Chapter 3</a></span>, <em class="calibre17">Dynamic Analysis,</em><span class="calibre7"> before proceeding further. </span></p>
<p class="calibre2">To debug a DLL using the IDA debugger, you first need to designate the executable (such as<span class="calibre7"> </span><kbd class="calibre13">rundll32.exe</kbd>) that will be used to load the DLL. To debug a DLL, first, load the DLL into IDA, which will likely display the disassembly of the<span class="calibre7"> </span><kbd class="calibre13">DLLMain</kbd><span class="calibre7"> </span>function. Set a breakpoint (<em class="calibre17">F2</em>) at the first instruction in the<span class="calibre7"> </span><kbd class="calibre13">DLLMain</kbd><span class="calibre7"> </span>function, as shown in the following screenshot. This ensures that when you run the DLL, the execution will pause at the first instruction in the<span class="calibre7"> </span><kbd class="calibre13">DLLMain</kbd><span class="calibre7"> </span>function. You can also set breakpoints on any function exported by the DLL by navigating to it from IDA's <span class="calibre7">Exports</span> window:</p>
<div class="cdpaligncenter"><img src="../images/00161.jpeg" class="calibre160"/></div>
<p class="calibre2">After you have set the breakpoint on the desired address (where you want the execution to pause), select the debugger via<span class="calibre7"> </span><span class="calibre7">Debugger | Select debugger | Local Win32 debugger</span><span class="calibre7"> </span>(or<span class="calibre7"> </span><span class="calibre7"><strong class="calibre5">Debugger</strong> | <strong class="calibre5">Select debugger</strong> | <strong class="calibre5">Local Windows debugger</strong></span>) and click on<span class="calibre7"> </span><span class="calibre7">OK</span>. Next, select<span class="calibre7"> </span><span class="calibre7">D</span><span class="calibre7">ebugger | Process<span class="calibre7"> </span>options</span>, which will bring up the dialog shown in the following screenshot. In the<span class="calibre7"> </span><span class="calibre7">Application</span><span class="calibre7"> </span>field, enter the full path to the executable<span class="calibre7"> </span>that is used to load the DLL <span class="calibre7">(</span><kbd class="calibre13">rundll32.exe</kbd><span class="calibre7">). I</span>n the<span class="calibre7"> </span><span class="calibre7">Input file</span><span class="calibre7"> </span>field, enter the full path to the DLL that you wish to debug, and in the<span class="calibre7"> </span><span class="calibre7">Parameters</span><span class="calibre7"> </span>field, enter the command-line arguments to pass to <kbd class="calibre13">rundll32.exe</kbd><span class="calibre7">, </span>and click on<span class="calibre7"> </span><span class="calibre7">OK</span>. Now, you can run the program to reach the breakpoint, after which you can debug it, as you would debug any other program. The arguments that you pass to<span class="calibre7"> </span><kbd class="calibre13">rundll32.exe</kbd><span class="calibre7"> </span>should have the correct syntax to successfully debug the DLL (refer to<span class="calibre7"> the </span><em class="calibre17">Working<span class="calibre7"> </span>of<span class="calibre7"> </span>rundll32.exe<span class="calibre7"> </span></em>section in <a href="part0065.html#1TVKI0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 3</a>, <em class="calibre17"><span class="calibre7">Dynamic Analysis</span></em>). A point to note is that<span class="calibre7"> </span><kbd class="calibre13">rundll32.exe</kbd><span class="calibre7"> </span>can also be used to execute a 64-bit DLL, in the same manner:</p>
<div class="cdpaligncenter"><img src="../images/00162.jpeg" class="calibre161"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.7.1 Debugging a DLL in a Specific Process</h1>
                
            
            <article>
                
<p class="calibre2">In <em class="calibre17"><a href="https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=885&amp;action=edit#post_522" class="calibre10">Chapter 3</a><span class="calibre7">, </span><span class="calibre7">Dynamic Analysis</span></em>, you learned how some DLLs can perform process checks to determine whether they are running under a particular process, such as <kbd class="calibre13">explorer.exe</kbd> or <kbd class="calibre13">iexplore.exe</kbd>. In that case, you may want to debug a DLL inside a specific host process, rather than<em class="calibre17"><span class="calibre7"> </span></em><kbd class="calibre13">rundll32.exe</kbd>.<span class="calibre7"> </span>To pause the execution at the DLL's entry point, you can either <em class="calibre17">start</em> a new instance of the host process or <em class="calibre17">attach</em> to the desired host process using the debugger, and then select<span class="calibre7"> </span><span class="calibre7">Debugger | Debugger<span class="calibre7"> </span>options</span> and check the option<span class="calibre7"> </span><span class="calibre7">Suspend on library load/unload</span>. This option will tell the debugger to pause whenever a new module is <em class="calibre17">loaded</em> or <em class="calibre17">unloaded</em>. After these settings, you can resume the paused host process and let it run by pressing<span class="calibre7"> the </span><em class="calibre17">F9</em> hotkey.<span class="calibre7"> Y</span>ou can now inject the DLL into the debugged host process with a tool like<span class="calibre7"> </span><em class="calibre17">RemoteDLL</em>.<span class="calibre7"> W</span>hen the DLL is loaded by the host process, the debugger will pause, giving you a chance to set breakpoints in the address of the loaded module. You can get an idea of where the DLL has loaded into the memory by looking at the<span class="calibre7"> </span><span class="calibre7">Segments window,</span><span class="calibre7"> </span>as shown here:</p>
<div class="cdpaligncenter"><img src="../images/00163.jpeg" class="calibre41"/></div>
<p class="calibre2">In the preceding screenshot, you can see that the injected DLL<span class="calibre7"> </span>(<kbd class="calibre13">rasaut.dll</kbd>)<span class="calibre7"> </span>has loaded into the memory at the address<span class="calibre7"> </span><kbd class="calibre13">0x10000000</kbd><span class="calibre7"> </span>(the base address). You can set a breakpoint at the address of the entry point by adding the base address<span class="calibre7"> </span>(<kbd class="calibre13">0x10000000</kbd>)<span class="calibre7"> </span>with the value of the<span class="calibre7"> </span><kbd class="calibre13">AddressOfEntryPoint</kbd><span class="calibre7"> </span>field in the<span class="calibre7"> </span><kbd class="calibre13">PE header</kbd>. You can determine the value of the address of the entry point by loading<span class="calibre7"> </span>the DLL into a tool such as<span class="calibre7"> </span><em class="calibre17">pestudio</em><span class="calibre7"> </span>or<span class="calibre7"> </span><em class="calibre17">CFFexplorer</em>. For example, if the<span class="calibre7"> </span><kbd class="calibre13">AddressOfEntryPoint</kbd><span class="calibre7"> </span>value is<span class="calibre7"> </span><kbd class="calibre13">0x1BFB</kbd>, the DLL entry point can be determined by adding the base address<span class="calibre7"> </span>(<kbd class="calibre13">0x10000000</kbd>)<span class="calibre7"> </span>with the value<span class="calibre7"> </span><kbd class="calibre13">0x1BFB</kbd>,<span class="calibre7"> </span>which results in<span class="calibre7"> </span><kbd class="calibre13">0x10001BFB</kbd>. You can now navigate to the address <span class="calibre7"><kbd class="calibre13">0x10001BFB</kbd> (or jump to the address by pressing the <em class="calibre17">G</em> key) and </span>set a breakpoint at this address, and then resume the paused process.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.8 Tracing Execution Using IDA</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre7"><em class="calibre17">Tracing</em> allows you to record (log) specific events while a process is executing. It can provide detailed execution information on a binary. </span>IDA supports three types of tracing:<em class="calibre17"> instruction tracing</em>,<span class="calibre7"> </span><em class="calibre17">function tracing,</em> and<span class="calibre7"> <em class="calibre17">b</em></span><em class="calibre17">asic block tracing</em>. To enable tracing in IDA, you need to set a breakpoint, then right-click on the breakpoint address and choose <span class="calibre7">Edit breakpoint,</span> which will bring up a <span class="calibre7">breakpoint settings</span> dialog. In the dialog, check the <span class="calibre7">Enable tracing</span> option, and choose the appropriate <span class="calibre7">Tracing type</span>. Then, select the debugger via<span class="calibre7"> the </span><span class="calibre7"><strong class="calibre5">Debugger</strong> | <strong class="calibre5">Select debugger</strong></span> menu<span class="calibre7"> </span>(as covered previously), and<span class="calibre7"> </span><span class="calibre7">Run</span> (<em class="calibre17">F9</em>)<span class="calibre7"> </span>the program. The <span class="calibre7">location</span> field in the following screenshot specifies the breakpoint being edited, and it will be used as the starting address to perform tracing. The tracing will continue until it reaches a breakpoint,<span class="calibre7"> </span>or until<span class="calibre7"> </span>it reaches the end of the program. To indicate which instructions were traced, IDA highlights the instructions by color-coding them. After tracing, you can view the results of the trace by selecting<span class="calibre7"> </span><span class="calibre7">Debugger | Tracing | Trace window</span>. You can control the tracing options via<span class="calibre7"> </span><span class="calibre7">Debugger | Tracing | Tracing options:</span></p>
<div class="cdpaligncenter"><img src="../images/00164.jpeg" class="calibre162"/></div>
<p class="calibre2"><em class="calibre17"><strong class="calibre5">Instruction tracing</strong></em> records the execution of each instruction and displays the modified register values.<span class="calibre7"> </span>Instruction tracing<span class="calibre7"> </span>is slower, because the debugger internally <em class="calibre17">single-steps</em> through the process, to monitor and log all of the register values.<span class="calibre7"> </span><em class="calibre17">Instruction tracing</em><span class="calibre7"> </span>is<span class="calibre7"> </span>useful<span class="calibre7"> for</span> determining the execution flow of the program, and to know which registers were modified during the execution of each instruction. You can control the tracing by adding breakpoints.</p>
<p class="calibre2">Consider the program in the following screenshot. Let's assume that you want to trace the first four instructions (which also includes a function call, in the third instruction). To do that, first, set a breakpoint at the first instruction and another breakpoint at the fifth instruction, as shown in the following screenshot. Then, edit the first breakpoint (at the address<span class="calibre7"> </span><kbd class="calibre13">0x00401010</kbd>) and enable instruction tracing. Now, when you start debugging, the debugger traces the first four instructions (including the instructions inside the function) and pauses at the fifth instruction. If you don't specify the second breakpoint, it will trace all of the instructions:</p>
<div class="cdpaligncenter"><img src="../images/00165.jpeg" class="calibre163"/></div>
<p class="calibre2">The following screenshot shows the <em class="calibre17">instruction tracing</em> events in the trace window, when the debugger paused at the fifth instruction. Note how the execution flows from<span class="calibre7"> </span><kbd class="calibre13">main</kbd><span class="calibre7"> </span>to <kbd class="calibre13">sub_E41000</kbd><span class="calibre7">, </span>and then back to<span class="calibre7"> </span><kbd class="calibre13">main</kbd>. If you wish to trace the rest of the instructions, you can do that by resuming the paused process:</p>
<div class="cdpaligncenter"><img src="../images/00166.jpeg" class="calibre164"/></div>
<p class="calibre2"><strong class="calibre5">Function Tracing</strong>: This records all of the function calls and the return, no register values are logged for function trace events.<span class="calibre7"> </span><em class="calibre17">Function tracing</em><span class="calibre7"> </span>is<span class="calibre7"> </span>useful<span class="calibre7"> for</span> determining which <em class="calibre17">functions</em> and <em class="calibre17">sub-functions</em> are called by the program. You can perform function tracing by setting the <span class="calibre7">Tracing type</span> to <span class="calibre7">Functions</span> and following the same procedure as <span class="calibre7">in </span><em class="calibre17">instruction tracing</em>.</p>
<p class="calibre2">In the following example, the malware sample calls two functions. Let's suppose that we want to get a quick overview of what other functions are called by the first function call. To do that, we can set the first breakpoint at the <em class="calibre17">first instruction</em> and enable function tracing (by editing the breakpoint), and then we can set another breakpoint at the <em class="calibre17">second instruction</em>. The second breakpoint will act as the stop point (tracing will be performed until the second breakpoint is reached). The following screenshot shows both of the breakpoints:</p>
<div class="cdpaligncenter"><img src="../images/00167.jpeg" class="calibre165"/></div>
<p class="calibre2">The following screenshot shows the results of function tracing. From the traced events, you can see that the function<span class="calibre7"> </span><kbd class="calibre13">sub_4014A0</kbd><span class="calibre7"> </span>calls registry-related API functions; this tells you that the function is responsible for performing registry operations:</p>
<div class="cdpaligncenter"><img src="../images/00168.jpeg" class="calibre166"/></div>
<p class="calibre2">Sometimes, your tracing may take a long time and seem to never end; this happens if the function is not returning to its caller and is running in a loop, waiting for an event to occur. In such a case, you will still be able to see the trace logs in the trace window.</p>
<p class="calibre2"><strong class="calibre5">Block Tracing</strong>: IDA allows you to perform <em class="calibre17">block tracing</em>, which is useful for knowing which blocks of code were executed during runtime. You can enable block tracing by setting the <span class="calibre7">Tracing type</span> to <span class="calibre7">Basic blocks</span>. In the case of block tracing, the debugger sets the breakpoint at the <em class="calibre17">last instructio</em>n of each basic block of every function, and it also sets breakpoints at any call instructions in the middle of the traced blocks. <em class="calibre17">Basic block tracing</em> is slower than normal execution, but faster than <em class="calibre17">instruction</em> or <em class="calibre17">function tracing</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.9 Debugger Scripting Using IDAPython</h1>
                
            
            <article>
                
<p class="calibre2">You can use debugger scripting to automate routine tasks related to malware analysis. In the previous chapter, we looked at examples of using IDAPython for static code analysis. In this section, you will learn how to use IDAPython to perform debugging-related tasks. The IDAPython scripts demonstrated in this section make use of the new IDAPython API, meaning that if you are using older versions of IDA (lower than IDA 7.0), these scripts will not work.</p>
<p class="calibre2">The following resources should help you get started with IDAPython debugger scripting. Most of these resources (except the IDAPython documentation) demonstrate scripting capabilities using the old IDAPython API, but they should be good enough for you to get the idea. Anytime you get stuck, you can refer to IDAPython documentation:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">IDAPython API Documentation</strong>:<span> </span><a href="https://www.hex-rays.com/products/ida/support/idapython_docs/idc-module.html" target="_blank" class="calibre10">https://www.hex-rays.com/products/ida/support/idapython_docs/idc-module.html</a></li>
<li class="calibre12"><strong class="calibre1">Magic Lantern Wiki</strong>:<span> </span><a href="http://magiclantern.wikia.com/wiki/IDAPython" target="_blank" class="calibre10">http://magiclantern.wikia.com/wiki/IDAPython</a></li>
<li class="calibre12"><strong class="calibre1">IDA Scriptable Debugger</strong>:<span> </span><a href="https://www.hex-rays.com/products/ida/debugger/scriptable.shtml" target="_blank" class="calibre10">https://www.hex-rays.com/products/ida/debugger/scriptable.shtml</a></li>
<li class="calibre12"><strong class="calibre1">Using IDAPython to Make Your Life Easier (Series)</strong>:<span> </span><a href="https://researchcenter.paloaltonetworks.com/2015/12/using-idapython-to-make-your-life-easier-part-1/" target="_blank" class="calibre10">https://researchcenter.paloaltonetworks.com/2015/12/using-idapython-to-make-your-life-easier-part-1/</a></li>
</ul>
<p class="calibre2">This section will give you a feel for how to use IDAPython for debugging-related tasks. First, load the executable in IDA, and select the debugger (via<span class="calibre7"> </span><span class="calibre7">Debugger | Select debugger</span>). For testing the following script commands, <span class="calibre7">Local Windows debugger</span> was chosen. After the executable has loaded, you can execute the Python code snippets mentioned in the following in IDA's Python shell, or by selecting<span class="calibre7"> </span><span class="calibre7">File | Script Command</span><span class="calibre7"> </span>(<em class="calibre17">Shift</em> + <em class="calibre17">F2</em>) and choosing the <span class="calibre7">Scripting language</span> as <span class="calibre7">Python</span> (from the drop-down menu). If you wish to run it as a standalone script, you may have to import the appropriate modules (for example, <kbd class="calibre13">import idc</kbd>).</p>
<p class="calibre2">The following code snippet sets a breakpoint at the current cursor location, starts the debugger, waits for the <kbd class="calibre13">suspend debugger</kbd> event to occur, and then prints the <em class="calibre17">address</em> and the <em class="calibre17">disassembly text</em> associated with the breakpoint address:</p>
<pre class="calibre18">idc.add_bpt(idc.get_screen_ea())<br class="title-page-name"/>idc.start_process('', '', '')<br class="title-page-name"/>evt_code = idc.wait_for_next_event(WFNE_SUSP, -1)<br class="title-page-name"/>if (evt_code &gt; 0) and (evt_code != idc.PROCESS_EXITED):<br class="title-page-name"/>    evt_ea = idc.get_event_ea()<br class="title-page-name"/>    print "Breakpoint Triggered at:", hex(evt_ea),idc.generate_disasm_line(evt_ea, 0)</pre>
<p class="calibre2">The following is the output generated as a result of executing the preceding script commands:</p>
<pre class="calibre18">Breakpoint Triggered at: 0x1171010 push ebp</pre>
<p class="calibre2">The following code snippet <em class="calibre17">steps into</em> the next instruction and prints the <em class="calibre17">address</em> and the <em class="calibre17">disassembly text</em>. In the same manner, you can use<span class="calibre7"> </span><kbd class="calibre13">idc.step_over()</kbd><span class="calibre7"> </span>to <em class="calibre17">step over</em> the instruction:</p>
<pre class="calibre18">idc.step_into()<br class="title-page-name"/>evt_code = idc.wait_for_next_event(WFNE_SUSP, -1)<br class="title-page-name"/>if (evt_code &gt; 0) and (evt_code != idc.PROCESS_EXITED):<br class="title-page-name"/>    evt_ea = idc.get_event_ea() <br class="title-page-name"/>    print "Stepped Into:", hex(evt_ea),idc.generate_disasm_line(evt_ea, 0)</pre>
<p class="calibre2">The results of executing the preceding script commands are shown here:</p>
<pre class="calibre18">Stepped Into: 0x1171011 mov ebp,esp</pre>
<p class="calibre2">To get the value of a register,  you can use <kbd class="calibre13">idc.get_reg_value()</kbd>. The following example gets the value of the <kbd class="calibre13">esp</kbd> register and prints it in the <em class="calibre17">output window:</em></p>
<pre class="calibre18">Python&gt;<strong class="calibre1">esp_value = idc.get_reg_value("esp")</strong><br class="title-page-name"/>Python&gt;<strong class="calibre1">print hex(esp_value)</strong><br class="title-page-name"/>0x1bf950</pre>
<p class="calibre2">To get the <kbd class="calibre13">dword</kbd> value at the address <kbd class="calibre13">0x14fb04</kbd>, use the following code. In the same<span class="calibre7"> </span>manner<span class="calibre7">, </span>you can use<span class="calibre7"> </span><kbd class="calibre13">idc.read_dbg_byte(ea)</kbd>, <kbd class="calibre13">idc.read_dbg_word(ea)</kbd>, and <kbd class="calibre13">idc.read_dbg_qword(ea)</kbd><span class="calibre7"> </span>to get the <kbd class="calibre13">byte</kbd>, <kbd class="calibre13">word</kbd>, and <kbd class="calibre13">qword</kbd> values at a particular address:</p>
<pre class="calibre18">Python&gt;<strong class="calibre1">ea = 0x14fb04</strong><br class="title-page-name"/>print <strong class="calibre1">hex(idc.read_dbg_dword(ea))</strong><br class="title-page-name"/>0x14fb54</pre>
<p class="calibre2">To get an ASCII string at the address <kbd class="calibre13"><span>0x01373000</span></kbd><span class="calibre7">, </span>use the following. By default, the <kbd class="calibre13">idc.get_strlit_contents()</kbd> function gets the ASCII string at a given address:</p>
<pre class="calibre18">Python&gt;<strong class="calibre1">ea = 0x01373000</strong><br class="title-page-name"/>Python&gt;<strong class="calibre1">print idc.get_strlit_contents(ea)</strong><br class="title-page-name"/>This is a simple program</pre>
<p class="calibre2"><span class="calibre7">To get the UNICODE string, you can use the <kbd class="calibre13">idc.get_strlit_contents()</kbd> function by setting its </span><kbd class="calibre13">strtype</kbd><span class="calibre7"> argument to a constant value, <kbd class="calibre13">idc.STRTYPE_C_16</kbd>, as follows. You can find the defined constant values in the <kbd class="calibre13">idc.idc</kbd> file, which is located in your IDA installation directory:</span></p>
<pre class="calibre18">Python&gt;<strong class="calibre1">ea = 0x00C37860</strong><br class="title-page-name"/>Python&gt;<strong class="calibre1">print idc.get_strlit_contents(ea, strtype=idc.STRTYPE_C_16)</strong><br class="title-page-name"/>SHAMple.dat</pre>
<p class="calibre2">The following code lists all of the loaded modules (executables and DLLs) and their base addresses:</p>
<pre class="calibre18">import idautils<br class="title-page-name"/>for m in idautils.Modules():<br class="title-page-name"/>    print "0x%08x %s" % (m.base, m.name)</pre>
<p class="calibre2">The result of executing the preceding script commands is shown here:</p>
<pre class="calibre18">0x00400000 C:\malware\5340.exe<br class="title-page-name"/>0x735c0000 C:\Windows\SYSTEM32\wow64cpu.dll<br class="title-page-name"/>0x735d0000 C:\Windows\SYSTEM32\wow64win.dll<br class="title-page-name"/>0x73630000 C:\Windows\SYSTEM32\wow64.dll<br class="title-page-name"/>0x749e0000 C:\Windows\syswow64\cryptbase.dll<br class="title-page-name"/>[REMOVED]</pre>
<p class="calibre2">To get the address of the<span class="calibre7"> </span><kbd class="calibre13">CreateFileA</kbd><span class="calibre7"> </span>function in <kbd class="calibre13">kernel32.dll</kbd>, use the following code:</p>
<pre class="calibre18">Python&gt;<strong class="calibre1">ea = idc.get_name_ea_simple("kernel32_CreateFileA")</strong><br class="title-page-name"/>Python&gt;<strong class="calibre1">print hex(ea)</strong><br class="title-page-name"/>0x768a53c6</pre>
<p class="calibre2">To resume a suspended process, you can use the following code:</p>
<pre class="calibre18">Python&gt;<strong class="calibre1">idc.resume_process()</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.9.1 Example – Determining Files Accessed by Malware</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapter, while discussing IDAPython, we wrote an IDAPython script to determine all of the cross-references to the<span class="calibre7"> </span><kbd class="calibre13">CreateFileA</kbd><span class="calibre7"> </span>function (the address where<span class="calibre7"> </span><kbd class="calibre13">CreateFileA</kbd><span class="calibre7"> </span>was called). In this section, let's enhance that script to perform debugging tasks and determine the name of the file created (or opened) by the malware.</p>
<p class="calibre2">The following script sets a breakpoint on all of the addresses where<span class="calibre7"> </span><kbd class="calibre13">CreateFileA</kbd><span class="calibre7"> </span>is called within the program, and runs the malware. Before running the following script, the appropriate debugger is selected (<span class="calibre7">Debugger | Select debugger | <span class="calibre7">Local Windows debugger</span></span><span class="calibre7">). </span>When this script is executed, it pauses at each breakpoint (in other words, before calls to<span class="calibre7"> </span><kbd class="calibre13">CreateFileA</kbd>), and it prints the first parameter (<kbd class="calibre13">lpFileName</kbd>), the second parameter<span class="calibre7"> </span><kbd class="calibre13">(dwDesiredAccess)</kbd><span class="calibre7">, </span>and    the fifth parameter<span class="calibre7"> </span><kbd class="calibre13">(dwCreationDisposition)</kbd><span class="calibre7">. T</span>hese parameters will give us the name of the file, a constant value that represents the operation performed on the file (such as <em class="calibre17">read</em>/<em class="calibre17">write</em>), and another constant value, indicating the action that will be performed (such as <em class="calibre17">create</em> or <em class="calibre17">open</em>). When the breakpoint is triggered, the first parameter can be accessed at<span class="calibre7"> </span><kbd class="calibre13">[esp]</kbd><span class="calibre7">, </span>the second parameter at<span class="calibre7"> </span><kbd class="calibre13">[esp+0x4]</kbd><span class="calibre7">, </span>and the fifth parameter at<span class="calibre7"> </span><kbd class="calibre13">[esp+0x10]</kbd>.<span class="calibre7"> </span>In addition to printing some of the parameters, the script also determines the <kbd class="calibre13">handle</kbd> to the file (<em class="calibre17">return value</em>) by retrieving the value of the<span class="calibre7"> </span><kbd class="calibre13">EAX</kbd><span class="calibre7"> </span>register after <em class="calibre17">stepping over</em> the<span class="calibre7"> </span><kbd class="calibre13">CreateFile</kbd><span class="calibre7"> </span>function:</p>
<pre class="calibre18">import idc<br class="title-page-name"/>import idautils<br class="title-page-name"/>import idaapi<br class="title-page-name"/><br class="title-page-name"/>ea = idc.get_name_ea_simple("CreateFileA")<br class="title-page-name"/>if ea == idaapi.BADADDR:<br class="title-page-name"/>   print "Unable to locate CreateFileA"<br class="title-page-name"/>else:<br class="title-page-name"/>   for ref in idautils.CodeRefsTo(ea, 1):<br class="title-page-name"/>       idc.add_bpt(ref)<br class="title-page-name"/>idc.start_process('', '', '')<br class="title-page-name"/>while True:<br class="title-page-name"/>    event_code = idc.wait_for_next_event(idc.WFNE_SUSP, -1)<br class="title-page-name"/>    if event_code &lt; 1 or event_code == idc.PROCESS_EXITED:<br class="title-page-name"/>         break<br class="title-page-name"/>    evt_ea = idc.get_event_ea()<br class="title-page-name"/>    print "0x%x %s" % (evt_ea, idc.generate_disasm_line(evt_ea,0))<br class="title-page-name"/>    esp_value = idc.get_reg_value("ESP")<br class="title-page-name"/>    dword = idc.read_dbg_dword(esp_value) <br class="title-page-name"/>    print "\tFilename:", idc.get_strlit_contents(dword)<br class="title-page-name"/>    print "\tDesiredAccess: 0x%x" % idc.read_dbg_dword(esp_value + 4)<br class="title-page-name"/>    print "\tCreationDisposition:", hex(idc.read_dbg_dword(esp_value+0x10))<br class="title-page-name"/>    idc.step_over()<br class="title-page-name"/>    evt_code = idc.wait_for_next_event(idc.WFNE_SUSP, -1)<br class="title-page-name"/>    if evt_code == idc.BREAKPOINT:<br class="title-page-name"/>        print "\tHandle(return value): 0x%x" % idc.get_reg_value("EAX")<br class="title-page-name"/>    idc.resume_process()</pre>
<p class="calibre2">The following is the result of executing the preceding script. The <kbd class="calibre13">DesiredAccess</kbd> values, <kbd class="calibre13">0x40000000</kbd><span class="calibre7"> </span>and<span class="calibre7"> </span><kbd class="calibre13">0x80000000</kbd><span class="calibre7">, </span>represent the<span class="calibre7"> </span><kbd class="calibre13">GENERIC_WRITE</kbd><span class="calibre7"> </span>and<span class="calibre7"> </span><kbd class="calibre13">GENERIC_READ</kbd><span class="calibre7"> </span>operations, respectively. The<span class="calibre7"> </span><kbd class="calibre13">createDisposition</kbd><span class="calibre7"> </span>values,<span class="calibre7"> </span><kbd class="calibre13">0x2</kbd><span class="calibre7"> </span>and<span class="calibre7"> </span><kbd class="calibre13">0x3</kbd>, signify<span class="calibre7"> </span><kbd class="calibre13">CREATE_ALWAYS</kbd><span class="calibre7"> </span>(create a new file always) and<span class="calibre7"> </span><kbd class="calibre13">OPEN_EXISTING</kbd><span class="calibre7"> </span>(open a file, only if it exists), respectively. As you can see, by using debugger scripting, it was possible to quickly determine the filenames created/accessed by malware:</p>
<pre class="calibre18"><strong class="calibre1">0x4013fb call     ds:CreateFileA</strong><br class="title-page-name"/>     Filename: <strong class="calibre1">ka4a8213.log</strong><br class="title-page-name"/>     DesiredAccess: <strong class="calibre1">0x40000000</strong><br class="title-page-name"/>     CreationDisposition: <strong class="calibre1">0x2</strong><br class="title-page-name"/>     Handle(return value): 0x50<br class="title-page-name"/><strong class="calibre1">0x401161 call     ds:CreateFileA</strong><br class="title-page-name"/>     Filename:<strong class="calibre1"> ka4a8213.log</strong><br class="title-page-name"/>     DesiredAccess: <strong class="calibre1">0x80000000</strong><br class="title-page-name"/>     CreationDisposition: <strong class="calibre1">0x3</strong><br class="title-page-name"/>     Handle(return value): 0x50<br class="title-page-name"/><strong class="calibre1">0x4011aa call     ds:CreateFileA</strong><br class="title-page-name"/>     Filename: <strong class="calibre1">C:\Users\test\AppData\Roaming\Microsoft\winlogdate.exe</strong><br class="title-page-name"/>     DesiredAccess: <strong class="calibre1">0x40000000</strong><br class="title-page-name"/>     CreationDisposition: <strong class="calibre1">0x2</strong><br class="title-page-name"/>     Handle(return value): 0x54<br class="title-page-name"/>----------------[Removed]------------------------</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4. Debugging a .NET Application</h1>
                
            
            <article>
                
<p class="calibre2">When performing malware analysis, you will have to deal with analyzing a wide variety of code. You are likely to encounter malware created using <em class="calibre17">Microsoft Visual C/C++</em>, <em class="calibre17">Delphi</em>, and the <em class="calibre17">.NET framework</em>. In this section, we will take a brief look at a tool called <em class="calibre17">dnSpy</em> (<a href="https://github.com/0xd4d/dnSpy" class="calibre10">https://github.com/0xd4d/dnSpy</a>), which makes analyzing .NET binaries much easier. It is quite effective when it comes to decompiling and debugging a .<em class="calibre17">NET application</em>. To load a .NET application, you can drag and drop the application into <em class="calibre17">dnSpy,</em> or launch <em class="calibre17">dnSpy</em> and select <span class="calibre7">File</span> | <span class="calibre7">Open</span>, giving it the path to the binary. Once the .NET application has loaded, dnSpy decompiles the application, and you can access the program's methods and classes in the left-hand window, named <span class="calibre7">Assembly explorer</span>. The following screenshot shows the<span class="calibre7"> </span><kbd class="calibre13">main</kbd><span class="calibre7"> </span>function of the decompiled .NET malicious binary (named<span class="calibre7"> </span><kbd class="calibre13">SQLite.exe</kbd>):</p>
<div class="cdpaligncenter"><img src="../images/00169.jpeg" class="calibre167"/></div>
<p class="calibre2">Once the binary has decompiled, you can either read the code (<em class="calibre17">static code analysis</em>) to determine the malware's functionality, or debug the code and perform <em class="calibre17">dynamic code analysis</em>. To debug the malware, you can either click on the <span class="calibre7">Start</span> button on the toolbar, or choose<span class="calibre7"> </span><span class="calibre7">Debug | Debug an Assembly</span><span class="calibre7"> </span>(<em class="calibre17">F5</em>); this will pop up the dialog shown here:</p>
<div class="cdpaligncenter"><img src="../images/00170.jpeg" class="calibre41"/></div>
<p class="calibre2">Using the <span class="calibre7">Break at</span> drop-down option, you can specify where to <em class="calibre17">break</em> when the debugger starts. Once you are satisfied with the options, you can click on<span class="calibre7"> </span><span class="calibre7">OK,</span><span class="calibre7"> </span>which will start the process under debugger control and pause the debugger at the entry point. Now, you can access various debugger options (such as <span class="calibre7">Step Over, Step into, Continue</span>, and so on) via the <span class="calibre7">Debug</span> menu, shown in the following screenshot. You can also set a breakpoint by double-clicking on a line, or by choosing<span class="calibre7"> </span><strong class="calibre5"><span class="calibre7">Debug | Toggle Breakpoint</span></strong> (<em class="calibre17">F9</em>).<span class="calibre7"> </span>While you are debugging, you can make use of the <span class="calibre7">Locals</span> window to examine some of the local variables or memory locations:</p>
<div class="cdpaligncenter"><img src="../images/00171.jpeg" class="calibre168"/></div>
<div class="cdpaligncenter"> </div>
<div class="packt_infobox">To get an idea of .NET binary analysis, and for a detailed analysis of the previously mentioned binary (named <kbd class="calibre42">SQLite.exe</kbd>), you can read the author's blog post at<span class="calibre21"> </span><a href="https://cysinfo.com/cyber-attack-targeting-cbi-and-possibly-indian-army-officials/" class="calibre20">https://cysinfo.com/cyber-attack-targeting-cbi-and-possibly-indian-army-officials/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">The debugging techniques covered in this chapter are effective methods for understanding the inner workings of a malicious binary. The debugging features provided by code analysis tools such as IDA, x64dbg, and dnSpy can greatly enhance your reverse engineering process. During malware analysis, you will often combine both disassembly and<span class="calibre7"> </span>debugging<span class="calibre7"> </span>techniques to determine malware functionalities and obtain valuable information from a malicious binary.</p>
<p class="calibre2">In the next chapter, we will use the skills that we have learned so far to understand various malware characteristics and functionalities.</p>


            </article>

            
        </section>
    </body></html>