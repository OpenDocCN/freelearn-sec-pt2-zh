["```\n(23+3)%26 = 0\n```", "```\n(i + key) % (length of the character set)\n\nwhere i = index of plaintext character\n```", "```\n(j - key) % (length of the character set)\n\nwhere j = index of ciphertext character\n```", "```\n>>> chr_set = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n>>> key = 3\n>>> cipher_text = \"CHXV\"\n>>> plain_text = \"\"\n>>> for ch in cipher_text:\n j = chr_set.find(ch.upper())\n plain_index = (j-key) % len(chr_set)\n plain_text += chr_set[plain_index]\n>>> print plain_text\nZEUS\n```", "```\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\n```", "```\nO -> 0x4f -> 01001111\nn -> 0x6e -> 01101110\ne -> 0x65 -> 01100101\n```", "```\n010011110110111001100101\n```", "```\n010011 -> 19 -> base64 table lookup -> T\n110110 -> 54 -> base64 table lookup -> 2\n111001 -> 57 -> base64 table lookup -> 5\n100101 -> 37 -> base64 table lookup -> l\n```", "```\n>>> import base64\n>>> plain_text = \"One\"\n>>> encoded = base64.b64encode(plain_text)\n>>> print encoded\nT25l\n```", "```\n>>> import base64\n>>> encoded = \"T25l\"\n>>> decoded = base64.b64decode(encoded)\n>>> print decoded\nOne\n```", "```\n>>> encoded = \"Q3VycmVudFZlcnNpb246IDYuMQ0KVXNlciBwcml2aWxlZ2llcyBsZXZlbDogMg0KUGFyZW50IHByb2Nlc3M6IFxEZXZpY2VcSGFyZGRpc2tWb2x1bWUxXFdpbmRvd3NcZXhwbG9yZXIuZXhlDQoNCg\"\n>>> len(encoded)\n150\n```", "```\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\n```", "```\n>>> import base64\n>>> encoded = \"cGFzc3dvcmQxMjM0IUA_PUB-\"\n>>> encoded = encoded.replace(\"-\",\"+\").replace(\"_\",\"/\")\n>>> decoded = base64.b64decode(encoded)\n>>> print decoded\npassword1234!@?=@~\n```", "```\n0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n```", "```\n>>> import base64\n>>> chr_set = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n>>> non_chr_set = \"0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz=\"\n>>> encoded = \"G6JgP6w=\"\n>>> re_encoded = \"\"\n>>> for en_ch in encoded:\n re_encoded += en_ch.replace(en_ch, chr_set[non_chr_set.find(en_ch)])\n>>> decoded = base64.b64decode(re_encoded)\n>>> print decoded\nHello\n```", "```\nrule base64\n{\nstrings:\n    $a=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n    $b=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"\ncondition:\n    $a or $b\n}\n```", "```\n                2: 0000 0010\n                4: 0000 0100\n---------------------------\nResult After XOR : 0000 0110 (6)\n```", "```\ndef xor(data, key):\n    translated = \"\"\n    for ch in data:\n        translated += chr(ord(ch) ^ key)\n    return translated\n\nif __name__ == \"__main__\":\n   out = xor(\"#!4\", 0x40)\n   print out\n```", "```\n>>> def xor_brute_force(content, to_match):\n for key in range(256):\n translated = \"\"\n for ch in content:\n translated += chr(ord(ch) ^ key)\n if to_match in translated:\n print \"Key %s(0x%x): %s\" % (key, key, translated)\n\n>>> xor_brute_force(\"lkwpjeia>i}ieglmja\", \"mymachine\")\nKey 4(0x4): hostname:mymachine\n```", "```\n>>> ch = 0x00\n>>> key = 4\n>>> ch ^ key\n4\n```", "```\n>>> plaintext = \"hello\\x00\\x00\\x00\"\n>>> key = 0x4b \n>>> enc_text = \"\"\n>>> for ch in plaintext:\n x = ord(ch) ^ key\n enc_hex += hex(x) + \" \"\n enc_text += chr(x)\n\n>>> print enc_hex\n0x23 0x2e 0x27 0x27 0x24 0x4b 0x4b 0x4b\n>>> print enc_text\n#.''$KKK\n```", "```\n>>> plaintext = \"hello\\x00\\x00\\x00\"\n>>> key = 0x4b\n>>> enc_text = \"\"\n>>> for ch in plaintext:\n if ch == \"\\x00\" or ch == chr(key):\n enc_text += ch\n else:\n enc_text += chr(ord(ch) ^ key)\n\n>>> enc_text\n\"#.''$\\x00\\x00\\x00\"\n```", "```\nimport os\nimport struct\nimport sys\n\ndef four_byte_xor(content, key ):\n    translated = \"\"\n    len_content = len(content)\n    index = 0\n    while (index < len_content):\n        data = content[index:index+4]\n        p = struct.unpack(\"I\", data)[0]\n        translated += struct.pack(\"I\", p ^ key)\n        index += 4\n    return translated\n\nin_file = open(\"rsrc.bin\", 'rb')\nout_file = open(\"decrypted.bin\", 'wb')\nxor_key = 0xEAD4AA34\nrsrc_content = in_file.read()\ndecrypted_content = four_byte_xor(rsrc_content,xor_key)\nout_file.write(decrypted_content)\n```", "```\n$ xxd decrypted.bin | more\n00000000:  4d5a 9000 0300 0000 0400 0000 ffff 0000  MZ..............\n00000010:  b800 0000 0000 0000 4000 0000 0000 0000  ........@.......\n00000020:  0000 0000 0000 0000 0000 0000 0000 0000  ................\n00000030:  0000 0000 0000 0000 0000 0000 f000 0000  ................\n00000040:  0e1f ba0e 00b4 09cd 21b8 014c cd21 5468  ........!..L.!Th\n00000050:  6973 2070 726f 6772 616d 2063 616e 6e6f  is program canno\n00000060:  7420 6265 2072 756e 2069 6e20 444f 5320  t be run in DOS\n```", "```\nC:\\signsrch>signsrch.exe -e kav.exe\n\nSignsrch 0.2.4\nby Luigi Auriemma\ne-mail: aluigi@autistici.org\nweb: aluigi.org\n  optimized search function by Andrew http://www.team5150.com/~andrew/\n  disassembler engine by Oleh Yuschuk\n\n- open file \"kav.exe\"\n- 91712 bytes allocated\n- load signatures\n- open file C:\\signsrch\\signsrch.sig\n- 3075 signatures in the database\n- start 1 threads\n- start signatures scanning:\n\n  offset num description [bits.endian.size]\n  --------------------------------------------\n00410438 1918 DES initial permutation IP [..64]\n00410478 2330 DES_fp [..64]\n004104b8 2331 DES_ei [..48]\n004104e8 2332 DES_p32i [..32]\n00410508 1920 DES permuted choice table (key) [..56]\n00410540 1921 DES permuted choice key (table) [..48]\n00410580 1922 DES S-boxes [..512]\n[Removed]\n```", "```\nC:\\signsrch>signsrch.exe -F kav.exe\n\n[removed]\n\n  offset num description [bits.endian.size]\n  --------------------------------------------\n[removed]\n004032e0 1918 DES initial permutation IP [..64]\n00403490 2330 DES_fp [..64]\n```", "```\nC:\\signsrch>signsrch.exe -P kav.exe\n\n[removed]\n\n- 01350000 0001b000 C:\\Users\\test\\Desktop\\kav.exe\n- pid 3068\n- base address 0x01350000\n- offset 01350000 size 0001b000\n- 110592 bytes allocated\n- load signatures\n- open file C:\\signsrch\\signsrch.sig\n- 3075 signatures in the database\n- start 1 threads\n- start signatures scanning:\n\n  offset num description [bits.endian.size]\n  --------------------------------------------\n  01360438 1918 DES initial permutation IP [..64]\n 01360478 2330 DES_fp [..64]\n 013604b8 2331 DES_ei [..48]\n```", "```\n>>> from Crypto.Hash import MD5,SHA256,SHA1\n>>> text = \"explorer.exe\"\n>>> MD5.new(text).hexdigest()\n'cde09bcdf5fde1e2eac52c0f93362b79'\n>>> SHA256.new(text).hexdigest()\n'7592a3326e8f8297547f8c170b96b8aa8f5234027fd76593841a6574f098759c'\n>>> SHA1.new(text).hexdigest()\n'7a0fd90576e08807bde2cc57bcf9854bbce05fe3'\n```", "```\n>>> from Crypto.Cipher import DES\n>>> text = \"hostname=blank78\"\n>>> key = \"14834567\"\n>>> des = DES.new(key, DES.MODE_ECB)\n>>> cipher_text = des.encrypt(text)\n>>> cipher_text\n'\\xde\\xaf\\t\\xd5)sNj`\\xf5\\xae\\xfd\\xb8\\xd3f\\xf7'\n>>> plain_text = des.decrypt(cipher_text)\n>>> plain_text\n'hostname=blank78'\n```", "```\n>>> import base64\n>>> from Crypto.Cipher import ARC4\n>>> rc4_key = \"e65wb24n5\"\n>>> cipher_text = \"kRp6OKW9r90_2_KvkKcQ_j5oA1D2aIxt6xPeFiJYlEHvM8QMql38CtWfWuYlgiXMDFlsoFoH\"\n>>> content = cipher_text.replace('_','/').replace('-','=')\n>>> b64_decode = base64.b64decode(content)\n>>> rc4 = ARC4.new(rc4_key)\n>>> plain_text = rc4.decrypt(b64_decode)\n>>> print plain_text\nMYHOSTNAME|Administrator|192.168.1.100|No Proxy|04182|\n```", "```\nimport idautils\nimport idaapi\nimport idc\n\nfor name in idautils.Names():\n    if name[1] == \"dec_function\":\n        ea= idc.get_name_ea_simple(\"dec_function\")\n        for ref in idautils.CodeRefsTo(ea, 1):\n            idc.add_bpt(ref)\nidc.start_process('', '', '')\nwhile True:\n    event_code = idc.wait_for_next_event(idc.WFNE_SUSP, -1)\n    if event_code < 1 or event_code == idc.PROCESS_EXITED:\n        break\n    rcx_value = idc.get_reg_value(\"RCX\")\n    encoded_string = idc.get_strlit_contents(rcx_value)\n    idc.step_over()\n    evt_code = idc.wait_for_next_event(idc.WFNE_SUSP, -1)\n    if evt_code == idc.BREAKPOINT:\n        rax_value = idc.get_reg_value(\"RAX\")\n    decoded_string = idc.get_strlit_contents(rax_value)\n    print \"{0} {1:>25}\".format(encoded_string, decoded_string)\n    idc.resume_process()\n```", "```\nC:\\TitanMist>TitanMist.exe -i packed.exe -o unpacked.exe -t python\n\nMatch found!\n│ Name: UPX\n│ Version: 0.8x - 3.x\n│ Author: Markus and Laszlo\n│ Wiki url: http://kbase.reversinglabs.com/index.php/UPX\n│ Description:\n\nUnpacker for UPX 1.x - 3.x packed files\nReversingLabs Corporation / www.reversinglabs.com\n[x] Debugger initialized.\n[x] Hardware breakpoint set.\n[x] Import at 00407000.\n[x] Import at 00407004.\n[x] Import at 00407008.[Removed]\n[x] Import at 00407118.\n[x] OEP found: 0x0040259B.\n[x] Process dumped.\n[x] IAT begin at 0x00407000, size 00000118.\n[X] Imports fixed.\n[x] No overlay found.\n[x] File has been realigned.\n[x] File has been unpacked to unpacked.exe.\n[x] Exit Code: 0.\n█ Unpacking succeeded! \n```"]