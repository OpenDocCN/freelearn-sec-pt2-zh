<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Hunting Malware Using Memory Forensics</h1>
                
            
            <article>
                
<p class="calibre2">In the chapters covered so far, we looked at the concepts, tools, and techniques that are used to analyze malware using static, dynamic, and code analysis. In this chapter, you will understand another technique, called <em class="calibre17">memory forensics (or Memory Analysis)</em>.</p>
<p class="calibre2">Memory forensics (or Memory Analysis) is an investigative technique which involves finding and extracting forensic artifacts from the computer's physical memory (RAM). A computer's memory stores valuable information about the runtime state of the system. Acquiring the memory and analyzing it will reveal necessary information for forensic investigation, such as which applications are running on the system, what objects (file, registry, and so on) these applications are accessing, active networks connections, loaded modules, loaded kernel drivers, and other information. For this reason, memory forensics is used in incident response and malware analysis.</p>
<p class="calibre2">During incident response,  in most cases, you will not have access to the malware sample but you may only have the memory image of a suspect system. For instance, you may receive an alert from a security product about a possible malicious behavior from a system, in that case, you may acquire the memory image of the suspect system, to perform memory forensics for confirming the infection and to find the malicious artifacts.</p>
<p class="calibre2">In addition to using memory forensics for incident response, you can also use it as part of malware analysis (where you have the malware sample) to gain additional information about the behavior of the malware post-infection. For instance, when you have a malware sample, in addition to performing static, dynamic, and code analysis, you can execute the sample in an isolated environment and then acquire the infected computer memory and examine the memory image to get an idea of the malware's behavior after infection.</p>
<p class="calibre2">Another reason why you use memory forensics is that some malware samples may not write malicious components to the disk (only in memory). As a result, disk forensics or the filesystem analysis might fail. In such cases, memory forensics can be extremely useful in finding the malicious component.</p>
<p class="calibre2">Some malware samples trick the operating system and live forensic tools by hooking or by modifying operating system structures. In such cases, memory forensics can be useful as it can bypass the tricks used by the malware to hide from the operating system and live forensic tools. This chapter introduces you to the concept of memory forensics and covers tools used to acquire and analyze the memory image.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1. Memory Forensics Steps</h1>
                
            
            <article>
                
<p class="calibre2">Whether you use memory forensics as part of the incident response or for malware analysis, the following are the general steps in memory forensics:</p>
<ul class="calibre11">
<li class="calibre12"><strong class="calibre1">Memory Acquisition</strong>: This involves acquiring (or dumping) the memory of a target machine to disk. Depending on whether you are investigating an infected system or using memory forensics as part of your malware analysis, the target machine can be a system (on your network) that you suspect to be infected, or it could be an analysis machine in your lab environment where you executed the malware sample.</li>
<li class="calibre12"><strong class="calibre1">Memory Analysis</strong>: After you dump the memory to disk, this step involves analyzing the dumped memory to find and extract forensic artifacts.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2. Memory Acquisition</h1>
                
            
            <article>
                
<p class="calibre2">Memory acquisition is the process of acquiring volatile memory (RAM) to non-volatile storage (file on the disk). There are various tools that allow you to acquire the memory of a physical machine. The following are some of the tools that allow you to acquire (dump) the physical memory onto Windows. Some of these tools are commercial, and many of them can be downloaded for free after registration. The following tools work with both x86 (32-bit) and x64 (64-bits) machines:</p>
<ul class="calibre11">
<li class="calibre12"><em class="calibre19">Comae Memory Toolkit (DumpIt)</em> by Comae Technologies <em class="calibre19">(free download with registration):</em> <a href="https://my.comae.io/" class="calibre10">https://my.comae.io/</a></li>
<li class="calibre12"><em class="calibre19">Belkasoft RAM Capturer (free download with registration):</em> <a href="https://belkasoft.com/ram-capturer" class="calibre10">https://belkasoft.com/ram-capturer</a> </li>
<li class="calibre12"><em class="calibre19">FTK Imager</em> by AccessData <em class="calibre19">(free download with registration):</em> <a href="https://accessdata.com/product-download" class="calibre10">https://accessdata.com/product-download</a></li>
<li class="calibre12"><em class="calibre19">Memoryze</em> by FireEye <em class="calibre19">(free download with registration):</em> <a href="https://www.fireeye.com/services/freeware/memoryze.html" class="calibre10">https://www.fireeye.com/services/freeware/memoryze.html</a></li>
<li class="calibre12"><em class="calibre19">Surge Collect</em> by Volexity (<em class="calibre19">Commercial</em>): <a href="https://www.volexity.com/products-overview/surge/" target="_blank" class="calibre10">https://www.volexity.com/products-overview/surge/</a></li>
<li class="calibre12"><em class="calibre19">OSForensics</em> by PassMark Software <em class="calibre19">(commercial):</em> <a href="https://www.osforensics.com/osforensics.html" class="calibre10">https://www.osforensics.com/osforensics.html</a></li>
<li class="calibre12"><em class="calibre19">WinPmem (open source), part of Rekall Memory forensic framework:</em> <a href="http://blog.rekall-forensic.com/search?q=winpmem" class="calibre10">http://blog.rekall-forensic.com/search?q=winpmem</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.1 Memory Acquisition Using DumpIt</h1>
                
            
            <article>
                
<p class="calibre2"><em class="calibre17">DumpIt</em> is an excellent memory acquisition tool that allows you to dump physical memory on Windows. It supports the acquisition of both 32-bit (x86) and 64-bit (x64) machines. DumpIt is part of a toolkit called the <em class="calibre17">Comae memory toolkit</em>, which consists of various standalone tools that assist with memory acquisition and conversion between different file formats. To download the latest copy of the <em class="calibre17">Comae memory toolkit</em>, you need to create an account by registering on <a href="https://my.comae.io" class="calibre10">https://my.comae.io</a>. Once the account is created, you can log in and download the latest copy of the <em class="calibre17">Comae memory toolkit.</em></p>
<p class="calibre2">After downloading the Comae toolkit, extract the archive, and navigate to the 32-bit or 64-bit directory, depending on whether you want to dump the memory of a 32-bit or 64-bit machine. The directory consists of various files, including <em class="calibre17">DumpIt.exe</em>. In this section, we will mainly focus on how to use DumpIt to dump the memory. If you are interested in understanding the functionality of other tools in the directory, read the <em class="calibre17">readme.txt</em> file.</p>
<p class="calibre2">The easiest method to acquire memory using <em class="calibre17">DumpIt</em> is to right-click on the <em class="calibre17">DumptIt.exe</em> file and select <em class="calibre17">Run as administrator</em>. By default, DumpIt dumps the memory to a file as a <em class="calibre17">Microsoft Crash Dump (with a .dmp extension),</em> which can then be analyzed with Memory Analysis tools such as <em class="calibre17">Volatility</em> (which will be covered next) or by using a Microsoft debugger such as <em class="calibre17">WinDbg</em>.</p>
<p class="calibre2">You can also run <em class="calibre17">DumpIt</em> from the command line; this provides you with multiple options. To display different options, run <em class="calibre17">cmd.exe</em> as an Administrator, navigate to the directory containing <em class="calibre17">DumpIt.exe</em>, and type the following command:</p>
<pre class="calibre18">C:\Comae-Toolkit-3.0.20180307.1\x64&gt;<strong class="calibre1">DumpIt.exe /?</strong><br class="title-page-name"/>  DumpIt 3.0.20180307.1<br class="title-page-name"/>  Copyright (C) 2007 - 2017, Matthieu Suiche &lt;http://www.msuiche.net&gt;<br class="title-page-name"/>  Copyright (C) 2012 - 2014, MoonSols Limited &lt;http://www.moonsols.com&gt;<br class="title-page-name"/>  Copyright (C) 2015 - 2017, Comae Technologies FZE &lt;http://www.comae.io&gt;<br class="title-page-name"/><br class="title-page-name"/>Usage: DumpIt [Options] /OUTPUT &lt;FILENAME&gt;<br class="title-page-name"/><br class="title-page-name"/>Description:<br class="title-page-name"/>  Enables users to create a snapshot of the physical memory as a local file.<br class="title-page-name"/><br class="title-page-name"/>Options:<br class="title-page-name"/>   /TYPE, /T Select type of memory dump (e.g. RAW or DMP) [default: DMP]<br class="title-page-name"/>   /OUTPUT, /O Output file to be created. (optional)<br class="title-page-name"/>   /QUIET, /Q Do not ask any questions. Proceed directly.<br class="title-page-name"/>   /NOLYTICS, /N Do not send any usage analytics information to Comae Technologies. This is used to  <br class="title-page-name"/>    improve our services.<br class="title-page-name"/>   /NOJSON, /J Do not save a .json file containing metadata. Metadata are the basic information you will <br class="title-page-name"/>    need for the analysis.<br class="title-page-name"/>   /LIVEKD, /L Enables live kernel debugging session.<br class="title-page-name"/>   /COMPRESS, /R Compresses memory dump file.<br class="title-page-name"/>   /APP, /A Specifies filename or complete path of debugger image to execute.<br class="title-page-name"/>   /CMDLINE, /C Specifies debugger command-line options.<br class="title-page-name"/>   /DRIVERNAME, /D Specifies the name of the installed device driver image.</pre>
<p class="calibre2">To acquire the memory of the Microsoft Crash dump from the command line, and to save the output to a file name of your choice, use the <kbd class="calibre13">/o</kbd> or <kbd class="calibre13">/OUTPUT</kbd> option, as follows:</p>
<pre class="calibre18">C:\Comae-Toolkit-3.0.20180307.1\x64&gt;<strong class="calibre1">DumpIt.exe /o memory.dmp</strong><br class="title-page-name"/><br class="title-page-name"/>  DumpIt 3.0.20180307.1<br class="title-page-name"/>  Copyright (C) 2007 - 2017, Matthieu Suiche &lt;http://www.msuiche.net&gt;<br class="title-page-name"/>  Copyright (C) 2012 - 2014, MoonSols Limited &lt;http://www.moonsols.com&gt;<br class="title-page-name"/>  Copyright (C) 2015 - 2017, Comae Technologies FZE &lt;http://www.comae.io&gt;<br class="title-page-name"/>    <br class="title-page-name"/>    Destination path: <strong class="calibre1">\??\C:\Comae-Toolkit-3.0.20180307.1\x64\memory.dmp</strong><br class="title-page-name"/>    <br class="title-page-name"/>    Computer name:             PC<br class="title-page-name"/><br class="title-page-name"/>    --&gt; Proceed with the acquisition ? [y/n] y<br class="title-page-name"/><br class="title-page-name"/>    [+] Information:<br class="title-page-name"/>    Dump Type:                  Microsoft Crash Dump<br class="title-page-name"/><br class="title-page-name"/>    [+] Machine Information:<br class="title-page-name"/>    Windows version: 6.1.7601<br class="title-page-name"/>    MachineId: A98B4D56-9677-C6E4-03F5-902A1D102EED<br class="title-page-name"/>    TimeStamp: 131666114153429014<br class="title-page-name"/>    Cr3: 0x187000<br class="title-page-name"/>    KdDebuggerData: 0xfffff80002c460a0<br class="title-page-name"/>    Current date/time: [2018-03-27 (YYYY-MM-DD) 8:03:35 (UTC)]<br class="title-page-name"/>    + Processing... Done.<br class="title-page-name"/>    Acquisition finished at: [2018-03-27 (YYYY-MM-DD) 8:04:57 (UTC)]<br class="title-page-name"/>    Time elapsed: 1:21 minutes:seconds (81 secs)<br class="title-page-name"/>    Created file size: 8589410304 bytes (8191 Mb)<br class="title-page-name"/>    Total physical memory size: 8191 Mb<br class="title-page-name"/>    NtStatus (troubleshooting): 0x00000000<br class="title-page-name"/>    Total of written pages: 2097022<br class="title-page-name"/>    Total of inacessible pages: 0<br class="title-page-name"/>    Total of accessible pages: 2097022<br class="title-page-name"/>    SHA-256: 3F5753EBBA522EF88752453ACA1A7ECB4E06AEA403CD5A4034BCF037CA83C224<br class="title-page-name"/>    JSON path: C:\Comae-Toolkit-3.0.20180307.1\x64\memory.json</pre>
<p class="calibre2">To acquire the memory as a raw memory dump instead of the default Microsoft crash dump, you can specify that with the <kbd class="calibre13">/t</kbd> or <kbd class="calibre13">/TYPE</kbd> option, as follows:</p>
<pre class="calibre18">C:\Comae-Toolkit-3.0.20180307.1\x64&gt;<strong class="calibre1">DumpIt.exe /t RAW</strong><br class="title-page-name"/><br class="title-page-name"/>  DumpIt 3.0.20180307.1<br class="title-page-name"/>  Copyright (C) 2007 - 2017, Matthieu Suiche &lt;http://www.msuiche.net&gt;<br class="title-page-name"/>  Copyright (C) 2012 - 2014, MoonSols Limited &lt;http://www.moonsols.com&gt;<br class="title-page-name"/>  Copyright (C) 2015 - 2017, Comae Technologies FZE &lt;http://www.comae.io&gt;<br class="title-page-name"/>  <br class="title-page-name"/>  WARNING: RAW memory snapshot files are considered obsolete and as a legacy format.<br class="title-page-name"/>  <br class="title-page-name"/>  Destination path:  <strong class="calibre1">\??\C:\Comae-Toolkit-3.0.20180307.1\x64\memory.bin</strong><br class="title-page-name"/>  Computer name:             PC<br class="title-page-name"/><br class="title-page-name"/>  --&gt; Proceed with the acquisition? [y/n] y<br class="title-page-name"/>  <br class="title-page-name"/>  [+] Information:<br class="title-page-name"/>  Dump Type:                  Raw Memory Dump<br class="title-page-name"/><br class="title-page-name"/>  [+] Machine Information:<br class="title-page-name"/>  Windows version:            6.1.7601<br class="title-page-name"/>  MachineId:                  A98B4D56-9677-C6E4-03F5-902A1D102EED<br class="title-page-name"/>  TimeStamp:                  131666117379826680<br class="title-page-name"/>  Cr3:                        0x187000<br class="title-page-name"/>  KdDebuggerData:             0xfffff80002c460a0<br class="title-page-name"/>  Current date/time:          [2018-03-27 (YYYY-MM-DD) 8:08:57 (UTC)]<br class="title-page-name"/><br class="title-page-name"/>[.......REMOVED.........]</pre>
<p class="calibre2">If you wish to acquire memory from servers consisting of large memory, you can use the <kbd class="calibre13">/R</kbd> or <kbd class="calibre13">/COMPRESS</kbd> option in <em class="calibre17">DumpIt</em>, which creates a <kbd class="calibre13">.zdmp</kbd> (<em class="calibre17">Comae compressed crash dump</em>) file, which reduces the file size and also makes acquisition faster. The dump file (<kbd class="calibre13">.zdmp</kbd>) can then be analyzed with the Comae Stardust enterprise platform: <a href="https://my.comae.io" class="calibre10">https://my.comae.io</a>. For more details, refer to the following blog post: <a href="https://blog.comae.io/rethinking-logging-for-critical-assets-685c65423dc0" class="calibre10">https://blog.comae.io/rethinking-logging-for-critical-assets-685c65423dc0</a>.</p>
<div class="packt_infobox">In most cases, you can acquire the memory of a <em class="calibre22">Virtual Machine (VM)</em> by suspending the VM. For instance, after executing the malware sample on VMware Workstation/VMware Fusion, you can suspend the VM, which will write the guest's memory (RAM) to a file with a <kbd class="calibre42">.vmem</kbd> extension on the host machine's disk. For those applications (such as VirtualBox) where the memory cannot be acquired by suspending, then you can use DumpIt inside the guest machine.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3. Volatility Overview</h1>
                
            
            <article>
                
<p class="calibre2">Once you acquire the memory of an infected system, the next step is to analyze the acquired memory image. <em class="calibre17">Volatility</em> (<a href="http://www.volatilityfoundation.org/releases" class="calibre10">http://www.volatilityfoundation.org/releases</a>) is an open source advanced memory forensics framework written in <em class="calibre17">Python</em> that allows you to analyze and extract digital artifacts from the memory image. Volatility can run on various platforms (Windows, macOS, and Linux), and it supports analysis of memory from 32-bit and 64-bit versions of Windows, macOS, and Linux operating systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.1 Installing Volatility</h1>
                
            
            <article>
                
<p class="calibre2">Volatility is distributed in several formats, and it can be downloaded from <a href="http://www.volatilityfoundation.org/releases" class="calibre10">http://www.volatilityfoundation.org/releases</a>. At the time of writing this book, the latest version of Volatility is version 2.6. Depending on the operating system that you intend to run Volatility on, follow the installation procedure for the appropriate operating system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.1.1 Volatility Standalone Executable</h1>
                
            
            <article>
                
<p class="calibre2">The fastest way to get started with Volatility is to use the <em class="calibre17">standalone executable</em>. The standalone executable is distributed for Windows, macOS, and Linux operating systems. The advantage of a standalone executable is that you don't need to install the Python interpreter or Volatility dependencies, since it comes packaged with Python 2.7 Interpreter and all the required dependencies.</p>
<p class="calibre2">On Windows, once the standalone executable is downloaded, you can check whether Volatility is ready to use by executing the standalone executable with the <kbd class="calibre13">-h (--help)</kbd> option from the command line, as shown here. The help option displays various options and plugins that are available in Volatility:</p>
<pre class="calibre18">C:\volatility_2.6_win64_standalone&gt;<strong class="calibre1">volatility_2.6_win64_standalone.exe -h</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Usage: Volatility - A memory forensics analysis platform.<br class="title-page-name"/><br class="title-page-name"/>Options:<br class="title-page-name"/>  -h, --help            list all available options and their default values.<br class="title-page-name"/>                        Default values may be set in the configuration file<br class="title-page-name"/>                        (/etc/volatilityrc)<br class="title-page-name"/>  --conf-file=.volatilityrc<br class="title-page-name"/>                        User based configuration file<br class="title-page-name"/>  -d, --debug           Debug volatility<br class="title-page-name"/>[.....REMOVED....]</pre>
<p class="calibre2">In the same manner, you can download the standalone executables for Linux or macOS and check if Volatility is ready to use by executing the standalone executable with the <kbd class="calibre13">-h</kbd> (or <kbd class="calibre13">--help</kbd>) option, as follows:</p>
<pre class="calibre18">$ <strong class="calibre1">./volatility_2.6_lin64_standalone -h</strong><br class="title-page-name"/># <strong class="calibre1">./volatility_2.6_mac64_standalone -h</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.1.2 Volatility Source Package</h1>
                
            
            <article>
                
<p class="calibre2">Volatility is also distributed as a source package; you can run it on <em class="calibre17">Windows</em>, macOS, or <em class="calibre17">Linux</em> operating systems. Volatility relies on various plugins to perform tasks, and some of these plugins depend on third-party Python packages. To run Volatility, you need to install Python 2.7 Interpreter and its dependencies. The web page: <a href="https://github.com/volatilityfoundation/volatility/wiki/Installation#recommended-packages" class="calibre10">https://github.com/volatilityfoundation/volatility/wiki/Installation#recommended-packages</a> contains a list of the third-party Python packages that are required by some of the Volatility plugins. You can install these dependencies by reading the documentation. Once all the dependencies are installed, download the Volatility source code package, extract it, and run <em class="calibre17">Volatility</em>, as follows:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -h</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Usage: Volatility - A memory forensics analysis platform.<br class="title-page-name"/><br class="title-page-name"/>Options:<br class="title-page-name"/>  -h, --help             list all available options and their default values.<br class="title-page-name"/>                         Default values may be set in the configuration file<br class="title-page-name"/>                         (/etc/volatilityrc)<br class="title-page-name"/>  --conf-file=/root/.volatilityrc<br class="title-page-name"/>                         User based configuration file<br class="title-page-name"/>  -d, --debug            Debug volatility<br class="title-page-name"/>[...REMOVED...]</pre>
<p class="calibre2">All the examples mentioned in this book use the Volatility Python script (<kbd class="calibre13">python vol.py</kbd>) from the source package. You are free to choose a standalone executable, but just remember to replace <kbd class="calibre13">python vol.py</kbd> with the standalone executable name.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3.2 Using Volatility</h1>
                
            
            <article>
                
<p class="calibre2">Volatility consists of various plugins that can extract different information from the memory image. The <kbd class="calibre13">python vol.py -h</kbd> option displays the supported plugins. For instance, if you wish to list the running processes from the memory image, you can use a plugin such a <kbd class="calibre13">pslist</kbd>, or if you wish to list the network connections, you can use a different plugin. Irrespective of the plugin that you use, you will use the following command syntax. Using <kbd class="calibre13">-f</kbd>, you specify the path to the memory image file, and  <kbd class="calibre13">--profile</kbd> tells Volatility which system and architecture the memory image was acquired from. The plugin can vary depending on what type of information you would like to extract from the memory image:</p>
<pre class="calibre18">$ python vol.py -f &lt;memory image file&gt; --profile=&lt;PROFILE&gt; &lt;PLUGIN&gt; [ARGS]</pre>
<p class="calibre2">The following command uses the <kbd class="calibre13">pslist</kbd> plugin to list the running processes from the memory image acquired from Windows 7 (32-bit) running Service Pack 1:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f mem_image.raw --profile=Win7SP1x86 pslist</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V)  Name        PID PPID Thds Hnds  Sess Wow64  Start<br class="title-page-name"/>---------- ---------- ---- ---- ---- ----  ---- ----- ---------------------<br class="title-page-name"/>0x84f4a958 System         4    0  86  448  ----    0  2016-08-13 05:54:20<br class="title-page-name"/>0x864284e0 smss.exe     272    4   2   29  ----    0  2016-08-13 05:54:20<br class="title-page-name"/>0x86266030 csrss.exe    356  340   9  504     0    0  2016-08-13 05:54:22<br class="title-page-name"/>0x86e0a1a0 wininit.exe  396  340   3   75     0    0  2016-08-13 05:54:22<br class="title-page-name"/>0x86260bd0 csrss.exe    404  388  10  213     1    0  2016-08-13 05:54:22<br class="title-page-name"/>0x86e78030 winlogon.exe 460  388   3  108     1    0  2016-08-13 05:54:22<br class="title-page-name"/><br class="title-page-name"/>[....REMOVED....]</pre>
<p class="calibre2">Sometimes, you might not know what profile to supply to Volatility. In that case, you can use the <kbd class="calibre13">imageinfo</kbd> plugin, which will determine the correct profile. The following command displays multiple profiles that are suggested by the <kbd class="calibre13">imageinfo</kbd> plugin; you can use any of the suggested profiles:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f mem_image.raw imageinfo</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>INFO    : volatility.debug    : Determining profile based on KDBG search...<br class="title-page-name"/>          Suggested Profile(s): <strong class="calibre1">Win7SP1x86_23418, Win7SP0x86, Win7SP1x86</strong><br class="title-page-name"/>                    AS Layer1 : IA32PagedMemoryPae (Kernel AS)<br class="title-page-name"/>                    AS Layer2 : FileAddressSpace (Users/Test/Desktop/mem_image.raw)<br class="title-page-name"/>                     PAE type : PAE<br class="title-page-name"/>                          DTB : 0x185000L<br class="title-page-name"/>                         KDBG : 0x82974be8L<br class="title-page-name"/>         Number of Processors : 1<br class="title-page-name"/>    Image Type (Service Pack) : 0<br class="title-page-name"/>               KPCR for CPU 0 : 0x82975c00L<br class="title-page-name"/>            KUSER_SHARED_DATA : 0xffdf0000L<br class="title-page-name"/>          Image date and time : 2016-08-13 06:00:43 UTC+0000<br class="title-page-name"/>    Image local date and time : 2016-08-13 11:30:43 +0530</pre>
<div class="packt_infobox">Most of the Volatility plugins, such as <kbd class="calibre42">pslist</kbd>, rely on extracting the information from the Windows operating system structures. These structures vary across different versions of Windows; the profile (<kbd class="calibre42">--profile</kbd>) tells Volatility which data structures, symbols, and algorithms to use.</div>
<p class="calibre2">The help option, <kbd class="calibre13">-h (--help)</kbd>, which that you saw previously, displays help that applies to all of the Volatility plugins. You can use the same <kbd class="calibre13">-h (--help)</kbd> option to determine various options and arguments supported by a plugin. To do that, just type <kbd class="calibre13">-h (--help)</kbd> next to the plugin name. The following command displays the help options for the <kbd class="calibre13">pslist</kbd> plugin:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f mem_image.raw --profile=Win7SP1x86 pslist -h</strong></pre>
<p class="calibre2">At this point, you should have an understanding of how to run <em class="calibre17">Volatility</em> plugins on an acquired memory image and how to determine various options supported by a plugin. In the following sections, you will learn about the different plugins and how to use them to extract forensic artifacts from the memory image.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4. Enumerating Processes</h1>
                
            
            <article>
                
<p class="calibre2">When you are investigating a memory image, you will mainly focus on identifying any suspicious process running on the system. There are various plugins in Volatility that allow you to enumerate processes. Volatility's <kbd class="calibre13">pslist</kbd> plugin lists the processes from the memory image, similar to how <em class="calibre17">task manager</em> lists the process on a live system. In the following output, running the <kbd class="calibre13">pslist</kbd> plugin against a memory image infected with a malware sample (<em class="calibre17">Perseus</em>) shows two suspicious processes: <kbd class="calibre13">svchost..exe</kbd> <em class="calibre17">(</em><kbd class="calibre13"><span><span>p</span></span>id 3832</kbd><em class="calibre17">)</em> and <kbd class="calibre13">suchost..exe</kbd> ( <kbd class="calibre13">pid 3924</kbd>). The reason why these two processes are suspicious is that the names of these processes have an additional <em class="calibre17">dot</em> character before the <kbd class="calibre13">.exe</kbd> extension (which is abnormal). On a clean system, you will find multiple instances of <kbd class="calibre13">svchost.exe</kbd> processes running. By creating a process such as <kbd class="calibre13">svchost..exe</kbd> and <kbd class="calibre13">suchost..exe</kbd>, the attacker is trying to blend in by making these processes look similar to the legitimate  <kbd class="calibre13">svchost.exe</kbd> <span class="calibre7">process:</span></p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f perseus.vmem --profile=Win7SP1x86 pslist</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V)  Name        PID  PPID  Thds Hnds Sess Wow64   Start <br class="title-page-name"/>---------- ----------- ---- ----- ---- ---- ---- ----- -------------------<br class="title-page-name"/>0x84f4a8e8 System          4    0   88  475 ----   0   2016-09-23 09:21:47<br class="title-page-name"/>0x8637b020 smss.exe      272    4    2   29 ----   0   2016-09-23 09:21:47<br class="title-page-name"/>0x86c19310 csrss.exe     356  340    8  637    0   0   2016-09-23 09:21:49<br class="title-page-name"/>0x86c13458 wininit.exe   396  340    3   75    0   0   2016-09-23 09:21:49<br class="title-page-name"/>0x86e84a08 csrss.exe     404  388    9  191    1   0   2016-09-23 09:21:49<br class="title-page-name"/>0x87684030 winlogon.exe  452  388    4  108    1   0   2016-09-23 09:21:49<br class="title-page-name"/>0x86284228 services.exe  496  396   11  242    0   0   2016-09-23 09:21:49<br class="title-page-name"/>0x876ab030 lsass.exe     504  396    9  737    0   0   2016-09-23 09:21:49<br class="title-page-name"/>0x876d1a70 svchost.exe   620  496   12  353    0   0   2016-09-23 09:21:49<br class="title-page-name"/>0x864d36a8 svchost.exe   708  496    6  302    0   0   2016-09-23 09:21:50<br class="title-page-name"/>0x86b777c8 svchost.exe   760  496   24  570    0   0   2016-09-23 09:21:50<br class="title-page-name"/>0x8772a030 svchost.exe   852  496   28  513    0   0   2016-09-23 09:21:50<br class="title-page-name"/>0x87741030 svchost.exe   920  496   46 1054    0   0   2016-09-23 09:21:50<br class="title-page-name"/>0x877ce3c0 spoolsv.exe  1272  496   15  338    0   0   2016-09-23 09:21:50<br class="title-page-name"/>0x95a06a58 svchost.exe  1304  496   19  306    0   0   2016-09-23 09:21:50<br class="title-page-name"/>0x8503f0e8 <strong class="calibre1">svchost..exe 3832</strong> 3712   11  303    0   0   2016-09-23 09:24:55<br class="title-page-name"/>0x8508bb20 <strong class="calibre1">suchost..exe 3924</strong> 3832   11  252    0   0   2016-09-23 09:24:55<br class="title-page-name"/>0x861d1030 svchost.exe  3120  496   12  311    0   0   2016-09-23 09:25:39<br class="title-page-name"/><br class="title-page-name"/>[......REMOVED..............]</pre>
<p class="calibre2">Running the Volatility plugin is easy; you can run the plugin without knowing how it works. Understanding how the plugins work will help you assess the accuracy of the results, and it will also help you choose the right plugin when an attacker uses stealth techniques. The question is, how does <kbd class="calibre13">pslist</kbd> work? To understand that first, you need to understand what a process is and how <em class="calibre17">Windows kernel</em> keeps track of processes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4.1 Process Overview</h1>
                
            
            <article>
                
<p class="calibre2">A <em class="calibre17">process</em> is an object. The Windows operating system is object-based (not to be confused with the term object used in object-oriented languages). An object refers to a system resource such as a process, file, device, directory, mutant, and so on, and they are managed by a component of a kernel called <em class="calibre17">object manager</em>. To get an idea of all the object types on Windows, you can use the <em class="calibre17">WinObj tool</em> (<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/winobj" class="calibre10">https://docs.microsoft.com/en-us/sysinternals/downloads/winobj</a>). To look at the object types in <em class="calibre17">WinObj</em>, launch <em class="calibre17">WinObj</em> as an Administrator and, in the left-hand pane, click on <em class="calibre17">ObjectTypes</em>, which will display all the Windows objects.</p>
<p class="calibre2">The objects (such as processes, files, threads, and so on) are represented as structures in C. What this means is that a process object has a structure associated with it, and this structure is called the <kbd class="calibre13">_EPROCESS</kbd> structure. The <kbd class="calibre13">_EPROCESS</kbd> structure resides in the kernel memory, and the Windows kernel uses the <kbd class="calibre13">EPROCESS</kbd> structure to represent a process internally. The <kbd class="calibre13">_EPROCESS</kbd> structure contains various information related to a process such as <em class="calibre17">the name of the process</em>, <em class="calibre17">process ID</em>, <em class="calibre17">parent process ID</em>, <em class="calibre17">number of threads associated with the process</em>, <em class="calibre17">the creation time of the process,</em> and so on. Now, go back to the <kbd class="calibre13">pslist</kbd> output and note what kind of information is displayed for a particular process. For example, if you look at the second entry from the <kbd class="calibre13">pslist</kbd> output, it shows the name of the <kbd class="calibre13">smss.exe</kbd> process, its process ID <kbd class="calibre13">(272)</kbd>, parent process ID (<kbd class="calibre13">4</kbd>), and so on. As you might have guessed, the information related to a process is coming from its <kbd class="calibre13">_EPROCESS</kbd> structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4.1.1 Examining the _EPROCESS Structure</h1>
                
            
            <article>
                
<p class="calibre2">To examine the <kbd class="calibre13">_EPROCESS</kbd> structure and the kind of information it contains, you can use a kernel debugger such as <em class="calibre17">WinDbg</em>. <em class="calibre17">WinDbg</em> helps in exploring and understanding the operating system data structures, which is often an important aspect of <em class="calibre17">Memory forensics</em>. To install <em class="calibre17">WinDbg</em>, you need to install the <q class="calibre256">"Debugging Tools for Windows"</q> package, which is included as part of <em class="calibre17">Microsoft SDK</em> (refer to <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index" class="calibre10">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index</a> for different installation types). Once the installation is complete, you can find <em class="calibre17">WinDbg.exe</em> in the installation directory (in my case, it is located in <em class="calibre17">C:\Program Files (x86)\Windows Kits\8.1\Debuggers\x64</em>). Next, download the <em class="calibre17">LiveKD</em> utility from <em class="calibre17">Sysinternals</em> (<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/livekd" class="calibre10">https://docs.microsoft.com/en-us/sysinternals/downloads/livekd</a>), extract it, and then copy <em class="calibre17">livekd.exe</em> into the installation directory of <em class="calibre17">WinDbg</em>. <em class="calibre17">LiveKD</em> enables you to perform local kernel debugging on a live system. To launch <em class="calibre17">WinDbg</em> via <em class="calibre17">livekd</em>, open Command Prompt (as <em class="calibre17">Administrator</em>), navigate to the <em class="calibre17">WinDbg installation directory,</em> and run <kbd class="calibre13">livekd</kbd> with the <kbd class="calibre13">-w</kbd> switch, as shown here. You can also add the <em class="calibre17">Windbg</em> installation directory to the path environment variable so that you can launch <em class="calibre17">LiveKD</em> from any path:</p>
<pre class="calibre18">C:\Program Files (x86)\Windows Kits\8.1\Debuggers\x64&gt;<strong class="calibre1">livekd -w</strong></pre>
<p class="calibre2">The <kbd class="calibre13">livekd -w</kbd> command automatically launches <kbd class="calibre13">Windbg</kbd>, loads the symbols, and presents you with a <kbd class="calibre13">kd&gt;</kbd> prompt that's ready to accept commands, as shown in the following screenshot. To explore the data structures (such as <kbd class="calibre13">_EPROCESS</kbd>), you will type the appropriate command into the Command Prompt (next to <kbd class="calibre13">kd&gt;</kbd>):</p>
<div class="cdpaligncenter"><img src="../images/00333.jpeg" class="calibre257"/></div>
<p class="calibre2">Now, going back to our discussion of the <kbd class="calibre13">_EPROCESS</kbd> structure, to explore the <kbd class="calibre13">_EPROCESS</kbd> structure, we will use the <kbd class="calibre13">Display Type</kbd> command <kbd class="calibre13">(dt).</kbd> The <kbd class="calibre13">dt</kbd> command can be used to explore a symbol that represents a variable, a structure, or a union. In the following output, the <kbd class="calibre13">dt</kbd> command is used to display the <kbd class="calibre13">_EPROCESS</kbd> structure defined in the <kbd class="calibre13">nt</kbd> module (the name of the kernel executive). The <kbd class="calibre13">EPROCESS</kbd> structure consists of multiple fields, storing all sorts of metadata of a process. Here is what it looks like for a 64-bit Windows 7 system (some of the fields have been removed to keep it small):</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">dt nt!_EPROCESS</strong><br class="title-page-name"/>   +0x000 Pcb : _KPROCESS<br class="title-page-name"/>   +0x160 ProcessLock : _EX_PUSH_LOCK<br class="title-page-name"/>   +0x168 CreateTime : _LARGE_INTEGER<br class="title-page-name"/>   +0x170 ExitTime : _LARGE_INTEGER<br class="title-page-name"/>   +0x178 RundownProtect : _EX_RUNDOWN_REF<br class="title-page-name"/>   +0x180 UniqueProcessId : Ptr64 Void<br class="title-page-name"/>   +0x188 ActiveProcessLinks : _LIST_ENTRY<br class="title-page-name"/>   +0x198 ProcessQuotaUsage : [2] Uint8B<br class="title-page-name"/>   +0x1a8 ProcessQuotaPeak : [2] Uint8B<br class="title-page-name"/>   [REMOVED]<br class="title-page-name"/>   +0x200 ObjectTable : Ptr64 _HANDLE_TABLE<br class="title-page-name"/>   +0x208 Token : _EX_FAST_REF<br class="title-page-name"/>   +0x210 WorkingSetPage : Uint8B<br class="title-page-name"/>   +0x218 AddressCreationLock : _EX_PUSH_LOCK<br class="title-page-name"/>   [REMOVED]<br class="title-page-name"/>   +0x290 InheritedFromUniqueProcessId : Ptr64 Void<br class="title-page-name"/>   +0x298 LdtInformation : Ptr64 Void<br class="title-page-name"/>   +0x2a0 Spare : Ptr64 Void<br class="title-page-name"/>   [REMOVED]<br class="title-page-name"/>   +0x2d8 Session : Ptr64 Void<br class="title-page-name"/>   +0x2e0 ImageFileName : [15] UChar<br class="title-page-name"/>   +0x2ef PriorityClass : UChar<br class="title-page-name"/>   [REMOVED]</pre>
<p class="calibre2">The following are some of the interesting fields in the <kbd class="calibre13">_EPROCESS</kbd> structure that we will use for this discussion:</p>
<ul class="calibre11">
<li class="calibre12"><kbd class="calibre13">CreateTime</kbd>: Timestamp that indicates when the process was first started</li>
<li class="calibre12"><kbd class="calibre13">ExitTime</kbd>: Timestamp that indicates when the process exited</li>
<li class="calibre12"><kbd class="calibre13">UniqueProcessID</kbd>: An integer that references the <em class="calibre19">process ID (PID)</em> of the process</li>
<li class="calibre12"><kbd class="calibre13">ActiveProcessLinks</kbd>: A double linked list that links all the active processes running on the system</li>
<li class="calibre12"><kbd class="calibre13">InheritedFromUniqueProcessId</kbd>: An integer that specifies the PID of the parent process</li>
<li class="calibre12"><kbd class="calibre13">ImageFileName</kbd>: An array of 16 ASCII characters which store the name of the process executable</li>
</ul>
<p class="calibre2">With an understanding of how to examine the <kbd class="calibre13">_EPROCESS</kbd> structure, let's now take a look at the <kbd class="calibre13">_EPROCESS</kbd> structure of a specific process. To do that, let's first list all active processes using <em class="calibre17">WinDbg</em>. You can use the <kbd class="calibre13">!process</kbd> extension command to print metadata of a particular process or all processes. In the following command, the first argument, <kbd class="calibre13">0</kbd>, lists metadata of all the processes. You can also display the information of a single process by specifying the address of the <kbd class="calibre13">_EPROCESS</kbd> structure. The second argument indicates the level of detail:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">!process 0 0</strong><br class="title-page-name"/>**** NT ACTIVE PROCESS DUMP ****<br class="title-page-name"/>PROCESS fffffa806106cb30<br class="title-page-name"/>    SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000<br class="title-page-name"/>    DirBase: 00187000 ObjectTable: fffff8a0000016d0 HandleCount: 539.<br class="title-page-name"/>    Image: System<br class="title-page-name"/><br class="title-page-name"/>PROCESS fffffa8061d35700<br class="title-page-name"/>    SessionId: none Cid: 00fc Peb: 7fffffdb000 ParentCid: 0004<br class="title-page-name"/>    DirBase: 1faf16000 ObjectTable: fffff8a0002d26b0 HandleCount: 29.<br class="title-page-name"/>    Image: smss.exe<br class="title-page-name"/><br class="title-page-name"/>PROCESS fffffa8062583b30<br class="title-page-name"/>    SessionId: 0 Cid: 014c Peb: 7fffffdf000 ParentCid: 0144<br class="title-page-name"/>    DirBase: 1efb70000 ObjectTable: fffff8a00af33ef0 HandleCount: 453.<br class="title-page-name"/>    Image: csrss.exe<br class="title-page-name"/><br class="title-page-name"/>[REMOVED]</pre>
<div class="packt_tip">For detailed information on WinDbg commands, refer to the Debugger.chm help, which is located in the WinDbg installation folder. You can also refer to the following online resources: <a href="http://windbg.info/doc/1-common-cmds.html" class="calibre20">http://windbg.info/doc/1-common-cmds.html</a> and <a href="http://windbg.info/doc/2-windbg-a-z.html" class="calibre20">http://windbg.info/doc/2-windbg-a-z.html</a>.</div>
<p class="calibre2">From the preceding output, let's look at the second entry, which describes <kbd class="calibre13">smss.exe</kbd>. The address, <kbd class="calibre13">fffffa8061d35700</kbd>, next to the <kbd class="calibre13">PROCESS</kbd>, is the address of the <kbd class="calibre13">_EPROCESS</kbd> structure associated with this instance of <kbd class="calibre13">smss.exe.</kbd> The <kbd class="calibre13">Cid</kbd> field, which has a value of <kbd class="calibre13">00fc</kbd> (<kbd class="calibre13">252</kbd> in decimal), is the process ID, and <kbd class="calibre13">ParentCid</kbd>, which has a value of <kbd class="calibre13">0004</kbd>, represents the process ID of the parent process. You can verify this by examining the values in the fields for the <kbd class="calibre13">_EPROCESS</kbd> structure of <kbd class="calibre13">smss.exe.</kbd> You can suffix the address of the <kbd class="calibre13">_EPROCESS</kbd> structure at the end of the <kbd class="calibre13">Display Type (dt)</kbd> command, as shown in the following code. In the following output, notice the values in the fields <kbd class="calibre13">UniqueProcessId</kbd> (process ID), <kbd class="calibre13">InheritedFromUniqueProcessId</kbd> (parent process ID), and <kbd class="calibre13">ImageFileName</kbd> (process executable name). These values match with the results that you determined previously from the <kbd class="calibre13">!process 0 0</kbd>  command:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">dt nt!_EPROCESS fffffa8061d35700</strong><br class="title-page-name"/>   +0x000 Pcb : _KPROCESS<br class="title-page-name"/>   +0x160 ProcessLock : _EX_PUSH_LOCK<br class="title-page-name"/>   +0x168 CreateTime : _LARGE_INTEGER 0x01d32dde`223f3e88<br class="title-page-name"/>   +0x170 ExitTime : _LARGE_INTEGER 0x0<br class="title-page-name"/>   +0x178 RundownProtect : _EX_RUNDOWN_REF<br class="title-page-name"/>   +0x180 <strong class="calibre1">UniqueProcessId : 0x00000000`000000fc</strong> Void<br class="title-page-name"/>   +0x188 ActiveProcessLinks : _LIST_ENTRY [ 0xfffffa80`62583cb8 - 0xfffffa80`6106ccb8 ]<br class="title-page-name"/>   +0x198 ProcessQuotaUsage : [2] 0x658<br class="title-page-name"/>   [REMOVED]<br class="title-page-name"/>   +0x290 <strong class="calibre1">InheritedFromUniqueProcessId : 0x00000000`00000004</strong> Void<br class="title-page-name"/>   +0x298 LdtInformation : (null) <br class="title-page-name"/>   [REMOVED]<br class="title-page-name"/>   +0x2d8 Session : (null) <br class="title-page-name"/>   +0x2e0 <strong class="calibre1">ImageFileName : [15] "smss.exe"</strong><br class="title-page-name"/>   +0x2ef PriorityClass : 0x2 ''<br class="title-page-name"/>   [REMOVED]</pre>
<p class="calibre2">So far, we know that the operating system keeps all kinds of metadata information about a process in the <kbd class="calibre13">_EPROCESS</kbd> structure, which resides in the kernel memory. This means that if you can find the address of the <kbd class="calibre13">_EPROCESS</kbd> structure for a particular process, you can get all the information about that process. Then, the question is, how do you get information about all the processes running on the system? For that, we need to understand how active processes are tracked by the Windows operating system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4.1.2 Understanding ActiveProcessLinks</h1>
                
            
            <article>
                
<p class="calibre2">Windows uses a circular double linked list of <kbd class="calibre13">_EPROCESS</kbd> structures to keep track of all the active processes. The <kbd class="calibre13">_EPROCESS</kbd> structure contains a field called <kbd class="calibre13">ActiveProcessLinks</kbd> which is of type <kbd class="calibre13">LIST_ENTRY.</kbd> The <kbd class="calibre13">_LIST_ENTRY</kbd> is another structure that contains two members, as shown in the following code. The <kbd class="calibre13">Flink</kbd> (forward link) points to the <kbd class="calibre13">_LIST_ENTRY</kbd> of the next <kbd class="calibre13">_EPROCESS</kbd> structure, and the <kbd class="calibre13">Blink</kbd> (backward link) points to the <kbd class="calibre13">_LIST_ENTRY</kbd> of the previous <kbd class="calibre13">_EPROCESS</kbd> structure:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">dt nt!_LIST_ENTRY</strong><br class="title-page-name"/>   +0x000 Flink : Ptr64 _LIST_ENTRY<br class="title-page-name"/>   +0x008 Blink : Ptr64 _LIST_ENTRY</pre>
<p class="calibre2"><kbd class="calibre13">Flink</kbd> and <kbd class="calibre13">Blink</kbd> together create a chain of process objects; this can be visualized as follows:</p>
<div class="cdpaligncenter"><img src="../images/00334.jpeg" class="calibre258"/></div>
<p class="calibre2">A point to note is that <kbd class="calibre13">Flink</kbd> and <kbd class="calibre13">Blink</kbd> do not point to the start of the <kbd class="calibre13">_EPROCESS</kbd> structure. <kbd class="calibre13">Flink</kbd> points to the start (first byte) of the <kbd class="calibre13">_LIST_ENTRY</kbd> structure of the next <kbd class="calibre13">_EPROCESS</kbd> structure, and <kbd class="calibre13">Blink</kbd> points to the first byte of the <kbd class="calibre13">_LIST_ENTRY</kbd> structure of the previous <kbd class="calibre13">_EPROCESS</kbd> structure. The reason why this is important is that, once you find the <kbd class="calibre13">_EPROCESS</kbd> structure of a process, you can walk the doubly linked list forward (using <kbd class="calibre13">Flink)</kbd> or backward <kbd class="calibre13">(Blink)</kbd> and then subtracting an offset value to get to the start of the <kbd class="calibre13">_EPROCESS</kbd> structure of the <em class="calibre17">next</em> or the <em class="calibre17">previous</em> process. To help you understand what this means, let's look at the values of the fields <kbd class="calibre13">Flink</kbd> and <kbd class="calibre13">Blink</kbd> in the <kbd class="calibre13">_EPROCESS</kbd> structure of <kbd class="calibre13">smss.exe</kbd>:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">dt -b -v nt!_EPROCESS fffffa8061d35700</strong><br class="title-page-name"/>struct _EPROCESS, 135 elements, 0x4d0 bytes<br class="title-page-name"/>.....<br class="title-page-name"/>   +0x180 UniqueProcessId : 0x00000000`000000fc <br class="title-page-name"/>   +0x188 ActiveProcessLinks : struct _LIST_ENTRY, 2 elements, 0x10 bytes<br class="title-page-name"/> [ 0xfffffa80`62583cb8 - 0xfffffa80`6106ccb8 ]<br class="title-page-name"/>      +0x000 <strong class="calibre1">Flink : 0xfffffa80`62583cb8</strong> <br class="title-page-name"/>      +0x008 <strong class="calibre1">Blink : 0xfffffa80`6106ccb8</strong></pre>
<p class="calibre2"><kbd class="calibre13">Flink</kbd> has a value of <kbd class="calibre13">0xfffffa8062583cb8</kbd>; this is the start address of the <kbd class="calibre13">ActiveProcessLinks</kbd> (<kbd class="calibre13">Flink</kbd>) of the next <kbd class="calibre13">_EPROCESS</kbd> structure. Since <kbd class="calibre13">ActiveProcessLinks</kbd>, in our example, is at offset <kbd class="calibre13">0x188</kbd> from the start of the <kbd class="calibre13">_EPROCESS</kbd>, you can get to the beginning of the <kbd class="calibre13">_EPROCESS</kbd> structure of the <em class="calibre17">next</em> process by subtracting <kbd class="calibre13">0x188</kbd> from the <kbd class="calibre13">Flink</kbd> value. In the following output, note how by subtracting <kbd class="calibre13">0x188</kbd> we landed on the <kbd class="calibre13">_EPROCESS</kbd> structure of the next process, which is <kbd class="calibre13">csrss.exe</kbd>:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">dt nt!_EPROCESS (0xfffffa8062583cb8-0x188)</strong><br class="title-page-name"/>   +0x000 Pcb : _KPROCESS<br class="title-page-name"/>   +0x160 ProcessLock : _EX_PUSH_LOCK<br class="title-page-name"/>   [REMOVED]<br class="title-page-name"/>   +0x180 UniqueProcessId : 0x00000000`0000014c Void<br class="title-page-name"/>   +0x188 ActiveProcessLinks : _LIST_ENTRY [ 0xfffffa80`625acb68 - 0xfffffa80`61d35888 ]<br class="title-page-name"/>   +0x198 ProcessQuotaUsage : [2] 0x2c18<br class="title-page-name"/>   [REMOVED]<br class="title-page-name"/>   +0x288 Win32WindowStation : (null) <br class="title-page-name"/>   +0x290 InheritedFromUniqueProcessId : 0x00000000`00000144 Void<br class="title-page-name"/>   [REMOVED]<br class="title-page-name"/>   +0x2d8 Session : 0xfffff880`042ae000 Void<br class="title-page-name"/>   +0x2e0 <strong class="calibre1">ImageFileName : [15] "csrss.exe"</strong><br class="title-page-name"/>   +0x2ef PriorityClass : 0x2 ''</pre>
<p class="calibre2">As you can see, by walking the doubly linked list, it is possible to list the information about all the active processes running on the system. On a live system, tools such as <em class="calibre17">task manager</em> or <em class="calibre17">Process Explorer</em> make use of API functions, which ultimately rely on finding and walking the same doubly linked list of <kbd class="calibre13">_EPROCESS</kbd> structures that exist in kernel memory. The <kbd class="calibre13">pslist</kbd> plugin also incorporates the logic of finding and walking the same doubly linked list of <kbd class="calibre13">_EPROCESS</kbd> structures from the memory image. To do that, the <kbd class="calibre13">pslist</kbd> plugin finds a symbol named <kbd class="calibre13">_PsActiveProcessHead</kbd>, which is defined in <kbd class="calibre13">ntoskrnl.exe</kbd> (or <kbd class="calibre13">ntkrnlpa.exe</kbd>). This symbol points to the beginning of the doubly linked list of <kbd class="calibre13">_EPROCESS</kbd> structures; the <kbd class="calibre13">pslist</kbd> then walks the doubly linked list of the <kbd class="calibre13">_EPROCESS</kbd> structures to enumerate all the running processes.</p>
<div class="packt_infobox">For detailed information on the workings and the logic used by the Volatility plugins covered in this book, refer to <q class="calibre259">The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory</q> by Michael Hale Ligh, Andrew Case, Jamie Levy, and Aaron Walters.</div>
<p class="calibre2">As mentioned earlier, a plugin such as <kbd class="calibre13">pslist</kbd> supports multiple options and arguments; this can be displayed by typing <kbd class="calibre13">-h (--help)</kbd> next to the plugin's name. One of the <kbd class="calibre13">pslist</kbd> options is <kbd class="calibre13">--output-file</kbd>. You can use this option to redirect the <kbd class="calibre13">pslist</kbd> output to the file, as shown here:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f perseus.vmem --profile=Win7SP1x86 pslist --output-file=pslist.txt</strong></pre>
<p class="calibre2">Another option is <kbd class="calibre13">-p (--pid)</kbd>. Using this option, you can determine the information of a specific process if you know its <strong class="calibre5">process ID</strong> (<strong class="calibre5">PID</strong>):</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f perseus.vmem --profile=Win7SP1x86 pslist -p 3832</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V) Name          PID  PPID Thds Hnds Wow64 Start<br class="title-page-name"/>---------- ------------ ---- ---- ---- ---- ----- -------------------<br class="title-page-name"/>0x8503f0e8 svchost..exe 3832 3712  11   303   0   2016-09-23 09:24:55</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4.2 Listing Processes Using psscan</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre13">psscan</kbd> is another Volatility plugin that lists the processes running on the system. Unlike <kbd class="calibre13">pslist</kbd>, <kbd class="calibre13">psscan</kbd> does not walk the doubly linked list of <kbd class="calibre13">_EPROCESS</kbd> objects. Instead, it scans the physical memory for the signature of the process objects. In other words, <kbd class="calibre13">psscan</kbd> uses a different approach to list the processes as compared to the <kbd class="calibre13">pslist</kbd> plugin. You might be thinking, what is the need for the <kbd class="calibre13">psscan</kbd> plugin when the <kbd class="calibre13">pslist</kbd> plugin can do the same thing? The answer lies in the technique used by <kbd class="calibre13">psscan</kbd>. Due to the approach it uses, it can detect terminated processes and also the hidden processes. An attacker can hide a process to prevent a forensic analyst from spotting the malicious process during live forensics. Now, the question is, how can an attacker hide a process? To understand that, you need to understand an attack technique known as <em class="calibre17">DKOM (Direct Kernel Object Manipulation)</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4.2.1 Direct Kernel Object Manipulation (DKOM)</h1>
                
            
            <article>
                
<p class="calibre2"><em class="calibre17">DKOM</em> is a technique that involves modifying the kernel data structures. Using DKOM, it is possible to hide a process or a driver. To hide a process, an attacker finds the <kbd class="calibre13">_EPROCESS</kbd> structure of the malicious process he/she wants to hide and modifies the <kbd class="calibre13">ActiveProcessLinks</kbd> field. In particular, the <kbd class="calibre13">Flink</kbd> of the previous <kbd class="calibre13">_EPROCESS</kbd> block is made to point to the <kbd class="calibre13">Flink</kbd> of the following <kbd class="calibre13">_EPROCESS</kbd> block, and the <kbd class="calibre13">Blink</kbd> of the following <kbd class="calibre13">_EPROCESS</kbd> block is set to point to the previous <kbd class="calibre13">_EPROCESS</kbd> block's <kbd class="calibre13">Flink.</kbd> As a result of this, the <kbd class="calibre13">_EPROCESS</kbd> block associated with the malware process is unlinked from the doubly linked list (as shown here):</p>
<div class="cdpaligncenter"><img src="../images/00335.jpeg" class="calibre260"/></div>
<p class="calibre2">By unlinking a process, an attacker can hide the malicious process from the live forensic tools that rely on walking the doubly linked list to enumerate the active processes. As you might have guessed, this technique also hides the malicious process from the <kbd class="calibre13">pslist</kbd> plugin (which also relies on walking the doubly linked list). The following is the <kbd class="calibre13">pslist</kbd> and <kbd class="calibre13">psscan</kbd> output from a system infected with the <em class="calibre17">prolaco</em> rootkit, which performs <em class="calibre17">DKOM</em> to hide a process. For the sake of brevity, some of the entries are truncated from the following output. When you compare the output from <kbd class="calibre13">pslist</kbd> and <kbd class="calibre13">psscan</kbd>, you will notice an additional process called <kbd class="calibre13">nvid.exe</kbd> (<kbd class="calibre13">pid 1700</kbd>) in the <kbd class="calibre13">psscan</kbd> output that's not present in the <kbd class="calibre13">pslist</kbd>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f infected.vmem --profile=WinXPSP3x86 pslist</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V)  Name         PID  PPID Thds Hnds Sess Wow64  Start<br class="title-page-name"/>--------- ------------- ---- ---- ---- ---- ---- ----- -------------------<br class="title-page-name"/>0x819cc830 System          4    0 56   256  ----    0<br class="title-page-name"/>0x814d8380 smss.exe      380    4  3    19  ----    0  2014-06-11 14:49:36<br class="title-page-name"/>0x818a1868 csrss.exe     632  380 11   423     0    0  2014-06-11 14:49:36<br class="title-page-name"/>0x813dc1a8 winlogon.exe  656  380 24   524     0    0  2014-06-11 14:49:37<br class="title-page-name"/>0x81659020 services.exe  700  656 15   267     0    0  2014-06-11 14:49:37<br class="title-page-name"/>0x81657910 lsass.exe     712  656 24   355     0    0  2014-06-11 14:49:37<br class="title-page-name"/>0x813d7688 svchost.exe   884  700 21   199     0    0  2014-06-11 14:49:37<br class="title-page-name"/>0x818f5d10 svchost.exe   964  700 10   235     0    0  2014-06-11 14:49:38<br class="title-page-name"/>0x813cf5a0 svchost.exe  1052  700 84  1467     0    0  2014-06-11 14:49:38<br class="title-page-name"/>0x8150b020 svchost.exe  1184  700 16   211     0    0  2014-06-11 14:49:40<br class="title-page-name"/>0x81506c68 spoolsv.exe  1388  700 15   131     0    0  2014-06-11 14:49:40<br class="title-page-name"/>0x81387710 explorer.exe 1456 1252 16   459     0    0  2014-06-11 14:49:55</pre>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f infected.vmem --profile=WinXPSP3x86 psscan</strong><br class="title-page-name"/> Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/> Offset(P)          Name         PID  PPID  PDB       Time created<br class="title-page-name"/> ------------------ ------------ ---- ---- ---------- -------------------<br class="title-page-name"/> 0x0000000001587710 explorer.exe 1456 1252 0x08440260 2014-06-11 14:49:55<br class="title-page-name"/> 0x00000000015cf5a0 svchost.exe  1052  700 0x08440120 2014-06-11 14:49:38<br class="title-page-name"/> 0x00000000015d7688 svchost.exe   884  700 0x084400e0 2014-06-11 14:49:37<br class="title-page-name"/> 0x00000000015dc1a8 winlogon.exe  656  380 0x08440060 2014-06-11 14:49:37<br class="title-page-name"/> 0x00000000016ba360<strong class="calibre1"> nvid.exe     1700</strong> 1660 0x08440320 2014-10-17 09:16:10<br class="title-page-name"/> 0x00000000016d8380 smss.exe      380    4 0x08440020 2014-06-11 14:49:36<br class="title-page-name"/> 0x0000000001706c68 spoolsv.exe  1388  700 0x084401a0 2014-06-11 14:49:40<br class="title-page-name"/> 0x000000000170b020 svchost.exe  1184  700 0x08440160 2014-06-11 14:49:40<br class="title-page-name"/> 0x0000000001857910 lsass.exe     712  656 0x084400a0 2014-06-11 14:49:37<br class="title-page-name"/> 0x0000000001859020 services.exe  700  656 0x08440080 2014-06-11 14:49:37<br class="title-page-name"/> 0x0000000001aa1868 csrss.exe     632  380 0x08440040 2014-06-11 14:49:36<br class="title-page-name"/> 0x0000000001af5d10 svchost.exe   964  700 0x08440100 2014-06-11 14:49:38<br class="title-page-name"/> 0x0000000001bcc830 System          4    0 0x00319000</pre>
<p class="calibre2">As mentioned earlier, the reason <kbd class="calibre13">psscan</kbd> detects the hidden process is that it uses a different technique to list the processes, called <em class="calibre17">pool tag scanning</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4.2.2 Understanding Pool Tag Scanning</h1>
                
            
            <article>
                
<p class="calibre2">If you recall, I previously referred to system resources such as processes, files, threads, and so on, as objects (or executive objects). The executive objects are managed by a component of a kernel called the <em class="calibre17">object manager</em>. Every executive object has a structure associated with it (such as <kbd class="calibre13">_EPROCESS</kbd> for process object). The executive object structure is preceded by a <kbd class="calibre13">_OBJECT_HEADER</kbd> structure, which contains information about an object's type and some reference counters. The <kbd class="calibre13">_OBJECT_HEADER</kbd> is then preceded by zero or more optional headers. In other words, you can think of an object as the combination of executive object structure, the object header, and the optional headers, as shown in the following screenshot:</p>
<div class="cdpaligncenter"><img src="../images/00336.jpeg" class="calibre261"/></div>
<p class="calibre2">To store an object, memory is needed, and this memory is allocated by the Windows memory manager from kernel pools. A kernel pool is a range of memory that can be divided into smaller blocks for storing data such as objects. The pool is divided into a <em class="calibre17">paged pool</em> (whose content may be swapped to disk) and a <em class="calibre17">non-paged pool</em> (whose content permanently resides in memory). The objects (such as process and threads) are kept in a non-paged pool in the kernel, which means they will always reside in the physical memory.</p>
<p class="calibre2">When the Windows kernel receives the request to create an object (possibly due to API calls made by processes such as <kbd class="calibre13">CreateProcess</kbd> or <kbd class="calibre13">CreateFile</kbd>), memory is allocated for the object either from the paged pool or non-paged pool (depending on the object type). This allocation is tagged by prepending a <kbd class="calibre13">_POOL_HEADER</kbd> structure to the object, so that in memory, each object will have a predictable structure, similar to the ones shown in the following screenshot. The <kbd class="calibre13">_POOL_HEADER</kbd> structure includes a field named <kbd class="calibre13">PoolTag</kbd> that contains a four-byte tag (referred to as a <em class="calibre17">pool tag</em>). This <em class="calibre17">pool tag</em> can be used to identify an object. For the <em class="calibre17">process object</em>, the tag is <kbd class="calibre13">Proc</kbd> and for the <em class="calibre17">File object</em>, the tag is <kbd class="calibre13">File</kbd>, and so on. The <kbd class="calibre13"><span>_POOL_HEADER</span></kbd>  structure also contains fields that tell the <em class="calibre17">size of the allocation</em> and the type of memory (<em class="calibre17">paged</em> or <em class="calibre17">non-paged pool</em>) it describes:</p>
<div class="cdpaligncenter"><img src="../images/00337.jpeg" class="calibre262"/></div>
<p class="calibre2">You can think of all the process objects residing in the non-paged pool of kernel memory (which ultimately maps to physical memory) as marked with a tag, <kbd class="calibre13">Proc</kbd>. It is this tag that the Volatility's <kbd class="calibre13">psscan</kbd> uses as the starting point to identify the process object. In particular, it scans the physical memory for the <kbd class="calibre13">Proc</kbd> tag to identify the pool tag allocation associated with the <em class="calibre17">process object</em>, and it further confirms it by using a more robust signature and heuristics. Once the <kbd class="calibre13">psscan</kbd> finds the process object, it extracts the necessary information from its <kbd class="calibre13">_EPROCESS</kbd> structure. The <kbd class="calibre13">psscan</kbd> repeats this process until it finds all the process objects. In fact, many volatility plugins rely on <em class="calibre17">pool tag scanning</em> to identify and extract information from the memory image.</p>
<p class="calibre2">The <kbd class="calibre13">psscan</kbd> plugin not only detects the hidden process, because of the approach it uses, but it can also detect terminated processes. When an object is destroyed (such as when a process is terminated), the memory allocation containing that object is released back to the kernel pool, but the content in the memory is not immediately overwritten, which means the process object can still be in the memory, unless that memory is allocated for a different purpose. If the memory containing the terminated process object is not overwritten, then <kbd class="calibre13">psscan</kbd> can detect the terminated process.</p>
<div class="packt_infobox">For detailed information on pool tag scanning, refer to the paper <em class="calibre22">Searching for Processes and Threads in Microsoft Windows Memory Dumps </em>by Andreas Schuster, or read the book <em class="calibre22">The Art of Memory Forensics</em>.</div>
<p class="calibre2">At this point, you should have an understanding of how Volatility plugins work; most plugins use similar logic. To summarize, critical information exists in the data structures maintained by the kernel. The plugins rely on finding and extracting information from these data structures. The approach for finding and extracting forensic artifacts varies; some plugins rely on walking the doubly linked list (like <kbd class="calibre13">pslist</kbd>), and some use the pool tag scanning technique (such as <kbd class="calibre13">psscan</kbd>) to extract relevant information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4.3 Determining Process Relationships</h1>
                
            
            <article>
                
<p class="calibre2">When examining processes, it can be useful to determine the parent/child relationships between the processes. During malware investigation, this will help you understand which other processes are related to the malicious process. The <kbd class="calibre13">pstree</kbd> plugin displays the parent-child process relationships by using the output from the <kbd class="calibre13">pslist</kbd> and formatting it in a tree view. In the following example, running the <kbd class="calibre13">pstree</kbd> plugin against an infected memory image displays a process relationship; a child process is indented to the right and prepended with periods. From the output, you can see that <kbd class="calibre13">OUTLOOK.EXE</kbd> was started by the <kbd class="calibre13">explorer.exe</kbd> process. This is normal because whenever you launch an application by double-clicking, it is the explorer that launches the application. <kbd class="calibre13">OUTLOOK.EXE</kbd> <kbd class="calibre13">(pid 4068)</kbd> launched <kbd class="calibre13">EXCEL.EXE (pid 1124)</kbd>, which in turn invoked <kbd class="calibre13">cmd.exe (pid 4056)</kbd> to execute the malware process <kbd class="calibre13">doc6.exe (pid 2308)</kbd>. By looking at the events, you can assume that the user opened a malicious Excel document sent via email, which probably exploited a vulnerability or executed a macro code to drop the malware and executed it via <kbd class="calibre13">cmd.exe</kbd>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f infected.raw --profile=Win7SP1x86 pstree</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Name                      Pid  PPid Thds Hnds Time<br class="title-page-name"/>------------------------ ---- ----- ---- ---- -------------------<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>0x86eb4780:explorer.exe   1608 1572  35   936 2016-05-11 12:15:10<br class="title-page-name"/>. 0x86eef030:vmtoolsd.exe 1708 1608   5   160 2016-05-11 12:15:10<br class="title-page-name"/>. 0x851ee2b8:<strong class="calibre1">OUTLOOK.EXE</strong>  4068 1608  17  1433 2018-04-15 02:14:23<br class="title-page-name"/>.. 0x8580a3f0:<strong class="calibre1">EXCEL.EXE</strong>   1124 4068  11   377 2018-04-15 02:14:35<br class="title-page-name"/>... 0x869d1030:<strong class="calibre1">cmd.exe</strong>    4056 1124   5   117 2018-04-15 02:14:41<br class="title-page-name"/>.... 0x85b02d40:<strong class="calibre1">doc6.exe</strong>  2308 4056   1    50 2018-04-15 02:14:59</pre>
<p class="calibre2">Since the <kbd class="calibre13">pstree</kbd> plugin relies on the <kbd class="calibre13">pslist</kbd> plugin, it cannot list the hidden or terminated processes. Another method to determine the process relationship is to use the <kbd class="calibre13">psscan</kbd> plugin to generate a visual representation of the parent/child relationships. The following <kbd class="calibre13">psscan</kbd> command prints the output in the <em class="calibre17">dot</em> format, which can then be opened with Graph Visualization Software such as <em class="calibre17">Graphviz</em> (<a href="https://www.graphviz.org/" class="calibre10">https://www.graphviz.org/</a>) or <em class="calibre17">XDot</em> (which can be installed on a Linux system using <kbd class="calibre13">sudo apt install xdot</kbd>):</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f infected.vmem --profile=Win7SP1x86 psscan --output=dot --output-file=infected.dot</strong></pre>
<p class="calibre2">Opening the <em class="calibre17">infected.dot</em> file with XDot displays the relationship between the processes discussed previously:</p>
<div class="cdpaligncenter"><img src="../images/00338.jpeg" class="calibre263"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4.4 Process Listing Using psxview</h1>
                
            
            <article>
                
<p class="calibre2">Previously, you saw how process listing could be manipulated to hide a process; you also understood how <kbd class="calibre13">psscan</kbd> uses pool tag scanning to detect the hidden process. It turns out that <kbd class="calibre13">_POOL_HEADER</kbd> (which <kbd class="calibre13">psscan</kbd> relies on) is only used for debugging purposes, and it does not affect the stability of the operating system. This means an attacker can install a kernel driver to run in the kernel space and modify the pool tags or any other field in the <kbd class="calibre13">_POOL_HEADER.</kbd> By modifying the pool tag, an attacker can prevent the plugins that rely on <em class="calibre17">pool tag scanning</em> from working properly. In other words, by modifying the pool tag, it is possible to hide the process from the <kbd class="calibre13">psscan</kbd>. To overcome this problem, The <kbd class="calibre13">psxview</kbd> plugin relies on extracting process information from different sources. It enumerates the process in seven different ways. By comparing the output from different sources, it is possible to detect discrepancies caused by the malware. In the following screenshot, <kbd class="calibre13">psxview</kbd> enumerates the processes using seven different techniques. Each process' information is displayed as a single row, and the techniques it uses are displayed as columns containing <kbd class="calibre13">True</kbd> or <kbd class="calibre13">False</kbd>. A <kbd class="calibre13">False</kbd> value under a particular column indicates that the process was not found using the respective method. In the following output, <kbd class="calibre13">psxview</kbd> detected the hidden process <kbd class="calibre13">nvid.exe</kbd> <kbd class="calibre13">(pid 1700)</kbd> using all the methods except the <kbd class="calibre13">pslist</kbd> method:</p>
<div class="cdpaligncenter"><img src="../images/00339.jpeg" class="calibre264"/></div>
<p class="calibre2">In the preceding screenshot, you will notice false values for a few processes. For example, the <kbd class="calibre13">cmd.exe</kbd> process is not present in any of the methods except the <kbd class="calibre13">psscan</kbd> method. You might think that <kbd class="calibre13">cmd.exe</kbd> is hidden, but that is not true; the reason why you see <kbd class="calibre13">False</kbd> is that <kbd class="calibre13">cmd.exe</kbd> is terminated (you can tell that from the <kbd class="calibre13">ExitTime</kbd> column). As a result, all other techniques were not able to find it where <kbd class="calibre13">psscan</kbd> was able to find it, because pool tag scanning can detect terminated process. In other words, a <kbd class="calibre13">False</kbd> value in a column does not necessarily mean that the process is hidden from that method; it can also mean that it is expected (depending on how and from where that method is getting the process information). To know whether it is expected or not, you can use the <kbd class="calibre13">-R (--apply-rules)</kbd> option as follows. In the following screenshot, notice how the <kbd class="calibre13">False</kbd> values are replaced with <kbd class="calibre13">Okay</kbd><strong class="calibre5">.</strong> An <kbd class="calibre13">Okay</kbd> means <kbd class="calibre13">False</kbd>, but it is an expected behavior. After running the <kbd class="calibre13">psxview</kbd> plugin with <kbd class="calibre13">-R</kbd> (<kbd class="calibre13">--apply-rules</kbd>), if you still see a <kbd class="calibre13">False</kbd> value (such as <kbd class="calibre13">nvid.exe</kbd> with <kbd class="calibre13">pid 1700</kbd> in the following screenshot), then it is a strong indication that the process is hidden from that method:</p>
<div class="cdpaligncenter"><img src="../images/00340.jpeg" class="calibre265"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">5. Listing Process Handles</h1>
                
            
            <article>
                
<p class="calibre2">During your investigation, once you pin down a malicious process, you may want to know which objects (such as processes, files, registry keys, and so on) the process is accessing. This will give you an idea of the components associated with the malware and an insight into their operation, for example, a keylogger may be accessing a log file to log captured keystrokes, or malware might have an open handle to the configuration file.</p>
<p class="calibre2">To access an object, a process needs to first open a handle to that object by calling an API such as <kbd class="calibre13">CreateFile</kbd> or <kbd class="calibre13">CreateMutex.</kbd> Once it opens a handle to an object, it uses that handle to perform subsequent operations such as writing to a file or reading from a file. A handle is an indirect reference to an object; think of a handle as something that represents an object (the handle is not the object itself). The objects reside in the kernel memory, whereas the process runs in the user space, because of which a process cannot access the objects directly, hence it uses a handle which represents that object.</p>
<p class="calibre2">Each process is given a private handle table that resides in the kernel memory. This table contains all the kernel objects such as files, processes, and network sockets that are associated with the process. The question is, how does this table get populated? When the kernel gets the request from a process to create an object (via an API such as <kbd class="calibre13">CreateFile</kbd>), the object is created in the <em class="calibre17">kernel memory.</em> The pointer to the object is placed in the first available slot in the process handle table, and the corresponding index value is returned to the process. The index value is the handle which represents the object, and the handle is used by the process to perform subsequent operations.</p>
<p class="calibre2">On a live system, you can inspect the kernel objects accessed by a particular process using the <em class="calibre17">Process Hacker</em> tool. To do that, launch Process Hacker as an <em class="calibre17">Administrator</em><strong class="calibre5">,</strong> right-click on any process, and then select the <em class="calibre17">Handles</em> tab. The following screenshot shows the process handles of the <em class="calibre17">csrss.exe</em> process. <em class="calibre17">csrss.exe</em> is a legitimate operating system process that plays a role in the creation of every process and thread. For this reason, you will see <em class="calibre17">csrss.exe</em> having open handles to most of the processes (except itself and its parent processes) running on the system. In the following screenshot, the third column is the <em class="calibre17">handle value</em>, and the fourth column shows the <em class="calibre17">address of the object</em> in the kernel memory. For example, the first process, <em class="calibre17">wininit.exe</em>, is located at address <kbd class="calibre13">0x8705c410</kbd> (the address of its <kbd class="calibre13">_EPROCESS</kbd> structure) in the kernel memory, and the handle value representing this object is <kbd class="calibre13">0x60</kbd>:</p>
<div class="cdpaligncenter"><img src="../images/00341.jpeg" class="calibre266"/></div>
<div class="packt_infobox">One of the methods used by the <kbd class="calibre42">psxview</kbd> plugin relies on walking the <em class="calibre22">csrss.exe</em> process's handle table to identify the process objects. If there are multiples instances of <em class="calibre22">csrss.exe</em>, then <kbd class="calibre42">psxview</kbd> parses the handle table of all <em class="calibre22">csrss.exe</em> instances to list the running processes, except the <em class="calibre22">csrss.exe</em> process and its parent processes (the <em class="calibre22">smss.exe</em> and <em class="calibre22">system</em> processes).</div>
<p class="calibre2">From the memory image, you can get a list of all the kernel objects that were accessed by a process using the <kbd class="calibre13">handles</kbd> plugin. The following screenshot displays the handles of the process with <kbd class="calibre13">pid 356</kbd>. If you run the <kbd class="calibre13">handles</kbd> plugin without <kbd class="calibre13">-p</kbd> options, it will display handle information for all the processes:</p>
<div class="cdpaligncenter"><img src="../images/00342.jpeg" class="calibre267"/></div>
<p class="calibre2">You can also filter the results for a specific object type (<kbd class="calibre13">File</kbd>, <kbd class="calibre13">Key</kbd>, <kbd class="calibre13">Process</kbd>, <kbd class="calibre13">Mutant</kbd>, and so on) using the <kbd class="calibre13">-t</kbd> option. In the following example, the <kbd class="calibre13">handles</kbd> plugin was run against the memory image infected with <em class="calibre17">Xtreme RAT</em>. The handles <kbd class="calibre13">plugin</kbd> was used to list the mutexes opened by the malicious process (with <kbd class="calibre13">pid 1772</kbd>). From the following output, you can see that <em class="calibre17">Xtreme RAT</em> creates a mutex called <kbd class="calibre13">oZ694XMhk6yxgbTA0</kbd> to mark its presence on the system. A mutex such as the one created by <em class="calibre17">Xtreme RAT</em> can make a good host-based indicator to use in host-based monitoring:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f xrat.vmem --profile=Win7SP1x86 handles -p 1772 -t Mutant</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V)  Pid  Handle Access   Type    Details<br class="title-page-name"/>---------- ---- ------ -------- ------ -----------------------------  <br class="title-page-name"/>0x86f0a450 1772 0x104  0x1f0001 Mutant <strong class="calibre1">oZ694XMhk6yxgbTA0</strong><br class="title-page-name"/>0x86f3ca58 1772 0x208  0x1f0001 Mutant _!MSFTHISTORY!_<br class="title-page-name"/>0x863ef410 1772 0x280  0x1f0001 Mutant WininetStartupMutex<br class="title-page-name"/>0x86d50ca8 1772 0x29c  0x1f0001 Mutant WininetConnectionMutex<br class="title-page-name"/>0x8510b8f0 1772 0x2a0  0x1f0001 Mutant WininetProxyRegistryMutex<br class="title-page-name"/>0x861e1720 1772 0x2a8  0x100000 Mutant RasPbFile<br class="title-page-name"/>0x86eec520 1772 0x364  0x1f0001 Mutant ZonesCounterMutex<br class="title-page-name"/>0x86eedb18 1772 0x374  0x1f0001 Mutant ZoneAttributeCacheCounterMutex</pre>
<p class="calibre2">In the following example of a memory image that's been infected with the <em class="calibre17">TDL3 rootkit</em>, the <kbd class="calibre13">svchost.exe</kbd> process <kbd class="calibre13">(pid 880)</kbd> has open file handles to the malicious DLL and the kernel driver associated with the rootkit:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f tdl3.vmem handles -p 880 -t File</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V)  Pid Handle Access   Type  Details<br class="title-page-name"/>---------- --- ------ -------- ---- ----------------------------<br class="title-page-name"/>0x89406028 880 0x50   0x100001 File  \Device\KsecDD<br class="title-page-name"/>0x895fdd18 880 0x100  0x100000 File  \Device\Dfs<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>0x8927b9b8 880 0x344  0x120089 File [REMOVED]\system32\<strong class="calibre1">TDSSoiqh.dll</strong><br class="title-page-name"/>0x89285ef8 880 0x34c  0x120089 File [REMOVED]\system32\drivers\<strong class="calibre1">TDSSpqxt.sys</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6. Listing DLLs</h1>
                
            
            <article>
                
<p class="calibre2">Throughout this book, you have seen examples of malware using DLL to implement the malicious functionality. Therefore, in addition to investigating processes, you may also want to examine the list of loaded libraries. To list the loaded modules (executable and DLLs), you can use Volatility's <kbd class="calibre13">dlllist</kbd> plugin. The <kbd class="calibre13">dlllist</kbd> plugin also displays the full path associated with a process. Let's take an example of the malware named <em class="calibre17">Ghost RAT</em>. It implements the malicious functionality as the <em class="calibre17">Service DLL</em>, and as a result, the malicious DLL gets loaded by the <kbd class="calibre13">svchost.exe</kbd> process (for more information on Service DLL, refer to the<em class="calibre17"> Service</em> section in <a target="_blank" href="part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 7</a>, <em class="calibre17">Malware Functionalities and Persistence</em>). The following is the output from the <kbd class="calibre13">dlllist</kbd>, where you can see a suspicious module with a non-standard extension <kbd class="calibre13">(.ddf)</kbd> loaded by the <kbd class="calibre13">svchost.exe</kbd> process (<kbd class="calibre13">pid 800</kbd>). The first column, <kbd class="calibre13">Base</kbd>, specifies the base address, that is, the address in the memory where the module is loaded:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f ghost.vmem --profile=Win7SP1x86 dlllist -p 880</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>******************************************************************<br class="title-page-name"/>svchost.exe pid: 880<br class="title-page-name"/>Command line : C:\Windows\system32\svchost.exe -k netsvcs<br class="title-page-name"/><br class="title-page-name"/>Base       Size     LoadCount Path<br class="title-page-name"/>---------- -------- --------- --------------------------------<br class="title-page-name"/>0x00f30000 0x8000   0xffff    C:\Windows\system32\svchost.exe<br class="title-page-name"/>0x76f60000 0x13c000 0xffff    C:\Windows\SYSTEM32\ntdll.dll<br class="title-page-name"/>0x75530000 0xd4000  0xffff    C:\Windows\system32\kernel32.dll<br class="title-page-name"/>0x75160000 0x4a000  0xffff    C:\Windows\system32\KERNELBASE.dll<br class="title-page-name"/>0x75480000 0xac000  0xffff    C:\Windows\system32\msvcrt.dll<br class="title-page-name"/>0x77170000 0x19000  0xffff    C:\Windows\SYSTEM32\sechost.dll<br class="title-page-name"/>0x76700000 0x15c000 0x62      C:\Windows\system32\ole32.dll<br class="title-page-name"/>0x76c30000 0x4e000  0x19c     C:\Windows\system32\GDI32.dll<br class="title-page-name"/>0x770a0000 0xc9000  0x1cd     C:\Windows\system32\USER32.dll<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>0x74fe0000 0x4b000  0xffff    C:\Windows\system32\apphelp.dll<br class="title-page-name"/>0x6bbb0000 0xf000   0x1       c:\windows\system32\appinfo.dll<br class="title-page-name"/>0x10000000 0x26000  0x1       <strong class="calibre1">c:\users\test\application data\acdsystems\acdsee\imageik.ddf</strong><br class="title-page-name"/>0x71200000 0x32000  0x3       C:\Windows\system32\WINMM.dll</pre>
<p class="calibre2">The <kbd class="calibre13">dlllist</kbd> plugin gets the information about the loaded modules from a structure named the <em class="calibre17">Process Environment Block (PEB)</em>. If you recall from <a target="_blank" href="part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 8</a>, <em class="calibre17">Code Injection and Hooking</em>, when covering the process memory components, I mentioned that the <em class="calibre17">PEB</em> structure resides in the process memory (in the user space). The PEB contains metadata information about where the process executable is loaded, its full path on the disk, and information about the loaded modules (executable and DLLs). The <kbd class="calibre13">dlllist</kbd> plugin finds the <em class="calibre17">PEB</em> structure of each process and gets the preceding information. Then, the question is, how do you find the PEB structure? The <kbd class="calibre13">_EPROCESS</kbd> structure has a field named <kbd class="calibre13">Peb</kbd> that contains the pointer to the <em class="calibre17">PEB.</em> What this means is that once the plugin finds the <kbd class="calibre13">_EPROCESS</kbd> structure, it can find the <em class="calibre17">PEB</em>. A point to remember is that <kbd class="calibre13">_EPROCESS</kbd> resides in the kernel memory (kernel space), whereas the <kbd class="calibre13">PEB</kbd> resides in the process memory (user-space).</p>
<p class="calibre2">To get the address of the <em class="calibre17">PEB</em> in a debugger, you can use the <kbd class="calibre13">!process</kbd> extension command, which shows the address of the <kbd class="calibre13">_EPROCESS</kbd> structure. It also specifies the address of the <em class="calibre17">PEB</em>. From the following output, you can see that the PEB of the <kbd class="calibre13">explorer.exe</kbd> process is at address <kbd class="calibre13">7ffd3000</kbd> in its process memory, and its <kbd class="calibre13">_EPROCESS</kbd> structure is at <kbd class="calibre13">0x877ced28</kbd> (in its kernel memory):</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">!process 0 0</strong><br class="title-page-name"/>**** NT ACTIVE PROCESS DUMP ****<br class="title-page-name"/>.........<br class="title-page-name"/>PROCESS 877cb4a8 SessionId: 1 Cid: 05f0 Peb: 7ffdd000 ParentCid: 0360<br class="title-page-name"/>    DirBase: beb47300 ObjectTable: 99e54a08 HandleCount: 70.<br class="title-page-name"/>    Image: dwm.exe<br class="title-page-name"/><strong class="calibre1">PROCESS</strong> <strong class="calibre1">877ced28</strong> SessionId: 1 Cid: 0600 <strong class="calibre1">Peb: 7ffd3000</strong> ParentCid: 05e8<br class="title-page-name"/>    DirBase: beb47320 ObjectTable: 99ee5890 HandleCount: 766.<br class="title-page-name"/>    Image: <strong class="calibre1">explorer.exe</strong></pre>
<p class="calibre2">Another method to determine the address of the PEB is to use the <kbd class="calibre13">display type (dt)</kbd> command. You can find the address of the <em class="calibre17">PEB</em> of the <kbd class="calibre13">explorer.exe</kbd> process by examining the <kbd class="calibre13">Peb</kbd> field in its <kbd class="calibre13">EPROCESS</kbd> structure, as follows:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">dt nt!_EPROCESS 877ced28</strong><br class="title-page-name"/>   [REMOVED]<br class="title-page-name"/>   +0x168 Session : 0x8f44e000 Void<br class="title-page-name"/>   +0x16c <strong class="calibre1">ImageFileName : [15] "explorer.exe"</strong><br class="title-page-name"/>   [REMOVED]<br class="title-page-name"/>   +0x1a8 <strong class="calibre1">Peb : 0x7ffd3000</strong> _PEB<br class="title-page-name"/>   +0x1ac PrefetchTrace : _EX_FAST_REF</pre>
<p class="calibre2">You now know how to find the <em class="calibre17">PEB</em>, so now, let's try to understand what kind of information <em class="calibre17">PEB</em> contains. To get the human-readable summary of the <em class="calibre17">PEB</em> for a given process, first, you need to switch to the context of the process whose <em class="calibre17">PEB</em> you want to examine. This can be done using the <kbd class="calibre13">.process</kbd> extension command. This command accepts the address of the <kbd class="calibre13">_EPROCESS</kbd> structure. The following command sets the current process context to the <kbd class="calibre13">explorer.exe</kbd> process:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">.process 877ced28</strong><br class="title-page-name"/>Implicit process is now 877ced28</pre>
<p class="calibre2">You can then use the <kbd class="calibre13">!peb</kbd> extension command followed by the address of the <em class="calibre17">PEB</em>. In the following output, some of the information is truncated for the sake of brevity. The <kbd class="calibre13">ImageBaseAddress</kbd> field specifies the address where the process executable (<kbd class="calibre13">explorer.exe</kbd>) is loaded in the memory. The <em class="calibre17">PEB</em> also contains another structure called the Ldr structure (of type <kbd class="calibre13">_PEB_LDR_DATA</kbd>), which maintains three doubly linked lists, which are <kbd class="calibre13">InLoadOrderModuleList</kbd>, <kbd class="calibre13">InMemoryOrderModuleList</kbd>, and <kbd class="calibre13">InInitializationOrderModuleList.</kbd> Each of these three doubly linked lists contains information regarding the modules (process executable and DLLs). It is possible to get information regarding the modules by walking any of these doubly linked lists. <kbd class="calibre13">InLoadOrderModuleList</kbd> organizes modules in the order in which they are loaded, <kbd class="calibre13">InMemoryOrderModuleList</kbd> organizes modules in the order in which they reside in the process memory, and <kbd class="calibre13">InInitializationOrderModuleList</kbd> organizes modules in the order in which their <kbd class="calibre13">DllMain</kbd> function was executed:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">!peb 0x7ffd3000</strong><br class="title-page-name"/>PEB at 7ffd3000<br class="title-page-name"/>    InheritedAddressSpace: No<br class="title-page-name"/>    ReadImageFileExecOptions: No<br class="title-page-name"/>    BeingDebugged: No<br class="title-page-name"/>    <strong class="calibre1">ImageBaseAddress: 000b0000</strong><br class="title-page-name"/>    Ldr 77dc8880<br class="title-page-name"/>    Ldr.Initialized: Yes<br class="title-page-name"/>    <strong class="calibre1">Ldr.InInitializationOrderModuleList</strong>: 00531f98 . 03d3b558<br class="title-page-name"/>    <strong class="calibre1">Ldr.InLoadOrderModuleList</strong>: 00531f08 . 03d3b548<br class="title-page-name"/>    <strong class="calibre1">Ldr.InMemoryOrderModuleList</strong>: 00531f10 . 03d3b550<br class="title-page-name"/>    [REMOVED]</pre>
<p class="calibre2">In other words, all the three PEB lists contain information about the loaded modules such as the base address, size, the full path associated with the module, and so on. An important point to remember is that <kbd class="calibre13">InInitializationOrderModuleList</kbd> will not contain the information about the process executable because the executable, is initialized differently as compared to the DLLs.</p>
<p class="calibre2">To help you understand better, the following diagram uses <kbd class="calibre13">Explorer.exe</kbd> as an example (the concept is similar to other processes as well). When <kbd class="calibre13">Explorer.exe</kbd> is executed, its process executable is loaded into the process memory at some address (let's say <kbd class="calibre13">0xb0000</kbd>) with <kbd class="calibre13">PAGE_EXECUTE_WRITECOPY</kbd> (<kbd class="calibre13">WCX</kbd>) protection. The associated DLLs are also loaded into the process memory. The process memory also includes the PEB structure which contains metadata information of where the <kbd class="calibre13">explorer.exe</kbd> is loaded (base address) in the memory. The <kbd class="calibre13">Ldr</kbd> structure in the PEB maintains three doubly linked lists; each element is a structure (of type <kbd class="calibre13">_LDR_DATA_TABLE_ENTRY</kbd>) that contains information (base address, full path, and so on) about the loaded modules. The <kbd class="calibre13">dlllist</kbd> plugin relies on walking the <kbd class="calibre13">InLoadOrderModuleList</kbd> to get the module's information:</p>
<div class="cdpaligncenter"><img src="../images/00343.jpeg" class="calibre41"/></div>
<p class="calibre2">The problem with getting the module information from any of these three PEB lists is that they are susceptible to <em class="calibre17">DKOM</em> attacks. All three PEB lists reside in the user space, which means an attacker can load the malicious DLL into the address space of a process and can unlink the malicious DLL from one or all PEB lists to hide from the tools which rely on walking these lists. To overcome this problem, we can use another plugin named <kbd class="calibre13">ldrmodules</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6.1 Detecting a Hidden DLL Using ldrmodules</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre13">ldrmodules</kbd> plugin compares module information from the three PEB lists (in the process memory) with the information from a data structure residing in the kernel memory known as <em class="calibre17">VADs</em> (<em class="calibre17">Virtual Address Descriptors</em>). The memory manager uses VADs to keep track of whichvirtual addresses in the process memory that are reserved (or free). The VAD is a binary tree structure that stores information about the virtually contiguous memory regions in the process memory. For each process, the memory manager maintains a set of VADs and each VAD node describes a virtually contiguous memory region. If the process memory region contains a memory-mapped file (such as an executable, DLL), then the VAD node stores information about its base address, file path, and memory protection. The following example should help you understand this concept. In the following screenshot, one of the VAD nodes in the kernel space is describing information about where the process executable (<em class="calibre17">explorer.exe</em>) is loaded, its full path, and memory protection. Similarly, other VAD nodes will describe process memory ranges, including the ones that contain mapped executable images such as DLLs:</p>
<div class="cdpaligncenter"><img src="../images/00344.jpeg" class="calibre268"/></div>
<p class="calibre2">To get the module's information, the <kbd class="calibre13">ldrmodules</kbd> plugin enumerates all the VAD nodes that contain mapped executable images and compares the results with the three PEB lists to identify any discrepancies. The following is the module listing of a process from a memory image infected with the <em class="calibre17">TDSS rootkit</em> (which we saw earlier). You can see that the <kbd class="calibre13">ldrmodules</kbd> plugin was able to identify a malicious DLL called <kbd class="calibre13">TDSSoiqh.dll</kbd>, which hides from all the three PEB lists (<kbd class="calibre13">InLoad</kbd>, <kbd class="calibre13">InInit</kbd>, and <kbd class="calibre13">InMem</kbd>). The <kbd class="calibre13">InInit</kbd> value is set to <kbd class="calibre13">False</kbd> for <kbd class="calibre13">svchost.exe</kbd>, which is expected for an executable, as mentioned earlier:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f tdl3.vmem --profile=WinXPSP3x86 ldrmodules -p 880</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Pid Process     Base     InLoad InInit InMem MappedPath<br class="title-page-name"/>--- ----------- --------  ----- ------- ----- ----------------------------<br class="title-page-name"/>880 svchost.exe 0x10000000 <strong class="calibre1">False False False \WINDOWS\system32\TDSSoiqh.dll</strong><br class="title-page-name"/>880 svchost.exe 0x01000000 True  <strong class="calibre1">False</strong> True  \WINDOWS\system32\svchost.exe<br class="title-page-name"/>880 svchost.exe 0x76d30000 True  True  True  \WINDOWS\system32\wmi.dll<br class="title-page-name"/>880 svchost.exe 0x76f60000 True  True  True  \WINDOWS\system32\wldap32.dll<br class="title-page-name"/>[REMOVED]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">7. Dumping an Executable and DLL</h1>
                
            
            <article>
                
<p class="calibre2">After you have identified the malicious process or DLL, you may want to dump it for further investigation (such as for extracting strings, running yara rules, disassembly, or scanning with Antivirus software). To dump a process executable from memory to disk, you can use the <kbd class="calibre13">procdump</kbd> plugin. To dump the process executable, you need to know either its process ID or its physical offset. In the following example of a memory image infected with <em class="calibre17">Perseus malware</em> (covered previously while discussing the <kbd class="calibre13">pslist</kbd> plugin), the <kbd class="calibre13">procdump</kbd> plugin is used to dump its malicious process executable <kbd class="calibre13">svchost..exe</kbd> (<kbd class="calibre13">pid 3832</kbd>). With the <kbd class="calibre13">-D</kbd> (<kbd class="calibre13">--dump-dir</kbd>) option, you specify the name of the directory in which to dump executable files. The dumped file is named based on the pid of a process such as <kbd class="calibre13">executable.PID.exe</kbd>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f perseus.vmem --profile=Win7SP1x86 procdump -p 3832 -D dump/</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Process(V) ImageBase  Name         Result<br class="title-page-name"/>---------- ---------- ------------ -----------------------<br class="title-page-name"/>0x8503f0e8 0x00b90000 svchost..exe OK: executable.3832.exe<br class="title-page-name"/><br class="title-page-name"/>$ <strong class="calibre1">cd dump</strong><br class="title-page-name"/>$ <strong class="calibre1">file executable.3832.exe</strong><br class="title-page-name"/>executable.3832.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windows</pre>
<p class="calibre2">To dump a process with the physical offset, you can use the <kbd class="calibre13">-o (--offset)</kbd> option, which is useful if you want to dump a hidden process from memory. In the following example of a memory image infected with <kbd class="calibre13">prolaco</kbd> malware (covered previously while discussing the <kbd class="calibre13">psscan</kbd> plugin), the hidden process is dumped using its physical offset. The physical offset was determined from the <kbd class="calibre13">psscan</kbd> plugin. You can also get the physical offset from the <kbd class="calibre13">psxview</kbd> plugin.  When using the <kbd class="calibre13">procdump</kbd> plugin, if you don't specify the <kbd class="calibre13">-p (--pid)</kbd> or <kbd class="calibre13">-o (--offset)</kbd> option, then it will dump the process executables of all the active processes running on the system:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f infected.vmem --profile=WinXPSP3x86 psscan</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(P)          Name    PID  PPID PDB        Time created <br class="title-page-name"/>------------------ ------- ---- ---- ---------- -------------------- <br class="title-page-name"/>[REMOVED]<br class="title-page-name"/><strong class="calibre1">0x00000000016ba360</strong> <strong class="calibre1">nvid.exe</strong> 1700 1660 0x08440320 2014-10-17 09:16:10</pre>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f infected.vmem --profile=WinXPSP3x86 procdump -o 0x00000000016ba360 -D dump/</strong> <br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Process(V) ImageBase  Name     Result<br class="title-page-name"/>---------- ---------- -------- -----------------------<br class="title-page-name"/>0x814ba360 0x00400000 nvid.exe OK: executable.1700.exe</pre>
<p class="calibre2">Similar, to the process executable, you can dump a malicious DLL to disk using the <kbd class="calibre13">dlldump</kbd> plugin. To dump the DLL, you need to specify the process ID (<kbd class="calibre13">-p</kbd> option) of the process that loaded the DLL, and the base address of the DLL, using the <kbd class="calibre13">-b (--base)</kbd> option. You can get the base address of a DLL from the <kbd class="calibre13">dlllist</kbd> or <kbd class="calibre13">ldrmodules</kbd> output. In the following example of a memory image infected with <em class="calibre17">Ghost RAT</em> (which we covered while discussing the <kbd class="calibre13">dlllist</kbd> plugin), the malicious DLL loaded by the <kbd class="calibre13">svchost.exe</kbd> (<kbd class="calibre13">pid 880</kbd>) process is dumped using the <kbd class="calibre13">dlldump</kbd> plugin:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f ghost.vmem --profile=Win7SP1x86 dlllist -p 880</strong> <br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>************************************************************************<br class="title-page-name"/>svchost.exe pid: 880<br class="title-page-name"/>Command line : C:\Windows\system32\svchost.exe -k netsvcs<br class="title-page-name"/><br class="title-page-name"/>Base        Size  LoadCount  Path<br class="title-page-name"/>---------- ------ --------   ------<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/><strong class="calibre1">0x10000000 0x26000 0x1 c:\users\test\application data\acd systems\acdsee\imageik.ddf</strong></pre>
<pre class="calibre18">$ <strong class="calibre1">python</strong><strong class="calibre1"> vol.py -f ghost.vmem --profile=Win7SP1x86 dlldump -p 880 -b 0x10000000 -D dump/</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Name       Module Base    Module Name       Result<br class="title-page-name"/>---------- ------------ ---------------- --------------------------<br class="title-page-name"/>svchost.exe 0x010000000  imageik.ddf      module.880.ea13030.10000000.dll</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">8. Listing Network Connections and Sockets</h1>
                
            
            <article>
                
<p class="calibre2">Most malicious programs perform some network activity, either to download additional components, to receive commands from the attacker, to exfiltrate data, or to create a remote backdoor on the system. Inspecting the networking activity will help you determine the network operations of the malware on the infected system. In many cases, it is useful to associate the process running on the infected system with the activities detected on the network. To determine the active network connections on pre-vista systems (such as Windows XP and 2003), you can use the <kbd class="calibre13">connections</kbd> plugin. The following command shows an example of using the <kbd class="calibre13">connections</kbd> plugin to print the active connections from a memory dump infected with <em class="calibre17">BlackEnergy</em> malware. From the following output, you can see that the process with a process ID of <kbd class="calibre13">756</kbd> was responsible for the C2 communication on port <kbd class="calibre13">443</kbd>. After running the <kbd class="calibre13">pslist</kbd> plugin, you can tell that the pid of <kbd class="calibre13">756</kbd> is associated with the <kbd class="calibre13">svchost.exe</kbd> process:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f be3.vmem --profile=WinXPSP3x86 connections</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V)  Local Address         Remote Address   Pid<br class="title-page-name"/>---------- ------------------   --------------  -------<br class="title-page-name"/>0x81549748 192.168.1.100:1037   X.X.32.230:443   756</pre>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f be3.vmem --profile=WinXPSP3x86 pslist -p 756</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V)  Name        PID PPID Thds Hnds Sess Wow64  Start               <br class="title-page-name"/>---------- ----------- --- ---- ---- ---- ---- ------ --------------------<br class="title-page-name"/>0x8185a808 svchost.exe 756 580  22   442  0    0      2016-01-13 18:38:10</pre>
<p class="calibre2">Another plugin that you can use to list the network connections on pre-vista systems is <kbd class="calibre13">connscan</kbd>.  It uses the pool tag scanning approach to determine the connections. As a result, it can also detect terminated connections. In the following example of the memory image infected with <em class="calibre17">TDL3</em> rootkit, the <kbd class="calibre13">connections</kbd> plugin does not return any results, whereas the <kbd class="calibre13">connscan</kbd> plugin displays the network connections. This does not necessarily mean that the connection is hidden, it just means that the network connection was not active (or terminated) when the memory image was acquired:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f tdl3.vmem --profile=WinXPSP3x86 connections</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V)  Local Address Remote Address Pid<br class="title-page-name"/>---------- ------------- -------------- ----</pre>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f tdl3.vmem --profile=WinXPSP3x86 connscan</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(P)  Local Address         Remote Address    Pid<br class="title-page-name"/>---------- ------------------   ---------------   -----<br class="title-page-name"/>0x093812b0 192.168.1.100:1032   XX.XXX.92.121:80   880</pre>
<p class="calibre2">Sometimes, you may want to get the information about the open sockets and their associated processes. On pre-vista systems, you can get the information about the open ports using the <kbd class="calibre13">sockets</kbd> and <kbd class="calibre13">sockscan</kbd> plugins. The <kbd class="calibre13">sockets</kbd> plugin prints the list of open sockets, and the <kbd class="calibre13">sockscan</kbd> plugin uses the pool tag scanning approach. As a result, it can detect the ports that have been closed.</p>
<p class="calibre2">On Vista and later systems (such as Windows 7), you can use the <kbd class="calibre13">netscan</kbd> plugin to display both the network connections and the sockets. The <kbd class="calibre13">netscan</kbd> plugin uses the pool tag scanning approach, similar to the <kbd class="calibre13">sockscan</kbd> and <kbd class="calibre13">connscan</kbd> plugins. In the following example of the memory image being infected with <em class="calibre17">Darkcomet RAT</em>, the <kbd class="calibre13">netscan</kbd> plugin displays C2 communication on port <kbd class="calibre13">81</kbd>, which has been made by the malicious process <kbd class="calibre13">dmt.exe (pid 3768)</kbd>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f darkcomet.vmem --profile=Win7SP1x86 netscan</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Proto Local Address   Foreign Address     State       Pid Owner<br class="title-page-name"/>TCPv4 192.168.1.60:139    0.0.0.0:0       LISTENING      4 System <br class="title-page-name"/>UDPv4 192.168.1.60:137    *:*                            4 System<br class="title-page-name"/>UDPv4 0.0.0.0:0           *:*                           1144 svchost.exe<br class="title-page-name"/>TCPv4 0.0.0.0:49155       0.0.0.0:0       LISTENING     496 services.exe <br class="title-page-name"/>UDPv4 0.0.0.0:64471       *:*                           1064 svchost.exe<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>UDPv4 0.0.0.0:64470       *:*                           1064 svchost.exe<br class="title-page-name"/><strong class="calibre1">TCPv4 192.168.1.60:49162  XX.XXX.228.199:81 ESTABLISHED 3768 dmt.exe</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9. Inspecting Registry</h1>
                
            
            <article>
                
<p class="calibre2">From a forensics perspective, the registry can provide valuable information about the context of the malware. While discussing the persistence methods in <a target="_blank" href="part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 7</a>, <em class="calibre17">Malware Functionalities and Persistence</em>, you saw how malicious programs add entries in the registry to survive the reboot. In addition to persistence, the malware uses the registry to store configuration data, encryption keys, and so on. To print the registry key, subkeys, and its values, you can use the <kbd class="calibre13">printkey</kbd> plugin by providing the desired registry key path using the <kbd class="calibre13">-K</kbd> (<kbd class="calibre13">--key</kbd>) argument. In the following example of a memory image infected with <em class="calibre17">Xtreme Rat</em>, it adds the malicious executable <kbd class="calibre13">C:\Windows\InstallDir\system.exe</kbd> in the Run registry key. As a result, the malicious executable will be executed every time the system starts:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f xrat.vmem --profile=Win7SP1x86 printkey -K "Microsoft\Windows\CurrentVersion\Run"</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Legend: (S) = Stable (V) = Volatile<br class="title-page-name"/><br class="title-page-name"/>----------------------------<br class="title-page-name"/>Registry: \SystemRoot\System32\Config\SOFTWARE<br class="title-page-name"/>Key name: Run (S)<br class="title-page-name"/>Last updated: 2018-04-22 06:36:43 UTC+0000<br class="title-page-name"/><br class="title-page-name"/>Subkeys:<br class="title-page-name"/><br class="title-page-name"/>Values:<br class="title-page-name"/>REG_SZ VMware User Process : (S) "C:\Program Files\VMware\VMware Tools\vmtoolsd.exe" -n vmusr<br class="title-page-name"/><strong class="calibre1">REG_EXPAND_SZ HKLM : (S) C:\Windows\InstallDir\system.exe</strong></pre>
<p class="calibre2">In the following example, the <em class="calibre17">Darkcomet RAT</em> adds an entry in the registry to load its malicious <kbd class="calibre13">DLL (mph.dll)</kbd> via <kbd class="calibre13">rundll32.exe</kbd>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f darkcomet.vmem --profile=Win7SP1x86 printkey -K "Software\Microsoft\Windows\CurrentVersion\Run"</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Legend: (S) = Stable (V) = Volatile<br class="title-page-name"/><br class="title-page-name"/>----------------------------<br class="title-page-name"/>Registry: \??\C:\Users\Administrator\ntuser.dat<br class="title-page-name"/>Key name: Run (S)<br class="title-page-name"/>Last updated: 2016-09-23 10:01:53 UTC+0000<br class="title-page-name"/><br class="title-page-name"/>Subkeys:<br class="title-page-name"/><br class="title-page-name"/>Values:<br class="title-page-name"/><strong class="calibre1">REG_SZ Adobe cleanup : (S) rundll32.exe "C:\Users\Administrator\Local Settings\Application Data\Adobe updater\mph.dll", StartProt</strong><br class="title-page-name"/>----------------------------</pre>
<p class="calibre2">There are other registry keys that store valuable information in binary form, which can be of great value to a forensic investigator. The volatility plugins such as <kbd class="calibre13">userassist</kbd>, <kbd class="calibre13">shellbags</kbd>, and <kbd class="calibre13">shimcache</kbd> parse these registry keys that contain binary data and display information in a much more readable format.</p>
<p class="calibre2">The <kbd class="calibre13">Userassist</kbd> registry key contains a list of programs that have been executed by the user on the system and the time when the program was run. To print <kbd class="calibre13">userassist</kbd> registry information, you can use Volatility's <kbd class="calibre13">userassist</kbd> plugin, as shown here. In the following example, a suspiciously named executable <kbd class="calibre13">(info.doc.exe)</kbd> was executed from the <strong class="calibre5">E:\</strong> drive (possibly the USB drive) at <kbd class="calibre13">2018-04-30 06:42:37</kbd>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f inf.vmem --profile=Win7SP1x86 userassist</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>----------------------------<br class="title-page-name"/>Registry: \??\C:\Users\test\ntuser.dat <br class="title-page-name"/><br class="title-page-name"/>[REMOVED]<br class="title-page-name"/><br class="title-page-name"/>REG_BINARY <strong class="calibre1">E:\info.doc.exe</strong> : <br class="title-page-name"/>Count: 1<br class="title-page-name"/>Focus Count: 0<br class="title-page-name"/>Time Focused: 0:00:00.500000<br class="title-page-name"/>Last updated: <strong class="calibre1">2018-04-30 06:42:37 UTC+0000</strong><br class="title-page-name"/>Raw Data:<br class="title-page-name"/>0x00000000 00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00<br class="title-page-name"/>0x00000010 00 00 80 bf 00 00 80 bf 00 00 80 bf 00 00 80 bf</pre>
<div class="packt_infobox">The <kbd class="calibre42">shimcache</kbd> and <kbd class="calibre42">shellbags</kbd> plugins can be useful when investigating a malware incident. The <kbd class="calibre42">shimcache</kbd> plugin can be helpful for proving the existence of a malware on the system and the time it ran. The <kbd class="calibre42">shellbags</kbd> plugin can give information about access to the files, folder, external storage devices, and network resources.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">10. Investigating Service</h1>
                
            
            <article>
                
<p class="calibre2">In <a target="_blank" href="part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 7</a>, <em class="calibre17">Malware Functionalities and Persistence</em>, we looked at how an attacker can persist on the system by installing on or modifying an existing service. In this section, we will focus on how to investigate services from the memory image. To list the services and their information such as <em class="calibre17">display name</em>, <em class="calibre17">type of service,</em> and <em class="calibre17">startup type</em> from the memory image, you can use the <kbd class="calibre13">svcscan</kbd> plugin. In the following example, the malware creates a service of type <kbd class="calibre13">WIN32_OWN_PROCESS</kbd> with the display name and service name as <kbd class="calibre13">svchost</kbd>. From the binary path, you can tell that the <kbd class="calibre13">svchost.exe</kbd> is malicious because it is running from the non-standard path <em class="calibre17">C:\Windows</em> instead of <em class="calibre17">C:\Windows\System32</em>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f svc.vmem --profile=Win7SP1x86 svcscan</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>Offset: 0x58e660<br class="title-page-name"/>Order: 396<br class="title-page-name"/>Start: SERVICE_AUTO_START<br class="title-page-name"/>Process ID: 4080<br class="title-page-name"/>Service Name: svchost<br class="title-page-name"/>Display Name: svchost<br class="title-page-name"/>Service Type: SERVICE_WIN32_OWN_PROCESS<br class="title-page-name"/>Service State: SERVICE_RUNNING<br class="title-page-name"/>Binary Path: <strong class="calibre1">C:\Windows\svchost.exe</strong></pre>
<p class="calibre2">For a service that is implemented as DLL (a service DLL), you can display the full path of the service DLL (or a kernel driver) by passing the <kbd class="calibre13">-v (--verbose)</kbd> option to the <kbd class="calibre13">svcscan</kbd> plugin. The <kbd class="calibre13">-v</kbd> option prints detailed information related to the service. The following is an example of the malware that runs a service as a DLL. The Service State is set to <kbd class="calibre13">SERVICE_START_PENDING</kbd>, and the start type is set to <kbd class="calibre13">SERVICE_AUTO_START</kbd>, which tells you that this service is not yet started and will be automatically started during system startup:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f svc.vmem --profile=Win7SP1x86 svcscan</strong><br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>Offset: 0x5903a8<br class="title-page-name"/>Order: 396<br class="title-page-name"/>Start: <strong class="calibre1">SERVICE_AUTO_START</strong><br class="title-page-name"/>Process ID: -<br class="title-page-name"/>Service Name: FastUserSwitchingCompatibility<br class="title-page-name"/>Display Name: FastUserSwitchingCompatibility<br class="title-page-name"/>Service Type: SERVICE_WIN32_SHARE_PROCESS<br class="title-page-name"/>Service State: <strong class="calibre1">SERVICE_START_PENDING</strong><br class="title-page-name"/>Binary Path: -<br class="title-page-name"/>ServiceDll: <strong class="calibre1">C:\Windows\system32\FastUserSwitchingCompatibilityex.dll</strong><br class="title-page-name"/>ImagePath: %SystemRoot%\System32\svchost.exe -k netsvcs</pre>
<p class="calibre2">Some malicious programs hijack the existing service that is unused or disabled to persist on the system. An example of such a malware is <em class="calibre17">BlackEnergy</em>, which replaces a legitimate kernel driver called <kbd class="calibre13">aliide.sys</kbd> on the disk. This kernel driver is associated with a service named <kbd class="calibre13">aliide.</kbd> After replacing the driver, it modifies the registry entry associated with the <kbd class="calibre13">aliide</kbd> service and sets it to autostart (that is, the service starts automatically when the system starts). It is hard to detect such attacks. One method to detect such a modification is to keep a list of all the services from a clean memory image, and compare that with the list of services from the suspect image to look for any modification. The following is the service configuration of the aliide service from the clean memory image. The legitimate aliide service is set to on-demand start (the service needs to be manually started) and the service is in the stopped state:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f win7_clean.vmem --profile=Win7SP1x64 svcscan</strong><br class="title-page-name"/>Offset: 0x871c30<br class="title-page-name"/>Order: 11<br class="title-page-name"/>Start: <strong class="calibre1">SERVICE_DEMAND_START</strong><br class="title-page-name"/>Process ID: -<br class="title-page-name"/>Service Name: aliide<br class="title-page-name"/>Display Name: aliide<br class="title-page-name"/>Service Type: SERVICE_KERNEL_DRIVER<br class="title-page-name"/>Service State: <strong class="calibre1">SERVICE_STOPPED</strong><br class="title-page-name"/>Binary Path: -</pre>
<p class="calibre2">The following is the <kbd class="calibre13">svcscan</kbd> output from a memory image infected with <em class="calibre17">BlackEnergy<strong class="calibre5">.</strong></em> After modification, the <kbd class="calibre13">aliide</kbd> service is set to autostart (the service starts automatically when the system starts) and is still in the stopped state. What this means is that after restarting the system, the service will automatically start and load the malicious <kbd class="calibre13">aliide.sys</kbd> driver. For a detailed analysis of this <em class="calibre17">BlackEnergy</em> dropper, refer to the author's blog post at <a href="https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/" class="calibre10">https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/</a>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f be3_big.vmem --profile=Win7SP1x64 svcscan</strong><br class="title-page-name"/>Offset: 0x881d30<br class="title-page-name"/>Order: 12<br class="title-page-name"/>Start: <strong class="calibre1">SERVICE_AUTO_START</strong><br class="title-page-name"/>Process ID: -<br class="title-page-name"/>Service Name: aliide<br class="title-page-name"/>Display Name: aliide<br class="title-page-name"/>Service Type: SERVICE_KERNEL_DRIVER<br class="title-page-name"/>Service State: <strong class="calibre1">SERVICE_STOPPED</strong><br class="title-page-name"/>Binary Path: -</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">11. Extracting Command History</h1>
                
            
            <article>
                
<p class="calibre2">After compromising the system, an attacker may execute various commands on the command shell to enumerate users, groups, and shares on your network, or an attacker may transfer a tool such as <em class="calibre17">Mimikatz</em> (<a href="https://github.com/gentilkiwi/mimikatz" class="calibre10">https://github.com/gentilkiwi/mimikatz</a>) to the comprised system and execute it to dump Windows credentials. Mimikatz is an open source tool that was written by Benjamin Delpy in 2011. It is one of the most popular tools for gathering credentials from Windows systems. Mimikatz is distributed in different flavors, such as the compiled version (<a href="https://github.com/gentilkiwi/mimikatz" class="calibre10">https://github.com/gentilkiwi/mimikatz</a>), and is part of PowerShell Modules such as <em class="calibre17">PowerSploit</em> (<a href="https://github.com/PowerShellMafia/PowerSploit" class="calibre10">https://github.com/PowerShellMafia/PowerSploit</a>) and <em class="calibre17">PowerShell Empire</em> (<a href="https://github.com/EmpireProject/Empire" class="calibre10">https://github.com/EmpireProject/Empire</a>).</p>
<p class="calibre2">Command history can provide valuable information about an attacker's activity on the compromised system. By examining the command history, you can determine information such as the commands that have been executed, programs invoked, and files and folders accessed by the attackers. The two volatility plugins, <kbd class="calibre13">cmdscan</kbd>, and <kbd class="calibre13">consoles</kbd> can extract command history from the memory image. These plugins extract the command history from <kbd class="calibre13">csrss.exe</kbd> (before Windows 7) or <kbd class="calibre13">conhost.exe</kbd> (Windows 7 and later versions) processes.</p>
<div class="packt_tip">To understand the detailed workings of these plugins, read the book <q class="calibre259">"The Art of Memory Forensics"</q> or read the research paper <q class="calibre259">"Extracting Windows Command Line Details from Physical Memory"</q> by Richard Stevens and Eoghan Casey (<a href="http://www.dfrws.org/2010/proceedings/2010-307.pdf" target="_blank" class="calibre20">http://www.dfrws.org/2010/proceedings/2010-307.pdf</a>).</div>
<p class="calibre2">The <kbd class="calibre13">cmdscan</kbd> plugin lists the commands executed by <kbd class="calibre13">cmd.exe</kbd>. The following example gives insight into the credential-stealing activity on the system. From the <kbd class="calibre13">cmdscan</kbd> output, you can see that an application with the name <kbd class="calibre13">net.exe</kbd> was invoked via the command shell <kbd class="calibre13">(cmd.exe).</kbd> From the commands extracted from <kbd class="calibre13">net.exe</kbd>, you can tell that the commands <kbd class="calibre13">privilege::debug</kbd> and <kbd class="calibre13">sekurlsa::logonpasswords</kbd> are associated with Mimikatz. In this case, the Mimikatz application was renamed to <kbd class="calibre13">net.exe</kbd>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f mim.vmem --profile=Win7SP1x64 cmdscan</strong><br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>CommandProcess: conhost.exe Pid: 2772<br class="title-page-name"/>CommandHistory: 0x29ea40 <strong class="calibre1">Application: cmd.exe</strong> Flags: Allocated, Reset<br class="title-page-name"/>CommandCount: 2 LastAdded: 1 LastDisplayed: 1<br class="title-page-name"/>FirstCommand: 0 CommandCountMax: 50<br class="title-page-name"/>ProcessHandle: 0x5c<br class="title-page-name"/>Cmd #0 @ 0x29d610: cd \<br class="title-page-name"/>Cmd #1 @ 0x27b920: <strong class="calibre1">cmd.exe /c %temp%\net.exe</strong><br class="title-page-name"/>Cmd #15 @ 0x260158: )<br class="title-page-name"/>Cmd #16 @ 0x29d3b0: )<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>**************************************************<br class="title-page-name"/>CommandProcess: conhost.exe Pid: 2772<br class="title-page-name"/>CommandHistory: 0x29f080 <strong class="calibre1">Application: net.exe</strong> Flags: Allocated, Reset<br class="title-page-name"/>CommandCount: 2 LastAdded: 1 LastDisplayed: 1<br class="title-page-name"/>FirstCommand: 0 CommandCountMax: 50<br class="title-page-name"/>ProcessHandle: 0xd4<br class="title-page-name"/>Cmd #0 @ 0x27ea70: <strong class="calibre1">privilege::debug</strong><br class="title-page-name"/>Cmd #1 @ 0x29b320: <strong class="calibre1">sekurlsa::logonpasswords</strong><br class="title-page-name"/>Cmd #23 @ 0x260158: )<br class="title-page-name"/>Cmd #24 @ 0x29ec20: '</pre>
<p class="calibre2">The <kbd class="calibre13">cmdscan</kbd> plugin displays the commands executed by the attacker. To get an idea of whether the command succeeded or not, you can use the <kbd class="calibre13">consoles</kbd> plugin. After running the <kbd class="calibre13">consoles</kbd> plugin, you can see that <kbd class="calibre13">net.exe</kbd> is indeed a Mimikatz application and, to dump the credentials,<span class="calibre7"> Mimkatz commands were</span> executed using the Mimikatz shell. From the output, you can tell that the credentials were successfully dumped and that the password was retrieved in clear text:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f mim.vmem --profile=Win7SP1x64 consoles</strong><br class="title-page-name"/>----<br class="title-page-name"/>CommandHistory: 0x29ea40 Application: cmd.exe Flags: Allocated, Reset<br class="title-page-name"/>CommandCount: 2 LastAdded: 1 LastDisplayed: 1<br class="title-page-name"/>FirstCommand: 0 CommandCountMax: 50<br class="title-page-name"/>ProcessHandle: 0x5c<br class="title-page-name"/>Cmd #0 at 0x29d610: cd \<br class="title-page-name"/>Cmd #1 at 0x27b920: <strong class="calibre1">cmd.exe /c %temp%\net.exe</strong><br class="title-page-name"/>----<br class="title-page-name"/>Screen 0x280ef0 X:80 Y:300<br class="title-page-name"/>Dump:<br class="title-page-name"/>Microsoft Windows [Version 6.1.7600] <br class="title-page-name"/>Copyright (c) 2009 Microsoft Corporation. All rights reserved. <br class="title-page-name"/>                                                                                <br class="title-page-name"/>C:\Windows\system32&gt;cd \ <br class="title-page-name"/>                                                                                <br class="title-page-name"/>C:\&gt;cmd.exe /c %temp%\net.exe<br class="title-page-name"/><br class="title-page-name"/>[REMOVED] <br class="title-page-name"/>                                                                                <br class="title-page-name"/><strong class="calibre1">mimikatz # privilege::debug</strong> <br class="title-page-name"/>Privilege '20' OK <br class="title-page-name"/>                                                                                <br class="title-page-name"/><strong class="calibre1">mimikatz # sekurlsa::logonpasswords</strong>                                                                             <br class="title-page-name"/>Authentication Id : 0 ; 269689 (00000000:00041d79) <br class="title-page-name"/>Session : Interactive from 1 <br class="title-page-name"/>User Name : test <br class="title-page-name"/>Domain : PC <br class="title-page-name"/>Logon Server : PC <br class="title-page-name"/>Logon Time : 5/4/2018 10:00:59 AM <br class="title-page-name"/>SID : S-1-5-21-1752268255-3385687637-2219068913-1000 <br class="title-page-name"/>        msv : <br class="title-page-name"/>         [00000003] Primary <br class="title-page-name"/>         * Username : test <br class="title-page-name"/>         * Domain : PC <br class="title-page-name"/>         * LM : 0b5e35e143b092c3e02e0f3aaa0f5959 <br class="title-page-name"/>         * NTLM : 2f87e7dcda37749436f914ae8e4cfe5f <br class="title-page-name"/>         * SHA1 : 7696c82d16a0c107a3aba1478df60e543d9742f1 <br class="title-page-name"/>        tspkg : <br class="title-page-name"/>         * Username : test <br class="title-page-name"/>         * Domain : PC <br class="title-page-name"/>         * Password : cleartext <br class="title-page-name"/>        wdigest : <br class="title-page-name"/>         * Username : test <br class="title-page-name"/>         * Domain : PC <br class="title-page-name"/>         * Password : cleartext <br class="title-page-name"/>        kerberos : <br class="title-page-name"/>         * Username : test <br class="title-page-name"/>         * Domain : PC <br class="title-page-name"/>         * Password : cleartext </pre>
<div class="packt_infobox">You may not be able to dump a password in clear text using Mimikatz on Windows 8.1 and later versions, however, Mimikatz provides various capabilities to an attacker. An attacker may use an extracted NTLM hash to impersonate an account. For detailed information on Mimikatz and how it can be used to extract Windows credentials, read <a href="https://adsecurity.org/?page_id=1821" class="calibre20">https://adsecurity.org/?page_id=1821</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">Memory forensics is a great technique to find and extract forensic artifacts from the computer's memory. In addition to using memory forensics for malware investigation, you can use it as part of the malware analysis to gain additional information about the behavior and the characteristics of a malware. This chapter covered different Volatility plugins, which enabled you to gain an understanding of the events that occurred on the comprised system and provided insight into the malware's activity. In the next chapter, we will determine the advanced malware capabilities, using a few more Volatility plugins, and you will understand how to extract forensic artifacts using these plugins.</p>


            </article>

            
        </section>
    </body></html>