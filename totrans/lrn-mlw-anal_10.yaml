- en: Hunting Malware Using Memory Forensics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the chapters covered so far, we looked at the concepts, tools, and techniques
    that are used to analyze malware using static, dynamic, and code analysis. In
    this chapter, you will understand another technique, called *memory forensics
    (or Memory Analysis)*.
  prefs: []
  type: TYPE_NORMAL
- en: Memory forensics (or Memory Analysis) is an investigative technique which involves
    finding and extracting forensic artifacts from the computer's physical memory
    (RAM). A computer's memory stores valuable information about the runtime state
    of the system. Acquiring the memory and analyzing it will reveal necessary information
    for forensic investigation, such as which applications are running on the system,
    what objects (file, registry, and so on) these applications are accessing, active
    networks connections, loaded modules, loaded kernel drivers, and other information.
    For this reason, memory forensics is used in incident response and malware analysis.
  prefs: []
  type: TYPE_NORMAL
- en: During incident response,  in most cases, you will not have access to the malware
    sample but you may only have the memory image of a suspect system. For instance,
    you may receive an alert from a security product about a possible malicious behavior
    from a system, in that case, you may acquire the memory image of the suspect system,
    to perform memory forensics for confirming the infection and to find the malicious
    artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using memory forensics for incident response, you can also use
    it as part of malware analysis (where you have the malware sample) to gain additional
    information about the behavior of the malware post-infection. For instance, when
    you have a malware sample, in addition to performing static, dynamic, and code
    analysis, you can execute the sample in an isolated environment and then acquire
    the infected computer memory and examine the memory image to get an idea of the
    malware's behavior after infection.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason why you use memory forensics is that some malware samples may
    not write malicious components to the disk (only in memory). As a result, disk
    forensics or the filesystem analysis might fail. In such cases, memory forensics
    can be extremely useful in finding the malicious component.
  prefs: []
  type: TYPE_NORMAL
- en: Some malware samples trick the operating system and live forensic tools by hooking
    or by modifying operating system structures. In such cases, memory forensics can
    be useful as it can bypass the tricks used by the malware to hide from the operating
    system and live forensic tools. This chapter introduces you to the concept of
    memory forensics and covers tools used to acquire and analyze the memory image.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Memory Forensics Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether you use memory forensics as part of the incident response or for malware
    analysis, the following are the general steps in memory forensics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory Acquisition**: This involves acquiring (or dumping) the memory of
    a target machine to disk. Depending on whether you are investigating an infected
    system or using memory forensics as part of your malware analysis, the target
    machine can be a system (on your network) that you suspect to be infected, or
    it could be an analysis machine in your lab environment where you executed the
    malware sample.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory Analysis**: After you dump the memory to disk, this step involves
    analyzing the dumped memory to find and extract forensic artifacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2\. Memory Acquisition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memory acquisition is the process of acquiring volatile memory (RAM) to non-volatile
    storage (file on the disk). There are various tools that allow you to acquire
    the memory of a physical machine. The following are some of the tools that allow
    you to acquire (dump) the physical memory onto Windows. Some of these tools are
    commercial, and many of them can be downloaded for free after registration. The
    following tools work with both x86 (32-bit) and x64 (64-bits) machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Comae Memory Toolkit (DumpIt)* by Comae Technologies *(free download with
    registration):* [https://my.comae.io/](https://my.comae.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Belkasoft RAM Capturer (free download with registration):* [https://belkasoft.com/ram-capturer](https://belkasoft.com/ram-capturer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*FTK Imager* by AccessData *(free download with registration):* [https://accessdata.com/product-download](https://accessdata.com/product-download)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Memoryze* by FireEye *(free download with registration):* [https://www.fireeye.com/services/freeware/memoryze.html](https://www.fireeye.com/services/freeware/memoryze.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Surge Collect* by Volexity (*Commercial*): [https://www.volexity.com/products-overview/surge/](https://www.volexity.com/products-overview/surge/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*OSForensics* by PassMark Software *(commercial):* [https://www.osforensics.com/osforensics.html](https://www.osforensics.com/osforensics.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*WinPmem (open source), part of Rekall Memory forensic framework:* [http://blog.rekall-forensic.com/search?q=winpmem](http://blog.rekall-forensic.com/search?q=winpmem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.1 Memory Acquisition Using DumpIt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*DumpIt* is an excellent memory acquisition tool that allows you to dump physical
    memory on Windows. It supports the acquisition of both 32-bit (x86) and 64-bit
    (x64) machines. DumpIt is part of a toolkit called the *Comae memory toolkit*,
    which consists of various standalone tools that assist with memory acquisition
    and conversion between different file formats. To download the latest copy of
    the *Comae memory toolkit*, you need to create an account by registering on [https://my.comae.io](https://my.comae.io).
    Once the account is created, you can log in and download the latest copy of the *Comae
    memory toolkit.*'
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the Comae toolkit, extract the archive, and navigate to the
    32-bit or 64-bit directory, depending on whether you want to dump the memory of
    a 32-bit or 64-bit machine. The directory consists of various files, including
    *DumpIt.exe*. In this section, we will mainly focus on how to use DumpIt to dump
    the memory. If you are interested in understanding the functionality of other
    tools in the directory, read the *readme.txt* file.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest method to acquire memory using *DumpIt* is to right-click on the
    *DumptIt.exe* file and select *Run as administrator*. By default, DumpIt dumps
    the memory to a file as a *Microsoft Crash Dump (with a .dmp extension),* which
    can then be analyzed with Memory Analysis tools such as *Volatility* (which will
    be covered next) or by using a Microsoft debugger such as *WinDbg*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run *DumpIt* from the command line; this provides you with multiple
    options. To display different options, run *cmd.exe* as an Administrator, navigate
    to the directory containing *DumpIt.exe*, and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To acquire the memory of the Microsoft Crash dump from the command line, and
    to save the output to a file name of your choice, use the `/o` or `/OUTPUT` option,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To acquire the memory as a raw memory dump instead of the default Microsoft
    crash dump, you can specify that with the `/t` or `/TYPE` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you wish to acquire memory from servers consisting of large memory, you can
    use the `/R` or `/COMPRESS` option in *DumpIt*, which creates a `.zdmp` (*Comae
    compressed crash dump*) file, which reduces the file size and also makes acquisition
    faster. The dump file (`.zdmp`) can then be analyzed with the Comae Stardust enterprise
    platform: [https://my.comae.io](https://my.comae.io). For more details, refer
    to the following blog post: [https://blog.comae.io/rethinking-logging-for-critical-assets-685c65423dc0](https://blog.comae.io/rethinking-logging-for-critical-assets-685c65423dc0).
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you can acquire the memory of a *Virtual Machine (VM)* by suspending
    the VM. For instance, after executing the malware sample on VMware Workstation/VMware
    Fusion, you can suspend the VM, which will write the guest's memory (RAM) to a
    file with a `.vmem` extension on the host machine's disk. For those applications
    (such as VirtualBox) where the memory cannot be acquired by suspending, then you
    can use DumpIt inside the guest machine.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Volatility Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you acquire the memory of an infected system, the next step is to analyze
    the acquired memory image. *Volatility* ([http://www.volatilityfoundation.org/releases](http://www.volatilityfoundation.org/releases))
    is an open source advanced memory forensics framework written in *Python* that
    allows you to analyze and extract digital artifacts from the memory image. Volatility
    can run on various platforms (Windows, macOS, and Linux), and it supports analysis
    of memory from 32-bit and 64-bit versions of Windows, macOS, and Linux operating
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Installing Volatility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Volatility is distributed in several formats, and it can be downloaded from
    [http://www.volatilityfoundation.org/releases](http://www.volatilityfoundation.org/releases).
    At the time of writing this book, the latest version of Volatility is version
    2.6\. Depending on the operating system that you intend to run Volatility on,
    follow the installation procedure for the appropriate operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1 Volatility Standalone Executable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fastest way to get started with Volatility is to use the *standalone executable*.
    The standalone executable is distributed for Windows, macOS, and Linux operating
    systems. The advantage of a standalone executable is that you don't need to install
    the Python interpreter or Volatility dependencies, since it comes packaged with
    Python 2.7 Interpreter and all the required dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, once the standalone executable is downloaded, you can check whether
    Volatility is ready to use by executing the standalone executable with the `-h
    (--help)` option from the command line, as shown here. The help option displays
    various options and plugins that are available in Volatility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same manner, you can download the standalone executables for Linux or
    macOS and check if Volatility is ready to use by executing the standalone executable
    with the `-h` (or `--help`) option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 3.1.2 Volatility Source Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Volatility is also distributed as a source package; you can run it on *Windows*,
    macOS, or *Linux* operating systems. Volatility relies on various plugins to perform
    tasks, and some of these plugins depend on third-party Python packages. To run
    Volatility, you need to install Python 2.7 Interpreter and its dependencies. The
    web page: [https://github.com/volatilityfoundation/volatility/wiki/Installation#recommended-packages](https://github.com/volatilityfoundation/volatility/wiki/Installation#recommended-packages) contains
    a list of the third-party Python packages that are required by some of the Volatility
    plugins. You can install these dependencies by reading the documentation. Once
    all the dependencies are installed, download the Volatility source code package,
    extract it, and run *Volatility*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: All the examples mentioned in this book use the Volatility Python script (`python
    vol.py`) from the source package. You are free to choose a standalone executable,
    but just remember to replace `python vol.py` with the standalone executable name.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Using Volatility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Volatility consists of various plugins that can extract different information
    from the memory image. The `python vol.py -h` option displays the supported plugins.
    For instance, if you wish to list the running processes from the memory image,
    you can use a plugin such a `pslist`, or if you wish to list the network connections,
    you can use a different plugin. Irrespective of the plugin that you use, you will
    use the following command syntax. Using `-f`, you specify the path to the memory
    image file, and `--profile` tells Volatility which system and architecture the
    memory image was acquired from. The plugin can vary depending on what type of
    information you would like to extract from the memory image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command uses the `pslist` plugin to list the running processes
    from the memory image acquired from Windows 7 (32-bit) running Service Pack 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, you might not know what profile to supply to Volatility. In that
    case, you can use the `imageinfo` plugin, which will determine the correct profile.
    The following command displays multiple profiles that are suggested by the `imageinfo`
    plugin; you can use any of the suggested profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Most of the Volatility plugins, such as `pslist`, rely on extracting the information
    from the Windows operating system structures. These structures vary across different
    versions of Windows; the profile (`--profile`) tells Volatility which data structures,
    symbols, and algorithms to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The help option, `-h (--help)`, which that you saw previously, displays help
    that applies to all of the Volatility plugins. You can use the same `-h (--help)`
    option to determine various options and arguments supported by a plugin. To do
    that, just type `-h (--help)` next to the plugin name. The following command displays
    the help options for the `pslist` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should have an understanding of how to run *Volatility* plugins
    on an acquired memory image and how to determine various options supported by
    a plugin. In the following sections, you will learn about the different plugins
    and how to use them to extract forensic artifacts from the memory image.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Enumerating Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are investigating a memory image, you will mainly focus on identifying
    any suspicious process running on the system. There are various plugins in Volatility
    that allow you to enumerate processes. Volatility''s `pslist` plugin lists the
    processes from the memory image, similar to how *task manager* lists the process
    on a live system. In the following output, running the `pslist` plugin against
    a memory image infected with a malware sample (*Perseus*) shows two suspicious
    processes: `svchost..exe` *(*`pid 3832`*)* and `suchost..exe` ( `pid 3924`). The
    reason why these two processes are suspicious is that the names of these processes
    have an additional *dot* character before the `.exe` extension (which is abnormal).
    On a clean system, you will find multiple instances of `svchost.exe` processes
    running. By creating a process such as `svchost..exe` and `suchost..exe`, the
    attacker is trying to blend in by making these processes look similar to the legitimate 
    `svchost.exe` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running the Volatility plugin is easy; you can run the plugin without knowing
    how it works. Understanding how the plugins work will help you assess the accuracy
    of the results, and it will also help you choose the right plugin when an attacker
    uses stealth techniques. The question is, how does `pslist` work? To understand
    that first, you need to understand what a process is and how *Windows kernel*
    keeps track of processes.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Process Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *process* is an object. The Windows operating system is object-based (not
    to be confused with the term object used in object-oriented languages). An object
    refers to a system resource such as a process, file, device, directory, mutant,
    and so on, and they are managed by a component of a kernel called *object manager*.
    To get an idea of all the object types on Windows, you can use the *WinObj tool*
    ([https://docs.microsoft.com/en-us/sysinternals/downloads/winobj](https://docs.microsoft.com/en-us/sysinternals/downloads/winobj)).
    To look at the object types in *WinObj*, launch *WinObj* as an Administrator and,
    in the left-hand pane, click on *ObjectTypes*, which will display all the Windows
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: The objects (such as processes, files, threads, and so on) are represented as
    structures in C. What this means is that a process object has a structure associated
    with it, and this structure is called the `_EPROCESS` structure. The `_EPROCESS`
    structure resides in the kernel memory, and the Windows kernel uses the `EPROCESS`
    structure to represent a process internally. The `_EPROCESS` structure contains
    various information related to a process such as *the name of the process*, *process
    ID*, *parent process ID*, *number of threads associated with the process*, *the
    creation time of the process,* and so on. Now, go back to the `pslist` output
    and note what kind of information is displayed for a particular process. For example,
    if you look at the second entry from the `pslist` output, it shows the name of
    the `smss.exe` process, its process ID `(272)`, parent process ID (`4`), and so
    on. As you might have guessed, the information related to a process is coming
    from its `_EPROCESS` structure.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1 Examining the _EPROCESS Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To examine the `_EPROCESS` structure and the kind of information it contains,
    you can use a kernel debugger such as *WinDbg*. *WinDbg* helps in exploring and
    understanding the operating system data structures, which is often an important
    aspect of *Memory forensics*. To install *WinDbg*, you need to install the <q
    class="calibre256">"Debugging Tools for Windows"</q> package, which is included
    as part of *Microsoft SDK* (refer to [https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/index)
    for different installation types). Once the installation is complete, you can
    find *WinDbg.exe* in the installation directory (in my case, it is located in
    *C:\Program Files (x86)\Windows Kits\8.1\Debuggers\x64*). Next, download the *LiveKD*
    utility from *Sysinternals* ([https://docs.microsoft.com/en-us/sysinternals/downloads/livekd](https://docs.microsoft.com/en-us/sysinternals/downloads/livekd)),
    extract it, and then copy *livekd.exe* into the installation directory of *WinDbg*.
    *LiveKD* enables you to perform local kernel debugging on a live system. To launch
    *WinDbg* via *livekd*, open Command Prompt (as *Administrator*), navigate to the
    *WinDbg installation directory,* and run `livekd` with the `-w` switch, as shown
    here. You can also add the *Windbg* installation directory to the path environment
    variable so that you can launch *LiveKD* from any path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `livekd -w` command automatically launches `Windbg`, loads the symbols,
    and presents you with a `kd>` prompt that''s ready to accept commands, as shown
    in the following screenshot. To explore the data structures (such as `_EPROCESS`),
    you will type the appropriate command into the Command Prompt (next to `kd>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00333.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, going back to our discussion of the `_EPROCESS` structure, to explore
    the `_EPROCESS` structure, we will use the `Display Type` command `(dt).` The
    `dt` command can be used to explore a symbol that represents a variable, a structure,
    or a union. In the following output, the `dt` command is used to display the `_EPROCESS`
    structure defined in the `nt` module (the name of the kernel executive). The `EPROCESS`
    structure consists of multiple fields, storing all sorts of metadata of a process.
    Here is what it looks like for a 64-bit Windows 7 system (some of the fields have
    been removed to keep it small):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some of the interesting fields in the `_EPROCESS` structure
    that we will use for this discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateTime`: Timestamp that indicates when the process was first started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExitTime`: Timestamp that indicates when the process exited'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UniqueProcessID`: An integer that references the *process ID (PID)* of the
    process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ActiveProcessLinks`: A double linked list that links all the active processes
    running on the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InheritedFromUniqueProcessId`: An integer that specifies the PID of the parent
    process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageFileName`: An array of 16 ASCII characters which store the name of the
    process executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With an understanding of how to examine the `_EPROCESS` structure, let''s now
    take a look at the `_EPROCESS` structure of a specific process. To do that, let''s
    first list all active processes using *WinDbg*. You can use the `!process` extension
    command to print metadata of a particular process or all processes. In the following
    command, the first argument, `0`, lists metadata of all the processes. You can
    also display the information of a single process by specifying the address of
    the `_EPROCESS` structure. The second argument indicates the level of detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For detailed information on WinDbg commands, refer to the Debugger.chm help,
    which is located in the WinDbg installation folder. You can also refer to the
    following online resources: [http://windbg.info/doc/1-common-cmds.html](http://windbg.info/doc/1-common-cmds.html)
    and [http://windbg.info/doc/2-windbg-a-z.html](http://windbg.info/doc/2-windbg-a-z.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding output, let''s look at the second entry, which describes
    `smss.exe`. The address, `fffffa8061d35700`, next to the `PROCESS`, is the address
    of the `_EPROCESS` structure associated with this instance of `smss.exe.` The
    `Cid` field, which has a value of `00fc` (`252` in decimal), is the process ID,
    and `ParentCid`, which has a value of `0004`, represents the process ID of the
    parent process. You can verify this by examining the values in the fields for
    the `_EPROCESS` structure of `smss.exe.` You can suffix the address of the `_EPROCESS`
    structure at the end of the `Display Type (dt)` command, as shown in the following
    code. In the following output, notice the values in the fields `UniqueProcessId`
    (process ID), `InheritedFromUniqueProcessId` (parent process ID), and `ImageFileName`
    (process executable name). These values match with the results that you determined
    previously from the `!process 0 0`  command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So far, we know that the operating system keeps all kinds of metadata information
    about a process in the `_EPROCESS` structure, which resides in the kernel memory.
    This means that if you can find the address of the `_EPROCESS` structure for a
    particular process, you can get all the information about that process. Then,
    the question is, how do you get information about all the processes running on
    the system? For that, we need to understand how active processes are tracked by
    the Windows operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2 Understanding ActiveProcessLinks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Windows uses a circular double linked list of `_EPROCESS` structures to keep
    track of all the active processes. The `_EPROCESS` structure contains a field
    called `ActiveProcessLinks` which is of type `LIST_ENTRY.` The `_LIST_ENTRY` is
    another structure that contains two members, as shown in the following code. The
    `Flink` (forward link) points to the `_LIST_ENTRY` of the next `_EPROCESS` structure,
    and the `Blink` (backward link) points to the `_LIST_ENTRY` of the previous `_EPROCESS`
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Flink` and `Blink` together create a chain of process objects; this can be
    visualized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00334.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A point to note is that `Flink` and `Blink` do not point to the start of the
    `_EPROCESS` structure. `Flink` points to the start (first byte) of the `_LIST_ENTRY`
    structure of the next `_EPROCESS` structure, and `Blink` points to the first byte
    of the `_LIST_ENTRY` structure of the previous `_EPROCESS` structure. The reason
    why this is important is that, once you find the `_EPROCESS` structure of a process,
    you can walk the doubly linked list forward (using `Flink)` or backward `(Blink)`
    and then subtracting an offset value to get to the start of the `_EPROCESS` structure
    of the *next* or the *previous* process. To help you understand what this means,
    let''s look at the values of the fields `Flink` and `Blink` in the `_EPROCESS`
    structure of `smss.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Flink` has a value of `0xfffffa8062583cb8`; this is the start address of the
    `ActiveProcessLinks` (`Flink`) of the next `_EPROCESS` structure. Since `ActiveProcessLinks`,
    in our example, is at offset `0x188` from the start of the `_EPROCESS`, you can
    get to the beginning of the `_EPROCESS` structure of the *next* process by subtracting
    `0x188` from the `Flink` value. In the following output, note how by subtracting
    `0x188` we landed on the `_EPROCESS` structure of the next process, which is `csrss.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, by walking the doubly linked list, it is possible to list the
    information about all the active processes running on the system. On a live system,
    tools such as *task manager* or *Process Explorer* make use of API functions,
    which ultimately rely on finding and walking the same doubly linked list of `_EPROCESS`
    structures that exist in kernel memory. The `pslist` plugin also incorporates
    the logic of finding and walking the same doubly linked list of `_EPROCESS` structures
    from the memory image. To do that, the `pslist` plugin finds a symbol named `_PsActiveProcessHead`,
    which is defined in `ntoskrnl.exe` (or `ntkrnlpa.exe`). This symbol points to
    the beginning of the doubly linked list of `_EPROCESS` structures; the `pslist`
    then walks the doubly linked list of the `_EPROCESS` structures to enumerate all
    the running processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For detailed information on the workings and the logic used by the Volatility
    plugins covered in this book, refer to <q class="calibre259">The Art of Memory
    Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory</q> by
    Michael Hale Ligh, Andrew Case, Jamie Levy, and Aaron Walters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, a plugin such as `pslist` supports multiple options and
    arguments; this can be displayed by typing `-h (--help)` next to the plugin''s
    name. One of the `pslist` options is `--output-file`. You can use this option
    to redirect the `pslist` output to the file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is `-p (--pid)`. Using this option, you can determine the information
    of a specific process if you know its **process ID** (**PID**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 4.2 Listing Processes Using psscan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`psscan` is another Volatility plugin that lists the processes running on the
    system. Unlike `pslist`, `psscan` does not walk the doubly linked list of `_EPROCESS`
    objects. Instead, it scans the physical memory for the signature of the process
    objects. In other words, `psscan` uses a different approach to list the processes
    as compared to the `pslist` plugin. You might be thinking, what is the need for
    the `psscan` plugin when the `pslist` plugin can do the same thing? The answer
    lies in the technique used by `psscan`. Due to the approach it uses, it can detect
    terminated processes and also the hidden processes. An attacker can hide a process
    to prevent a forensic analyst from spotting the malicious process during live
    forensics. Now, the question is, how can an attacker hide a process? To understand
    that, you need to understand an attack technique known as *DKOM (Direct Kernel
    Object Manipulation)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1 Direct Kernel Object Manipulation (DKOM)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*DKOM* is a technique that involves modifying the kernel data structures. Using
    DKOM, it is possible to hide a process or a driver. To hide a process, an attacker
    finds the `_EPROCESS` structure of the malicious process he/she wants to hide
    and modifies the `ActiveProcessLinks` field. In particular, the `Flink` of the
    previous `_EPROCESS` block is made to point to the `Flink` of the following `_EPROCESS`
    block, and the `Blink` of the following `_EPROCESS` block is set to point to the
    previous `_EPROCESS` block''s `Flink.` As a result of this, the `_EPROCESS` block
    associated with the malware process is unlinked from the doubly linked list (as
    shown here):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00335.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By unlinking a process, an attacker can hide the malicious process from the
    live forensic tools that rely on walking the doubly linked list to enumerate the
    active processes. As you might have guessed, this technique also hides the malicious
    process from the `pslist` plugin (which also relies on walking the doubly linked
    list). The following is the `pslist` and `psscan` output from a system infected
    with the *prolaco* rootkit, which performs *DKOM* to hide a process. For the sake
    of brevity, some of the entries are truncated from the following output. When
    you compare the output from `pslist` and `psscan`, you will notice an additional
    process called `nvid.exe` (`pid 1700`) in the `psscan` output that''s not present
    in the `pslist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, the reason `psscan` detects the hidden process is that
    it uses a different technique to list the processes, called *pool tag scanning*.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.2 Understanding Pool Tag Scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you recall, I previously referred to system resources such as processes,
    files, threads, and so on, as objects (or executive objects). The executive objects
    are managed by a component of a kernel called the *object manager*. Every executive
    object has a structure associated with it (such as `_EPROCESS` for process object).
    The executive object structure is preceded by a `_OBJECT_HEADER` structure, which
    contains information about an object''s type and some reference counters. The
    `_OBJECT_HEADER` is then preceded by zero or more optional headers. In other words,
    you can think of an object as the combination of executive object structure, the
    object header, and the optional headers, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00336.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To store an object, memory is needed, and this memory is allocated by the Windows
    memory manager from kernel pools. A kernel pool is a range of memory that can
    be divided into smaller blocks for storing data such as objects. The pool is divided
    into a *paged pool* (whose content may be swapped to disk) and a *non-paged pool*
    (whose content permanently resides in memory). The objects (such as process and
    threads) are kept in a non-paged pool in the kernel, which means they will always
    reside in the physical memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Windows kernel receives the request to create an object (possibly
    due to API calls made by processes such as `CreateProcess` or `CreateFile`), memory
    is allocated for the object either from the paged pool or non-paged pool (depending
    on the object type). This allocation is tagged by prepending a `_POOL_HEADER`
    structure to the object, so that in memory, each object will have a predictable
    structure, similar to the ones shown in the following screenshot. The `_POOL_HEADER`
    structure includes a field named `PoolTag` that contains a four-byte tag (referred
    to as a *pool tag*). This *pool tag* can be used to identify an object. For the
    *process object*, the tag is `Proc` and for the *File object*, the tag is `File`,
    and so on. The `_POOL_HEADER`  structure also contains fields that tell the *size
    of the allocation* and the type of memory (*paged* or *non-paged pool*) it describes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00337.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can think of all the process objects residing in the non-paged pool of kernel
    memory (which ultimately maps to physical memory) as marked with a tag, `Proc`.
    It is this tag that the Volatility's `psscan` uses as the starting point to identify
    the process object. In particular, it scans the physical memory for the `Proc`
    tag to identify the pool tag allocation associated with the *process object*,
    and it further confirms it by using a more robust signature and heuristics. Once
    the `psscan` finds the process object, it extracts the necessary information from
    its `_EPROCESS` structure. The `psscan` repeats this process until it finds all
    the process objects. In fact, many volatility plugins rely on *pool tag scanning*
    to identify and extract information from the memory image.
  prefs: []
  type: TYPE_NORMAL
- en: The `psscan` plugin not only detects the hidden process, because of the approach
    it uses, but it can also detect terminated processes. When an object is destroyed
    (such as when a process is terminated), the memory allocation containing that
    object is released back to the kernel pool, but the content in the memory is not
    immediately overwritten, which means the process object can still be in the memory,
    unless that memory is allocated for a different purpose. If the memory containing
    the terminated process object is not overwritten, then `psscan` can detect the
    terminated process.
  prefs: []
  type: TYPE_NORMAL
- en: For detailed information on pool tag scanning, refer to the paper *Searching
    for Processes and Threads in Microsoft Windows Memory Dumps *by Andreas Schuster,
    or read the book *The Art of Memory Forensics*.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have an understanding of how Volatility plugins work;
    most plugins use similar logic. To summarize, critical information exists in the
    data structures maintained by the kernel. The plugins rely on finding and extracting
    information from these data structures. The approach for finding and extracting
    forensic artifacts varies; some plugins rely on walking the doubly linked list
    (like `pslist`), and some use the pool tag scanning technique (such as `psscan`)
    to extract relevant information.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Determining Process Relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When examining processes, it can be useful to determine the parent/child relationships
    between the processes. During malware investigation, this will help you understand
    which other processes are related to the malicious process. The `pstree` plugin
    displays the parent-child process relationships by using the output from the `pslist`
    and formatting it in a tree view. In the following example, running the `pstree`
    plugin against an infected memory image displays a process relationship; a child
    process is indented to the right and prepended with periods. From the output,
    you can see that `OUTLOOK.EXE` was started by the `explorer.exe` process. This
    is normal because whenever you launch an application by double-clicking, it is
    the explorer that launches the application. `OUTLOOK.EXE` `(pid 4068)` launched
    `EXCEL.EXE (pid 1124)`, which in turn invoked `cmd.exe (pid 4056)` to execute
    the malware process `doc6.exe (pid 2308)`. By looking at the events, you can assume
    that the user opened a malicious Excel document sent via email, which probably
    exploited a vulnerability or executed a macro code to drop the malware and executed
    it via `cmd.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `pstree` plugin relies on the `pslist` plugin, it cannot list the
    hidden or terminated processes. Another method to determine the process relationship
    is to use the `psscan` plugin to generate a visual representation of the parent/child
    relationships. The following `psscan` command prints the output in the *dot* format,
    which can then be opened with Graph Visualization Software such as *Graphviz*
    ([https://www.graphviz.org/](https://www.graphviz.org/)) or *XDot* (which can
    be installed on a Linux system using `sudo apt install xdot`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening the *infected.dot* file with XDot displays the relationship between
    the processes discussed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00338.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 4.4 Process Listing Using psxview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Previously, you saw how process listing could be manipulated to hide a process;
    you also understood how `psscan` uses pool tag scanning to detect the hidden process.
    It turns out that `_POOL_HEADER` (which `psscan` relies on) is only used for debugging
    purposes, and it does not affect the stability of the operating system. This means
    an attacker can install a kernel driver to run in the kernel space and modify
    the pool tags or any other field in the `_POOL_HEADER.` By modifying the pool
    tag, an attacker can prevent the plugins that rely on *pool tag scanning* from
    working properly. In other words, by modifying the pool tag, it is possible to
    hide the process from the `psscan`. To overcome this problem, The `psxview` plugin
    relies on extracting process information from different sources. It enumerates
    the process in seven different ways. By comparing the output from different sources,
    it is possible to detect discrepancies caused by the malware. In the following
    screenshot, `psxview` enumerates the processes using seven different techniques.
    Each process'' information is displayed as a single row, and the techniques it
    uses are displayed as columns containing `True` or `False`. A `False` value under
    a particular column indicates that the process was not found using the respective
    method. In the following output, `psxview` detected the hidden process `nvid.exe`
    `(pid 1700)` using all the methods except the `pslist` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00339.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, you will notice false values for a few processes.
    For example, the `cmd.exe` process is not present in any of the methods except
    the `psscan` method. You might think that `cmd.exe` is hidden, but that is not
    true; the reason why you see `False` is that `cmd.exe` is terminated (you can
    tell that from the `ExitTime` column). As a result, all other techniques were
    not able to find it where `psscan` was able to find it, because pool tag scanning
    can detect terminated process. In other words, a `False` value in a column does
    not necessarily mean that the process is hidden from that method; it can also
    mean that it is expected (depending on how and from where that method is getting
    the process information). To know whether it is expected or not, you can use the `-R
    (--apply-rules)` option as follows. In the following screenshot, notice how the
    `False` values are replaced with `Okay`**.** An `Okay` means `False`, but it is
    an expected behavior. After running the `psxview` plugin with `-R` (`--apply-rules`),
    if you still see a `False` value (such as `nvid.exe` with `pid 1700` in the following
    screenshot), then it is a strong indication that the process is hidden from that
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00340.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 5\. Listing Process Handles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During your investigation, once you pin down a malicious process, you may want
    to know which objects (such as processes, files, registry keys, and so on) the
    process is accessing. This will give you an idea of the components associated
    with the malware and an insight into their operation, for example, a keylogger
    may be accessing a log file to log captured keystrokes, or malware might have
    an open handle to the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: To access an object, a process needs to first open a handle to that object by
    calling an API such as `CreateFile` or `CreateMutex.` Once it opens a handle to
    an object, it uses that handle to perform subsequent operations such as writing
    to a file or reading from a file. A handle is an indirect reference to an object;
    think of a handle as something that represents an object (the handle is not the
    object itself). The objects reside in the kernel memory, whereas the process runs
    in the user space, because of which a process cannot access the objects directly,
    hence it uses a handle which represents that object.
  prefs: []
  type: TYPE_NORMAL
- en: Each process is given a private handle table that resides in the kernel memory.
    This table contains all the kernel objects such as files, processes, and network
    sockets that are associated with the process. The question is, how does this table
    get populated? When the kernel gets the request from a process to create an object
    (via an API such as `CreateFile`), the object is created in the *kernel memory.*
    The pointer to the object is placed in the first available slot in the process
    handle table, and the corresponding index value is returned to the process. The
    index value is the handle which represents the object, and the handle is used
    by the process to perform subsequent operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a live system, you can inspect the kernel objects accessed by a particular
    process using the *Process Hacker* tool. To do that, launch Process Hacker as
    an *Administrator***,** right-click on any process, and then select the *Handles*
    tab. The following screenshot shows the process handles of the *csrss.exe* process.
    *csrss.exe* is a legitimate operating system process that plays a role in the
    creation of every process and thread. For this reason, you will see *csrss.exe*
    having open handles to most of the processes (except itself and its parent processes)
    running on the system. In the following screenshot, the third column is the *handle
    value*, and the fourth column shows the *address of the object* in the kernel
    memory. For example, the first process, *wininit.exe*, is located at address `0x8705c410`
    (the address of its `_EPROCESS` structure) in the kernel memory, and the handle
    value representing this object is `0x60`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00341.jpeg)One of the methods used by the `psxview` plugin relies
    on walking the *csrss.exe* process''s handle table to identify the process objects.
    If there are multiples instances of *csrss.exe*, then `psxview` parses the handle
    table of all *csrss.exe* instances to list the running processes, except the *csrss.exe*
    process and its parent processes (the *smss.exe* and *system* processes).'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the memory image, you can get a list of all the kernel objects that were
    accessed by a process using the `handles` plugin. The following screenshot displays
    the handles of the process with `pid 356`. If you run the `handles` plugin without
    `-p` options, it will display handle information for all the processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00342.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also filter the results for a specific object type (`File`, `Key`,
    `Process`, `Mutant`, and so on) using the `-t` option. In the following example,
    the `handles` plugin was run against the memory image infected with *Xtreme RAT*.
    The handles `plugin` was used to list the mutexes opened by the malicious process
    (with `pid 1772`). From the following output, you can see that *Xtreme RAT* creates
    a mutex called `oZ694XMhk6yxgbTA0` to mark its presence on the system. A mutex
    such as the one created by *Xtreme RAT* can make a good host-based indicator to
    use in host-based monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example of a memory image that''s been infected with the *TDL3
    rootkit*, the `svchost.exe` process `(pid 880)` has open file handles to the malicious
    DLL and the kernel driver associated with the rootkit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 6\. Listing DLLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, you have seen examples of malware using DLL to implement
    the malicious functionality. Therefore, in addition to investigating processes,
    you may also want to examine the list of loaded libraries. To list the loaded
    modules (executable and DLLs), you can use Volatility''s `dlllist` plugin. The
    `dlllist` plugin also displays the full path associated with a process. Let''s
    take an example of the malware named *Ghost RAT*. It implements the malicious
    functionality as the *Service DLL*, and as a result, the malicious DLL gets loaded
    by the `svchost.exe` process (for more information on Service DLL, refer to the* Service*
    section in [Chapter 7](part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485),
    *Malware Functionalities and Persistence*). The following is the output from the
    `dlllist`, where you can see a suspicious module with a non-standard extension
    `(.ddf)` loaded by the `svchost.exe` process (`pid 800`). The first column, `Base`,
    specifies the base address, that is, the address in the memory where the module
    is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `dlllist` plugin gets the information about the loaded modules from a structure
    named the *Process Environment Block (PEB)*. If you recall from [Chapter 8](part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485), *Code
    Injection and Hooking*, when covering the process memory components, I mentioned
    that the *PEB* structure resides in the process memory (in the user space). The
    PEB contains metadata information about where the process executable is loaded,
    its full path on the disk, and information about the loaded modules (executable
    and DLLs). The `dlllist` plugin finds the *PEB* structure of each process and
    gets the preceding information. Then, the question is, how do you find the PEB
    structure? The `_EPROCESS` structure has a field named `Peb` that contains the
    pointer to the *PEB.* What this means is that once the plugin finds the `_EPROCESS`
    structure, it can find the *PEB*. A point to remember is that `_EPROCESS` resides
    in the kernel memory (kernel space), whereas the `PEB` resides in the process
    memory (user-space).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the address of the *PEB* in a debugger, you can use the `!process` extension
    command, which shows the address of the `_EPROCESS` structure. It also specifies
    the address of the *PEB*. From the following output, you can see that the PEB
    of the `explorer.exe` process is at address `7ffd3000` in its process memory,
    and its `_EPROCESS` structure is at `0x877ced28` (in its kernel memory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Another method to determine the address of the PEB is to use the `display type
    (dt)` command. You can find the address of the *PEB* of the `explorer.exe` process
    by examining the `Peb` field in its `EPROCESS` structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You now know how to find the *PEB*, so now, let''s try to understand what kind
    of information *PEB* contains. To get the human-readable summary of the *PEB*
    for a given process, first, you need to switch to the context of the process whose
    *PEB* you want to examine. This can be done using the `.process` extension command.
    This command accepts the address of the `_EPROCESS` structure. The following command
    sets the current process context to the `explorer.exe` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use the `!peb` extension command followed by the address of the
    *PEB*. In the following output, some of the information is truncated for the sake
    of brevity. The `ImageBaseAddress` field specifies the address where the process
    executable (`explorer.exe`) is loaded in the memory. The *PEB* also contains another
    structure called the Ldr structure (of type `_PEB_LDR_DATA`), which maintains
    three doubly linked lists, which are `InLoadOrderModuleList`, `InMemoryOrderModuleList`,
    and `InInitializationOrderModuleList.` Each of these three doubly linked lists
    contains information regarding the modules (process executable and DLLs). It is
    possible to get information regarding the modules by walking any of these doubly
    linked lists. `InLoadOrderModuleList` organizes modules in the order in which
    they are loaded, `InMemoryOrderModuleList` organizes modules in the order in which
    they reside in the process memory, and `InInitializationOrderModuleList` organizes
    modules in the order in which their `DllMain` function was executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In other words, all the three PEB lists contain information about the loaded
    modules such as the base address, size, the full path associated with the module,
    and so on. An important point to remember is that `InInitializationOrderModuleList`
    will not contain the information about the process executable because the executable,
    is initialized differently as compared to the DLLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you understand better, the following diagram uses `Explorer.exe` as
    an example (the concept is similar to other processes as well). When `Explorer.exe`
    is executed, its process executable is loaded into the process memory at some
    address (let''s say `0xb0000`) with `PAGE_EXECUTE_WRITECOPY` (`WCX`) protection.
    The associated DLLs are also loaded into the process memory. The process memory
    also includes the PEB structure which contains metadata information of where the
    `explorer.exe` is loaded (base address) in the memory. The `Ldr` structure in
    the PEB maintains three doubly linked lists; each element is a structure (of type
    `_LDR_DATA_TABLE_ENTRY`) that contains information (base address, full path, and
    so on) about the loaded modules. The `dlllist` plugin relies on walking the `InLoadOrderModuleList`
    to get the module''s information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00343.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The problem with getting the module information from any of these three PEB
    lists is that they are susceptible to *DKOM* attacks. All three PEB lists reside
    in the user space, which means an attacker can load the malicious DLL into the
    address space of a process and can unlink the malicious DLL from one or all PEB
    lists to hide from the tools which rely on walking these lists. To overcome this
    problem, we can use another plugin named `ldrmodules`.
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Detecting a Hidden DLL Using ldrmodules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ldrmodules` plugin compares module information from the three PEB lists
    (in the process memory) with the information from a data structure residing in
    the kernel memory known as *VADs* (*Virtual Address Descriptors*). The memory
    manager uses VADs to keep track of whichvirtual addresses in the process memory
    that are reserved (or free). The VAD is a binary tree structure that stores information
    about the virtually contiguous memory regions in the process memory. For each
    process, the memory manager maintains a set of VADs and each VAD node describes
    a virtually contiguous memory region. If the process memory region contains a
    memory-mapped file (such as an executable, DLL), then the VAD node stores information
    about its base address, file path, and memory protection. The following example
    should help you understand this concept. In the following screenshot, one of the
    VAD nodes in the kernel space is describing information about where the process
    executable (*explorer.exe*) is loaded, its full path, and memory protection. Similarly,
    other VAD nodes will describe process memory ranges, including the ones that contain
    mapped executable images such as DLLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00344.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get the module''s information, the `ldrmodules` plugin enumerates all the
    VAD nodes that contain mapped executable images and compares the results with
    the three PEB lists to identify any discrepancies. The following is the module
    listing of a process from a memory image infected with the *TDSS rootkit* (which
    we saw earlier). You can see that the `ldrmodules` plugin was able to identify
    a malicious DLL called `TDSSoiqh.dll`, which hides from all the three PEB lists
    (`InLoad`, `InInit`, and `InMem`). The `InInit` value is set to `False` for `svchost.exe`, which
    is expected for an executable, as mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 7\. Dumping an Executable and DLL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you have identified the malicious process or DLL, you may want to dump
    it for further investigation (such as for extracting strings, running yara rules,
    disassembly, or scanning with Antivirus software). To dump a process executable
    from memory to disk, you can use the `procdump` plugin. To dump the process executable,
    you need to know either its process ID or its physical offset. In the following
    example of a memory image infected with *Perseus malware* (covered previously
    while discussing the `pslist` plugin), the `procdump` plugin is used to dump its
    malicious process executable `svchost..exe` (`pid 3832`). With the `-D` (`--dump-dir`)
    option, you specify the name of the directory in which to dump executable files.
    The dumped file is named based on the pid of a process such as `executable.PID.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To dump a process with the physical offset, you can use the `-o (--offset)`
    option, which is useful if you want to dump a hidden process from memory. In the
    following example of a memory image infected with `prolaco` malware (covered previously
    while discussing the `psscan` plugin), the hidden process is dumped using its
    physical offset. The physical offset was determined from the `psscan` plugin.
    You can also get the physical offset from the `psxview` plugin.  When using the
    `procdump` plugin, if you don''t specify the `-p (--pid)` or `-o (--offset)` option,
    then it will dump the process executables of all the active processes running
    on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar, to the process executable, you can dump a malicious DLL to disk using
    the `dlldump` plugin. To dump the DLL, you need to specify the process ID (`-p`
    option) of the process that loaded the DLL, and the base address of the DLL, using
    the `-b (--base)` option. You can get the base address of a DLL from the `dlllist`
    or `ldrmodules` output. In the following example of a memory image infected with
    *Ghost RAT* (which we covered while discussing the `dlllist` plugin), the malicious
    DLL loaded by the `svchost.exe` (`pid 880`) process is dumped using the `dlldump`
    plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 8\. Listing Network Connections and Sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most malicious programs perform some network activity, either to download additional
    components, to receive commands from the attacker, to exfiltrate data, or to create
    a remote backdoor on the system. Inspecting the networking activity will help
    you determine the network operations of the malware on the infected system. In
    many cases, it is useful to associate the process running on the infected system
    with the activities detected on the network. To determine the active network connections
    on pre-vista systems (such as Windows XP and 2003), you can use the `connections`
    plugin. The following command shows an example of using the `connections` plugin
    to print the active connections from a memory dump infected with *BlackEnergy*
    malware. From the following output, you can see that the process with a process
    ID of `756` was responsible for the C2 communication on port `443`. After running
    the `pslist` plugin, you can tell that the pid of `756` is associated with the
    `svchost.exe` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Another plugin that you can use to list the network connections on pre-vista
    systems is `connscan`.  It uses the pool tag scanning approach to determine the
    connections. As a result, it can also detect terminated connections. In the following
    example of the memory image infected with *TDL3* rootkit, the `connections` plugin
    does not return any results, whereas the `connscan` plugin displays the network
    connections. This does not necessarily mean that the connection is hidden, it
    just means that the network connection was not active (or terminated) when the
    memory image was acquired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you may want to get the information about the open sockets and their
    associated processes. On pre-vista systems, you can get the information about
    the open ports using the `sockets` and `sockscan` plugins. The `sockets` plugin
    prints the list of open sockets, and the `sockscan` plugin uses the pool tag scanning
    approach. As a result, it can detect the ports that have been closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Vista and later systems (such as Windows 7), you can use the `netscan` plugin
    to display both the network connections and the sockets. The `netscan` plugin
    uses the pool tag scanning approach, similar to the `sockscan` and `connscan`
    plugins. In the following example of the memory image being infected with *Darkcomet
    RAT*, the `netscan` plugin displays C2 communication on port `81`, which has been
    made by the malicious process `dmt.exe (pid 3768)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 9\. Inspecting Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From a forensics perspective, the registry can provide valuable information
    about the context of the malware. While discussing the persistence methods in
    [Chapter 7](part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485), *Malware Functionalities
    and Persistence*, you saw how malicious programs add entries in the registry to
    survive the reboot. In addition to persistence, the malware uses the registry
    to store configuration data, encryption keys, and so on. To print the registry
    key, subkeys, and its values, you can use the `printkey` plugin by providing the
    desired registry key path using the `-K` (`--key`) argument. In the following
    example of a memory image infected with *Xtreme Rat*, it adds the malicious executable
    `C:\Windows\InstallDir\system.exe` in the Run registry key. As a result, the malicious
    executable will be executed every time the system starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, the *Darkcomet RAT* adds an entry in the registry
    to load its malicious `DLL (mph.dll)` via `rundll32.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: There are other registry keys that store valuable information in binary form,
    which can be of great value to a forensic investigator. The volatility plugins
    such as `userassist`, `shellbags`, and `shimcache` parse these registry keys that
    contain binary data and display information in a much more readable format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Userassist` registry key contains a list of programs that have been executed
    by the user on the system and the time when the program was run. To print `userassist`
    registry information, you can use Volatility''s `userassist` plugin, as shown
    here. In the following example, a suspiciously named executable `(info.doc.exe)`
    was executed from the **E:\** drive (possibly the USB drive) at `2018-04-30 06:42:37`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `shimcache` and `shellbags` plugins can be useful when investigating a malware
    incident. The `shimcache` plugin can be helpful for proving the existence of a
    malware on the system and the time it ran. The `shellbags` plugin can give information
    about access to the files, folder, external storage devices, and network resources.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Investigating Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 7](part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485), *Malware
    Functionalities and Persistence*, we looked at how an attacker can persist on
    the system by installing on or modifying an existing service. In this section,
    we will focus on how to investigate services from the memory image. To list the
    services and their information such as *display name*, *type of service,* and
    *startup type* from the memory image, you can use the `svcscan` plugin. In the
    following example, the malware creates a service of type `WIN32_OWN_PROCESS` with
    the display name and service name as `svchost`. From the binary path, you can
    tell that the `svchost.exe` is malicious because it is running from the non-standard
    path *C:\Windows* instead of *C:\Windows\System32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For a service that is implemented as DLL (a service DLL), you can display the
    full path of the service DLL (or a kernel driver) by passing the `-v (--verbose)`
    option to the `svcscan` plugin. The `-v` option prints detailed information related
    to the service. The following is an example of the malware that runs a service
    as a DLL. The Service State is set to `SERVICE_START_PENDING`, and the start type
    is set to `SERVICE_AUTO_START`, which tells you that this service is not yet started
    and will be automatically started during system startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Some malicious programs hijack the existing service that is unused or disabled
    to persist on the system. An example of such a malware is *BlackEnergy*, which
    replaces a legitimate kernel driver called `aliide.sys` on the disk. This kernel
    driver is associated with a service named `aliide.` After replacing the driver,
    it modifies the registry entry associated with the `aliide` service and sets it
    to autostart (that is, the service starts automatically when the system starts).
    It is hard to detect such attacks. One method to detect such a modification is
    to keep a list of all the services from a clean memory image, and compare that
    with the list of services from the suspect image to look for any modification.
    The following is the service configuration of the aliide service from the clean
    memory image. The legitimate aliide service is set to on-demand start (the service
    needs to be manually started) and the service is in the stopped state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `svcscan` output from a memory image infected with *BlackEnergy**.***
    After modification, the `aliide` service is set to autostart (the service starts
    automatically when the system starts) and is still in the stopped state. What
    this means is that after restarting the system, the service will automatically
    start and load the malicious `aliide.sys` driver. For a detailed analysis of this
    *BlackEnergy* dropper, refer to the author''s blog post at [https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/](https://cysinfo.com/blackout-memory-analysis-of-blackenergy-big-dropper/):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 11\. Extracting Command History
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After compromising the system, an attacker may execute various commands on the
    command shell to enumerate users, groups, and shares on your network, or an attacker
    may transfer a tool such as *Mimikatz* ([https://github.com/gentilkiwi/mimikatz](https://github.com/gentilkiwi/mimikatz))
    to the comprised system and execute it to dump Windows credentials. Mimikatz is
    an open source tool that was written by Benjamin Delpy in 2011\. It is one of
    the most popular tools for gathering credentials from Windows systems. Mimikatz
    is distributed in different flavors, such as the compiled version ([https://github.com/gentilkiwi/mimikatz](https://github.com/gentilkiwi/mimikatz)),
    and is part of PowerShell Modules such as *PowerSploit* ([https://github.com/PowerShellMafia/PowerSploit](https://github.com/PowerShellMafia/PowerSploit))
    and *PowerShell Empire* ([https://github.com/EmpireProject/Empire](https://github.com/EmpireProject/Empire)).
  prefs: []
  type: TYPE_NORMAL
- en: Command history can provide valuable information about an attacker's activity
    on the compromised system. By examining the command history, you can determine
    information such as the commands that have been executed, programs invoked, and
    files and folders accessed by the attackers. The two volatility plugins, `cmdscan`,
    and `consoles` can extract command history from the memory image. These plugins
    extract the command history from `csrss.exe` (before Windows 7) or `conhost.exe`
    (Windows 7 and later versions) processes.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the detailed workings of these plugins, read the book <q class="calibre259">"The
    Art of Memory Forensics"</q> or read the research paper <q class="calibre259">"Extracting
    Windows Command Line Details from Physical Memory"</q> by Richard Stevens and
    Eoghan Casey ([http://www.dfrws.org/2010/proceedings/2010-307.pdf](http://www.dfrws.org/2010/proceedings/2010-307.pdf)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cmdscan` plugin lists the commands executed by `cmd.exe`. The following
    example gives insight into the credential-stealing activity on the system. From
    the `cmdscan` output, you can see that an application with the name `net.exe`
    was invoked via the command shell `(cmd.exe).` From the commands extracted from
    `net.exe`, you can tell that the commands `privilege::debug` and `sekurlsa::logonpasswords`
    are associated with Mimikatz. In this case, the Mimikatz application was renamed
    to `net.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cmdscan` plugin displays the commands executed by the attacker. To get
    an idea of whether the command succeeded or not, you can use the `consoles` plugin.
    After running the `consoles` plugin, you can see that `net.exe` is indeed a Mimikatz
    application and, to dump the credentials, Mimkatz commands were executed using
    the Mimikatz shell. From the output, you can tell that the credentials were successfully
    dumped and that the password was retrieved in clear text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You may not be able to dump a password in clear text using Mimikatz on Windows
    8.1 and later versions, however, Mimikatz provides various capabilities to an
    attacker. An attacker may use an extracted NTLM hash to impersonate an account.
    For detailed information on Mimikatz and how it can be used to extract Windows
    credentials, read [https://adsecurity.org/?page_id=1821](https://adsecurity.org/?page_id=1821).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory forensics is a great technique to find and extract forensic artifacts
    from the computer's memory. In addition to using memory forensics for malware investigation,
    you can use it as part of the malware analysis to gain additional information
    about the behavior and the characteristics of a malware. This chapter covered
    different Volatility plugins, which enabled you to gain an understanding of the
    events that occurred on the comprised system and provided insight into the malware's
    activity. In the next chapter, we will determine the advanced malware capabilities,
    using a few more Volatility plugins, and you will understand how to extract forensic
    artifacts using these plugins.
  prefs: []
  type: TYPE_NORMAL
