<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Detecting Advanced Malware Using Memory Forensics</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapter, we looked at different Volatility plugins, which help in extracting valuable information from the memory image. In this chapter, we will continue our journey of memory forensics and we will look at a few more plugins that will help you extract forensic artifacts from the memory image infected with advanced malware, which uses stealth and concealment techniques. In the next section, we will focus on detecting code injection techniques using memory forensics. The next section discusses some of the concepts already covered in <a href="part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 8</a>,<em class="calibre17"> Code Injection and Hooking,</em> so it is highly recommended to read that chapter before reading the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1. Detecting Code Injection</h1>
                
            
            <article>
                
<p class="calibre2">If you recall from Chapter 8, <span class="calibre7"><em class="calibre17">Code Injection and Hooking</em>, </span>code injection is a technique used for injecting malicious code (such as EXE, DLL, or shellcode) into legitimate process memory and executing the malicious code within the context of a legitimate process. To inject code into the remote process, a malware program normally allocates a memory with a protection of <kbd class="calibre13">Read</kbd>, <kbd class="calibre13">Write</kbd>, and <kbd class="calibre13">Execute</kbd> permission <kbd class="calibre13">(PAGE_EXECUTE_READWRITE)</kbd>, and then injects the code into the allocated memory of the remote process. To detect the code that is injected into the remote process, you can look for the suspicious memory ranges based on the memory protection and content of the memory. The compelling question is, what is the suspicious memory range and how do you get information about the process memory range? If you recall from the previous chapter (in the<em class="calibre17"> Detecting Hidden DLL using ldrmodules</em> section), Windows maintains a binary tree structure named <em class="calibre17">Virtual Address Descriptors (VADs)</em> in the kernel space, and each VAD node describes a virtually contiguous memory region in the process memory. If the process memory region contains a memory-mapped file (such as an executable, DLL, and so on), then one of VAD nodes stores information about its base address, file path, and the memory protection. The following depiction is not an exact representation of VAD, but it should help you understand the concept. In the following screenshot, one of the VAD nodes in the kernel space is describing the information about where the process executable (<kbd class="calibre13">explorer.exe</kbd>) is loaded, its full path, and the memory protection. Similarly, other VAD nodes will describe process memory ranges, including the ones that contain mapped executable images such as DLL. What this means is that VAD can be used to determine the memory protections of each contiguous process memory range, and it can also give information about a memory region containing a memory-mapped image file (such as an executable or DLL):</p>
<div class="cdpaligncenter"><img src="../images/00345.jpeg" class="calibre269"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.1 Getting VAD Information</h1>
                
            
            <article>
                
<p class="calibre2">To get VAD information from the memory image, you can use the <kbd class="calibre13">vadinfo</kbd> Volatility plugin. In the following example, <kbd class="calibre13">vadinfo</kbd> is used to display the memory regions of an <kbd class="calibre13">explorer.exe</kbd> process using its process ID <kbd class="calibre13">(pid 2180)</kbd>. In the following output, the first VAD node at address <kbd class="calibre13">0x8724d718</kbd> in the kernel memory describes the memory range <kbd class="calibre13">0x00db0000-0x0102ffff</kbd> in the process memory and its memory protection <kbd class="calibre13">PAGE_EXECUTE_WRITECOPY.</kbd> Since the first node is describing a memory range containing a memory-mapped executable image (<kbd class="calibre13">explorer.exe</kbd>), it also gives its full path on the disk. The second node, <kbd class="calibre13">0x8723fb50</kbd>, describes a memory range of <kbd class="calibre13">0x004b0000-0x004effff</kbd>, which does not contain any memory mapped file. Similarly, the third node at address <kbd class="calibre13">0x8723fb78</kbd> displays the information about the process memory range of <kbd class="calibre13">0x77690000-0x777cbfff</kbd>, which contains <kbd class="calibre13">ntdll.dll</kbd> and its memory protection:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f win7.vmem --profile=Win7SP1x86 vadinfo -p 2180</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/><br class="title-page-name"/>VAD node @ <strong class="calibre1">0x8724d718</strong> Start <strong class="calibre1">0x00db0000</strong> End <strong class="calibre1">0x0102ffff</strong> Tag Vadm<br class="title-page-name"/>Flags: CommitCharge: 4, Protection: 7, VadType: 2<br class="title-page-name"/>Protection: <strong class="calibre1">PAGE_EXECUTE_WRITECOPY</strong><br class="title-page-name"/>Vad Type: VadImageMap<br class="title-page-name"/>ControlArea @87240008 Segment 82135000<br class="title-page-name"/>NumberOfSectionReferences: 1 NumberOfPfnReferences: 215<br class="title-page-name"/>NumberOfMappedViews: 1 NumberOfUserReferences: 2<br class="title-page-name"/>Control Flags: Accessed: 1, File: 1, Image: 1<br class="title-page-name"/>FileObject @8723f8c0, <strong class="calibre1">Name: \Device\HarddiskVolume1\Windows\explorer.exe</strong><br class="title-page-name"/>First prototype PTE: 82135030 Last contiguous PTE: fffffffc<br class="title-page-name"/>Flags2: Inherit: 1, LongVad: 1<br class="title-page-name"/><br class="title-page-name"/>VAD node @ <strong class="calibre1">0x8723fb50</strong> Start <strong class="calibre1">0x004b0000</strong> End <strong class="calibre1">0x004effff</strong> Tag VadS<br class="title-page-name"/>Flags: CommitCharge: 43, PrivateMemory: 1, Protection: 4<br class="title-page-name"/>Protection: PAGE_READWRITE<br class="title-page-name"/>Vad Type: VadNone<br class="title-page-name"/><br class="title-page-name"/>VAD node @ <strong class="calibre1">0x8723fb78</strong> Start <strong class="calibre1">0x77690000</strong> End <strong class="calibre1">0x777cbfff</strong> Tag Vad <br class="title-page-name"/>Flags: CommitCharge: 9, Protection: 7, VadType: 2<br class="title-page-name"/>Protection: <strong class="calibre1">PAGE_EXECUTE_WRITECOPY</strong><br class="title-page-name"/>Vad Type: VadImageMap<br class="title-page-name"/>ControlArea @8634b790 Segment 899fc008<br class="title-page-name"/>NumberOfSectionReferences: 2 NumberOfPfnReferences: 223<br class="title-page-name"/>NumberOfMappedViews: 40 NumberOfUserReferences: 42<br class="title-page-name"/>Control Flags: Accessed: 1, File: 1, Image: 1<br class="title-page-name"/>FileObject @8634bc38, <strong class="calibre1">Name: \Device\HarddiskVolume1\Windows\System32\ntdll.dll</strong><br class="title-page-name"/>First prototype PTE: 899fc038 Last contiguous PTE: fffffffc<br class="title-page-name"/>Flags2: Inherit: 1<br class="title-page-name"/>[REMOVED]</pre>
<div class="packt_infobox">To get the VAD information of a process using the Windbg kernel debugger, first, you need to switch the context to the desired process using the <kbd class="calibre42">.process</kbd> command followed by the address of the <kbd class="calibre42">_EPROCESS</kbd> structure. After switching the context, use the <kbd class="calibre42">!vad</kbd> extension command to display the process memory regions.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.2 Detecting Injected Code Using VAD</h1>
                
            
            <article>
                
<p class="calibre2">An important point to note is that when an executable image (such as EXE or DLL) is normally loaded into the memory, that memory region is given a memory protection of <kbd class="calibre13">PAGE_EXECUTE_WRITECOPY(WCX)</kbd> by the operating system. An application is generally not allowed to allocate a memory with <kbd class="calibre13">PAGE_EXECUTE_WRITECOPY</kbd> protection using an API call such as <kbd class="calibre13">VirtualAllocEx.</kbd> In other words, if an attacker wants to inject a PE file (such as EXE or DLL) or shellcode, then a memory with a <kbd class="calibre13">PAGE_EXECUTE_READWRITE(RWX)</kbd> protection needs be allocated. Normally, you will see that very few memory ranges have a memory protection of <kbd class="calibre13">PAGE_EXECUTE_READWRITE.</kbd> A memory range having a protection of <kbd class="calibre13">PAGE_EXECUTE_READWRITE</kbd> is not always malicious, because a program may allocate memory with that protection for a legitimate purpose. To detect code injection, we can look for memory ranges containing a memory protection of <kbd class="calibre13">PAGE_EXECUTE_READWRITE</kbd> and examine and verify its contents to confirm the maliciousness. To help you understand this, let's take an example of a memory image infected with <em class="calibre17">SpyEye.</em> This malware injects code into a legitimate <kbd class="calibre13">explorer.exe</kbd> process (<kbd class="calibre13">pid 1608</kbd>)<kbd class="calibre13">.</kbd> The <kbd class="calibre13">vadinfo</kbd> plugin shows two memory ranges in the <kbd class="calibre13">explorer.exe</kbd> process having a suspicious memory protection of <kbd class="calibre13">PAGE_EXECUTE_READWRITE</kbd>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f spyeye.vmem --profile=Win7SP1x86 vadinfo -p 1608</strong><br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>VAD node @ 0x86fd9ca8 Start <strong class="calibre1">0x03120000</strong> End <strong class="calibre1">0x03124fff</strong> Tag VadS<br class="title-page-name"/>Flags: CommitCharge: 5, MemCommit: 1, PrivateMemory: 1, Protection: 6<br class="title-page-name"/>Protection: <strong class="calibre1">PAGE_EXECUTE_READWRITE</strong><br class="title-page-name"/>Vad Type: VadNone<br class="title-page-name"/><br class="title-page-name"/>VAD node @ 0x86fd0d00 Start <strong class="calibre1">0x03110000</strong> End <strong class="calibre1">0x03110fff</strong> Tag VadS<br class="title-page-name"/>Flags: CommitCharge: 1, MemCommit: 1, PrivateMemory: 1, Protection: 6<br class="title-page-name"/>Protection: <strong class="calibre1">PAGE_EXECUTE_READWRITE</strong><br class="title-page-name"/>Vad Type: VadNone</pre>
<p class="calibre2">Just from the memory protection, it is hard to conclude if the preceding memory regions contain any malicious code. To determine if there is any malicious code, we can dump the contents of these memory regions. To display the contents of a memory region, you can use the <kbd class="calibre13">volshell</kbd> plugin. The following command invokes <kbd class="calibre13">volshell</kbd> (an interactive Python shell) in the context of the <kbd class="calibre13">explorer.exe</kbd> process (<kbd class="calibre13">pid 1608</kbd>). The <kbd class="calibre13">db</kbd> command dumps the content of the given memory address. To get help information and display the supported <kbd class="calibre13">volshell</kbd> commands, just type <kbd class="calibre13">hh()</kbd> in the <kbd class="calibre13">volshell.</kbd> Dumping the contents of the memory address <kbd class="calibre13">0x03120000</kbd> (the first entry from the preceding <kbd class="calibre13">vadinfo</kbd> output) using the <kbd class="calibre13">db</kbd> command shows the presence of the <kbd class="calibre13">PE</kbd> file. The memory protection of <kbd class="calibre13">PAGE_EXECUTE_READWRITE</kbd> and the presence of the PE file is a clear indication that the executable was not normally loaded but was injected into the address space of the <kbd class="calibre13">explorer.exe</kbd> process:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f spyeye.vmem --profile=Win7SP1x86 volshell -p 1608</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Current context: <strong class="calibre1">explorer.exe</strong> @ 0x86eb4780, pid=1608, ppid=1572 DTB=0x1eb1a340<br class="title-page-name"/>Python 2.7.13 (default, Jan 19 2017, 14:48:08)<br class="title-page-name"/><br class="title-page-name"/>&gt;&gt;&gt; <strong class="calibre1">db(0x03120000)</strong><br class="title-page-name"/>0x03120000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 <strong class="calibre1">MZ</strong>..............<br class="title-page-name"/>0x03120010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@.......<br class="title-page-name"/>0x03120020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................<br class="title-page-name"/>0x03120030 00 00 00 00 00 00 00 00 00 00 00 00 d8 00 00 00 ................<br class="title-page-name"/>0x03120040 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 ........!..L.!Th<br class="title-page-name"/>0x03120050 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f is.program.canno<br class="title-page-name"/>0x03120060 74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 t.be.run.in.DOS.<br class="title-page-name"/>0x03120070 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00 mode....$.......</pre>
<p class="calibre2">Sometimes, displaying the contents of a memory region may not be enough to identify malicious code. This is especially true when the shellcode is injected, and in that case, you need to disassemble the content. For instance, if you dump the contents of the address <kbd class="calibre13">0x03110000</kbd> (the second entry from the preceding <kbd class="calibre13">vadinfo</kbd> output) using the <kbd class="calibre13">db</kbd> command, you will see the following hex dump. From the output, it is not easy to say if this is a malicious code:</p>
<pre class="calibre18">&gt;&gt;&gt; <strong class="calibre1">db(0x03110000)</strong><br class="title-page-name"/>0x03110000 64 a1 18 00 00 00 c3 55 8b ec 83 ec 54 83 65 fc d......U....T.e.<br class="title-page-name"/>0x03110010 00 64 a1 30 00 00 00 8b 40 0c 8b 40 1c 8b 40 08 .d.0....@..@..@.<br class="title-page-name"/>0x03110020 68 34 05 74 78 50 e8 83 00 00 00 59 59 89 45 f0 h4.txP.....YY.E.<br class="title-page-name"/>0x03110030 85 c0 74 75 8d 45 ac 89 45 f4 8b 55 f4 c7 02 6b ..tu.E..E..U...k<br class="title-page-name"/>0x03110040 00 65 00 83 c2 04 c7 02 72 00 6e 00 83 c2 04 c7 .e......r.n.....</pre>
<p class="calibre2">If you suspect that the memory region contains a shellcode, you can use the  <kbd class="calibre13">dis</kbd> command in <kbd class="calibre13">volshell</kbd> to disassemble the code at a given address. From the disassembly output that's shown in the following code, you can probably tell that a shellcode has been injected into this memory region, because it contains valid CPU instructions. To verify if the memory region contains any malicious code, you need to analyze it further in order to determine the context. This is because injected code can also look similar to the legitimate code:</p>
<pre class="calibre18">&gt;&gt;&gt; <strong class="calibre1">dis(0x03110000)</strong><br class="title-page-name"/>0x3110000 64a118000000 MOV EAX, [FS:0x18]<br class="title-page-name"/>0x3110006 c3           RET<br class="title-page-name"/>0x3110007 55           PUSH EBP<br class="title-page-name"/>0x3110008 8bec         MOV EBP, ESP<br class="title-page-name"/>0x311000a 83ec54       SUB ESP, 0x54<br class="title-page-name"/>0x311000d 8365fc00     AND DWORD [EBP-0x4], 0x0<br class="title-page-name"/>0x3110011 64a130000000 MOV EAX, [FS:0x30]<br class="title-page-name"/>0x3110017 8b400c       MOV EAX, [EAX+0xc]<br class="title-page-name"/>0x311001a 8b401c       MOV EAX, [EAX+0x1c]<br class="title-page-name"/>0x311001d 8b4008       MOV EAX, [EAX+0x8]<br class="title-page-name"/>0x3110020 6834057478   PUSH DWORD 0x78740534<br class="title-page-name"/>0x3110025 50           PUSH EAX<br class="title-page-name"/>0x3110026 e883000000   CALL 0x31100ae<br class="title-page-name"/>[REMOVED]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.3 Dumping The Process Memory Region</h1>
                
            
            <article>
                
<p class="calibre2">After you have identified the injected code (PE file or shellcode) in the process memory, you may want to dump it to disk for further analysis (for extracting strings, to perform YARA scans, or for disassembly). To dump a region of memory described by the VAD node, you can use the <kbd class="calibre13">vaddump</kbd> plugin. For example, if you want to dump the memory region containing the shellcode at address <kbd class="calibre13">0x03110000,</kbd> you can supply the <kbd class="calibre13">-b (--base)</kbd> option followed by the base address, as follows. If you don’t specify the <kbd class="calibre13">-b (--base)</kbd> option, the plugin dumps all memory regions into separate files:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f spyeye.vmem --profile=Win7SP1x86 vaddump -p 1608 -b 0x03110000 -D dump/</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Pid  Process      Start      End        Result<br class="title-page-name"/>---- -----------  ---------- ---------- ---------------------------<br class="title-page-name"/>1608 explorer.exe 0x03110000 0x03110fff dump/explorer.exe.1deb4780.0x03110000-0x03110fff.dmp</pre>
<div class="packt_infobox">Some malware programs use stealth techniques to bypass detection. For example, a malware program may inject a PE file and wipe out the PE header after it is loaded into the memory. In that case, if you are looking at the hex dump, it will not give you any indication of the presence of PE file; some level of manual analysis may be required to verify the code. An example of such a malware sample is mentioned in a blog post titled <em class="calibre22">"Recovering CoreFlood Binaries with Volatility"</em> (<a href="http://mnin.blogspot.in/2008/11/recovering-coreflood-binaries-with.html" class="calibre20">http://mnin.blogspot.in/2008/11/recovering-coreflood-binaries-with.html</a>).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">1.4 Detecting Injected Code Using malfind</h1>
                
            
            <article>
                
<p class="calibre2">So far, we have looked at identifying suspicious memory regions manually using <kbd class="calibre13">vadinfo</kbd>. You have also understood how to dump a region of memory using <kbd class="calibre13">vaddump</kbd>. There is another Volatility plugin named <kbd class="calibre13">malfind</kbd>, which automates the process of identifying suspicious memory regions based on the memory content and the VAD characteristics covered previously. In the following example, when <kbd class="calibre13">malfind</kbd> was run against the memory image infected with <em class="calibre17">SpyEye,</em> it automatically identified the suspicious memory regions (containing a PE file and shellcode). In addition to that, it also displayed the hex dump and the disassembly starting at the base address. If you do not specify the <kbd class="calibre13">-p (--pid)</kbd> option, <kbd class="calibre13">malfind</kbd> will identify suspicious memory ranges of all the processes running on the system:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f spyeye.vmem --profile=Win7SP1x86 malfind -p 1608</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/><br class="title-page-name"/>Process: <strong class="calibre1">explorer.exe</strong> Pid: 1608 Address: <strong class="calibre1">0x3120000</strong><br class="title-page-name"/>Vad Tag: VadS Protection: PAGE_EXECUTE_READWRITE<br class="title-page-name"/>Flags: CommitCharge: 5, MemCommit: 1, PrivateMemory: 1, Protection: 6<br class="title-page-name"/><br class="title-page-name"/>0x03120000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 <strong class="calibre1">MZ</strong>..............<br class="title-page-name"/>0x03120010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@.......<br class="title-page-name"/>0x03120020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................<br class="title-page-name"/>0x03120030 00 00 00 00 00 00 00 00 00 00 00 00 d8 00 00 00 ................<br class="title-page-name"/><br class="title-page-name"/>0x03120000 4d DEC EBP<br class="title-page-name"/>0x03120001 5a POP EDX<br class="title-page-name"/>0x03120002 90 NOP<br class="title-page-name"/>0x03120003 0003 ADD [EBX], AL<br class="title-page-name"/>0x03120005 0000 ADD [EAX], AL<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>Process: <strong class="calibre1">explorer.exe</strong> Pid: 1608 Address: <strong class="calibre1">0x3110000</strong><br class="title-page-name"/>Vad Tag: VadS Protection: PAGE_EXECUTE_READWRITE<br class="title-page-name"/>Flags: CommitCharge: 1, MemCommit: 1, PrivateMemory: 1, Protection: 6<br class="title-page-name"/><br class="title-page-name"/>0x03110000 64 a1 18 00 00 00 c3 55 8b ec 83 ec 54 83 65 fc d......U....T.e.<br class="title-page-name"/>0x03110010 00 64 a1 30 00 00 00 8b 40 0c 8b 40 1c 8b 40 08 .d.0....@..@..@.<br class="title-page-name"/>0x03110020 68 34 05 74 78 50 e8 83 00 00 00 59 59 89 45 f0 h4.txP.....YY.E.<br class="title-page-name"/>0x03110030 85 c0 74 75 8d 45 ac 89 45 f4 8b 55 f4 c7 02 6b ..tu.E..E..U...k<br class="title-page-name"/><br class="title-page-name"/>0x03110000 64a118000000 MOV EAX, [FS:0x18]<br class="title-page-name"/>0x03110006 c3 RET<br class="title-page-name"/>0x03110007 55 PUSH EBP<br class="title-page-name"/>0x03110008 8bec MOV EBP, ESP<br class="title-page-name"/>0x0311000a 83ec54 SUB ESP, 0x54<br class="title-page-name"/>0x0311000d 8365fc00 AND DWORD [EBP-0x4], 0x0<br class="title-page-name"/>0x03110011 64a130000000 MOV EAX, [FS:0x30]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2. Investigating Hollow Process Injection</h1>
                
            
            <article>
                
<p class="calibre2">In the case of code injection techniques covered in the previous sections, the malicious code is injected into the process address space of a legitimate process. <em class="calibre17">Hollow Process Injection</em> (or <em class="calibre17">Process Hollowing</em>) is also a code injection technique, but the difference is that in this technique, the process executable of a legitimate process in the memory is replaced with a malicious executable. Before getting into the detection of hollow process injection, let's understand how it works in the next section. The detailed information on hollow process injection was covered in <em class="calibre17"><a href="part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 8</a>, Code Injection and Hooking (section)</em>. You can also look at the author's presentation and video demos on hollow process injection (<a href="https://cysinfo.com/7th-meetup-reversing-and-investigating-malware-evasive-tactics-hollow-process-injection/" class="calibre10">https://cysinfo.com/7th-meetup-reversing-and-investigating-malware-evasive-tactics-hollow-process-injection/</a>) for a better understanding of the subject.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.1 Hollow Process Injection Steps</h1>
                
            
            <article>
                
<p class="calibre2">The following steps describe how malware normally performs process hollowing. Let’s assume that there are two processes, A and B. In this case, process A is the malicious process and process B is the legitimate process (also known as a remote process) such as <kbd class="calibre13">explorer.exe</kbd>:</p>
<ul class="calibre11">
<li class="calibre12">Process A starts a legitimate process, B, in the suspended mode. As a result of that, the executable section of process B is loaded in the memory, and the <kbd class="calibre13">PEB</kbd> (Process Environment Block) identifies the full path to the legitimate process. The PEB structure's <kbd class="calibre13">ImageBaseAddress</kbd> field points to the base address where the legitimate process executable is loaded.</li>
<li class="calibre12">Process A gets the malicious executable that will be injected into the remote process. This executable can come from the resource section of the malware process or from the file on the disk.</li>
<li class="calibre12">Process A determines the base address of the legitimate process B so that it can unmap the executable section of the legitimate process. Malware can determine the base address by reading the <kbd class="calibre13">PEB</kbd> (in our case, <kbd class="calibre13">PEB.ImageBaseAddress</kbd>).</li>
<li class="calibre12">Process A then deallocates the executable section of the legitimate process.</li>
<li class="calibre12">Process A then allocates the memory in the legitimate process B with <kbd class="calibre13">read</kbd>, <kbd class="calibre13">write</kbd>, and <kbd class="calibre13">execute</kbd> permission. This memory allocation is normally done at the same address where the executable was previously loaded.</li>
<li class="calibre12">Process A then writes the PE header and PE sections of the malicious executable to be injected into the allocated memory.</li>
<li class="calibre12">Process A then changes the start address of the suspended thread to the address of the entry point of the injected executable and resumes the suspended thread of the legitimate process. As a result of that, the legitimate process now starts executing malicious code.</li>
</ul>
<p class="calibre2"><em class="calibre17">Stuxnet</em> is one such malware that performs hollow process injection using the preceding steps. To be specific, Stuxnet creates the legitimate <kbd class="calibre13">lsass.exe</kbd> process in the suspended mode. As a result, <kbd class="calibre13">lsass.exe</kbd> is loaded into memory with <kbd class="calibre13">PAGE_EXECUTE_WRITECOPY(WCX)</kbd> protection. At this point (before hollowing), both <kbd class="calibre13">PEB</kbd> and <kbd class="calibre13">VAD</kbd> contain the same metadata information about lsass.exe's memory protection, base address, and the full path. Stuxnet then hollows out the legitimate process executable (<kbd class="calibre13">lsass.exe</kbd>) and allocates a new memory with <kbd class="calibre13">PAGE_EXECUTE_READWRITE (RWX)</kbd> protection in the same region where the <kbd class="calibre13">lsass.exe</kbd> was previously loaded, before injecting the malicious executable in the allocated memory and resuming the suspended thread. As a result of hollowing out the process executable, it creates a discrepancy in the process path information between the <kbd class="calibre13">VAD</kbd> and <kbd class="calibre13">PEB</kbd>, that is, the process path in <kbd class="calibre13">PEB</kbd> still contains the full path to <kbd class="calibre13">lsass.exe</kbd>, whereas <kbd class="calibre13">VAD</kbd> doesn't show the full path. Also, there is memory protection discrepancy before hollowing <kbd class="calibre13">(WCX)</kbd> and after hollowing <kbd class="calibre13">(RWX).</kbd> The following diagram should help you visualize what happens before hollowing, and the discrepancy it creates in <kbd class="calibre13">PEB</kbd> and <kbd class="calibre13">VAD</kbd> after hollowing the process:</p>
<div class="cdpaligncenter"><img src="../images/00346.jpeg" class="calibre41"/></div>
<div class="packt_infobox">The complete analysis of Stuxnet, using memory forensics, was covered by Michael Hale Ligh in the following blog post: <a href="http://mnin.blogspot.in/2011/06/examining-stuxnets-footprint-in-memory.html" class="calibre20">http://mnin.blogspot.in/2011/06/examining-stuxnets-footprint-in-memory.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.2 Detecting Hollow Process Injection</h1>
                
            
            <article>
                
<p class="calibre2">To detect hollow process injection, you can look for the discrepancies created between <kbd class="calibre13">PEB</kbd> and <kbd class="calibre13">VAD</kbd>, as well as the memory protection discrepancy. You can also look for the discrepancy in the parent-child process relationship. In the following <em class="calibre17">Stuxnet</em> example, you can see that there are two <kbd class="calibre13">lsass.exe</kbd> processes running on the system. The first <kbd class="calibre13">lsass.exe</kbd> process (<kbd class="calibre13">pid 708</kbd>) has a parent process of <kbd class="calibre13">winlogon.exe</kbd> (<kbd class="calibre13">pid 652</kbd>), whereas the second <kbd class="calibre13">lsass.exe</kbd> process (<kbd class="calibre13">pid 1732</kbd>) has a parent process (<kbd class="calibre13">pid 1736</kbd>) which is terminated. Based on the process information, you can tell that <kbd class="calibre13">lsass.exe</kbd> with a pid of <kbd class="calibre13">1732</kbd> is the suspicious process because, on a clean system, <kbd class="calibre13">winlogon.exe</kbd> will be the parent process of <kbd class="calibre13">lsass.exe</kbd> on pre-Vista machines and <kbd class="calibre13">wininit.exe</kbd> will be the parent process of <kbd class="calibre13">lsass.exe</kbd> on Vista and later systems:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f stux.vmem --profile=WinXPSP3x86 pslist | grep -i lsass</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>0x818c1558 lsass.exe 708 652 24 343 0 0 2016-05-10 06:47:24+0000 <br class="title-page-name"/>0x81759da0 lsass.exe 1732 1736 5 86 0 0 2018-05-12 06:39:42<br class="title-page-name"/><br class="title-page-name"/>$ <strong class="calibre1">python vol.py -f stux.vmem --profile=WinXPSP3x86 pslist -p 652</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V) Name          PID PPID Thds Hnds Sess Wow64  Start                <br class="title-page-name"/>---------- ------------ ---- ---- ---- ---- --- ------ ------------------<br class="title-page-name"/>0x818321c0 winlogon.exe 652  332  23  521    0      0  2016-05-10 06:47:24<br class="title-page-name"/><br class="title-page-name"/>$ <strong class="calibre1">python vol.py -f stux.vmem --profile=WinXPSP3x86 pslist -p 1736</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>ERROR : volatility.debug : Cannot find PID 1736. If its terminated or unlinked, use psscan and then supply --offset=OFFSET</pre>
<p class="calibre2">As mentioned earlier, you can detect hollow process injection by comparing the <kbd class="calibre13">PEB</kbd> and <kbd class="calibre13">VAD</kbd> structure. The <kbd class="calibre13">dlllist</kbd> plugin, which gets module information from the <kbd class="calibre13">PEB</kbd>, shows the full path to <kbd class="calibre13">lsass.exe</kbd> (<kbd class="calibre13">pid 1732</kbd>) and the base address <kbd class="calibre13">(0x01000000)</kbd> where it is loaded:</p>
<pre class="calibre18">lsass.exe pid: 1732<br class="title-page-name"/>Command line : "C:\WINDOWS\\system32\\lsass.exe"<br class="title-page-name"/>Service Pack 3<br class="title-page-name"/><br class="title-page-name"/>Base Size  Load    Count  Path<br class="title-page-name"/>---------- ------- ------ -------------------------------<br class="title-page-name"/><strong class="calibre1">0x01000000 0x6000  0xffff C:\WINDOWS\system32\lsass.exe</strong><br class="title-page-name"/>0x7c900000 0xaf000 0xffff C:\WINDOWS\system32\ntdll.dll<br class="title-page-name"/>0x7c800000 0xf6000 0xffff C:\WINDOWS\system32\kernel32.dll<br class="title-page-name"/>0x77dd0000 0x9b000 0xffff C:\WINDOWS\system32\ADVAPI32.dll<br class="title-page-name"/>[REMOVED]</pre>
<p class="calibre2"><span class="calibre7">The <kbd class="calibre13">ldrmodules</kbd> plugin, which relies on VAD in the kernel, does not show the full path name to the <kbd class="calibre13">lsass.exe.</kbd> As a result of malware</span> unmapping <span class="calibre7">the <kbd class="calibre13">lsass.exe</kbd> process executable section, the full</span> path name <span class="calibre7">is no longer associated with the address <kbd class="calibre13">0x01000000</kbd>:</span></p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f stux.vmem --profile=WinXPSP3x86 ldrmodules -p 1732</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Pid  Process   Base       InLoad InInit InMem    MappedPath<br class="title-page-name"/>---- --------- ---------- ------ ------ ------ ----------------------------<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>1732 lsass.exe 0x7c900000 True  True   True   \WINDOWS\system32\ntdll.dll<br class="title-page-name"/>1732 lsass.exe 0x71ad0000 True  True   True   \WINDOWS\system32\wsock32.dll<br class="title-page-name"/>1732 lsass.exe 0x77f60000 True  True   True   \WINDOWS\system32\shlwapi.dll<br class="title-page-name"/><strong class="calibre1">1732 lsass.exe 0x01000000 True  False  True</strong> <br class="title-page-name"/>1732 lsass.exe 0x76b40000 True  True   True   \WINDOWS\system32\winmm.dll<br class="title-page-name"/>[REMOVED]</pre>
<p class="calibre2">Since the malware normally allocates memory with <kbd class="calibre13">PAGE_EXECUTE_READWRITE</kbd> permission after hollowing and before injecting the executable, you can look for that memory protection. The <kbd class="calibre13">malfind</kbd> plugin identified the suspicious memory protection at the same address <kbd class="calibre13">(0x01000000)</kbd> where the executable <kbd class="calibre13">lsass.exe</kbd> was loaded:</p>
<pre class="calibre18">Process: lsass.exe Pid: 1732 Address: <strong class="calibre1">0x1000000</strong><br class="title-page-name"/>Vad Tag: Vad Protection: <strong class="calibre1">PAGE_EXECUTE_READWRITE</strong><br class="title-page-name"/>Flags: CommitCharge: 2, Protection: 6<br class="title-page-name"/><br class="title-page-name"/>0x01000000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 <strong class="calibre1">MZ</strong>..............<br class="title-page-name"/>0x01000010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@.......<br class="title-page-name"/>0x01000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................<br class="title-page-name"/>0x01000030 00 00 00 00 00 00 00 00 00 00 00 00 d0 00 00 00 ................<br class="title-page-name"/><br class="title-page-name"/>0x01000000 4d DEC EBP<br class="title-page-name"/>0x01000001 5a POP EDX<br class="title-page-name"/>0x01000002 90 NOP</pre>
<p class="calibre2">If you wish to dump the suspicious memory regions detected by <kbd class="calibre13">malfind</kbd> to disk, you can specify <kbd class="calibre13">-D</kbd>  followed by the directory name where all the suspicious memory regions will be dumped.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">2.3 Hollow Process Injection Variations</h1>
                
            
            <article>
                
<p class="calibre2">In the following example, we will look at a malware named <em class="calibre17">Skeeyah</em>, which performs hollow process injection in a slightly different way. This is the same sample which was covered in <a href="part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 8</a>,<em class="calibre17"> Code Injection and Hooking (section 3.6 Hollow Process Injection)</em>. The following are the steps performed by <em class="calibre17">Skeeyah</em>:</p>
<ul class="calibre11">
<li class="calibre12">It starts the <kbd class="calibre13">svchost.exe</kbd> process in the suspended mode. As a result, <kbd class="calibre13">svchost.exe</kbd> is loaded into the memory (in this case, at address <kbd class="calibre13">0x1000000</kbd>).</li>
<li class="calibre12">It determines the base address of <kbd class="calibre13">svchost.exe</kbd> by reading <kbd class="calibre13">PEB.ImageBaseAddress</kbd> and then deallocates the executable section of <kbd class="calibre13">svchost.exe</kbd>.</li>
<li class="calibre12">Instead of allocating memory in the same region where the <kbd class="calibre13">svchost.exe</kbd> was previously loaded (<kbd class="calibre13">0x1000000</kbd>), it allocates memory in a different address, <kbd class="calibre13">0x00400000</kbd>, with <kbd class="calibre13">read</kbd>, <kbd class="calibre13">write</kbd>, and <kbd class="calibre13">execute</kbd> permission.</li>
<li class="calibre12">It then overwrites the <kbd class="calibre13">PEB.ImageBaseAdress</kbd> of the <kbd class="calibre13">svchost.exe</kbd> process with the newly allocated address, <kbd class="calibre13">0x00400000.</kbd> This changes the base address of <kbd class="calibre13">svchost.exe</kbd> in the <kbd class="calibre13">PEB</kbd> from <kbd class="calibre13">0x1000000</kbd> to <kbd class="calibre13">0x00400000</kbd> (which contains injected executables).</li>
<li class="calibre12">It then changes the start address of the suspended thread to the address of the entry point of the injected executable and resumes the thread.</li>
</ul>
<p class="calibre2">The following screenshot shows the discrepancy before and after hollowing. To be specific, the PEB after hollowing thinks that <kbd class="calibre13">svchost.exe</kbd> is loaded at <kbd class="calibre13">0x00400000</kbd>.  The <kbd class="calibre13">VAD</kbd> node that previously represented <kbd class="calibre13">svchost.exe</kbd> (loaded at <kbd class="calibre13">0x1000000</kbd>) is no longer present, because when the malware hollowed out the <kbd class="calibre13">svchost.exe</kbd> process executable, the entry for that was removed from the <kbd class="calibre13">VAD</kbd> tree:</p>
<div class="cdpaligncenter"><img src="../images/00347.jpeg" class="calibre41"/></div>
<p class="calibre2">To detect this variation of hollow process injection, you can follow the same methodology. Depending on how the hollow process injection is performed, the results will vary. The process listing shows multiple instances of the <kbd class="calibre13">svchost.exe</kbd> process, which is normal. All the <kbd class="calibre13">svchost.exe</kbd> processes except the last <kbd class="calibre13">svchost.exe (pid 1824)</kbd> have a parent process of <kbd class="calibre13">services.exe</kbd> <kbd class="calibre13">(pid 696)</kbd>. On a clean system, all the <kbd class="calibre13">svchost.exe</kbd> process are started by <kbd class="calibre13">services.exe</kbd>. When you look at the parent process of <kbd class="calibre13">svchost.exe</kbd> <kbd class="calibre13">(pid 1824)</kbd> you can see that its parent process is terminated. Based on the process information, you can tell that the last <kbd class="calibre13">svchost.exe (pid 1824)</kbd> is suspicious:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f skeeyah.vmem --profile=WinXPSP3x86 pslist | grep -i svchost</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>0x815cfaa0 svchost.exe  876  696  20  202  0 0 2016-05-10 06:47:25<br class="title-page-name"/>0x818c5a78 svchost.exe  960  696   9  227  0 0 2016-05-10 06:47:25<br class="title-page-name"/>0x8181e558 svchost.exe 1044  696  68  1227 0 0 2016-05-10 06:47:25<br class="title-page-name"/>0x818c7230 svchost.exe 1104  696   5  59   0 0 2016-05-10 06:47:25<br class="title-page-name"/>0x81743da0 svchost.exe 1144  696  15  210  0 0 2016-05-10 06:47:25<br class="title-page-name"/>0x817ba390 <strong class="calibre1">svchost.exe 1824 1768</strong>   1  26   0 0 2016-05-12 14:43:43<br class="title-page-name"/><br class="title-page-name"/>$ <strong class="calibre1">python vol.py -f skeeyah.vmem --profile=WinXPSP3x86 pslist -p 696</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V)  Name         PID PPID Thds Hnds Sess Wow64  Start  <br class="title-page-name"/>---------- ------------ --- ---- ---- ---- ---- ------ --------------------<br class="title-page-name"/>0x8186c980 services.exe 696 652   16  264   0    0     2016-05-10 06:47:24<br class="title-page-name"/><br class="title-page-name"/>$ <strong class="calibre1">python vol.py -f skeeyah.vmem --profile=WinXPSP3x86 pslist -p 1768</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>ERROR : volatility.debug : Cannot find PID 1768. If its terminated or unlinked, use psscan and then supply --offset=OFFSET</pre>
<p class="calibre2">The <kbd class="calibre13">dlllist</kbd> plugin (which relies on <kbd class="calibre13">PEB</kbd>) shows the full path to <kbd class="calibre13">svchost.exe</kbd> (<kbd class="calibre13">pid 1824</kbd>) and reports the base address as <kbd class="calibre13">0x00400000</kbd>.</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f skeeyah.vmem --profile=WinXPSP3x86 dlllist -p 1824</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>************************************************************************<br class="title-page-name"/>svchost.exe pid: 1824<br class="title-page-name"/>Command line : "C:\WINDOWS\system32\svchost.exe"<br class="title-page-name"/>Service Pack 3<br class="title-page-name"/><br class="title-page-name"/>Base       Size    LoadCount  Path<br class="title-page-name"/>---------- ------- ---------- ----------------------------------<br class="title-page-name"/><strong class="calibre1">0x00400000 0x7000   0xffff     C:\WINDOWS\system32\svchost.exe</strong><br class="title-page-name"/>0x7c900000 0xaf000  0xffff     C:\WINDOWS\system32\ntdll.dll<br class="title-page-name"/>0x7c800000 0xf6000  0xffff     C:\WINDOWS\system32\kernel32.dll<br class="title-page-name"/>[REMOVED]</pre>
<p class="calibre2">On the other hand, the <kbd class="calibre13">ldrmodules</kbd> plugin (which relies on VAD in the kernel) does not show any entry for <kbd class="calibre13">svchost.exe</kbd>, as shown in the following screenshot:</p>
<div class="cdpaligncenter"><img src="../images/00348.jpeg" class="calibre270"/></div>
<p class="calibre2"><kbd class="calibre13">malfind</kbd> shows the presence of a PE file at address <kbd class="calibre13">0x00400000</kbd> with a suspicious memory protection of <kbd class="calibre13">PAGE_EXECUTE_READWRITE</kbd>, indicating that this executable was injected and not normally loaded:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f skeeyah.vmem --profile=WinXPSP3x86 malfind -p 1824</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Process: svchost.exe Pid: 1824 Address: <strong class="calibre1">0x400000</strong><br class="title-page-name"/>Vad Tag: VadS Protection: <strong class="calibre1">PAGE_EXECUTE_READWRITE</strong><br class="title-page-name"/>Flags: CommitCharge: 7, MemCommit: 1, PrivateMemory: 1, Protection: 6<br class="title-page-name"/><br class="title-page-name"/>0x00400000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 <strong class="calibre1">MZ</strong>..............<br class="title-page-name"/>0x00400010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@.......<br class="title-page-name"/>0x00400020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................<br class="title-page-name"/>0x00400030 00 00 00 00 00 00 00 00 00 00 00 00 e0 00 00 00 ................<br class="title-page-name"/><br class="title-page-name"/>0x00400000 4d DEC EBP<br class="title-page-name"/>0x00400001 5a POP EDX<br class="title-page-name"/>[REMOVED]</pre>
<div class="packt_infobox">Attackers use different variations of hollow process injection to bypass, deflect, and divert forensic analysis. For detailed information on how these evasive techniques work and how to detect them using a custom Volatility plugin, watch the author's Black Hat presentation titled: <em class="calibre22">"What Malware Authors Don't Want You to Know - Evasive Hollow Process Injection"</em> (<a href="https://youtu.be/9L9I1T5QDg4" class="calibre20">https://youtu.be/9L9I1T5QDg4</a>). Alternatively, you can read the author's blog post at the following link: <a href="https://cysinfo.com/detecting-deceptive-hollowing-techniques/" class="calibre20">https://cysinfo.com/detecting-deceptive-hollowing-techniques/</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">3. Detecting API Hooks</h1>
                
            
            <article>
                
<p class="calibre2">After injecting the malicious code into the target process, malware can hook API calls made by the target process to control its execution path and reroute it to the malicious code. The details of hooking techniques were covered in <a href="part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 8,</a><em class="calibre17"> Code Injection and Hooking (</em>in the <em class="calibre17">Hooking Techniques</em> section). In this section, we will mainly focus on detecting such hooking techniques using memory forensics. To identify API hooks in both processes and kernel memory, you can use the <kbd class="calibre13">apihooks</kbd> Volatility plugin. In the following example of <em class="calibre17">Zeus bot</em>, an executable is injected into the <kbd class="calibre13">explorer.exe</kbd> process's memory at address <kbd class="calibre13">0x2c70000</kbd>, as detected by the <kbd class="calibre13">malfind</kbd> plugin:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f zeus.vmem --profile=Win7SP1x86 malfind</strong><br class="title-page-name"/><br class="title-page-name"/>Process: <strong class="calibre1">explorer.exe</strong> Pid: 1608 Address: <strong class="calibre1">0x2c70000</strong><br class="title-page-name"/>Vad Tag: Vad Protection: <strong class="calibre1">PAGE_EXECUTE_READWRITE</strong><br class="title-page-name"/>Flags: Protection: 6<br class="title-page-name"/><br class="title-page-name"/>0x02c70000 4d 5a 00 00 00 00 00 00 00 00 00 00 00 00 00 00 <strong class="calibre1">MZ</strong>..............<br class="title-page-name"/>0x02c70010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................<br class="title-page-name"/>0x02c70020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................<br class="title-page-name"/>0x02c70030 00 00 00 00 00 00 00 00 00 00 00 00 d8 00 00 00 ................</pre>
<p class="calibre2">In the following output, the <kbd class="calibre13">apihooks</kbd> plugin detects the hook in the user-mode API <kbd class="calibre13">HttpSendRequestA</kbd> (in <kbd class="calibre13">wininet.dll</kbd>). The hooked API is then redirected to address <kbd class="calibre13">0x2c7ec48</kbd> (hook address). The hook address falls within the address range of the injected executable (hooking module). The name of the hooking module is unknown, because it is not normally loaded from the disk (but injected). To be specific, at the start address (<kbd class="calibre13">0x753600fc</kbd>) of the API function <kbd class="calibre13">HttpSendRequestA</kbd>, there is a jump instruction which redirects the execution flow of <kbd class="calibre13">HttpSendRequestA</kbd> to address <kbd class="calibre13">0x2c7ec48</kbd> within the injected executable:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f zeus.vmem --profile=Win7SP1x86 apihooks -p 1608</strong><br class="title-page-name"/><br class="title-page-name"/>Hook mode: Usermode<br class="title-page-name"/>Hook type: Inline/Trampoline<br class="title-page-name"/>Process: 1608 (explorer.exe)<br class="title-page-name"/>Victim module: wininet.dll (0x752d0000 - 0x753c4000)<br class="title-page-name"/>Function: <strong class="calibre1">wininet.dll!HttpSendRequestA at 0x753600fc</strong><br class="title-page-name"/>Hook address: <strong class="calibre1">0x2c7ec48</strong><br class="title-page-name"/>Hooking module: <strong class="calibre1">&lt;unknown&gt;</strong><br class="title-page-name"/><br class="title-page-name"/>Disassembly(0):<br class="title-page-name"/><strong class="calibre1">0x753600fc e947eb918d   JMP 0x2c7ec48</strong><br class="title-page-name"/>0x75360101 83ec38       SUB ESP, 0x38<br class="title-page-name"/>0x75360104 56           PUSH ESI<br class="title-page-name"/>0x75360105 6a38         PUSH 0x38<br class="title-page-name"/>0x75360107 8d45c8       LEA EAX, [EBP-0x38]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">4. Kernel Mode Rootkits</h1>
                
            
            <article>
                
<p class="calibre2">A malicious program such as rootkit can load a kernel driver to run the code in kernel mode. Once it's running in the kernel space, it has access to the internal operating system code and it can monitor system events, evade detection by modifying the internal data structures, hook functions, and modify the call tables. A kernel mode driver typically has an extension of <kbd class="calibre13">.sys</kbd> and it resides in <kbd class="calibre13">%windir%\system32\drivers</kbd>. A kernel driver is normally loaded by creating a service of type <em class="calibre17">Kernel Driver Service</em> (as described in <a href="part0219.html#6GRB60-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 7</a><em class="calibre17">, <span class="calibre7">Malware Functionalities and Persistence, </span></em>in the <em class="calibre17">Service</em> section).</p>
<p class="calibre2">Windows has implemented various security mechanisms that are designed to prevent the execution of unauthorized code in the kernel space. This makes it difficult for a rootkit to install the kernel drivers. On 64-bit Windows, Microsoft implemented <em class="calibre17">Kernel-Mode Code Signing (KMCS)</em>, which requires the kernel mode drivers to be digitally signed in order to be loaded into memory. Another security mechanism is <em class="calibre17">Kernel Patch Protection (KPP)</em>, also known as <em class="calibre17">PatchGuard</em>, which prevents modifications to core system components, data structures, and call tables (such as SSDT, IDT, and so on). These security mechanisms are effective against most rootkits, but at the same time, this has forced the attackers to come up with advanced techniques that allow them to install unsigned drivers and to bypass these security mechanisms. One method is to install a <em class="calibre17">Bootkit</em>. A Bootkit infects the early stages of the system startup process, even before the operating system is fully loaded. Another method is to exploit vulnerabilities in the kernel or third-party driver to install an unsigned driver. For the rest of this chapter, we will assume that an attacker has managed to install the kernel mode driver (using <em class="calibre17">Bootkit</em> or by exploiting a kernel-level vulnerability), and we will focus on kernel memory forensics, which involves identifying the malicious driver.</p>
<p class="calibre2">On a clean windows system, you will find hundreds of kernel modules, so finding the malicious kernel module requires some work. In the following sections, we will look at some of the common techniques to locate and extract malicious kernel modules. We will start by listing the kernel modules.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">5. Listing Kernel Modules</h1>
                
            
            <article>
                
<p class="calibre2">To list the kernel modules, you can use the <kbd class="calibre13">modules</kbd> plugin. This plugin relies on walking the doubly linked list of metadata structures (<kbd class="calibre13">KLDR_DATA_TABLE_ENTRY</kbd>) pointed to by <kbd class="calibre13">PsLoadedModuleList</kbd> (this technique is similar to walking the doubly linked list of <kbd class="calibre13">_EPROCESS</kbd> structures, as described in <a href="part0300.html#8U38O0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 10</a><em class="calibre17">, <span class="calibre7">Hunting Malware Using Memory Forensics</span><span class="calibre7">,</span></em> <span class="calibre7">in the</span><em class="calibre17"> Understanding ActiveProcessLinks</em> section<em class="calibre17">)</em>. Listing kernel modules may not always help you identify the malicious kernel driver out of the hundreds of loaded kernel modules, but it can be useful for spotting a suspicious indicator such as a kernel driver having a weird name, or kernel modules loading from non-standard paths or the temporary paths. The <kbd class="calibre13">modules</kbd> plugin lists the kernel modules in the order in which they were loaded, which means that if a rootkit driver was recently installed, you are very likely to find that module at the end of the list, provided the module is not hidden and the system was not rebooted before the memory image was acquired.</p>
<p class="calibre2">In the following example of a memory image infected with the <em class="calibre17">Laqma</em> rootkit, the module listing shows the malicious driver of <em class="calibre17">Laqma,</em> <kbd class="calibre13">lanmandrv.sys</kbd>, at the end of the list running from the <kbd class="calibre13">C:\Windows\System32</kbd> directory, whereas most of the other kernel drivers are loaded from <kbd class="calibre13"><em class="calibre19">S</em>ystemRoot\System32\DRIVERS\</kbd><em class="calibre17">.</em> From the listing, you can also see that the core operating system components such as the NT kernel module (<kbd class="calibre13">ntkrnlpa.exe</kbd> or <kbd class="calibre13">ntoskrnl.exe</kbd>) and the hardware abstraction layer <kbd class="calibre13">(hal.dll)</kbd> are loaded first, followed by the boot drivers (such as <kbd class="calibre13">kdcom.dll</kbd>) which start automatically at the boot time and then followed by other drivers:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f laqma.vmem --profile=Win7SP1x86 modules</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V)  Name          Base       Size     File<br class="title-page-name"/>---------- ------------  ---------- -------- ---------------------------------<br class="title-page-name"/>0x84f41c98 ntoskrnl.exe 0x8283d000 0x410000 \SystemRoot\system32\ntkrnlpa.exe<br class="title-page-name"/>0x84f41c20 hal.dll      0x82806000 0x37000  \SystemRoot\system32\halmacpi.dll<br class="title-page-name"/>0x84f41ba0 kdcom.dll    0x80bc5000 0x8000   \SystemRoot\system32\kdcom.dll<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>0x86e36388 srv2.sys     0xa46e1000 0x4f000  \SystemRoot\System32\DRIVERS\srv2.sys<br class="title-page-name"/>0x86ed6d68 srv.sys      0xa4730000 0x51000  \SystemRoot\System32\DRIVERS\srv.sys<br class="title-page-name"/>0x86fe8f90 spsys.sys    0xa4781000 0x6a000  \SystemRoot\system32\drivers\spsys.sys<br class="title-page-name"/><strong class="calibre1">0x861ca0d0 lanmandrv.sys 0xa47eb000 0x2000  \??\C:\Windows\System32\lanmandrv.sys</strong></pre>
<p class="calibre2">Since walking the doubly linked list is susceptible to DKOM attacks (described in <a href="part0300.html#8U38O0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 10</a><em class="calibre17">, <span class="calibre7">Hunting Malware Using Memory Forensics,</span> section 4.2.1 Direct Kernel Object Manipulation (DKOM)</em>), it is possible to hide a kernel driver from the listing by unlinking it. To overcome this problem, you can use another plugin named <kbd class="calibre13">modscan.</kbd> The <kbd class="calibre13">modscan</kbd> plugin relies on the pool tag scanning approach (covered in <a href="https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=1250&amp;action=edit#post_1143" class="calibre10">Chapter 10</a><em class="calibre17">, <span class="calibre7">Hunting Malware Using Memory Forensics</span></em><em class="calibre17">, section 4.2.2 Understanding Pool Tag Scanning</em>). In other words, it scans the physical address space looking for the pool tag (<kbd class="calibre13">MmLd</kbd>) associated with the kernel module. As a result of pool tag scanning, it can detect unlinked modules and the previously loaded modules. The <kbd class="calibre13">modscan</kbd> plugin displays the kernel modules in the order in which they were found in the physical address space, and not based on the order in which they were loaded. In the following example of the <em class="calibre17">Necurs</em> rootkit, the <kbd class="calibre13">modscan</kbd> plugin displays the malicious kernel driver (<kbd class="calibre13">2683608180e436a1.sys</kbd>) whose name is composed entirely of hex characters:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f necurs.vmem --profile=Win7SP1x86 modscan</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(P)          Name                 Base       Size   File<br class="title-page-name"/>------------------ -------------------- ---------- ------ --------<br class="title-page-name"/>0x0000000010145130 Beep.SYS             0x880f2000 0x7000 \SystemRoot\System32\Drivers\Beep.SYS<br class="title-page-name"/>0x000000001061bad0 secdrv.SYS           0xa46a9000 0xa000 \SystemRoot\System32\Drivers\secdrv.SYS<br class="title-page-name"/>0x00000000108b9120 rdprefmp.sys         0x88150000 0x8000 \SystemRoot\system32\drivers\rdprefmp.sys<br class="title-page-name"/>0x00000000108b9b10 USBPORT.SYS          0x9711e000 0x4b000 \SystemRoot\system32\DRIVERS\USBPORT.SYS<br class="title-page-name"/>0x0000000010b3b4a0 rdbss.sys            0x96ef6000 0x41000 \SystemRoot\system32\DRIVERS\rdbss.sys<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/><strong class="calibre1">0x000000001e089170 2683608180e436a1.sys 0x851ab000 0xd000 \SystemRoot\System32\Drivers\2683608180e436a1.sys</strong><br class="title-page-name"/>0x000000001e0da478 usbccgp.sys          0x9700b000 0x17000 \SystemRoot\system32\DRIVERS\usbccgp.sys</pre>
<p class="calibre2">When you run the <kbd class="calibre13">modules</kbd> plugin against the memory image infected with the <em class="calibre17">Necurs</em> rootkit, it does not display that malicious driver (<kbd class="calibre13">2683608180e436a1.sys</kbd>):</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f necurs.vmem --profile=Win7SP1x86 modules | grep 2683608180e436a1</strong></pre>
<p class="calibre2">Since <kbd class="calibre13">modscan</kbd> uses the pool tag scanning approach, which can detect unloaded modules (provided that the memory has not been overwritten), it is possible that the malicious driver, <kbd class="calibre13">2683608180e436a1.sys</kbd> was quickly loaded and unloaded, or that it is hidden. To confirm whether the driver was unloaded or hidden, you can use the <kbd class="calibre13">unloadedmodules</kbd> plugin, which will display the list of unloaded modules and the time when each one was unloaded. In the following output, absence of the malicious driver, <kbd class="calibre13">2683608180e436a1.sys</kbd>, tells you that this driver was not unloaded and it is hidden. From the following output, you can see another malicious driver called <kbd class="calibre13">2b9fb.sys</kbd> which was previously loaded and unloaded quickly (not present in the <kbd class="calibre13">modules</kbd> and <kbd class="calibre13">modscan</kbd> listing which is shown in the following code). The <kbd class="calibre13">unloadedmodules</kbd> plugin can prove to be useful during the investigation to detect the rootkit's attempt to quickly load and unload the driver so that it does not show up in the module listing:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f necurs.vmem --profile=Win7SP1x86 unloadedmodules</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Name              StartAddress EndAddress Time<br class="title-page-name"/>----------------- ------------ ---------- -------------------<br class="title-page-name"/>dump_dumpfve.sys  0x00880bb000 0x880cc000 2016-05-11 12:15:08 <br class="title-page-name"/>dump_LSI_SAS.sys  0x00880a3000 0x880bb000 2016-05-11 12:15:08 <br class="title-page-name"/>dump_storport.sys 0x0088099000 0x880a3000 2016-05-11 12:15:08 <br class="title-page-name"/>parport.sys       0x0094151000 0x94169000 2016-05-11 12:15:09 <br class="title-page-name"/><strong class="calibre1">2b9fb.sys         0x00a47eb000 0xa47fe000 2018-05-21 10:57:52</strong> <br class="title-page-name"/><br class="title-page-name"/>$ <strong class="calibre1">python vol.py -f necurs.vmem --profile=Win7SP1x86 modules | grep -i 2b9fb.sys</strong><br class="title-page-name"/>$ <strong class="calibre1">python vol.py -f necurs.vmem --profile=Win7SP1x86 modscan | grep -i 2b9fb.sys</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">5.1 Listing Kernel Modules Using driverscan</h1>
                
            
            <article>
                
<p class="calibre2">Another method for listing the kernel modules is to use the <kbd class="calibre13">driverscan</kbd> plugin, as shown in the following code. The <kbd class="calibre13">driverscan</kbd> plugin gets the information related to kernel modules from a structure named <kbd class="calibre13">DRIVER_OBJECT.</kbd> To be specific, the <kbd class="calibre13">driverscan</kbd> plugin uses pool tag scanning to find the driver objects in the physical address space. The first column, <kbd class="calibre13">Offset(P)</kbd>, specifies the physical address where the <kbd class="calibre13">DRIVER_OBJECT</kbd> structure was found, the second column, <kbd class="calibre13">Start</kbd>, contains the base address of the module, and the <kbd class="calibre13">Driver Name</kbd> column displays the name of the Driver. For example, the driver name <kbd class="calibre13">\Driver\Beep</kbd> is the same as <kbd class="calibre13">Beep.sys</kbd>, and the last entry shows the malicious driver, <kbd class="calibre13">\Driver\2683608180e436a1</kbd>, associated with the <em class="calibre17">Necurs</em> rootkit. The <kbd class="calibre13">driverscan</kbd> plugin is another way of listing the kernel modules and can be useful when the rootkit tries to hide from the <kbd class="calibre13">modules</kbd> and the <kbd class="calibre13">modscan</kbd> plugin:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f necurs.vmem --profile=Win7SP1x86 driverscan</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(P)           Start     Size   Service Key  Name   Driver Name<br class="title-page-name"/>------------------ --------  ------- ----------- ------ -----------<br class="title-page-name"/>0x00000000108b9030 0x88148000 0x8000  RDPENCDD  RDPENCDD \Driver\RDPENCDD<br class="title-page-name"/>0x00000000108b9478 0x97023000 0xb7000 DXGKrnl   DXGKrnl  \Driver\DXGKrnl<br class="title-page-name"/>0x00000000108b9870 0x88150000 0x8000  RDPREFMP  RDPREFMP \Driver\RDPREFMP<br class="title-page-name"/>0x0000000010b3b1d0 0x96ef6000 0x41000 rdbss     rdbss    \FileSystem\rdbss<br class="title-page-name"/>0x0000000011781188 0x88171000 0x17000 tdx       tdx      \Driver\tdx<br class="title-page-name"/>0x0000000011ff6a00 0x881ed000 0xd000  kbdclass  kbdclass \Driver\kbdclass<br class="title-page-name"/>0x0000000011ff6ba0 0x880f2000 0x7000  Beep      Beep     \Driver\Beep<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/><strong class="calibre1">0x000000001e155668 0x851ab000 0xd000 2683608180e436a1 26836...36a1 \Driver\2683608180e436a1</strong></pre>
<p class="calibre2">To list the kernel modules with the kernel debugger (Windbg), use the <kbd class="calibre13">lm k</kbd> command as follows. For verbose output, you can use the <kbd class="calibre13">lm kv</kbd> command:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">lm k</strong><br class="title-page-name"/>start end module name<br class="title-page-name"/>80bb4000 80bbc000 kdcom (deferred) <br class="title-page-name"/>82a03000 82a3a000 hal (deferred) <br class="title-page-name"/>82a3a000 82e56000 nt (pdb symbols)<br class="title-page-name"/>8b200000 8b20e000 WDFLDR (deferred) <br class="title-page-name"/>8b20e000 8b22a800 vmhgfs (deferred) <br class="title-page-name"/>8b22b000 8b2b0000 mcupdate_GenuineIntel (deferred) <br class="title-page-name"/>8b2b0000 8b2c1000 PSHED (deferred) <br class="title-page-name"/>8b2c1000 8b2c9000 BOOTVID (deferred) <br class="title-page-name"/>8b2c9000 8b30b000 CLFS (deferred) <br class="title-page-name"/>[REMOVED]</pre>
<p class="calibre2">After you identify the malicious kernel module, you can dump it from memory to disk using the <kbd class="calibre13">moddump</kbd> plugin. To dump the module to disk, you need to specify the base address of the module, which you can get from the <kbd class="calibre13">modules</kbd>, <kbd class="calibre13">modscan</kbd>, or <kbd class="calibre13">driverscan</kbd> plugins. In the following example, the malicious driver of the <em class="calibre17">Necurs rootkit</em> is dumped to disk using its base address, as follows:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f necurs.vmem --profile=Win7SP1x86 moddump -b 0x851ab000 -D dump/</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Module Base   Module Name      Result<br class="title-page-name"/>-----------  --------------    ------<br class="title-page-name"/>0x0851ab000    UNKNOWN         OK: driver.851ab000.sys</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6. I/O Processing</h1>
                
            
            <article>
                
<p class="calibre2">While discussing the <kbd class="calibre13">driverscan</kbd> plugin, I had mentioned that <kbd class="calibre13">driverscan</kbd> gets module information from the <kbd class="calibre13">DRIVER_OBJECT</kbd> structure. Are you wondering what the <kbd class="calibre13">DRIVER_OBJECT</kbd> structure is? This will become clear soon. In this section, you will understand the interaction between the user-mode and kernel-mode components, the role of the device driver, and its interaction with the I/O manager. Typically, a rootkit consists of a user-mode component (EXE or DLL) and a kernel mode component (device driver). The user-mode component of the rootkit communicates with the kernel-mode components, using a specific mechanism. From a forensics standpoint, it is essential to understand how these communications work and the components involved. This section will help you understand the communication mechanism and lays the foundation for the upcoming topics.</p>
<p class="calibre2">Let's try to understand what happens when a user-mode application performs input/output (I/O) operations, and how it is processed at a high level. While discussing the API call flow in <a href="part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 8</a>, <em class="calibre17"><span class="calibre7">Code Injection and Hooking</span></em> (in the <em class="calibre17">Windows API call flow</em> section), I used the example of a user-mode application performing a write operation using the <kbd class="calibre13">WriteFile()</kbd> API, which ends up calling the <kbd class="calibre13">NtWriteFile()</kbd> system service routine in the kernel executive <kbd class="calibre13">(ntoskrnl.exe)</kbd>, which then directs the request to the I/O manager, whereupon the I/O manager requests the device driver to perform the I/O operation. Here, I will revisit that topic again with a little more detail and with an emphasis on the kernel-space components (mainly the device driver and the I/O manager). The following diagram illustrates the flow of the write request (other types of I/O requests, such as read, are similar; they just use different APIs):</p>
<div class="cdpaligncenter"><img src="../images/00349.jpeg" class="calibre41"/></div>
<p class="calibre2">The following points discuss the role of the device driver and the I/O manager at a high level:</p>
<ol class="calibre14">
<li class="calibre12" value="1">The device driver typically creates a device or multiple devices and specifies what type of operations (open, read, and write) it can handle for the device. It also specifies the address of routines that handle these operations. These routines are called dispatch routines or IRP handlers.</li>
</ol>
<ol start="2" class="calibre14">
<li class="calibre12" value="2">After creating the device, the driver advertises that device so that it is accessible to user-mode applications.</li>
<li class="calibre12" value="3">The user mode application can use API calls, such as <kbd class="calibre13">CreateFile</kbd>, to open handle the advertised device and perform I/O operations such as read, and write on the device using the <kbd class="calibre13">ReadFile</kbd> and <kbd class="calibre13">WriteFile</kbd> APIs. APIs, such as <kbd class="calibre13">CreateFile</kbd>, <kbd class="calibre13">ReadWrite</kbd>, and <kbd class="calibre13">WriteFile</kbd>, that are used to perform I/O operations on the file also work on a device. This is because the device is treated as a virtual file.</li>
<li class="calibre12" value="4">When the I/O operation is performed on the advertised device by the user mode application, the request is routed to the I/O manager. The I/O manager determines the driver that handles the device and requests the driver to complete the operation by passing an IRP (I/O request packet). An IRP is a data structure that contains information on what operation to perform and the buffer required for the I/O operation.</li>
</ol>
<p class="calibre2">The driver reads the IRP, verifies it, and completes the requested operation before notifying the I/O manager about the status of the operation. The I/O manager then returns the status and the data back to the user application.</p>
<p class="calibre2">At this stage, the preceding points might seem foreign to you, but don't let it discourage you: it will be clear by the time you complete this section. Next, we will look at the role of the device driver, followed by the role of the I/O manager.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6.1 The Role Of The Device Driver</h1>
                
            
            <article>
                
<p class="calibre2">When the driver is loaded into the system, the I/O manager creates a driver object (<kbd class="calibre13">DRIVER_OBJECT</kbd> structure). The I/O manager then calls the driver's initialization routine, <kbd class="calibre13">DriverEntry</kbd> (which is analogous to the <kbd class="calibre13">main()</kbd> or <kbd class="calibre13">WinMain()</kbd> functions), by passing a pointer to the <kbd class="calibre13">DRIVER_OBJECT</kbd> structure as an argument. A driver object (<kbd class="calibre13">DRIVER_OBJECT</kbd> structure) represents an individual driver on the system. The <kbd class="calibre13">DriverEntry</kbd> routine will use the <kbd class="calibre13">DRIVER_OBJECT</kbd> to populate it with various entry points of the driver for handling specific I/O requests. Typically, in the <kbd class="calibre13">DriverEntry</kbd> routine, the driver creates a device object (<kbd class="calibre13">DEVICE_OBJECT</kbd> structure) that represent logical or physical devices. The device is created using an API called <kbd class="calibre13">IoCreateDevice</kbd> or <kbd class="calibre13">IoCreateDevice-Secure.</kbd> When the driver creates a device object, it can optionally assign the name to the device and it can also create multiple devices. After the device is created, the pointer to the first created device is updated in the driver object. To help you understand this better, let's list the loaded kernel modules and look at a driver object of a simple kernel module. For this example, we will examine the <kbd class="calibre13">null.sys</kbd> kernel driver. As per Microsoft documentation, the Null device driver provides the functional equivalent of <kbd class="calibre13">\dev\null</kbd> in the Unix environment. When the system starts during the kernel initialization phase, <kbd class="calibre13">null.sys</kbd> gets loaded into the system. In the kernel module listing, you can see that <kbd class="calibre13">null.sys</kbd> is loaded at base address <kbd class="calibre13">8bcde000</kbd>:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">lm k</strong><br class="title-page-name"/>start end module name<br class="title-page-name"/>80ba2000 80baa000 kdcom (deferred) <br class="title-page-name"/>81e29000 81e44000 luafv (deferred) <br class="title-page-name"/>[REMOVED]<br class="title-page-name"/><strong class="calibre1">8bcde000 8bce5000 Null</strong> (deferred)</pre>
<p class="calibre2">Since <kbd class="calibre13">null.sys</kbd> is already loaded, its driver object (<kbd class="calibre13">DRIVER_OBJECT</kbd> structure) will be populated with metadata information during the driver initialization. Let's look at its driver object to understand what kind of information it contains. You can display the driver object information using the <kbd class="calibre13">!drvobj</kbd> extension command. From the following output, the driver object representing <kbd class="calibre13">null.sys</kbd> is at address <kbd class="calibre13">86a33180.</kbd> The value <kbd class="calibre13">86aa2750</kbd> below <kbd class="calibre13">Device Object list</kbd> is the pointer to the device object created by <kbd class="calibre13">null.sys</kbd>. If the driver creates multiple devices, you will see multiple entries under the <kbd class="calibre13">Device Object list</kbd>:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">!drvobj Null</strong><br class="title-page-name"/>Driver object (<strong class="calibre1">86a33180</strong>) is for:<br class="title-page-name"/> \Driver\Null<br class="title-page-name"/>Driver Extension List: (id , addr)<br class="title-page-name"/><br class="title-page-name"/>Device Object list:<br class="title-page-name"/><strong class="calibre1">86aa2750</strong></pre>
<p class="calibre2">You can use the driver object address <kbd class="calibre13">86a33180</kbd> to examine the <kbd class="calibre13">_DRIVER_OBJECT</kbd> structure of <kbd class="calibre13">null.sys</kbd> using the <kbd class="calibre13">dt (display type)</kbd> command. From the following output, you can see that the <kbd class="calibre13">DriverStart</kbd> field holds the base address (<kbd class="calibre13">0x8bcde000</kbd>) of the driver, the <kbd class="calibre13">DriverSize</kbd> field contains the size of the <kbd class="calibre13">driver(0x7000)</kbd>, and the <kbd class="calibre13">Drivername</kbd> is the name of the driver object (<kbd class="calibre13">\Driver\Null</kbd>)<kbd class="calibre13">.</kbd> The <kbd class="calibre13">DriverInit</kbd> field holds the pointer to the <em class="calibre17">Driver initialization routine</em> (<kbd class="calibre13">DriverEntry</kbd>). The <kbd class="calibre13">DriverUnload</kbd> field contains the pointer to the driver's unload routine, which normally frees up resources created by the driver during unload process. The <kbd class="calibre13">MajorFunction</kbd> field is one of the most important fields, that points to a table of 28 major function pointers. This table will be populated with the addresses of the dispatch routines, and we will look at the <kbd class="calibre13">MajorFunction</kbd> table later in this section. The <kbd class="calibre13">driverscan</kbd> plugin covered earlier performs pool tag scanning for the driver objects and gets the information related to the kernel module such as base address, size, and the driver name by reading some of these fields:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">dt nt!_DRIVER_OBJECT 86a33180</strong><br class="title-page-name"/>   +0x000 Type : 0n4<br class="title-page-name"/>   +0x002 Size : 0n168<br class="title-page-name"/>   +0x004<strong class="calibre1"> DeviceObject : 0x86aa2750 _DEVICE_OBJECT</strong><br class="title-page-name"/>   +0x008 Flags : 0x12<br class="title-page-name"/>   +0x00c <strong class="calibre1">DriverStart : 0x8bcde000</strong> Void<br class="title-page-name"/>   +0x010 <strong class="calibre1">DriverSize : 0x7000</strong><br class="title-page-name"/>   +0x014 DriverSection : 0x86aa2608 Void<br class="title-page-name"/>   +0x018 DriverExtension : 0x86a33228 _DRIVER_EXTENSION<br class="title-page-name"/>   +0x01c <strong class="calibre1">DriverName : _UNICODE_STRING "\Driver\Null"</strong><br class="title-page-name"/>   +0x024 HardwareDatabase : 0x82d86270 _UNICODE_STRING "\REGISTRY\MACHINE\HARDWARE\DESCRIPTION\SYSTEM"<br class="title-page-name"/>   +0x028 FastIoDispatch : 0x8bce0000 _FAST_IO_DISPATCH<br class="title-page-name"/>   +0x02c <strong class="calibre1">DriverInit : 0x8bce20bc long Null!GsDriverEntry+0</strong><br class="title-page-name"/>   +0x030 DriverStartIo : (null) <br class="title-page-name"/>   +0x034 <strong class="calibre1">DriverUnload : 0x8bce1040</strong> void Null!NlsUnload+0<br class="title-page-name"/>   +0x038 <strong class="calibre1">MajorFunction : [28] 0x8bce107c</strong></pre>
<p class="calibre2">The <kbd class="calibre13">DeviceObject</kbd> field in the <kbd class="calibre13">DRIVER_OBJECT</kbd> structure contains the pointer to the device object created by the driver (<kbd class="calibre13">null.sys</kbd>). You can use the device object address <kbd class="calibre13">0x86aa2750</kbd> to determine the name of the device created by the driver. In this case, <kbd class="calibre13">Null</kbd> is the name of the device created by the driver <kbd class="calibre13">null.sys</kbd>:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">!devobj 86aa2750</strong><br class="title-page-name"/>Device object (86aa2750) is for:<br class="title-page-name"/> <strong class="calibre1">Null</strong> \Driver\Null DriverObject 86a33180<br class="title-page-name"/>Current Irp 00000000 RefCount 0 Type 00000015 Flags 00000040<br class="title-page-name"/>Dacl 8c667558 DevExt 00000000 DevObjExt 86aa2808 <br class="title-page-name"/>ExtensionFlags (0x00000800) DOE_DEFAULT_SD_PRESENT<br class="title-page-name"/>Characteristics (0x00000100) FILE_DEVICE_SECURE_OPEN<br class="title-page-name"/>Device queue is not busy.</pre>
<p class="calibre2">You can also look at the actual <kbd class="calibre13">DEVICE_OBJECT</kbd> structure by specifying the device object address next to the <kbd class="calibre13">display type (dt)</kbd> command, as shown in the following code. If the driver creates more than one device, then the <kbd class="calibre13">NextDevice</kbd> field in the <kbd class="calibre13">DEVICE_OBJECT</kbd> structure will point to the next device object. Since the <kbd class="calibre13">null.sys</kbd> driver creates only one device, the <kbd class="calibre13">NextDevice</kbd> field is set to <kbd class="calibre13">null</kbd>:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">dt nt!_DEVICE_OBJECT 86aa2750</strong><br class="title-page-name"/>   +0x000 Type : 0n3<br class="title-page-name"/>   +0x002 Size : 0xb8<br class="title-page-name"/>   +0x004 ReferenceCount : 0n0<br class="title-page-name"/>   +0x008 <strong class="calibre1">DriverObject : 0x86a33180 _DRIVER_OBJECT</strong><br class="title-page-name"/>   +0x00c NextDevice : (null) <br class="title-page-name"/>   +0x010 AttachedDevice : (null) <br class="title-page-name"/>   +0x014 CurrentIrp : (null) <br class="title-page-name"/>   +0x018 Timer : (null) <br class="title-page-name"/>   +0x01c Flags : 0x40<br class="title-page-name"/>   +0x020 Characteristics : 0x100<br class="title-page-name"/>   +0x024 Vpb : (null) <br class="title-page-name"/>   +0x028 DeviceExtension : (null) <br class="title-page-name"/>   +0x02c DeviceType : 0x15<br class="title-page-name"/>   +0x030 StackSize : 1 ''<br class="title-page-name"/>   [REMOVED]</pre>
<p class="calibre2">From the preceding output, you can see that the <kbd class="calibre13">DEVICE_OBJECT</kbd> contains a <kbd class="calibre13">DriverObject</kbd> field that points back to the driver object. In other words, the associated driver can be determined from the device object. This is how the I/O manager can determine the associated driver when it receives the I/O request for a specific device. This concept can be visualized using the following diagram:</p>
<div class="cdpaligncenter"><img src="../images/00350.jpeg" class="calibre41"/></div>
<p class="calibre2">You can use a GUI tool such as <em class="calibre17">DeviceTree</em> (<a href="http://www.osronline.com/article.cfm?article=97" class="calibre10">http://www.osronline.com/article.cfm?article=97</a>) to look at the devices created by the driver. The following is a screenshot of the tool showing the <kbd class="calibre13">Null</kbd> device created by the <kbd class="calibre13">null.sys</kbd> driver:</p>
<div class="cdpaligncenter"><img src="../images/00351.jpeg" class="calibre271"/></div>
<p class="calibre2">When a driver creates a device, the device objects are placed in the <kbd class="calibre13">\Device</kbd> directory in the Windows object manager's namespace. To view the object manager's namespace information, you can use the  <em class="calibre17">WinObj</em> tool (<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/winobj" class="calibre10">https://docs.microsoft.com/en-us/sysinternals/downloads/winobj</a>). The following screenshot shows the device (<kbd class="calibre13">Null</kbd>) created by <kbd class="calibre13">null.sys</kbd> in the <kbd class="calibre13">\Device</kbd> directory. You can also see the devices that have been created by other drivers:</p>
<div class="cdpaligncenter"><img src="../images/00352.jpeg" class="calibre272"/></div>
<p class="calibre2">The device created under the <kbd class="calibre13">\Device</kbd> directory is not accessible to the applications running in the user mode. In other words, if a user mode application wants to perform I/O operations on the device, it cannot directly open a handle to the device by passing the name of the device (such as <kbd class="calibre13">\Device\Null</kbd>) as the argument to the <kbd class="calibre13">CreateFile</kbd> function. The <kbd class="calibre13">CreateFile</kbd> function is not just used for creating or opening a file, it can also be used to open a handle to the device. If a user mode application cannot access the device, then how can it perform I/O operations? To make the device accessible to the user mode applications, the driver needs to advertise the device. This is done by creating a symbolic link to the device. A driver can create a symbolic link using the kernel API <kbd class="calibre13">IoCreateSymbolicLink.</kbd> When a symbolic link is created for a device (such as <kbd class="calibre13">\Device\Null</kbd>), you can find it in the <kbd class="calibre13">\GLOBAL??</kbd> directory in the object manager namespace, which can also be viewed using the <em class="calibre17">WinObj</em> tool. In the following screenshot, you can see that <kbd class="calibre13">NUL</kbd> is the name of the symbolic link created for the <kbd class="calibre13">\Device\Null</kbd> device by the <kbd class="calibre13">null.sys</kbd> driver:</p>
<div class="cdpaligncenter"><img src="../images/00353.jpeg" class="calibre273"/></div>
<p class="calibre2">The symbolic link is also referred to as an MS-DOS device name. A user mode application can simply use the name of the symbolic link (MS-DOS device name) to open the handle to the device using the convention <kbd class="calibre13">\\.\&lt;symboliclink name&gt;</kbd>. For example, to open a handle to <kbd class="calibre13">\Device\Null</kbd>, a user mode application has to just pass <kbd class="calibre13">\\.\NUL</kbd> as the first argument (<kbd class="calibre13">lpFilename</kbd>) to the <kbd class="calibre13">CreateFile</kbd> function, which returns the file handle to the device. To be specific, anything that is a symbolic link within the object manager's directory <kbd class="calibre13">GLOBAL??</kbd> can be opened using the <kbd class="calibre13">CreateFile</kbd> function. As shown in the following screenshot, the <kbd class="calibre13">C:</kbd> volume is just a symbolic link to <kbd class="calibre13">\Device\HarddiskVolume1</kbd><em class="calibre17">.</em> In Windows, I/O operations are performed on virtual files. In other words, devices, directories, pipes, and files are all treated as virtual files (that can be opened using the <kbd class="calibre13">CreateFile</kbd> function):</p>
<div class="cdpaligncenter"><img src="../images/00354.jpeg" class="calibre41"/></div>
<p class="calibre2">At this point, you know that the driver, during its initialization, creates the device and advertises it to be used by the user application using symbolic links. Now, the question is, how does the driver tell the I/O manager what type of operation (open, read, write, and so on) it supports for the device? During initialization, another thing the driver normally does is update the <kbd class="calibre13">Major function table (dispatch routine array)</kbd> with the addresses of the dispatch routines in the <kbd class="calibre13">DRIVER_OBJECT</kbd> structure. Examining the major function table will give you an idea of the type of operations (open, read, write, and so on) supported by the driver, and the addresses of dispatch routines associated with the specific operation. The major function table is an array of <kbd class="calibre13">28</kbd> function pointers; the index values <kbd class="calibre13">0</kbd> to <kbd class="calibre13">27</kbd> represents a particular operation. For example, the index value <kbd class="calibre13">0</kbd> corresponds to the major function code <kbd class="calibre13">IRP_MJ_CREATE</kbd>, the index value <kbd class="calibre13">3</kbd> corresponds to the major function code <kbd class="calibre13">IRP_MJ_READ</kbd>, and so on. In other words, if an application wants to open a handle to a file or device object, the request will be sent to the I/O manager, which will then use the <kbd class="calibre13">IRP_MJ_CREATE</kbd> major function code as the index into the major function table to find the address of the dispatch routine that will handle this request. In the same manner for the read operation, <kbd class="calibre13">IRP_MJ_READ</kbd> is used as the index to determine the address of the dispatch routine.</p>
<p class="calibre2">The following <kbd class="calibre13">!drvobj</kbd> commands displays the dispatch routine array populated by the <kbd class="calibre13">null.sys</kbd> driver. The operations that are not supported by the driver point to <kbd class="calibre13">IopInvalidDeviceRequest</kbd> in the <kbd class="calibre13">ntoskrnl.exe</kbd> (<kbd class="calibre13">nt</kbd>). Based on this information, you can tell that <kbd class="calibre13">null.sys</kbd> only supports <kbd class="calibre13">IRP_MJ_CREATE</kbd> (open), <kbd class="calibre13">IRP_MJ_CLOSE</kbd> (close), <kbd class="calibre13">IRP_MJ_READ</kbd> (read), <kbd class="calibre13">IRP_MJ_WRITE</kbd> (write), <kbd class="calibre13">IRP_MJ_QUERY_INFORMATION</kbd> (query information), and <kbd class="calibre13">IRP_MJ_LOCK_CONTROL</kbd> (lock control) operations. Any request to perform any of the supported operations will be dispatched to the appropriate dispatch routine. For example, when the user application performs a <kbd class="calibre13">write</kbd> operation, the <kbd class="calibre13">write</kbd> request to the device will be dispatched to the <kbd class="calibre13">MajorFunction[IRP_MJ_WRITE]</kbd> function, which happens to be at address <kbd class="calibre13">8bce107c</kbd> within the <kbd class="calibre13">null.sys</kbd> driver's unload routine. In the case of <kbd class="calibre13">null.sys</kbd>, all the supported operations are dispatched to the same address, <kbd class="calibre13">8bce107c</kbd>. Normally, that is not the case; you will see different routine addresses for handling different operations:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">!drvobj Null 2</strong><br class="title-page-name"/>Driver object (86a33180) is for:<br class="title-page-name"/> \Driver\Null<br class="title-page-name"/>DriverEntry: 8bce20bc Null!GsDriverEntry<br class="title-page-name"/>DriverStartIo: 00000000 <br class="title-page-name"/>DriverUnload: 8bce1040 Null!NlsUnload<br class="title-page-name"/>AddDevice: 00000000 <br class="title-page-name"/><br class="title-page-name"/>Dispatch routines:<br class="title-page-name"/>[00] IRP_MJ_CREATE                   8bce107c Null!NlsUnload+0x3c<br class="title-page-name"/>[01] IRP_MJ_CREATE_NAMED_PIPE        82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[02] IRP_MJ_CLOSE                    8bce107c Null!NlsUnload+0x3c<br class="title-page-name"/>[03] IRP_MJ_READ                     8bce107c Null!NlsUnload+0x3c<br class="title-page-name"/>[04] IRP_MJ_WRITE                    8bce107c Null!NlsUnload+0x3c<br class="title-page-name"/>[05] IRP_MJ_QUERY_INFORMATION        8bce107c Null!NlsUnload+0x3c<br class="title-page-name"/>[06] IRP_MJ_SET_INFORMATION          82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[07] IRP_MJ_QUERY_EA                 82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[08] IRP_MJ_SET_EA                   82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[09] IRP_MJ_FLUSH_BUFFERS            82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[0a] IRP_MJ_QUERY_VOLUME_INFORMATION 82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[0b] IRP_MJ_SET_VOLUME_INFORMATION   82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[0c] IRP_MJ_DIRECTORY_CONTROL        82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[0d] IRP_MJ_FILE_SYSTEM_CONTROL      82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[0e] IRP_MJ_DEVICE_CONTROL           82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[0f] IRP_MJ_INTERNAL_DEVICE_CONTROL  82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[10] IRP_MJ_SHUTDOWN                 82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[11] IRP_MJ_LOCK_CONTROL             8bce107c Null!NlsUnload+0x3c<br class="title-page-name"/>[12] IRP_MJ_CLEANUP                  82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[13] IRP_MJ_CREATE_MAILSLOT          82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[14] IRP_MJ_QUERY_SECURITY           82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[15] IRP_MJ_SET_SECURITY             82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[16] IRP_MJ_POWER                    82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[17] IRP_MJ_SYSTEM_CONTROL           82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[18] IRP_MJ_DEVICE_CHANGE            82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[19] IRP_MJ_QUERY_QUOTA              82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[1a] IRP_MJ_SET_QUOTA                82ac5fbe nt!IopInvalidDeviceRequest<br class="title-page-name"/>[1b] IRP_MJ_PNP                      82ac5fbe nt!IopInvalidDeviceRequest </pre>
<p class="calibre2">You can also look at the supported operations in the <em class="calibre17">DeviceTree</em> tool, as shown the following screenshot:</p>
<div class="cdpaligncenter"><img src="../images/00355.jpeg" class="calibre41"/></div>
<p class="calibre2">At this point, you know that the driver creates the device, advertises it to be used by the user applications, and it also updates the dispatch routine array (major function table) to tell the I/O manager what operation it supports. Now, let's look at what the role of the I/O manager is and understand how the I/O request received from the user application is dispatched to the driver.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6.2 The Role Of The I/O Manager</h1>
                
            
            <article>
                
<p class="calibre2">When the I/O request reaches the I/O manager, the I/O manager locates the driver and creates an <kbd class="calibre13">IRP (I/O request packet)</kbd>, that is a data structure which contains information describing an I/O request. For an operation such as read, write, and so on, the IRP created by the I/O manager also contains a buffer in the kernel memory to be used by the driver to store the data read from the device or the data to be written to the device. The IRP created by the I/O manager is then passed to the correct driver's dispatch routine. The driver receives the IRP, and the IRP contains the major function code (<kbd class="calibre13">IRP_MJ_XXX</kbd>) that describes the operation (open, read, or write) to be performed. Before initiating an I/O operation, the driver performs a check to make sure everything is OK (for example, the buffer provided for read or write operations is large enough) after which it initiates the I/O operation. The driver normally goes through the HAL routines if it is required to perform I/O operations on the hardware device. Upon completion of its work, the driver then returns the IRP to the I/O manager, either to let it know that the requested I/O operation has been completed or because it must be passed to another driver for further processing in the driver stack. The I/O manager frees the IRP if the job is complete or passes the IRP to the next driver in the device stack to complete the IRP. Upon completion of the job, the I/O manager returns the status and the data to the user mode application.</p>
<div class="packt_infobox">At this point, you should have an understanding of the role of the I/O manager. For detailed information on the I/O system and device drivers, refer to the book <em class="calibre22">"Windows Internals, Part 1: 7th Edition"</em> by Pavel Yosifovich, Alex Ionescu, Mark E. Russinovich, and David A. Solomon.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6.3 Communicating With The Device Driver</h1>
                
            
            <article>
                
<p class="calibre2">Now, let's revisit the interaction between the user-mode component and the kernel-mode component. We will get back to our example of the <kbd class="calibre13">null.sys</kbd> driver and trigger a write operation to it's device <span class="calibre7">(<kbd class="calibre13">\Device\Null</kbd>) </span>from the user-mode and monitor the IRP sent to the <kbd class="calibre13">null.sys</kbd> driver. To monitor the IRP packets sent to the driver, we can use the <kbd class="calibre13">IrpTracker</kbd> tool (<a href="https://www.osronline.com/article.cfm?article=199" class="calibre10">https://www.osronline.com/article.cfm?article=199</a>). To monitor launch the <kbd class="calibre13">IrpTracker</kbd> as an Administrator, click on <span class="calibre7">File</span> | <span class="calibre7">Select Driver</span> and enter the name of the driver (in this case, <kbd class="calibre13">null</kbd>), as shown in the following screenshot, and select the <span class="calibre7">OK</span> button:</p>
<div class="cdpaligncenter"><img src="../images/00356.jpeg" class="calibre41"/></div>
<p class="calibre2">Now, to trigger the I/O operation, you can open the Command Prompt and type the following command. This will write the string <kbd class="calibre13">"hello"</kbd> to the null device. As mentioned earlier, the symbolic link name is what a user-mode application (such as <kbd class="calibre13">cmd.exe</kbd>) can use; that is the reason I'm specifying the symbolic link name of the device (NUL) to write the content:</p>
<pre class="calibre18">C:\&gt;<strong class="calibre1">echo "hello" &gt; NUL</strong></pre>
<p class="calibre2">A device is treated as a virtual file and before writing to the device, handles to the device will be opened using <kbd class="calibre13">CreateFile()</kbd> (an API that's used to create/open a file or device). The <kbd class="calibre13">CreateFile()</kbd> API will eventually call <kbd class="calibre13">NtCreateFile()</kbd> in <kbd class="calibre13">ntoskrnl.exe</kbd>, which sends the request to the I/O manager. The I/O manager finds the driver associated with the device based on the symbolic link name, and calls its dispatch routine corresponding to the <kbd class="calibre13">IRP_MJ_CREATE</kbd> major function code. After the handle is opened to the device, the write operation is performed using <kbd class="calibre13">WriteFile()</kbd>, which will call <kbd class="calibre13">NtWriteFile</kbd>. This request will be dispatched by the I/O manager to the driver's routine that's corresponding to the <kbd class="calibre13">IRP_MJ_WRITE</kbd> major function code. The following screenshot shows calls to the driver's dispatch routines that are corresponding to <kbd class="calibre13">IRP_MJ_CREATE</kbd> and <kbd class="calibre13">IRP_MJ_WRITE</kbd> and their completion status:</p>
<div class="cdpaligncenter"><img src="../images/00357.jpeg" class="calibre41"/></div>
<p class="calibre2">At this point, you should have an understanding of how the user-mode code that performs I/O operations communicates with the kernel mode driver. Windows supports another mechanism, which allows the user-mode code to communicate directly with the kernel-mode device driver. This is done using the generic API called <kbd class="calibre13">DeviceIoControl</kbd> (exported by <kbd class="calibre13">kernel32.dll</kbd>). This API accepts the handle to the device as one of the parameters. Another parameter it accepts is the control code, known as the <kbd class="calibre13">IOCTL</kbd> (I/O control) code, which is a 32-bit integer value. Each control code identifies a specific operation to be performed and the type of device on which to perform the operation. A user-mode application can open the handle to the device (using <kbd class="calibre13">CreateFile</kbd>), call <kbd class="calibre13">DeviceIoControl</kbd>, and pass the standard control codes provided by the Windows operating system to perform direct input and output operations on the device, such as hard disk drive, tape drive, or CD-ROM drive. In addition, a device driver (a rootkit driver) can define its own device-specific control codes, which can be used by the user-mode component of the rootkit to communicate with the driver via the <kbd class="calibre13">DeviceIoControl</kbd> API. When a user-mode component calls <kbd class="calibre13">DeviceIoControl</kbd> by passing <kbd class="calibre13">IOCTL</kbd> code, it calls <kbd class="calibre13">NtDeviceIoControlFile</kbd> in <kbd class="calibre13">ntdll.dll</kbd>, which transitions the thread to the kernel-mode and calls the system service routine <kbd class="calibre13">NtDeviceIoControlFile</kbd> in the Windows executive <kbd class="calibre13">ntoskrnl.exe.</kbd> The Windows executive invokes the I/O manager, the I/O manager builds an IRP packet containing the IOCTL code, and then it routes it to the kernel dispatch routine identified by <kbd class="calibre13">IRP_MJ_DEVICE_CONTROL.</kbd> The following diagram illustrates this concept of communication between user-mode code and the kernel-mode driver:</p>
<div class="cdpaligncenter"><img src="../images/00358.jpeg" class="calibre41"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">6.4 I/O Requests To Layered Drivers</h1>
                
            
            <article>
                
<p class="calibre2">So far, you have understood how an I/O request is handled by a simple device controlled by a single driver. The I/O request can go through multiple layers of drivers; I/O processing for the layered drivers happens in much the same way. The following screenshot illustrates an example of how an I/O request might travel through layered drivers before reaching the hardware-based devices:</p>
<div class="cdpaligncenter"><img src="../images/00359.jpeg" class="calibre41"/></div>
<p class="calibre2">This concept is better understood with an example, so let's trigger a write operation to <kbd class="calibre13">c:\abc.txt</kbd> using the following command. When this command is executed, <kbd class="calibre13">netstat</kbd> will open the handle to <kbd class="calibre13">abc.txt</kbd> and write to it:</p>
<pre class="calibre18">C:\Windows\system32&gt;<strong class="calibre1">netstat -an -t 60 &gt; C:\abc.txt</strong></pre>
<p class="calibre2">A point to note here is that the filename <em class="calibre17">(</em><kbd class="calibre13">C:\abc.txt</kbd><em class="calibre17">)</em> also includes the name of the device where the file resides, that is, volume <kbd class="calibre13">C:</kbd> is the symbolic link name for the device, <kbd class="calibre13">\Device\HarddiskVolume1</kbd> (you can verify it using the <kbd class="calibre13">WinObj</kbd> tool, as mentioned earlier). This means the write operation will be routed to the driver associated with the device <kbd class="calibre13">\Device\HarddiskVolume1</kbd><em class="calibre17">.</em> When <kbd class="calibre13">netstat.exe</kbd> opens <kbd class="calibre13">abc.txt</kbd>, the I/O manager creates a file object (<kbd class="calibre13">FILE_OBJECT</kbd> structure) and stores the pointer to the device object inside the file object before returning the handle to <kbd class="calibre13">netstat.exe.</kbd> The following screenshot from the <kbd class="calibre13">ProcessHacker</kbd> tool displays the handle to <kbd class="calibre13">C:\abc.txt</kbd> that has been opened by <kbd class="calibre13">netstat.exe.</kbd> The object address <kbd class="calibre13">0x85f78ce8</kbd> represents the file object:</p>
<div class="cdpaligncenter"><img src="../images/00360.jpeg" class="calibre41"/></div>
<p class="calibre2">You can examine the file object (<kbd class="calibre13">FILE_OBJECT</kbd>) using the object address as follows. From the output, you can see that the <kbd class="calibre13">FileName</kbd> field contains the name of the file, and the <kbd class="calibre13">DeviceObject</kbd> field contains the pointer to the device object <kbd class="calibre13">(DEVICE_OBJECT)</kbd>:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">dt nt!_FILE_OBJECT 0x85f78ce8</strong><br class="title-page-name"/>   +0x000 Type : 0n5<br class="title-page-name"/>   +0x002 Size : 0n128<br class="title-page-name"/>   +0x004 <strong class="calibre1">DeviceObject : 0x868e7e20 _DEVICE_OBJECT</strong><br class="title-page-name"/>   +0x008 Vpb : 0x8688b658 _VPB<br class="title-page-name"/>   +0x00c FsContext : 0xa74fecf0 Void<br class="title-page-name"/>   [REMOVED]<br class="title-page-name"/>   +0x030 <strong class="calibre1">FileName : _UNICODE_STRING "\abc.txt"</strong><br class="title-page-name"/>   +0x038 CurrentByteOffset : _LARGE_INTEGER 0xe000</pre>
<p class="calibre2">As mentioned earlier, from the device object, one can determine the name of the device and the associated driver. This is how the I/O manager determines which driver to pass the I/O request to. The following output displays the name of the device, <kbd class="calibre13">HarddiskVolume1</kbd>, and its associated driver, <kbd class="calibre13">volmgr.sys.</kbd> The <kbd class="calibre13">AttachedDevice</kbd> field tells you that there is an unnamed device object (<kbd class="calibre13">868e7b28</kbd>) associated with the <kbd class="calibre13">fvevol.sys</kbd> driver sitting on top of the device object <kbd class="calibre13">HarddiskVolume1</kbd> in the device stack:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">!devobj 0x868e7e20</strong><br class="title-page-name"/>Device object (868e7e20) is for:<br class="title-page-name"/> <strong class="calibre1">HarddiskVolume1</strong> <strong class="calibre1">\Driver\volmgr</strong> DriverObject 862e0bd8<br class="title-page-name"/>Current Irp 00000000 RefCount 13540 Type 00000007 Flags 00201150<br class="title-page-name"/>Vpb 8688b658 Dacl 8c7b3874 DevExt 868e7ed8 DevObjExt 868e7fc0 Dope 86928870 DevNode 86928968 <br class="title-page-name"/>ExtensionFlags (0x00000800) DOE_DEFAULT_SD_PRESENT<br class="title-page-name"/>Characteristics (0000000000) <br class="title-page-name"/><strong class="calibre1">AttachedDevice (Upper)</strong> <strong class="calibre1">868e7b28 \Driver\fvevol</strong><br class="title-page-name"/>Device queue is not busy.</pre>
<p class="calibre2">To determine the layers of drivers through which the I/O request goes through, you can use the <kbd class="calibre13">!devstack</kbd> kernel debugger command and pass the device object address to display the device stack (of layered device objects) associated with a particular device object. The following output shows the device stack associated with <kbd class="calibre13">\Device\HarddiskVolume1</kbd>, which is owned by <kbd class="calibre13">volmgr.sys.</kbd> The <kbd class="calibre13">&gt;</kbd> character in the fourth column tells you that the entry is associated with the device <kbd class="calibre13">HarddiskVolume1</kbd> and the entries above that line are the list of drivers layered above <kbd class="calibre13">volmgr.sys.</kbd> What this means is that the I/O request will be first passed to <kbd class="calibre13">volsnap.sys</kbd> by the I/O manager. Depending on the type of request, <kbd class="calibre13">volsnap.sys</kbd> can handle the IRP request and send the request down to other drivers in the stack, which finally reaches <kbd class="calibre13">volmgr.sys</kbd>:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">!devstack 0x868e7e20</strong><br class="title-page-name"/>  !DevObj !DrvObj !DevExt ObjectName<br class="title-page-name"/>  85707658 \Driver\volsnap 85707710 <br class="title-page-name"/>  868e78c0 \Driver\rdyboost 868e7978 <br class="title-page-name"/>  868e7b28 \Driver\fvevol 868e7be0 <br class="title-page-name"/><strong class="calibre1">&gt;</strong> 868e7e20 \Driver\volmgr 868e7ed8 HarddiskVolume1</pre>
<p class="calibre2">To view the device tree, you can use the GUI tool <em class="calibre17">DeviceTree</em> (which we mentioned earlier). The tool displays the driver on the outer edge of the tree, and their devices are indented one level. The attached devices are further intended, as shown in the following screenshot. You can compare the following screenshot with the preceding <kbd class="calibre13">!devstack</kbd> output to get an idea of how to interpret the information:</p>
<div class="cdpaligncenter"><img src="../images/00361.jpeg" class="calibre41"/></div>
<p class="calibre2">It is important to understand this layered approach, because sometimes, a rookit driver can insert or attach below or above the target device's stack to receive <kbd class="calibre13">IRP</kbd>. Using this technique, a rootkit driver can log or modify the <kbd class="calibre13">IRP</kbd> before passing it on to the legitimate driver. For example, a keylogger can log strokes by inserting a malicious driver that sits above the keyboard function driver.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">7. Displaying Device Trees</h1>
                
            
            <article>
                
<p class="calibre2">You can use the <kbd class="calibre13">devicetree</kbd> plugin in Volatility to display the device tree in the same format as the <em class="calibre17">DeviceTree</em> tool. The following highlighted entries show the device stack of <kbd class="calibre13">HarddiskVolume1</kbd> that is associated with <kbd class="calibre13">volmgr.sys</kbd>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f win7_x86.vmem --profile=Win7SP1x86 devicetree</strong><br class="title-page-name"/><br class="title-page-name"/>DRV 0x05329db8 \Driver\WMIxWDM<br class="title-page-name"/>---| DEV 0x85729a38 WMIAdminDevice FILE_DEVICE_UNKNOWN<br class="title-page-name"/>---| DEV 0x85729b60 WMIDataDevice FILE_DEVICE_UNKNOWN<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">DRV 0xbf2e0bd8 \Driver\volmgr</strong><br class="title-page-name"/><strong class="calibre1">---| DEV 0x868e7e20 HarddiskVolume1 FILE_DEVICE_DISK</strong><br class="title-page-name"/><strong class="calibre1">------| ATT 0x868e7b28 - \Driver\fvevol FILE_DEVICE_DISK</strong><br class="title-page-name"/><strong class="calibre1">---------| ATT 0x868e78c0 - \Driver\rdyboost FILE_DEVICE_DISK</strong><br class="title-page-name"/><strong class="calibre1">------------| ATT 0x85707658 - \Driver\volsnap FILE_DEVICE_DISK</strong><br class="title-page-name"/>[REMOVED]</pre>
<p class="calibre2">To help you understand the use of the <kbd class="calibre13">devicetree</kbd> plugin in forensic investigation, let's take a look at a malware which creates its own device to store its malicious binary. In the following example of the Z<em class="calibre17">eroAccess</em> <em class="calibre17">rootkit</em>, I have used the <kbd class="calibre13">cmdline</kbd> plugin, which displays process command-line arguments. This can be useful in determining the full path of a process (you can also use the <kbd class="calibre13">dlllist</kbd> plugin). From the output, you can see that the last <kbd class="calibre13">svchost.exe</kbd> process is running from a suspicious namespace:</p>
<pre class="calibre18">svchost.exe pid: 624<br class="title-page-name"/>Command line : C:\Windows\system32\svchost.exe -k DcomLaunch<br class="title-page-name"/>svchost.exe pid: 712<br class="title-page-name"/>Command line : C:\Windows\system32\svchost.exe -k RPCSS<br class="title-page-name"/>svchost.exe pid: 764<br class="title-page-name"/>Command line : C:\Windows\System32\svchost.exe -k LocalServiceNetworkRestricted<br class="title-page-name"/>svchost.exe pid: 876<br class="title-page-name"/>Command line : C:\Windows\System32\svchost.exe -k LocalSystemNetworkRestricted<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">svchost.exe pid: 1096</strong><br class="title-page-name"/><strong class="calibre1">Command line : "\\.\globalroot\Device\svchost.exe\svchost.exe"</strong></pre>
<p class="calibre2">From the earlier discussion, if you remember, <kbd class="calibre13">\\.\&lt;symbolic link name&gt;</kbd> is the convention used to access a device from the user-mode using the name of the symbolic link. When a driver creates a symbolic link for the device, it is added to the <kbd class="calibre13">\GLOBAL??</kbd> directory in the object manager namespace (which can be viewed using the <em class="calibre17">WinObj</em> tool, as we discussed earlier). In this case, <kbd class="calibre13">globalroot</kbd> is the name of the symbolic link. Then, the question is, what is <kbd class="calibre13">\\.\globalroot</kbd>? It turns out that <kbd class="calibre13">\\.\globalroot</kbd> refers to the <kbd class="calibre13">\GLOBAL??</kbd> namespace. In other words, the <kbd class="calibre13">\\.\globalroot\Device\svchost.exe\svchost.exe</kbd> path is the same as <kbd class="calibre13">\Device\svchost.exe\svchost.exe</kbd><em class="calibre17">.</em> At this stage, you know that the Z<em class="calibre17">eroAccess</em> rootkit creates its own device (<kbd class="calibre13">svchost.exe</kbd>) to hide its malicious binary, <kbd class="calibre13">svchost.exe.</kbd> To identify the driver which created this device, you can use the <kbd class="calibre13">devicetree</kbd> plugin. From the following output, you can tell that the <kbd class="calibre13">svchost.exe</kbd> device was created by the <kbd class="calibre13">00015300.sys</kbd> driver:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f zaccess1.vmem --profile=Win7SP1x86 devicetree</strong><br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>DRV 0x1fc84478 <strong class="calibre1">\Driver\00015300</strong><br class="title-page-name"/>---| DEV 0x84ffbf08 <strong class="calibre1">svchost.exe</strong> FILE_DEVICE_DISK</pre>
<p class="calibre2">In the following example of <em class="calibre17">BlackEnergy</em> malware, it replaces the legitimate <kbd class="calibre13">aliide.sys</kbd> driver on the disk with the malicious driver to hijack the existing service (as covered in <a href="part0300.html#8U38O0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 10</a>,<em class="calibre17"> <span class="calibre7">Hunting Malware Using Memory Forensics,</span></em> <span class="calibre7">in the</span><em class="calibre17"><span class="calibre7"> </span>Investigating Service</em> section). When the service starts, the malicious driver creates a device to communicate with the malicious user-mode component (DLL injected into the legitimate <kbd class="calibre13">svchost.exe</kbd>) process. The following <kbd class="calibre13">devicetree</kbd> output shows the device created by the malicious driver:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f be3_big_restart.vmem --profile=Win7SP1x64 devicetree | grep -i aliide -A1</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>DRV 0x1e45fbe0 \Driver\aliide<br class="title-page-name"/>---| DEV 0xfffffa8008670e40 <strong class="calibre1">{C9059FFF-1C49-4445-83E8-4F16387C3800}</strong> FILE_DEVICE_UNKNOWN</pre>
<p class="calibre2">To get an idea of the type of operations supported by the malicious driver. You can use Volatility's <kbd class="calibre13">driverirp</kbd> plugin, since it displays the major IRP functions associated with a particular driver or all the drivers. From the following output, you can tell that the malicious <kbd class="calibre13">aliide</kbd> driver supports <kbd class="calibre13">IRP_MJ_CREATE (open)</kbd>, <kbd class="calibre13">IRP_MJ_CLOSE (close)</kbd>, and the <kbd class="calibre13">IRP_MJ_DEVICE_CONTROL (DeviceIoControl)</kbd> operations. The operations that are not supported by the driver typically point to <kbd class="calibre13">IopInvalidDeviceRequest</kbd> in the <kbd class="calibre13">ntoskrnl.exe</kbd>, which is the reason you are seeing all other non-supported operations pointing to <kbd class="calibre13">0xfffff80002a5865c</kbd> in <kbd class="calibre13">ntoskrnl.exe</kbd>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f be3_big_restart.vmem --profile=Win7SP1x64 driverirp -r aliide</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>--------------------------------------------------<br class="title-page-name"/>DriverName: aliide<br class="title-page-name"/>DriverStart: 0xfffff88003e1d000<br class="title-page-name"/>DriverSize: 0x14000<br class="title-page-name"/>DriverStartIo: 0x0<br class="title-page-name"/>   <strong class="calibre1">0 IRP_MJ_CREATE                  0xfffff88003e1e160 aliide.sys</strong><br class="title-page-name"/>   1 IRP_MJ_CREATE_NAMED_PIPE       0xfffff80002a5865c ntoskrnl.exe<br class="title-page-name"/>   <strong class="calibre1">2 IRP_MJ_CLOSE                   0xfffff88003e1e160 aliide.sys</strong><br class="title-page-name"/>   3 IRP_MJ_READ                    0xfffff80002a5865c ntoskrnl.exe<br class="title-page-name"/>   4 IRP_MJ_WRITE                   0xfffff80002a5865c ntoskrnl.exe<br class="title-page-name"/>  [REMOVED]<br class="title-page-name"/>  12 IRP_MJ_DIRECTORY_CONTROL       0xfffff80002a5865c ntoskrnl.exe<br class="title-page-name"/>  13 IRP_MJ_FILE_SYSTEM_CONTROL     0xfffff80002a5865c ntoskrnl.exe<br class="title-page-name"/>  <strong class="calibre1">14 IRP_MJ_DEVICE_CONTROL          0xfffff88003e1e160 aliide.sys</strong><br class="title-page-name"/>  15 IRP_MJ_INTERNAL_DEVICE_CONTROL 0xfffff80002a5865c ntoskrnl.exe<br class="title-page-name"/>  [REMOVED]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">8. Detecting Kernel Space Hooking</h1>
                
            
            <article>
                
<p class="calibre2">When discussing hooking techniques (In case <a href="part0248.html#7CGBG0-ac10ba3f98854c44bac1c2c5641ca485" class="calibre10">Chapter 8</a>, <em class="calibre17"><span class="calibre7">Code Injection and Hooking,</span></em> <span class="calibre7">in the</span><em class="calibre17"><span class="calibre7"> </span>Hooking Techniques</em> section), we saw how some malware programs modify the call table (<em class="calibre17">IAT Hooking</em>) and some modify the API function (<em class="calibre17">inline hooking</em>) to control the execution path of the program and re-route it to the malicious code. The objective is to block calls to the API, monitor input parameters passed to the API, or to filter the output parameters returned from the API. The techniques covered in <a href="https://cdp.packtpub.com/learning_malware_analysis/wp-admin/post.php?post=1250&amp;action=edit#post_985" class="calibre10">Chapter 8</a><span class="calibre7">, </span><em class="calibre17"><span class="calibre7">Code Injection and Hooking,</span><span class="calibre7"> </span></em>mainly focused on hooking techniques in the user space. Similar capabilities are possible in the kernel space if an attacker manages to install a kernel driver. Hooking in a kernel space is more powerful approach an than hooking in a user space, because kernel components play a very important role in the operation of the system as a whole. It allows an attacker to execute code with high privileges, giving them the capability to conceal the presence of the malicious component, bypass security software, or  intercept the execution path. In this section, we will understand different hooking techniques in the kernel space and how to detect such techniques using memory forensics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">8.1 Detecting SSDT Hooking</h1>
                
            
            <article>
                
<p class="calibre2">The <strong class="calibre5">System Service Descriptor Table</strong> (<strong class="calibre5"><span class="calibre7">SSDT</span></strong>) in kernel space contains the pointers to the system service routines (kernel functions) exported by the kernel executive (<kbd class="calibre13">ntoskrnl.exe, ntkrnlpa.exe</kbd> and so on). When an application calls an API such as <kbd class="calibre13">WriteFile()</kbd>, <kbd class="calibre13">ReadFile()</kbd>, or <kbd class="calibre13">CreateProcess()</kbd>, it calls the stub in the <kbd class="calibre13">ntdll.dll</kbd> which switches the thread to the kernel mode. The thread running in the kernel mode consults the <em class="calibre17">SSDT</em> to determine the address of the kernel function to invoke. The following screenshot illustrates this concept with an example of <kbd class="calibre13">WriteFile()</kbd> (the concept is similar for other APIs):</p>
<div class="cdpaligncenter"><img src="../images/00362.jpeg" class="calibre274"/></div>
<p class="calibre2">In general, <kbd class="calibre13">ntoskrnl.exe</kbd> exports core kernel API functions such as <kbd class="calibre13">NtReadFile()</kbd>, <kbd class="calibre13">NtWrite()File</kbd>, and so on. In the x86 platform, the pointers to these kernel functions are stored directly in the SSDT, whereas on the x64 platforms,  SSDT does not contain the pointers. Instead, it stores an encoded integer that is decoded to determine the address of the kernel function. Irrespective of the implementation, the concept remains the same and the SSDT is consulted to determine the address of a specific kernel function. The following <em class="calibre17">WinDbg</em> command on the <kbd class="calibre13">Windows7 x86</kbd> platform displays the contents of the SSDT. The entries in the table contain the pointers to the functions implemented by <kbd class="calibre13">ntoskrnl.exe</kbd> (<kbd class="calibre13">nt</kbd>). The order and the number of entries vary across operating system versions:</p>
<pre class="calibre18">kd&gt; <strong class="calibre1">dps nt!KiServiceTable</strong><br class="title-page-name"/>82a8f5fc 82c8f06a nt!NtAcceptConnectPort<br class="title-page-name"/>82a8f600 82ad2739 nt!NtAccessCheck<br class="title-page-name"/>82a8f604 82c1e065 nt!NtAccessCheckAndAuditAlarm<br class="title-page-name"/>82a8f608 82a35a1c nt!NtAccessCheckByType<br class="title-page-name"/>82a8f60c 82c9093d nt!NtAccessCheckByTypeAndAuditAlarm<br class="title-page-name"/>82a8f610 82b0f7a4 nt!NtAccessCheckByTypeResultList<br class="title-page-name"/>82a8f614 82d02611 nt!NtAccessCheckByTypeResultListAndAuditAlarm<br class="title-page-name"/>[REMOVED]</pre>
<p class="calibre2">There is a second table, similar to the SSDT, known as <em class="calibre17">SSDT shadow</em>. This table stores the pointers to the GUI-related functions exported by <kbd class="calibre13">win32k.sys.</kbd> To display the entries of both the tables, you can use the <kbd class="calibre13">ssdt</kbd> volatility plugin, as shown here. <kbd class="calibre13">SSDT[0]</kbd> refers to the native <em class="calibre17">SSDT table</em> and <kbd class="calibre13">SSDT[1]</kbd> refers to <em class="calibre17">SSDT shadow</em>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f win7_x86.vmem --profile=Win7SP1x86 ssdt</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>[x86] Gathering all referenced SSDTs from KTHREADs...<br class="title-page-name"/>Finding appropriate address space for tables...<br class="title-page-name"/><strong class="calibre1">SSDT[0]</strong> <strong class="calibre1">at 82a8f5fc with 401 entries</strong><br class="title-page-name"/>  Entry 0x0000: 0x82c8f06a (NtAcceptConnectPort) owned by ntoskrnl.exe<br class="title-page-name"/>  Entry 0x0001: 0x82ad2739 (NtAccessCheck) owned by ntoskrnl.exe<br class="title-page-name"/>  Entry 0x0002: 0x82c1e065 (NtAccessCheckAndAuditAlarm) owned by ntoskrnl.exe<br class="title-page-name"/>  Entry 0x0003: 0x82a35a1c (NtAccessCheckByType) owned by ntoskrnl.exe<br class="title-page-name"/>  [REMOVED]<br class="title-page-name"/><strong class="calibre1">SSDT[1]</strong> <strong class="calibre1">at 96c37000 with 825 entries</strong><br class="title-page-name"/>  Entry 0x1000: 0x96bc0e6d (NtGdiAbortDoc) owned by win32k.sys<br class="title-page-name"/>  Entry 0x1001: 0x96bd9497 (NtGdiAbortPath) owned by win32k.sys<br class="title-page-name"/>  Entry 0x1002: 0x96a272c1 (NtGdiAddFontResourceW) owned by win32k.sys<br class="title-page-name"/>  Entry 0x1003: 0x96bcff67 (NtGdiAddRemoteFontToDC) owned by win32k.sys</pre>
<p class="calibre2">In the case of SSDT hooking, an attacker replaces the pointer of a specific function with the address of the malicious function. For instance, if an attacker wishes to intercept the data that is written to a file, the pointer to <kbd class="calibre13">NtWriteFile()</kbd> can be changed to point to the address of the malicious function of an attacker's choice. This is illustrated in the following diagram:</p>
<div class="cdpaligncenter"><img src="../images/00363.jpeg" class="calibre41"/></div>
<p class="calibre2">To detect SSDT hooking, you can look for the entries in the SSDT table that do not point to addresses in <kbd class="calibre13">ntoskrnl.exe</kbd> or <kbd class="calibre13">win32k.sys.</kbd> The following code is an example of the <em class="calibre17">Mader</em> rootkit, which hooks various-registry related functions and points them to the malicious driver <kbd class="calibre13">core.sys.</kbd> At this stage, you can determine the base address of <kbd class="calibre13">core.sys</kbd> using <kbd class="calibre13">modules</kbd>, <kbd class="calibre13">modscan</kbd>, or <kbd class="calibre13">driverscan</kbd> and then dump it to disk for further analysis using the <kbd class="calibre13">moddump</kbd> plugin:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f mader.vmem --profile=WinXPSP3x86 ssdt | egrep -v "(ntoskrnl|win32k)"</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>[x86] Gathering all referenced SSDTs from KTHREADs...<br class="title-page-name"/>Finding appropriate address space for tables...<br class="title-page-name"/>SSDT[0] at 80501b8c with 284 entries<br class="title-page-name"/> <strong class="calibre1"> Entry 0x0019: 0xf66eb74e (NtClose) owned by core.sys</strong><br class="title-page-name"/><strong class="calibre1">  Entry 0x0029: 0xf66eb604 (NtCreateKey) owned by core.sys</strong><br class="title-page-name"/><strong class="calibre1">  Entry 0x003f: 0xf66eb6a6 (NtDeleteKey) owned by core.sys</strong><br class="title-page-name"/><strong class="calibre1">  Entry 0x0041: 0xf66eb6ce (NtDeleteValueKey) owned by core.sys</strong><br class="title-page-name"/><strong class="calibre1">  Entry 0x0062: 0xf66eb748 (NtLoadKey) owned by core.sys</strong><br class="title-page-name"/><strong class="calibre1">  Entry 0x0077: 0xf66eb4a7 (NtOpenKey) owned by core.sys</strong><br class="title-page-name"/><strong class="calibre1">  Entry 0x00c1: 0xf66eb6f8 (NtReplaceKey) owned by core.sys</strong><br class="title-page-name"/><strong class="calibre1">  Entry 0x00cc: 0xf66eb720 (NtRestoreKey) owned by core.sys</strong><br class="title-page-name"/><strong class="calibre1">  Entry 0x00f7: 0xf66eb654 (NtSetValueKey) owned by core.sys</strong></pre>
<p class="calibre2">The disadvantage of using SSDT hooking for an attacker is that it is easy to detect, and the 64-bit release of Windows prevents SSDT hooking due to the <strong class="calibre5">Kernel Patch Protection</strong> (<strong class="calibre5">KPP</strong>) mechanism, also known as <em class="calibre17">PatchGuard</em> (<a href="https://en.wikipedia.org/wiki/Kernel_Patch_Protection" class="calibre10">https://en.wikipedia.org/wiki/Kernel_Patch_Protection</a>). Since the entries in the SSDT vary across different versions of Windows and are subject to change in newer versions, it becomes difficult for a malware author to write a rootkit that is reliable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">8.2 Detecting IDT Hooking</h1>
                
            
            <article>
                
<p class="calibre2">The <strong class="calibre5">Interrupt Descriptor Table</strong> (<strong class="calibre5">IDT</strong>) stores the addresses of functions known as <em class="calibre17">ISR (Interrupt Service Routines or Interrupt handlers).</em> These functions handle interrupts and processor exceptions. Like hooking an SSDT, an attacker may hook the entries in the IDT to redirect control to the malicious code. To display the IDT entries, you can use the <kbd class="calibre13">idt</kbd> Volatility plugin. An example of a malware which hooked an IDT is the <em class="calibre17">Uroburos (Turla) rootkit.</em> This rootkit hooked the interrupt handler located at the <kbd class="calibre13">0xc3 (INT C3)</kbd> index. On a clean system, the interrupt handler at <kbd class="calibre13">0xC3</kbd> points to an address that resides in the memory of <kbd class="calibre13">ntoskrnl.exe</kbd>. The following output shows the entry from the clean system:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f win7.vmem --profile=Win7SP1x86 idt</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>   CPU   Index   Selector   Value        Module      Section <br class="title-page-name"/>------   ------  ---------- ----------  ---------    ------------<br class="title-page-name"/>     0    0         0x8     0x82890200  ntoskrnl.exe  .text <br class="title-page-name"/>     0    1         0x8     0x82890390  ntoskrnl.exe  .text <br class="title-page-name"/>     0    2         0x58    0x00000000  NOT USED <br class="title-page-name"/>     0    3         0x8     0x82890800  ntoskrnl.exe  .text <br class="title-page-name"/>     [REMOVED]<br class="title-page-name"/>     0    C1        0x8     0x8282f3f4  hal.dll       _PAGELK <br class="title-page-name"/>     0    C2        0x8     0x8288eea4  ntoskrnl.exe  .text <br class="title-page-name"/>     <strong class="calibre1">0    C3        0x8     0x8288eeae  ntoskrnl.exe  .text</strong></pre>
<p class="calibre2">The following output displays the hooked entry. You can see that the <kbd class="calibre13">0xC3</kbd> entry in the IDT is pointing to an address in the <kbd class="calibre13">UNKNOWN</kbd> module. In other words, the hooked entry resides outside the range of the <kbd class="calibre13">ntoskrnl.exe</kbd> module:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f turla1.vmem --profile=Win7SP1x86 idt</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>   CPU   Index   Selector   Value        Module      Section <br class="title-page-name"/>------   ------  ---------- ----------  ---------    ------------<br class="title-page-name"/>     0    0         0x8     0x82890200  ntoskrnl.exe  .text <br class="title-page-name"/>     0    1         0x8     0x82890390  ntoskrnl.exe  .text <br class="title-page-name"/>     0    2         0x58    0x00000000  NOT USED <br class="title-page-name"/>     0    3         0x8     0x82890800  ntoskrnl.exe  .text <br class="title-page-name"/>     [REMOVED]<br class="title-page-name"/>     0    C1        0x8     0x8282f3f4  hal.dll       _PAGELK <br class="title-page-name"/>     0    C2        0x8     0x8288eea4  ntoskrnl.exe  .text <br class="title-page-name"/>     <strong class="calibre1">0    C3        0x8     0x85b422b0  UNKNOWN        </strong></pre>
<div class="packt_infobox">For detailed analysis of Uroburos rootkit and to understand the technique used by the rootkit to trigger the hooked interrupt handler, refer to the following blog post: <a href="https://www.gdatasoftware.com/blog/2014/06/23953-analysis-of-uroburos-using-windbg" target="_blank" class="calibre20">https://www.gdatasoftware.com/blog/2014/06/23953-analysis-of-uroburos-using-windbg</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">8.3 Identifying Inline Kernel Hooks</h1>
                
            
            <article>
                
<p class="calibre2">Instead of replacing the pointers in the SSDT, which makes it easy to recognize, an attacker can modify the kernel function or function in an existing kernel driver with a <kbd class="calibre13">jmp</kbd> instruction to reroute the execution flow to the malicious code. As mentioned earlier in this chapter, you can use the <kbd class="calibre13">apihooks</kbd> plugin to detect inline hooking in the kernel space. By specifying the <kbd class="calibre13">-P</kbd> argument, you can tell the <kbd class="calibre13">apihooks</kbd> plugin to only scan for the hooks in the kernel space. In the following example of a <em class="calibre17">TDL3 rootkit</em>, the <kbd class="calibre13">apihooks</kbd> detect the hooks in the kernel functions <kbd class="calibre13">IofCallDriver</kbd> and <kbd class="calibre13">IofCompleteRequest.</kbd> The hooked API functions are redirected to the <kbd class="calibre13">0xb878dfb2</kbd> and <kbd class="calibre13">0xb878e6bb</kbd> addresses within a malicious module whose name is unknown (possibly because it is hiding by unlinking the <kbd class="calibre13">KLDR_DATA_TABLE_ENTRY</kbd> structure):</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f tdl3.vmem --profile=WinXPSP3x86 apihooks -P</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>************************************************************************<br class="title-page-name"/>Hook mode: Kernelmode<br class="title-page-name"/>Hook type: Inline/Trampoline<br class="title-page-name"/>Victim module: ntoskrnl.exe (0x804d7000 - 0x806cf580)<br class="title-page-name"/>Function: <strong class="calibre1">ntoskrnl.exe!IofCallDriver at 0x804ee120</strong><br class="title-page-name"/>Hook address: <strong class="calibre1">0xb878dfb2</strong><br class="title-page-name"/>Hooking module: <strong class="calibre1">&lt;unknown&gt;</strong><br class="title-page-name"/><br class="title-page-name"/>Disassembly(0):<br class="title-page-name"/>0x804ee120 ff2500c25480 <strong class="calibre1">JMP DWORD [0x8054c200]</strong><br class="title-page-name"/>0x804ee126 cc           INT 3<br class="title-page-name"/>0x804ee127 cc           INT 3<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/><br class="title-page-name"/>************************************************************************<br class="title-page-name"/>Hook mode: Kernelmode<br class="title-page-name"/>Hook type: Inline/Trampoline<br class="title-page-name"/>Victim module: ntoskrnl.exe (0x804d7000 - 0x806cf580)<br class="title-page-name"/>Function: <strong class="calibre1">ntoskrnl.exe!IofCompleteRequest at 0x804ee1b0</strong><br class="title-page-name"/>Hook address: <strong class="calibre1">0xb878e6bb</strong><br class="title-page-name"/>Hooking module: <strong class="calibre1">&lt;unknown&gt;</strong><br class="title-page-name"/><br class="title-page-name"/>Disassembly(0):<br class="title-page-name"/>0x804ee1b0 ff2504c25480 <strong class="calibre1">JMP DWORD [0x8054c204]</strong><br class="title-page-name"/>0x804ee1b6 cc           INT 3<br class="title-page-name"/>0x804ee1b7 cc           INT 3<br class="title-page-name"/>[REMOVED]</pre>
<p class="calibre2">Even though the name of the hooking module is unknown, it is still possible to detect the malicious kernel module. In this case, we know the API functions are redirected to addresses starting with <kbd class="calibre13">0xb87</kbd> within the malicious module, which means the malicious module must be residing at some address starting with <kbd class="calibre13">0xb87</kbd>.  Running the <kbd class="calibre13">modules</kbd> plugin does not detect any module at that address range (because it is hidden), whereas the modscan plugin detected a kernel module called <kbd class="calibre13">TDSSserv.sys</kbd> loaded at base address <kbd class="calibre13">0xb878c000</kbd> with a size of <kbd class="calibre13">0x11000.</kbd> In other words, the start address of the kernel module <kbd class="calibre13">TDSSserv.sys</kbd> is <kbd class="calibre13">0xb878c000</kbd> and the end address is <kbd class="calibre13">0xb879d000 (0xb878c000+0x11000)</kbd>. You can clearly see that the hook addresses <kbd class="calibre13">0xb878dfb2</kbd> and <kbd class="calibre13">0xb878e6bb</kbd> fall within the address range of <kbd class="calibre13">TDSSserv.sys</kbd>. At this point, we have successfully identified the malicious driver. You can now dump the driver to disk for further analysis:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f tdl3.vmem --profile=WinXPSP3x86 modules | grep -i 0xb878</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/><br class="title-page-name"/>$ <strong class="calibre1">python vol.py -f tdl3.vmem --profile=WinXPSP3x86 modscan | grep -i 0xb878</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/><strong class="calibre1">0x0000000009773c98 TDSSserv.sys 0xb878c000 0x11000 \systemroot\system32\drivers\TDSSserv.sys</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">8.4 Detecting IRP Function Hooks</h1>
                
            
            <article>
                
<p class="calibre2">Instead of hooking the kernel API functions, a rootkit can modify the entries in the major function table (dispatch routine array) to point to a routine in the malicious module. For example, a rookit can inspect the data buffer that is written to a disk or network by overwriting the address corresponding to <kbd class="calibre13">IRP_MJ_WRITE</kbd> in a driver's major function table. The following diagram illustrates this concept:</p>
<div class="cdpaligncenter"><img src="../images/00364.jpeg" class="calibre275"/></div>
<p class="calibre2">Normally, the IRP handler functions of a driver point within their own module. For instance, the routine associated with <kbd class="calibre13">IRP_MJ_WRITE</kbd> of <kbd class="calibre13">null.sys</kbd> points to an address in <kbd class="calibre13">null.sys</kbd>, however, sometimes a driver will forward the handler function to another driver. The following is an example of the disk driver forwarding handler functions to <kbd class="calibre13">CLASSPNP.SYS</kbd> (the storage class device driver):</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f win7_clean.vmem --profile=Win7SP1x64 driverirp -r disk</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>--------------------------------------------------<br class="title-page-name"/>DriverName: Disk<br class="title-page-name"/>DriverStart: 0xfffff88001962000<br class="title-page-name"/>DriverSize: 0x16000<br class="title-page-name"/>DriverStartIo: 0x0<br class="title-page-name"/>   <strong class="calibre1">0 IRP_MJ_CREATE                0xfffff88001979700 CLASSPNP.SYS</strong><br class="title-page-name"/>   1 IRP_MJ_CREATE_NAMED_PIPE     0xfffff8000286d65c ntoskrnl.exe<br class="title-page-name"/>   <strong class="calibre1">2 IRP_MJ_CLOSE                 0xfffff88001979700 CLASSPNP.SYS</strong><br class="title-page-name"/>   <strong class="calibre1">3 IRP_MJ_READ                  0xfffff88001979700 CLASSPNP.SYS</strong><br class="title-page-name"/>   <strong class="calibre1">4 IRP_MJ_WRITE                 0xfffff88001979700 CLASSPNP.SYS</strong><br class="title-page-name"/>   5 IRP_MJ_QUERY_INFORMATION     0xfffff8000286d65c ntoskrnl.exe<br class="title-page-name"/>   [REMOVED] </pre>
<p class="calibre2">To detect IRP hooks, you can focus on IRP handler functions that point to another driver, and since the driver can forward an IRP handler to another driver, you need to further investigate it to confirm the hook. If you are analyzing the rootkit in a lab setup, then you can list the IRP functions of all the drivers from a clean memory image and compare them with the IRP functions from the infected memory image for any modifications. In the following example, the <em class="calibre17">ZeroAccess rootkit</em> hooks the IRP functions of the disk driver and redirects them to the functions within a malicious module whose address is unknown (because the module is hidden):</p>
<pre class="calibre18">DriverName: Disk<br class="title-page-name"/>DriverStart: 0xba8f8000<br class="title-page-name"/>DriverSize: 0x8e00<br class="title-page-name"/>DriverStartIo: 0x0<br class="title-page-name"/>   <strong class="calibre1">0 IRP_MJ_CREATE                0xbabe2bde Unknown</strong><br class="title-page-name"/><strong class="calibre1">   1 IRP_MJ_CREATE_NAMED_PIPE     0xbabe2bde Unknown</strong><br class="title-page-name"/><strong class="calibre1">   2 IRP_MJ_CLOSE                 0xbabe2bde Unknown</strong><br class="title-page-name"/><strong class="calibre1">   3 IRP_MJ_READ                  0xbabe2bde Unknown</strong><br class="title-page-name"/><strong class="calibre1">   4 IRP_MJ_WRITE                 0xbabe2bde Unknown</strong><br class="title-page-name"/><strong class="calibre1">   5 IRP_MJ_QUERY_INFORMATION     0xbabe2bde Unknown</strong><br class="title-page-name"/>   [REMOVED]</pre>
<p class="calibre2">The following output from the <kbd class="calibre13">modscan</kbd> displays the malicious driver (with a suspicious name) associated with <em class="calibre17">ZeroAccess</em> and the base address where it is loaded in the memory (which can be used to dump the driver to disk):</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f zaccess_maxplus.vmem --profile=WinXPSP3x86 modscan | grep -i 0xbabe</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/><strong class="calibre1">0x0000000009aabf18 * 0xbabe0000 0x8000 \*</strong></pre>
<p class="calibre2">Some rootkits use indirect IRP hooking to avoid suspicion. In the following example, the <em class="calibre17">Gapz</em> Bootkit hooks the <kbd class="calibre13">IRP_MJ_DEVICE_CONTROL</kbd> of <kbd class="calibre13">null.sys</kbd>. At first glance, it may look like everything is normal because the IRP handler address corresponding to <kbd class="calibre13">IRP_MJ_DEVICE_CONTROL</kbd> points to within <kbd class="calibre13">null.sys.</kbd> Upon close inspection, you will notice the discrepancy; on a clean system, <kbd class="calibre13">IRP_MJ_DEVICE_CONTROL</kbd> points to the address in <kbd class="calibre13">ntoskrnl.exe</kbd> (<kbd class="calibre13">nt!IopInvalidDeviceRequest</kbd>). In this case, it is pointing to <kbd class="calibre13">0x880ee040</kbd> in <kbd class="calibre13">null.sys</kbd>. After disassembling the address <kbd class="calibre13">0x880ee040</kbd> (using the <kbd class="calibre13">volshell</kbd> plugin), you can see the jump to an address of <kbd class="calibre13">0x8518cad9</kbd>, which is outside the range of <kbd class="calibre13">null.sys</kbd>:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f gapz.vmem --profile=Win7SP1x86 driverirp -r null</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>--------------------------------------------------<br class="title-page-name"/>DriverName: Null<br class="title-page-name"/>DriverStart: 0x880eb000<br class="title-page-name"/>DriverSize: 0x7000<br class="title-page-name"/>DriverStartIo: 0x0<br class="title-page-name"/>   0 IRP_MJ_CREATE                   0x880ee07c Null.SYS<br class="title-page-name"/>   1 IRP_MJ_CREATE_NAMED_PIPE        0x828ee437 ntoskrnl.exe<br class="title-page-name"/>   2 IRP_MJ_CLOSE                    0x880ee07c Null.SYS<br class="title-page-name"/>   3 IRP_MJ_READ                     0x880ee07c Null.SYS<br class="title-page-name"/>   4 IRP_MJ_WRITE                    0x880ee07c Null.SYS<br class="title-page-name"/>   5 IRP_MJ_QUERY_INFORMATION        0x880ee07c Null.SYS<br class="title-page-name"/>   [REMOVED]<br class="title-page-name"/>  13 IRP_MJ_FILE_SYSTEM_CONTROL      0x828ee437 ntoskrnl.exe<br class="title-page-name"/>  14 <strong class="calibre1">IRP_MJ_DEVICE_CONTROL           0x880ee040 Null.SYS</strong><br class="title-page-name"/>  15 IRP_MJ_INTERNAL_DEVICE_CONTROL  0x828ee437 ntoskrnl.exe<br class="title-page-name"/><br class="title-page-name"/>$ <strong class="calibre1">python vol.py -f gapz.vmem --profile=Win7SP1x86 volshell</strong><br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>&gt;&gt;&gt; <strong class="calibre1">dis(0x880ee040)</strong><br class="title-page-name"/>0x880ee040 8bff        MOV EDI, EDI<br class="title-page-name"/>0x880ee042 e992ea09fd  <strong class="calibre1">JMP 0x8518cad9</strong><br class="title-page-name"/>0x880ee047 6818e10e88  PUSH DWORD 0x880ee118</pre>
<div class="packt_infobox">For detailed information on the stealth techniques used by the Gapz Bootkit, read the whitepaper (<a href="https://www.welivesecurity.com/wp-content/uploads/2013/04/gapz-bootkit-whitepaper.pdf" class="calibre20">https://www.welivesecurity.com/wp-content/uploads/2013/04/gapz-bootkit-whitepaper.pdf</a>) titled "<em class="calibre22">Mind the Gapz: The Most Complex Bootkit Ever Analyzed"</em> by Eugene Rodionov and Aleksandr Matrosov.</div>
<p class="calibre2">As discussed so far, detecting standard hooking techniques is fairly straightforward. For instance, you can look for signs such as SSDT entries not pointing to <kbd class="calibre13">ntoskrnl.exe</kbd>/<kbd class="calibre13">win32k.sys</kbd> or IRP functions pointing to somewhere else, or jump instructions at the start of the function. To avoid such detections, an attacker can implement hooks while keeping call table entries within the range, or place the jump instructions deep inside the code. To do this, they need to rely on patching the system modules or third-party drivers. The problem with patching system modules is that <em class="calibre17">Windows Kernel Patch Protection (PatchGuard)</em> prevents patching call tables (such as SSDT or IDT) and the core system modules on 64-bit systems. For these reasons, attackers either use techniques that rely on bypassing these protection mechanisms (such as installing a <em class="calibre17">Bootkit/</em>exploiting kernel-mode vulnerabilities) or they use supported ways (which also work on 64-bit systems) to execute their malicious code to blend in with other legitimate drivers and reduce the risk of detection. In the next section, we will look at some of the supported techniques used by the rootkits.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">9. Kernel Callbacks And Timers</h1>
                
            
            <article>
                
<p class="calibre2">The Windows operating system allows a driver to register a callback routine, which will be called when a particular event occurs. For instance, if a rootkit driver wants to monitor the execution and termination of all processes running on the system, it can register a callback routine for the process event by calling the kernel function <kbd class="calibre13">PsSetCreateProcessNotifyRoutine</kbd>, <kbd class="calibre13">PsSetCreateProcessNotifyRoutineEx</kbd>, or <kbd class="calibre13">PsSetCreateProcessNotifyRoutineEx2</kbd>. When the process event occurs (starts or exits) the rootkit's callback routine will be invoked, which can then take necessary action such as preventing a process from launching. In the same manner, a rootkit driver can register a callback routine to receive notifications when an image (EXE or DLL) gets loaded into memory, when file and registry operations are performed, or when the system is about to be shut down. In other words, the callback functionality gives the rootkit driver the ability to monitor system activities and take necessary action depending on the activity. You can get a list of some of the documented and undocumented kernel functions that the rootkit may use to register callback routines at the following link: <a href="https://www.codemachine.com/article_kernel_callback_functions.html" target="_blank" class="calibre10">https://www.codemachine.com/article_kernel_callback_functions.html</a>. The kernel functions are defined in different header files (<kbd class="calibre13">ntddk.h</kbd>, <kbd class="calibre13">Wdm.h</kbd>, and so on) in the <em class="calibre17">Windows Driver Kit (WDK)</em>. The quickest method to get details on the documented kernel functions is to do a quick Google search, which should take you to the appropriate link in the WDK online documentation.</p>
<p class="calibre2">The way callbacks work is that a particular driver creates a callback object, which is a structure that contains the list of function pointers. The created callback object is advertised so that it can be used by other drivers. The other drivers can then register their callback routines with the driver that created the callback object (<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/callback-objects" target="_blank" class="calibre10">https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/callback-objects</a>). The driver that created the callback can be the same as or different from the kernel driver that is registering for the callback. To look at the system-wide callback routines, you can use <kbd class="calibre13">callbacks</kbd> Volatility plugin. On a clean Windows system, you will typically see many callbacks installed by various drivers, which means not all entries in the <kbd class="calibre13">callbacks</kbd> output are malicious; further analysis is required to identify the malicious driver from a suspect memory image.</p>
<p class="calibre2">In the following example, the <em class="calibre17">Mader rootkit</em> as which performed <em class="calibre17">SSDT hooking</em> (discussed in the<em class="calibre17"> Detecting SSDT Hooking</em> section of this chapter), also installed a process creation callback routine to monitor the execution or termination of all the processes running on the system. In particular, when a process event occurs, the callback routine at address <kbd class="calibre13">0xf66eb050</kbd> within the malicious module <kbd class="calibre13">core.sys</kbd> is invoked. The <kbd class="calibre13">Module</kbd> column specifies the name of the kernel module within which the callback function is implemented. The <kbd class="calibre13">Details</kbd> column gives the name or description of the kernel object that installed the callback. After you have identified the malicious driver, you can further investigate it or you can dump it to disk for further analysis (disassembly, AV scanning, string extraction, and so on), as shown in the <kbd class="calibre13">moddump</kbd> command here:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f mader.vmem --profile=WinXPSP3x86 callbacks</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Type                             Callback    Module        Details<br class="title-page-name"/>---------------------------      ----------  ----------   -------<br class="title-page-name"/>IoRegisterShutdownNotification  0xf9630c6a  VIDEOPRT.SYS  \Driver\VgaSave<br class="title-page-name"/>IoRegisterShutdownNotification  0xf9630c6a  VIDEOPRT.SYS  \Driver\vmx_svga<br class="title-page-name"/>IoRegisterShutdownNotification  0xf9630c6a  VIDEOPRT.SYS  \Driver\mnmdd<br class="title-page-name"/>IoRegisterShutdownNotification  0x805f5d66  ntoskrnl.exe  \Driver\WMIxWDM<br class="title-page-name"/>IoRegisterFsRegistrationChange  0xf97c0876  sr.sys         -<br class="title-page-name"/><strong class="calibre1">GenericKernelCallback           0xf66eb050  core.sys       -</strong><br class="title-page-name"/><strong class="calibre1">PsSetCreateProcessNotifyRoutine 0xf66eb050  core.sys       -</strong><br class="title-page-name"/>KeBugCheckCallbackListHead      0xf96e85ef  NDIS.sys      Ndis miniport<br class="title-page-name"/>[REMOVED]</pre>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f mader.vmem --profile=WinXPSP3x86 modules | grep -i core<br class="title-page-name"/></strong>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>0x81772bf8  core.sys  0xf66e9000  0x12000   \system32\drivers\core.sys</pre>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f mader.vmem --profile=WinXPSP3x86 moddump -b 0xf66e9000 -D dump/</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Module Base    Module Name      Result<br class="title-page-name"/>-----------   ----------------- ------<br class="title-page-name"/>0x0f66e9000    core.sys         OK: driver.f66e9000.sys</pre>
<p class="calibre2">In the following example, the <em class="calibre17">TDL3 rootkit</em> installs process callback and image load callback notifications. This allows the rootkit to monitor process events and to get notifications when an executable image (EXE, DLL, or kernel module) is mapped into memory. The module names in the entries are set to <kbd class="calibre13">UNKNOWN</kbd>; this tells you that callback routine exists in an unknown module, which happens if the rootkit driver tries to hide by unlinking the <kbd class="calibre13">KLDR_DATA_TABLE_ENTRY</kbd> structure or if a rootkit is running an orphan thread (a thread that is hidden or detached from the kernel module). In such cases, the <kbd class="calibre13">UNKNOWN</kbd> entry makes it easy for you to spot the suspicious entry:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f tdl3.vmem --profile=WinXPSP3x86 callbacks</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Type                            Callback    Module        Details<br class="title-page-name"/>------------------------        ----------  --------      -------<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>IoRegisterShutdownNotification  0x805cdef4  ntoskrnl.exe  \FileSystem\RAW<br class="title-page-name"/>IoRegisterShutdownNotification  0xba8b873a  MountMgr.sys  \Driver\MountMgr<br class="title-page-name"/><strong class="calibre1">GenericKernelCallback           0xb878f108  UNKNOWN        -</strong><br class="title-page-name"/>IoRegisterFsRegistrationChange  0xba6e34b8  fltMgr.sys     -<br class="title-page-name"/><strong class="calibre1">GenericKernelCallback           0xb878e8e9  UNKNOWN        -</strong><br class="title-page-name"/><strong class="calibre1">PsSetLoadImageNotifyRoutine     0xb878f108  UNKNOWN        -</strong><br class="title-page-name"/><strong class="calibre1">PsSetCreateProcessNotifyRoutine 0xb878e8e9  UNKNOWN        -</strong><br class="title-page-name"/>KeBugCheckCallbackListHead      0xba5f45ef  NDIS.sys      Ndis miniport<br class="title-page-name"/>[REMOVED]</pre>
<p class="calibre2">Even though the module name is <kbd class="calibre13">UNKNOWN</kbd>, based on the callback routine address, we can deduce that the malicious module should be residing somewhere in the memory region starting with address <kbd class="calibre13">0xb878</kbd>. From the output of the <kbd class="calibre13">modules</kbd> plugin, you can see that the module has unlinked itself, but the <kbd class="calibre13">modscan</kbd> plugin was able to detect the kernel module which is loaded at <kbd class="calibre13">0xb878c000</kbd> and with a size of <kbd class="calibre13">0x11000</kbd>. Clearly, all the callback routine addresses fall within the range of this module. Now that the base address of the kernel module is known, you can dump it using the <kbd class="calibre13">moddump</kbd> plugin for further analysis:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f tdl3.vmem --profile=WinXPSP3x86 modules | grep -i 0xb878</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/><br class="title-page-name"/>$ <strong class="calibre1">python vol.py -f tdl3.vmem --profile=WinXPSP3x86 modscan | grep -i 0xb878</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>0x9773c98 TDSSserv.sys 0xb878c000 0x11000 \system32\drivers\TDSSserv.sys</pre>
<p class="calibre2">Like callbacks, a rootkit driver may create a timer and get notified when the specified time elapses. A rootkit driver may use this functionality to schedule operations to be performed periodically. The way it works is that the rootkit creates a timer and provides a callback routine known as <em class="calibre17">DPC (Deferred Procedure Call),</em> which will be called when the timer expires. When the callback routine is invoked, the rootkit can perform malicious actions. In other words, the timer is another way by which a rootkit can get to execute its malicious code. For detailed information on how the kernel timer works, refer to the following Microsoft documentation: <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/timer-objects-and-dpcs" target="_blank" class="calibre10">https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/timer-objects-and-dpcs</a>.</p>
<p class="calibre2">To list the kernel timers, you can use the <kbd class="calibre13">timers</kbd> Volatility plugin. A point to note out is that timers are not malicious, as such; it is a Windows functionality, so on a clean system you will see some of the legitimate drivers installing timers. Like callbacks, further analysis may be required to identify the malicious module. Since most rootkits try to hide their driver, as a result, obvious artifacts are created that can help you quickly identify the malicious module. In the following example, the <em class="calibre17">ZeroAccess rootkit</em> installs a timer for <kbd class="calibre13">6000</kbd> milliseconds. When this time elapses, the routine at address <kbd class="calibre13">0x814f9db0</kbd> in an <kbd class="calibre13">UNKNOWN</kbd> module is invoked. The <kbd class="calibre13">UNKNOWN</kbd> in the <kbd class="calibre13">Module</kbd> column tells us that the module is probably hidden, but the routine address points you to the memory range where the malicious code is present:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 timers</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Offset(V)  DueTime                Period(ms) Signaled Routine   Module<br class="title-page-name"/>---------- ---------------------  --------- -------- -------- ------<br class="title-page-name"/>0x805516d0 0x00000000:0x6b6d9546  60000      Yes    0x804f3eae ntoskrnl.exe<br class="title-page-name"/>0x818751f8 0x80000000:0x557ed358  0          -      0x80534e48 ntoskrnl.exe<br class="title-page-name"/>0x81894948 0x00000000:0x64b695cc  10000      -      0xf9cbc6c4 watchdog.sys<br class="title-page-name"/>0xf6819990 0x00000000:0x78134eb2  60000      Yes    0xf68021f8 HTTP.sys<br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>0xf7228d60 0x00000000:0x714477b4  60000      Yes    0xf7220266 ipnat.sys<br class="title-page-name"/><strong class="calibre1">0x814ff790 0x00000000:0xc4b6c5b4  60000      -      0x814f9db0 UNKNOWN</strong><br class="title-page-name"/>0x81460728 0x00000000:0x760df068  0          -      0x80534e48 ntoskrnl.exe<br class="title-page-name"/>[REMOVED]</pre>
<p class="calibre2">In addition to timers, <em class="calibre17">ZeroAccess</em> also installs callbacks to monitor registry operations. Again, the callback routine address points to the same memory range (starting with <kbd class="calibre13">0x814f</kbd>):</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 callbacks</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>Type                           Callback    Module         Details<br class="title-page-name"/>------------------------------ ----------  -----------    -------<br class="title-page-name"/>IoRegisterShutdownNotification 0xf983e2be  ftdisk.sys    \Driver\Ftdisk<br class="title-page-name"/>IoRegisterShutdownNotification 0x805cdef4  ntoskrnl.exe  \FileSystem\RAW<br class="title-page-name"/>IoRegisterShutdownNotification 0x805f5d66  ntoskrnl.exe  \Driver\WMIxWDM<br class="title-page-name"/><strong class="calibre1">GenericKernelCallback          0x814f2d60  UNKNOWN       -</strong><br class="title-page-name"/>KeBugCheckCallbackListHead     0xf96e85ef  NDIS.sys      Ndis miniport<br class="title-page-name"/><strong class="calibre1">CmRegisterCallback             0x814f2d60  UNKNOWN       -</strong></pre>
<p class="calibre2">Trying to find the <kbd class="calibre13">UNKNOWN</kbd> module using the <kbd class="calibre13">modules</kbd>, <kbd class="calibre13">modscan</kbd>, and <kbd class="calibre13">driverscan</kbd> plugins does not return any results:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 modules | grep -i 0x814f</strong><br class="title-page-name"/><br class="title-page-name"/>$ <strong class="calibre1">python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 modscan | grep -i 0x814f</strong><br class="title-page-name"/><br class="title-page-name"/>$ <strong class="calibre1">python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 driverscan | grep -i 0x814f</strong></pre>
<p class="calibre2">Inspecting the driverscan listing revealed suspicious entries where the base address and the size are zeroed out (which is not normal and could be a bypass trick). Zeroing out the base address explains why <kbd class="calibre13">modules</kbd>, <kbd class="calibre13">modscan</kbd>, and <kbd class="calibre13">driverscan</kbd> did not return any results. The output also reveals that the name of the malicious driver is composed only of numbers, which adds to the suspicion:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 driverscan</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>0x00001abf978  1  0  <strong class="calibre1">0x00000000  0x0</strong>  \Driver\00009602  \Driver\00009602<br class="title-page-name"/>0x00001b017e0  1  0  <strong class="calibre1">0x00000000  0x0</strong>  \Driver\00009602  \Driver\00009602</pre>
<p class="calibre2">By zeroing out the base address, the rootkit is making it hard for the forensic analyst to determine the start address of the kernel module, which also prevents us from dumping the malicious module. We still know where the malicious code is residing (the address starting with <kbd class="calibre13">0x814f</kbd>). The compelling question is, how do we determine the base address using that information? One method is to take one of the addresses and subtract a certain number of bytes (such as by going backwards) till you find the <kbd class="calibre13">MZ</kbd> signature, but the problem with that approach is that it's not easy to determine how many bytes to subtract. The fastest method is to use the <kbd class="calibre13">yarascan</kbd> plugin, since this plugin allows you to scan for a pattern (string, hex bytes, or regex) in the memory. Since we are trying to find the module that resides in the kernel memory starting with address <kbd class="calibre13">0x814f</kbd>, we can use <kbd class="calibre13">yarascan</kbd> with <kbd class="calibre13">-K</kbd> ( which only scans kernel memory) to look for the <kbd class="calibre13">MZ</kbd> signature. From the output, you can see the presence of an executable at address <kbd class="calibre13">0x814f1b80</kbd>. You can specify this as the base address to dump the malicious module to disk using the <kbd class="calibre13">moddump</kbd> plugin. The dumped module is around 53.2 KB in size, which turns out to be <kbd class="calibre13">0xd000</kbd> bytes in hex. In other words, the module starts at address <kbd class="calibre13">0x814f1b80</kbd> and ends at <kbd class="calibre13">0x814feb80</kbd>. All the callback addresses fall within the address range of this module:</p>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 yarascan -K -Y "MZ" | grep -i 0x814f</strong><br class="title-page-name"/>Volatility Foundation Volatility Framework 2.6<br class="title-page-name"/>0x814f1b80 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 <strong class="calibre1">MZ</strong>..............<br class="title-page-name"/>0x814f1b90 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@.......<br class="title-page-name"/>0x814f1ba0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................<br class="title-page-name"/>0x814f1bb0 00 00 00 00 00 00 00 00 00 00 00 00 d0 00 00 00 ................<br class="title-page-name"/>0x814f1bc0 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 ........!..L.!<strong class="calibre1">Th</strong><br class="title-page-name"/>0x814f1bd0 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f <strong class="calibre1">is.program.canno</strong><br class="title-page-name"/>0x814f1be0 74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 <strong class="calibre1">t.be.run.in.DOS</strong>.<br class="title-page-name"/>0x814f1bf0 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00 <strong class="calibre1">mode</strong>....$.......</pre>
<pre class="calibre18">$ <strong class="calibre1">python vol.py -f zaccess1.vmem --profile=WinXPSP3x86 moddump -b 0x814f1b80 -D dump/</strong><br class="title-page-name"/>Module Base  Module Name          Result<br class="title-page-name"/>-----------  -------------------- ------<br class="title-page-name"/>0x0814f1b80  UNKNOWN              <strong class="calibre1">OK: driver.814f1b80.sys</strong><br class="title-page-name"/><br class="title-page-name"/>$ <strong class="calibre1">ls -al</strong><br class="title-page-name"/>[REMOVED]<br class="title-page-name"/>-rw-r--r-- 1 ubuntu ubuntu <strong class="calibre1">53248</strong> Jun 9 15:25 <strong class="calibre1">driver.814f1b80.sys</strong></pre>
<p class="calibre2">To confirm that the dumped module is malicious, it was submitted to <em class="calibre17">VirusTotal</em>. The results from AV vendors confirm it to be the <em class="calibre17">ZeroAccess Rootkit</em> (also known as <em class="calibre17">Sirefef</em>):</p>
<div class="cdpaligncenter"><img src="../images/00365.jpeg" class="calibre276"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">Malware authors use various advanced techniques to install their kernel driver and to bypass Windows security mechanisms. Once the kernel driver is installed, it can modify the system components or third-party drivers to bypass, deflect, and divert your forensic analysis. In this chapter, you looked at some of the most common rootkit techniques and we saw how to detect such techniques using memory forensics. Memory forensics is a powerful technique, and using it as part of your malware analysis efforts will greatly help you understand adversary tactics. Malware authors frequently come up with new ways to hide their malicious component, so it is not enough just to know how to use the tools; it becomes important to understand the underlying concepts to recognize the efforts by the attackers to bypass the forensic tools.</p>


            </article>

            
        </section>
    </body></html>