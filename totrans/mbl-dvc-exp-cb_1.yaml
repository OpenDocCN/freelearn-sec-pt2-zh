- en: Chapter 1.  Introduction to Mobile Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Android SDK and ADB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple Android app and running it in an emulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the Android permission model using ADB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing Android lock screen protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the iOS development environment - Xcode and iOS simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple iOS app and running it in the simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Android pentesting environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the iOS pentesting environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to rooting and jailbreaking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, smartphone usage is a much talked about subject. The world is quickly
    moving towards smartphone ownership, rather than traditional feature phones. Various
    studies and surveys have predicted increasing future usage of smartphones and
    tablets. There are incentives to do so; a lot of things are doable with these
    smartphones.
  prefs: []
  type: TYPE_NORMAL
- en: With increasing mobility comes risk. Attackers or cyber criminals look at all
    possible ways to attack users in order to obtain their personal data, credit card
    details, passwords, and other secrets. There have been threat reports from various
    security vendors on the increase in mobile attacks that comes with increased usage.
    Today, corporations are worried about data confidentiality and the resultant financial
    and reputational losses.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we introduce readers to some mobile device exploitation recipes,
    to let everyone understand the kind of attacks that are possible. Once people
    understand this, they will be more aware of such attack vectors and be better
    prepared to deal with them and secure their stuff.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will give the reader an idea about the basic security models of
    the two most popular mobile device platforms, Android and iOS. We will cover an
    introduction to their development environments and basic security models. We will
    set up a penetration testing environment and will introduce you to rooting and
    jailbreaking. This chapter builds the foundation for what is to be covered in
    the upcoming chapters, and is a pre-requisite for exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Android SDK and ADB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The very first step in Android development and security testing is to learn
    to install and configure the Android SDK and ADB. The **software development kit**
    (**SDK**) for Android comes in two installable versions; Android Studio and the
    standalone SDK tools. This recipe primarily uses Android Studio and later provides
    additional information about standalone SDK tools.
  prefs: []
  type: TYPE_NORMAL
- en: Android Debug Bridge (**ADB**) is a very useful tool, which can connect to Android
    devices and emulators and is used to perform debugging and security testing for
    mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever we use the words "Android devices" in this book, this means Android
    smartphones and tablets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigate to [https://developer.android.com](https://developer.android.com) and
    download either **Android Studio** or standalone SDK tools. You will also require
    JDK v7 or newer.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s set up using the first method, Android Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)
    and download the latest Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have downloaded the Android Studio installer file, the installer guides
    you through the next steps and you just have to follow the instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of writing this, the installer file used is `android-studio-bundle-135.1740770-windows.exe`.
  prefs: []
  type: TYPE_NORMAL
- en: Android SDK and ABD are installed as part of the default installation. Unless
    you deselect these, they will be installed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**AVD** stands for Android Virtual Device, which in turn refers to the Android
    emulator. Emulators provide a virtualized setup to test, run, and debug Android
    applications. These are especially useful in cases where hardware devices are
    not available. Most development testing works using emulators. We will use an
    emulator in the next recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the Android Studio and SDK installation paths. You will need them repeatedly
    in setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_01_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once Android Studio is installed, run it. It will guide you through the next
    set of instructions. It downloads the Android SDK tools, which may take up to
    4 hours depending upon the Internet speed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The development environment is ready. Take a moment to make yourself familiar
    with the SDK installation directory (the path shown in the preceding screenshot).
    There are a few quick things you must know:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SDK Manager**: This is used to manage Android packages and can be used to
    install or uninstall newer/older versions as required.![How it works...](graphics/image_01_002.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AVD Manager**: This is used to manage AVD. Use it to create a few emulators
    that we will use at the appropriate time.![How it works...](graphics/image_01_003.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now run one of the emulators to test whether the installed setup is working
    well. An emulator takes 2-3 minutes to start up, so be patient and if the installation
    has gone well, the emulator should be up and running. (Please refer to the next
    recipe if you want to look at the emulator screenshot now.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**platform-tools**: This folder contains useful tools such as ADB, SQLite3,
    and so on. We will use these tools in various recipes throughout this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tools**: This folder contains batch files and other executables. We will
    mostly use `emulator.exe`, as well as other `.exe` files in this folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an alternative way to develop in Android, as many people prefer other
    IDEs. In such cases, the standalone SDK tools can be downloaded. This provides
    the SDK tools required for application development and these tools can be invoked
    from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: These standalone tools are also useful for pentesters and black hats, for quick
    analysis of underlying, application-related stuff. A lot of the time, application
    development is not needed and there is a need to debug; in such cases, the standalone
    SDK tools can be used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Analyzing the Android permission model using ADB*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple Android app and running it in an emulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are ready with the Android SDK, let's write our first Android application.
    A little bit of coding skill is needed to get started. However, don't worry if
    source code scares you. There is a lot of sample code available in the Internet
    communities for you to use to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get ready to code the Android application, you need the SDK to be working
    well. If you have followed the first recipe and know a little bit of Java programming,
    the rest is easy and you are all set to code your very first Android application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write a very simple program to add two numbers together. I used the
    Eclipse IDE and created an Android application project called `Addition`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the graphical layout. Drag and drop three text fields (one each for the
    first number and the second number, and the last one to print the sum of the first
    two numbers), two TextView boxes to display text so that the user knows to enter
    two numbers, and finally a button for the addition action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `activity_main.xml` file is autogenerated. Edit it to look like the following
    code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the declared button:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the third variable, which will contain the sum of the two numbers,
    is declared:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have to write Java code to input and add the numbers, and output the
    sum. At this point, don''t worry if you do not know Activity, Intent, and so on.
    Just focus on getting the code error-free. Eclipse guides you at each step. We
    start our program with `MainActivity`, coded like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See how straightforward this program is; it just takes two numbers, adds them
    together, and provides the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Debug and run the program. The emulator opens up and the program runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Android In Action*, *Ableson, Sen*, *King*, *Manning Publications Co*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the Android permission model using ADB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having set up the development environment and coded your first Android application,
    now it's time to understand the underlying permission model of the Android operating
    system. The underlying operating system is Linux; the Android operating system
    is built using Linux as the basis. Applications in Linux run with a specific user
    ID and group ID. Android uses the same Linux model to set permissions for applications;
    this separates and protects Android applications from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have ADB installed. You also need an Android emulator or an Android
    device to connect to ADB.
  prefs: []
  type: TYPE_NORMAL
- en: A device or emulator that has been used frequently is best for this purpose
    (as a newly created emulator or device may not contain much data to view using
    ADB). Furthermore, for learning purposes, a rooted phone is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the steps given here for analyzing the Android permission model using
    ADB:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable **USB debugging** mode on your Android device and connect it via a data
    cable to a computer on which ADB is running. ADB is a very powerful tool and can
    be used to run various useful commands, which can help us with the following tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pushing data into the phone/emulator
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulling data from the phone/emulator
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Obtaining a shell in the phone/emulator
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and removing applications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating the filesystem
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stealing key system files
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Stealing application-related files such as preferences and SQLite files
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing device logs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use ADB to analyze the application permissions. To do this, we will have to
    first obtain the shell in the device using the `adb shell` command and then we
    will have to run the `ps` command to find the details of the process that is running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot depicts this process for a phone connected to the
    Linux machine on which ADB was run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_01_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take a while to analyze the preceding screenshot. Make a note of the first,
    second, and last columns which show `USER`, `PID`, and application `NAME` respectively.
    Note that each application has a unique `PID` and is run from a specific user.
    Only a few privileged processes run with the user root. Other applications run
    via specific users. For example, the `com.android.datapass` application with `PID
    299` runs as user `app_47`. Also, `com.svox.pico` runs with user `app_28`.
  prefs: []
  type: TYPE_NORMAL
- en: Each application in Android runs in its own **sandbox**. A sandbox is a virtual
    environment where the application runs within its limited context and is not allowed
    access to, or to be accessed from, other applications. The permissions model in
    Android (applications running with specific users) helps create a sandbox, thereby
    restricting applications within their own context and allowing no or limited interaction
    (as chosen by the application developer) with other applications. This also secures
    applications against data theft or other attacks from rogue applications and malware.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android permissions model and sandbox implementation attempts to build in
    security by design. This has been the target of attackers and evangelists. Android
    sandbox bypass attacks and attacks originating from insecure code implementation
    are a couple of the types of attack against this security feature. Nevertheless,
    security by design is implemented in the Android OS itself in the form of the
    permissions model.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [http://developer.android.com/tools/help/adb.html](http://developer.android.com/tools/help/adb.html)
    for more information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing Android lock screen protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android users are advised to protect their devices by setting up a password,
    pin, or lock screen (graphical pattern). When users talk about lock screen bypass,
    they usually mean they have locked their phone or forgotten their pattern, not
    how to bypass the screen and get into the device. We are approaching the topic
    in a more aggressive fashion, as this book is about mobile device exploitation.
    As an attacker, how could we bypass a victim's lock screen? Now, this topic is
    widely spoken about and there is already a wide range of tricks to do it; various
    exploits/methods may work in specific Android or device versions but may not work
    with others.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to take a case where we reset the lock pattern in a phone via ADB.
    So for this recipe, you need ADB ready. We learned about ADB in the previous recipe.
    Let's now use that what we learnt, to hack. Apart from ADB, you need to obtain
    an Android device with **USB debugging** enabled, and has a that password needs
    to be reset.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to bypass the lock screen protection:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to the target Android device using ADB. If we have obtained a phone
    with **USB debugging** enabled and the phone is rooted, things are much easier.
    If the phone is not rooted, then there are hacks to do so as well. For this recipe,
    let's consider a rooted phone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that you are connected via ADB, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This gives you the shell in a connected Android device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, change the current working directory to /data/system, which is where
    keys are located. To do this, we have to type the following command to change
    the directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then finally you need to delete the relevant key. Simply run the remove command
    to delete it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It can also be run as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In case you are prompted for superuser permissions, you can run the `su` command.
    The preceding commands delete the key files containing lock screen information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, do a device reboot and the lock screen should have gone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This works because the key files in the `/data/system` folder contain system
    information, such as the lock screen's password information. If these key files
    are deleted, on reboot the device is not able to locate a lock screen setting,
    so effectively it allows access without a password.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A device already in USB debugging mode, and rooted as well, allows this recipe
    to work quite easily.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key message is; this is not the only way to bypass the lock screen, nor
    is this method guaranteed to work in all cases. Hackers have come up with multiple
    ways to bypass Android lock screens. To further complicate matters, not all methods
    work for all Android versions. So you may have to spend a lot of effort in certain
    cases to figure out how to bypass the Android lock screen.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the iOS development environment - Xcode and iOS simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you have got the hang of Android development. Now it's time to be introduced
    to the iOS development environment. Apple's iPhone and iPad run on the iOS operating
    system. Application development for iOS requires the Xcode IDE, which runs on
    Mac OS X. Xcode, together with iOS simulator, can be used to develop and test
    iOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note we say emulators when we talk about Android, and we say simulators when
    talk about iOS. These two are similar to each other, but with one major difference.
    An emulator can use some OS features to test specific applications.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an Emulator can use a laptop's webcam to run an application that
    requires a camera, whereas such application testing will be limited in an iOS
    simulator. Emulators can also send an SMS to other emulators.
  prefs: []
  type: TYPE_NORMAL
- en: Some people say that emulators are smarter than simulators. However, generalizing
    that much may not be fair, as long as both serve the job they are designed for.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xcode is the IDE for developing iOS applications. Xcode runs on Mac OS X, so
    a MacBook is required for iOS application development. So get a MacBook, install
    Xcode, install the iOS SDK, and start coding in iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there are useful guidelines at [https://developer.apple.com/programs/ios/gettingstarted/](https://developer.apple.com/programs/ios/gettingstarted/)
    to help you out with this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps for setting up Xcode and iOS simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: Locate App Store on your MacBook. Now use App Store to download Xcode (this
    is just like any other App download on mobile phones). You will need an Apple
    ID to download from the App Store. Note that Xcode is free to download from Apple's
    App Store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Xcode is installed, you can explore the IDE. It can be used to develop
    Mac OS X applications. Xcode is a common IDE for both OS X applications and iOS
    application development. To be able to develop an iOS application, you also need
    to install the iOS SDK. The latest versions of Xcode include both OS X and the
    iOS SDK. Simulators and instruments are also part of Xcode now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thankfully this is not complicated and the installation of Xcode takes care
    of everything.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have everything set up, create a new project. Note that if things
    are properly installed, you get the option to create an iOS and OS X application,
    as shown here:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_01_005.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make ourselves familiar with the Xcode IDE.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding screenshot, let's create a project. We will choose the **Single
    View Application** template for simplicity's sake. This action opens up the **Choose
    options for your new project** window. Provide a name for your project, which
    appends the organization identifier to create a bundle identifier.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/image_01_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note we selected **Swift**, which is a new language introduced in iOS 8\. There
    is another option, to choose traditional **Objective-C**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift is new programming language for iOS and OS X. It is interactive and is
    intended to make coding fun. Swift makes app development easier and can work alongside
    traditional Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Some people say that emulators are smarter than simulators. However, generalizing
    that may not be fair, as long as both serve the job they are designed for.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is also important that the appropriate device option is selected
    from **iPhone**, **iPad**, or **Universal**. We select **iPhone**, just for the
    sake of this demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you select **Next** and **Create**, we see our project window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/image_01_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The left-hand pane is the project navigator. You can find all your project files
    in this area. The center part of the workspace is the editor area. Depending on
    the type of file, Xcode shows different interfaces in the editing area.
  prefs: []
  type: TYPE_NORMAL
- en: The right-hand pane is the utility area. This area displays the properties of
    files, and allows you to access **Quick Help**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up to now we have written zero lines of code. Even so, we can run our app using
    the built-in simulator. In the toolbar, we can see the *run* button (top left,
    the one resembling the traditional *play* music icon):'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](graphics/image_01_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we hit the run button, Xcode automatically builds the app and runs it
    on the default iPhone 6 simulator. Of course, since we haven''t programmed our
    app to do anything, it will just display a white screen with nothing inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](graphics/image_01_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The *stop* button next to the *run* button terminates the app.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Setting up the iOS pentesting environment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple iOS app and running it in the simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having introduced you to Xcode and the simulator, now we will create our first
    iOS application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get ready to code the iOS application, you need Xcode and iOS Simulator in
    your MacBook and working. If you have followed the previous recipe, and know a
    little bit of Objective-C, you are all set to code your very first iOS application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a basic idea of Xcode, let''s start by building the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: In the project navigator, select `Main.storyboard`. Xcode then brings up a visual
    editor for storyboards, called **interface builder**.![How to do it...](graphics/image_01_010.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A storyboard is used to lay out views and transition between different views.
    As we use a single-view application, the storyboard already includes a View Controller.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will add a button to the view. The bottom part of the utility area
    shows the Object Library, as shown in the following screenshot:![How to do it...](graphics/image_01_011.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Button** object from the Object Library to the view:![How to do it...](graphics/image_01_012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop dragging and move the button to the area of your choice. Double-click on
    the button and rename it `Click Me`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we will add a few lines of code to display our message. In the project
    navigator, you should find the `ViewController.swift` file. We will be adding
    a method to the already present `ViewController` class. When this method is called,
    our code will tell iOS to display a certain message.![How to do it...](graphics/image_01_013.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s code our method. This is what our method looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is what the finished work will look like:![How to do it...](graphics/image_01_014.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to connect our **Click Me** button in the storyboard to our `showMessage`
    method. This part is easy; we click on `Main.storyboard`, where we have displayed
    our screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press and hold the **Ctrl** key on your keyboard, click the **Click Me** button,
    and drag it to the **View Controller** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release both buttons, and we see a pop-up message with the `showMessage` option.
    Select it to make a connection between the button and our function:![How to do
    it...](graphics/image_01_015.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! If everything is correct, we can now run our app perfectly when we
    click on the *run* button:![How to do it...](graphics/image_01_016.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@IBAction` attribute, introduced in Swift, is used to connect storyboard
    actions to the code. Here, we wanted to connect the click of a button to a message
    being displayed. So, we defined the function `showMessage` as `func`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting from iOS 8, `UIActionSheet` and `UIAlertView` were replaced by the
    new `UIAlertController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our function, we call `UIAlertController` and ask it to display an alert
    popup, with the title `My First App` and the message `Hello World`. We also add
    an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This essentially means we add an option to close the popup when **OK** is clicked
    on.
  prefs: []
  type: TYPE_NORMAL
- en: When we dragged our button to the `ViewController` and selected our `showMessage`
    function, we essentially linked the clicking of the button to the calling of our
    function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can experiment by trying different styles of button, or using table views,
    links, and so on. Add more functionality to experiment in ways of learning iOS
    app development.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good starting place would be the documentation from the creators of iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find a lot of resources on starting out with app development, along
    with videos, tutorials, and sample code, from [https://developer.apple.com/swift/resources/](https://developer.apple.com/swift/resources/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Android pentesting environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By this time, you will be familiar with the Android development environment,
    ADB, and emulators. You have also coded your first application. Now let''s get
    into penetration testing. Penetration testing for mobile applications can be broadly
    classified under four categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile application traffic-related attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile device storage-related attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile application source code-related attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacks involving mobile OS features used by mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the most complicated category. There are various Android OS features
    that applications interact with, such as Bluetooth, NFC, intents, broadcast receivers,
    and so on. These also need to be covered in an offensive penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have to set up a lab for Android pentesting, which should be sufficiently
    well equipped to be able to conduct testing for test cases that fall into the
    four categories listed previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get going, we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The Android SDK, emulators, and ADB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulators with different Android versions configured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or two Android handsets or tablets (rooted)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy tools such as Charles, Burp Suite, and Fiddler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Wi-Fi network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools such as SQLite browser, text editors, and XML viewers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools such as a DEX to JAR convertor, jdgui, or Java decompilers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools such as DroidProxy or Autoproxy for Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at each of these tools:'
  prefs: []
  type: TYPE_NORMAL
- en: Android SDK, emulators, and ADB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already learned about these in previous recipes in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Emulators with different Android versions configured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the AVD Manager screenshot shown in a previous recipe. There, we used
    API level 21 and created an emulator for Android version 5.0.1\. Using the new
    option there, we can create more emulators for different API levels and for different
    Android versions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These different versions will come in handy when applications to be pentested
    are developed for specific versions. They also come in handy when specific mobile
    application features are present in specific Android versions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One or two Android handsets or tablets (rooted)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is optional to have physical devices, but they do come in handy. Sometimes
    we see that applications crash, emulators are slow, or proxy tools in combination
    with emulators are too slow/crash often, making it difficult to test the application
    with emulators. Having a physical mobile device comes in handy in such cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Proxy tools such as Charles, Burp Suite, and Fiddler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various proxy tools can be downloaded from their websites. These are quite straightforward
    and there are guides and help forums about them as well. The installation of such
    tools is outside the scope of this book, but we will cover their configuration
    for mobile applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here are some links to the most common proxy tools:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://portswigger.net/burp/download.html](http://portswigger.net/burp/download.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.charlesproxy.com/download/](http://www.charlesproxy.com/download/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.telerik.com/download/fiddler](http://www.telerik.com/download/fiddler)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A Wi-Fi network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a Wi-Fi network to intercept Wi-Fi traffic. We will later set up a proxy
    for a mobile device to a laptop running a proxy tool, both on the same Wi-Fi network.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can either use a Wi-Fi router to set up your personal Wi-Fi network, or
    you can use one of the free tools available to create a hotspot from your laptop.
    In our experience, it is sometimes difficult to work with the latter option, so
    we prefer using the former.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tools such as SQLite browser, text editors, and XML viewers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are additional tools to read the data extracted from phones. Again, these
    are free downloads or you may already have them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A data cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also important to own a data cable. Later we will use it to connect the
    phone in order to read its data and conduct attacks that originate via USB.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tools such as a DEX to JAR convertor, jdgui, or Java decompilers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also important that these tools are ready in our lab. These small tools
    help us in the decompilation of Android applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tools such as DroidProxy or Autoproxy for Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since previous versions of Android did not have a feature to direct the OS to
    set a proxy, we need such tools to be downloaded from Google Play Store.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the tools ready in our pentesting lab, let''s see how we can link the
    penetration testing use cases to different categories while using the tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mobile application traffic-related attacks**: This is where Wi-Fi network
    and proxy tools are going to come in handy. A laptop with a Charles or Burp proxy
    installed is connected to Wi-Fi. A mobile device running the application is directed
    to the laptop proxy, using the proxy configuration on the device. Since both the
    laptop and the mobile device are on the same Wi-Fi network, application traffic
    gets routed via the Charles or Burp proxy tool. Use tools like DroidProxy or Autoproxy
    for Android devices to set a proxy if required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effectively, this whole process makes application traffic readable and editable
    via proxy tools so we can conduct various attacks, which will be seen in another
    chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Mobile device storage-related attacks**: We have a data cable to connect
    the phone to the laptop. We have the emulator on the laptop. Both of them can
    run mobile applications. We also have a very powerful tool, ADB, with us; it can
    connect to, and steal data from, devices or emulators, as well as performing many
    other possible attacks.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile application source code-related attacks**: Decompiling the Android
    application can be broken into two steps: APK to DEX conversion and DEX to JAR
    conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APK is the Android application package. Once the Android application is developed
    and packed, the resulting file format is `.apk`. Mobile applications are named
    `<filename>.apk`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: APK to DEX conversion is quite straightforward; it just involves renaming and
    unzipping the archived files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.dex` to `.jar` conversion is achieved via tools such as DEX to JAR converters.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Attacks involving mobile OS features used by mobile applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the iOS pentesting environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you are well acquainted with the iOS development environment and simulators,
    and have coded your first application as well, it is time to learn about penetration
    testing for iOS applications. Penetration testing for mobile applications can
    be broadly classified into four categories, as we saw in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile application traffic-related attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile device storage-related attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile application source code-related attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacks involving mobile OS features used by mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have to set up a lab for iOS pentesting, which should be sufficiently well
    equipped to be able to conduct testing for test cases that fall into the four
    categories listed previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get going, we need a minimum of the following tools. The list is not very
    different from Android, but includes some specific tools:'
  prefs: []
  type: TYPE_NORMAL
- en: iOS simulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iExplorer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or two iPhones or iPads (jailbroken)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy tools such as Charles, Burp Suite, and Fiddler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Wi-Fi network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools such as SQLite browser, text editors, XML viewers, and plist editors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools such as otool and **classdump**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at each of these tools:'
  prefs: []
  type: TYPE_NORMAL
- en: iOS simulators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use iOS Simulators to run iOS applications where we have the application
    code available to us. In such cases, testing can be conducted from just one MacBook
    with all the tools installed (no need for Wi-Fi or mobile handsets).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Xcode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xcode is the IDE for iOS applications. It is not only helpful for reviewing
    the source code of an iOS application, but also comes in handy in terms of viewing
    certain files, which open in Xcode only.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: iExplorer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iExplorer can be downloaded on a MacBook from the Apple App Store. A Windows
    version of this can also be downloaded when working with iPhones or iPads connected
    to a Windows machine via a data cable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: iExplorer, like Windows Explorer, helps to navigate the filesystem. It can be
    used to explore, read files, and steal data from iOS devices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One or two iPhones or iPads (jailbroken)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A jailbroken iOS device comes in handy. The applications installed on these
    devices can be pentested from the device itself, eliminating the requirement for
    Simulators.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Proxy tools such as Charles, Burp Suite, and Fiddler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various proxy tools can be downloaded from their websites. These are quite straightforward
    and there are guides and help forums about them as well. The installation of such
    tools is outside the scope of this book, but we will cover the configuration of
    them for mobile applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here are links to the most common proxy tools:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://portswigger.net/burp/download.html](http://portswigger.net/burp/download.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.charlesproxy.com/download/](http://www.charlesproxy.com/download/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.telerik.com/download/fiddler](http://www.telerik.com/download/fiddler)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A Wi-Fi network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a Wi-Fi network to intercept Wi-Fi traffic. We will later set up a proxy
    for a mobile device to a laptop running a proxy tool, with both on the same Wi-Fi
    network.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Either you can use a Wi-Fi router to set up your personal Wi-Fi network, or
    you can use one of the free tools available to create a hotspot from your laptop.
    In our experience, it is sometimes difficult to work with the latter option, so
    we prefer using the former.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tools such as SQLite browser, text editors, XML viewers, and plist editors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are additional tools for reading the data extracted from phones. Again
    these are free to download, or you may already have them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: plist files are used in iOS applications to store data, and plist editors are
    useful in reading such files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A data cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also important to own a data cable. Later, we will use it to connect to
    the phone in order to read data and conduct attacks that originate via USB.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tools such as otool and classdump
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools are decompilation tools for iOS applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the tools ready in our pentesting lab, let''s see how we can link the
    penetration testing use cases to different categories while using these tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mobile application traffic-related attacks**: This is where a Wi-Fi network
    and proxy tools are going to come in handy. A laptop with a Charles or Burp proxy
    installed is connected to Wi-Fi. An iOS device running the application is directed
    to the laptop proxy, using the proxy configuration on the device. Since both the
    laptop and the mobile device are on the same Wi-Fi network, application traffic
    is routed via the Charles or Burp proxy tool. This setup does not require a MacBook
    (any other laptop will do), but an iOS device is needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another possibility is that we can use a MacBook but not an iOS device. In this
    case, we will run the application via Xcode and the Simulator. The proxy is set
    to localhost on the MacBook, where we are running a proxy tool such as Burp or
    Charles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Effectively, both approaches make application traffic readable and editable
    via proxy tools, and we can conduct various attacks, which will be seen in another
    chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Mobile device storage-related attacks**: We have a data cable to connect
    the iPhone or iPad to the laptop. We can use the iExplorer tool on the laptop
    to read and steal files and other data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mobile application source code-related attacks**: We discussed the otool
    and classdump tools. Only a limited decompilation is possible in the case of iOS
    applications, and these tools can help only up to a certain point. This will be
    covered in detail in one of the later chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Attacks involving mobile OS features used by mobile applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the most complicated category and becomes further complicated in the
    case of the iOS platform. There are various iOS features that applications interact
    with, such as screenshot backgrounding, Bluetooth, NFC, and so on. The interaction
    of these features with the application, along with the insecure implementation
    of these features in the application, results in vulnerabilities. A popular example
    is the screenshot backgrounding vulnerability in iOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to rooting and jailbreaking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fundamentally, rooting is obtaining root access to the underlying Linux system,
    in order to perform operations such as mounting/unmounting filesystems; running
    SSH, HTTP, DHCP, DNS or proxy daemons; killing system processes; and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to run commands as the root user allows us to do anything on Linux
    and thus, by extension, on an Android system.
  prefs: []
  type: TYPE_NORMAL
- en: Jailbreaking is the process of privilege escalation, by which we can remove
    the hardware level restrictions imposed by Apple on iOS devices. Jailbreaking
    permits root access to the iOS filesystem and manager, allowing the downloading
    of additional applications, extensions, and themes that are unavailable through
    the official Apple App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All that is needed to root an Android device is a USB cable; an unrooted Android
    device; and an exploit code to be run on the device, either through ADB, one-click-root
    programs/apps, or a modified ROM that can be flashed onto the device.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements for an iOS jailbreak are a USB Cable, an iOS device, and a
    jailbreaking program.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we will go through two steps; rooting and jailbreaking.
  prefs: []
  type: TYPE_NORMAL
- en: Rooting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The actual rooting process itself should only take a single click. However,
    you''ll need to do a few quick things first:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install the Java JDK and Android SDK on your computer before continuing.
    Java must be installed before the Android SDK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable **USB debugging** on your Android. On the device, go into the **Settings**
    screen, tap **Applications**, tap **Development**, and enable the **USB debugging**
    checkbox:![Rooting](graphics/image_01_017.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After this, the rooting process essentially involves finding tested rooting
    methods for your specific device by searching the Internet. The rooting processes
    for most Android devices can be categorized into the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Using a rooting application**: In this process you perform the following
    tasks:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the rooting application on your machine
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Android device with **USB debugging** enabled
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the simple instructions to root your device
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Using rooting apps**: In this process you perform the following tasks:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the rooting APK
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable **USB debugging** mode and allow installation from unknown sources, from
    the development settings of the Android device
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the rooting APK using `adb install /path/to/apk`
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the onscreen instructions to root the Android device
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Flashing a custom ROM**: In this process you perform the following tasks:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the modified ROM to the SD card of the Android device (as a `.zip` file)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Reboot the device in recovery mode
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Head to the **install** or **install zip from sdcard** section of the recovery
    menu
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the `.zip` file, and select it from the list to flash it
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Jailbreaking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before performing a jailbreak, you should back up your device. If for any reason
    the jailbreak fails, you can restore the backup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The jailbreaking process involves downloading the program to a Mac/Windows
    machine, connecting our iOS device to our machine via a USB cable, and running
    the tool. One such tool is **evasi0n**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jailbreaking](graphics/image_01_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The instructions are mentioned along with the tool, and should be followed methodically.
  prefs: []
  type: TYPE_NORMAL
- en: As a part of the jailbreaking process, the tool installs Cydia on the target
    iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: Cydia is an alternative App store containing iOS apps other than ones provided
    and usually *approved* by Apple. Most of these apps are developed by the jailbreaking
    community, such as tools for using custom themes and widgets, changing default
    apps, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Jailbreaking](graphics/image_01_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at the details with reference to the processes individually.
  prefs: []
  type: TYPE_NORMAL
- en: Rooting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Being able to run commands as the root user allows us to do anything on Linux
    and thus, by extension, on an Android system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process for rooting an Android device typically involves two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find an exploit that allows the execution of arbitrary code as `root`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the exploit to install `su`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the target device has an unlocked **bootloader**, the process is pretty easy.
    An unpackaged bootloader allows the flashing of arbitrary ROMs, so `su` can be
    added to a stock ROM and repackaged into a modified ROM. All the user needs to
    do is to reboot the device into flashing mode by pressing a combination of keys
    during bootup, and use the device's utilities to flash the modified ROM onto the
    device.
  prefs: []
  type: TYPE_NORMAL
- en: But, what about devices that have locked bootloaders? You can only interact
    with unprivileged programs on the system and they cannot help you execute any
    privileged code.
  prefs: []
  type: TYPE_NORMAL
- en: Many programs, such as system services, run as root on Android, to be able to
    access underlying hardware resources.
  prefs: []
  type: TYPE_NORMAL
- en: All one-click-root methods exploit vulnerabilities in one of these system processes
    running in privileged mode to execute a particular piece of code that mounts the
    system in read-write mode and installs the `su` binary on the system, thus gaining
    privileged access to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Jailbreaking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The jailbreaking process differs from tool to tool, and different procedures
    are followed for different iOS versions. Here, we analyze the anatomy of one such
    tool, used to jailbreak an iPhone 5.
  prefs: []
  type: TYPE_NORMAL
- en: The jailbreaking program begins by running `libimobiledevice` to exploit a bug
    in iOS's mobile backup system in order to gain access to a normally restricted
    file containing the time zone settings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: libimobiledevice is a cross-platform software library which "talks" the protocols
    that support iOS devices. It allows other software to easily access the device's
    filesystem; retrieve information about the device and its internals; back up and
    restore the device; manage installed applications; retrieve address books, calendars,
    notes and bookmarks; and synchronize music and video to the device.
  prefs: []
  type: TYPE_NORMAL
- en: More information can be found at [http://www.libimobiledevice.org/](http://www.libimobiledevice.org/).
  prefs: []
  type: TYPE_NORMAL
- en: It then inserts a "symbolic link" to a certain altered "socket," which allows
    programs to communicate with **launchd**, a master process which is loaded whenever
    an iOS device boots up and can launch applications that require "root" privileges.
  prefs: []
  type: TYPE_NORMAL
- en: So now, whenever an iOS mobile backup runs, all programs will automatically
    be granted access to the time zone file, and therefore access to launchd.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty neat, huh?
  prefs: []
  type: TYPE_NORMAL
- en: iOS implements code-signing as a safeguard to prevent any "untrusted" application
    from gaining access to launchd.
  prefs: []
  type: TYPE_NORMAL
- en: So to defeat code signing, the jailbreaking tool launches a new, unsigned, seemingly
    benign app. But when the user is prompted to tap the app's icon, the app uses
    a technique called shebang to call up code from another signed application, which
    in this case was launchd.
  prefs: []
  type: TYPE_NORMAL
- en: A shebang is a character sequence consisting of the hash symbol and exclamation
    mark characters (that is, `#!`) at the beginning of a script.
  prefs: []
  type: TYPE_NORMAL
- en: In Unix, when a script with a shebang is run as a program, the program loader
    parses the rest of the script's initial line as an interpreter directive; the
    specified interpreter program is run instead, passing to it as an argument the
    path that was initially used when attempting to run the script.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a code has the path `path/to/code`, and it starts with `#!/bin/sh`,
    then the program loader is instructed to run the program `/bin/sh` instead, passing
    `path/to/code` as the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: launchd is then used to run the `remount` command, which changes the memory
    settings of the read-only root file system to be writable.
  prefs: []
  type: TYPE_NORMAL
- en: To make the jailbreak "persistent", the `launchd.conf` file is called to alter
    the launchd configurations. The user now does not need to re-run the program on
    every reboot.
  prefs: []
  type: TYPE_NORMAL
- en: The jailbreaking tool then moves on to its last feat, removing restrictions
    at the kernel level. The iOS kernel uses **Apple Mobile File Integrity Daemon**
    (**AMFID**) to run unapproved apps from using a process. The jailbreaking program
    leverages launchd once again, to load a library of functions into AMFID in order
    to always approve all apps.
  prefs: []
  type: TYPE_NORMAL
- en: The second restriction posed by the kernel is **Address Space Layout Randomization**
    (**ASLR**), used to prevent the alteration of memory by randomizing or "hiding"
    the device's code every time it boots. This would prevent someone from write over
    a particular part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The jailbreaking tool then uses a neat trick to locate one particular area in
    memory; the ARM exception vector. This part handles app crashes, indicating the
    part of memory where the crash occurred.
  prefs: []
  type: TYPE_NORMAL
- en: A crash is simulated by the jailbreaking tool, checking the ARM exception vector
    to see where the crash occurred and collecting minimal information, enough to
    map out the rest of the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: The tool, as its final step, uses a bug in iOS's USB interface that passes an
    address in the kernel's memory to a program and expects the program to return
    it untampered.
  prefs: []
  type: TYPE_NORMAL
- en: This allows the tool to write to the part of the kernel that restricts code
    changes, thus taking complete control, and fulfilling its purpose successfully!
  prefs: []
  type: TYPE_NORMAL
