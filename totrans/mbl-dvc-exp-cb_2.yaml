- en: Chapter 2. Mobile Malware-Based Attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing an Android malware sample
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Androguard for malware analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing custom malware for Android from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permission model bypassing in Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse engineering iOS applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing malware in the iOS environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We probably know a lot about the viruses that attack our computers, but what
    about the viruses aimed at our mobile devices?
  prefs: []
  type: TYPE_NORMAL
- en: You may be surprised to learn that there is malicious software aimed at mobile
    devices, otherwise known as mobile malware. Malware is on the rise, infecting
    all the major smartphone platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learn about malware, how they affect our smartphones, how
    to analyze them, and how to create samples of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing an Android malware sample
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by analyzing a simple Android-based malware application, called
    **Android.Dogowar**. This malware is a repackaged version of the Android gaming
    application *Dog Wars*, which was downloadable from a third-party app store and
    had to be manually installed on an Android device during analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Dog Wars was a game where users could breed, train, and fight with *virtual
    dogs*. This game caused an outcry from animal rights protestors through public
    outcry and write-in campaigns. After these attempts seemed to have little effect
    on convincing the developers to discontinue the app, a group of protestors targeted
    end users to get their message across.
  prefs: []
  type: TYPE_NORMAL
- en: The original Dog Wars app (Beta 0.981) was repackaged as malware and placed
    on several third-party app stores for download.
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing an Android malware sample](graphics/image_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: During installation, the malware app requested that users grant SMS permission,
    among others.
  prefs: []
  type: TYPE_NORMAL
- en: Upon installation, the display icon of the malware looked almost identical to
    that of the legitimate app, except that the malware app displayed `PETA` rather
    than `BETA` in the app icon.
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing an Android malware sample](graphics/image_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once opened, the app sent out a text message to all people listed in the contacts
    of the compromised device with the following message: `I take pleasure in hurting
    small animals, just thought you should know that.`'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated in the previous chapter, Android Studio/standalone SDK tools and JDK
    v7 or newer should be installed and functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will primarily be using three tools for our analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apktool**: This tool will be used to decompile the APK file to obtain the
    decompiled code. It can be obtained from http://ibotpeaches.github.io/Apktool/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dex2Jar**: This utility converts Dalvik executable (`.dex`) files to JAR
    files. This tool can be downloaded from http://sourceforge.net/projects/dex2jar/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JD-GUI**: This utility reads the JAR files and displays the inherent code.
    Visit http://jd.benow.ca/ to download JD-GUI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin our analysis by first analyzing the malware APK. We start by disassembling
    the malware APK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to convert the APK into a JAR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_02_003.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We have successfully converted our APK into a JAR for code analysis. Now we
    need to read the code to identify the malicious elements of it. We will be using
    JD-GUI for this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the directory where JD-GUI is installed and open the application.
    Open the newly created `AndroidDogowar-dex2jar.jar`, and this is what we see:![How
    to do it...](graphics/image_02_004.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the original app is meant to be a gaming application, our analysis would
    start by searching for keywords such as `url`, `http`, `sms`, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On doing a quick search, we find out that the infected class is `Rabies` located
    under the `dogbite` package, as it imports the `android.telephony.SmsManager`
    class:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_02_005.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: On further analyzing the class file, we see the `onStart` function that calls
    `sendTextMessage` to send a text message titled `I take pleasure in hurting small
    animals, just thought you should know that`.![How to do it...](graphics/image_02_006.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The malware code was injected as a package called `Dogbite`. This package defined
    a service called `Rabies`, which is initiated in the background of the compromised
    Android device on startup. This service carried out the core functionality. Once
    the service was initiated, it sent out the text message to all the people listed
    in the **Contacts** list on your phone.
  prefs: []
  type: TYPE_NORMAL
- en: This app also sent a text message to `73882` with the word `text`, which apparently
    signed up users of compromised devices to an alert service operated by **People
    for the Ethical Treatment of Animals** (**PETA**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code moves a cursor over every contact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The subsequent code is used to load the contact list into the `str` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it uses the contacts content provider to return loaded phone numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is used to send text message to all contacts in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this snippet subscribes the user to PETA text alert services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are well-versed in **smali**, then you can use `apktool` to decompile
    the app and analyze smali files for patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'To decompile using `apktool`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a directory with exactly the same name as that of the
    APK, where we can find the decompiled files.
  prefs: []
  type: TYPE_NORMAL
- en: Using Androguard for malware analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Androguard is a Python-based tool that is used for the analysis of an Android
    application. Its functionalities make malware analysis a less cumbersome task.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be introduced to Androguard and its various features.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure Python is installed on your machine. Python 2.7.10 for Windows can
    be downloaded from [https://www.python.org/ftp/python/2.7.10/python-2.7.10.msi](https://www.python.org/ftp/python/2.7.10/python-2.7.10.msi)
    . All releases of Python can be downloaded from [https://www.python.org/downloads/](https://www.python.org/downloads/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Download Androguard from GitHub via [https://github.com/androguard/androguard](https://github.com/androguard/androguard)
    and place it in the directory of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the Androguard directory and run the following command from the
    command prompt or terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will be using the NickiSpy malware, repackaged in a simple app, as our sample.
  prefs: []
  type: TYPE_NORMAL
- en: NickiSpy gained quite a bit of notoriety around 2011\. It recorded phone calls
    to the device's SD card and sent the device's IMEI to a phone number in China.
    Additionally, it also recorded the device's GPS coordinates and made connections
    to a remote server in China.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have installed Androguard, let''s begin analyzing our Malware:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command starts its own input prompt. Now let's define the path of the APK
    and the type of decompiler we want to use to decompile the app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Input this command into the prompt and replace `path_to_apk` with the path
    of the APK we want to analyze:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_02_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Use the following command in the input prompt to get all the permissions used
    by the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the output of the preceding command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_02_008.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Looking at the permissions, it can be clearly seen that the app is requesting
    to read/write SMS and contacts, access GPS, record audio, access caller, and so
    on, enough to raise many alarming flags.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s go further and analyze the class names. Run the following command in
    the input prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Take a look at the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_02_009.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We further reinforce our initial impression when we look at classes such as
    `CallListener`, `SMSListener`, `RecorderService`, `GPSService`, and so on. We
    now have enough reason to believe that the target app is infected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can go further and list all the strings and methods defined in the app as
    output, via these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To view all this information at once, use the following command at the command
    prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the output of the preceding command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_02_010.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: One seemingly tricky task is to find out if an application is actually malware
    or a legitimate application. Androguard gives us an option to compare two Android
    applications, using a utility called **Androdiff**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Androdiff is a Python script bundled with Androguard, which is used to extract
    and observe differences between two Android applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's run the command against a simple `Hello World` application and malware
    disguised as a `Hello World` application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can now analyze the results by taking a closer look at the output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following block reveals that there are `3536` identical elements, which
    means the two applications are in fact very similar. There is one similar element,
    which indicates that there are possible enhancements to some code, and finally
    `3` new elements, which indicates additional code is present in one application:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_02_011.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Scanning further down the output, we see the following:![How to do it...](graphics/image_02_012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This reveals to us that the new methods `backupSMS` and `generateCSVFileForSMS`
    have been added to the malware application, which in conclusion is the `SMSCopy`
    app.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To read about more Android malware and related analysis, a good book to read
    is *Android Malware and Analysis*, *Auerbach Publications* ([https://www.crcpress.com/product/isbn/9781482252194](https://www.crcpress.com/product/isbn/9781482252194)).
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom malware for Android from scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we will learn how to create simple malware for the Android platform. We
    will create simple malware that copies all text messages from a user's SMS app
    and stores them on the SD card as a `.csv` file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have followed all the steps for creating an Android application
    from the first chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the application is created successfully, you can follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Android Studio and create a new project called `SMSCopy`:![How to do it...](graphics/image_02_013.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use API15: Android 4.0.3 as our target platform. You may choose one
    that is to your liking.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Blank Activity** and click on **Finish**. Your project workspace should
    now look like this:![How to do it...](graphics/image_02_014.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to, and open the `MainActivity.java` file under `app/java/com.your_package_name/MainActivity`
    in the left-hand window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code just before the last closing brace (at the end of the
    file):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following line after the code line `setContentView(R.layout.activity_main);`
    in the `onCreate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure you have the following `import` statements in your `Mainactivity.java`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to `app` | `manifests` | `AndroidManifest.xml` and add the following
    lines under the `</application>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, run the project in the emulator or attached device. You will see an app
    with the name `SMSCopy` on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On running the app, we get a page with simple `Hello World` text displayed.
    Let's see if the malware actually worked in the backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the command prompt, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should now have a shell prompt. On the prompt, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now see a file named `SMS.csv` in the SD card directory of our device. Run
    the following command in the shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now see that all the text messages have been successfully copied to
    the file and stored on the SD card:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_02_015.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We specify the target file name as `SMS.csv` and create a function called `backupSMS()`,
    in which we access the device''s text messages by internally calling the `content://sms`
    URI. We then create a cursor to query SMS data and define strings for various
    fields: `thread_id`, `address`, `person`, and `date`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we move our cursor to read all SMS data recursively, and store it in
    defined string arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all the values segregated in separate arrays, we add them
    to our predefined `smsBuffer` buffer, and pass them to another function, `generateCSVFileForSMS()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the `generateCSVFileForSMS()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This essentially instructs the Android device to locate the path for external
    storage, append the file name `SMS.csv` to it, and allocate it to the `storage_path`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: It then opens a file writer and writes all array values to the generated file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can extend our malware's functionality by creating a remote server that receives
    and stores input, and send this file to the remote server from the target Android
    device through GET or POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try to play around with contacts, SMS, MMS, and browsing data in the same fashion,
    by exploring `android.content`. For further information, visit [http://developer.android.com/reference/android/content/package-summary.html](http://developer.android.com/reference/android/content/package-summary.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permission model bypassing in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we know that all Android apps require explicit permissions to execute
    certain functions or process certain data. These permissions are defined in the
    `AndroidManifest.xml` file packaged inside the APK.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical permission to read a text message would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, a simple application that requires permissions to access GPS location,
    read Contacts, read SMS, and write to external storage would raise suspicions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if an application were to require NO special permissions, it would be considered
    a benign application, right?
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we learn a simple way to perform malicious activity without
    our application requiring any special permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We only need Android Studio and the SDK installed and running, as explained
    in previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: We will need to create a listening web server, for which we will use XAMPP,
    which can be downloaded from [https://www.apachefriends.org/index.html](https://www.apachefriends.org/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s make an app that reads a file from an SD card and sends it to a remote
    server, without requiring any special permissions to do so. We begin by creating
    a file called `sensitive.txt` on our SD card:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Issue the following command to access the device shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the SD card and create `sensitive.txt` with content `Username:Akshay.
    Password:secret123`, by entering the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify whether the file has been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it...](graphics/image_02_016.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now that we have our sensitive file ready, let''s code our app to steal this
    file and upload it to the server. Follow the steps in the previous recipe to make
    a new project and open the basic project window and then perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We will now add our code to read `sensitive.txt` and upload its data to a remote
    server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to and open the `MainActivity.java` file under `app` | `java` | `com."your_package_name"`
    | `MainActivity` in the left-hand window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code just inside the `protected void onCreate(Bundle savedInstanceState)`
    function, under the `setContentView(R.layout.activity_main);` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have used `http://10.0.2.2` as our web server address in our code, as we
    are testing this app in the emulator, and the IP address of the base machine is
    always `10.0.2.2` when we are trying to access it via an emulator. If you are
    using an actual Android device to test this, ensure that the device and your workstation
    are connected and replace the IP address with that of the workstation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ensure the following imports are present in your file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now successfully created our malware with no permissions to read the
    `sensitive.txt` file, ready to upload it to the remote server. Let's now create
    our listening page.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a file called `input.php`, and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save this file in the `htdocs` directory where XAMPP is installed in your machine.
    Also, create a blank file called `output.txt` and save it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the XAMPP control panel and start the Apache service:![How to do it...](graphics/image_02_017.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have our setup ready, let's run our application. After the app is
    run on your target device, open the directory in which XAMPP is installed and
    locate `output.txt`:![How to do it...](graphics/image_02_018.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code creates a file input stream reader to read `sensitive.txt`
    and a buffer to store the content in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We execute the following command on the Android device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining code is used to read the lines of the file and store them in
    the `str` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we send the captured data to the server via the GET method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is more to explore in the area of Android permission bypassing, gaining
    root privileges, and extending permissions. Refer to the link mentioned in the
    *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://hackinparis.com/data/slides/2012/Georgia-androidpermissions.pdf](https://hackinparis.com/data/slides/2012/Georgia-androidpermissions.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse engineering iOS applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to perform reverse engineering on the iOS
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The target device needs to be jailbroken for a smooth reverse engineering activity.
  prefs: []
  type: TYPE_NORMAL
- en: Install **i-Funbox** on your machine from [www.i-funbox.com](http://www.i-funbox.com)
    . i-Funbox is an app management tool for iPhone, iPad, and iPod Touch. We will
    use this tool for device and application analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Download the class_dump_z tool from https://code.google.com/p/networkpx/wiki/class_dump_z.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps help you perform reverse engineering on the iOS platform:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the jaibroken device to your workstation using a USB cable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the i-Funbox application. This is what the interface should look like:![How
    to do it...](graphics/image_02_019.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's install a malware app on our device and explore it through i-Funbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the malware in your machine's filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left-hand panel of i-Funbox, click on **Cydia App Install**. A blank
    area appears in the center of the screen:![How to do it...](graphics/image_02_020.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag and drop the malware into the blank area:![How to do it...](graphics/image_02_021.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To complete the installation, just reboot the device. That's it! The malware
    is installed and ready for analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now unpack the `.deb` file to view the content of the package. The unpacked
    directory contains a file called `data.tar`, which can be further unpacked to
    the `data` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now explore further, to `/data/bin`, where we find three files:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: com.xsser.0day.iphone.plist
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: xsser.0day_t
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: xsser.0day_t.sh
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In i-Funbox, click on **Raw File System**:![How to do it...](graphics/image_02_022.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we know that one of the files is a shell file, let's see if the file has
    been installed as a binary on the device.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the `bin` directory. We see that the shell file is, in fact, in
    the bin directory, along with the other files identified earlier as well. Jailbroken
    devices have an SSH server listening by default, with the user as `root` and the
    password as `alpine`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the command prompt/terminal, issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When prompted for a password, enter `alpine`. One of the most important requirements
    is to be able to view the source code of an iOS application. This can be achieved
    with a tool called `class_dump-z`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory where `class_dump_z` is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's use a preinstalled app for this purpose.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using i-Funbox, navigate to the application directory, click on **Contacts~iphone**,
    and then click on **Copy to PC**. Select the destination directory on your machine,
    and click on **Save**:![How to do it...](graphics/image_02_023.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s dump the classes from this app. Navigate to `class_dump_z` directory,
    and execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_02_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have a dump of all classes, methods, and related relevant information
    for our analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet reveals a class named `SearchRequestHistoryItem`, which
    is inheriting from `PersistentSearchRequestHistoryItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Malware is known to create executable files, which are added to system directories
    and provide executable permissions.
  prefs: []
  type: TYPE_NORMAL
- en: These executables in turn add property files, try to access and control launch
    daemons, read sensitive data, and even attempt to upload sensitive data to remote
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing malware in the iOS environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will take a look at the XSSer mRAT iOS malware sample, for our preliminary
    analysis. If installed, this malware operates in the background of a victim's
    phone, and the contents of the targeted device are sent to remote servers that
    appear to be controlled by a foreign government or organization. XSSer mRAT can
    steal SMS messages, call logs, location data, photos, address books, data from
    the Chinese messaging application Tencent, and passwords from the iOS keychain.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need unzipping utilities such as 7-Zip, WinZip, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To analyze malware in the iOS environment perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We unpack the `.deb` file to view the contents of the package. The unpacked
    directory contains a file called `data.tar`, which can be further unpacked to
    the `data` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now explore further, to /data/bin, where we find three files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: com.xsser.0day.iphone.plist
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: xsser.0day_t
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: xsser.0day_t.sh
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at the `xxser.0day_t.sh` file. The following code is revealed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Code analysis reveals that the app attempts to copy the binary package `xsser.0day_t`
    to the device's `/bin` directory, which indicates that the binary file is used
    to carry out malicious commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next line reveals that the malware copies the plist file to the `/Library/LaunchDaemons`
    directory to launch the App code at system startup and reboot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also see that permission of `755` has been granted to both files using `chmod
    0755`, which allows everyone to read and execute the file, and the file owner
    to write to the file with the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The app now uses `launchctl` to interface with `launchd` in order to load `daemons/agents`
    and generally control `launchd` via its `plist` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s have a look at the plist file. Open the plist file in Notepad. The contents
    are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This plist file defines the `xsser.0day` binary as a program that has the capability
    to be started by launch daemons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This process essentially installs a native service and loads it.![How to do
    it...](graphics/image_02_025.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the application is running, it sends an HTTP GET request to [www.xsser.com/CheckLibrary.aspx](http://www.xsser.com/CheckLibrary.aspx)
    to get the library version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the app runs at bootup, the binary checks the version of the library and
    saves it to a file named `/bin/iVersion`. If the version doesn't match, then it
    downloads and updates the iLib version. The main binary also has some minimal
    logging to `/bin/debuglogFile.log`.
  prefs: []
  type: TYPE_NORMAL
- en: The app then sends data such as the OS version, Mac address, device version,
    phone number, IMSI, and IMEI code via a GET request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server responds to the GET request, with a set of commands to be executed
    on the device. These commands include uploading the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: All images are in the `/private/var/mobile/Media/DCIM/100APPLE/` directory.
    Additionally, GPS information and Keychain are also accessed by the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the data is then uploaded to http://xsser.com/TargetUploadGPS.aspx:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/image_02_026.jpg)'
  prefs: []
  type: TYPE_IMG
