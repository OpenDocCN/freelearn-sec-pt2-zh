<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Auditing Mobile Applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Auditing Mobile Applications</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Auditing Android apps using static analysis</li><li class="listitem" style="list-style-type: disc">Auditing Android apps using a dynamic analyzer</li><li class="listitem" style="list-style-type: disc">Using Drozer to find vulnerabilities in Android applications</li><li class="listitem" style="list-style-type: disc">Auditing iOS application using static analysis</li><li class="listitem" style="list-style-type: disc">Auditing iOS application using a dynamic analyzer</li><li class="listitem" style="list-style-type: disc">Examining iOS App Data storage and Keychain security vulnerabilities</li><li class="listitem" style="list-style-type: disc">Finding vulnerabilities in WAP-based mobile apps</li><li class="listitem" style="list-style-type: disc">Finding client-side injection</li><li class="listitem" style="list-style-type: disc">Insecure encryption in mobile apps</li><li class="listitem" style="list-style-type: disc">Discovering data leakage sources</li><li class="listitem" style="list-style-type: disc">Other application-based attacks in mobile devices</li><li class="listitem" style="list-style-type: disc">Launching intent injection in Android</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Introduction</h1></div></div></div><p>Mobile applications such as web applications may have vulnerabilities. These vulnerabilities in most cases are the result of bad programming practices or insecure coding techniques, or may be because of purposefully injected bad code. For users and organizations, it is important to know how vulnerable their applications are. Should they fix the vulnerabilities or keep/stop using the applications?</p><p>To address this dilemma, mobile applications need to be audited with the goal of uncovering vulnerabilities. Mobile applications (Android, iOS, or other platforms) can be analyzed using static or dynamic techniques. Static analysis is conducted by employing certain text or string based searches across decompiled source code. Dynamic analysis is conducted at runtime and vulnerabilities are uncovered in simulated fashion. Dynamic analysis is difficult as compared to static analysis. In this chapter, we will employ both static and dynamic analysis to audit Android and iOS applications. We will also learn various other techniques to audit findings, including Drozer framework usage, WAP-based application audits, and typical mobile-specific vulnerability discovery.</p></div></div>
<div class="section" title="Auditing Android apps using static analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Auditing Android apps using static analysis</h1></div></div></div><p>Static analysis is the most commonly and easily applied analysis method in source code audits. Static by definition means something that is constant. Static analysis is conducted on the static code, that is, raw or decompiled source code or on the compiled (object) code, but the analysis is conducted without the runtime. In most cases, static analysis becomes code analysis via static string searches. A very common scenario is to figure out vulnerable or insecure code patterns and find the same in the entire application code.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec71"/>Getting ready</h2></div></div></div><p>For conducting static analysis of Android applications, we at least need one Android application and a static code scanner. Pick up any Android application of your choice and use any static analyzer tool of your choice.</p><p>In this recipe, we use <span class="strong"><strong>Insecure Bank</strong></span>, which is a vulnerable Android application for Android security enthusiasts. We will also use <span class="strong"><strong>ScriptDroid</strong></span>, which is a static analysis script. Both Insecure Bank and ScriptDroid are coded by Android security researcher, Dinesh Shetty.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec72"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the latest version of the Insecure Bank application from GitHub. Decompress or unzip the <code class="literal">.apk</code> file and note the path of the unzipped application.</li><li class="listitem">Create a <code class="literal">ScriptDroid.bat</code> file by using the following code:<pre class="programlisting">  @ECHO OFF &#13;
  SET /P Filelocation=Please Enter Location: &#13;
 &#13;
  mkdir %Filelocation%OUTPUT &#13;
 &#13;
  :: Code to check for presence of Comments &#13;
  grep -H -i -n -e "//" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_comment.txt" &#13;
  type -H -i  "%Filelocation%*.java" |gawk "/\/\*/,/\*\//" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\MultilineComments.txt" &#13;
  grep -H -i -n -v "TODO" "%Filelocation%OUTPUT\Temp_comment.txt" &gt;&gt; &#13;
  "%Filelocation%OUTPUT\SinglelineComments.txt"&#13;
  del %Filelocation%OUTPUT\Temp_comment.txt &#13;
 &#13;
  :: Code to check for insecure usage of SharedPreferences &#13;
  grep -H -i -n -C2 -e "putString" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\verify_sharedpreferences.txt" &#13;
  grep -H -i -n -C2 -e "MODE_PRIVATE" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Modeprivate.txt" &#13;
  grep -H -i -n -C2 -e "MODE_WORLD_READABLE" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Worldreadable.txt" &#13;
  grep -H -i -n -C2 -e "MODE_WORLD_WRITEABLE" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Worldwritable.txt" &#13;
  grep -H -i -n -C2 -e "addPreferencesFromResource" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\verify_sharedpreferences.txt" &#13;
 &#13;
  :: Code to check for possible TapJacking attack &#13;
  grep -H -i -n -e filterTouchesWhenObscured\="true" "%Filelocation%..\..\..\..\res\layout\*.xml" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Temp_tapjacking.txt" &#13;
  grep -H -i -n -e "&lt;Button" "%Filelocation%..\..\..\..\res\layout\*.xml" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\tapjackings.txt"  &#13;
  grep -H -i -n -v filterTouchesWhenObscured\="true" "%Filelocation%OUTPUT\tapjackings.txt" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Temp_tapjacking.txt" &#13;
  del %Filelocation%OUTPUT\Temp_tapjacking.txt &#13;
 &#13;
  :: Code to check usage of external storage card for storing information &#13;
  grep -H -i -n  -e "WRITE_EXTERNAL_STORAGE" "%Filelocation%..\..\..\..\AndroidManifest.xml" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\SdcardStorage.txt"   &#13;
  grep -H -i -n  -e "getExternalStorageDirectory()" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\SdcardStorage.txt"&#13;
  grep -H -i -n  -e "sdcard" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\SdcardStorage.txt" &#13;
 &#13;
  :: Code to check for possible scripting javscript injection &#13;
  grep -H -i -n  -e "addJavascriptInterface()" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Temp_probableXss.txt" &#13;
  grep -H -i -n  -e "setJavaScriptEnabled(true)" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Temp_probableXss.txt" &#13;
  grep -H -i -n -v "import" "%Filelocation%OUTPUT\Temp_probableXss.txt" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\probableXss.txt" &#13;
  del %Filelocation%OUTPUT\Temp_probableXss.txt &#13;
 &#13;
  :: Code to check for presence of possible weak algorithms &#13;
  grep -H -i -n  -e "MD5" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_weakencryption.txt" &#13;
  grep -H -i -n  -e "base64" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_weakencryption.txt" &#13;
  grep -H -i -n  -e "des" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_weakencryption.txt" &#13;
  grep -H -i -n  -v "import" "%Filelocation%OUTPUT\Temp_weakencryption.txt" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Weakencryption.txt" &#13;
  del %Filelocation%OUTPUT\Temp_weakencryption.txt &#13;
 &#13;
  :: Code to check for weak transportation medium &#13;
  grep -H -i -n -C3  "http://" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_overhttp.txt" &#13;
  grep -H -i -n -C3 -e "HttpURLConnection" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Temp_overhttp.txt" &#13;
  grep -H -i -n -C3 -e "URLConnection" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Temp_OtherUrlConnection.txt" &#13;
  grep -H -i -n -C3 -e "URL" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Temp_OtherUrlConnection.txt" &#13;
  grep -H -i -n  -e "TrustAllSSLSocket-Factory" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\BypassSSLvalidations.txt" &#13;
  grep -H -i -n -e "AllTrustSSLSocketFactory" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\BypassSSLvalidations.txt" &#13;
  grep -H -i -n -e "NonValidatingSSLSocketFactory" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\BypassSSLvalidations.txt"  &#13;
  grep -H -i -n  -v "import" "%Filelocation%OUTPUT\Temp_OtherUrlConnection.txt" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\OtherUrlConnections.txt" &#13;
  del %Filelocation%OUTPUT\Temp_OtherUrlConnection.txt &#13;
  grep -H -i -n  -v "import" "%Filelocation%OUTPUT\Temp_overhttp.txt" &gt;&gt; &#13;
  "%Filelocation%OUTPUT\UnencryptedTransport.txt" &#13;
  del %Filelocation%OUTPUT\Temp_overhttp.txt &#13;
 &#13;
 &#13;
  :: Code to check for Autocomplete ON &#13;
  grep -H -i -n -e "&lt;Input" "%Filelocation%..\..\..\..\res\layout\*.xml" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Temp_autocomp.txt"  &#13;
  grep -H -i -n -v "textNoSuggestions" "%Filelocation%OUTPUT\Temp_autocomp.txt" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\AutocompleteOn.txt" &#13;
  del %Filelocation%OUTPUT\Temp_autocomp.txt &#13;
 &#13;
 &#13;
  :: Code to presence of possible SQL Content &#13;
  grep -H -i -n  -e "rawQuery" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_sqlcontent.txt"  &#13;
  grep -H -i -n  -e "compileStatement" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Temp_sqlcontent.txt"  &#13;
  grep -H -i -n  -e "db" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_sqlcontent.txt"  &#13;
  grep -H -i -n  -e "sqlite" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_sqlcontent.txt"  &#13;
  grep -H -i -n  -e "database" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_sqlcontent.txt"  &#13;
  grep -H -i -n  -e "insert" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_sqlcontent.txt"  &#13;
  grep -H -i -n -e "delete" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_sqlcontent.txt"  &#13;
  grep -H -i -n  -e "select" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_sqlcontent.txt"  &#13;
  grep -H -i -n  -e "table" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_sqlcontent.txt"  &#13;
  grep -H -i -n -e "cursor" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_sqlcontent.txt"  &#13;
  grep -H -i -n -v "import" "%Filelocation%OUTPUT\Temp_sqlcontent.txt" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Sqlcontents.txt" &#13;
  del %Filelocation%OUTPUT\Temp_sqlcontent.txt &#13;
 &#13;
  :: Code to check for Logging mechanism &#13;
  grep -H -i -n  -F "Log." "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Logging.txt"  &#13;
 &#13;
  :: Code to check for Information in Toast messages &#13;
  grep -H -i -n -e "Toast.makeText" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_Toast.txt"  &#13;
  grep -H -i -n -v "//" "%Filelocation%OUTPUT\Temp_Toast.txt" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Toast_content.txt" &#13;
  del %Filelocation%OUTPUT\Temp_Toast.txt &#13;
 &#13;
  :: Code to check for Debugging status &#13;
  grep -H -i -n  -e "android:debuggable" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\DebuggingAllowed.txt"  &#13;
 &#13;
  :: Code to check for presence of Device Identifiers &#13;
  grep -H -i -n  -e "uid\|user-id\|imei\|deviceId\|deviceSerialNumber\|devicePrint\|X-DSN\|phone&#13;
  \|mdn\|did\|IMSI\|uuid" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\Temp_Identifiers.txt"  &#13;
  grep -H -i -n -v "//" "%Filelocation%OUTPUT\Temp_Identifiers.txt" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\Device_Identifier.txt" &#13;
 del %Filelocation%OUTPUT\Temp_Identifiers.txt &#13;
 &#13;
  :: Code to check for presence of Location Info &#13;
  grep -H -i -n  -e "getLastKnownLocation()\|requestLocationUpdates()\|getLatitude()\|getLongitude()&#13;
  \|LOCATION" "%Filelocation%*.java" &gt;&gt; "%Filelocation%OUTPUT\LocationInfo.txt"  &#13;
 &#13;
  :: Code to check for possible Intent Injection &#13;
  grep -H -i -n -C3 -e "Action.getIntent(" "%Filelocation%*.java" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\IntentValidation.txt" &#13;
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec73"/>How it works...</h2></div></div></div><p>Go to the command prompt and navigate to the path where ScriptDroid is placed. Run the <code class="literal">.bat</code> file and it prompts you to input the path of the application for which you wish to perform static analysis. In our case we provide it with the path of the Insecure Bank application, precisely the path where Java files are stored. If everything worked correctly, the screen should look like the following:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_001.jpg" alt="How it works..."/></div><p>
</p><p>The script generates a folder by the name <code class="literal">OUTPUT</code> in the path where the Java files of the application are present. The <code class="literal">OUTPUT</code> folder contains multiple text files, each one corresponding to a particular vulnerability. The individual text files pinpoint the location of vulnerable code pertaining to the vulnerability under discussion.</p><p>The combination of ScriptDroid and Insecure Bank gives a very nice view of various Android vulnerabilities; usually the same is not possible with live apps.</p><p>Consider the following points, for instance:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Weakencryption.txt</code> has listed down the instances of Base64 encoding used for passwords in the Insecure Bank application</li><li class="listitem" style="list-style-type: disc"><code class="literal">Logging.txt</code> contains the list of insecure log functions used in the application</li><li class="listitem" style="list-style-type: disc"><code class="literal">SdcardStorage.txt</code> contains the code snippet pertaining to the definitions related to data storage in SD Cards</li></ul></div><p>Details like these from static analysis are eye-openers in letting us know of the vulnerabilities in our application, without even running the application.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec74"/>There's more...</h2></div></div></div><p>The current recipe used just ScriptDroid, but there are many other options available. You can either choose to write your own script or you may use one of the free or commercial tools. A few commercial tools have pioneered the static analysis approach over the years via their dedicated focus.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec75"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://github.com/dineshshetty/Android-InsecureBankv2">https://github.com/dineshshetty/Android-InsecureBankv2</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Auditing iOS application using static analysis</em></span></li></ul></div></div></div>
<div class="section" title="Auditing Android apps a using a dynamic analyzer"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Auditing Android apps a using a dynamic analyzer</h1></div></div></div><p>
<span class="strong"><strong>Dynamic analysis</strong></span> is another technique applied in source code audits. Dynamic analysis is conducted in runtime. The application is run or simulated and the flaws or vulnerabilities are discovered while the application is running. Dynamic analysis can be tricky, especially in the case of mobile platforms. As opposed to static analysis, there are certain requirements in dynamic analysis, such as the analyzer environment needs to be runtime or a simulation of the real runtime.</p><p>Dynamic analysis can be employed to find vulnerabilities in Android applications which are difficult to find via static analysis. A static analysis may let you know a password is going to be stored, but dynamic analysis reads the memory and reveals the password stored in runtime. Dynamic analysis can be helpful in tampering data in transmission during runtime that is, tampering with the amount in a transaction request being sent to the payment gateway. Some Android applications employ obfuscation to prevent attackers reading the code; Dynamic analysis changes the whole game in such cases, by revealing the hardcoded data being sent out in requests, which is otherwise not readable in static analysis.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec76"/>Getting ready</h2></div></div></div><p>For conducting dynamic analysis of Android applications, we at least need one Android application and a dynamic code analyzer tool. Pick up any Android application of your choice and use any dynamic analyzer tool of your choice.</p><p>The dynamic analyzer tools can be classified under two categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The tools which run from computers and connect to an Android device or emulator (to conduct dynamic analysis)</li><li class="listitem" style="list-style-type: disc">The tools that can run on the Android device itself</li></ul></div><p>For this recipe, we choose a tool belonging to the latter category.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec77"/>How to do it...</h2></div></div></div><p>Perform the following steps for conducting dynamic analysis:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Have an Android device with applications (to be analyzed dynamically) installed.</li><li class="listitem">Go to the Play Store and download <span class="strong"><strong>Andrubis</strong></span>. Andrubis is a tool from iSecLabs which runs on Android devices and conducts static, dynamic, and URL analysis on the installed applications. We will use it for dynamic analysis only in this recipe.</li><li class="listitem">Open the Andrubis application on your Android device. It displays the applications installed on the Android device and analyzes these applications.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec78"/>How it works...</h2></div></div></div><p>Open the analysis of the application of your interest. Andrubis computes an overall malice score (out of 10) for the applications and gives the color icon in front of its main screen to reflect the vulnerable application.</p><p>We selected an orange colored application to make more sense with this recipe. This is how the application summary and score is shown in Andrubis:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_002.jpg" alt="How it works..."/></div><p>
</p><p>Let us navigate to the <span class="strong"><strong>Dynamic Analysis</strong></span> tab and check the results:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_003.jpg" alt="How it works..."/></div><p>
</p><p>The results are interesting for this application. Notice that all the files going to be written by the application under dynamic analysis are listed down. In our case, one <code class="literal">preferences.xml</code> is located.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>Though the fact that the application is going to create a preferences file could have been found in static analysis as well, additionally, dynamic analysis confirmed that such a file is indeed created. It also confirms that the code snippet found in static analysis about the creation of a preferences file is not a dormant code but a file that is going to be created.
Further, go ahead and read the created file and find any sensitive data present there. Who knows, luck may strike and give you a key to hidden treasure.</p></div></div><p>Notice that the first screen has a hyperlink, <span class="strong"><strong>View full report in browser</strong></span>. Tap on it and notice that the detailed dynamic analysis is presented for your further analysis. This also lets you understand what the tool tried and what response it got. This is shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_004.jpg" alt="How it works..."/></div><p>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec79"/>There's more...</h2></div></div></div><p>The current recipe used a dynamic analyzer belonging to the latter category. There are many other tools available in the former category. Since this is an Android platform, many of them are open source tools.</p><p>DroidBox can be tried for dynamic analysis. It looks for file operations (read/write), network data traffic, SMS, permissions, broadcast receivers, and so on, among other checks.</p><p>Hooker is another tool that can intercept and modify API calls initiated from the application. This is very useful in dynamic analysis. Try hooking and tampering with data in API calls.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec80"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://play.google.com/store/apps/details?id=org.iseclab.andrubis">https://play.google.com/store/apps/details?id=org.iseclab.andrubis</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://code.google.com/p/droidbox/">https://code.google.com/p/droidbox/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://github.com/AndroidHooker/hooker">https://github.com/AndroidHooker/hooker</a></li></ul></div></div></div>
<div class="section" title="Using Drozer to find vulnerabilities in Android applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Using Drozer to find vulnerabilities in Android applications</h1></div></div></div><p>Drozer is a mobile security audit and attack framework, maintained by MWR InfoSecurity. It is a must-have tool in the tester's armory. Drozer (Android installed application) interacts with other Android applications via <span class="strong"><strong>IPC</strong></span> (<span class="strong"><strong>Inter Process Communication</strong></span>). It allows fingerprinting of application package-related information, its attack surface, and attempts to exploit those. Drozer is an attack framework and advanced level exploits can be conducted from it. We use Drozer to find vulnerabilities in our applications.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec81"/>Getting ready</h2></div></div></div><p>Install Drozer by downloading it from 
<a class="ulink" href="https://www.mwrinfosecurity.com/products/drozer/">https://www.mwrinfosecurity.com/products/drozer/</a>
 and follow the installation instructions mentioned in the user guide.</p><p>Install Drozer console agent and start a session as mentioned in the User Guide.</p><p>If your installation is correct, you should get Drozer command prompt (<code class="literal">dz&gt;</code>).</p><p>You should also have a few vulnerable applications as well to analyze. Here we chose OWASP GoatDroid application.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec82"/>How to do it...</h2></div></div></div><p>Every pentest starts with fingerprinting. Let us use Drozer for the same. The Drozer User Guide is very helpful for referring to the commands.</p><p>The following command can be used to obtain information about an Android application package:</p><pre class="programlisting">
<span class="strong"><strong>run app.package.info -a &lt;package name&gt;</strong></span>
</pre><p>We used the same to extract the information from the GoatDroid application and found the following results:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_005.jpg" alt="How to do it..."/></div><p>
</p><p>Notice that apart from the general information about the application, <code class="literal">User Permissions</code> are also listed by Drozer.</p><p>Further, let us analyze the attack surface. Drozer's attack surface lists the exposed activities, broadcast receivers, content providers, and services. The in-genuinely exposed ones may be a critical security risk and may provide you access to privileged content.</p><p>Drozer has the following command to analyze the attack surface:</p><pre class="programlisting">
<span class="strong"><strong>run app.package.attacksurface &lt;package name&gt;</strong></span>
</pre><p>We used the same to obtain the attack surface of the Herd Financial application of GoatDroid and the results can be seen in the following screenshot. Notice that one Activity and one Content Provider are exposed.</p><p>We chose to attack the content provider to obtain the data stored locally. We used the following Drozer command to analyze the content provider of the same application:</p><pre class="programlisting">
<span class="strong"><strong>run app.provider.info -a &lt;package name&gt;</strong></span>
</pre><p>This gave us the details of the exposed content provider, which we used in another Drozer command:</p><pre class="programlisting">
<span class="strong"><strong>run scanner.provider.finduris -a &lt;package name&gt;</strong></span>
</pre><p>We could successfully query the content providers. Lastly, we would be interested in stealing the data stored by this content provider. This is possible via another Drozer command:</p><pre class="programlisting">
<span class="strong"><strong>run app.provider.query content://&lt;content provider details&gt;/</strong></span>
</pre><p>The entire sequence of events is shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_006.jpg" alt="How to do it..."/></div><p>
</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec83"/>How it works...</h2></div></div></div><p>ADB is used to establish a connection between Drozer Python server (present on computer) and Drozer agent (<code class="literal">.apk</code> file installed in emulator or Android device). Drozer console is initialized to run the various commands we saw.</p><p>Drozer agent utilizes the Android OS feature of IPC to take over the role of the target application and run the various commands as the original application.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec84"/>There's more...</h2></div></div></div><p>Drozer not only allows users to obtain the attack surface and steal data via content providers or launch intent injection attacks, but it is way beyond that. It can be used to fuzz the application, cause local injection attacks by providing a way to inject payloads.</p><p>Drozer can also be used to run various in-built exploits and can be utilized to attack Android applications via custom-developed exploits. Further, it can also run in Infrastructure mode, allowing remote connections and remote attacks.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec85"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Launching intent injection in Android</em></span></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf">https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf</a></li></ul></div></div></div>
<div class="section" title="Auditing iOS application using static analysis"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Auditing iOS application using static analysis</h1></div></div></div><p>Static analysis in source code reviews is an easier technique, and employing static string searches makes it convenient to use. Static analysis is conducted on the raw or decompiled source code or on the compiled (object) code, but the analysis is conducted outside of runtime. Usually, static analysis figures out vulnerable or insecure code patterns.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec86"/>Getting ready</h2></div></div></div><p>For conducting static analysis of iOS applications, we need at least one iOS application and a static code scanner. Pick up any iOS application of your choice and use any static analyzer tool of your choice.</p><p>We will use <code class="literal">iOS-ScriptDroid</code>, which is a static analysis script, developed by Android security researcher, Dinesh Shetty.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec87"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Keep the decompressed iOS application filed and note the path of the folder containing the <code class="literal">.m</code> files.</li><li class="listitem">Create an <code class="literal">iOS-ScriptDroid.bat</code> file by using the following code:<pre class="programlisting">  ECHO Running ScriptDriod ... &#13;
  @ECHO OFF &#13;
  SET /P Filelocation=Please Enter Location: &#13;
  :: SET Filelocation=Location of the folder containing all the .m files eg: C:\sourcecode\project&#13;
  \iOS\xyz\ &#13;
 &#13;
  mkdir %Filelocation%OUTPUT &#13;
 &#13;
 &#13;
  :: Code to check for Sensitive Information storage in Phone memory &#13;
  grep -H -i -n -C2 -e "NSFile" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\phonememory.txt" &#13;
  grep -H -i -n -e  "writeToFile " "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\phonememory.txt" &#13;
 &#13;
  :: Code to check for possible Buffer overflow &#13;
  grep -H -i -n  -e "strcat(\|strcpy(\|strncat(\|strncpy(\|sprintf(\|vsprintf(\|gets("&#13;
  "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\BufferOverflow.txt" &#13;
 &#13;
 &#13;
  :: Code to check for usage of URL Schemes &#13;
  grep -H -i -n  -C2 "openUrl\|handleOpenURL" "%Filelocation%*.m" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\URLSchemes.txt" &#13;
 &#13;
 &#13;
  :: Code to check for possible scripting javscript injection &#13;
  grep -H -i -n  -e "webview" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\probableXss.txt" &#13;
 &#13;
 &#13;
  :: Code to check for presence of possible weak algorithms &#13;
  grep -H -i -n  -e "MD5" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\tweakencryption.txt" &#13;
  grep -H -i -n  -e "base64" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\tweakencryption.txt" &#13;
  grep -H -i -n  -e "des" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\tweakencryption.txt" &#13;
  grep -H -i -n -v "//" "%Filelocation%OUTPUT\tweakencryption.txt" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\weakencryption.txt" &#13;
  del %Filelocation%OUTPUT\tweakencryption.txt &#13;
 &#13;
  :: Code to check for weak transportation medium &#13;
  grep -H -i -n -e  "http://" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\overhttp.txt" &#13;
  grep -H -i -n  -e "NSURL" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\OtherUrlConnection.txt" &#13;
  grep -H -i -n  -e "URL" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\OtherUrlConnection.txt" &#13;
  grep -H -i -n  -e "writeToUrl" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\OtherUrlConnection.txt" &#13;
  grep -H -i -n  -e "NSURLConnection" "%Filelocation%*.m" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\OtherUrlConnection.txt" &#13;
  grep -H -i -n -C2 "CFStream" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\OtherUrlConnection.txt" &#13;
  grep -H -i -n  -C2 "NSStreamin" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\OtherUrlConnection.txt" &#13;
 &#13;
  grep -H -i -n -e "setAllowsAnyHTTPSCertificate\|kCFStreamSSLAllowsExpiredRoots&#13;
  \|kCFStreamSSLAllowsExpiredCertificates" "%Filelocation%*.m" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\BypassSSLvalidations.txt"  &#13;
  grep -H -i -n -e "kCFStreamSSLAllowsAnyRoot\|continueWithoutCredentialForAuthenticationChallenge"&#13;
  "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\BypassSSLvalidations.txt" &#13;
  ::to add check for "didFailWithError" &#13;
 &#13;
  :: Code to presence of possible SQL Content &#13;
  grep -H -i -F  -e "db" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\sqlcontent.txt"  &#13;
  grep -H -i -F  -e "sqlite" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\sqlcontent.txt"  &#13;
  grep -H -i -F  -e "database" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\sqlcontent.txt"  &#13;
  grep -H -i -F  -e "insert" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\sqlcontent.txt"  &#13;
  grep -H -i -F -e "delete" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\sqlcontent.txt"  &#13;
  grep -H -i -F  -e "select" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\sqlcontent.txt"  &#13;
  grep -H -i -F  -e "table" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\sqlcontent.txt"  &#13;
  grep -H -i -F -e "cursor" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\sqlcontent.txt"  &#13;
  grep -H -i -F -e "sqlite3_prepare" "%Filelocation%OUTPUT\sqlcontent.txt" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\sqlcontent.txt"  &#13;
  grep -H -i -F -e "sqlite3_compile" "%Filelocation%OUTPUT\sqlcontent.txt" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\sqlcontent.txt"  &#13;
 &#13;
  :: Code to check for presence of keychain usage source code&#13;
  grep -H -i -n  -e "kSecASttr\|SFHFKkey" "%Filelocation%*.m" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\LocationInfo.txt"  &#13;
 &#13;
  :: Code to check for Logging mechanism &#13;
  grep -H -i -n  -F "NSLog" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\Logging.txt"  &#13;
  grep -H -i -n  -F "XLog" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\Logging.txt"  &#13;
  grep -H -i -n  -F "ZNLog" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\Logging.txt"  &#13;
 &#13;
 &#13;
  :: Code to check for presence of password in source code &#13;
  grep -H -i -n  -e "password\|pwd" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\password.txt"  &#13;
 &#13;
  :: Code to check for Debugging status &#13;
  grep -H -i -n  -e "#ifdef DEBUG" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\DebuggingAllowed.txt"  &#13;
 &#13;
  :: Code to check for presence of Device Identifiers  ===need to work more on this &#13;
  grep -H -i -n  -e "uid\|user-id\|imei\|deviceId\|deviceSerialNumber\|devicePrint\|X-DSN\|phone&#13;
  \|mdn\|did\|IMSI\|uuid" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\Temp_Identifiers.txt"  &#13;
  grep -H -i -n -v "//" "%Filelocation%OUTPUT\Temp_Identifiers.txt" &gt;&gt;&#13;
   "%Filelocation%OUTPUT\Device_Identifier.txt" &#13;
  del %Filelocation%OUTPUT\Temp_Identifiers.txt &#13;
 &#13;
 &#13;
  :: Code to check for presence of Location Info &#13;
  grep -H -i -n  -e "CLLocationManager\|\startUpdatingLocation\|locationManager\|didUpdateToLocation&#13;
  \|CLLocationDegrees\|CLLocation\|CLLocationDistance\|startMonitoringSignificantLocationChanges"&#13;
  "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\LocationInfo.txt"  &#13;
 &#13;
  :: Code to check for presence of Comments &#13;
  grep -H -i -n -e "//" "%Filelocation%*.m" &gt;&gt; "%Filelocation%OUTPUT\Temp_comment.txt" &#13;
  type -H -i  "%Filelocation%*.m" |gawk "/\/\*/,/\*\//" &gt;&gt; "%Filelocation%OUTPUT\MultilineComments.txt" &#13;
  grep -H -i -n -v "TODO" "%Filelocation%OUTPUT\Temp_comment.txt" &gt;&gt;&#13;
  "%Filelocation%OUTPUT\SinglelineComments.txt" &#13;
  del %Filelocation%OUTPUT\Temp_comment.txt &#13;
</pre></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec88"/>How it works...</h2></div></div></div><p>Go to the command prompt and navigate to the path where <code class="literal">iOS-ScriptDroid</code> is placed. Run the batch file and it prompts you to input the path of the application for which you wish to perform static analysis.</p><p>In our case, we arbitrarily chose an application and inputted the path of the implementation (<code class="literal">.m</code>) files.</p><p>The script generates a folder by the name <code class="literal">OUTPUT</code> in the path where the <code class="literal">.m</code> files of the application are present. The <code class="literal">OUTPUT</code> folder contains multiple text files, each one corresponding to a particular vulnerability. The individual text files pinpoint the location of vulnerable code pertaining to the vulnerability under discussion.</p><p>The <code class="literal">iOS-ScriptDroid</code> gives first hand info of various iOS applications vulnerabilities present in the current applications.</p><p>For instance, here are a few of them which are specific to the iOS platform.</p><p>
<code class="literal">BufferOverflow.txt</code> contains the usage of harmful functions when missing buffer limits such as <code class="literal">strcat</code>, <code class="literal">strcpy</code>, and so on are found in the application.</p><p>URL Schemes, if implemented in an insecure manner, may result in access related vulnerabilities. Usage of URL schemes is listed in <code class="literal">URLSchemes.txt</code>.</p><p>These are sefuuseful vulnerability details to know in iOS applications via static analysis.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec89"/>There's more...</h2></div></div></div><p>The current recipe used just <code class="literal">iOS-ScriptDroid</code> but there are many other options available. You can either choose to write your own script or you may use one of the free or commercial tools available. A few commercial tools have pioneered the static analysis approach over the years via their dedicated focus.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec90"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Auditing Android apps using static analysis</em></span></li></ul></div></div></div>
<div class="section" title="Auditing iOS application using a dynamic analyzer"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Auditing iOS application using a dynamic analyzer</h1></div></div></div><p>Dynamic analysis is the runtime analysis of the application. The application is run or simulated to discover the flaws during runtime. Dynamic analysis can be tricky, especially in the case of mobile platforms.</p><p>Dynamic analysis is helpful in tampering data in transmission during runtime, for example, tampering with the amount in a transaction request being sent to a payment gateway. In applications that use custom encryption to prevent attackers reading the data, dynamic analysis is useful in revealing the encrypted data, which can be reverse-engineered.</p><p>Note that since iOS applications cannot be decompiled to the full extent, dynamic analysis becomes even more important in finding the sensitive data which could have been hardcoded.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec91"/>Getting ready</h2></div></div></div><p>For conducting dynamic analysis of iOS applications, we need at least one iOS application and a dynamic code analyzer tool. Pick up any iOS application of your choice and use any dynamic analyzer tool of your choice.</p><p>In this recipe, let us use the open source tool <span class="strong"><strong>Snoop-it</strong></span>. We will use an iOS app that locks files which can only be opened using PIN, pattern, and a secret question and answer to unlock and view the file.</p><p>Let us see if we can analyze this app and find a security flaw in it using Snoop-it. Please note that Snoop-it only works on jailbroken devices.</p><p>To install Snoop-it on your iDevice, visit 
<a class="ulink" href="https://code.google.com/p/snoop-it/wiki/GettingStarted?tm=6">https://code.google.com/p/snoop-it/wiki/GettingStarted?tm=6</a>
.</p><p>We have downloaded <span class="strong"><strong>Locker Lite</strong></span> from the App Store onto our device, for analysis.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec92"/>How to do it...</h2></div></div></div><p>Perform the following steps to conduct dynamic analysis on iOS applications:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the Snoop-it app by tapping on its icon.</li><li class="listitem">Navigate to <span class="strong"><strong>Settings</strong></span>. Here you will see the URL through which the interface can be accessed from your machine:<p>
</p><div class="mediaobject"><img src="graphics/image_03_007.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">Please note the URL, for we will be using it soon. We have disabled authentication for our ease.</li><li class="listitem">Now, on the iDevice, tap on <span class="strong"><strong>Applications</strong></span> | <span class="strong"><strong>Select App Store Apps</strong></span> and select the <span class="strong"><strong>Locker</strong></span> app:<p>
</p><div class="mediaobject"><img src="graphics/image_03_008.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">Press the home button, and open the Locker app. Note that on entering the wrong PIN, we do not get further access:<p>
</p><div class="mediaobject"><img src="graphics/image_03_009.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">Making sure the workstation and iDevice are on the same network, open the previously noted URL in any browser. This is how the interface will look:<p>
</p><div class="mediaobject"><img src="graphics/image_03_010.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">Click on the <span class="strong"><strong>Objective-C Classes</strong></span> link under <span class="strong"><strong>Analysis</strong></span> in the left-hand panel:<p>
</p><div class="mediaobject"><img src="graphics/image_03_011.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">Now, click on <code class="literal">SM_LoginManagerController</code>. Class information gets loaded in the panel to the right of it.</li><li class="listitem">Navigate down until you see <code class="literal">-(void) unlockWasSuccessful</code> and click on the radio button preceding it:<p>
</p><div class="mediaobject"><img src="graphics/image_03_012.jpg" alt="How to do it..."/></div><p>
</p><p>This method has now been selected.</p></li><li class="listitem">Next, click on the <span class="strong"><strong>Setup and invoke</strong></span> button on the top-right of the panel. In the window that appears, click on the <span class="strong"><strong>Invoke Method</strong></span> button at the bottom:<p>
</p><div class="mediaobject"><img src="graphics/image_03_013.jpg" alt="How to do it..."/></div><p>
</p><p>As soon as we click on the button, we notice that the authentication has been bypassed, and we can view our locked file successfully.</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec93"/>How it works...</h2></div></div></div><p>Snoop-it loads all classes that are in the app, and indicates the ones that are currently operational with a green color. Since we want to bypass the current login screen, and load directly into the main page, we look for <code class="literal">UIViewController</code>.</p><p>Inside <code class="literal">UIViewController</code>, we see <code class="literal">SM_LoginManagerController</code>, which could contain methods relevant to authentication. On observing the class, we see various methods such as <code class="literal">numberLoginSucceed</code>, <code class="literal">patternLoginSucceed</code>, and many others.</p><p>The app calls the <code class="literal">unlockWasSuccessful</code> method when a PIN code is entered successfully.</p><p>So, when we invoke this method from our machine and the function is called directly, the app loads the main page successfully.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec94"/>There's more...</h2></div></div></div><p>The current recipe used just one dynamic analyzer but other options and tools can also be employed. There are many challenges in doing dynamic analysis of iOS applications. You may like to use multiple tools and not just rely on one to overcome the challenges.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec95"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://code.google.com/p/snoop-it/">https://code.google.com/p/snoop-it/</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Auditing Android apps using a dynamic analyzer</em></span></li></ul></div></div></div>
<div class="section" title="Examining iOS App Data storage and Keychain security vulnerabilities"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Examining iOS App Data storage and Keychain security vulnerabilities</h1></div></div></div><p>Keychain in iOS is an encrypted SQLite database that uses a 128-bit AES algorithm to hold identities and passwords.</p><p>On any iOS device, the Keychain SQLite database is used to store user credentials such as usernames, passwords, encryption keys, certificates, and so on.</p><p>Developers use this service API to instruct the operating system to store sensitive data securely, rather than using a less secure alternative storage mechanism such as a property list file or a configuration file.</p><p>In this recipe we will be analyzing Keychain dump to discover stored credentials.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec96"/>Getting ready</h2></div></div></div><p>Please follow the given steps to prepare for Keychain dump analysis:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Jailbreak the iPhone or iPad.</li><li class="listitem">Ensure the SSH server is running on the device (default after jailbreak).</li><li class="listitem">Download the <code class="literal">Keychain_dumper</code> binary from <a class="ulink" href="https://github.com/ptoomey3/Keychain-Dumper">https://github.com/ptoomey3/Keychain-Dumper</a></li><li class="listitem">Connect the iPhone and the computer to the same Wi-Fi network.</li><li class="listitem">On the computer, run SSH into the iPhone by typing the iPhone IP address, username as <code class="literal">root</code>, and password as <code class="literal">alpine</code>.</li></ol></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec97"/>How to do it...</h2></div></div></div><p>Follow these steps to examine security vulnerabilities in iOS:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Copy <code class="literal">keychain_dumper</code> into the iPhone or iPad by issuing the following command:<pre class="programlisting">
<span class="strong"><strong>scp root@&lt;device ip&gt;:keychain_dumper private/var/tmp</strong></span>
</pre></li><li class="listitem">Alternatively, Windows WinSCP can be used to do the same:<p>
</p><div class="mediaobject"><img src="graphics/image_03_014.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">Once the binary has been copied, ensure the <code class="literal">keychain-2.db</code> has read access:<pre class="programlisting">
<span class="strong"><strong>chmod +r /private/var/Keychains/keychain-2.db</strong></span>
</pre><p>This is shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_015.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">Give executable right to binary:<pre class="programlisting">
<span class="strong"><strong>chmod 777 /private/var/tmp/keychain_dumper</strong></span>
</pre></li><li class="listitem">Now, we simply run <code class="literal">keychain_dumper</code>:<pre class="programlisting">
<span class="strong"><strong>/private/var/tmp/keychain_dumper</strong></span>
</pre><p>
</p><div class="mediaobject"><img src="graphics/image_03_016.jpg" alt="How to do it..."/></div><p>
</p><p>This command will dump all keychain information, which will contain all the generic and Internet passwords stored in the keychain:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_017.jpg" alt="How to do it..."/></div><p>
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec98"/>How it works...</h2></div></div></div><p>Keychain in an iOS device is used to securely store sensitive information such as credentials, such as usernames, passwords, authentication tokens for different applications, and so on, along with connectivity (Wi-Fi/VPN) credentials and so on. It is located on iOS devices as an encrypted SQLite database file located at <code class="literal">/private/var/Keychains/keychain-2.db</code>.</p><p>Insecurity arises when application developers use this feature of the operating system to store credentials rather than storing it themselves in <code class="literal">NSUserDefaults</code>, <code class="literal">.plist</code> files, and so on. To provide users the ease of not having to log in every time and hence saving the credentials in the device itself, the keychain information for every app is stored outside of its sandbox.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec99"/>There's more...</h2></div></div></div><p>This analysis can also be performed for specific apps dynamically, using tools such as Snoop-it. Follow the steps to hook Snoop-it to the target app, click on <code class="literal">Keychain Values</code>, and analyze the attributes to see its values reveal in the Keychain.</p><p>More will be discussed in further recipes.</p></div></div>
<div class="section" title="Finding vulnerabilities in WAP-based mobile apps"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Finding vulnerabilities in WAP-based mobile apps</h1></div></div></div><p>WAP-based mobile applications are mobile applications or websites that run on mobile browsers. Most organizations create a lightweight version of their complex websites to be able to run easily and appropriately in mobile browsers. For example, a hypothetical company called <code class="literal">ABCXYZ</code> may have their main website at <code class="literal">www.abcxyz.com</code>, while their mobile website takes the form <code class="literal">m.abcxyz.com</code>. Note that the mobile website (or WAP apps) are separate from their installable application form, such as <code class="literal">.apk</code> on Android.</p><p>Since mobile websites run on browsers, it is very logical to say that most of the vulnerabilities applicable to web applications are applicable to WAP apps as well. However, there are caveats to this. Exploitability and risk ratings may not be the same. Moreover, not all attacks may be directly applied or conducted.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec100"/>Getting ready</h2></div></div></div><p>For this recipe, make sure to be ready with the following set of tools (in the case of Android):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">ADB</li><li class="listitem" style="list-style-type: disc">WinSCP</li><li class="listitem" style="list-style-type: disc">Putty</li><li class="listitem" style="list-style-type: disc">Rooted Android mobile</li><li class="listitem" style="list-style-type: disc">SSH proxy application installed on Android phone</li></ul></div><p>Let us see the common WAP application vulnerabilities. While discussing these, we will limit ourselves to mobile browsers only:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Browser cache</strong></span>: Android browsers store cache in two different parts—content cache and component cache. Content cache may contain basic frontend components such as HTML, CSS, or JavaScript. Component cache contains sensitive data like the details to be populated once content cache is loaded. You have to locate the browser cache folder and find sensitive data in it.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Browser memory</strong></span>: Browser memory refers to the location used by browsers to store the data. Memory is usually long-term storage, while cache is short-term. Browse through the browser memory space for various files such as <code class="literal">.db</code>, <code class="literal">.xml</code>, <code class="literal">.txt</code>, and so on. Check all these files for the presence of sensitive data.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Browser history</strong></span>: Browser history contains the list of the URLs browsed by the user. These URLs in GET request format contain parameters. Again, our goal is to locate a URL with sensitive data for our WAP application.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cookies</strong></span>: Cookies are mechanisms for websites to keep track of user sessions. Cookies are stored locally in devices. Following are the security concerns with respect to cookie usage:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sometimes a cookie contains sensitive information</li><li class="listitem" style="list-style-type: disc">Cookie attributes, if weak, may make the application security weak</li><li class="listitem" style="list-style-type: disc">Cookie stealing may lead to a session hijack</li></ul></div><p>
</p></li></ul></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec101"/>How to do it...</h2></div></div></div><p>
<span class="strong"><strong>Browser Cache</strong></span>:</p><p>Let's look at the steps that need to be followed with browser cache:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Android browser cache can be found at this location: <code class="literal">/data/data/com.android.browser/cache/webviewcache/</code>.</li><li class="listitem">You can use either ADB to pull the data from <code class="literal">webviewcache</code>, or use <code class="literal">WinSCP/Putty</code> and connect to SSH application in rooted Android phones.</li><li class="listitem">Either way, you will land up at the <code class="literal">webviewcache</code> folder and find arbitrarily named files. Refer to the highlighted section in the following screenshot:<p>
</p><div class="mediaobject"><img src="graphics/image_03_018.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">Rename the extension of arbitrarily named files to <code class="literal">.jpg</code> and you will be able to view the cache in screenshot format. Search through all files for sensitive data pertaining to the WAP app you are searching for.</li></ol></div><p>
<span class="strong"><strong>Browser Memory</strong></span>:</p><p>Like an Android application, browser also has a memory space under the <code class="literal">/data/data</code> folder by the name <code class="literal">com.android.browser</code> (default browser). Here is how a typical browser memory space looks:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_019.jpg" alt="How to do it..."/></div><p>
</p><p>Make sure you traverse through all the folders to get the useful sensitive data in the context of the WAP application you are looking for.</p><p>
<span class="strong"><strong>Browser history</strong></span>
</p><p>Go to browser, locate options, navigate to <span class="strong"><strong>History</strong></span>, and find the URLs present there.</p><p>
<span class="strong"><strong>Cookies</strong></span>
</p><p>The files containing cookie values can be found at <code class="literal">/data/data/com.android.browser/databases/webview.db</code>.</p><p>These DB files can be opened with the SQLite Browser tool and cookies can be obtained.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec102"/>There's more...</h2></div></div></div><p>Apart from the primary vulnerabilities described here mainly concerned with browser usage, all other web application vulnerabilities which are related to or exploited from or within a browser are applicable and need to be tested:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cross-site scripting, a result of a browser executing unsanitized harmful scripts reflected by the servers is very valid for WAP applications.</li><li class="listitem" style="list-style-type: disc">The autocomplete attribute not turned to off may result in sensitive data remembered by the browser for returning users. This again is a source of data leakage.</li><li class="listitem" style="list-style-type: disc">Browser thumbnails and image buffer are other sources to look for data.</li></ul></div><p>Above all, all the vulnerabilities in web applications, which may not relate to browser usage, apply. These include <span class="strong"><strong>OWASP Top 10</strong></span> vulnerabilities such as SQL injection attacks, broken authentication and session management, and so on. Business logic validation is another important check to bypass. All these are possible by setting a proxy to the browser and playing around with the mobile traffic (we provide a different recipe for the same in a later chapter).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>The discussion of this recipe has been around Android, but all the discussion is fully applicable to an iOS platform when testing WAP applications. Approach, steps to test, and the locations would vary, but all vulnerabilities still apply. You may want to try out iExplorer and plist editor tools when working with an iPhone or iPad.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec103"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://resources.infosecinstitute.com/browser-based-vulnerabilities-in-web-applications/">http://resources.infosecinstitute.com/browser-based-vulnerabilities-in-web-applications/</a></li></ul></div></div></div>
<div class="section" title="Finding client-side injection"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Finding client-side injection</h1></div></div></div><p>Client-side injection is a new dimension to the mobile threat landscape. Client side injection (also known as local injection) is a result of the injection of malicious payloads to local storage to reveal data not by the usual workflow of the mobile application. If <code class="literal">'or'1'='1</code> is injected in a mobile application on search parameter, where the search functionality is built to search in the local SQLite DB file, this results in revealing all data stored in the corresponding table of SQLite DB; client side SQL injection is successful.</p><p>Notice that the payload did not to go the database on the server side (which possibly can be Oracle or MSSQL) but it did go to the local database (SQLite) in the mobile. Since the injection point and injectable target are local (that is, mobile), the attack is called a <span class="strong"><strong>client side injection</strong></span>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec104"/>Getting ready</h2></div></div></div><p>To get ready to find client side injection, have a few mobile applications ready to be audited and have a bunch of tools used in many other recipes throughout this book.</p><p>Note that client side injection is not easy to find on account of the complexities involved; many a time you will have to fine-tune your approach as per the successful first signs.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec105"/>How to do it...</h2></div></div></div><p>The prerequisite to the existence of client side injection vulnerability in mobile apps is the presence of a local storage and an application feature which queries the local storage. For the convenience of the first discussion, let us learn client side SQL injection, which is fairly easy to learn as users know very well SQL Injection in web apps.</p><p>Let us take the case of a mobile banking application which stores the branch details in a local SQLite database. The application provides a search feature to users wishing to search a branch. Now, if a person types in the city as Mumbai, the <code class="literal">city</code> parameter is populated with the value <code class="literal">Mumbai</code> and the same is dynamically added to the SQLite query. The query builds and retrieves the branch list for Mumbai city. (Usually, purely local features are provided for faster user experience and network bandwidth conservation.)</p><p>Now if a user is able to inject harmful payloads into the city parameter, such as a wildcard character or a SQLite payload to the drop table, and the payloads execute revealing all the details (in the case of a wildcard) or the payload drops the table from the DB (in the case of a drop table payload) then you have successfully exploited client side SQL injection.</p><p>Another type of client side injection, presented in OWASP Mobile TOP 10 release, is local <span class="strong"><strong>cross-site scripting</strong></span> (<span class="strong"><strong>XSS</strong></span>). Refer to slide number 22 of the original OWASP PowerPoint presentation here: 
<a class="ulink" href="http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks">http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks</a>
. They referred to it as Garden Variety XSS and presented a code snippet, wherein SMS text was accepted locally and printed at UI. If a script was inputted in SMS text, it would result in local XSS (JavaScript Injection).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec106"/>There's more...</h2></div></div></div><p>In a similar fashion, HTML Injection is also possible. If an HTML file contained in the application local storage can be compromised to contain malicious code and the application has a feature which loads or executes this HTML file, HTML injection is possible locally.</p><p>A variant of the same may result in <span class="strong"><strong>Local File Inclusion</strong></span> (<span class="strong"><strong>LFI</strong></span>) attacks.</p><p>If data is stored in the form of XML files in the mobile, local XML Injection can also be attempted.</p><p>There could be more variants of these attacks possible. Finding client-side injection is quite difficult and time consuming. It may need to employ both static and dynamic analysis approaches. Most scanners also do not support discovery of Client Side Injection.</p><p>Another dimension to Client Side Injection is the impact, which is judged to be low in most cases. There is a strong counter argument to this vulnerability. If the entire local storage can be obtained easily in Android, then why do we need to conduct Client Side Injection? I agree to this argument in most cases, as the entire SQLite or XML file from the phone can be stolen, why spend time searching a variable that accepts a wildcard to reveal the data from the SQLite or XML file?</p><p>However, you should still look out for this vulnerability, as HTML injection or LFI kind of attacks have malware-corrupted file insertion possibility and hence the impactful attack. Also, there are platforms such as iOS where sometimes, stealing the local storage is very difficult. In such cases, client side injection may come in handy.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec107"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://www.owasp.org/index.php/Mobile_Top_10_2014-M7">https://www.owasp.org/index.php/Mobile_Top_10_2014-M7</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks">
http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks</a></li></ul></div></div></div>
<div class="section" title="Insecure encryption in mobile apps"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Insecure encryption in mobile apps</h1></div></div></div><p>Encryption is one of the misused terms in information security. Some people confuse it with hashing, while others may implement encoding and call it encryption. symmetric key and asymmetric key are two types of encryption schemes.</p><p>Mobile applications implement encryption to protect sensitive data in storage and in transit. While doing audits, your goal should be to uncover weak encryption implementation or the so-called encoding or other weaker forms, which are implemented in places where a proper encryption should have been implemented. Try to circumvent the encryption implemented in the mobile application under audit.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec108"/>Getting ready</h2></div></div></div><p>Be ready with a few mobile applications and tools such as ADB and other file and memory readers, decompiler and decoding tools, and so on.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec109"/>How to do it...</h2></div></div></div><p>There are multiple types of faulty implementation of encryption in mobile applications. There are different ways to discover each of them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Encoding (instead of encryption): Many a time, mobile app developers simply implement Base64 or URL encoding in applications (an example of security by obscurity).<p>Such encoding can be discovered by simply doing static analysis. You can use the script discussed in the first recipe of this chapter for finding out such encoding algorithms.</p><p>Dynamic analysis will help you obtain the locally stored data in encoded format. Decoders for these known encoding algorithms are available freely. Using any of those, you will be able to uncover the original value. Thus, such implementation is not a substitute for encryption.</p></li><li class="listitem" style="list-style-type: disc">Serialization (instead of encryption): Another variation of faulty implementation is serialization. Serialization is the process of conversion of data objects to byte stream. The reverse process, deserialization, is also very simple and the original data can be obtained easily.<p>Static Analysis may help reveal implementations using serialization.</p></li><li class="listitem" style="list-style-type: disc">Obfuscation (instead of encryption): Obfuscation also suffers from similar problems and the obfuscated values can be deobfuscated.</li><li class="listitem" style="list-style-type: disc">Hashing (instead of encryption): Hashing is a one-way process using a standard complex algorithm. These one-way hashes suffer from a major problem in that they can be replayed (without needing to recover the original data). Also, rainbow tables can be used to crack the hashes.</li></ul></div><p>Like other techniques described previously, hashing usage in mobile applications can also be discovered via static analysis. Dynamic analysis may additionally be employed to reveal the one-way hashes stored locally.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec110"/>How it works...</h2></div></div></div><p>To understand the insecure encryption in mobile applications, let us take a live case, which we observed.</p><div class="section" title="An example of weak custom implementation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec4"/>An example of weak custom implementation</h3></div></div></div><p>While testing a live mobile banking application, me and my colleagues came across a scenario where a <code class="literal">userid</code> and <code class="literal">mpin</code> combination was sent by a custom encoding logic. The encoding logic here was based on a predefined character by character replacement by another character, as per an in-built mapping. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">2</code> is replaced by <code class="literal">4</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">0</code> is replaced by <code class="literal">3</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">3</code> is replaced by <code class="literal">2</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">7</code> is replaced by <code class="literal">=</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">a</code> is replaced by <code class="literal">R</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">A</code> is replaced by <code class="literal">N</code></li></ul></div><p>As you can notice, there is no logic to the replacement. Until you uncover or decipher the whole in-built mapping, you won't succeed. A simple technique is to supply all possible characters one-by-one and watch out for the response. Let's input <code class="literal">userid</code> and <code class="literal">PIN</code> as <code class="literal">222222</code> and <code class="literal">2222</code> and notice the converted <code class="literal">userid</code> and <code class="literal">PIN</code> are <code class="literal">444444</code> and <code class="literal">4444</code> respectively, as per the mapping above. Go ahead and keep changing the inputs, you will create a full mapping as is used in the application.</p><p>Now steal the user's encoded data and apply the created mapping, thereby uncovering the original data. This whole approach is nicely described in the article mentioned under the <span class="emphasis"><em>See also </em></span>section of this recipe.</p><p>This is a custom example of faulty implementation pertaining to encryption. Such kinds of faults are often difficult to find in static analysis, especially in the case of difficult to reverse apps such as iOS applications. The possibility of automated dynamic analysis discovering this is also difficult. Manual testing and analysis stands, along with dynamic or automated analysis, a better chance of uncovering such custom implementations.</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec111"/>There's more...</h2></div></div></div><p>Finally, I would share another application we came across. This one used proper encryption. The encryption algorithm was a well known secure algorithm and the key was strong. Still, the whole encryption process can be reversed.</p><p>The application had two mistakes; we combined both of them to break the encryption:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The application code had the standard encryption algorithm in the APK bundle. Not even obfuscation was used to protect the names at least. We used the simple process of APK to DEX to JAR conversion to uncover the algorithm details.</li><li class="listitem" style="list-style-type: disc">The application had stored the strong encryption key in the local XML file under the <code class="literal">/data/data</code> folder of the Android device. We used adb to read this xml file and hence obtained the encryption key.</li></ul></div><p>According to Kerckhoff's principle, the security of a cryptosystem should depend solely on the secrecy of the key and the private randomizer. This is how all encryption algorithms are implemented. The key is the secret, not the algorithm.</p><p>In our scenario, we could obtain the key and know the name of the encryption algorithm. This is enough to break the strong encryption implementation.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec112"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.paladion.net/index.php/mobile-phone-data-encryption-why-is-it-necessary/">http://www.paladion.net/index.php/mobile-phone-data-encryption-why-is-it-necessary/</a></li></ul></div></div></div>
<div class="section" title="Discovering data leakage sources"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Discovering data leakage sources</h1></div></div></div><p>Data leakage risk worries organizations across the globe and people have been implementing solutions to prevent data leakage. In the case of mobile applications, first we have to think what could be the sources or channels for data leakage possibility. Once this is clear, devise or adopt a technique to uncover each of them.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec113"/>Getting ready</h2></div></div></div><p>As in other recipes, here also you need bunch of applications (to be analyzed), an Android device or emulator, ADB, DEX to JAR converter, Java decompilers, Winrar, or Winzip.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec114"/>How to do it...</h2></div></div></div><p>To identify the data leakage sources, list down all possible sources you can think of for the mobile application under audit. In general, all mobile applications have the following channels of potential data leakage:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Files stored locally</li><li class="listitem" style="list-style-type: disc">Client side source code</li><li class="listitem" style="list-style-type: disc">Mobile device logs</li><li class="listitem" style="list-style-type: disc">Web caches</li><li class="listitem" style="list-style-type: disc">Console messages</li><li class="listitem" style="list-style-type: disc">Keystrokes</li><li class="listitem" style="list-style-type: disc">Sensitive data sent over HTTP</li></ul></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec115"/>How it works...</h2></div></div></div><p>The next step is to uncover the data leakage vulnerability at these potential channels. Let us see the six previously identified common channels:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Files stored locally</strong></span>: By this time, readers are very familiar with this. The data is stored locally in files like shared preferences, xml files, SQLite DB, and other files.<p>In Android, these are located inside the application folder under <code class="literal">/data/data</code> directory and can be read using tools such as ADB.</p><p>In iOS, tools such as iExplorer or SSH can be used to read the application folder.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Client side source code</strong></span>: Mobile application source code is present locally in the mobile device itself. The source code in applications has been hardcoding data, and a common mistake is hardcoding sensitive data (either knowingly or unknowingly).<p>From the field, we came across an application which had hardcoded the connection key to the connected PoS terminal. Hardcoded formulas to calculate a certain figure, which should have ideally been present in the server-side code, was found in the mobile app. Database instance names and credentials are also a possibility where the mobile app directly connects to a server datastore.</p><p>In Android, the source code is quite easy to decompile via a two-step process—APK to DEX and DEX to JAR conversion.</p><p>In iOS, the source code of header files can be decompiled up to a certain level using tools such as classdump-z or otool.</p><p>Once the raw source code is available, a static string search can be employed to discover sensitive data in the code.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mobile device logs</strong></span>: All devices create local logs to store crash and other information, which can be used to debug or analyze a security violation. A poor coding may put sensitive data in local logs and hence data can be leaked from here as well.<p>Android ADB command <code class="literal">adb logcat</code> can be used to read the logs on Android devices. If you use the same ADB command for the Vulnerable Bank application, you will notice the user credentials in the logs as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_03_020.jpg" alt="How it works..."/></div><p>
</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Web caches</strong></span>: Web caches may also contain the sensitive data related to web components used in mobile apps. We discussed how to discover this in the WAP recipe in this chapter previously.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Console messages</strong></span>: Console messages are used by developers to print messages to the console while application development and debugging is in progress. Console messages, if not turned off while launching the application (GO LIVE), may be another source of data leakage. Console messages can be checked by running the application in debug mode.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Keystrokes</strong></span>: Certain mobile platforms have been known to cache key strokes. A malware or key stroke logger may take advantage and steal a user's key strokes, hence making it another data leakage source. Malware analysis needs to be performed to uncover embedded or pre-shipped malware or keystroke loggers with the application. Dynamic analysis also helps.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Sensitive data sent over HTTP</strong></span>: Applications either send sensitive data over HTTP or use a weak implementation of SSL. In either case, sensitive data leakage is possible.</li></ul></div><p>Usage of HTTP can be found via static analysis to search for HTTP strings. Dynamic analysis to capture the packets at runtime also reveals whether traffic is over HTTP or HTTPS.</p><p>There are various SSL-related weak implementation and downgrade attacks, which make data vulnerable to sniffing and hence data leakage.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec116"/>There's more...</h2></div></div></div><p>Data leakage sources can be vast and listing all of them does not seem possible. Sometimes there are applications or platform-specific data leakage sources, which may call for a different kind of analysis.</p><p>Intent injection can be used to fire intents to access privileged contents. Such intents may steal protected data such as the personal information of all the patients in a hospital (under HIPPA compliance).</p><p>iOS screenshot backgrounding issues, where iOS applications store screenshots with populated user input data, on the iPhone or iPAD when the application enters background. Imagine such screenshots containing a user's credit card details, CCV, expiry date, and so on, are found in an application under PCI-DSS compliance.</p><p>Malwares give a totally different angle to data leakage. Note that data leakage is a very big risk organizations are tackling today. It is not just financial loss; losses may be intangible, such as reputation damage, or compliance or regulatory violations. Hence, it makes it very important to identify the maximum possible data leakage sources in the application and rectify the potential leakages.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec117"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://www.owasp.org/index.php/Mobile_Top_10_2014-M4">https://www.owasp.org/index.php/Mobile_Top_10_2014-M4</a></li><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Launching intent injection in Android</em></span></li></ul></div></div></div>
<div class="section" title="Other application-based attacks in mobile devices"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Other application-based attacks in mobile devices</h1></div></div></div><p>When we talk about application-based attacks, <span class="strong"><strong>OWASP TOP 10</strong></span> risks are the very first things that strike. OWASP (
<a class="ulink" href="http://www.owasp.org">www.owasp.org</a>
) has a dedicated project to mobile security, which releases <span class="strong"><strong>Mobile Top 10</strong></span>.</p><p>OWASP gathers data from industry experts and ranks the top 10 risks every three years. It is a very good knowledge base for mobile application security. Here is the latest Mobile Top 10 released in the year 2014:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">M1: Weak Server Side Controls</li><li class="listitem" style="list-style-type: disc">M2: Insecure Data Storage</li><li class="listitem" style="list-style-type: disc">M3: Insufficient Transport Layer Protection</li><li class="listitem" style="list-style-type: disc">M4: Unintended Data Leakage</li><li class="listitem" style="list-style-type: disc">M5: Poor Authorization and Authentication</li><li class="listitem" style="list-style-type: disc">M6: Broken Cryptography</li><li class="listitem" style="list-style-type: disc">M7: Client Side Injection</li><li class="listitem" style="list-style-type: disc">M8: Security Decisions via Untrusted Inputs</li><li class="listitem" style="list-style-type: disc">M9: Improper Session Handling</li><li class="listitem" style="list-style-type: disc">M10: Lack of Binary Protections</li></ul></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec118"/>Getting ready</h2></div></div></div><p>Have a few applications ready to be analyzed, use the same set of tools we have been discussing till now, and refer to the  <span class="emphasis"><em>Setting up the Android pentesting environment</em></span> and <span class="emphasis"><em>Setting up the iOS pentesting environment</em></span> recipes in <a class="link" href="ch01.html" title="Chapter 1.  Introduction to Mobile Security">Chapter 1</a>, <span class="emphasis"><em>Introduction to Mobile Security</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec119"/>How to do it...</h2></div></div></div><p>In this recipe, we restrict ourselves to other application attacks. The attacks which we have not covered till now in this book are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">M1: Weak Server Side Controls</li><li class="listitem" style="list-style-type: disc">M5: Poor Authorization and Authentication</li><li class="listitem" style="list-style-type: disc">M8: Security Decisions via Untrusted Inputs</li><li class="listitem" style="list-style-type: disc">M9: Improper Session Handling</li></ul></div><p>In <a class="link" href="ch05.html" title="Chapter 5. Working with Other Platforms">Chapter 5</a>, <span class="emphasis"><em>Working with Other Platforms</em></span>, M1 is covered in a detailed manner and M5 and M9, which are mostly server-side issues are also discussed in it.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec120"/>How it works...</h2></div></div></div><p>Currently, let us discuss client-side or mobile-side issues for M5, M8, and M9.</p><div class="section" title="M5: Poor Authorization and Authentication"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec5"/>M5: Poor Authorization and Authentication</h3></div></div></div><p>A few common scenarios which can be attacked are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Authentication implemented at device level (for example, PIN stored locally)</li><li class="listitem" style="list-style-type: disc">Authentication bound on poor parameters (such as UDID or IMEI numbers)</li><li class="listitem" style="list-style-type: disc">Authorization parameter responsible for access to protected application menus is stored locally</li></ul></div><p>These can be attacked by reading data using ADB, decompiling the applications, and conducting static analysis on the same or by doing dynamic analysis on the outgoing traffic.</p></div><div class="section" title="M8: Security Decisions via Untrusted Inputs"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec6"/>M8: Security Decisions via Untrusted Inputs</h3></div></div></div><p>This one talks about IPC. IPC entry points for applications to communicate to one other, such as Intents in Android or URL schemes in iOS, are vulnerable. If the origination source is not validated, the application can be attacked.</p><p>Malicious intents can be fired to bypass authorization or steal data. Let us discuss this in further detail in the next recipe.</p><p>URL schemes are a way for applications to specify the launch of certain components. For example, the mailto scheme in iOS is used to create a new e-mail. If the applications fail to specify the acceptable sources, any malicious application will be able to send a mailto scheme to the victim application and create new e-mails.</p></div><div class="section" title="M9: Improper Session Handling"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec7"/>M9: Improper Session Handling</h3></div></div></div><p>From a purely mobile device perspective, session tokens stored in <code class="literal">.db</code> files or <code class="literal">oauth</code> tokens, or strings granting access stored in weakly protected files, are vulnerable. These can be obtained by reading the local data folder using ADB.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec121"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://www.owasp.org/index.php/P;rojects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks">
https://www.owasp.org/index.php/P;rojects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks
</a></li></ul></div></div></div>
<div class="section" title="Launching intent injection in Android"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Launching intent injection in Android</h1></div></div></div><p>Android uses intents to request action from another application component. A common communication is passing Intent to start a service. We will exploit this fact via an <span class="strong"><strong>intent injection attack</strong></span>.</p><p>An intent injection attack works by injecting intent into the application component to perform a task that is usually not allowed by the application workflow. For example, if the Android application has a login activity which, post successful authentication, allows you access to protected data via another activity. Now if an attacker can invoke the internal activity to access protected data by passing an Intent, it would be an Intent Injection attack.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec122"/>Getting ready</h2></div></div></div><p>Install Drozer by downloading it from 
<a class="ulink" href="https://www.mwrinfosecurity.com/products/drozer/">https://www.mwrinfosecurity.com/products/drozer/</a>
 and following the installation instructions mentioned in the User Guide.</p><p>Install Drozer Console Agent and start a session as mentioned in the User Guide.</p><p>If your installation is correct, you should get a Drozer command prompt (<code class="literal">dz&gt;</code>).</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec123"/>How to do it...</h2></div></div></div><p>You should also have a few vulnerable applications to analyze. Here we chose the OWASP GoatDroid application:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Start the OWASP GoatDroid Fourgoats application in emulator.</li><li class="listitem">Browse the application to develop understanding. Note that you are required to authenticate by providing a username and password, and post-authentication you can access profile and other pages. Here is the pre-login screen you get:<p>
</p><div class="mediaobject"><img src="graphics/image_03_021.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">Let us now use Drozer to analyze the activities of the Fourgoats application. The following Drozer command is helpful:<pre class="programlisting">
<span class="strong"><strong>run app.activity.info -a &lt;package name&gt;</strong></span>
</pre><p>Drozer detects four activities with null permission. Out of these four, <code class="literal">ViewCheckin</code> and <code class="literal">ViewProfile</code> are post-login activities.</p></li><li class="listitem">Use Drozer to access these two activities directly, via the following command:<pre class="programlisting">
<span class="strong"><strong>run app.activity.start --component &lt;package name&gt; &lt;activity name&gt;</strong></span>
</pre></li><li class="listitem">We chose to access <code class="literal">ViewProfile</code> activity and the entire sequence of activities is shown in the following screenshot:<p>
</p><div class="mediaobject"><img src="graphics/image_03_022.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">Drozer performs some actions and the protected user profile opens up in the emulator, as shown here:<p>
</p><div class="mediaobject"><img src="graphics/image_03_023.jpg" alt="How to do it..."/></div><p>
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec124"/>How it works...</h2></div></div></div><p>Drozer passed an Intent in the background to invoke the post-login activity <code class="literal">ViewProfile</code>. This resulted in <code class="literal">ViewProfile</code> activity performing an action resulting in display of profile screen. This way, an intent injection attack can be performed using Drozer framework.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec125"/>There's more...</h2></div></div></div><p>Android uses intents also for starting a service or delivering a broadcast. Intent injection attacks can be performed on services and broadcast receivers. A Drozer framework can also be used to launch attacks on the app components. Attackers may write their own attack scripts or use different frameworks to launch this attack.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec126"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using Drozer to find vulnerabilities in Android applications</em></span></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf">https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://www.eecs.berkeley.edu/~daw/papers/intents-mobisys11.pdf">https://www.eecs.berkeley.edu/~daw/papers/intents-mobisys11.pdf</a></li></ul></div></div></div></body></html>