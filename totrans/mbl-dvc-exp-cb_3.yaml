- en: Chapter 3. Auditing Mobile Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Auditing Android apps using static analysis
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing Android apps using a dynamic analyzer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Drozer to find vulnerabilities in Android applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing iOS application using static analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing iOS application using a dynamic analyzer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining iOS App Data storage and Keychain security vulnerabilities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding vulnerabilities in WAP-based mobile apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding client-side injection
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insecure encryption in mobile apps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering data leakage sources
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other application-based attacks in mobile devices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching intent injection in Android
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile applications such as web applications may have vulnerabilities. These
    vulnerabilities in most cases are the result of bad programming practices or insecure
    coding techniques, or may be because of purposefully injected bad code. For users
    and organizations, it is important to know how vulnerable their applications are.
    Should they fix the vulnerabilities or keep/stop using the applications?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: To address this dilemma, mobile applications need to be audited with the goal
    of uncovering vulnerabilities. Mobile applications (Android, iOS, or other platforms)
    can be analyzed using static or dynamic techniques. Static analysis is conducted
    by employing certain text or string based searches across decompiled source code.
    Dynamic analysis is conducted at runtime and vulnerabilities are uncovered in
    simulated fashion. Dynamic analysis is difficult as compared to static analysis.
    In this chapter, we will employ both static and dynamic analysis to audit Android
    and iOS applications. We will also learn various other techniques to audit findings,
    including Drozer framework usage, WAP-based application audits, and typical mobile-specific
    vulnerability discovery.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Auditing Android apps using static analysis
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static analysis is the most commonly and easily applied analysis method in source
    code audits. Static by definition means something that is constant. Static analysis
    is conducted on the static code, that is, raw or decompiled source code or on
    the compiled (object) code, but the analysis is conducted without the runtime.
    In most cases, static analysis becomes code analysis via static string searches.
    A very common scenario is to figure out vulnerable or insecure code patterns and
    find the same in the entire application code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For conducting static analysis of Android applications, we at least need one
    Android application and a static code scanner. Pick up any Android application
    of your choice and use any static analyzer tool of your choice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we use **Insecure Bank**, which is a vulnerable Android application
    for Android security enthusiasts. We will also use **ScriptDroid**, which is a
    static analysis script. Both Insecure Bank and ScriptDroid are coded by Android
    security researcher, Dinesh Shetty.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest version of the Insecure Bank application from GitHub. Decompress
    or unzip the `.apk` file and note the path of the unzipped application.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 GitHub 下载最新版本的 Insecure Bank 应用程序。解压或解压`.apk`文件，并记下解压后的应用程序路径。
- en: 'Create a `ScriptDroid.bat` file by using the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个`ScriptDroid.bat`文件：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Go to the command prompt and navigate to the path where ScriptDroid is placed.
    Run the `.bat` file and it prompts you to input the path of the application for
    which you wish to perform static analysis. In our case we provide it with the
    path of the Insecure Bank application, precisely the path where Java files are
    stored. If everything worked correctly, the screen should look like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 打开命令提示符并导航到 ScriptDroid 所在的路径。运行 `.bat` 文件，它会提示你输入要进行静态分析的应用程序路径。在我们的例子中，我们提供了
    Insecure Bank 应用的路径，准确地说是 Java 文件存储的路径。如果一切正常，屏幕应该显示如下内容：
- en: '![How it works...](graphics/image_03_001.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](graphics/image_03_001.jpg)'
- en: The script generates a folder by the name `OUTPUT` in the path where the Java
    files of the application are present. The `OUTPUT` folder contains multiple text
    files, each one corresponding to a particular vulnerability. The individual text
    files pinpoint the location of vulnerable code pertaining to the vulnerability
    under discussion.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本会在应用程序的 Java 文件所在的路径生成一个名为`OUTPUT`的文件夹。`OUTPUT`文件夹包含多个文本文件，每个文件对应一个特定的漏洞。这些文本文件标明了与正在讨论的漏洞相关的易受攻击的代码位置。
- en: The combination of ScriptDroid and Insecure Bank gives a very nice view of various
    Android vulnerabilities; usually the same is not possible with live apps.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ScriptDroid 与 Insecure Bank 的结合为我们提供了一个非常好的视角，展示了各种 Android 漏洞；通常，实时应用程序无法做到这一点。
- en: 'Consider the following points, for instance:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下几点，例如：
- en: '`Weakencryption.txt` has listed down the instances of Base64 encoding used
    for passwords in the Insecure Bank application'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Weakencryption.txt`列出了 Insecure Bank 应用中用于密码的 Base64 编码实例。'
- en: '`Logging.txt` contains the list of insecure log functions used in the application'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Logging.txt`包含应用程序中使用的不安全日志函数列表。'
- en: '`SdcardStorage.txt` contains the code snippet pertaining to the definitions
    related to data storage in SD Cards'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SdcardStorage.txt`包含与 SD 卡中数据存储相关定义的代码片段。'
- en: Details like these from static analysis are eye-openers in letting us know of
    the vulnerabilities in our application, without even running the application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些来自静态分析的细节让我们了解到应用程序中的漏洞，甚至在未运行应用程序的情况下。
- en: There's more...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The current recipe used just ScriptDroid, but there are many other options available.
    You can either choose to write your own script or you may use one of the free
    or commercial tools. A few commercial tools have pioneered the static analysis
    approach over the years via their dedicated focus.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当前使用的配方仅限于 ScriptDroid，但还有许多其他选项可供选择。你可以选择编写自己的脚本，或者使用一些免费的或商业的工具。一些商业工具多年来通过专注于静态分析方法，已经在这一领域开创了先河。
- en: See also
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[https://github.com/dineshshetty/Android-InsecureBankv2](https://github.com/dineshshetty/Android-InsecureBankv2)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/dineshshetty/Android-InsecureBankv2](https://github.com/dineshshetty/Android-InsecureBankv2)'
- en: '*Auditing iOS application using static analysis*'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用静态分析审计 iOS 应用*'
- en: Auditing Android apps a using a dynamic analyzer
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态分析审计 Android 应用
- en: '**Dynamic analysis** is another technique applied in source code audits. Dynamic
    analysis is conducted in runtime. The application is run or simulated and the
    flaws or vulnerabilities are discovered while the application is running. Dynamic
    analysis can be tricky, especially in the case of mobile platforms. As opposed
    to static analysis, there are certain requirements in dynamic analysis, such as
    the analyzer environment needs to be runtime or a simulation of the real runtime.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态分析**是另一种用于源代码审计的技术。动态分析是在运行时进行的。应用程序被运行或模拟，并且在应用程序运行时发现缺陷或漏洞。动态分析可能会很棘手，特别是在移动平台上。与静态分析不同，动态分析有一些特定的要求，比如分析环境需要是运行时环境或真实运行时的模拟。'
- en: Dynamic analysis can be employed to find vulnerabilities in Android applications
    which are difficult to find via static analysis. A static analysis may let you
    know a password is going to be stored, but dynamic analysis reads the memory and
    reveals the password stored in runtime. Dynamic analysis can be helpful in tampering
    data in transmission during runtime that is, tampering with the amount in a transaction
    request being sent to the payment gateway. Some Android applications employ obfuscation
    to prevent attackers reading the code; Dynamic analysis changes the whole game
    in such cases, by revealing the hardcoded data being sent out in requests, which
    is otherwise not readable in static analysis.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析可以用来发现 Android 应用程序中的漏洞，这些漏洞通过静态分析是难以发现的。静态分析可能让你知道一个密码会被存储，但动态分析则读取内存并揭示运行时存储的密码。动态分析有助于在运行时篡改传输中的数据，例如篡改发送到支付网关的交易请求中的金额。一些
    Android 应用程序使用混淆技术来防止攻击者读取代码；在这种情况下，动态分析改变了整个游戏规则，它能够揭示在请求中发送的硬编码数据，而这些数据在静态分析中是无法读取的。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For conducting dynamic analysis of Android applications, we at least need one
    Android application and a dynamic code analyzer tool. Pick up any Android application
    of your choice and use any dynamic analyzer tool of your choice.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行 Android 应用程序的动态分析，至少需要一个 Android 应用程序和一个动态代码分析工具。选择任何你喜欢的 Android 应用程序，并使用你喜欢的任何动态分析工具。
- en: 'The dynamic analyzer tools can be classified under two categories:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析工具可以分为两类：
- en: The tools which run from computers and connect to an Android device or emulator
    (to conduct dynamic analysis)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从计算机上运行并连接到 Android 设备或模拟器的工具（用于进行动态分析）
- en: The tools that can run on the Android device itself
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在 Android 设备本身运行的工具
- en: For this recipe, we choose a tool belonging to the latter category.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们选择了属于后一类的工具。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps for conducting dynamic analysis:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤进行动态分析：
- en: Have an Android device with applications (to be analyzed dynamically) installed.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一台安装了应用程序（需要进行动态分析的）Android 设备。
- en: Go to the Play Store and download **Andrubis**. Andrubis is a tool from iSecLabs
    which runs on Android devices and conducts static, dynamic, and URL analysis on
    the installed applications. We will use it for dynamic analysis only in this recipe.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 Play 商店并下载 **Andrubis**。Andrubis 是 iSecLabs 提供的一款工具，可在 Android 设备上运行，对已安装的应用程序进行静态、动态和
    URL 分析。在本教程中，我们仅使用它进行动态分析。
- en: Open the Andrubis application on your Android device. It displays the applications
    installed on the Android device and analyzes these applications.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Android 设备上打开 Andrubis 应用程序。它会显示已安装的应用程序并分析这些应用程序。
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: Open the analysis of the application of your interest. Andrubis computes an
    overall malice score (out of 10) for the applications and gives the color icon
    in front of its main screen to reflect the vulnerable application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你感兴趣的应用程序的分析。Andrubis 会计算应用程序的总体恶意评分（满分为 10 分），并在主屏幕前显示颜色图标，以反映易受攻击的应用程序。
- en: 'We selected an orange colored application to make more sense with this recipe.
    This is how the application summary and score is shown in Andrubis:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了一个橙色的应用程序，以便与本教程更好地契合。下面是 Andrubis 中展示的应用程序摘要和评分：
- en: '![How it works...](graphics/image_03_002.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](graphics/image_03_002.jpg)'
- en: 'Let us navigate to the **Dynamic Analysis** tab and check the results:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导航到 **动态分析** 标签并查看结果：
- en: '![How it works...](graphics/image_03_003.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](graphics/image_03_003.jpg)'
- en: The results are interesting for this application. Notice that all the files
    going to be written by the application under dynamic analysis are listed down.
    In our case, one `preferences.xml` is located.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的结果很有意思。注意，在动态分析过程中，应用程序将写入的所有文件都列出。我们在这里找到一个名为 `preferences.xml` 的文件。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Though the fact that the application is going to create a preferences file could
    have been found in static analysis as well, additionally, dynamic analysis confirmed
    that such a file is indeed created. It also confirms that the code snippet found
    in static analysis about the creation of a preferences file is not a dormant code
    but a file that is going to be created. Further, go ahead and read the created
    file and find any sensitive data present there. Who knows, luck may strike and
    give you a key to hidden treasure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the first screen has a hyperlink, **View full report in browser**.
    Tap on it and notice that the detailed dynamic analysis is presented for your
    further analysis. This also lets you understand what the tool tried and what response
    it got. This is shown in the following screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](graphics/image_03_004.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current recipe used a dynamic analyzer belonging to the latter category.
    There are many other tools available in the former category. Since this is an
    Android platform, many of them are open source tools.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: DroidBox can be tried for dynamic analysis. It looks for file operations (read/write),
    network data traffic, SMS, permissions, broadcast receivers, and so on, among
    other checks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Hooker is another tool that can intercept and modify API calls initiated from
    the application. This is very useful in dynamic analysis. Try hooking and tampering
    with data in API calls.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://play.google.com/store/apps/details?id=org.iseclab.andrubis](https://play.google.com/store/apps/details?id=org.iseclab.andrubis)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://code.google.com/p/droidbox/](https://code.google.com/p/droidbox/)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/AndroidHooker/hooker](https://github.com/AndroidHooker/hooker)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Drozer to find vulnerabilities in Android applications
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drozer is a mobile security audit and attack framework, maintained by MWR InfoSecurity.
    It is a must-have tool in the tester's armory. Drozer (Android installed application)
    interacts with other Android applications via **IPC** (**Inter Process Communication**).
    It allows fingerprinting of application package-related information, its attack
    surface, and attempts to exploit those. Drozer is an attack framework and advanced
    level exploits can be conducted from it. We use Drozer to find vulnerabilities
    in our applications.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install Drozer by downloading it from [https://www.mwrinfosecurity.com/products/drozer/](https://www.mwrinfosecurity.com/products/drozer/)
    and follow the installation instructions mentioned in the user guide.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Install Drozer console agent and start a session as mentioned in the User Guide.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: If your installation is correct, you should get Drozer command prompt (`dz>`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: You should also have a few vulnerable applications as well to analyze. Here
    we chose OWASP GoatDroid application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every pentest starts with fingerprinting. Let us use Drozer for the same. The
    Drozer User Guide is very helpful for referring to the commands.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command can be used to obtain information about an Android application
    package:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令可用于获取关于 Android 应用程序包的信息：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We used the same to extract the information from the GoatDroid application
    and found the following results:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的方法从 GoatDroid 应用中提取信息，并得到了以下结果：
- en: '![How to do it...](graphics/image_03_005.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/image_03_005.jpg)'
- en: Notice that apart from the general information about the application, `User
    Permissions` are also listed by Drozer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了关于应用程序的一般信息，`User Permissions`（用户权限）也会被 Drozer 列出。
- en: Further, let us analyze the attack surface. Drozer's attack surface lists the
    exposed activities, broadcast receivers, content providers, and services. The
    in-genuinely exposed ones may be a critical security risk and may provide you
    access to privileged content.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步分析攻击面。Drozer 的攻击面列出了暴露的活动、广播接收器、内容提供者和服务。那些不应暴露的内容可能是严重的安全风险，并可能让你访问特权内容。
- en: 'Drozer has the following command to analyze the attack surface:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Drozer 具有以下命令来分析攻击面：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We used the same to obtain the attack surface of the Herd Financial application
    of GoatDroid and the results can be seen in the following screenshot. Notice that
    one Activity and one Content Provider are exposed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的方法获取了 GoatDroid 的 Herd Financial 应用的攻击面，结果可以在以下截图中看到。请注意，一个活动和一个内容提供者被暴露。
- en: 'We chose to attack the content provider to obtain the data stored locally.
    We used the following Drozer command to analyze the content provider of the same
    application:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择攻击内容提供者以获取本地存储的数据。我们使用以下 Drozer 命令分析相同应用的内容提供者：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This gave us the details of the exposed content provider, which we used in
    another Drozer command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们获得了暴露的内容提供者的详细信息，我们在另一个 Drozer 命令中使用了这些信息：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We could successfully query the content providers. Lastly, we would be interested
    in stealing the data stored by this content provider. This is possible via another
    Drozer command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功查询了内容提供者。最后，我们有兴趣窃取这个内容提供者存储的数据。这可以通过另一个 Drozer 命令实现：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The entire sequence of events is shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了整个事件的过程：
- en: '![How to do it...](graphics/image_03_006.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/image_03_006.jpg)'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: ADB is used to establish a connection between Drozer Python server (present
    on computer) and Drozer agent (`.apk` file installed in emulator or Android device).
    Drozer console is initialized to run the various commands we saw.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ADB 用于在 Drozer Python 服务器（位于计算机上）和 Drozer 代理（`.apk` 文件安装在模拟器或 Android 设备上）之间建立连接。Drozer
    控制台初始化后，可以运行我们看到的各种命令。
- en: Drozer agent utilizes the Android OS feature of IPC to take over the role of
    the target application and run the various commands as the original application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Drozer 代理利用 Android 操作系统的 IPC 特性，接管目标应用的角色，并作为原始应用运行各种命令。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Drozer not only allows users to obtain the attack surface and steal data via
    content providers or launch intent injection attacks, but it is way beyond that.
    It can be used to fuzz the application, cause local injection attacks by providing
    a way to inject payloads.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Drozer 不仅允许用户通过内容提供者获取攻击面并窃取数据，或发起意图注入攻击，它的功能远不止这些。它还可以用于对应用程序进行模糊测试，通过提供注入有效负载的方法来引发本地注入攻击。
- en: Drozer can also be used to run various in-built exploits and can be utilized
    to attack Android applications via custom-developed exploits. Further, it can
    also run in Infrastructure mode, allowing remote connections and remote attacks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Drozer 还可以用来运行各种内置的漏洞攻击，并且可以通过自定义开发的漏洞攻击 Android 应用程序。此外，它还可以在基础设施模式下运行，允许远程连接和远程攻击。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*Launching intent injection in Android*'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 Android 中发起意图注入*'
- en: '[https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf](https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf](https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf)'
- en: Auditing iOS application using static analysis
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态分析审核 iOS 应用程序
- en: Static analysis in source code reviews is an easier technique, and employing
    static string searches makes it convenient to use. Static analysis is conducted
    on the raw or decompiled source code or on the compiled (object) code, but the
    analysis is conducted outside of runtime. Usually, static analysis figures out
    vulnerable or insecure code patterns.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For conducting static analysis of iOS applications, we need at least one iOS
    application and a static code scanner. Pick up any iOS application of your choice
    and use any static analyzer tool of your choice.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: We will use `iOS-ScriptDroid`, which is a static analysis script, developed
    by Android security researcher, Dinesh Shetty.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep the decompressed iOS application filed and note the path of the folder
    containing the `.m` files.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an `iOS-ScriptDroid.bat` file by using the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go to the command prompt and navigate to the path where `iOS-ScriptDroid` is
    placed. Run the batch file and it prompts you to input the path of the application
    for which you wish to perform static analysis.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we arbitrarily chose an application and inputted the path of the
    implementation (`.m`) files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The script generates a folder by the name `OUTPUT` in the path where the `.m`
    files of the application are present. The `OUTPUT` folder contains multiple text
    files, each one corresponding to a particular vulnerability. The individual text
    files pinpoint the location of vulnerable code pertaining to the vulnerability
    under discussion.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The `iOS-ScriptDroid` gives first hand info of various iOS applications vulnerabilities
    present in the current applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: For instance, here are a few of them which are specific to the iOS platform.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '`BufferOverflow.txt` contains the usage of harmful functions when missing buffer
    limits such as `strcat`, `strcpy`, and so on are found in the application.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: URL Schemes, if implemented in an insecure manner, may result in access related
    vulnerabilities. Usage of URL schemes is listed in `URLSchemes.txt`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: These are sefuuseful vulnerability details to know in iOS applications via static
    analysis.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current recipe used just `iOS-ScriptDroid` but there are many other options
    available. You can either choose to write your own script or you may use one of
    the free or commercial tools available. A few commercial tools have pioneered
    the static analysis approach over the years via their dedicated focus.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Auditing Android apps using static analysis*'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing iOS application using a dynamic analyzer
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic analysis is the runtime analysis of the application. The application
    is run or simulated to discover the flaws during runtime. Dynamic analysis can
    be tricky, especially in the case of mobile platforms.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis is helpful in tampering data in transmission during runtime,
    for example, tampering with the amount in a transaction request being sent to
    a payment gateway. In applications that use custom encryption to prevent attackers
    reading the data, dynamic analysis is useful in revealing the encrypted data,
    which can be reverse-engineered.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析对于在运行时篡改传输中的数据非常有用，例如，篡改向支付网关发送的交易请求中的金额。在使用自定义加密以防止攻击者读取数据的应用程序中，动态分析有助于揭示被加密的数据，这些数据可以被逆向工程。
- en: Note that since iOS applications cannot be decompiled to the full extent, dynamic
    analysis becomes even more important in finding the sensitive data which could
    have been hardcoded.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于iOS应用无法完全反编译，因此动态分析在发现可能被硬编码的敏感数据时显得尤为重要。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For conducting dynamic analysis of iOS applications, we need at least one iOS
    application and a dynamic code analyzer tool. Pick up any iOS application of your
    choice and use any dynamic analyzer tool of your choice.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对iOS应用进行动态分析时，我们需要至少一个iOS应用和一个动态代码分析工具。选择任意iOS应用，并使用任何你喜欢的动态分析工具。
- en: In this recipe, let us use the open source tool **Snoop-it**. We will use an
    iOS app that locks files which can only be opened using PIN, pattern, and a secret
    question and answer to unlock and view the file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作中，我们将使用开源工具**Snoop-it**。我们将使用一个iOS应用，该应用通过PIN码、图案和秘密问题与答案来锁定文件，只有解锁后才能查看文件。
- en: Let us see if we can analyze this app and find a security flaw in it using Snoop-it.
    Please note that Snoop-it only works on jailbroken devices.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看能否分析这个应用并使用Snoop-it找到其中的安全漏洞。请注意，Snoop-it只适用于越狱设备。
- en: To install Snoop-it on your iDevice, visit [https://code.google.com/p/snoop-it/wiki/GettingStarted?tm=6](https://code.google.com/p/snoop-it/wiki/GettingStarted?tm=6)
    .
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的iDevice上安装Snoop-it，请访问[https://code.google.com/p/snoop-it/wiki/GettingStarted?tm=6](https://code.google.com/p/snoop-it/wiki/GettingStarted?tm=6)。
- en: We have downloaded **Locker Lite** from the App Store onto our device, for analysis.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从App Store下载了**Locker Lite**并安装到我们的设备上进行分析。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to conduct dynamic analysis on iOS applications:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来对iOS应用进行动态分析：
- en: Open the Snoop-it app by tapping on its icon.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Snoop-it应用图标打开它。
- en: Navigate to **Settings**. Here you will see the URL through which the interface
    can be accessed from your machine:![How to do it...](graphics/image_03_007.jpg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**设置**。在这里你将看到可以从你的设备访问界面的URL：![如何操作...](graphics/image_03_007.jpg)
- en: Please note the URL, for we will be using it soon. We have disabled authentication
    for our ease.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意这个URL，因为我们稍后会使用它。为了方便，我们已禁用认证。
- en: Now, on the iDevice, tap on **Applications** | **Select App Store Apps** and
    select the **Locker** app:![How to do it...](graphics/image_03_008.jpg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在iDevice上，点击**应用程序** | **选择App Store应用**，然后选择**Locker**应用：![如何操作...](graphics/image_03_008.jpg)
- en: Press the home button, and open the Locker app. Note that on entering the wrong
    PIN, we do not get further access:![How to do it...](graphics/image_03_009.jpg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下主屏按钮，打开Locker应用。注意，如果输入错误的PIN码，我们将无法继续访问：![如何操作...](graphics/image_03_009.jpg)
- en: Making sure the workstation and iDevice are on the same network, open the previously
    noted URL in any browser. This is how the interface will look:![How to do it...](graphics/image_03_010.jpg)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保工作站和iDevice处于同一网络，打开先前记下的URL，并在任何浏览器中查看。界面将呈现如下：![如何操作...](graphics/image_03_010.jpg)
- en: Click on the **Objective-C Classes** link under **Analysis** in the left-hand
    panel:![How to do it...](graphics/image_03_011.jpg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧面板中的**分析**下的**Objective-C 类**链接：![如何操作...](graphics/image_03_011.jpg)
- en: Now, click on `SM_LoginManagerController`. Class information gets loaded in
    the panel to the right of it.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击`SM_LoginManagerController`。类信息会加载到右侧面板中。
- en: Navigate down until you see `-(void) unlockWasSuccessful` and click on the radio
    button preceding it:![How to do it...](graphics/image_03_012.jpg)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下导航，直到看到`-(void) unlockWasSuccessful`，然后点击前面的单选按钮：![如何操作...](graphics/image_03_012.jpg)
- en: This method has now been selected.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法现在已被选中。
- en: Next, click on the **Setup and invoke** button on the top-right of the panel.
    In the window that appears, click on the **Invoke Method** button at the bottom:![How
    to do it...](graphics/image_03_013.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击面板右上角的**设置并调用**按钮。在出现的窗口中，点击底部的**调用方法**按钮：![如何操作...](graphics/image_03_013.jpg)
- en: As soon as we click on the button, we notice that the authentication has been
    bypassed, and we can view our locked file successfully.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Snoop-it loads all classes that are in the app, and indicates the ones that
    are currently operational with a green color. Since we want to bypass the current
    login screen, and load directly into the main page, we look for `UIViewController`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Inside `UIViewController`, we see `SM_LoginManagerController`, which could contain
    methods relevant to authentication. On observing the class, we see various methods
    such as `numberLoginSucceed`, `patternLoginSucceed`, and many others.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The app calls the `unlockWasSuccessful` method when a PIN code is entered successfully.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: So, when we invoke this method from our machine and the function is called directly,
    the app loads the main page successfully.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The current recipe used just one dynamic analyzer but other options and tools
    can also be employed. There are many challenges in doing dynamic analysis of iOS
    applications. You may like to use multiple tools and not just rely on one to overcome
    the challenges.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://code.google.com/p/snoop-it/](https://code.google.com/p/snoop-it/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Auditing Android apps using a dynamic analyzer*'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining iOS App Data storage and Keychain security vulnerabilities
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keychain in iOS is an encrypted SQLite database that uses a 128-bit AES algorithm
    to hold identities and passwords.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: On any iOS device, the Keychain SQLite database is used to store user credentials
    such as usernames, passwords, encryption keys, certificates, and so on.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Developers use this service API to instruct the operating system to store sensitive
    data securely, rather than using a less secure alternative storage mechanism such
    as a property list file or a configuration file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will be analyzing Keychain dump to discover stored credentials.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Please follow the given steps to prepare for Keychain dump analysis:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Jailbreak the iPhone or iPad.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the SSH server is running on the device (default after jailbreak).
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `Keychain_dumper` binary from [https://github.com/ptoomey3/Keychain-Dumper](https://github.com/ptoomey3/Keychain-Dumper)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the iPhone and the computer to the same Wi-Fi network.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the computer, run SSH into the iPhone by typing the iPhone IP address, username
    as `root`, and password as `alpine`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to examine security vulnerabilities in iOS:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy `keychain_dumper` into the iPhone or iPad by issuing the following command:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Alternatively, Windows WinSCP can be used to do the same:![How to do it...](graphics/image_03_014.jpg)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the binary has been copied, ensure the `keychain-2.db` has read access:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is shown in the following screenshot:'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_03_015.jpg)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Give executable right to binary:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we simply run `keychain_dumper`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![How to do it...](graphics/image_03_016.jpg)'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'This command will dump all keychain information, which will contain all the
    generic and Internet passwords stored in the keychain:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_03_017.jpg)'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keychain in an iOS device is used to securely store sensitive information such
    as credentials, such as usernames, passwords, authentication tokens for different
    applications, and so on, along with connectivity (Wi-Fi/VPN) credentials and so
    on. It is located on iOS devices as an encrypted SQLite database file located
    at `/private/var/Keychains/keychain-2.db`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Insecurity arises when application developers use this feature of the operating
    system to store credentials rather than storing it themselves in `NSUserDefaults`,
    `.plist` files, and so on. To provide users the ease of not having to log in every
    time and hence saving the credentials in the device itself, the keychain information
    for every app is stored outside of its sandbox.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This analysis can also be performed for specific apps dynamically, using tools
    such as Snoop-it. Follow the steps to hook Snoop-it to the target app, click on
    `Keychain Values`, and analyze the attributes to see its values reveal in the
    Keychain.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: More will be discussed in further recipes.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Finding vulnerabilities in WAP-based mobile apps
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WAP-based mobile applications are mobile applications or websites that run on
    mobile browsers. Most organizations create a lightweight version of their complex
    websites to be able to run easily and appropriately in mobile browsers. For example,
    a hypothetical company called `ABCXYZ` may have their main website at `www.abcxyz.com`,
    while their mobile website takes the form `m.abcxyz.com`. Note that the mobile
    website (or WAP apps) are separate from their installable application form, such
    as `.apk` on Android.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Since mobile websites run on browsers, it is very logical to say that most of
    the vulnerabilities applicable to web applications are applicable to WAP apps
    as well. However, there are caveats to this. Exploitability and risk ratings may
    not be the same. Moreover, not all attacks may be directly applied or conducted.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, make sure to be ready with the following set of tools (in
    the case of Android):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: ADB
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WinSCP
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putty
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rooted Android mobile
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH proxy application installed on Android phone
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us see the common WAP application vulnerabilities. While discussing these,
    we will limit ourselves to mobile browsers only:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**Browser cache**: Android browsers store cache in two different parts—content
    cache and component cache. Content cache may contain basic frontend components
    such as HTML, CSS, or JavaScript. Component cache contains sensitive data like
    the details to be populated once content cache is loaded. You have to locate the
    browser cache folder and find sensitive data in it.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browser memory**: Browser memory refers to the location used by browsers
    to store the data. Memory is usually long-term storage, while cache is short-term.
    Browse through the browser memory space for various files such as `.db`, `.xml`,
    `.txt`, and so on. Check all these files for the presence of sensitive data.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browser history**: Browser history contains the list of the URLs browsed
    by the user. These URLs in GET request format contain parameters. Again, our goal
    is to locate a URL with sensitive data for our WAP application.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cookies**: Cookies are mechanisms for websites to keep track of user sessions.
    Cookies are stored locally in devices. Following are the security concerns with
    respect to cookie usage:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes a cookie contains sensitive information
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookie attributes, if weak, may make the application security weak
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookie stealing may lead to a session hijack
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Browser Cache**:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the steps that need to be followed with browser cache:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Android browser cache can be found at this location: `/data/data/com.android.browser/cache/webviewcache/`.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use either ADB to pull the data from `webviewcache`, or use `WinSCP/Putty`
    and connect to SSH application in rooted Android phones.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either way, you will land up at the `webviewcache` folder and find arbitrarily
    named files. Refer to the highlighted section in the following screenshot:![How
    to do it...](graphics/image_03_018.jpg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the extension of arbitrarily named files to `.jpg` and you will be able
    to view the cache in screenshot format. Search through all files for sensitive
    data pertaining to the WAP app you are searching for.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Browser Memory**:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Like an Android application, browser also has a memory space under the `/data/data`
    folder by the name `com.android.browser` (default browser). Here is how a typical
    browser memory space looks:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](graphics/image_03_019.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: Make sure you traverse through all the folders to get the useful sensitive data
    in the context of the WAP application you are looking for.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**Browser history**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Go to browser, locate options, navigate to **History**, and find the URLs present
    there.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**Cookies**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The files containing cookie values can be found at `/data/data/com.android.browser/databases/webview.db`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: These DB files can be opened with the SQLite Browser tool and cookies can be
    obtained.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the primary vulnerabilities described here mainly concerned with
    browser usage, all other web application vulnerabilities which are related to
    or exploited from or within a browser are applicable and need to be tested:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site scripting, a result of a browser executing unsanitized harmful scripts
    reflected by the servers is very valid for WAP applications.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The autocomplete attribute not turned to off may result in sensitive data remembered
    by the browser for returning users. This again is a source of data leakage.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser thumbnails and image buffer are other sources to look for data.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Above all, all the vulnerabilities in web applications, which may not relate
    to browser usage, apply. These include **OWASP Top 10** vulnerabilities such as
    SQL injection attacks, broken authentication and session management, and so on.
    Business logic validation is another important check to bypass. All these are
    possible by setting a proxy to the browser and playing around with the mobile
    traffic (we provide a different recipe for the same in a later chapter).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The discussion of this recipe has been around Android, but all the discussion
    is fully applicable to an iOS platform when testing WAP applications. Approach,
    steps to test, and the locations would vary, but all vulnerabilities still apply.
    You may want to try out iExplorer and plist editor tools when working with an
    iPhone or iPad.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://resources.infosecinstitute.com/browser-based-vulnerabilities-in-web-applications/](http://resources.infosecinstitute.com/browser-based-vulnerabilities-in-web-applications/)'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding client-side injection
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client-side injection is a new dimension to the mobile threat landscape. Client
    side injection (also known as local injection) is a result of the injection of
    malicious payloads to local storage to reveal data not by the usual workflow of
    the mobile application. If `'or'1'='1` is injected in a mobile application on
    search parameter, where the search functionality is built to search in the local
    SQLite DB file, this results in revealing all data stored in the corresponding
    table of SQLite DB; client side SQL injection is successful.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the payload did not to go the database on the server side (which
    possibly can be Oracle or MSSQL) but it did go to the local database (SQLite)
    in the mobile. Since the injection point and injectable target are local (that
    is, mobile), the attack is called a **client side injection**.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get ready to find client side injection, have a few mobile applications ready
    to be audited and have a bunch of tools used in many other recipes throughout
    this book.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Note that client side injection is not easy to find on account of the complexities
    involved; many a time you will have to fine-tune your approach as per the successful
    first signs.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prerequisite to the existence of client side injection vulnerability in
    mobile apps is the presence of a local storage and an application feature which
    queries the local storage. For the convenience of the first discussion, let us
    learn client side SQL injection, which is fairly easy to learn as users know very
    well SQL Injection in web apps.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Let us take the case of a mobile banking application which stores the branch
    details in a local SQLite database. The application provides a search feature
    to users wishing to search a branch. Now, if a person types in the city as Mumbai,
    the `city` parameter is populated with the value `Mumbai` and the same is dynamically
    added to the SQLite query. The query builds and retrieves the branch list for
    Mumbai city. (Usually, purely local features are provided for faster user experience
    and network bandwidth conservation.)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Now if a user is able to inject harmful payloads into the city parameter, such
    as a wildcard character or a SQLite payload to the drop table, and the payloads
    execute revealing all the details (in the case of a wildcard) or the payload drops
    the table from the DB (in the case of a drop table payload) then you have successfully
    exploited client side SQL injection.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Another type of client side injection, presented in OWASP Mobile TOP 10 release,
    is local **cross-site scripting** (**XSS**). Refer to slide number 22 of the original
    OWASP PowerPoint presentation here: [http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks](http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks)
    . They referred to it as Garden Variety XSS and presented a code snippet, wherein
    SMS text was accepted locally and printed at UI. If a script was inputted in SMS
    text, it would result in local XSS (JavaScript Injection).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a similar fashion, HTML Injection is also possible. If an HTML file contained
    in the application local storage can be compromised to contain malicious code
    and the application has a feature which loads or executes this HTML file, HTML
    injection is possible locally.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: A variant of the same may result in **Local File Inclusion** (**LFI**) attacks.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: If data is stored in the form of XML files in the mobile, local XML Injection
    can also be attempted.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: There could be more variants of these attacks possible. Finding client-side
    injection is quite difficult and time consuming. It may need to employ both static
    and dynamic analysis approaches. Most scanners also do not support discovery of
    Client Side Injection.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Another dimension to Client Side Injection is the impact, which is judged to
    be low in most cases. There is a strong counter argument to this vulnerability.
    If the entire local storage can be obtained easily in Android, then why do we
    need to conduct Client Side Injection? I agree to this argument in most cases,
    as the entire SQLite or XML file from the phone can be stolen, why spend time
    searching a variable that accepts a wildcard to reveal the data from the SQLite
    or XML file?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: However, you should still look out for this vulnerability, as HTML injection
    or LFI kind of attacks have malware-corrupted file insertion possibility and hence
    the impactful attack. Also, there are platforms such as iOS where sometimes, stealing
    the local storage is very difficult. In such cases, client side injection may
    come in handy.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/index.php/Mobile_Top_10_2014-M7](https://www.owasp.org/index.php/Mobile_Top_10_2014-M7)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks](http://www.slideshare.net/JackMannino/owasp-top-10-mobile-risks)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insecure encryption in mobile apps
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encryption is one of the misused terms in information security. Some people
    confuse it with hashing, while others may implement encoding and call it encryption.
    symmetric key and asymmetric key are two types of encryption schemes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Mobile applications implement encryption to protect sensitive data in storage
    and in transit. While doing audits, your goal should be to uncover weak encryption
    implementation or the so-called encoding or other weaker forms, which are implemented
    in places where a proper encryption should have been implemented. Try to circumvent
    the encryption implemented in the mobile application under audit.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be ready with a few mobile applications and tools such as ADB and other file
    and memory readers, decompiler and decoding tools, and so on.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are multiple types of faulty implementation of encryption in mobile applications.
    There are different ways to discover each of them:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Encoding (instead of encryption): Many a time, mobile app developers simply
    implement Base64 or URL encoding in applications (an example of security by obscurity).'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such encoding can be discovered by simply doing static analysis. You can use
    the script discussed in the first recipe of this chapter for finding out such
    encoding algorithms.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Dynamic analysis will help you obtain the locally stored data in encoded format.
    Decoders for these known encoding algorithms are available freely. Using any of
    those, you will be able to uncover the original value. Thus, such implementation
    is not a substitute for encryption.
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Serialization (instead of encryption): Another variation of faulty implementation
    is serialization. Serialization is the process of conversion of data objects to
    byte stream. The reverse process, deserialization, is also very simple and the
    original data can be obtained easily.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static Analysis may help reveal implementations using serialization.
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Obfuscation (instead of encryption): Obfuscation also suffers from similar
    problems and the obfuscated values can be deobfuscated.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hashing (instead of encryption): Hashing is a one-way process using a standard
    complex algorithm. These one-way hashes suffer from a major problem in that they
    can be replayed (without needing to recover the original data). Also, rainbow
    tables can be used to crack the hashes.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like other techniques described previously, hashing usage in mobile applications
    can also be discovered via static analysis. Dynamic analysis may additionally
    be employed to reveal the one-way hashes stored locally.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand the insecure encryption in mobile applications, let us take a
    live case, which we observed.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: An example of weak custom implementation
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While testing a live mobile banking application, me and my colleagues came
    across a scenario where a `userid` and `mpin` combination was sent by a custom
    encoding logic. The encoding logic here was based on a predefined character by
    character replacement by another character, as per an in-built mapping. For example:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '`2` is replaced by `4`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` is replaced by `3`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` is replaced by `2`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`7` is replaced by `=`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a` is replaced by `R`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A` is replaced by `N`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can notice, there is no logic to the replacement. Until you uncover or
    decipher the whole in-built mapping, you won't succeed. A simple technique is
    to supply all possible characters one-by-one and watch out for the response. Let's
    input `userid` and `PIN` as `222222` and `2222` and notice the converted `userid`
    and `PIN` are `444444` and `4444` respectively, as per the mapping above. Go ahead
    and keep changing the inputs, you will create a full mapping as is used in the
    application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Now steal the user's encoded data and apply the created mapping, thereby uncovering
    the original data. This whole approach is nicely described in the article mentioned
    under the *See also* section of this recipe.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: This is a custom example of faulty implementation pertaining to encryption.
    Such kinds of faults are often difficult to find in static analysis, especially
    in the case of difficult to reverse apps such as iOS applications. The possibility
    of automated dynamic analysis discovering this is also difficult. Manual testing
    and analysis stands, along with dynamic or automated analysis, a better chance
    of uncovering such custom implementations.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, I would share another application we came across. This one used proper
    encryption. The encryption algorithm was a well known secure algorithm and the
    key was strong. Still, the whole encryption process can be reversed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'The application had two mistakes; we combined both of them to break the encryption:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The application code had the standard encryption algorithm in the APK bundle.
    Not even obfuscation was used to protect the names at least. We used the simple
    process of APK to DEX to JAR conversion to uncover the algorithm details.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application had stored the strong encryption key in the local XML file under
    the `/data/data` folder of the Android device. We used adb to read this xml file
    and hence obtained the encryption key.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: According to Kerckhoff's principle, the security of a cryptosystem should depend
    solely on the secrecy of the key and the private randomizer. This is how all encryption
    algorithms are implemented. The key is the secret, not the algorithm.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: In our scenario, we could obtain the key and know the name of the encryption
    algorithm. This is enough to break the strong encryption implementation.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[http://www.paladion.net/index.php/mobile-phone-data-encryption-why-is-it-necessary/](http://www.paladion.net/index.php/mobile-phone-data-encryption-why-is-it-necessary/)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering data leakage sources
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data leakage risk worries organizations across the globe and people have been
    implementing solutions to prevent data leakage. In the case of mobile applications,
    first we have to think what could be the sources or channels for data leakage
    possibility. Once this is clear, devise or adopt a technique to uncover each of
    them.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in other recipes, here also you need bunch of applications (to be analyzed),
    an Android device or emulator, ADB, DEX to JAR converter, Java decompilers, Winrar,
    or Winzip.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To identify the data leakage sources, list down all possible sources you can
    think of for the mobile application under audit. In general, all mobile applications
    have the following channels of potential data leakage:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Files stored locally
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client side source code
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile device logs
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web caches
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Console messages
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keystrokes
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensitive data sent over HTTP
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to uncover the data leakage vulnerability at these potential
    channels. Let us see the six previously identified common channels:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '**Files stored locally**: By this time, readers are very familiar with this.
    The data is stored locally in files like shared preferences, xml files, SQLite
    DB, and other files.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Android, these are located inside the application folder under `/data/data`
    directory and can be read using tools such as ADB.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In iOS, tools such as iExplorer or SSH can be used to read the application folder.
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Client side source code**: Mobile application source code is present locally
    in the mobile device itself. The source code in applications has been hardcoding
    data, and a common mistake is hardcoding sensitive data (either knowingly or unknowingly).'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the field, we came across an application which had hardcoded the connection
    key to the connected PoS terminal. Hardcoded formulas to calculate a certain figure,
    which should have ideally been present in the server-side code, was found in the
    mobile app. Database instance names and credentials are also a possibility where
    the mobile app directly connects to a server datastore.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In Android, the source code is quite easy to decompile via a two-step process—APK
    to DEX and DEX to JAR conversion.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In iOS, the source code of header files can be decompiled up to a certain level
    using tools such as classdump-z or otool.
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the raw source code is available, a static string search can be employed
    to discover sensitive data in the code.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Mobile device logs**: All devices create local logs to store crash and other
    information, which can be used to debug or analyze a security violation. A poor
    coding may put sensitive data in local logs and hence data can be leaked from
    here as well.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Android ADB command `adb logcat` can be used to read the logs on Android devices.
    If you use the same ADB command for the Vulnerable Bank application, you will
    notice the user credentials in the logs as shown in the following screenshot:'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How it works...](graphics/image_03_020.jpg)'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Web caches**: Web caches may also contain the sensitive data related to web
    components used in mobile apps. We discussed how to discover this in the WAP recipe
    in this chapter previously.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Console messages**: Console messages are used by developers to print messages
    to the console while application development and debugging is in progress. Console
    messages, if not turned off while launching the application (GO LIVE), may be
    another source of data leakage. Console messages can be checked by running the
    application in debug mode.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keystrokes**: Certain mobile platforms have been known to cache key strokes.
    A malware or key stroke logger may take advantage and steal a user''s key strokes,
    hence making it another data leakage source. Malware analysis needs to be performed
    to uncover embedded or pre-shipped malware or keystroke loggers with the application.
    Dynamic analysis also helps.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sensitive data sent over HTTP**: Applications either send sensitive data
    over HTTP or use a weak implementation of SSL. In either case, sensitive data
    leakage is possible.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of HTTP can be found via static analysis to search for HTTP strings. Dynamic
    analysis to capture the packets at runtime also reveals whether traffic is over
    HTTP or HTTPS.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: There are various SSL-related weak implementation and downgrade attacks, which
    make data vulnerable to sniffing and hence data leakage.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data leakage sources can be vast and listing all of them does not seem possible.
    Sometimes there are applications or platform-specific data leakage sources, which
    may call for a different kind of analysis.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Intent injection can be used to fire intents to access privileged contents.
    Such intents may steal protected data such as the personal information of all
    the patients in a hospital (under HIPPA compliance).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: iOS screenshot backgrounding issues, where iOS applications store screenshots
    with populated user input data, on the iPhone or iPAD when the application enters
    background. Imagine such screenshots containing a user's credit card details,
    CCV, expiry date, and so on, are found in an application under PCI-DSS compliance.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Malwares give a totally different angle to data leakage. Note that data leakage
    is a very big risk organizations are tackling today. It is not just financial
    loss; losses may be intangible, such as reputation damage, or compliance or regulatory
    violations. Hence, it makes it very important to identify the maximum possible
    data leakage sources in the application and rectify the potential leakages.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/index.php/Mobile_Top_10_2014-M4](https://www.owasp.org/index.php/Mobile_Top_10_2014-M4)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Launching intent injection in Android*'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other application-based attacks in mobile devices
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about application-based attacks, **OWASP TOP 10** risks are the
    very first things that strike. OWASP ( [www.owasp.org](http://www.owasp.org) )
    has a dedicated project to mobile security, which releases **Mobile Top 10**.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'OWASP gathers data from industry experts and ranks the top 10 risks every three
    years. It is a very good knowledge base for mobile application security. Here
    is the latest Mobile Top 10 released in the year 2014:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'M1: Weak Server Side Controls'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M2: Insecure Data Storage'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M3: Insufficient Transport Layer Protection'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M4: Unintended Data Leakage'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M5: Poor Authorization and Authentication'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M6: Broken Cryptography'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M7: Client Side Injection'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M8: Security Decisions via Untrusted Inputs'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M9: Improper Session Handling'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M10: Lack of Binary Protections'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have a few applications ready to be analyzed, use the same set of tools we have
    been discussing till now, and refer to the  *Setting up the Android pentesting
    environment* and *Setting up the iOS pentesting environment* recipes in [Chapter
    1](ch01.html "Chapter 1.  Introduction to Mobile Security"), *Introduction to
    Mobile Security*.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we restrict ourselves to other application attacks. The attacks
    which we have not covered till now in this book are:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'M1: Weak Server Side Controls'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M5: Poor Authorization and Authentication'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M8: Security Decisions via Untrusted Inputs'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'M9: Improper Session Handling'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.html "Chapter 5. Working with Other Platforms"), *Working
    with Other Platforms*, M1 is covered in a detailed manner and M5 and M9, which
    are mostly server-side issues are also discussed in it.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, let us discuss client-side or mobile-side issues for M5, M8, and
    M9.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'M5: Poor Authorization and Authentication'
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A few common scenarios which can be attacked are:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Authentication implemented at device level (for example, PIN stored locally)
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication bound on poor parameters (such as UDID or IMEI numbers)
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization parameter responsible for access to protected application menus
    is stored locally
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can be attacked by reading data using ADB, decompiling the applications,
    and conducting static analysis on the same or by doing dynamic analysis on the
    outgoing traffic.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'M8: Security Decisions via Untrusted Inputs'
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This one talks about IPC. IPC entry points for applications to communicate to
    one other, such as Intents in Android or URL schemes in iOS, are vulnerable. If
    the origination source is not validated, the application can be attacked.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Malicious intents can be fired to bypass authorization or steal data. Let us
    discuss this in further detail in the next recipe.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: URL schemes are a way for applications to specify the launch of certain components.
    For example, the mailto scheme in iOS is used to create a new e-mail. If the applications
    fail to specify the acceptable sources, any malicious application will be able
    to send a mailto scheme to the victim application and create new e-mails.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'M9: Improper Session Handling'
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From a purely mobile device perspective, session tokens stored in `.db` files
    or `oauth` tokens, or strings granting access stored in weakly protected files,
    are vulnerable. These can be obtained by reading the local data folder using ADB.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/index.php/P;rojects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks](https://www.owasp.org/index.php/P;rojects/OWASP_Mobile_Security_Project_-_Top_Ten_Mobile_Risks)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching intent injection in Android
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android uses intents to request action from another application component. A
    common communication is passing Intent to start a service. We will exploit this
    fact via an **intent injection attack**.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: An intent injection attack works by injecting intent into the application component
    to perform a task that is usually not allowed by the application workflow. For
    example, if the Android application has a login activity which, post successful
    authentication, allows you access to protected data via another activity. Now
    if an attacker can invoke the internal activity to access protected data by passing
    an Intent, it would be an Intent Injection attack.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install Drozer by downloading it from [https://www.mwrinfosecurity.com/products/drozer/](https://www.mwrinfosecurity.com/products/drozer/)
    and following the installation instructions mentioned in the User Guide.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Install Drozer Console Agent and start a session as mentioned in the User Guide.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: If your installation is correct, you should get a Drozer command prompt (`dz>`).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should also have a few vulnerable applications to analyze. Here we chose
    the OWASP GoatDroid application:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Start the OWASP GoatDroid Fourgoats application in emulator.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse the application to develop understanding. Note that you are required
    to authenticate by providing a username and password, and post-authentication
    you can access profile and other pages. Here is the pre-login screen you get:![How
    to do it...](graphics/image_03_021.jpg)
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us now use Drozer to analyze the activities of the Fourgoats application.
    The following Drozer command is helpful:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Drozer detects four activities with null permission. Out of these four, `ViewCheckin`
    and `ViewProfile` are post-login activities.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use Drozer to access these two activities directly, via the following command:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We chose to access `ViewProfile` activity and the entire sequence of activities
    is shown in the following screenshot:![How to do it...](graphics/image_03_022.jpg)
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drozer performs some actions and the protected user profile opens up in the
    emulator, as shown here:![How to do it...](graphics/image_03_023.jpg)
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drozer passed an Intent in the background to invoke the post-login activity
    `ViewProfile`. This resulted in `ViewProfile` activity performing an action resulting
    in display of profile screen. This way, an intent injection attack can be performed
    using Drozer framework.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android uses intents also for starting a service or delivering a broadcast.
    Intent injection attacks can be performed on services and broadcast receivers.
    A Drozer framework can also be used to launch attacks on the app components. Attackers
    may write their own attack scripts or use different frameworks to launch this
    attack.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using Drozer to find vulnerabilities in Android applications*'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf](https://www.mwrinfosecurity.com/system/assets/937/original/mwri_drozer-user-guide_2015-03-23.pdf)'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.eecs.berkeley.edu/~daw/papers/intents-mobisys11.pdf](https://www.eecs.berkeley.edu/~daw/papers/intents-mobisys11.pdf)'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
