<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Attacking Mobile Application Traffic"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Attacking Mobile Application Traffic</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up the wireless pentesting lab for mobile devices</li><li class="listitem" style="list-style-type: disc">Configuring traffic interception with Android</li><li class="listitem" style="list-style-type: disc">Intercepting traffic using Burp Suite and Wireshark</li><li class="listitem" style="list-style-type: disc">Using MITM proxy to modify and attack</li><li class="listitem" style="list-style-type: disc">Configuring traffic interception with iOS</li><li class="listitem" style="list-style-type: disc">Analyzing traffic and extracting sensitive information from iOS App traffic</li><li class="listitem" style="list-style-type: disc">WebKit attacks on mobile applications</li><li class="listitem" style="list-style-type: disc">Performing SSL traffic interception by certificate manipulation</li><li class="listitem" style="list-style-type: disc">Using a mobile configuration profile to set up a VPN and intercept traffic in iOS devices</li><li class="listitem" style="list-style-type: disc">Bypassing SSL certificate validation in Android and iOS</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Introduction</h1></div></div></div><p>Mobile application architecture involves communication between an application running on mobile devices (<code class="literal">.apk</code>, <code class="literal">.ipa</code>, and so on) and the server-side application component, where the business logic resides. This communication is over various channels like HTTP, GPRS, USSD, SMS, and so on. Communication channels are open for attackers, and so, the communication security or the security for data in transit becomes important.</p><p>This chapter focuses on attacking the mobile application traffic. For the sake of simplicity, we selected the HTTP communication layer in the recipes that follow. Sensitive mobile applications have implemented SSL for implementing confidentiality, but we will learn in the recipes that follow that the SSL traffic can be attacked too.</p></div></div>
<div class="section" title="Setting up the wireless pentesting lab for mobile devices"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Setting up the wireless pentesting lab for mobile devices</h1></div></div></div><p>Let us start with setting up a lab for wireless pentesting of mobile devices. To be able to sniff traffic originating from mobile devices, we need to see how mobile applications communicate, that is, what is the communication channel? How do HTTP or HTTPS requests flow out of mobile?</p><p>Mobile application HTTP/HTTPS traffic flows via GPRS or a Wi-Fi channel. With either channel we need to set up a lab to sniff over the air. GPRS sniffing requires a specific set of hardware and various black hat techniques around it are available to do the rest. Be careful with it, GPRS (telecom) traffic interception is illegal in some countries. We will focus on lab setup for a Wi-Fi channel.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec127"/>Getting ready</h2></div></div></div><p>We need a Wi-Fi network (wireless access point connected to the Internet). We need mobile device(s) running the target applications, whose traffic will be sniffed. We also need a laptop (or computer), with any proxy tool installed on it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Note that both the mobile device and laptop should have wireless cards; they should be able to connect to the Wi-Fi network and participate in the HTTP communication.</p></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec128"/>How to do it...</h2></div></div></div><p>Perform the following steps to set up the wireless pentesting lab:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Set up the wireless network and check to make sure that the Wi-Fi network is broadcasting and the SSID is available to connect various Wi-Fi enabled devices to it.</li><li class="listitem">Connect your mobile device to the Wi-Fi network.</li><li class="listitem">Browse certain applications to verify that the application communication works.</li><li class="listitem">Now, install a web proxy tool like Burp Suite or Fiddler in a laptop. Connect this laptop also to the same Wi-Fi network. This setup should look like as shown in the following diagram:<p>
</p><div class="mediaobject"><img src="graphics/image_04_001.jpg" alt="How to do it..."/></div><p>
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec129"/>How it works...</h2></div></div></div><p>Usual communication from mobile applications would traverse the path: <span class="strong"><strong>Mobile</strong></span> | <span class="strong"><strong>Wireless Access Point</strong></span> | <span class="strong"><strong>Server</strong></span> on the <span class="strong"><strong>Internet</strong></span>. In the following diagram, this is the path <code class="literal">1</code> | <code class="literal">4</code>:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_002.jpg" alt="How it works..."/></div><p>
</p><p>The wireless   pentest lab is designed to insert steps <span class="strong"><strong>2</strong></span> and <span class="strong"><strong>3</strong></span>, in between the usual communication path of <span class="strong"><strong>1</strong></span> to <span class="strong"><strong>4</strong></span> (please refer to the preceding diagram for steps).</p><p>Mobile devices are configured to set a network proxy for the Wi-Fi network, so we forced the traffic to take the step <span class="strong"><strong>2</strong></span> route. Now we are running a proxy tool on the proxy machine; this proxy tool is capable of viewing and editing the mobile application traffic before forwarding it via step <span class="strong"><strong>3</strong></span> to the wireless access point. Thereafter, routine step <span class="strong"><strong>4</strong></span> of communication to the server happens.</p><p>This way, the wireless lab is set up for a pentest environment. Here, the mobile application traffic can be tampered to bypass business logic. Even an SSL application's traffic can be modified this way. We will see this in the recipes that follow.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec130"/>There's more...</h2></div></div></div><p>An alternative to using mobile phones is to use emulators. When using emulators, lab requirements are further simplified. The same machine can run emulators and proxy tools and edit the traffic before it reaches the server. So, having emulators, ADB, and proxy tools in the same laptop is also an essential requirement of the mobile wireless pentest lab. However, please note that for some production applications, it is not possible to test in emulators. We have seen the SMS activation step as a reason in banking apps for not being able to work the mobile app in emulators. The same can be worked around with cooperation from application developers to bypass such steps. When doing a black-box pentest, such an option is not available.</p><p>In a specific case, we came across a mobile application which was tied to a specific telecom 3G network and did not work on Wi-Fi or another operator's 3G network.</p><p>This requires a slightly different laboratory. In the preceding diagram, we replaced the wireless access point with a 3G and Wi-Fi-enabled tab. This tab was used to create a hotspot, thereby providing the wireless network, and final communication via this tab is over 3G to the server. So steps <span class="strong"><strong>1</strong></span>, <span class="strong"><strong>2</strong></span>, and <span class="strong"><strong>3</strong></span> of the interception setup remain the same. In step <span class="strong"><strong>4</strong></span>, instead of a wired network, we followed a 3G channel to connect to the server.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec131"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Configuring traffic interception with iOS</em></span></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://www.blackhat.com/presentations/bh-dc-08/Steve-DHulton/Whitepaper/bh-dc-08-steve-dhulton-WP.pdf">
https://www.blackhat.com/presentations/bh-dc-08/Steve-DHulton/Whitepaper/bh-dc-08-steve-dhulton-WP.pdf
</a></li></ul></div></div></div>
<div class="section" title="Configuring traffic interception with Android"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Configuring traffic interception with Android</h1></div></div></div><p>In the previous recipe, we learned how to create a penetration testing lab for mobile device interception, where we said we need to configure a mobile device to force step <span class="strong"><strong>2</strong></span> to follow a network proxy. Let us learn in this recipe how to do this in Android phones.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec132"/>Getting ready</h2></div></div></div><p>An Android phone. A rooted phone is required for mobile applications. (We learned rooting in the <span class="emphasis"><em>Introduction to rooting and jailbreaking</em></span> recipe of 
<a class="link" href="ch01.html" title="Chapter 1.  Introduction to Mobile Security">Chapter 1</a>
, <span class="emphasis"><em>Introduction to Mobile Security</em></span>).</p><p>Android proxy tools like ProxyDroid are available for download from Play Store.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec133"/>How to do it...</h2></div></div></div><p>It is very easy to set up traffic interception for WAP-based applications (that is, applications that run on a browser in Android). For this, go to Wi-Fi settings and select the <span class="strong"><strong>Wi-Fi</strong></span> you wish to connect to; there you can see <span class="strong"><strong>Proxy settings</strong></span> under <span class="strong"><strong>Advanced Options</strong></span>. Select <span class="strong"><strong>Proxy settings</strong></span> as <span class="strong"><strong>Manual</strong></span> to configure the <span class="strong"><strong>Proxy hostname</strong></span>/<span class="strong"><strong>IP address</strong></span>, <span class="strong"><strong>Proxy port</strong></span> number, and so on. This is also shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_003.jpg" alt="How to do it..."/></div><p>
</p><p>While the preceding approach is good for WAP applications, it does not work for downloaded and installed applications (that is, native and hybrid apps). For these applications, we need to install Android proxy tools on the phone. ProxyDroid is one such tool and can be downloaded free from Google Play Store. The proxy settings using these tools work only on rooted phones. So the sequence for proxying using third-party proxy tools is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Root your Android device.</li><li class="listitem">Install proxy tools such as <span class="strong"><strong>ProxyDroid</strong></span> or <span class="strong"><strong>Autoproxy lite</strong></span>.</li><li class="listitem">Configure the proxy tools.</li></ol></div><p>The first two steps are already known to you by now. The third step is pictorially represented as follows:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_004.jpg" alt="How to do it..."/></div><p>
</p><p>ProxyDroid requires superuser permission to allow it to be able to set a proxy. Move to the next step and enable <span class="strong"><strong>Proxy Switch</strong></span> to configure the name of the <span class="strong"><strong>Host</strong></span>, <span class="strong"><strong>Port</strong></span>, and so on. A final, optional step is, if the proxy requires authentication, to provide the authentication credentials. Since the proxy is in our control, we would like to keep it simple by not configuring authentication for seamless testing.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec134"/>How it works...</h2></div></div></div><p>Android OS is built on a Linux base. Linux uses a routing table for routing packets over the network. So, we need to modify the routing table entries in Android to be able to route packets to the network proxy we are willing to intercept at.</p><p>Access to the underlying components (like routing tables) is not allowed, and hence we need to root the phone so that the proxy tools are able to obtain superuser permission on OS. This way, the proxy tools on a rooted phone overwrite the routing tables based on the proxy settings provided by the user.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec135"/>There's more...</h2></div></div></div><p>When using Android emulators, a proxy can be set using the ADB tool. Both the emulator and web proxy tool can be run on the same machine. Use the following command for starting the emulator with a local proxy on port <code class="literal">7000</code>:</p><pre class="programlisting">
<span class="strong"><strong>emulator.exe -avd &lt;name&gt; -http-proxy 127.0.0.1:7000</strong></span>
</pre></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec136"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Intercepting traffic using Burp Suite and Wireshark</em></span></li><li class="listitem" style="list-style-type: disc">https://play.google.com/store/apps/details?id=org.proxydroid&amp;hl=en</li><li class="listitem" style="list-style-type: disc">https://play.google.com/store/apps/details?id=com.mgranja.autoproxy_lite&amp;hl=en</li></ul></div></div></div>
<div class="section" title="Intercepting traffic using Burp Suite and Wireshark"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Intercepting traffic using Burp Suite and Wireshark</h1></div></div></div><p>Traffic interception is the next thing to target after setting the proxy on the phone. Traffic interception opens up another layer to attack in the applications. In this recipe, we will learn to set up traffic interception while the next recipe discusses attacking the application using proxy interception of traffic.</p><p>Two primary tools for intercepting or sniffing the traffic are web proxy tools such as Burp Suite or Charles Proxy, and network sniffers such as Wireshark or Shark for Root on Android. While Burp Suite inserts itself in the middle of the communication (stop, modify, and forward), Shark for Root sniffs the network packets (on Wi-Fi or 3G both).</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec137"/>Getting ready</h2></div></div></div><p>For intercepting the mobile traffic, set up the lab and tools as described in the previous two recipes. Additionally, download and install <span class="strong"><strong>Shark</strong></span> from Play Store.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec138"/>How to do it...</h2></div></div></div><p>The following, are the steps that need to be followed to set up using Burp Suite and Shark for Root respectively:</p><p>
<span class="strong"><strong>Burp Suite</strong></span>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Set up the wireless pentest lab as described in the <span class="emphasis"><em>Setting up the Wireless Pentesting Lab for mobile devices</em></span> recipe. Burp Suite (Burp Proxy) should now be running on your laptop, and it must be listening on default port <code class="literal">8080</code>.</li><li class="listitem">Now configure the Android phone to route traffic to the Burp Proxy running on your laptop (use the previous recipe for this configuration). Make sure that the IP address, Port, and so on are configured correctly. Now you can see the intercepted traffic and tamper it as well. Let us park the malicious activities for the next recipe.</li></ol></div><p>
<span class="strong"><strong>Shark for Root</strong></span>
</p><p>Like the proxy tools on Android, Shark for Root also requires superuser permission. This needs to be on a rooted phone and needs to be allowed for the creation of packet dump. This step is shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_005.jpg" alt="How to do it..."/></div><p>
</p><p>Finally, set the parameters for capturing the traffic. Shark for Root dumps all the packets in the <code class="literal">.pcap</code> file, as you can also see in the following screenshot, indicating that <code class="literal">pcap</code> dumping has started. The same screenshot on the right-hand side shows the path in the phone where the <code class="literal">.pcap</code> file is created and stored:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_006.jpg" alt="How to do it..."/></div><p>
</p><p>The <code class="literal">.pcap</code> file can be transferred to the computer and can be interpreted better by Wireshark.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec139"/>How it works...</h2></div></div></div><p>The working of a network proxy (or Burp Suite) is simple. It inserts itself in the network path like a man-in-the-middle and listens or modifies the traffic.</p><p>Shark for Root works by obtaining superuser permission on the underlying OS and gets access to networking files; thereby, it is able to sniff packets and create a packet dump.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec140"/>There's more...</h2></div></div></div><p>The packet dump (<code class="literal">.pcap</code>) file created by Shark for Root is very useful in analyzing the kind of packets being transmitted over the network. Sometimes the web proxies are not able to capture the traffic. Reasons for this could be specific SSL certificates bundled into the mobile applications, or specific TCP packets or protocols used (not necessarily HTTP). In such cases when proxy tools fail, Shark for Root can be useful to understand the failure reasons, which give further direction to interception   troubleshooting.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec141"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using MITM Proxy to modify and attack</em></span></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://portswigger.net/burp/">https://portswigger.net/burp/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://play.google.com/store/apps/details?id=lv.n3o.shark&amp;hl=en">https://play.google.com/store/apps/details?id=lv.n3o.shark&amp;hl=en</a></li></ul></div></div></div>
<div class="section" title="Using MITM proxy to modify and attack"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Using MITM proxy to modify and attack</h1></div></div></div><p>Burp Suite is set as a <span class="strong"><strong>Man-in-the-middle</strong></span> (<span class="strong"><strong>MITM</strong></span>) proxy. A man-in-the-middle has control over every transaction (request and response) being exchanged by the two parties, that is, the mobile application on the phone and the mobile server where business logic resides.</p><p>A MITM proxy is used to attack the application business logic, like the transfer limit of 1000 Dollars can be attempted to bypass by making higher amount transactions; specific workflows such as OTP bypass can also be attempted. MITM proxies can also be used to obtain privileged access in the application by accessing an object or modifying a parameter value to serve privileged content.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec142"/>Getting ready</h2></div></div></div><p>For intercepting the mobile traffic, set up the lab and tools as described in the previous recipes in this chapter. Once you are done, your Burp Suite is already ready to modify and attack.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec143"/>How to do it...</h2></div></div></div><p>Let us take a business case and employ the <span class="emphasis"><em>modify and attack</em></span> method. All mobile banking applications allow a basic feature to view balance for self-owned bank accounts. Let us attack this feature to view the balance of other user accounts:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Firstly, select a mobile banking application.</li><li class="listitem">Log in and go to the view balance feature; the application allows you to select one of the self-owned accounts and subsequently sends a request to the server requesting user balance. This request is intercepted in the Burp Proxy as shown:</li></ol></div><p>
</p><div class="mediaobject"><img src="graphics/image_04_007.jpg" alt="How to do it..."/></div><p>
</p><p>Notice the <code class="literal">Payment Instrument Id</code> highlighted in the screenshot. This parameter value was tampered to another value like <code class="literal">10001856</code> and it resulted in revealing the account balance of an account which does not belong to the logged-in user. Unfortunately, this being a live mobile banking application, we are unable to show you further application screenshots.</p><p>This way, a MITM proxy is used to modify and attack the parameters in the applications.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec144"/>How it works...</h2></div></div></div><p>MITM proxy medication attacks are to target server-side application logic. Since the proxy is acting as a man-in-the-middle, it can fully control the data being transferred. The parameters that could be responsible for resulting in data in response are selected and modified to achieve something that is not functionally allowed in the application.</p><p>In this particular case, there is a unique session token allocated for each user but the application fails to validate that the parameter value (<code class="literal">Payment Instrument Id</code>) being requested does not belong to the logged-in user. So it displays the account balance of other customers, allowing business logic validation to be bypassed.</p><p>This MITM proxy is responsible for various notorious attacks on the application logic. The key is to select the right variable to manipulate, which may sometimes be time consuming.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec145"/>There's more...</h2></div></div></div><p>We can only discuss one case. A lot more can be achieved via this MITM modify and attack method. Think about the application functions and validations which are built and then decide which one should be attacked using this method.</p><p>For a mobile banking application, here is an indicative list of possible attacks you can attempt:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">View account balance of others</li><li class="listitem" style="list-style-type: disc">View transaction history of others</li><li class="listitem" style="list-style-type: disc">Transfer funds from other users' accounts</li><li class="listitem" style="list-style-type: disc">Transfer funds to a non-added beneficiary</li><li class="listitem" style="list-style-type: disc">Register or de-register credit cards in other users' accounts</li><li class="listitem" style="list-style-type: disc">Register or de-register billers in other users' accounts</li></ul></div><p>Similarly, in an application involving multiple roles like user, manager, and admin, you would like to play around with the request variable responsible for serving privileged content. If successful, a user can obtain manager's or admin's access, thereby successfully conducting a privilege escalation attack.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec146"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Analyzing traffic and extracting sensitive information from iOS App traffic</em></span></li></ul></div></div></div>
<div class="section" title="Configuring traffic interception with iOS"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Configuring traffic interception with iOS</h1></div></div></div><p>A penetration testing lab for mobile device interception is conceptualized in the, <span class="emphasis"><em>Setting up the wireless pentesting lab for mobile devices</em></span>, recipe of this chapter. We have to configure an iOS device to force step 2 (described in the first recipe) to follow a network proxy. Let us learn in this recipe how to do this in iOS devices.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec147"/>Getting ready</h2></div></div></div><p>An iOS device, along with other necessities of lab setup like Wi-Fi network and a laptop with web proxy tools (as discussed in the first recipe of this chapter) are required.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec148"/>How to do it...</h2></div></div></div><p>iOS provides a proxy as a feature to iDevice users. This makes it very easy for users or attackers to set up traffic interception for iOS applications. The device proxy settings are global and apply for applications too.</p><p>The settings can be configured by navigating to settings in an iPhone or iPad.</p><p>For this, go to Wi-Fi settings and select the Wi-Fi you wish to connect to; there you can see <span class="strong"><strong>Proxy Settings</strong></span> under Advanced Options. Select <span class="strong"><strong>Manual</strong></span> under <span class="strong"><strong>HTTP PROXY</strong></span> to configure the Proxy Hostname/IP address, Proxy Port number, and so on. This is also shown in the following screenshot:</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec149"/>How it works...</h2></div></div></div><p>iOS has provided a feature to set proxy using which users set a network proxy and capture the traffic. This is complicated in the case of Android, as the proxy feature itself was not present by default. In the case of iOS, the presence of a proxy as a feature has made it direct.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec150"/>There's more...</h2></div></div></div><p>For iOS applications and Xcode projects, which can be run on iOS Simulator, a proxy can be set. Xcode and iOS Simulator run on Mac OS X. We can set global proxy settings in MacBook. Under Wi-Fi settings, for the connected Wi-Fi network, navigate to <span class="strong"><strong>Proxies</strong></span> and to <span class="strong"><strong>Web Proxy (HTTP)</strong></span>. There, set a local proxy (<code class="literal">127.0.0.1</code>) and provide the proxy port (<code class="literal">8080</code> for Burp Proxy). This is shown in the following screenshot and it will ensure that the traffic from iOS Simulator goes to the server via the proxy tool running on the same machine (MacBook):</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_008.jpg" alt="There's more..."/></div><p>
</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec151"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.charlesproxy.com/documentation/faqs/using-charles-from-an-iphone/">http://www.charlesproxy.com/documentation/faqs/using-charles-from-an-iphone/</a></li></ul></div></div></div>
<div class="section" title="Analyzing traffic and extracting sensitive information from iOS App traffic"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Analyzing traffic and extracting sensitive information from iOS App traffic</h1></div></div></div><p>When the interception setup is ready, traffic analysis has started. The most difficult task from traffic is to extract sensitive information, or rather, to find the HTTP requests and variables which can help further extract sensitive information.</p><p>Let us take the case of an iOS application we came across. Let us first analyze the traffic and later see how to extract sensitive information.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec152"/>Getting ready</h2></div></div></div><p>For intercepting the iOS application traffic, set up the lab and tools as discussed in the previous recipe. Once you are done, the proxy tool (Charles Proxy) is ready to intercept the traffic.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec153"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Log in to the mobile app, as shown in the following screenshot. Enter the wrong password for the correct username:<p>
</p><div class="mediaobject"><img src="graphics/image_04_009.jpg" alt="How to do it..."/><div class="caption">Note that a login request goes and a response is received.</div></div><p>
</p></li><li class="listitem">Closely monitor the response traffic. For the incorrect password, there is a <code class="literal">ERR_PWD</code> text in the response, as shown in the following screenshot:<p>
</p><div class="mediaobject"><img src="graphics/image_04_010.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">This results in an error response on the iPhone screen, as shown in the following screenshot:<p>
</p><div class="mediaobject"><img src="graphics/image_04_011.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">Now try logging in to the application with the correct username and password. Notice the response to the login request. It contains a text <code class="literal">SUCCESS_LOGIN</code> in the response, as shown in the following screenshot. This action displays the internal screen of the mobile application:<p>
</p><div class="mediaobject"><img src="graphics/image_04_012.jpg" alt="How to do it..."/></div><p>
</p></li></ol></div><p>This analysis of iOS application traffic shows the difference in the responses of two cases. Let us now try pasting the response of one case to another.</p><p>When we log in with an incorrect password, we get <code class="literal">ERR_PWD</code> in the response. Now, from the Charles Proxy tool, manipulate the response <code class="literal">ERR_PWD</code> to <code class="literal">SUCCESS_LOGIN</code> and forward the response from Charles. This action logs the user in to the application and the internal application screen is shown in the iPhone. This way, we obtained sensitive information from an iOS application, with a wrong password.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec154"/>There's more...</h2></div></div></div><p>The possibilities are numerous with application traffic to reveal sensitive information. Another case worth mentioning is when we found an iPad application to be sending a request containing username, password, and <span class="strong"><strong>Unique Device Identifier</strong></span> (<span class="strong"><strong>UDID</strong></span>) number. The application tried to implement user locking to a particular iPad only, so that the same user is not able to log in from other iPads.</p><p>We could bypass this and log in the same user from another iPad by tampering the UDID number of the other iPad to the previous iPad in the outgoing request. This way, the iPad binding of the application was proved useless.</p><p>Depending on the application functionalities and the traffic analysis, many things can be attempted and bypassed.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec155"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Using MITM Proxy to modify and attack</em></span></li></ul></div></div></div>
<div class="section" title="WebKit attacks on mobile applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec46"/>WebKit attacks on mobile applications</h1></div></div></div><p>Safari and other mobile applications use <span class="strong"><strong>WebKit</strong></span>. It is a web browser engine. It provides browser capabilities to the applications wherever it is implemented. Most Hybrid Mobile Applications use WebKit for the applications feature to be able to invoke browser components and make it a seamless integration for application users.</p><p>WebKit-based attacks for mobile applications are similar to the web applications browser-based attacks. The <span class="strong"><strong>cross-site scripting</strong></span> (<span class="strong"><strong>XSS</strong></span>) or HTML injection are the most common attacks on the WebKit components of mobile applications.</p><p>Cross-site scripting takes advantage of the application feature of reflecting user inputs back to the user without sanitizing the outputs. So, if the application reflects a malicious JavaScript posted by the attacker to the user, then the script is executed at the user's browser. These scripts could steal a user session token or could download and install malwares and backdoors.</p><p>The HTML injection slightly varies from XSS. Here, the HTML tags or code is sent, which upon reflection back to the user, modifies the HTML view. This could eventually bypass certain client side restrictions or completely change the presentation, including loading of a new HTML file.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec156"/>Getting ready</h2></div></div></div><p>For this, we need applications that use WebKit components. Testing tools are the same as described in previous recipes in this chapter.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec157"/>How to do it...</h2></div></div></div><p>Let us take an iOS application that uses UIWebView to embed the web content in the mobile application.</p><p>In this application, a web page is loaded inside the application by simply passing the URL to the <code class="literal">UIWebView</code> class object. This object renders the HTML as the iOS Safari browser (WebKit) would do it.</p><p>Let us look at the WebKit attack possibility in this scenario:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Tamper the path variable to load another stored or compromised HTML file (HTML injection variant).</li><li class="listitem">Load some other page with embedded malicious JavaScript, resulting in execution of JavaScript at the user's context (XSS variant).</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec158"/>How it works...</h2></div></div></div><p>To understand how the WebKit attack works in this case, let us have a look at how the iOS application code associated with view generation looks:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_013.jpg" alt="How it works..."/></div><p>
</p><p>From the code, note that the HTML file present at index location is going to be loaded.</p><p>If this index file can be compromised or modified to contain JavaScript, it can result in cross-site scripting attacks. This requires the attacker to hold control over the user's mobile device.</p><p>For demonstration purposes, an HTML code was inserted into the <code class="literal">index.html</code> file and loaded to show that the HTML injection attack is also possible. The result of this is shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_014.jpg" alt="How it works..."/></div><p>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec159"/>There's more...</h2></div></div></div><p>For similar categories of WebKit attacks, you need mobile applications that use the WebKit component and reflect user input. You need proxy tools like Burp Proxy to attack network traffic, tampering and inserting specific payloads. These payloads are reflected under the WebKit instantly to execute the attack.</p><p>Look at the applications with WebView, WebKit, and so on in the mobile side code. Employ web application proxy techniques to figure out the parameters that reflect in response. Create a payload and work out your custom attack.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec160"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Finding vulnerabilities in WAP-based mobile apps</em></span>, <a class="link" href="ch03.html" title="Chapter 3. Auditing Mobile Applications">Chapter 3</a>,<span class="emphasis"><em> Auditing Mobile Applications
</em></span></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://cansecwest.com/slides/2015/Liang_CanSecWest2015.pdf">https://cansecwest.com/slides/2015/Liang_CanSecWest2015.pdf</a></li></ul></div></div></div>
<div class="section" title="Performing SSL traffic interception by certificate manipulation"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Performing SSL traffic interception by certificate manipulation</h1></div></div></div><p>In <span class="emphasis"><em>Intercepting traffic using Burp Suite and Wireshark</em></span> and <span class="emphasis"><em>Using MITM proxy to modify and attack</em></span> recipes, we intercepted traffic of mobile applications. Today, most organizations are using SSL to protect data over the network. So, expect most real-world mobile applications to be under SSL. The next challenge we need to address is the interception of SSL traffic of mobile applications. This requires certification manipulation at the user or victim end.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec161"/>Getting ready</h2></div></div></div><p>Primary requirements for this recipe are mobile applications that use SSL. Additionally, you need all the tools we have used in the <span class="emphasis"><em>Intercepting traffic using Burp Suite and Shark</em></span> and <span class="emphasis"><em>Using MITM proxy to modify and attack</em></span> recipes in this chapter.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec162"/>How to do it...</h2></div></div></div><p>Try to set up a proxy tool and intercept the traffic of an Android or iOS application as per the previously described methods in this chapter. You will notice for WAP-based applications, the SSL error occurs on the mobile browser. In the case of installed or hybrid applications, you might not see any error and the traffic will not be captured.</p><p>In the case of WAP applications, if it provides an option of certificate acceptance, you can proceed and still capture the traffic in a proxy tool.</p><p>In the case of non-WAP applications, you need to forcefully make the application accept the proxy certificate. This can be achieved by adding the proxy certificate to the trusted credentials store.</p><p>Let us use Charles Proxy for this recipe:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install Charles Proxy in our Android phone to be able to intercept Android applications traffic.</li><li class="listitem">The SSL Certificate for Charles Proxy prior to v3.10 can be downloaded from <a class="ulink" href="http://www.charlesproxy.com/assets/legacy-ssl/charles.crt">
http://www.charlesproxy.com/assets/legacy-ssl/charles.crt
</a>.</li><li class="listitem">To install the Charles Proxy certificate, open the preceding URL from the Android phone.</li><li class="listitem">The proxy installation screen asks you to provide a name; we will write <code class="literal">charles</code> here, as shown in the following screenshot:<p>
</p><div class="mediaobject"><img src="graphics/image_04_015.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">The next steps prompt us to provide a lock screen PIN or password. Once we do so, we get a message that <code class="literal">Charles is installed</code>.</li><li class="listitem">Let us go to the <span class="strong"><strong>Trusted credentials</strong></span> store to verify that the certificate is installed. Navigation to this is: <span class="strong"><strong>Settings</strong></span> | <span class="strong"><strong>Security</strong></span> | <span class="strong"><strong>Trusted credentials</strong></span> | <span class="strong"><strong>User</strong></span>:<p>
</p><div class="mediaobject"><img src="graphics/image_04_016.jpg" alt="How to do it..."/></div><p>
</p></li></ol></div><p>Notice from the preceding screenshot that the <code class="literal">Charles Proxy SSL Certificate</code> is present and installed.</p><p>The next steps are smooth and are similar to the fourth recipe of this chapter. This way, SSL Proxy can be set for mobile applications and traffic can be tampered to attack the application business logic.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec163"/>How it works...</h2></div></div></div><p>SSL proxy interception works because SSL protocol is inherently vulnerable to MITM attacks. If two people (<code class="literal">A</code> and <code class="literal">B</code>) communicate using SSL, each of them has their public and private keys. Consider the MITM scenario where an attacker comes in between the communication path of <code class="literal">A</code> and <code class="literal">B</code>.</p><p>This attacker (or MITM) intercepts and exchanges the key with <code class="literal">A</code> and <code class="literal">B</code>. With this changed key, the attacker is able to encrypt and decrypt the communication initiated by either <code class="literal">A</code> or <code class="literal">B</code> and send it seamlessly to the other party.</p><p>This attack does pop up a SSL certificate error, and only when the user accepts the fake (or attacker's) certificate, is the communication initiated. In this recipe, we forced the acceptance of Charles Proxy on an Android phone by manual installation of the same. Real world MITM attacks rely either on the user somehow accepting the certificate or to figure out an alternate attack channel to install the fake certificate in the trusted store.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec164"/>There's more...</h2></div></div></div><p>Similar to how a proxy certificate was installed for Charles Proxy, SSL certificates for other proxy tools such as Burp Suite, Fiddler, and so on, can be installed in various mobile devices. The same steps can be followed to install the SSL certificates in emulators or simulators.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec165"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">https://en.wikipedia.org/wiki/Man-in-the-middle_attack</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://www.symantec.com/connect/blogs/android-mobile-app-pen-test-tricks-part-i-installing-ca-certificates">http://www.symantec.com/connect/blogs/android-mobile-app-pen-test-tricks-part-i-installing-ca-certificates</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://resources.infosecinstitute.com/android-application-penetration-testing-setting-certificate-installation-goatdroid-installation/">http://resources.infosecinstitute.com/android-application-penetration-testing-setting-certificate-installation-goatdroid-installation/</a></li></ul></div></div></div>
<div class="section" title="Using a mobile configuration profile to set up a VPN and intercept traffic in iOS devices"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Using a mobile configuration profile to set up a VPN and intercept traffic in iOS devices</h1></div></div></div><p>iOS allows iDevices to configure and participate in VPN. This VPN channel opens up another communication channel and so we can use this channel also for setting a proxy to intercept traffic.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec166"/>Getting ready</h2></div></div></div><p>We require proxy tools, an iDevice, and other requirements of a wireless pentesting lab.</p><p>Additionally, you need to configure a VPN server on a machine. Open VPN or PPTP Server can be used for the same.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec167"/>How to do it...</h2></div></div></div><p>Once you are ready, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download <span class="strong"><strong>PPTP Server</strong></span> from http://poptop.sourceforge.net/dox/ and install it on a Linux machine.</li><li class="listitem">Edit the <code class="literal">pptpd.conf</code> files to allocate <span class="strong"><strong>IP ranges</strong></span> for the VPN clients and provide a static IP to the VPN server, which will also act as a gateway.</li><li class="listitem">Further configure <span class="strong"><strong>DNS</strong></span><span class="strong"><strong>servers</strong></span> for the <span class="strong"><strong>VPN</strong></span> clients.</li><li class="listitem">Lastly, configure the <span class="strong"><strong>VPN</strong></span> password and adjust network settings if required.</li><li class="listitem">Once the configuration edits are done, save the <code class="literal">pptpd.conf</code> file and restart the VPN service. This makes sure that the VPN server is up and working.</li><li class="listitem">Now the mobile VPN client needs to be configured in the iDevice. Locate the <span class="strong"><strong>VPN settings</strong></span> on your iDevice and edit the <span class="strong"><strong>PPTP</strong></span> settings.</li><li class="listitem">Configure the server <span class="strong"><strong>IP address</strong></span>, <span class="strong"><strong>VPN authentication credentials</strong></span>, and so on. These settings are shown in the following screenshot:<p>
</p><div class="mediaobject"><img src="graphics/image_04_017.jpg" alt="How to do it..."/></div><p>
</p></li><li class="listitem">The preceding step makes sure that the iDevice is now part of the VPN, where the default gateway is under our control.</li><li class="listitem">Now let us set a proxy to this VPN client, that is, our iDevice. Under the <span class="strong"><strong>VPN settings</strong></span>, scroll down to locate the <span class="strong"><strong>Proxy settings</strong></span>, where you can configure <span class="strong"><strong>Proxy server IP address</strong></span> and <span class="strong"><strong>Port</strong></span> and provide proxy authentication details if required. This is shown in the following screenshot:<p>
</p><div class="mediaobject"><img src="graphics/image_04_018.jpg" alt="How to do it..."/></div><p>
</p></li></ol></div><p>Now the Burp or Charles Proxy running at the proxy IP address starts capturing the traffic.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec168"/>How it works...</h2></div></div></div><p>This recipe may sound complicated, with VPN server, client configuration, and proxy. In reality, it works very simply. Once a VPN network is set, all the components such as iDevice, VPN server, and Proxy tool are part of the same network. Now a network proxy is in this VPN network. So nothing has changed, just that it is a VPN proxy rather than a Wi-Fi proxy, as we have seen earlier. The fact that iOS provides VPN configuration as a feature on iDevices makes it fairly easy.</p><p>The importance of this recipe can be realized more on cellular network traffic interception, which can be very difficult otherwise.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec169"/>There's more...</h2></div></div></div><p>OpenVPN server and clients can be looked at as an alternative to PPTP Server. The steps are quite similar:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install the OpenVPN server on a machine.</li><li class="listitem">Install the OpenVPN client on an iDevice.</li><li class="listitem">Run a proxy tool like Burp or Charles proxy.</li><li class="listitem">Once all the preceding three components are on the same VPN network, configure proxy settings in the iDevice to initiate the traffic interception.</li></ol></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec170"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://thesprawl.org/research/ios-data-interception/">https://thesprawl.org/research/ios-data-interception/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="http://poptop.sourceforge.net/dox/">http://poptop.sourceforge.net/dox/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://itunes.apple.com/in/app/openvpn-connect/id590379981?mt=8">https://itunes.apple.com/in/app/openvpn-connect/id590379981?mt=8</a></li></ul></div></div></div>
<div class="section" title="Bypassing SSL certificate validation in Android and iOS"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Bypassing SSL certificate validation in Android and iOS</h1></div></div></div><p>SSL certificate validation is implemented in mobile applications for forceful usage of SSL with trusted certificates. A server certificate is pinned to the mobile application. SSL certificates get stored in the mobile device's trusted store and the mobile application is coded to use the same, while initiating connection to the server. This is also known as <span class="strong"><strong>certificate pinning</strong></span>.</p><p>Certificate pinning can be bypassed, which results in overall SSL certificate validation bypass. Let us learn certificate pinning bypass for both Android and iOS devices.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec171"/>Getting ready</h2></div></div></div><p>We will need the SSL interception tools and other tools as mentioned across various recipes in this chapter, application reverse engineering or decompiler tools, and the applications that use SSL pinning.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec172"/>How to do it...</h2></div></div></div><p>Follow these steps to bypass pinning:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Install a mobile application that uses SSL pinning.</li><li class="listitem">Try to set Burp proxy and notice that there is an error, and a successful connection is not established. This happens because the mobile application is coded to use a pinned certificate only. Since the Burp proxy certificate is not pinned, the application does not initiate the SSL communication. So, this makes it obvious that we are required to pin the Burp proxy certificate to the mobile application.</li><li class="listitem">Let us first install the Burp proxy certificate to the mobile device trusted certificate store. For this, please follow the <span class="emphasis"><em>Performing SSL Traffic Interception by Certificate Manipulation</em></span> recipe, previously explained in this chapter.</li><li class="listitem">The application now needs to be configured to remove pinning and/or use the new certificate stored on the mobile device. For this, you need to locate the application code that is responsible for using the pinned certificate, remove this code, and repack the application. The newly-packed application does not use the pinned certificate now and uses the trusted certificate of the Burp proxy. This way, the SSL proxy is set and the certificate validation is bypassed.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec173"/>How it works...</h2></div></div></div><p>The SSL pinning bypass works because it relies on checking that the user-supplied certificates are not allowed and only pinned certificates are used. It does not try to match the pinned certificate to the parameters belonging to the server certificate. In the whole process, it forgets that the mobile device is in user control and that they can conduct hacks to disable pinning.</p><p>Proxy certificates (or fake certificates) can be pushed into the mobile device's trusted store via different hacks. Also, the application is modified to drop the use of pinned certificates. Mobile applications fall for it and start communicating using fake or proxy certificates, which are already trusted by the mobile device.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec174"/>There's more...</h2></div></div></div><p>The preceding method relied on application code being manipulated to drop the pinned certificate. There is another method where code need not be manipulated but the keystore is manipulated to add proxy (or fake) certificates to the keystore.</p><p>This requires a keystore password, which is hardcoded into the mobile application code. Keystore passwords can be obtained from decompiled code. Tools like <span class="strong"><strong>smali</strong></span>/baksmali can be used for the same.</p><p>Finally, locate the keystore. The most probable location in Android is under the <code class="literal">res</code> folder. Now use the <code class="literal">keytool</code> command to add the proxy certificate to the keystore. Repack and sign the application. Now, it uses the proxy certificate and traffic interception works, thus bypassing the SSL certificate validation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>Make a point to check that the mobile application source code does not have any type of code to bypass SSL validation. A few developers prefer to write SSL validation bypass code for testing and debugging purposes. This code, when moved to production, should be sanitized to remove such bypass code.</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec175"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="emphasis"><em>Examining iOS App Data storage</em></span> and <span class="emphasis"><em>Keychain security vulnerabilities</em></span>, <a class="link" href="ch03.html" title="Chapter 3. Auditing Mobile Applications">Chapter 3</a>, <span class="emphasis"><em>Auditing Mobile Applications</em></span>.</li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://media.blackhat.com/bh-us-12/Turbo/Diquet/BH_US_12_Diqut_Osborne_Mobile_Certificate_Pinning_Slides.pdf">https://media.blackhat.com/bh-us-12/Turbo/Diquet/BH_US_12_Diqut_Osborne_Mobile_Certificate_Pinning_Slides.pdf</a></li></ul></div></div></div></body></html>