- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defense Evasion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main idea of this chapter is simple – *know your tooling*. It can be very
    tempting to start pulling fresh tooling from GitHub after getting an initial foothold
    on the target machine, looking for low-hanging fruit and quick wins. It may work
    well in some training labs to learn about attacking concepts; however, during
    real engagement, a mature opponent can easily detect your malicious activity.
    There are quite a lot of professionally written tools for both defense and offense,
    not to mention C2 frameworks, vendor EDRs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is not a fully comprehensive guide on how to evade all possible
    detection. Evasion is a constantly evolving game between the sword and the shield.
    Several factors can influence the way offensive operation is going, including
    preparation, the development of specific tooling, the team’s skill set, and the
    capabilities of both sides. We are not going to touch EDR/antivirus evasion. Excellent
    books have been published that will teach you how to find and develop possible
    bypasses, including attacking security solutions themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus on built-in security capabilities that can be deployed and enforced
    in the Windows environment. In this chapter, we are going to cover the following
    main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: AMSI, AppLocker, and PowerShell **Constrained Language Mode** (**CLM**) deployment
    and bypass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy PowerShell Enhanced Logging, evade it, and use Sysmon to detect yourself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is ETW? What extra capabilities and insights can it provide?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will use only two VMs from the GOADv2 lab – DC01 and SRV01\.
    Ensure that SRV01 is a domain-joined machine, as we are going to use Group Policies
    during this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: AMSI, PowerShell CLM, and AppLocker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss some of the built-in capabilities in Windows
    that can limit attacker’s actions on the compromised machine. AMSI, AppLocker,
    and PowerShell CLM can be bypassed in different ways, but considering them as
    defense in depth is a good decision. As usual, we need to know the limitations
    and cover bypasses where it is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Antimalware Scan Interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s first discuss what **Antimalware Scan Interface** (**AMSI**) is. Microsoft
    developed it to provide a set of API calls for applications, including any third-party
    applications, to perform a signature-based scan of the content. Windows Defender
    uses it to scan PowerShell scripts, .NET, VBA macros, **Windows Script Host**
    (**WSH**), VBScript, and JavaScript to detect common malware. The important thing
    about AMSI is that you do not need to deploy it; it has been there since Windows
    10.
  prefs: []
  type: TYPE_NORMAL
- en: 'In plain words, the AMSI algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**amsi.dll** will be loaded into the process memory space; for example, PowerShell
    and **AmsiInitialize** will be called.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, **AmsiOpenSession** is called, which opens a session for a scan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The script content will be scanned before the execution invoking one of the
    APIs is called – **AmsiScanBuffer** or **AmsiScanString**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the content is clear from known malicious signatures, Microsoft Defender
    will return **1** as the result and the script will be executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To confirm this AMSI behavior, we can use Process Hacker[1] or API monitor[2].
    These open source tools allow us to see loaded in-process modules, get information
    about them, and a lot of other information. In the following screenshot, we can
    see the loaded **amsi.dll** and a list of exported functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Loaded amsi.dll and exported functions](image/B18964_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Loaded amsi.dll and exported functions
  prefs: []
  type: TYPE_NORMAL
- en: 'One important caveat from the Microsoft documentation is as follows – “*But
    you ultimately need to supply the scripting engine with plain, un-obfuscated code.
    And that is the point at which you invoke the AMSI APIs*.” A quick test to prove
    this statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Detection and concatenation](image/B18964_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Detection and concatenation
  prefs: []
  type: TYPE_NORMAL
- en: It looks trivial. We can split the string first and then bypass AMSI using concatenation,
    but in more complex code this approach will require much more effort. There are
    a few strategies that were used by researchers to develop reliable bypasses –
    encoding/obfuscation, hooking, memory patching, forcing an error, registry key
    modification, and DLL hijacking. You can find two great compiled lists of bypasses
    and credits to original research created by *S3cur3Th1sSh1t*[3] and *Pentest Laboratories*[4].
    Some of the bypasses look like a one-liner, but I highly encourage you to dive
    deeper and review them, read the original research, and follow the thought process.
    It’s also worth mentioning that not every bypass will be successful, as Microsoft
    tries to patch them as well. The chances are not great that the good old base64-encoded
    one-liners will do the trick. The best way to ensure that your bypass will work
    in the target environment is to precisely identify the victim’s OS version, recreate
    it in your lab environment, and test, test, test.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For some quick wins, there is a great free website developed by *Flangvik* ([https://amsi.fail/](https://amsi.fail/)),
    where you can generate various PowerShell snippets to disable or break AMSI. Another
    helpful tool is Invoke-Obfuscation[5], written by *Daniel Bohannon*. This tool
    has different modes. For me, AST mode was the one that provided reliable bypasses
    most of the time. The idea is that the script will be obfuscated in such a way
    that it breaks the AST parsing algorithm in AMSI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will try to bypass AMSI using three different techniques: error forcing,
    obfuscation, and memory patching. As mentioned previously, I will use the SRV01
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Way 1 – Error forcing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s first look at error-forcing code and a bit of split/concatenate fantasy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of running the preceding commands is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Error forcing](image/B18964_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Error forcing
  prefs: []
  type: TYPE_NORMAL
- en: Way 2 – Obfuscation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For AST obfuscation, let’s try to get reverse shell callback using **PowerShellTcpOneLine.ps1**
    from the Nishang framework[6] and the previously mentioned Invoke-Obfuscation
    tool. We will set up a listener on port 443 with powercat[7] on another Windows
    box. Here is the original reverse shell code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we try to run it, AMSI catches us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – AMSI blocks original reverse shell](image/B18964_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – AMSI blocks original reverse shell
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the Invoke-Obfuscation tool, choosing AST obfuscation, and providing
    the path to our original reverse shell. After obfuscation, the code looked like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result obtained by running the preceding commands is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Obfuscated reverse shell callback](image/B18964_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Obfuscated reverse shell callback
  prefs: []
  type: TYPE_NORMAL
- en: Way 3 – Memory patch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few ways we can manipulate AMSI in memory to achieve the bypass.
    The key reasoning behind this is that we are in full control of the process where
    **amsi.dll** will be loaded. One of the examples is to force **AmsiScanBuffer**
    to return **AMSI_RESULT_CLEAN**. The general idea is to import API calls and then
    return a specific value to the **AmsiScanBuffer()** call: **0x80070057**. The
    original bypass is detected by AMSI now, so we can manipulate with assembly instructions
    by using a double **add** operand and successfully bypass the control. The code
    for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result obtained by running the preceding commands is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Successful AMSI disarm using memory patching](image/B18964_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Successful AMSI disarm using memory patching
  prefs: []
  type: TYPE_NORMAL
- en: Also, as an attacker, we cannot ignore the fact that some defensive mechanisms
    can be abused as well as bypassed. A great example was published by *netbiosX*[8],
    which stated that AMSI can be used to achieve persistence on the compromised host.
    Using previous research and their coding skills, a fake AMSI provider was developed
    and registered on the compromised host. Using a special keyword, we can initiate
    a callback home from our backdoor.
  prefs: []
  type: TYPE_NORMAL
- en: All the techniques mentioned here will leave some sort of trace on the victim’s
    machine. Moreover, even successful bypasses can still be caught by defenders.
    Excellent blog posts by *Pentest Laboratories*[9] and *F-Secure*[10] show how
    to create detections and share excellent ready-to-use recipes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to discuss two security controls that are
    quite often deployed in corporate environments.
  prefs: []
  type: TYPE_NORMAL
- en: AppLocker and PowerShell CLM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'AppLocker was added by Microsoft in Windows 7 as a successor to the older **Software
    Restriction Policies** (**SRP**). It was supposed to be a comprehensive application
    white-listing solution. With this feature, you can limit not only applications,
    but also scripts, batches, DLLs, and more. There are a few ways that a limit can
    be applied: by Name, Path, Publisher, or Hash. As stated by Microsoft, AppLocker
    is a security feature, not a boundary. Nowadays, the recommendation is to enforce
    **Windows Defender Application Control** (**WDAC**) as restrictively as possible
    and then use AppLocker to fine-tune the restrictions. However, in complex enterprise
    environments, it is still common to see AppLocker alone as it is easier to deploy
    and administrate.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand in more detail how AppLocker is working, I recommend you read
    four parts of *Tyraniddo*’s blog[11] about this feature. He starts the journey
    with the AppLocker setup and overview. In part 2, the author reveals how the process
    creation is blocked by the operating system’s kernel, followed by a clear example.
    Part 3 is devoted to rule processing, covering access tokens and access checks.
    Some basic understanding of security descriptors and tokens will not hurt the
    reader. The final part has a full focus on DLL blocking.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what AppLocker is, why do we need anything on top? What is
    PowerShell CLM, and how does it relate to AppLocker? In short, we can limit PowerShell
    sensitive language capabilities to the users by enabling CLM. Some examples of
    these sensitive capabilities are Windows API invocation, creating arbitrary types,
    and dot sourcing[12].
  prefs: []
  type: TYPE_NORMAL
- en: CLM can be enforced via environment variables or by setting it through language
    mode. However, these methods are not reliable and can be bypassed with almost
    no effort from the attacker. But with system-wide application control solutions,
    it can be used. The idea is that PowerShell will detect when the AppLocker policy
    is being enforced and will run only in CLM.
  prefs: []
  type: TYPE_NORMAL
- en: '*How robust are* *these protections?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will deploy it in our **sevenkingdoms.local** lab domain. I advise you to
    take a snapshot before any change in the lab so we can quickly revert to the initial
    state if required. We will create an AppLocker group policy on DC01 and enforce
    it on the SRV01 server. If you have never deployed AppLocker, there is a friendly
    guide available[13]. The rule is straightforward – action, user, condition, and
    exceptions if required. By following the previously mentioned guide[13], we will
    create default rules and restrictions for users to run **cmd.exe**. One important
    caveat – if you are in the **Administrators** group, by default, AppLocker is
    not applied to your account. To check your current ruleset, we can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The new **Deny_CMD** rule can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Deny rule in AppLocker](image/B18964_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Deny rule in AppLocker
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, as we enforced rules for scripts as well, PowerShell went down in
    CLM. It is easy to check using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – PowerShell CLM in action](image/B18964_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – PowerShell CLM in action
  prefs: []
  type: TYPE_NORMAL
- en: The robustness of these security features depends on the quality of the rules
    we are implementing. In AppLocker, we have Publisher, File Hash, and Path conditions.
    Let’s briefly discuss all of them and show some possible bypasses.
  prefs: []
  type: TYPE_NORMAL
- en: '*Path* restrictions can be bypassed by evaluating trusted paths and copying
    our binary there; for example, there are plenty of subfolders inside **C:\Windows**,
    where the normal user can copy files. The File Hash deny rule can be bypassed
    by changing the binary with the known hash mentioned in the rule. Let’s bypass
    the first two conditions combined and execute **nc64.exe** on the host. I created
    the rule to block **nc64.exe** by its hash. We will first copy **nc64.exe** to
    the **C:\Windows\System32\spool\drivers\color\** and then bypass the File Hash
    rule by changing the File Hash by adding an extra **A** at the end of the file.
    The result of the bypass is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Path and hash rule bypass for nc.exe](image/B18964_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Path and hash rule bypass for nc.exe
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Publisher* condition is much more difficult to bypass. The reason is that
    the application’s publisher signature and extended attributes will be checked.
    We cannot use self-signed certificates to bypass it, but we can abuse legitimate
    signed binaries, which have the extended functionality we need. There is a whole
    project with a list of such binaries at [https://lolbas-project.github.io/](https://lolbas-project.github.io/).
    There are two well-illustrated blog posts about common LOLBAS abuse to bypass
    AppLocker using **InstallUtil**[14] and MSBuild[15]. In brief, we will use **MSBuild.exe**
    to compile and run our malicious code stored in an XML file; for example, with
    Windows APIs we can allocate memory, and copy and run our shellcode. Another method
    is to use InstallUtil to run our executable if it is located on the victim’s box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: But what if **cmd.exe** is locked down? Not a big deal! You create shortcuts
    of the required binaries, such as InstallUtil and csc, then manually change the
    target field value so that it stores the required command line to execute. It
    is still reliably working until the LOLBAS binaries are not blocked. The entire
    project with the AppLocker bypasses list is available on GitHub[16]. By evaluating
    them, we can assess how robust our rules are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking about CLM bypass, there are different ways to achieve Full Language
    Mode, such as spawn PowerShell such that it downgrades to version 2 (rarely installed
    these days), use **rundll32.exe** with **PowerShlld.dll**[17], or use bypasses
    such as a wrapper over **InstallUtil**[18] and function return value patching[19].
    The last three projects will require obfuscation to evade Microsoft Defender nowadays.
    To read more about the process of finding bypasses, I recommend going through
    *XPN’s* great research, “AppLocker and CLM Bypass via COM”[20]. But let me show
    you one of my favourite bypasses by *sp00ks* that I recently found[21]. The following
    code sets the environment registry value in the HKCU hive (you do not need to
    be an administrator for that), creates a PowerShell process using WMI, and then
    sets the value back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result obtained by running the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Example of CLM bypass](image/B18964_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Example of CLM bypass
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned at the beginning of the section, the best way to harden application
    control is to deploy **Windows Defender Application Control** (**WDAC**) together
    with AppLocker. One of the most powerful collections of rules is called AaronLocker[22],
    which can be deployed together with WDAC in your environment via Group Policy[23].
    It is recommended to start monitoring your rulesets in audit mode, gradually fine-tuning
    them.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell Enhanced Logging and Sysmon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to explore what Sysmon[24] is and how it can be
    used to detect attacker’s activities. Sysmon is a system service in Windows that
    we can install and use to log information about various events, including process
    creation, various file events, registry access, named pipes, and network connections.
    Logs stay in Windows Event Collection. Sysmon does not prevent any attacks or
    provide an analysis of the events. There are a few great projects that can help
    you get started with Sysmon. A great community guide is provided by *TrustedSec*[25],
    and we will use the Sysmon config created by *SwiftOnSecurity*[26] as it is one
    of the best high-quality event tracing templates. Two more projects that provide
    a variety of config files were created by *Florian Roth*[27] and *Olaf Hartong*[28].
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s install Sysmon, apply the configs from the preceding project, and start
    digging inside the logs. Installation is straightforward; only one command being
    run as administrator is required, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Sysmon installation](image/B18964_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Sysmon installation
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to enable PowerShell Transcription, Script Block, and Module
    Logging. To enable them, I will use Group Policy Management on **kingslanding.sevenkingdoms.local**.
    I will create a separate GPO at **Computer Configuration** | **Policies** | **Administrative
    Templates** | **Windows Components** | **Windows PowerShell**. The settings can
    be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Group Policies to enable PowerShell Logging](image/B18964_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Group Policies to enable PowerShell Logging
  prefs: []
  type: TYPE_NORMAL
- en: 'These logging features are intended to provide better visibility for defenders
    if PowerShell is expected to be used across the organization. Our first control
    is **Script Block Logging**, including **Warning Logging of Suspicious Commands**.
    There are known bypasses found by *cobbr.io* (the author of the C2 Covenant Framework)
    for ScriptBlock Logging[29] and Suspicious Commands Logging[30]. I just slightly
    modified the code to bypass AMSI and added a bit more visibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result obtained from running the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – PowerShell Script Block Logging bypass](image/B18964_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – PowerShell Script Block Logging bypass
  prefs: []
  type: TYPE_NORMAL
- en: 'One point to consider is that our bypass will still be logged until we disable
    **Event Tracing for Windows** (**ETW**) for the current PowerShell session first.
    This can be done using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can also obfuscate this command to bypass Suspicious ScriptBlock Logging.
    Do not rely much on obfuscation as an experienced blue team will de-obfuscate
    it with the help of a tool such as DeepBlue[31] and immediately launch the investigation.
    The good thing is that for this bypass, we do not need elevated privileges and
    only manipulate cached values from Group Policy, so no modification on the host
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: Two new PowerShell ScriptBlock and Module Logging bypasses were introduced by
    *BC-security* in their series of blog posts. The ScriptBlock bypass is based on
    the fact that the script block that has already been logged will be skipped if
    it is encountered a second time. The idea is to set the value of **HasLogged**
    to **True** before invoking the script. The purpose of the Module Logging bypass
    was to create a callable command that has no module or PowerShell snap-in associated
    with it[32]. Part 2 of the blog series showed how commands can be obfuscated to
    make the defender’s analysis more difficult[33]. Quick prevention recommendations
    against these bypasses will require the PowerShell Protect module[34].
  prefs: []
  type: TYPE_NORMAL
- en: However, if PowerShell Transcription is enabled, our activity will be still
    logged in to the file regardless of the preceding bypass. The reason is that even
    if we disable transcription in the active PowerShell session, it will continue
    the transcription and ignore the newly changed value. The original way to bypass
    was shown by *Jann Lemm* from *Avantguard* in his blog post[35]. The idea is to
    create a custom runspace, overwrite the value of **EnableTranscripting**, and
    then open the new runspace. Proof-of-concept code is available in the blogpost.
  prefs: []
  type: TYPE_NORMAL
- en: But what if there is a tool that can help us to bypass everything with almost
    no manual effort? Well, please, welcome Invisi-Shell, written by *Omer Yair*.
    The tool hooks .NET assemblies via the CLR Profiler API, making PowerShell security
    controls blind. For more details, I highly encourage you to read the tools code[36]
    and watch the original talk presented by the author on DerbyCon. But keep in mind
    that the tool is quite old and is easily detected by most security solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The most up-to-date tool to achieve all this was written by *mgeeky* and is
    called **Stracciatella**[37]. This tool is based on the SharpPick technique (launch
    PowerShell code from within a C# assembly using runspaces) with AMSI, ETW, and
    PowerShell Logging bypasses incorporated inside. Still, some AV evasion will be
    required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we achieved administrator privileges on the compromised box and decided
    to disable transcription by modifying the **EnableTranscripting** registry key,
    located in **HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription**.
    This can be done with the following PowerShell command running from an elevated
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But let’s say we have a Sysmon rule, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get an event that could potentially trigger an investigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Sysmon detects registry change](image/B18964_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Sysmon detects registry change
  prefs: []
  type: TYPE_NORMAL
- en: Another good example of Sysmon detection is AMSI provider deletion via the registry,
    which will create event ID 13 in the log. All the providers have their unique
    keys. For example, Windows Defender has **HKLM:\SOFTWARE\Microsoft\AMSI\Providers\{2781761E-28E0-4109-99FE-B9D127C57AFE}**.
    Sysmon can provide much more from a detection perspective if you examine the published
    configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another good example for Sysmon is network connection detection. Let’s try
    to run something like the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Sysmon will detect activity, but not prevent the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Suspicious outbound connection detected by Sysmon](image/B18964_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Suspicious outbound connection detected by Sysmon
  prefs: []
  type: TYPE_NORMAL
- en: We are close to concluding this section, so let’s briefly go through the possible
    ways to find and tamper with Sysmon. A great guide was created by *spotheplanet*[38].
    An adversary can check process and service names, evaluate registry keys for Sysmon
    Windows Events, and search for Sysmon configs and tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two main ways to bypass Sysmon – operate inside rules’ blind spots
    or disarm Sysmon. Rules bypass will be specific to the environment and may vary
    significantly. So, let’s have a look at what we can do to disarm Sysmon. *Olaf
    Hartong* has an excellent blog post describing possible venues for attackers[39].
    Most of the techniques mentioned require highly privileged access on the box and
    can trigger an immediate critical security incident for the blue team, but they
    are still worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sysmon service stop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppress logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access/alter configuration via registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process injection in **Sysmon.exe**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driver renaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reliable way to silence Sysmon is by using the **Invoke-Phant0m** tool[40],
    which will keep the victim’s machine online but not logging anything, because
    it kills logging threads. There are also more advanced ways to put Sysmon in quiet
    mode, such as patching the **EtwEventWrite** API[41]. There is remarkable research
    done by *Code White* that shows how Sysmon can be hooked and events can be manipulated[42].
    Particularly, I would like to mention that this way of disarming Sysmon is probably
    the most silent publicly available way, as stated that by the researchers[42]:
    “*no suspicious ProcessAccess events on Sysmon are observable via Sysmon or the
    Event Log making the detection (**supposedly) nontrivial.*”'
  prefs: []
  type: TYPE_NORMAL
- en: Another way is to unload the Sysmon driver completely using a tool called **Shhmon**[43].
    It allows the attacker to find even renamed Sysmon drivers and unload them. We
    can also use a built-in utility called **fltMC.exe** or the **misc::mflt** Mimikatz
    module for the same purpose. Anyway, there are notable events left in logs that
    can be used to hunt for this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Event Tracing for Windows (ETW)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Event Tracing for Windows** (**ETW**) is a kernel-level tracing facility
    for logging events and is intended to be used for application debugging and can
    be enabled/disabled without restarting the application/system. In short, the system
    consists of three components – controllers, providers, and consumers. Controllers
    are used to start/stop the Event Tracing session, which is used to receive events
    from providers and deliver them to consumers. To start using ETW, I can recommend
    the most detailed beginners guide[44]. *Bmcder* shows how to use the **logman**
    and **wevtutil.exe** tools, event manifests, and APIs to access ETW. At the end,
    there is a list of useful providers for the blue team. Also, it’s important to
    note that ETW is useful for collecting ongoing events rather than historical ones.
    However, the number of events is huge and will require post-processing using SIEM
    and/or Yara.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s investigate how to use ETW for .NET tooling usage visibility. There are
    two excellent blog posts by *F-Secure* on how to detect malicious use of .NET.
    Part 1[45] is dedicated to the process of loading .NET assemblies and how to gain
    visibility of them. Part 2[46] goes into the details of JIT and Interop tracing,
    showing how malicious examples of Meterpreter and SafetyKatz can be detected.
    Method names, assemblies, and common malware API calls will be a security concern
    for an insightful defender. For both offensive and defensive tests, we can use
    a great tool created by *FuzzySec* called **SilkETW**[47]. Essentially, it is
    a set of wrappers for ETW that we can use in real time for collecting and filtering
    .NET events from **Microsoft-Windows-DotNETRuntime** and other providers. We can
    further enhance our analysis by applying known indicators of compromise from Yara.
    Following is a simple example of running renamed Seatbelt[48]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Process Hacker shows loaded .NET assemblies](image/B18964_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – Process Hacker shows loaded .NET assemblies
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start SilkETW by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After the launch of the SilkETW process, 820 events have been collected already.
    We execute Seatbelt to get system information by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The number of events goes up to 1,763, and some of them include indicators
    of compromise. Going through these events allows security products such as Yara
    or modern AV/EDR solutions to detect our activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – SilkETW in action](image/B18964_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – SilkETW in action
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the corresponding log entries is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Multiple Seatbelt entries inside the log](image/B18964_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Multiple Seatbelt entries inside the log
  prefs: []
  type: TYPE_NORMAL
- en: We have two main strategies to avoid detection – tamper with ETW or use some
    kind of obfuscation. One example of an open source protector is **ConfuserEx**[49].
    It still leaves some IOCs, but it can be a good starting point, as was demonstrated
    in the blog post by *White* *Knight Labs*[50].
  prefs: []
  type: TYPE_NORMAL
- en: A more promising way to bypass ETW is to hide tradecraft from it. *XPN* published
    great research on how to do it in his blog[51]. The idea has much in common with
    AMSI bypass – patch the call to **ntdll!EtwEventWrite** in a way that will not
    log anything. Another way to achieve the same result was demonstrated by *Cneelis*
    in his TamperETW[52] example.
  prefs: []
  type: TYPE_NORMAL
- en: To observe ETW in action, I encourage you to read an excellent blog post by
    *mez0*[53]. The author demonstrates .NET provider creation, simple .NET loader
    detection, and ETW neutralization. Repairing the ETW provider after execution
    is demonstrated as well. Links to relevant research and an overview of other security
    ETW providers are included as well, making this research unique and distinguishable.
  prefs: []
  type: TYPE_NORMAL
- en: A list of other ETW tampering techniques was published by *Palantir* in their
    blog[54]. Two of these techniques (Autologger provider removal and provider **Enable**
    property modification) will require reboot, and all of them require at least administrator
    privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we demonstrated the basic concepts of evasion for common security
    controls. This is just the tip of the iceberg, as we did not cover AV/EDR bypass,
    tool customization, shellcode loaders, and much more. We covered built-in controls
    (AMSI) as well as enhanced security components that can be deployed by Group Policies
    in the domain (AppLocker and Enhanced PowerShell Security). Then, we had a look
    at possible detection mechanisms that can be enforced in Windows with the help
    of Sysmon and ETW.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapters, we are going to use different tools and focus on concepts.
    We will run tools on machines with Microsoft Defender disabled. It is important
    to show that evasion is a vital part of the process and always comes first. The
    key to success is to know what our tools are doing under the hood, and what IOCs
    we leave on compromised machines.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be devoted to domain enumeration. We will see how it can
    be done with different tools, what the well-known patterns are for such activities,
    and how not to miss important bits.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Process Hacker: [https://processhacker.sourceforge.io/](https://processhacker.sourceforge.io/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'API monitor: [http://www.rohitab.com/apimonitor](http://www.rohitab.com/apimonitor)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AMSI bypass list by *S3cur3Th1sSh1t:*  [https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell](https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AMSI bypass list by *Pentestlaboratories:*  [https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/](https://pentestlaboratories.com/2021/05/17/amsi-bypass-methods/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke-Obfuscation script: [https://github.com/danielbohannon/Invoke-Obfuscation](https://github.com/danielbohannon/Invoke-Obfuscation)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Nishang project: [https://github.com/samratashok/nishang](https://github.com/samratashok/nishang)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Powercat: [https://github.com/besimorhino/powercat](https://github.com/besimorhino/powercat)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Persistence via AMSI: [https://pentestlab.blog/2021/05/17/persistence-amsi/](https://pentestlab.blog/2021/05/17/persistence-amsi/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Threat Hunting AMSI bypasses by Pentest Laboratories: [https://pentestlaboratories.com/2021/06/01/threat-hunting-amsi-bypasses/](https://pentestlaboratories.com/2021/06/01/threat-hunting-amsi-bypasses/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hunt for AMSI bypasses by *F-Secure*: [https://blog.f-secure.com/hunting-for-amsi-bypasses/](https://blog.f-secure.com/hunting-for-amsi-bypasses/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tiraniddo’s research about Applocker internals: [https://www.tiraniddo.dev/2019/11/the-internals-of-applocker-part-1.xhtml](https://www.tiraniddo.dev/2019/11/the-internals-of-applocker-part-1.xhtml)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sensitive PowerShell capabilities constrained by CLM: [https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/#what-does-constrained-language-constrain](https://devblogs.microsoft.com/powershell/powershell-constrained-language-mode/#what-does-constrained-language-constrain)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AppLocker beginners guide: [https://www.hackingarticles.in/windows-applocker-policy-a-beginners-guide/](https://www.hackingarticles.in/windows-applocker-policy-a-beginners-guide/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AppLocker bypass using InstallUtil: [https://www.ired.team/offensive-security/code-execution/t1118-installutil](https://www.ired.team/offensive-security/code-execution/t1118-installutil)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AppLocker bypass using MSBuild: [https://www.ired.team/offensive-security/code-execution/using-msbuild-to-execute-shellcode-in-c](https://www.ired.team/offensive-security/code-execution/using-msbuild-to-execute-shellcode-in-c)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AppLocker bypass list project: [https://github.com/api0cradle/UltimateAppLockerByPassList](https://github.com/api0cradle/UltimateAppLockerByPassList)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PowerShdll project uses PowerShell automation DLLs: [https://github.com/p3nt4/PowerShdll](https://github.com/p3nt4/PowerShdll)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PSBypassCLM project to create a wrapper over InstalUtil: [https://github.com/padovah4ck/PSByPassCLM](https://github.com/padovah4ck/PSByPassCLM)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bypass-CLM project to patch the return value: [https://github.com/calebstewart/bypass-clm](https://github.com/calebstewart/bypass-clm)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bypass CLM with the help of COM: [https://blog.xpnsec.com/constrained-language-mode-bypass/](https://blog.xpnsec.com/constrained-language-mode-bypass/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bypass CLM by setting the HKCU environment value: [https://sp00ks-git.github.io/posts/CLM-Bypass/](https://sp00ks-git.github.io/posts/CLM-Bypass/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AaronLocker project: [https://github.com/microsoft/AaronLocker](https://github.com/microsoft/AaronLocker)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy WDAC and AppLocker: [https://improsec.com/tech-blog/one-thousand-and-one-application-blocks](https://improsec.com/tech-blog/one-thousand-and-one-application-blocks)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sysmon: [https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon](https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sysmon Community Guide: [https://github.com/trustedsec/SysmonCommunityGuide](https://github.com/trustedsec/SysmonCommunityGuide)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sysmon config version by *SwiftOnSecurity*: [https://github.com/SwiftOnSecurity/sysmon-config](https://github.com/SwiftOnSecurity/sysmon-config)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sysmon config version by *Florian* *Roth*: [https://github.com/Neo23x0/sysmon-config](https://github.com/Neo23x0/sysmon-config)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sysmon config version by *Olaf* *Hartong*: [https://github.com/olafhartong/sysmon-modular](https://github.com/olafhartong/sysmon-modular)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ScriptBlock Logging bypass by *cobbr.io*: [https://cobbr.io/ScriptBlock-Logging-Bypass.xhtml](https://cobbr.io/ScriptBlock-Logging-Bypass.xhtml)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ScriptBlock Warning Event Logging by cobbr.io: [https://cobbr.io/ScriptBlock-Warning-Event-Logging-Bypass.xhtml](https://cobbr.io/ScriptBlock-Warning-Event-Logging-Bypass.xhtml)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DeepBlue: [https://github.com/sans-blue-team/DeepBlueCLI](https://github.com/sans-blue-team/DeepBlueCLI)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Newish bypasses Part 1: [https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-1/](https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-1/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Newish bypasses Part 2: [https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-2/](https://www.bc-security.org/post/powershell-logging-obfuscation-and-some-newish-bypasses-part-2/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PowerShell Protect Module: [https://blog.ironmansoftware.com/protect-logging-bypass/](https://blog.ironmansoftware.com/protect-logging-bypass/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bypass of EnableTranscripting: [https://avantguard.io/en/blog/powershell-enhanced-logging-capabilities-bypass](https://avantguard.io/en/blog/powershell-enhanced-logging-capabilities-bypass)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invisi-Shell tool: [https://github.com/OmerYa/Invisi-Shell](https://github.com/OmerYa/Invisi-Shell)
    and [https://www.youtube.com/watch?v=Y3oMEiySxcc](https://www.youtube.com/watch?v=Y3oMEiySxcc)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stracciatella tool: [https://github.com/mgeeky/Stracciatella](https://github.com/mgeeky/Stracciatella)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Detect Sysmon: [https://www.ired.team/offensive-security/enumeration-and-discovery/detecting-sysmon-on-the-victim-host](https://www.ired.team/offensive-security/enumeration-and-discovery/detecting-sysmon-on-the-victim-host)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sysmon tampering: [https://medium.com/@olafhartong/endpoint-detection-superpowers-on-the-cheap-part-3-sysmon-tampering-49c2dc9bf6d9](mailto:https://medium.com/@olafhartong/endpoint-detection-superpowers-on-the-cheap-part-3-sysmon-tampering-49c2dc9bf6d9)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Phant0m tool: [https://github.com/hlldz/Phant0m](https://github.com/hlldz/Phant0m)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SysmonQuiet: [https://github.com/ScriptIdiot/SysmonQuiet](https://github.com/ScriptIdiot/SysmonQuiet)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SysmonEnte: [https://codewhitesec.blogspot.com/2022/09/attacks-on-sysmon-revisited-sysmonente.xhtml](https://codewhitesec.blogspot.com/2022/09/attacks-on-sysmon-revisited-sysmonente.xhtml)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Shhmon: [https://github.com/matterpreter/Shhmon](https://github.com/matterpreter/Shhmon)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ETW beginner’s guide: [https://bmcder.com/blog/a-begginers-all-inclusive-guide-to-etw](https://bmcder.com/blog/a-begginers-all-inclusive-guide-to-etw)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Detect malicious usage of .NET part 1: [https://blog.f-secure.com/detecting-malicious-use-of-net-part-1/](https://blog.f-secure.com/detecting-malicious-use-of-net-part-1/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Detect malicious usage of .NET part 2: [https://blog.f-secure.com/detecting-malicious-use-of-net-part-2/](https://blog.f-secure.com/detecting-malicious-use-of-net-part-2/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SilkETW: [https://github.com/mandiant/SilkETW](https://github.com/mandiant/SilkETW)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Seatbelt: [https://github.com/GhostPack/Seatbelt](https://github.com/GhostPack/Seatbelt)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ConfuserEx: [https://github.com/mkaring/ConfuserEx](https://github.com/mkaring/ConfuserEx)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bypass ETW by neutering the EtwEventWrite API: [https://whiteknightlabs.com/2021/12/11/bypassing-etw-for-fun-and-profit/](https://whiteknightlabs.com/2021/12/11/bypassing-etw-for-fun-and-profit/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Patch EtwEventWrite API: [https://blog.xpnsec.com/hiding-your-dotnet-etw/](https://blog.xpnsec.com/hiding-your-dotnet-etw/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'TamperETW: [https://github.com/outflanknl/TamperETW](https://github.com/outflanknl/TamperETW)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Evade ETW and AMSI: [https://pre.empt.blog/2023/maelstrom-6-working-with-amsi-and-etw-for-red-and-blue](https://pre.empt.blog/2023/maelstrom-6-working-with-amsi-and-etw-for-red-and-blue)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tampering with ETW: [https://blog.palantir.com/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63](https://blog.palantir.com/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These aids for further study will let you dive deeper into the attacks covered
    in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Great blog post with ready-to-use code for AmsiScanBufferBypass: [https://fatrodzianko.com/2020/08/25/getting-rastamouses-amsiscanbufferbypass-to-work-again/](https://fatrodzianko.com/2020/08/25/getting-rastamouses-amsiscanbufferbypass-to-work-again/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Excellent blog post about PowerShell CLM and examples of rule evaluation: [https://p0w3rsh3ll.wordpress.com/2019/03/07/applocker-and-powershell-how-do-they-tightly-work-together/](https://p0w3rsh3ll.wordpress.com/2019/03/07/applocker-and-powershell-how-do-they-tightly-work-together/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is an excellent post that combines the MSBuild and InstallUtils AppLocker
    bypass methods: [https://www.blackhillsinfosec.com/powershell-without-powershell-how-to-bypass-application-whitelisting-environment-restrictions-av/](https://www.blackhillsinfosec.com/powershell-without-powershell-how-to-bypass-application-whitelisting-environment-restrictions-av/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
