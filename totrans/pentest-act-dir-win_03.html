<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer065">
<h1 class="chapter-number" id="_idParaDest-40"><a id="_idTextAnchor040"/>3</h1>
<h1 id="_idParaDest-41"><a id="_idTextAnchor041"/>Domain Reconnaissance and Discovery</h1>
<p>This chapter will focus on domain enumeration. Even if the methodology looks obvious and straightforward, the process itself can seem daunting, and reconnaissance is a crucial stepping stone toward successful compromise. Moreover, it is important to reiterate enumeration after every move, as new paths may open up. Sometimes enumeration can lead to a direct compromise; for example, a <a id="_idIndexMarker127"/>compromised user could read <strong class="bold">Local Administrator Password Solution</strong> (<strong class="bold">LAPS</strong>) or <strong class="bold">Group Managed Service Accounts</strong> (<strong class="bold">gMSA</strong>) passwords or could have administrator privileges on the box with <a id="_idIndexMarker128"/><span class="No-Break">unconstrained delegation.</span></p>
<p>We will briefly refresh the reconnaissance methodology and start comprehensive enumeration in different ways. We will cover the usage of<a id="_idIndexMarker129"/> built-in PowerShell modules, <strong class="bold">Windows Management Instrumentation</strong> (<strong class="bold">WMI</strong>), and <strong class="source-inline">net.exe</strong> commands, and utilize LDAP search capabilities. As a next step, we will use the PowerView and BloodHound tools. We will finish our journey with service enumeration. As a cherry on the pie, we will study <strong class="bold">Advanced Threat Analytics</strong> (<strong class="bold">ATA</strong>) detection <a id="_idIndexMarker130"/>evasion during our activities and how to understand and deal with <span class="No-Break">honey tokens.</span></p>
<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>Enumeration using built-in capabilities (PowerShell, WMI, <span class="No-Break"><strong class="source-inline">net.exe</strong></span><span class="No-Break">, LDAP)</span></li>
<li>The most common tools for enumeration (<span class="No-Break">PowerView, BloodHound)</span></li>
<li>Domain <span class="No-Break">service enumeration</span></li>
<li>Detection evasion for ATA and <span class="No-Break">honey tokens</span></li>
</ul>
<h1 id="_idParaDest-42"><a id="_idTextAnchor042"/>Technical requirements</h1>
<p>For this chapter, the technical requirements are <span class="No-Break">as follows:</span></p>
<ul>
<li>VMware Workstation or Oracle VirtualBox with at least 16 GB of RAM, 8 CPU cores, and at least 55 GB of total space (more if you <span class="No-Break">take snapshots)</span></li>
<li>A Linux-based operating system is <span class="No-Break">strongly recommended</span></li>
<li>Vagrant installed with a plugin for a corresponding virtualization platform <span class="No-Break">and Ansible</span></li>
<li>A deployed version of DetectionLab for ATA <span class="No-Break">cases (</span><a href="https://www.detectionlab.network/introduction/prerequisites/"><span class="No-Break">https://www.detectionlab.network/introduction/prerequisites/</span></a><span class="No-Break">)</span></li>
<li>From the GOADv2 project, we will use DC01, DC02, SRV01, <span class="No-Break">and SRV03</span></li>
</ul>
<h1 id="_idParaDest-43"><a id="_idTextAnchor043"/>Enumeration using built-in capabilities</h1>
<p>In our scenario, we have established an initial foothold, successfully identifying and evading defensive security measures. For the next step, we need a better understanding of the environment we have landed in. All our reconnaissance actions could be under close monitoring by the blue team. Later, we will run various commands and tools, examine Windows event logs, and generate traffic. The purpose of such an exercise is to understand what protocols are used under the hood and what indicators of compromise can be left <span class="No-Break">during </span><span class="No-Break"><a id="_idIndexMarker131"/></span><span class="No-Break">enumeration.</span></p>
<p>Before jumping to the hands-on part, let us go through a brief overview of the enumeration methodology we are going to follow. My approach will be to go from a higher level of abstraction to a <span class="No-Break">low one.</span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor044"/>PowerShell cmdlet</h2>
<p>We are<a id="_idIndexMarker132"/> going to enumerate an<a id="_idIndexMarker133"/> Active Directory environment, starting with forests, domains, and trust relationships between them. For the next step, we will enumerate each domain separately, getting information <a id="_idIndexMarker134"/>about <strong class="bold">Organizational Units</strong> (<strong class="bold">OUs</strong>) and groups containing <a id="_idIndexMarker135"/>respective users and computers, finishing with domain <strong class="bold">Group Policy Objects</strong> (<strong class="bold">GPOs</strong>) and <strong class="bold">Access Control Lists</strong> (<strong class="bold">ACLs</strong>). With PowerShell, you have multiple ways to perform <a id="_idIndexMarker136"/>enumeration. There is an Active Directory cmdlet, but it is installed by default only on domain controllers. But this is not a big deal! There is an amazing project, created by <em class="italic">Nikhil Mittal</em>, called ADModule. The idea is that we copy a Microsoft signed DLL for the Active Directory cmdlet and without any RSAT installation and administrative privileges, use a cmdlet for enumeration. Also, it is possible to keep everything in memory without touching the disk. The main drawback of ADModule project is that it is not maintained anymore, so no new commands will be available. It is important to<a id="_idIndexMarker137"/> mention that the PowerShell Active Directory cmdlet requires <strong class="bold">Active Directory Web Services </strong>(<strong class="bold">ADWS</strong>) running on port <strong class="source-inline">9389</strong>. We can see it in<a id="_idIndexMarker138"/> the <a id="_idIndexMarker139"/>fourth connection packet in the Wireshark <span class="No-Break">packet capture:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<img alt="Figure 3.1 – Connection to ADWS on port 9389" height="443" src="image/B18964_03_01.jpg" width="1185"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Connection to ADWS on port 9389</p>
<p>The complete list of available commands can be viewed by running <span class="No-Break">the following:</span></p>
<pre class="console">
Get-Command -Module ActiveDirectory</pre> <p>Using such a<a id="_idIndexMarker140"/> module has obvious advantages; for example, no antivirus bypass is required, all execution happens in memory, and the traffic blends well in the environment if no special detection rules are applied. Defenders<a id="_idIndexMarker141"/> can block port <strong class="source-inline">9389</strong>, disable ADWS, and/or create alerts in case traffic goes to this port. But it fully depends on the target environment – in most cases, such activity will be treated as a normal one. Next, we will discuss enumeration using WMI as another option available by default on every machine in <span class="No-Break">the domain.</span></p>
<h2 id="_idParaDest-45"><a id="_idTextAnchor045"/>WMI</h2>
<p><strong class="bold">WMI</strong> is <a id="_idIndexMarker142"/>a Microsoft<a id="_idIndexMarker143"/> implementation <a id="_idIndexMarker144"/>of <strong class="bold">Web-Based Enterprise Management</strong> (<strong class="bold">WBEM</strong>). WMI uses the <strong class="bold">Common Information Model</strong> (<strong class="bold">CIM</strong>) for <a id="_idIndexMarker145"/>the representation of <span class="No-Break">managed components.</span></p>
<p>To check WMI in action, I highly recommend reading five blog posts written by <em class="italic">0xinfection</em>[2]. WMI is available in PowerShell, so we will use it for Active Directory enumeration. Also, WMI operations <a id="_idIndexMarker146"/>can be performed from the command line by using the <strong class="bold">WMI command line</strong> (<strong class="bold">WMIC</strong>). WMI has a provider called <strong class="source-inline">root\directory\ldap</strong>, which we will use for our interaction with <span class="No-Break">Active Directory.</span></p>
<p>Let us run a command from the following example to find the domain name and see what traffic will <span class="No-Break">be sent:</span></p>
<pre class="console">
Get-WmiObject -Namespace root\directory\ldap -Class ds_domain | select ds_dc, ds_distinguishedname, pscomputername</pre> <p>I am not going to discuss every packet in the capture, but in plain words, the following high-level <span class="No-Break">steps occurred:</span></p>
<ol>
<li>Kerberos authentication <span class="No-Break">took place.</span></li>
<li>There was an LDAP bind request <span class="No-Break">and response.</span></li>
<li>There were search requests from the attacker and corresponding <span class="No-Break">result entries.</span></li>
</ol>
<p>After completing the preceding steps, we will receive the <span class="No-Break">following output:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Figure 3.2 – Result for the current domain" height="98" src="image/B18964_03_02.jpg" width="1164"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Result for the current domain</p>
<p>In the respective Wireshark window, we can see that it took 11 LDAP queries/replies to receive the information from the <span class="No-Break">preceding screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 3.3 – Wireshark traffic capture after getting the current domain information" height="279" src="image/B18964_03_03.jpg" width="745"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Wireshark traffic capture after getting the current domain information</p>
<p>It is important to<a id="_idIndexMarker147"/> mention that this<a id="_idIndexMarker148"/> traffic flow is solely between the domain controller and the compromised machine. We can see that WMI relies on LDAP, which we will <span class="No-Break">cover later.</span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor046"/>net.exe</h2>
<p>Another built-in tool for <a id="_idIndexMarker149"/>domain enumeration is <a id="_idIndexMarker150"/><strong class="source-inline">net.exe</strong>. In this section, we will enumerate domain users with the <span class="No-Break">following command:</span></p>
<pre class="console">
net user /domain</pre> <p>The result of running the preceding command is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<img alt="Figure 3.4 – Domain user enumeration using the net.exe command" height="280" src="image/B18964_03_04.jpg" width="870"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Domain user enumeration using the net.exe command</p>
<p>In this case, traffic sent by our machine will use a distinct set of protocols – SMBv2, DCERPC, and SAMR. This is important to understand as usage of some protocols can be a good indicator of compromise. We will see that later in <span class="No-Break">the chapter.</span></p>
<p>A high-level explanation of <a id="_idIndexMarker151"/>how <strong class="bold">Security Account Manager Remote</strong> (<strong class="bold">SAMR</strong>) works was published with BloodHound use in mind[3]. We will use the information from all three blog posts later in the chapter when we analyze SharpHound behavior. In short, our machine opens an SMB connection to the domain controller, then binds itself to <strong class="source-inline">\PIPE\samr</strong>, which is exported via <strong class="source-inline">IPC$</strong> share and uses SAMR queries to extract information <span class="No-Break">about users.</span></p>
<p>Here is a<a id="_idIndexMarker152"/> Wireshark<a id="_idIndexMarker153"/> <span class="No-Break">traffic capture:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<img alt="Figure 3.5 – MS-RPC in traffic capture" height="556" src="image/B18964_03_05.jpg" width="1644"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – MS-RPC in traffic capture</p>
<p>All the preceding enumeration methods were shown using a Windows-based system. But what if we have access to a Linux machine? In the next section, we will use <strong class="bold">Lightweight Directory Access Protocol</strong> (<strong class="bold">LDAP</strong>) search <a id="_idIndexMarker154"/>queries together with popular <span class="No-Break">Linux tools.</span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor047"/>LDAP</h2>
<p>LDAP is a <a id="_idIndexMarker155"/>directory service protocol that provides a mechanism to <a id="_idIndexMarker156"/>connect, search, and modify directories. There is an excellent wiki available for free online[4] where you can find relevant LDAP query examples for Active Directory. To understand how we can apply it to something meaningful enumeration-wise, I highly recommend going through an excellent presentation made by <em class="italic">ropnop</em> in <span class="No-Break">Thotcon 2018[5].</span></p>
<p>In the<a id="_idIndexMarker157"/> previous examples, we performed enumeration in the domain user context using a valid set of credentials. But what if we do not have one yet? In rare cases, some older environments may allow NULL sessions for enumeration with the <span class="No-Break">following command:</span></p>
<pre class="console">
rpcclient –U"%" IPAddress</pre> <p>A fresh point of view was shared by <em class="italic">Reino Mostert</em>, who talked about the three ways to enumerate users on Windows domain controllers[6] and supplemented his research with <span class="No-Break">the tool[7].</span></p>
<p>To sum up, as an unauthenticated domain user, we can run <strong class="source-inline">nbtscan</strong>, <strong class="source-inline">dig</strong>, <strong class="source-inline">ldapsearch</strong>, and in some cases, <strong class="source-inline">rpcclient</strong> to retrieve the domain name, domain controllers, and computer <span class="No-Break">NetBIOS names:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<img alt="Figure 3.6 – Enumeration without domain user credentials" height="1002" src="image/B18964_03_06.jpg" width="976"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Enumeration without domain user credentials</p>
<p>Obtaining<a id="_idIndexMarker158"/> our first set of valid domain user credentials will open an avenue for more information, as can be seen in the <span class="No-Break">following screenshot.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<img alt="Figure 3.7 – Authenticated enumeration using rpcclient" height="934" src="image/B18964_03_07.jpg" width="804"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Authenticated enumeration using rpcclient</p>
<p>Please be<a id="_idIndexMarker159"/> careful as, depending on the Windows version, some of the SAMR queries do not work, but NETLOGON and LSARPC are still fine. This is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<img alt="Figure 3.8 – SAMR queries failed" height="344" src="image/B18964_03_08.jpg" width="752"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – SAMR queries failed</p>
<p>LDAP queries<a id="_idIndexMarker160"/> will provide more flexibility than predefined searches in <strong class="source-inline">rpcclient</strong> or <strong class="source-inline">enum4linux</strong>. We can use <strong class="source-inline">ldapsearch</strong>[8] and/or <strong class="source-inline">windapsearch</strong>[9]. We can enumerate members of the administrative groups with a query, <span class="No-Break">as follows:</span></p>
<pre class="console">
ldapsearch -LLL -x -H ldap://kingslanding.sevenkingdoms.local -D "lord.varys@sevenkingdoms.local" -w 'Qwerty123!' -b dc=sevenkingdoms,dc=local "adminCount=1" dn | grep "dn:"</pre> <p>Running the preceding command would result in the <span class="No-Break">following output:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<img alt="Figure 3.9 – List objects with attribute adminCount=1" height="376" src="image/B18964_03_09.jpg" width="1610"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – List objects with attribute adminCount=1</p>
<p>We have discussed ways to perform enumeration manually and analyzed traffic to understand underlying protocol usage. Now, we will discuss the most common tools that are used to perform enumeration in an automated or <span class="No-Break">semi-automated way.</span></p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor048"/>Enumeration tools</h1>
<p>The most common tools used for <a id="_idIndexMarker161"/>domain enumeration are PowerView or SharpView and SharpHound together <span class="No-Break">with BloodHound.</span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor049"/>SharpView/PowerView</h2>
<p>SharpView[10] is a .NET port <a id="_idIndexMarker162"/>of PowerView[11]. This tool has a wide variety of methods<a id="_idIndexMarker163"/> that can improve and speed up the<a id="_idIndexMarker164"/> enumeration process in complex environments. I can recommend reading the PowerView wiki[12], as it explains in detail how the tool runs queries. Let us grab the version from GitHub, compile it, and follow our methodology. We will not run Wireshark for every command, but choose one as an example to understand what traces are left behind us. To make our life easier, I used the <span class="No-Break"><strong class="source-inline">Get-DomainSID</strong></span><span class="No-Break"> command:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<img alt="Figure 3.10 – Result of the Get-DomainSID command" height="110" src="image/B18964_03_10.jpg" width="1129"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Result of the Get-DomainSID command</p>
<p>The following Wireshark capture shows a few DNS requests for the domain LDAP SRV, then a mix of CLDAP and LDAP queries/responses, together with Kerberos authentication. Overall, 265 packets <span class="No-Break">were captured:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<img alt="Figure 3.11 – Wireshark capture for the Get-DomainSID command" height="548" src="image/B18964_03_11.jpg" width="1572"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Wireshark capture for the Get-DomainSID command</p>
<p>The following list shows<a id="_idIndexMarker165"/> the most common enumeration commands that you will use during almost every engagement. Command names are self-explanatory. For extra options and keys, follow the <span class="No-Break">official guide:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">Get-Forest</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-ForestDomain</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-ForestTrust</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-Domain</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-DomainTrust</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-DomainController</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-DomainOU</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-DomainGroup</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-DomainGroupMember</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-DomainUser</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-DomainComputer</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-DomainGPO</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-DomainForeignUser</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-DomainForeignGroupMember</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Invoke-ACLScanner</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Find-LocalAdminAccess</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Find-DomainShare</strong></span></li>
</ul>
<p>As an example, I will <a id="_idIndexMarker166"/>show how SharpView commands can help in forest enumeration. Enumeration is performed as a standard user. After running only three commands, we know the domain SID of the root domain and all domains in the forest, including domain controllers’ names, and that there is a bidirectional trust between two forests. The result of forest enumeration is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<img alt="Figure 3.12 – Result of forest enumeration using SharpView" height="691" src="image/B18964_03_12.jpg" width="903"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – Result of forest enumeration using SharpView</p>
<p>After collecting all the<a id="_idIndexMarker167"/> forest and domain information, we need to analyze it. We are interested in finding a way to chain allowed trust and access with misconfigurations to progress further. What if there was a tool that can help to get all the bits together in some automated way? Let us welcome and <span class="No-Break">discuss BloodHound!</span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor050"/>BloodHound</h2>
<p><em class="italic">Defenders think in lists. Attackers think in graphs. As long as this is true, attackers win.</em> This great quote is <a id="_idIndexMarker168"/>from <em class="italic">John Lambert</em>. I think such a shift in thinking can help us<a id="_idIndexMarker169"/> to understand the full power of <strong class="bold">BloodHound</strong>[13]. This tool utilizes graph theory to help the attacker find relationships between objects within Active Directory that were not intended to exist or could be abused for further compromise. To make the magic happen, we need the SharpHound data collector[14] and BloodHound. Our goal is to understand how these tools work and the benefits of using them. SharpHound has several collection methods, and before using all of them, we need to understand the implications. For example, methods such as RDP, DCOM, PSRemote, LocalAdmin, and LoggedOn are very noisy and generate a lot of traffic as they will connect to each computer in the domain to retrieve the <span class="No-Break">requested information.</span></p>
<p>After running SharpHound with the default collection options and uploading the results to BloodHound, we can find<a id="_idIndexMarker170"/> promising paths such as in the following screenshot, where <strong class="source-inline">tywin.lannister</strong> can change the password of another user and add himself to <span class="No-Break">a group:</span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<img alt="Figure 3.13 – ACL misconfiguration found by BloodHound" height="222" src="image/B18964_03_13.jpg" width="319"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – ACL misconfiguration found by BloodHound</p>
<p>It can be the case that<a id="_idIndexMarker171"/> pre-defined queries in BloodHound are not enough to find the next move. Then, we can write them ourselves and/or use published <span class="No-Break">custom queries[15].</span></p>
<p>To get more insights about <a id="_idIndexMarker172"/>BloodHound internals, there are three blog posts written by <em class="italic">Sven Defatsch</em>[3]. In these articles, he discusses user and session enumeration via different methods. We are not going to replicate the full research but will briefly have a look at the traffic to confirm the results. We will start data collection for sessions alongside <span class="No-Break">packet capture:</span></p>
<pre class="console">
SharpHound.exe -d sevenkingdoms.local –CollectionMethods Session --Stealth</pre> <p>The preceding command created the following <span class="No-Break">data capture:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<img alt="Figure 3.14 – Session collection" height="450" src="image/B18964_03_14.jpg" width="1653"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Session collection</p>
<p>As we can see, the traffic is the<a id="_idIndexMarker173"/> same as in the original research. There are plenty of collection methods with different levels of noise. Also, it depends on what you are hunting for. General advice is to use the <strong class="source-inline">--Jitter</strong> and <strong class="source-inline">--Throttle</strong> options to create a delay between requests. The <strong class="source-inline">--Stealthy</strong> option forces SharpHound to behave differently, however, it may also influence the <span class="No-Break">collection quality.</span></p>
<p>To summarize, the data collector gets information using various named pipes and protocols over an SMB connection with <span class="No-Break">Kerberos authentication.</span></p>
<p>However, there is another way to explore the target Active Directory. <strong class="bold">ADExplorer</strong>[16] is a tool written by Microsoft that not only allows viewing and editing objects but also supports snapshots. I highly encourage you to read the post about ADExplorer usage during engagements by <em class="italic">api0cradle</em>[18]. Using the tool, written by <em class="italic">c3c</em>[18], we can convert snapshots to<a id="_idIndexMarker174"/> BloodHound-compatible JSON files. Obviously, as there is no network interaction with systems, information such as the local administrator list and sessions will be missing. The only OpSec consideration when doing a snapshot is to keep in mind that a large volume of data will be collected. However, detection of Active Directory data collection is not easy, as mentioned <span class="No-Break">by </span><span class="No-Break"><em class="italic">FalconForce</em></span><span class="No-Break">[19].</span></p>
<p>After collecting all available information about the domain, next, we will focus on services deployed inside the domain and will briefly have a look at the user <span class="No-Break">hunting process.</span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor051"/>Enumerating services and hunting for users</h1>
<p>To continue our enumeration, the next step will be to identify available services, file and SQL servers, and the privileged users’ activity in the domain. As we discussed at the beginning of this chapter, our target is to get access to critical data and services in the <span class="No-Break">compromised environment.</span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/>SPN</h2>
<p><strong class="bold">Service Principal Names</strong> (<strong class="bold">SPNs</strong>) are<a id="_idIndexMarker175"/> the names by which a Kerberos client uniquely identifies instances of a service for a given Kerberos target computer. There is a comprehensive list of known SPNs for Active Directory held by <em class="italic">PyroTek3</em>[20]. We can use them to better understand what services are present in the domain and use <span class="No-Break">Kerberos authentication.</span></p>
<p>We can enumerate SPN in the domain by using the <strong class="source-inline">setspn</strong> utility or SharpView with the following commands to find users and computers <span class="No-Break">with SPNs:</span></p>
<pre class="console">
Get-DomainComputer -ServicePrincipalName "*"
Get-DomainUser -SPN</pre> <p>To get all SPNs with the <strong class="source-inline">setspn</strong> utility, we can run the <span class="No-Break">following command:</span></p>
<pre class="console">
setspn -T sevenkingdoms.local -F -Q */*</pre> <p>As a result, we received a lengthy list of SPNs. We can narrow the list down by using the <strong class="source-inline">-L</strong> switch for a specific server or user. Following are some promising findings after running the <span class="No-Break">preceding command:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<img alt="Figure 3.15 – SPN in the sevenkingdoms forest" height="125" src="image/B18964_03_15.jpg" width="611"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – SPN in the sevenkingdoms forest</p>
<p>The next target to hunt for in the domain is a file server. Sometimes it can even have open shares or shares we have “write” permissions on. In <a href="B18964_05.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we will show how to get an advantage from writable shares, but first we need to <span class="No-Break">find them.</span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor053"/>The file server</h2>
<p>The file server is a <a id="_idIndexMarker176"/>great resource of information. If an attacker compromises a user with wide access rights across the organization, then there is a chance to just pull all the required information from file shares. There are a few options in SharpView for file server enumeration. They are <span class="No-Break">as follows:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">Get-DomainFileServer</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Find-DomainShare -CheckShareAccess</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Find-InterestingFile</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Find-InterestingDomainShareFile</strong></span></li>
</ul>
<h2 id="_idParaDest-54"><a id="_idTextAnchor054"/>User hunting</h2>
<p>User hunting is more of an <a id="_idIndexMarker177"/>art rather than a process. A great presentation[21] was created by <em class="italic">harmj0y</em> that shows the general approach. It may look like a straightforward process for a small environment, but if there are thousands of users across multiple domains and forests, it is not. Locating the right user for the hunt is the most vital step. For privileged users, we can first identify them by using the following command <span class="No-Break">from SharpView:</span></p>
<pre class="console">
Get-DomainUser -AdminCount -Properties samaccountname</pre> <p>The following is the list of privileged users in <span class="No-Break">the domain:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<img alt="Figure 3.16 – List of users with the AdminCount=1 attribute" height="368" src="image/B18964_03_16.jpg" width="1236"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – List of users with the AdminCount=1 attribute</p>
<p>As the next step, we can run various commands, such as <span class="No-Break">the following:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">Find-DomainUserLocation</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">Get-NetSession</strong></span></li>
<li><strong class="source-inline">Invoke-UserHunter -</strong><span class="No-Break"><strong class="source-inline">Stealth -ShowAll</strong></span></li>
</ul>
<p>Just be careful as the first and last commands without the <strong class="source-inline">Stealth</strong> switch (<a href="http://www.labofapenetrationtester.com/2018/10/deploy-deception.xhtml">http://www.labofapenetrationtester.com/2018/10/deploy-deception.xhtml</a>) will generate a lot of noise by querying every machine in the domain. In the next section, we will cover some detections and ways to avoid them <span class="No-Break">during enumeration.</span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor055"/>Enumeration detection evasion</h1>
<p>Enumeration can be a noisy process<a id="_idIndexMarker178"/> if tools are used without precautions. Also, defenders hunt for reconnaissance activities by using security products and deception methods. These methods are like a hidden bell in a dark room – you need to know where it is located to avoid detection. We will cover Microsoft ATA and its successor – <strong class="bold">Defender for Identity</strong> (<strong class="bold">MDI</strong>) together <a id="_idIndexMarker179"/>with <span class="No-Break">honey tokens.</span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor056"/>Microsoft ATA</h2>
<p>Microsoft <strong class="bold">Advanced Threat Analytics</strong> (<strong class="bold">ATA</strong>) is an <a id="_idIndexMarker180"/>on-premises platform that helps to protect enterprises from <a id="_idIndexMarker181"/>threats. Extended support ends in 2026, so it makes sense to quickly <span class="No-Break">cover it.</span></p>
<p>In this section, we will discuss only detections for recon methods; other attacks and bypasses will be covered in respective chapters. In general, ATA parses the network traffic of multiple protocols to detect malicious activity. It’s important to mention that it will take time for the tool to learn the normal behavior of the users and machines in the environment. Data collection happens on ATA Gateways. A great series of five blog posts[22] related to ATA detection and bypass was written by <em class="italic">Nikhil Mittal</em> in 2017. The general bypass strategy is to blend in existing environment traffic and limit interaction with domain controllers. <strong class="bold">Microsoft Defender for Identity</strong> (<strong class="bold">MDI</strong>) is a successor of ATA. Nikhil took a fresh look at the product and <a id="_idIndexMarker182"/>shared his research during the BruCON conference[23]. All techniques mentioned there are still truly relevant to ATA as well. Two good enumeration recommendations were given during the talk: exclude SMB session enumeration against DC and forget about any tool that utilizes the SAMR protocol. WMI and LDAP queries are a way to go for reconnaissance, but now it is recommended to request all LDAP attributes and filter <span class="No-Break">them offline.</span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor057"/>Honey tokens</h2>
<p>Another way to detect malicious <a id="_idIndexMarker183"/>activity <a id="_idIndexMarker184"/>inside the environment is to deploy and monitor decoy objects in the environment. These objects should be desirable for attackers but should never be used during normal activities. We can point to more research by <em class="italic">Nikhil Mittal</em>[24] and his ready-to-use PowerShell module[25]. Using the tool, we can deploy honey users, computers, and groups. To detect access to these objects, we need to configure Group Policy auditing[26] or we can simply add the account to honey tokens in <span class="No-Break">Microsoft ATA:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<img alt="Figure 3.17 – Honey tokens in Microsoft ATA" height="575" src="image/B18964_03_17.jpg" width="598"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – Honey tokens in Microsoft ATA</p>
<p>There are still ways an attacker can identify honey accounts by examining attributes such as <strong class="source-inline">LastLogon</strong>, <strong class="source-inline">logonCount</strong>, <strong class="source-inline">badpwdCount</strong>, <strong class="source-inline">whenCreated</strong>, and a few others. Some tools can assist in such <a id="_idIndexMarker185"/>activities, such as <strong class="source-inline">HoneypotBuster</strong>[27]. It uses an internal fake ranking system, calculated as a combination of several parameters for the account. The ranking system of the tool can be analyzed by the blue team, so honeypots may be tweaked up to the <span class="No-Break">desired level.</span></p>
<p>Another approach is<a id="_idIndexMarker186"/> to introduce false credentials inside<a id="_idIndexMarker187"/> the memory of the machines in the domain and detect credential reuse during privilege escalation attempts via a pass-the-hash attack. A great project that demonstrates such deception is <a id="_idIndexMarker188"/>called Dcept[28]. If the blue team detects such activity, they will know the exact host that was compromised and the way the attacker performed <span class="No-Break">lateral movement.</span></p>
<p>Another script, Honeyhash[29], is written<a id="_idIndexMarker189"/> in PowerShell and creates in-memory deception. It creates an in-memory fake account that will then be used by the attacker for lateral movement. A good walk-through on how to deploy and implement detections was written by the <span class="No-Break"><em class="italic">Stealthbits</em></span><span class="No-Break"> company[30].</span></p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor058"/>Summary</h1>
<p>In this chapter, we discussed available tools and protocols that attackers can use for enumeration activity. We briefly covered tooling internals to get a clear insight into the traces we left. Our methodology was to enumerate from a high level to a low level inside the environment. One of the key ideas was that enumeration is a constant process. At the end of the chapter, we went through some OpSec concerns and saw how a blue team can <span class="No-Break">deceive attackers.</span></p>
<p>In the next chapter, we will cover credential access from a domain point of view. We will not spend time on endpoint credential access, rather we will explore things such as Kerberoasting, GMSA, LAPS, different types of coerced authentication, how to abuse writable shares, <span class="No-Break">and more.</span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/>References</h1>
<ol>
<li><span class="No-Break">ADModule: </span><a href="https://github.com/samratashok/ADModule"><span class="No-Break">https://github.com/samratashok/ADModule</span></a></li>
<li>WMI basics <span class="No-Break">series: </span><a href="https://0xinfection.github.io/posts/wmi-basics-part-1/"><span class="No-Break">https://0xinfection.github.io/posts/wmi-basics-part-1/</span></a></li>
<li>Bloodhound inner workings: <a href="https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-1/">https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-1/</a>, <a href="https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/">https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/</a> <span class="No-Break">and </span><a href="https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-3/"><span class="No-Break">https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-3/</span></a></li>
<li>LDAP <span class="No-Break">wiki: </span><a href="https://ldapwiki.com/wiki/Main"><span class="No-Break">https://ldapwiki.com/wiki/Main</span></a></li>
<li>LDAP and <span class="No-Break">Kerberos: </span><a href="https://blog.ropnop.com/talk/2018/funwithldapkerb/"><span class="No-Break">https://blog.ropnop.com/talk/2018/funwithldapkerb/</span></a></li>
<li>New look on NULL session <span class="No-Break">enumeration: </span><a href="https://sensepost.com/blog/2018/a-new-look-at-null-sessions-and-user-enumeration/"><span class="No-Break">https://sensepost.com/blog/2018/a-new-look-at-null-sessions-and-user-enumeration/</span></a></li>
<li><span class="No-Break">UserEnum: </span><a href="https://github.com/sensepost/UserEnum"><span class="No-Break">https://github.com/sensepost/UserEnum</span></a></li>
<li><span class="No-Break">Ldapsearch: </span><a href="https://malicious.link/post/2022/ldapsearch-reference/"><span class="No-Break">https://malicious.link/post/2022/ldapsearch-reference/</span></a></li>
<li><span class="No-Break">Windapsearch: </span><a href="https://github.com/ropnop/windapsearch"><span class="No-Break">https://github.com/ropnop/windapsearch</span></a></li>
<li><span class="No-Break">SharpView: </span><a href="https://github.com/tevora-threat/SharpView"><span class="No-Break">https://github.com/tevora-threat/SharpView</span></a></li>
<li><span class="No-Break">PowerView: </span><a href="https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1"><span class="No-Break">https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</span></a></li>
<li>PowerView recon <span class="No-Break">wiki: </span><a href="https://powersploit.readthedocs.io/en/latest/Recon/"><span class="No-Break">https://powersploit.readthedocs.io/en/latest/Recon/</span></a></li>
<li><span class="No-Break">BloodHound: </span><a href="https://bloodhound.readthedocs.io/en/latest/"><span class="No-Break">https://bloodhound.readthedocs.io/en/latest/</span></a></li>
<li><span class="No-Break">SharpHound: </span><a href="https://bloodhound.readthedocs.io/en/latest/data-collection/sharphound.xhtml"><span class="No-Break">https://bloodhound.readthedocs.io/en/latest/data-collection/sharphound.xhtml</span></a></li>
<li>Custom BloodHound <span class="No-Break">queries: </span><a href="https://github.com/hausec/Bloodhound-Custom-Queries"><span class="No-Break">https://github.com/hausec/Bloodhound-Custom-Queries</span></a></li>
<li><span class="No-Break">ADExplorer: </span><a href="https://learn.microsoft.com/en-us/sysinternals/downloads/adexplorer"><span class="No-Break">https://learn.microsoft.com/en-us/sysinternals/downloads/adexplorer</span></a></li>
<li>ADExplorer on <span class="No-Break">engagements: </span><a href="https://www.trustedsec.com/blog/adexplorer-on-engagements/"><span class="No-Break">https://www.trustedsec.com/blog/adexplorer-on-engagements/</span></a></li>
<li><span class="No-Break">ADExplorerSnapshot: </span><a href="https://github.com/c3c/ADExplorerSnapshot.py"><span class="No-Break">https://github.com/c3c/ADExplorerSnapshot.py</span></a></li>
<li>Detect AD data <span class="No-Break">collection: </span><a href="https://falconforce.nl/falconfriday-detecting-active-directory-data-collection-0xff21/"><span class="No-Break">https://falconforce.nl/falconfriday-detecting-active-directory-data-collection-0xff21/</span></a></li>
<li>List of known <span class="No-Break">SPNs: </span><a href="https://adsecurity.org/?page_id=183"><span class="No-Break">https://adsecurity.org/?page_id=183</span></a></li>
<li>Hunt <span class="No-Break">sysadmins: </span><a href="https://www.slideshare.net/harmj0y/i-hunt-sys-admins-20"><span class="No-Break">https://www.slideshare.net/harmj0y/i-hunt-sys-admins-20</span></a></li>
<li>Evade Microsoft <span class="No-Break">ATA: </span><a href="http://www.labofapenetrationtester.com/2017/08/week-of-evading-microsoft-ata-day1.xhtml"><span class="No-Break">http://www.labofapenetrationtester.com/2017/08/week-of-evading-microsoft-ata-day1.xhtml</span></a></li>
<li>Abuse <span class="No-Break">MDI: </span><a href="https://www.youtube.com/watch?v=bzLvOu1awKM"><span class="No-Break">https://www.youtube.com/watch?v=bzLvOu1awKM</span></a></li>
<li>Deploy deception <span class="No-Break">research: </span><a href="http://www.labofapenetrationtester.com/2018/10/deploy-deception.xhtml"><span class="No-Break">http://www.labofapenetrationtester.com/2018/10/deploy-deception.xhtml</span></a></li>
<li>Deploy Deception <span class="No-Break">tool: </span><a href="https://github.com/samratashok/Deploy-Deception"><span class="No-Break">https://github.com/samratashok/Deploy-Deception</span></a></li>
<li>Group Policy configuration for AD honey <span class="No-Break">tokens: </span><a href="https://www.bordergate.co.uk/active-directory-honey-tokens/"><span class="No-Break">https://www.bordergate.co.uk/active-directory-honey-tokens/</span></a></li>
<li><span class="No-Break">HoneypotBuster: </span><a href="https://github.com/JavelinNetworks/HoneypotBuster"><span class="No-Break">https://github.com/JavelinNetworks/HoneypotBuster</span></a></li>
<li><span class="No-Break">DCEPT: </span><a href="https://github.com/secureworks/dcept"><span class="No-Break">https://github.com/secureworks/dcept</span></a></li>
<li><span class="No-Break">HoneyHash: </span><a href="https://github.com/EmpireProject/Empire/blob/dev/data/module_source/management/New-HoneyHash.ps1"><span class="No-Break">https://github.com/EmpireProject/Empire/blob/dev/data/module_source/management/New-HoneyHash.ps1</span></a></li>
<li>How to detect <span class="No-Break">honey hash:</span><a href="https://stealthbits.com/blog/implementing-detections-for-the-honeyhash/"><span class="No-Break">https://stealthbits.com/blog/implementing-detections-for-the-honeyhash/</span></a></li>
</ol>
<h1 id="_idParaDest-60"><a id="_idTextAnchor060"/>Further reading</h1>
<p>These will aid further study and allow you to dive deeper into the attacks covered in <span class="No-Break">the chapter:</span></p>
<ul>
<li>More details about WMI from <span class="No-Break">Microsoft: </span><a href="https://learn.microsoft.com/en-us/windows/win32/wmisdk/about-wmi"><span class="No-Break">https://learn.microsoft.com/en-us/windows/win32/wmisdk/about-wmi</span></a></li>
<li>Enumerate Active Directory using <span class="No-Break">WMI: </span><a href="https://0xinfection.github.io/posts/wmi-ad-enum/"><span class="No-Break">https://0xinfection.github.io/posts/wmi-ad-enum/</span></a></li>
<li>LDAP APIs in <span class="No-Break">Windows: </span><a href="https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ldap/lightweight-directory-access-protocol-ldap-api"><span class="No-Break">https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ldap/lightweight-directory-access-protocol-ldap-api</span></a></li>
</ul>
</div>
</div></body></html>