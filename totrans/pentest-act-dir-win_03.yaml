- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Domain Reconnaissance and Discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on domain enumeration. Even if the methodology looks
    obvious and straightforward, the process itself can seem daunting, and reconnaissance
    is a crucial stepping stone toward successful compromise. Moreover, it is important
    to reiterate enumeration after every move, as new paths may open up. Sometimes
    enumeration can lead to a direct compromise; for example, a compromised user could
    read **Local Administrator Password Solution** (**LAPS**) or **Group Managed Service
    Accounts** (**gMSA**) passwords or could have administrator privileges on the
    box with unconstrained delegation.
  prefs: []
  type: TYPE_NORMAL
- en: We will briefly refresh the reconnaissance methodology and start comprehensive
    enumeration in different ways. We will cover the usage of built-in PowerShell
    modules, **Windows Management Instrumentation** (**WMI**), and **net.exe** commands,
    and utilize LDAP search capabilities. As a next step, we will use the PowerView
    and BloodHound tools. We will finish our journey with service enumeration. As
    a cherry on the pie, we will study **Advanced Threat Analytics** (**ATA**) detection
    evasion during our activities and how to understand and deal with honey tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration using built-in capabilities (PowerShell, WMI, **net.exe**, LDAP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common tools for enumeration (PowerView, BloodHound)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain service enumeration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection evasion for ATA and honey tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, the technical requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: VMware Workstation or Oracle VirtualBox with at least 16 GB of RAM, 8 CPU cores,
    and at least 55 GB of total space (more if you take snapshots)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Linux-based operating system is strongly recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vagrant installed with a plugin for a corresponding virtualization platform
    and Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deployed version of DetectionLab for ATA cases ([https://www.detectionlab.network/introduction/prerequisites/](https://www.detectionlab.network/introduction/prerequisites/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the GOADv2 project, we will use DC01, DC02, SRV01, and SRV03
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumeration using built-in capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our scenario, we have established an initial foothold, successfully identifying
    and evading defensive security measures. For the next step, we need a better understanding
    of the environment we have landed in. All our reconnaissance actions could be
    under close monitoring by the blue team. Later, we will run various commands and
    tools, examine Windows event logs, and generate traffic. The purpose of such an
    exercise is to understand what protocols are used under the hood and what indicators
    of compromise can be left during enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Before jumping to the hands-on part, let us go through a brief overview of the
    enumeration methodology we are going to follow. My approach will be to go from
    a higher level of abstraction to a low one.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell cmdlet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to enumerate an Active Directory environment, starting with forests,
    domains, and trust relationships between them. For the next step, we will enumerate
    each domain separately, getting information about **Organizational Units** (**OUs**)
    and groups containing respective users and computers, finishing with domain **Group
    Policy Objects** (**GPOs**) and **Access Control Lists** (**ACLs**). With PowerShell,
    you have multiple ways to perform enumeration. There is an Active Directory cmdlet,
    but it is installed by default only on domain controllers. But this is not a big
    deal! There is an amazing project, created by *Nikhil Mittal*, called ADModule.
    The idea is that we copy a Microsoft signed DLL for the Active Directory cmdlet
    and without any RSAT installation and administrative privileges, use a cmdlet
    for enumeration. Also, it is possible to keep everything in memory without touching
    the disk. The main drawback of ADModule project is that it is not maintained anymore,
    so no new commands will be available. It is important to mention that the PowerShell
    Active Directory cmdlet requires **Active Directory Web Services** (**ADWS**)
    running on port **9389**. We can see it in the fourth connection packet in the
    Wireshark packet capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Connection to ADWS on port 9389](image/B18964_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Connection to ADWS on port 9389
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete list of available commands can be viewed by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using such a module has obvious advantages; for example, no antivirus bypass
    is required, all execution happens in memory, and the traffic blends well in the
    environment if no special detection rules are applied. Defenders can block port
    **9389**, disable ADWS, and/or create alerts in case traffic goes to this port.
    But it fully depends on the target environment – in most cases, such activity
    will be treated as a normal one. Next, we will discuss enumeration using WMI as
    another option available by default on every machine in the domain.
  prefs: []
  type: TYPE_NORMAL
- en: WMI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**WMI** is a Microsoft implementation of **Web-Based Enterprise Management**
    (**WBEM**). WMI uses the **Common Information Model** (**CIM**) for the representation
    of managed components.'
  prefs: []
  type: TYPE_NORMAL
- en: To check WMI in action, I highly recommend reading five blog posts written by
    *0xinfection*[2]. WMI is available in PowerShell, so we will use it for Active
    Directory enumeration. Also, WMI operations can be performed from the command
    line by using the **WMI command line** (**WMIC**). WMI has a provider called **root\directory\ldap**,
    which we will use for our interaction with Active Directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us run a command from the following example to find the domain name and
    see what traffic will be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'I am not going to discuss every packet in the capture, but in plain words,
    the following high-level steps occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos authentication took place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There was an LDAP bind request and response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There were search requests from the attacker and corresponding result entries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After completing the preceding steps, we will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Result for the current domain](image/B18964_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Result for the current domain
  prefs: []
  type: TYPE_NORMAL
- en: 'In the respective Wireshark window, we can see that it took 11 LDAP queries/replies
    to receive the information from the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Wireshark traffic capture after getting the current domain information](image/B18964_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Wireshark traffic capture after getting the current domain information
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention that this traffic flow is solely between the domain
    controller and the compromised machine. We can see that WMI relies on LDAP, which
    we will cover later.
  prefs: []
  type: TYPE_NORMAL
- en: net.exe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another built-in tool for domain enumeration is **net.exe**. In this section,
    we will enumerate domain users with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of running the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Domain user enumeration using the net.exe command](image/B18964_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Domain user enumeration using the net.exe command
  prefs: []
  type: TYPE_NORMAL
- en: In this case, traffic sent by our machine will use a distinct set of protocols
    – SMBv2, DCERPC, and SAMR. This is important to understand as usage of some protocols
    can be a good indicator of compromise. We will see that later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A high-level explanation of how **Security Account Manager Remote** (**SAMR**)
    works was published with BloodHound use in mind[3]. We will use the information
    from all three blog posts later in the chapter when we analyze SharpHound behavior.
    In short, our machine opens an SMB connection to the domain controller, then binds
    itself to **\PIPE\samr**, which is exported via **IPC$** share and uses SAMR queries
    to extract information about users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a Wireshark traffic capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – MS-RPC in traffic capture](image/B18964_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – MS-RPC in traffic capture
  prefs: []
  type: TYPE_NORMAL
- en: All the preceding enumeration methods were shown using a Windows-based system.
    But what if we have access to a Linux machine? In the next section, we will use
    **Lightweight Directory Access Protocol** (**LDAP**) search queries together with
    popular Linux tools.
  prefs: []
  type: TYPE_NORMAL
- en: LDAP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LDAP is a directory service protocol that provides a mechanism to connect, search,
    and modify directories. There is an excellent wiki available for free online[4]
    where you can find relevant LDAP query examples for Active Directory. To understand
    how we can apply it to something meaningful enumeration-wise, I highly recommend
    going through an excellent presentation made by *ropnop* in Thotcon 2018[5].
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous examples, we performed enumeration in the domain user context
    using a valid set of credentials. But what if we do not have one yet? In rare
    cases, some older environments may allow NULL sessions for enumeration with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A fresh point of view was shared by *Reino Mostert*, who talked about the three
    ways to enumerate users on Windows domain controllers[6] and supplemented his
    research with the tool[7].
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, as an unauthenticated domain user, we can run **nbtscan**, **dig**,
    **ldapsearch**, and in some cases, **rpcclient** to retrieve the domain name,
    domain controllers, and computer NetBIOS names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Enumeration without domain user credentials](image/B18964_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Enumeration without domain user credentials
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining our first set of valid domain user credentials will open an avenue
    for more information, as can be seen in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Authenticated enumeration using rpcclient](image/B18964_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Authenticated enumeration using rpcclient
  prefs: []
  type: TYPE_NORMAL
- en: 'Please be careful as, depending on the Windows version, some of the SAMR queries
    do not work, but NETLOGON and LSARPC are still fine. This is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – SAMR queries failed](image/B18964_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – SAMR queries failed
  prefs: []
  type: TYPE_NORMAL
- en: 'LDAP queries will provide more flexibility than predefined searches in **rpcclient**
    or **enum4linux**. We can use **ldapsearch**[8] and/or **windapsearch**[9]. We
    can enumerate members of the administrative groups with a query, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding command would result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – List objects with attribute adminCount=1](image/B18964_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – List objects with attribute adminCount=1
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed ways to perform enumeration manually and analyzed traffic
    to understand underlying protocol usage. Now, we will discuss the most common
    tools that are used to perform enumeration in an automated or semi-automated way.
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common tools used for domain enumeration are PowerView or SharpView
    and SharpHound together with BloodHound.
  prefs: []
  type: TYPE_NORMAL
- en: SharpView/PowerView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SharpView[10] is a .NET port of PowerView[11]. This tool has a wide variety
    of methods that can improve and speed up the enumeration process in complex environments.
    I can recommend reading the PowerView wiki[12], as it explains in detail how the
    tool runs queries. Let us grab the version from GitHub, compile it, and follow
    our methodology. We will not run Wireshark for every command, but choose one as
    an example to understand what traces are left behind us. To make our life easier,
    I used the **Get-DomainSID** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Result of the Get-DomainSID command](image/B18964_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Result of the Get-DomainSID command
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Wireshark capture shows a few DNS requests for the domain LDAP
    SRV, then a mix of CLDAP and LDAP queries/responses, together with Kerberos authentication.
    Overall, 265 packets were captured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Wireshark capture for the Get-DomainSID command](image/B18964_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Wireshark capture for the Get-DomainSID command
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows the most common enumeration commands that you will
    use during almost every engagement. Command names are self-explanatory. For extra
    options and keys, follow the official guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get-Forest**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-ForestDomain**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-ForestTrust**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-Domain**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-DomainTrust**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-DomainController**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-DomainOU**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-DomainGroup**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-DomainGroupMember**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-DomainUser**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-DomainComputer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-DomainGPO**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-DomainForeignUser**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-DomainForeignGroupMember**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invoke-ACLScanner**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find-LocalAdminAccess**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find-DomainShare**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, I will show how SharpView commands can help in forest enumeration.
    Enumeration is performed as a standard user. After running only three commands,
    we know the domain SID of the root domain and all domains in the forest, including
    domain controllers’ names, and that there is a bidirectional trust between two
    forests. The result of forest enumeration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Result of forest enumeration using SharpView](image/B18964_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Result of forest enumeration using SharpView
  prefs: []
  type: TYPE_NORMAL
- en: After collecting all the forest and domain information, we need to analyze it.
    We are interested in finding a way to chain allowed trust and access with misconfigurations
    to progress further. What if there was a tool that can help to get all the bits
    together in some automated way? Let us welcome and discuss BloodHound!
  prefs: []
  type: TYPE_NORMAL
- en: BloodHound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Defenders think in lists. Attackers think in graphs. As long as this is true,
    attackers win.* This great quote is from *John Lambert*. I think such a shift
    in thinking can help us to understand the full power of **BloodHound**[13]. This
    tool utilizes graph theory to help the attacker find relationships between objects
    within Active Directory that were not intended to exist or could be abused for
    further compromise. To make the magic happen, we need the SharpHound data collector[14]
    and BloodHound. Our goal is to understand how these tools work and the benefits
    of using them. SharpHound has several collection methods, and before using all
    of them, we need to understand the implications. For example, methods such as
    RDP, DCOM, PSRemote, LocalAdmin, and LoggedOn are very noisy and generate a lot
    of traffic as they will connect to each computer in the domain to retrieve the
    requested information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After running SharpHound with the default collection options and uploading
    the results to BloodHound, we can find promising paths such as in the following
    screenshot, where **tywin.lannister** can change the password of another user
    and add himself to a group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – ACL misconfiguration found by BloodHound](image/B18964_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – ACL misconfiguration found by BloodHound
  prefs: []
  type: TYPE_NORMAL
- en: It can be the case that pre-defined queries in BloodHound are not enough to
    find the next move. Then, we can write them ourselves and/or use published custom
    queries[15].
  prefs: []
  type: TYPE_NORMAL
- en: 'To get more insights about BloodHound internals, there are three blog posts
    written by *Sven Defatsch*[3]. In these articles, he discusses user and session
    enumeration via different methods. We are not going to replicate the full research
    but will briefly have a look at the traffic to confirm the results. We will start
    data collection for sessions alongside packet capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command created the following data capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Session collection](image/B18964_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Session collection
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the traffic is the same as in the original research. There are
    plenty of collection methods with different levels of noise. Also, it depends
    on what you are hunting for. General advice is to use the **--Jitter** and **--Throttle**
    options to create a delay between requests. The **--Stealthy** option forces SharpHound
    to behave differently, however, it may also influence the collection quality.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, the data collector gets information using various named pipes
    and protocols over an SMB connection with Kerberos authentication.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is another way to explore the target Active Directory. **ADExplorer**[16]
    is a tool written by Microsoft that not only allows viewing and editing objects
    but also supports snapshots. I highly encourage you to read the post about ADExplorer
    usage during engagements by *api0cradle*[18]. Using the tool, written by *c3c*[18],
    we can convert snapshots to BloodHound-compatible JSON files. Obviously, as there
    is no network interaction with systems, information such as the local administrator
    list and sessions will be missing. The only OpSec consideration when doing a snapshot
    is to keep in mind that a large volume of data will be collected. However, detection
    of Active Directory data collection is not easy, as mentioned by *FalconForce*[19].
  prefs: []
  type: TYPE_NORMAL
- en: After collecting all available information about the domain, next, we will focus
    on services deployed inside the domain and will briefly have a look at the user
    hunting process.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating services and hunting for users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To continue our enumeration, the next step will be to identify available services,
    file and SQL servers, and the privileged users’ activity in the domain. As we
    discussed at the beginning of this chapter, our target is to get access to critical
    data and services in the compromised environment.
  prefs: []
  type: TYPE_NORMAL
- en: SPN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Service Principal Names** (**SPNs**) are the names by which a Kerberos client
    uniquely identifies instances of a service for a given Kerberos target computer.
    There is a comprehensive list of known SPNs for Active Directory held by *PyroTek3*[20].
    We can use them to better understand what services are present in the domain and
    use Kerberos authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can enumerate SPN in the domain by using the **setspn** utility or SharpView
    with the following commands to find users and computers with SPNs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To get all SPNs with the **setspn** utility, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we received a lengthy list of SPNs. We can narrow the list down
    by using the **-L** switch for a specific server or user. Following are some promising
    findings after running the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – SPN in the sevenkingdoms forest](image/B18964_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – SPN in the sevenkingdoms forest
  prefs: []
  type: TYPE_NORMAL
- en: The next target to hunt for in the domain is a file server. Sometimes it can
    even have open shares or shares we have “write” permissions on. In [*Chapter 5*](B18964_05.xhtml#_idTextAnchor093),
    we will show how to get an advantage from writable shares, but first we need to
    find them.
  prefs: []
  type: TYPE_NORMAL
- en: The file server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The file server is a great resource of information. If an attacker compromises
    a user with wide access rights across the organization, then there is a chance
    to just pull all the required information from file shares. There are a few options
    in SharpView for file server enumeration. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get-DomainFileServer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find-DomainShare -CheckShareAccess**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find-InterestingFile**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find-InterestingDomainShareFile**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User hunting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'User hunting is more of an art rather than a process. A great presentation[21]
    was created by *harmj0y* that shows the general approach. It may look like a straightforward
    process for a small environment, but if there are thousands of users across multiple
    domains and forests, it is not. Locating the right user for the hunt is the most
    vital step. For privileged users, we can first identify them by using the following
    command from SharpView:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the list of privileged users in the domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – List of users with the AdminCount=1 attribute](image/B18964_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – List of users with the AdminCount=1 attribute
  prefs: []
  type: TYPE_NORMAL
- en: 'As the next step, we can run various commands, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Find-DomainUserLocation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-NetSession**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invoke-UserHunter -****Stealth -ShowAll**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just be careful as the first and last commands without the **Stealth** switch
    ([http://www.labofapenetrationtester.com/2018/10/deploy-deception.xhtml](http://www.labofapenetrationtester.com/2018/10/deploy-deception.xhtml))
    will generate a lot of noise by querying every machine in the domain. In the next
    section, we will cover some detections and ways to avoid them during enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration detection evasion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enumeration can be a noisy process if tools are used without precautions. Also,
    defenders hunt for reconnaissance activities by using security products and deception
    methods. These methods are like a hidden bell in a dark room – you need to know
    where it is located to avoid detection. We will cover Microsoft ATA and its successor
    – **Defender for Identity** (**MDI**) together with honey tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft ATA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft **Advanced Threat Analytics** (**ATA**) is an on-premises platform
    that helps to protect enterprises from threats. Extended support ends in 2026,
    so it makes sense to quickly cover it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will discuss only detections for recon methods; other attacks
    and bypasses will be covered in respective chapters. In general, ATA parses the
    network traffic of multiple protocols to detect malicious activity. It’s important
    to mention that it will take time for the tool to learn the normal behavior of
    the users and machines in the environment. Data collection happens on ATA Gateways.
    A great series of five blog posts[22] related to ATA detection and bypass was
    written by *Nikhil Mittal* in 2017\. The general bypass strategy is to blend in
    existing environment traffic and limit interaction with domain controllers. **Microsoft
    Defender for Identity** (**MDI**) is a successor of ATA. Nikhil took a fresh look
    at the product and shared his research during the BruCON conference[23]. All techniques
    mentioned there are still truly relevant to ATA as well. Two good enumeration
    recommendations were given during the talk: exclude SMB session enumeration against
    DC and forget about any tool that utilizes the SAMR protocol. WMI and LDAP queries
    are a way to go for reconnaissance, but now it is recommended to request all LDAP
    attributes and filter them offline.'
  prefs: []
  type: TYPE_NORMAL
- en: Honey tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to detect malicious activity inside the environment is to deploy
    and monitor decoy objects in the environment. These objects should be desirable
    for attackers but should never be used during normal activities. We can point
    to more research by *Nikhil Mittal*[24] and his ready-to-use PowerShell module[25].
    Using the tool, we can deploy honey users, computers, and groups. To detect access
    to these objects, we need to configure Group Policy auditing[26] or we can simply
    add the account to honey tokens in Microsoft ATA:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Honey tokens in Microsoft ATA](image/B18964_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Honey tokens in Microsoft ATA
  prefs: []
  type: TYPE_NORMAL
- en: There are still ways an attacker can identify honey accounts by examining attributes
    such as **LastLogon**, **logonCount**, **badpwdCount**, **whenCreated**, and a
    few others. Some tools can assist in such activities, such as **HoneypotBuster**[27].
    It uses an internal fake ranking system, calculated as a combination of several
    parameters for the account. The ranking system of the tool can be analyzed by
    the blue team, so honeypots may be tweaked up to the desired level.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to introduce false credentials inside the memory of the
    machines in the domain and detect credential reuse during privilege escalation
    attempts via a pass-the-hash attack. A great project that demonstrates such deception
    is called Dcept[28]. If the blue team detects such activity, they will know the
    exact host that was compromised and the way the attacker performed lateral movement.
  prefs: []
  type: TYPE_NORMAL
- en: Another script, Honeyhash[29], is written in PowerShell and creates in-memory
    deception. It creates an in-memory fake account that will then be used by the
    attacker for lateral movement. A good walk-through on how to deploy and implement
    detections was written by the *Stealthbits* company[30].
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed available tools and protocols that attackers can
    use for enumeration activity. We briefly covered tooling internals to get a clear
    insight into the traces we left. Our methodology was to enumerate from a high
    level to a low level inside the environment. One of the key ideas was that enumeration
    is a constant process. At the end of the chapter, we went through some OpSec concerns
    and saw how a blue team can deceive attackers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover credential access from a domain point of
    view. We will not spend time on endpoint credential access, rather we will explore
    things such as Kerberoasting, GMSA, LAPS, different types of coerced authentication,
    how to abuse writable shares, and more.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ADModule: [https://github.com/samratashok/ADModule](https://github.com/samratashok/ADModule)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'WMI basics series: [https://0xinfection.github.io/posts/wmi-basics-part-1/](https://0xinfection.github.io/posts/wmi-basics-part-1/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bloodhound inner workings: [https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-1/](https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-1/),
    [https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/](https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-2/)
    and [https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-3/](https://blog.compass-security.com/2022/05/bloodhound-inner-workings-part-3/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'LDAP wiki: [https://ldapwiki.com/wiki/Main](https://ldapwiki.com/wiki/Main)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'LDAP and Kerberos: [https://blog.ropnop.com/talk/2018/funwithldapkerb/](https://blog.ropnop.com/talk/2018/funwithldapkerb/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'New look on NULL session enumeration: [https://sensepost.com/blog/2018/a-new-look-at-null-sessions-and-user-enumeration/](https://sensepost.com/blog/2018/a-new-look-at-null-sessions-and-user-enumeration/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'UserEnum: [https://github.com/sensepost/UserEnum](https://github.com/sensepost/UserEnum)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ldapsearch: [https://malicious.link/post/2022/ldapsearch-reference/](https://malicious.link/post/2022/ldapsearch-reference/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Windapsearch: [https://github.com/ropnop/windapsearch](https://github.com/ropnop/windapsearch)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SharpView: [https://github.com/tevora-threat/SharpView](https://github.com/tevora-threat/SharpView)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PowerView: [https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1](https://github.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PowerView recon wiki: [https://powersploit.readthedocs.io/en/latest/Recon/](https://powersploit.readthedocs.io/en/latest/Recon/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'BloodHound: [https://bloodhound.readthedocs.io/en/latest/](https://bloodhound.readthedocs.io/en/latest/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SharpHound: [https://bloodhound.readthedocs.io/en/latest/data-collection/sharphound.xhtml](https://bloodhound.readthedocs.io/en/latest/data-collection/sharphound.xhtml)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Custom BloodHound queries: [https://github.com/hausec/Bloodhound-Custom-Queries](https://github.com/hausec/Bloodhound-Custom-Queries)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ADExplorer: [https://learn.microsoft.com/en-us/sysinternals/downloads/adexplorer](https://learn.microsoft.com/en-us/sysinternals/downloads/adexplorer)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ADExplorer on engagements: [https://www.trustedsec.com/blog/adexplorer-on-engagements/](https://www.trustedsec.com/blog/adexplorer-on-engagements/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ADExplorerSnapshot: [https://github.com/c3c/ADExplorerSnapshot.py](https://github.com/c3c/ADExplorerSnapshot.py)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Detect AD data collection: [https://falconforce.nl/falconfriday-detecting-active-directory-data-collection-0xff21/](https://falconforce.nl/falconfriday-detecting-active-directory-data-collection-0xff21/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'List of known SPNs: [https://adsecurity.org/?page_id=183](https://adsecurity.org/?page_id=183)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hunt sysadmins: [https://www.slideshare.net/harmj0y/i-hunt-sys-admins-20](https://www.slideshare.net/harmj0y/i-hunt-sys-admins-20)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Evade Microsoft ATA: [http://www.labofapenetrationtester.com/2017/08/week-of-evading-microsoft-ata-day1.xhtml](http://www.labofapenetrationtester.com/2017/08/week-of-evading-microsoft-ata-day1.xhtml)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Abuse MDI: [https://www.youtube.com/watch?v=bzLvOu1awKM](https://www.youtube.com/watch?v=bzLvOu1awKM)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy deception research: [http://www.labofapenetrationtester.com/2018/10/deploy-deception.xhtml](http://www.labofapenetrationtester.com/2018/10/deploy-deception.xhtml)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy Deception tool: [https://github.com/samratashok/Deploy-Deception](https://github.com/samratashok/Deploy-Deception)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Group Policy configuration for AD honey tokens: [https://www.bordergate.co.uk/active-directory-honey-tokens/](https://www.bordergate.co.uk/active-directory-honey-tokens/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'HoneypotBuster: [https://github.com/JavelinNetworks/HoneypotBuster](https://github.com/JavelinNetworks/HoneypotBuster)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DCEPT: [https://github.com/secureworks/dcept](https://github.com/secureworks/dcept)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'HoneyHash: [https://github.com/EmpireProject/Empire/blob/dev/data/module_source/management/New-HoneyHash.ps1](https://github.com/EmpireProject/Empire/blob/dev/data/module_source/management/New-HoneyHash.ps1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to detect honey hash:[https://stealthbits.com/blog/implementing-detections-for-the-honeyhash/](https://stealthbits.com/blog/implementing-detections-for-the-honeyhash/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These will aid further study and allow you to dive deeper into the attacks
    covered in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'More details about WMI from Microsoft: [https://learn.microsoft.com/en-us/windows/win32/wmisdk/about-wmi](https://learn.microsoft.com/en-us/windows/win32/wmisdk/about-wmi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enumerate Active Directory using WMI: [https://0xinfection.github.io/posts/wmi-ad-enum/](https://0xinfection.github.io/posts/wmi-ad-enum/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LDAP APIs in Windows: [https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ldap/lightweight-directory-access-protocol-ldap-api](https://learn.microsoft.com/en-us/previous-versions/windows/desktop/ldap/lightweight-directory-access-protocol-ldap-api)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
