- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Credential Access in Domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It was difficult to choose the order of *Chapters 4*, *5* and *6*, as they are
    all closely interconnected. We are not going to cover how to dump secrets from
    the host (LSASS, DPAPI, Credential Manager, etc.). Instead, we will keep our focus
    on Active Directory. This chapter starts with discussing ways to obtain credentials
    in clear text in the domain. Then, we will explore various techniques to capture
    the hash, such as forced authentication and poisoning. Relay will be covered later
    in [*Chapter 5*](B18964_05.xhtml#_idTextAnchor093), *Lateral Movement*. After
    that will be an introduction to the Kerberos authentication protocol and different
    styles of roasting the three-headed dog. Finally, we will discuss native security
    mechanisms for password management, such as **Local Administrator Password Solution**
    (**LAPS**) and **Group Managed Service Account** (**gMSA**), and ways to recover
    privileged credentials from them. As a final note, the DCSync attack together
    with ways to dump hashes from the ntds.dit domain controller will be explained.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Clear-text credentials in the domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capture the hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forced authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways to roast Kerberos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic password management in the domain (LAPS or gMSA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DCSync attack and NTDS credentials exfiltration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will need to have access to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: VMware Workstation or Oracle VirtualBox with at least 16 GB of RAM, eight CPU
    cores, and at least 55 GB of total space (more if you take snapshots)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Linux-based operating system is strongly recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vagrant installed with the plugin for the corresponding virtualization platform
    and Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the GOADv2 project, we will use DC02, DC03, SRV02, and SRV03
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear-text credentials in the domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss different ways to obtain credentials in clear
    text. However, we will not touch on things such as the **password.txt** file left
    on the share, the default set of credentials for some applications, and pushing
    the **WDigest** parameter so a password can be dumped in clear text from memory.
    We also will not discuss Internal Monologue attack[1] that allows to obtain credentials
    without touching LSASS[1]. Our focus is solely on Active Directory. We may find
    a very old pre-Windows 2000 computer in the domain or the domain may be vulnerable
    to MS14-025 with the local administrator password encrypted in a Group Policy
    file. We can try our luck with password spraying or by searching for a password
    in an Active Directory user’s comment field.
  prefs: []
  type: TYPE_NORMAL
- en: Old, but still worth trying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recently, I came across some intriguing research published by *Oddvar Moe* regarding
    pre-created computer accounts[2]. Apparently, checking the **Assign this computer
    account as a pre-Windows 2000 computer** field will turn the password for the
    computer account into the same as the computer name. This is the case when the
    computer account was manually created by the administrator and has never been
    used in the domain. To find such accounts, we look for the **UserAccountControl**
    flag value equaling **4128**. Then, we can extract a list of computers and try
    to log in using **CrackMapExec**. The **STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT**
    error message will flag that the guessed password for the computer account is
    correct. We need to change the password before we can use the computer account.
    It can be done with various tools, such as **kpasswd.py** or **rpcchangepwd.py**.
    Note that using Kerberos authentication will take away your need to change the
    password for the computer account. This behavior was discovered by *Filip* *Dragovic:*
    https://twitter.com/filip_dragovic/status/1524730451826511872.
  prefs: []
  type: TYPE_NORMAL
- en: '**Group Policy Preferences** (**GPP**) were introduced in Windows 2008 R2 to
    help system administrators with various configuration changes. The most dangerous
    one was the ability to set the local administrator’s password on domain machines.
    The problem was that the password was stored in an XML file that every authenticated
    user could read in **\\<DOMAIN>\SYSVOL\<DOMAIN>\Policies\**. While the password
    was encrypted using the AES-256 key, Microsoft published the private key on MSDN,
    effectively making encryption useless. A good blog post by *Sean Metcalf* with
    a deeper explanation is available[3]. The attack comprises essentially two commands
    – one line by *Oddvar Moe* to search for the value and a Linux one-liner by *0x00C651E0*
    to decrypt the password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Other tools, such as **Gpp-Decrypt** and the Metasploit **post/windows/gather/credentials/gpp**
    module, are available as well. After the patch, this functionality was completely
    removed from GPP by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: Password in the description field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During the enumeration, we may be lucky and find the password in the description
    field of the user profile in Active Directory. An example is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Password in the description field
  prefs: []
  type: TYPE_NORMAL
- en: Even if there is no password in the description field, it is a good idea to
    examine it, as we may find useful information about the account’s purpose, instructions
    to the IT staff, and other valuable bits. However, such an account can be a honeypot.
  prefs: []
  type: TYPE_NORMAL
- en: Password spray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way we can try to guess the correct set of credentials is with a password
    spray. There are different approaches we can take; for example, try the username
    as the password. Before starting, it is very important to review the password
    policy to avoid a lockout. If **NULL** session binding is not allowed, we need
    a set of valid credentials to pull the password policy. We can do it with the
    help of an amazing tool – **CrackMapExec**[4]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Password policy enumeration
  prefs: []
  type: TYPE_NORMAL
- en: There are various PowerShell commands we can use to pull the policy, such as
    **Get-DomainPolicyData** from PowerView or the native **Get-ADDefaultDomainPasswordPolicy**
    command from the Active Directory module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know the password policy and lockout rules and hopefully have a
    list of the users, we can start our spray. CrackMapExec provides different options
    for performing a spray, for example, using lists, one-to-one matches, and wordlists.
    Let’s try to perform a spray where the username is the same as the password. We
    can run a command where we try to log in to all machines in the subnet over SMB
    (it is very loud and not OpSec safe):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous command is shown in the following screenshot (user
    **hodor** has password **hodor**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Successful password spray
  prefs: []
  type: TYPE_NORMAL
- en: There are other tools that can be used for a spray, such as **kerbrute**[5]
    by *ropnop* and **DomainPasswordSpray**[6] by *dafthack*.
  prefs: []
  type: TYPE_NORMAL
- en: Before performing a spray, it is important to carefully enumerate domain users,
    in order not to trigger possible decoy accounts. Also, wisely choose the interval
    between sprays, as a large number of failed login attempts (event ID 4625) will
    trigger an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will cover how to capture the hash and avoid confusion
    in terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Capture the hash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will be focused on capturing the hash, the number-one step in
    a well-known attack: NTLM relay. As an introduction to this theme, I highly encourage
    you to read the most comprehensive guide about this attack[7].'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to cover a bit of a theory. The NTLM authentication protocol
    is used for network authentication and has two versions. It uses a *zero-knowledge
    proof* concept, meaning that credentials have never been transmitted over the
    network. It uses a challenge-response scheme, where the server sends a random
    set of data and client responses with a value, which is a result of hashing this
    data together with some extra parameters and the client’s secret key. As an attacker,
    we are interested in capturing this valid NTLM response from the client. Next,
    we can try to crack the hash or relay it.
  prefs: []
  type: TYPE_NORMAL
- en: 'NTLMv1 is deprecated and not considered secure. However, it is possible to
    see NTLMv1 in use in older environments. There are two techniques to capture the
    hash: **Man in the Middle** (**MITM**) and **coerced authentication**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend you refer to this resource if anything is not clear in the following
    text: [https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications](https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with network-related attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ARP poisoning** is possible when an attacker is sitting between the client
    and the server. The success ratio of this attack depends on the network topology
    and hardening. Also, it can cause severe network disruptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DNS spoofing** requires the attacker to introduce a malicious DNS server
    in the network for the clients via ARP/DHCPv6 spoofing. Then, the attacker can
    reply to the received client’s requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DHCP poisoning** happens by injecting a malicious WPAD or DNS server address
    into the client’s DHCP reply. The client’s request for **wpad.dat** will trigger
    a malicious server to request authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DHCPv6 spoofing** is possible because IPv6 in Windows has higher priority
    than IPv4 and it is a multicast protocol. The attacker can provide the client
    with a malicious config and proceed with DNS spoofing later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local-Link Multicast Name Resolution (LLMNR), NetBIOS Name Service (NBT-NS),
    and Multicast Domain Name System (mDNS) spoofing** are possible because of multicast
    name resolution protocols used in Windows environments. If DNS fails, these protocols
    will be used for resolution as a fallback option. The attacker can answer queries
    and then ask the client to authenticate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WSUS spoofing** requires ARP poisoning and an evil WSUS server to deploy
    malicious updates to the clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ADIDNS poisoning** is an attack on Active Directory-integrated DNS. The idea
    is to inject malicious DDNS records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WPAD spoofing** abuses the feature of helping clients locate proxy configuration
    scripts. After the MS16-077 security update, this attack is only possible through
    ADIDNS or DHCPv6 spoofing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the NTLMv1 protocol is allowed in the network, we can try to downgrade the
    authentication to obtain the NTLMv1 response. It uses weak DES encryption. We
    add a magical challenge value (**1122334455667788**) to the **Responder’s**[8]
    configuration file (**/etc/responder/Responder.conf**) and start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In our lab, we do not have NTLMv1 enabled; however, after spinning up Responder,
    in a few minutes, we captured the NTLMv2 response for user **eddard.stark**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](image/B18964_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Capturing the NTLMv2 response
  prefs: []
  type: TYPE_NORMAL
- en: To simulate this activity, the lab author created a scheduled task on **winterfell**
    as the user **eddard.stark** is trying to connect over SMB to the server by DNS
    name with a typo. As the DNS server cannot resolve the name, broadcast protocols
    kicked in and we captured the NTLMv2 response.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate such capturing possibilities, ideally, we need to stop using NTLM.
    If this is not possible (as is often the case), a strong password policy and strict
    hardening on the network level should be applied. The idea is to disable all unnecessary
    multicasting protocols and NTLMv1 (in Group Policy, set **LAN Manager** to **Send
    NTLMv2 responses only. Refuse LM & NTLM**). We will provide recommendations for
    mitigating relay in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if these network protocols are disabled and MITM is not really an
    option? There are a few ways we can force the client to authenticate to us. Recently,
    some intriguing research was published by *MDSec*[9]. There are certain types
    of files that we can put on the writable share and Windows will automatically
    authenticate and send an NTLM response to a remote machine: **SCF,** **URL**,
    **library-ms**, and **searchConnector-ms**. An important remark is that the attacker’s
    machine should be within the local intranet zone, meaning that the network connection
    can be established by using a UNC path. The idea in the research was to use a
    WebDAV-enabled HTTP server to collect hashes, which is called **farmer**, and
    the tool to create files is called **crop**. The following two commands will capture
    the hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create a .URL file manually. The idea is that we put an environment
    variable in the file, so Explorer on the victim’s machine when viewing the folder
    will proactively look up this variable before sending the request, effectively
    connecting to our file share without any user interaction. This behavior allows
    us to catch the NTLMv2 response with Responder. The URL file content could look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be seen as follows in Responder when **jon.snow** opens a publicly
    shared folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – NTLMv2 response capture after opening a public share with a .URL
    file
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Other interesting places to steal NTLMv2 responses are thoroughly described
    in this blog post by *Osanda* *Malith*: https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/.'
  prefs: []
  type: TYPE_NORMAL
- en: To prevent forced authentication of the file types mentioned previously, we
    need to turn off the display of thumbnails on network folders via the Group Policy
    setting. Next, we will cover another powerful technique to capture the hash, if
    all previous attempts were not successful.
  prefs: []
  type: TYPE_NORMAL
- en: Forced authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered MITM capabilities and now will discuss in detail various ways
    to force authentication. The idea is that a standard user can force the target
    machine account (usually a domain controller) to connect to an arbitrary target.
    This is made possible through an automatic authentication attempt. You can find
    a repository with 15 known methods in 5 protocols[10]. Now, let’s dive a bit deeper
    into each method.
  prefs: []
  type: TYPE_NORMAL
- en: MS-RPRN abuse (PrinterBug)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a *won’t-fix* bug, which is enabled by default in every Windows environment.
    The idea is that by using a domain username and password, the attacker can trigger
    the **RpcRemoteFindFirstPrinterChangeNotificationEx** method and force authentication
    over SMB. We will demonstrate this attack later when discussing Kerberos’s unconstrained
    delegation in [*Chapter 5*](B18964_05.xhtml#_idTextAnchor093). A go-to tool for
    this abuse is called **SpoolSample**[11] and can be found on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: MS-EFSR abuse (PetitPotam)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Encrypting File System Remote** (**EFSR**) protocol can be abused via
    a number of RPC calls, such as **EfsRpcOpenFileRaw**, to coerce Windows hosts
    to authenticate to other machines. This RPC interface is available through different
    SMB pipes, including those discussed in [*Chapter 3*](B18964_03.xhtml#_idTextAnchor040),
    **\pipe\samr** and **\pipe\lsarpc**. To demonstrate this attack, we will use this
    proof of concept[12].
  prefs: []
  type: TYPE_NORMAL
- en: 'We will run this command on **castelblack** with the attacker and domain controller
    IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will catch the domain controller’s hash with Responder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – PetitPotam coerced authentication successful
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B18964_08.xhtml#_idTextAnchor163), we will show how the domain
    controller’s hash can be relayed to the server running Active Directory Certificate
    Services, effectively allowing us to compromise the whole domain.
  prefs: []
  type: TYPE_NORMAL
- en: WebDAV abuse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind WebDAV abuse is to find machines running this service in the
    domain. The **WebclientServiceScanner**[13] tool can help with such a task. If
    no clients have the **WebClient** service running, it can be enabled remotely
    via the **searchConnector-ms** file[14]. Then, we can use **PetitPotam** from
    previously, combined with **Resource-Based Constrained Delegation** (**RBCD**)
    abuse. We will discuss RBCD abuse in the Kerberos section of [*Chapter 5*](B18964_05.xhtml#_idTextAnchor093).
  prefs: []
  type: TYPE_NORMAL
- en: MS-FSRVP abuse (ShadowCoerce)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Microsoft’s File Server Remote VSS Protocol** (**MS-FSRVP**) is used to make
    shadow copies on the remote computer. Two methods are supported. Invocation is
    possible through an SMB named pipe. An attack is not possible if **File Server
    VSS Agent Service** is not enabled on the target machine. Also, patch KB5014692
    prevents coercion attacks. I was able to run a proof of concept[15] but did not
    manage to get the NTLMv2 response on Windows Server 2019 (c**astelblack**). The
    result of the coercion attempt is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 — ShadowCoerce running
  prefs: []
  type: TYPE_NORMAL
- en: The next method also requires a service to be up and running on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: MS-DFSNM abuse (DFSCoerce)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same as other coerce methods, this one uses the RPC interface available
    through an SMB named pipe (**\pipe\netdfs**) in Microsoft’s Distributed File System
    Namespace Management protocol. *Filip Dragovic* found two methods (**NetrDfsAddStdRoot**
    and **NetrDfsRemoveStdRoot**) that can be used to force authentication. The proof-of-concept
    code was published on GitHub[16]. Simply run the command against only the domain
    controller with DFS running.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will cover another authentication protocol – Kerberos. Understanding
    the mechanisms and workflow of the protocol is crucial for understanding material
    further in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Roasting the three-headed dog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It was inevitable that we would reach a point where we must discuss and understand
    Kerberos. This authentication protocol was built to access services in the network
    by presenting a valid ticket.
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos 101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need a bit more of an understanding of how the protocol works before we can
    discuss the attack venues available for us. As a good starting point, I can recommend
    the blog post by *hackndo*[17]
  prefs: []
  type: TYPE_NORMAL
- en: 'We have three main subjects – the client, service, and **Key Distribution Center**
    (**KDC**), which is the domain controller. The following diagram[18], which was
    published on the Microsoft website, explains how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Kerberos in a nutshell
  prefs: []
  type: TYPE_NORMAL
- en: Now let follow the authentication process in more details step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: '**KRB_AS_REQ** (**Kerberos Authentication Service Request**) is sent by the
    client to KDC and contains various information, most importantly, a timestamp
    that is encrypted with the hashed version of the password. If the client exists,
    then KDC will try to decrypt the timestamp by using the received hash of the client’s
    password. If everything goes smoothly, the session key will be generated.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**KRB_AS_REP** (**Kerberos Authentication Service Reply**) will contain a **Ticket-Granting
    Ticket** (**TGT**), which is encrypted by the client’s password hash session key,
    the validity period, and other information. It is encrypted by the KDC key, so
    only the domain controller can read this ticket.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**KRB_TGS_REQ** (**Kerberos Ticket Granting Service Request**) is sent by the
    client when it wants to use a service. It contains the TGT, the service, and an
    authenticator. The authenticator is encrypted by the session key from *step 2*
    and contains the username and timestamp. If the session key from the TGT successfully
    decrypted the authenticator and the data matches, then authentication is successful.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**KRB_TGS_REP** (**Kerberos Ticket Granting Service Reply**) will contain the
    requested service name, client’s name, and session key for the service and client.
    The ticket is encrypted with the service’s key and with the session key from *step
    2*. Effectively, the client will decrypt the ticket and extract a new session
    key and ticket to communicate with the service.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**KRB_AP_REQ** (**Kerberos Application Request**) is sent by the client with
    a new authenticator and TGS. The authenticator is encrypted with the session key
    inside TGS. Verification is like in *step 2*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will discuss how things can go wrong here. The following attacks are
    quite easy to perform, but we need to be OpSec aware when performing them.
  prefs: []
  type: TYPE_NORMAL
- en: ASREQRoast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with an attack that does not abuse any misconfiguration of the
    protocol and requires a powerful MITM attack. The idea is to intercept the KRB_AS_REQ
    packet and attempt to crack the hash of the user’s password. This hash is used
    to encrypt the timestamp in the pre-authentication stage. You can read the original
    research that covers this attack in detail[19]. In essence, we should have the
    MITM position; we passively collect the traffic and then use a tool such as **Pcredz**[20]
    to extract hashes that we can try to crack later with hashcat[21]. The main caveat
    in this attack is the requirement to obtain the MITM position.
  prefs: []
  type: TYPE_NORMAL
- en: KRB_AS_REP roasting (ASREPRoast)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This attack is possible when there is a misconfiguration made in Active Directory
    by enabling **Do not require Kerberos preauthentication**. This can be seen in
    the user object properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – User with pre-authentication enabled
  prefs: []
  type: TYPE_NORMAL
- en: 'For the attack execution, we will use Rubeus[22]. But before typing commands,
    we need to discuss some OpSec considerations. We know from the documentation that
    Rubeus will find all misconfigured accounts and try to roast them. This will create
    a security event on the domain controller with *ID=4768* and certain values (**Ticket
    Encryption Type 0x17, Pre-Authentication** **Type: 0**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – ASREPRoasting detected
  prefs: []
  type: TYPE_NORMAL
- en: 'A much better way is to pull the list of misconfigured accounts first, do a
    bit more reconnaissance (i.e., checking for honeypot accounts), and then roast
    them. We can use PowerView for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The LDAP search filter and output are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – List of users vulnerable to AS-REP roasting
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Hash ready for cracking
  prefs: []
  type: TYPE_NORMAL
- en: We can use **john** (**--format=krb5asrep**) or **hashcat** (**-m 18200**) to
    crack the hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mitigate this attack, we can try the following measures:'
  prefs: []
  type: TYPE_NORMAL
- en: By default, pre-authentication is enabled, so check why it was disabled for
    certain accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply additional password complexity requirements for accounts with disabled
    pre-authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that only privileged users can change the pre-authentication attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor events for changing the pre-authentication attribute (ID 4738 and ID
    5136)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor for roasting attempts (ID 4768 and ID 4625)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kerberoasting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind this attack is to request a **Service Ticket** (**ST**) and
    crack the hash to obtain the service account’s password. To be able to request
    the ST, we need to be authenticated in the domain (possess a valid TGT) and know
    the **Service Principal Name** (**SPN**). The SPN is a unique service name in
    the forest. In most cases, services run under machine accounts that have long
    and complex passwords. But if a service account has a manually set password and
    SPN, we can try our luck.
  prefs: []
  type: TYPE_NORMAL
- en: There is an outstanding blog post that covers Kerberoasting and OpSec in detail
    with examples[23]. We will cover the material from there, but the original research
    is an absolute must-read.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the strategy stays the same – find accounts with an SPN and roast
    them. Possible OpSec failures that can happen during AS-REP roasting are also
    relevant here as well as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Too-wide LDAP search filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple STs requested in a short period of time (security events with ID 4769),
    including for honeypot accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting STs with encryption downgrade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will discuss how to avoid a failure step by step. Enumeration is the
    key to success here. Depending on the size of the forest, we can run general LDAP
    searches with a focus on collecting information that will help us to choose the
    right target. In our lab, our initial enumeration can be done by filtering users,
    excluding **krbtgt** and disabled ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one promising candidate named **sql_svc**. We can confirm with the
    help of PowerView that this user has an SPN:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – User with SPN found
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that we are not dealing with a honeypot, we can check that the object
    really exists in the domain. What are the privileges of this object? Will we really
    benefit from roasting it? Also, its **pwdLastSet** and **lastLogon** attributes
    should be self-explanatory. The next smart move is to check the encryption type
    in the **MsDS-SupportedEncryptionTypes** attribute. In Rubeus, there is a parameter
    to filter AES-enabled accounts: **/rc4opsec**. As a last step, run the following
    command to obtain the hash (the **/nowrap** option will output the hash as a one-liner):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after executing the preceding command is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Kerberoasting
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can crack this hash with **john** **(--format=krb5tgs**) or **hashcat**
    (**-m 13100**). There is one important thing to add before we discuss mitigations.
    It is possible to perform targeted Kerberoasting if an attacker has the right
    to add an SPN to another account. We will discuss it in more detail in [*Chapter
    6*](B18964_06.xhtml#_idTextAnchor119), *Privilege Escalation*.
  prefs: []
  type: TYPE_NORMAL
- en: There is a C# tool written by *Luct0r* that fully implements OpSec recommendations
    from the blog post and can be found on GitHub[24].
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate such attacks, we need to avoid assigning SPNs to user accounts.
    If this is not possible, we can use **Group Managed Service Accounts** (**gMSA**)
    for automatic password management, which we will discuss in the next section.
    Also, honeypot accounts and prompt logging of the event and search filters can
    help to identify attacks.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will show how adversaries can abuse domain security enhancements
    if they are misconfigured.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic password management in the domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the attacks from previously, for example, MS14-025 and Kerberoasting,
    contributed to the development of password management automation. To resolve the
    problem of local administrator password rotation, LAPS was created. To tackle
    Kerberoasting, gMSA was introduced a bit later by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: LAPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we will deploy LAPS on **braavos** in the **essos** domain and discuss
    possible attack venues. I will follow this deployment guide[25]. The general steps
    include component installation, Active Directory schema extension, agent deployment
    on computers, and Group Policy configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation is straightforward. Just download the **.msi** file and deploy
    it. After running the following command, your schema will be extended (run as
    schema admin):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Schema update was successful
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is the most important as misconfiguration here may lead to compromise.
    We need to assign users who will be able to view administrator passwords. By default,
    these users are is **SYSTEM** and from the “**Domain Admins"** group. This time,
    we will add non-privileged users to this group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Grant user LAPS read rights
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will change sides and discuss the attacker’s options. First, we need
    to understand whether LAPS is installed. There are a few ways to get an answer:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine computer object attributes for the **ms-Mcs-AdmPwdExpirationTime** attribute
    with the help of PowerView
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for **AdmPwd.dll** in **C:\Program Files\LAPS\CSE**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for a **Group Policy Object** (**GPO**) named *LAPS*, *passwords*, or
    similar; however, do not fully rely on naming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Considering we are logged in as a domain user, we should be able to discover
    who is allowed to read the LAPS password. This can be done with the help of BloodHound
    and PowerView. Also, **LAPSToolkit**[26] can be used as a tool to execute the
    full attack chain. The output after running **Invoke-ACLScanner** from PowerView
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – User found with ReadLAPS privileges
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have compromised such a user, we can obtain the local administrator password
    with the help of the **Get-LAPSPasswords** PowerShell commandlet[27]. The output
    from this operation is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – Local administrator password revealed
  prefs: []
  type: TYPE_NORMAL
- en: The only mitigations we can introduce here are being careful of who you delegate
    the right to reveal the password to and ensuring that you enforce an expiration
    time via Group Policy. This will help us to ensure passwords are changed regularly.
  prefs: []
  type: TYPE_NORMAL
- en: gMSA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: gMSA was introduced in Windows Server 2016 but can be leveraged from Windows
    Server 2012 and above. The idea behind it has much in common with LAPS’s creation,
    but instead of local administrator accounts, it is used for service accounts.
  prefs: []
  type: TYPE_NORMAL
- en: gMSA is an object type in Active Directory with attributes and permissions.
    The most interesting attributes are **msDS-ManagedPassword** (blob with a password)
    and **msDS-GroupMSAMembership** (who can read the blob). Let’s deploy gMSA and
    discuss the attacking steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create gMSA using the following two commands (run them
    as the domain administrator, not on domain controllers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the account was successfully created in the Active Directory
    Users and Computers console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – gMSA created
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step will be to set principals who are allowed to retrieve the plaintext
    password. We will again set the principals on an unprivileged user to demonstrate
    the attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'An attacker can use the following command to obtain information about the principal
    who can retrieve the managed password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the commands is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – User to retrieve the gMSA password
  prefs: []
  type: TYPE_NORMAL
- en: 'The third step is to compromise the user and retrieve the password as a blob
    that the attacker can then convert into an NT hash using the following commands
    and the **DSInternals**[28] module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows **SecureCurrentPassword** and **CurrentPassword**
    in UTF-16 format. We have also converted **SecureCurrentPassword** into an NT
    hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – NT hash of the gMSA password
  prefs: []
  type: TYPE_NORMAL
- en: This hash can then be used for a pass-the-hash attack, which we will discuss
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if we do not have the AD module installed, we can use **GMSAPasswordReader**
    written in Windows, by *rvazarkar*[29], or **gMSADumper** in Linux, written by
    *micahvandeusen*[30]. The only caveat is that we need the account name to dump
    its hash. Run the simple command as a user who has privileges to read the gMSA
    password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – Result of using the GMSAPasswordRead tool
  prefs: []
  type: TYPE_NORMAL
- en: As usual, mitigations are to ensure that permissions are set correctly for GMSA.
    Also, event logs can be configured and monitored for event ID 4662, which will
    show what account has queried the **msDS-ManagedPassword** attribute.
  prefs: []
  type: TYPE_NORMAL
- en: NTDS secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will cover NTDS secrets extraction as this attack applies only to domain
    controllers. The ntds.dit file is a database that stores Active Directory data,
    including hashes. This file is in **%systemroot\NTDS\ntds.dit** and **%systemroot\System32\ntds.dit**.
    It is constantly in use, so it can’t be copied directly as any other file. There
    are different ways that ntds.dit data can be dumped[31]:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ntdsutil.exe** – Active Directory maintenance tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VSSAdmin** – volume shadow copy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**vshadow**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DiskShadow**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**esentutl.exe**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NinjaCopy** from PowerSploit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy-VSS** from Nishang'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**windows/gather/credentials/domain_hashdump** from Metasploit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, on a domain controller, we will run **ntdsutil.exe**, which
    will save the ntds.dit file and **SYSTEM** registry hive, which we can then move
    to our machine and extract hashes using **secretsdump**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 – Dumped hashes from NTDS.dit
  prefs: []
  type: TYPE_NORMAL
- en: To detect dumping, we need to enable command-line auditing and monitor event
    ID 4688 for signs of using tools from the preceding list. In the application log,
    check for NTDS database creation and detachment with event IDs 325, 326, 327,
    and 216.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will execute a DCSync attack against the domain controller,
    which does not require us to run any commands on the machine itself. We can do
    it over the network, and in case of misconfiguration, our user could lose all
    privileges.
  prefs: []
  type: TYPE_NORMAL
- en: DCSync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DCSync uses the domain controller’s API to emulate the replication process from
    a remote domain controller. DCSync, in a nutshell, performs a **DsGetNCChanges**
    operation from a domain controller via an RPC request to the **Directory Replication
    Service API** (**DRSUAPI**). This attack requires extended privileges, **DS-Replication-Get-Changes**
    and **DS-Replication-Get-Changes-All**, which are assigned by default only to
    the “Domain Controllers”, “Domain Admins”, “Administrators”, and “Enterprise Admins”
    groups in the domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were able to compromise the user with extended privileges, we could run
    **secretsdump** to obtain all hashes in the domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output produced by the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 – Result of DCSync attack
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, a DCSync attack is powerful, allowing the complete takeover of
    the entire domain. To reduce the footprint, an adversary may run this attack directly
    on a domain controller, avoiding network detection. However, it requires domain
    admin privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Attack detection is possible via network traffic analysis or through event log
    monitoring. We can analyze traffic going toward domain controllers and check whether
    DRSUAPI RPC requests for the **DsGetNCChanges** operation are initiated by another
    domain controller. This can be done with the help of the tool named **DCSYNCMonitor**[32].
    This tool accepts a list of domain controllers and will generate an event when
    there is a request from an unknown source.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Windows event log, we can check for event ID 4662 and evaluate the **Property**
    value for control access rights:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1131f6ad-9c07-11d1-f79f-00c04fc2dcd2** (**DS-Replication-Get-Changes-All**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**89e95b76-444d-4c62-991a-0facbeda640c** (**DS-Replication-Get-Changes-In-Filtered-Set**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1131f6aa-9c07-11d1-f79f-00c04fc2dcd2** (**DS-Replication-Get-Changes**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we need to check whether the value of **Account Name** is a domain controller.
    If it is not, then we can reliably detect DCSync. Event ID 4662 will appear in
    the log even if DCSync is running locally on the domain controller.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as DCSync uses the RPC protocol, ETW can be used to detect it on an endpoint,
    based on the UUID for DRSUAPI. Correlating **DSRUAPI UUID** (**e3514235-4b06-11d1-ab04-00c04fc2dcd2**)
    and **OpNum 3** (**IDL_DRSGetNCChanges**) would be a good indicator of malicious
    activity[33].
  prefs: []
  type: TYPE_NORMAL
- en: Dumping user credentials in clear text via DPAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us go through a scenario. Following internal security policies and after
    security awareness training, users started using Credential Manager in Windows
    instead of **password.txt** files. Credential Manager is a built-in password manager
    in Windows that uses the **Data Protection API** (**DPAPI**). DPAPI allows programs,
    such as Chrome or RDP, to store sensitive data transparently. This data is stored
    in a user’s directory and is encrypted by a key that is derived from the user’s
    password. Our target user, **khal.drogo**, had credentials in their Credential
    Manager for SQL **system administrator** (**SA**) account. An adversary has compromised
    the user with domain admin privileges and intends to pull the sa password in clear
    text. There are three attack scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain **khal.drogo**’s master key and then decrypt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract all local master keys if you have local administrator privileges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract all backup master keys with the account in **Domain** **Admins** group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For demonstration purposes, we chose the third path. All commands are running
    under the **daenerys.targaryen** account (which is a member of “Domain Admins”
    group).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are required for successful password extraction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate credential files. Files are hidden and located in the following path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the **guidMasterKey** value by using the Mimikatz **dpapi::cred** command
    with the path to the credential file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extract backup master keys from the domain controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the master key of the user **khal.drogo**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decrypt saved credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of the command execution can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B18964_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.25 – Clear-text sa password
  prefs: []
  type: TYPE_NORMAL
- en: This technique can be detected by command-line auditing, generating event ID
    4688 for malicious tooling. A better option is to enable object auditing and check
    event ID 4662 for the object type (**SecretObject**), object name (***UPKEY***),
    and access mask (**0x2**) values.
  prefs: []
  type: TYPE_NORMAL
- en: Just a quick remark that dumping the backup key is possible via DCSync as well.
    Domain objectGUID of the key needs to be found in Active Directory for further
    dumping.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was devoted to tools and techniques that can help you get access
    to credentials either in clear-text or hashed form. Obtaining such sensitive data
    is a crucial step to progress further in attacking Active Directory. We have also
    discussed OpSec consideration and possible mitigation/detection options.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover lateral movement inside the domain and between
    forests. We will focus on relay and different types of pass-the-whatever attacks,
    finishing with Kerberos delegation abuse and lateral movement between forests.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internal Monologue Attack – Retrieving NTLM Hashes without Touching LSASS:
    [https://github.com/eladshamir/Internal-Monologue](https://github.com/eladshamir/Internal-Monologue)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pre-created computer account research: [https://www.trustedsec.com/blog/diving-into-pre-created-computer-accounts/](https://www.trustedsec.com/blog/diving-into-pre-created-computer-accounts/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exploiting GPP: [https://adsecurity.org/?p=2288](https://adsecurity.org/?p=2288)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'CrackMapExec: [https://github.com/Porchetta-Industries/CrackMapExec](https://github.com/Porchetta-Industries/CrackMapExec)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kerbrute: [https://github.com/ropnop/kerbrute](https://github.com/ropnop/kerbrute)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DomainPasswordSpray: [https://github.com/dafthack/DomainPasswordSpray](https://github.com/dafthack/DomainPasswordSpray)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'NTLM relay: [https://en.hackndo.com/ntlm-relay/](https://en.hackndo.com/ntlm-relay/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Responder: [https://github.com/lgandx/Responder](https://github.com/lgandx/Responder)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Harvesting NetNTLM: [https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/](https://www.mdsec.co.uk/2021/02/farming-for-red-teams-harvesting-netntlm/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Coerced authentication methods: [https://github.com/p0dalirius/windows-coerced-authentication-methods](https://github.com/p0dalirius/windows-coerced-authentication-methods)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SpoolSample: [https://github.com/leechristensen/SpoolSample](https://github.com/leechristensen/SpoolSample)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PetitPotam: [https://github.com/topotam/PetitPotam](https://github.com/topotam/PetitPotam)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'WebClient Service Scanner: [https://github.com/Hackndo/WebclientServiceScanner](https://github.com/Hackndo/WebclientServiceScanner)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remotely enable the WebClient service: [https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/](https://dtm.uk/exploring-search-connectors-and-library-files-on-windows/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ShadowCoerce: [https://github.com/ShutdownRepo/ShadowCoerce](https://github.com/ShutdownRepo/ShadowCoerce)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DFSCoerce: [https://github.com/Wh04m1001/DFSCoerce](https://github.com/Wh04m1001/DFSCoerce)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kerberos: [https://en.hackndo.com/kerberos/](https://en.hackndo.com/kerberos/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kerberos diagram: [https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ASREQRoast: [https://dumpco.re/blog/asreqroast](https://dumpco.re/blog/asreqroast)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pcredz: [https://github.com/lgandx/PCredz](https://github.com/lgandx/PCredz)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hashcat: [https://hashcat.net/hashcat/](https://hashcat.net/hashcat/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rubeus: [https://github.com/GhostPack/Rubeus](https://github.com/GhostPack/Rubeus)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kerberoast with OpSec: [https://m365internals.com/2021/11/08/kerberoast-with-opsec/](https://m365internals.com/2021/11/08/kerberoast-with-opsec/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'KerberOPSEC: [https://github.com/Luct0r/KerberOPSEC](https://github.com/Luct0r/KerberOPSEC)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'LAPS deploy: [https://theitbros.com/deploying-local-administrator-password-solution-laps-in-active-directory/](https://theitbros.com/deploying-local-administrator-password-solution-laps-in-active-directory/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'LAPSToolkit: [https://github.com/leoloobeek/LAPSToolkit](https://github.com/leoloobeek/LAPSToolkit)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get-LAPSPasswords: [https://github.com/kfosaaen/Get-LAPSPasswords](https://github.com/kfosaaen/Get-LAPSPasswords)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DSInternals: [https://github.com/MichaelGrafnetter/DSInternals](https://github.com/MichaelGrafnetter/DSInternals)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'GMSAPasswordReader: [https://github.com/rvazarkar/GMSAPasswordReader](https://github.com/rvazarkar/GMSAPasswordReader)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'gMSADumper: [https://github.com/micahvandeusen/gMSADumper](https://github.com/micahvandeusen/gMSADumper)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Dumping domain credentials: [https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#dumping-ad-domain-credentials](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#dumping-ad-domain-credentials)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DCSYNCMonitor: [https://github.com/shellster/DCSYNCMonitor](https://github.com/shellster/DCSYNCMonitor)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Detect a DCSync attack via ETW: [https://www.netero1010-securitylab.com/detection/dcsync-detection](https://www.netero1010-securitylab.com/detection/dcsync-detection)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These resources for further study will help you dive deeper into the attacks
    covered in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A good walk-through of WebDAV abuse and a further attack path: [https://pentestlab.blog/2021/10/20/lateral-movement-webclient/](https://pentestlab.blog/2021/10/20/lateral-movement-webclient/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A great writeup with traffic samples and event IDs generated during AS-REP
    roasting: [https://rioasmara.com/2020/07/04/kerberoasting-as-req-pre-auth-vs-non-pre-auth/](https://rioasmara.com/2020/07/04/kerberoasting-as-req-pre-auth-vs-non-pre-auth/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A blog post with a focus on detecting and preventing AS-REP roasting: [https://blog.netwrix.com/2022/11/03/cracking_ad_password_with_as_rep_roasting/](https://blog.netwrix.com/2022/11/03/cracking_ad_password_with_as_rep_roasting/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A step-by-step guide on how to implement and abuse gMSA in the domain: [https://www.dsinternals.com/en/retrieving-cleartext-gmsa-passwords-from-active-directory/](https://www.dsinternals.com/en/retrieving-cleartext-gmsa-passwords-from-active-directory/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A blog post about NTLM relay for gMSA passwords published by *Cube0x0*: [https://cube0x0.github.io/Relaying-for-gMSA/](https://cube0x0.github.io/Relaying-for-gMSA/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
