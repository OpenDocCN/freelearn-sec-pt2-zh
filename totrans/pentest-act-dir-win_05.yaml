- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lateral Movement in Domain and Across Forests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After an adversary establishes a foothold in the environment and/or harvests
    valid credentials, the next step is usually lateral movement. Lateral movement
    is a set of techniques that allows an attacker to move deeper into the target
    environment and search for high-value assets and sensitive data, including new
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with a scenario in which an attacker obtained a clear-text password
    (e.g., successful password spray attack) and now tries to blend in with usual
    environment traffic by abusing administrative protocols. As a next step, we will
    discuss how to relay the hash and the prerequisites for this move to be successful.
    To perform lateral movement, the attacker does not only require an **New Technology
    LAN Manager** (**NTLM**) response or clear-text password; it can be any other
    form of credential material: NT hash, key, or ticket. As Kerberos is recommended
    by Microsoft as the primary secure authentication protocol in the domain, we will
    cover three types of Kerberos delegation in detail. As the last step, we will
    focus on lateral movement between forests only and how a security mechanism called
    SID filtering can stop it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Abusing administrative protocols for lateral movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relay the hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the whatever
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kerberos delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Movement between domains and forests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will need to have access to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: VMware Workstation or Oracle VirtualBox with at least 16 GB of RAM, 8 CPU cores,
    and 55 GB of total space (more if you take snapshots)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Linux-based operating system is strongly recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed Vagrant with a plugin for the corresponding virtualization platform
    and Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GOADv2 project with all machines up and running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of administration protocols in the domain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover various administration protocols that are usually
    used by IT staff inside the domain for day-to-day support activities. We will
    discuss PowerShell features such as PSRemoting and **Just Enough Administration**
    (**JEA**). The **Remote Desktop Protocol** (**RDP**) is one of the most common
    protocols used by administration as well. We will briefly go through other protocols
    that can be used for lateral movement such as WMI, SMB, DCOM, and PSExec from
    Impacket.
  prefs: []
  type: TYPE_NORMAL
- en: PSRemoting and JEA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PSRemoting** allows you to connect to multiple computers and run the commands
    on them. Another option is that you can have a one-to-one interactive shell on
    the target machine. For simplicity, you can think of it as SSH, but for Windows
    to run PowerShell commands. In a nutshell, the client tries to connect to a tiny
    web server running on a destination server called the **WinRM listener**. HTTP
    or HTTPS protocols can be used to provide transport for authentication. We can
    list available listeners by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command on SRV02 is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – WinRM listeners on SRV02](image/B18964_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – WinRM listeners on SRV02
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s log in to the remote computer with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The traffic capture during authentication will be as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – PSRemoting login traffic capture](image/B18964_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – PSRemoting login traffic capture
  prefs: []
  type: TYPE_NORMAL
- en: If we are on a Linux machine, we can try the **evil-winrm** tool[1] to get an
    interactive shell. Also, PSRemoting supports different authentication protocols.
    Our focus will be only on Kerberos authentication. To be able to log in to the
    machine, the user should be a part of the **Administrators** or **Remote Management
    Users** groups. Also, it is important to mention that configuring a list of trusted
    machines by filling in the **Trusted Hosts** option in WinRM configuration and
    applying HTTPS as a transport protocol will benefit the security of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: In some environments, you can encounter **Just In Time** (**JIT**) administration
    and/orJEA. JIT is a security concept in which administrative rights can be assigned
    and revoked on a time-dependent basis. JEA is a concept that limits what certain
    users can do remotely on the machine. There is a good example of setting up JEA
    in a lab environment for training purposes[2]. We are not going to cover this
    in detail, but it is important to mention such security mechanisms. As usual,
    every security boundary can be bypassed if configured insecurely.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A good presentation with tips to escape can be found here: [https://www.triplesec.info/slides/3c567aac7cf04f8646bf126423393434.pdf](https://www.triplesec.info/slides/3c567aac7cf04f8646bf126423393434.pdf).
    A great toolkit called RACE[3] that can assist in getting persistence through
    JEA was released by *Nikhil Mittal*.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss the second most common administration protocol, which is
    RDP.
  prefs: []
  type: TYPE_NORMAL
- en: RDP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RDP allows you to connect to a remote computer and provides the same experience
    as if you were sitting in front of it, including the GUI as well. If you have
    the clear-text credentials of a compromised user, you can use RDP to access the
    target machine. This information can be found by the BloodHound tool during enumeration.
    To identify such users, BloodHound collects members of the **Remote Desktop Users**
    group on the computer and principals with **SeRemoteInteractiveLoginPrivilege**
    rights in the **Local Security Authority** (**LSA**) policy. If there is a user
    who meets both criteria, then the **CanRDP** edge appears[4]. For connection,
    we can use a Windows built-in client or **xfreerdp** from Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have only the NT hash, we can abuse the feature called **Restricted Admin**
    mode. In this mode, credentials won’t be sent to the remote computer and will
    not be stored in memory, because it transforms the logon to a **Network Logon
    (Type 3)** instead of a **Remote Interactive Logon (Type 10)**. This looks like
    a good security measure, but this is exactly why we can pass the hash to RDP.
    The main caveat is that the compromised user must be in the **Administrator**
    group and this mode needs to be enabled. Let us quickly demonstrate this mode
    in practice. To log in as **eddard.stark** in winterfell, we can use a Windows
    Native Client by doing pass-the-hash with Mimikatz first or **xfreerdp** from
    a Linux machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of running this command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Restricted Admin mode is not enabled](image/B18964_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Restricted Admin mode is not enabled
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, there is a tool called **RestrictedAdmin** available on GitHub[5].
    However, it is not OpSec safe, because it changes the registry key that is highly
    likely to be monitored by the blue team; different types of logon will be in the
    event logs as well. Running the following commands will enable this mode on the
    remote machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Enabling Restricted Admin mode](image/B18964_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Enabling Restricted Admin mode
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will be able to log in using pass-the-hash to RDP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Successful login to the target machine over RDP](image/B18964_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Successful login to the target machine over RDP
  prefs: []
  type: TYPE_NORMAL
- en: 'Two more things worth sharing regarding RDP: firstly, thanks to the **SharpRDP**
    tool[6], we can use RDP for the purposes of non-graphical authenticated remote
    command execution against a target in our preferable command-and-control software.'
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we can dump RDP credentials from the endpoint in different ways such
    as dumping from process memory, using **SharpRDPThief**[7], or from Windows Credentials
    Manager using Mimikatz.
  prefs: []
  type: TYPE_NORMAL
- en: A possible mitigation recommendation is to protect Remote Desktop credentials
    with **Windows Defender Remote Credential Guard**. It allows only Kerberos for
    authentication and prevents pass-the-hash and credential reuse after disconnecting.
    **Multi-factor authentication** (**MFA**) is another good option to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss ways to do lateral movement using Impacket. These protocols
    can be abused from Windows tooling as well, but introducing Impacket is important
    for the sake of knowledge and further chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Other protocols with Impacket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Impacket**[8] is a collection of Python classes that were created for working
    with various network protocols. In the **example** folder, there are tons of useful
    Python scripts that allow you various methods for lateral movement, dealing with
    Kerberos, accessing Windows secrets, and performing relay attacks. This toolkit
    is a great alternative to tools such as Rubeus, which are not available on Linux.
    We have the following lateral movement options in Impacket to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PSExec** is loud and catches defenders’ attention quite quickly, as it uploads
    executables and creates a service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SmbExec** creates a service on every request but does not upload anything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AtExec** creates scheduled tasks in **C:\Windows\System32\Tasks\** as **SYSTEM**
    with a random name and provides output in a file located at **C:\Windows\Temp\**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DCOMExec** requires file creation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WMIExec** requires file creation and deletion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these techniques can be caught with enhanced monitoring such as Sysmon
    and correlation of the Windows event logs.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a good prevention strategy is to deploy **Attack Surface Reduction** (**ASR**)
    rules. ASR prevents typical malicious actions on the endpoints such as process
    creation from different applications, prevents execution of files depending on
    their origin and various conditions, vulnerable signed drivers loading, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will cover NTLM response relay attacks and different
    types of hashes.
  prefs: []
  type: TYPE_NORMAL
- en: Relaying the hash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered different possibilities to capture the NTLM
    response by forcing authentication or using MitM. Now we are getting to the answer
    of why we want to capture responses. Before we jump into practice, some theory
    concepts and caveats need to be explained first.
  prefs: []
  type: TYPE_NORMAL
- en: First, there are two versions of the NTLM protocol (v1 and v2). Next, NTLM authentication
    messages can be relayed cross-protocol as they are protocol-independent. It is
    important to understand what protocol was used to capture NTLM authentication
    and what protocol we are planning to relay it over. The following mindmap was
    created by *nwodtuhs* and is a good reference for our discussion.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – NTLM relay](image/B18964_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – NTLM relay
  prefs: []
  type: TYPE_NORMAL
- en: Let us focus more on an important topic, which is signing, especially for SMB
    and LDAP. Signing configuration and existence is controlled by settings on the
    client and server side. For SMB, it will depend on the protocol version and whether
    the server is a domain controller. The key takeaway is that signing for SMB v2
    must be required by the server and/or client. LDAP behaves differently and packets
    will be signed if both sides are able to do so, but is not specifically required.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Notable examples of LDAP and SMB signing configuration and negotiation can
    be found here: [https://en.hackndo.com/ntlm-relay/](https://en.hackndo.com/ntlm-relay/).'
  prefs: []
  type: TYPE_NORMAL
- en: But session signing is negotiated during the NTLM authentication, maybe we can
    try to unset it? Here, we will learn more about **Message Integrity Code** (**MIC**),
    which is available only in NTLM v2\. The **MIC** is a signature resulting from
    the **HMAC_MD5** function calculated over a few parameters. The most important
    parameters are the session key, which depends on the client’s secret, and the
    value, which states whether the signing is negotiated. If we do not know the client’s
    secret, the **MIC** can’t be changed. However, two vulnerabilities were found
    by researchers from a company called *Preempt* and were conveniently named **Drop
    the MIC** (**CVE-2019-1040**) and **Drop the MIC 2** (**CVE-2019-1166**), allowing
    to simply remove the **MIC**.
  prefs: []
  type: TYPE_NORMAL
- en: Another vulnerability, **CVE-2019-1019**, which was a successor of **CVE-2015-005**,
    allows the retrieval of the session key for any authentication attempt by missing
    the computer name while establishing the **NETLOGON** channel. A detailed attack
    walk-through can be found here[9].
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we are going to cover is **Extended Protection for Authentication**
    (**EPA**). It was introduced against cross-protocol relay allowing it to bind
    the authentication layer with the protocol. If the TLS channel is required to
    be bound (LDAPS or HTTPS), the server certificate hash (called **Channel Binding
    Token**) will be used as a part of the NTLM response, meaning that spoofing is
    not possible without knowing the client’s secret. For non-TLS protocols such as
    CIFS or HTTP, the field is called **Service Binding Information**. The idea is
    very similar to TLS binding, but instead of using the certificate’s hash target,
    the **Service Principal Name** (**SPN**) will be checked in the NTLM response.
    In both cases, a mismatch will lead to an “Access Denied” error.
  prefs: []
  type: TYPE_NORMAL
- en: That was a hefty amount of theory! Let’s move on to some practice and see the
    benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If something is not going as expected, the following lab creator has your back
    covered: [https://mayfly277.github.io/posts/GOADv2-pwning-part4/](https://mayfly277.github.io/posts/GOADv2-pwning-part4/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first enumerate machines that do not require SMB signing. We can do
    it using **CrackMapExec**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a list of the machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Machines with SMB signing disabled](image/B18964_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Machines with SMB signing disabled
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we captured the NTLM response of **eddard.stark**
    because of the scheduled task running with a typo in the DNS name. Now, let us
    use it for relay. We disable SMB and HTTP servers in Responder by editing **/etc/responder/Responder.conf**
    and running **ntlmrelayx** to dump the SAM database on castelblack as the **eddard.stark**
    user has administrator rights on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the result of dumping the **Security Accounts
    Manager** (**SAM**) database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Relay NTLM v2 response and dumping the SAM database](image/B18964_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Relay NTLM v2 response and dumping the SAM database
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention that since **MS08-68**, it is not possible to relay
    the hash toward itself. There is also an option in **ntlmrelayx (--socks)** to
    use an SMB connection as a **SOCKS** proxy, avoiding noisy login and not requiring
    administrative rights on the box. Then, we can use proxy chains to run the tools
    we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a next step, we will use a relay for LDAP enumeration. We can’t relay the
    hash that was obtained over SMB as the domain controller requires signing, so
    we can use the WebDAV service if installed (as shown here by *Jean_Maes_1994*:
    [https://www.trustedsec.com/blog/a-comprehensive-guide-on-relaying-anno-2022/](https://www.trustedsec.com/blog/a-comprehensive-guide-on-relaying-anno-2022/))
    or try **mitm6**. An excellent walk-through of how to use the **mitm6** toolkit
    was demonstrated by the lab creator, so we will show the WebDAV scenario and apply
    necessary changes in the lab to **castelblack**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, you can read more information here: [https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications/webclient](https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications/webclient).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first preparation step on castelblack, we need to install a feature called
    **WebDAV Redirector** using PowerShell as **Administrator**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we can see that the feature was successfully installed
    and the service was stopped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – WebClient service was successfully installed](image/B18964_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – WebClient service was successfully installed
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now force the WebClient service to start by placing the **.searchConnector-ms**
    file on the public share, as described by *MDSec* researchers, with content such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then verify that the service has successfully started. If we do not
    know any server in the network with a running WebClient service, we can scan the
    IP range using the **CrackMapExec** module, **WebDAV**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of our recon activity are presented in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – WebClient service recon](image/B18964_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – WebClient service recon
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to use the coercion method to trigger authentication over
    HTTP to our Kali machine and then relay it to LDAP. We will need Responder with
    a disabled HTTP server and **ntlmrelayx**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For our exercise, I chose PrinterBug as a coercion method and its implementation
    on Linux via a tool called **dementor**[10]. The following screenshot shows the
    result of dumping domain information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Domain enumeration LDAP](image/B18964_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Domain enumeration LDAP
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last example, I would like to show **CVE-2019-1040** in action. *Mayfly*
    introduced a vulnerable server in the lab. To find vulnerable boxes, we can use
    a scanner created by *_dirkjan*[11]. The following command will check whether
    the target is vulnerable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to relay SMB to LDAP in the patched system, it will lead to the following
    error in **ntlmrelayx**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – SMB to LDAP relay failed](image/B18964_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – SMB to LDAP relay failed
  prefs: []
  type: TYPE_NORMAL
- en: 'But if there is a *Drop the MIC* vulnerability, we can add the **-–remove-mic**
    flag and, as a result, successfully relay, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Drop the MIC allowed to relay](image/B18964_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Drop the MIC allowed to relay
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To get more information on how to prevent certain types of relays, we can use
    the Nettitude blog post ([https://labs.nettitude.com/blog/network-relaying-abuse-windows-domain/](https://labs.nettitude.com/blog/network-relaying-abuse-windows-domain/))
    as a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Killing relay attack vectors will require a significant number of services to
    be reviewed and tested, so signing can be enforced for SMB, LDAP, and EPA for
    LDAPS and HTTPS. Fine-tune IPv6, and disable broadcast protocols and unused services
    as a domain-hardening exercise. Try to use only Kerberos for authentication in
    the domain, but if it is not possible, then only use NTLM v2\. NTLM v1 should
    be disabled entirely!
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss the ways to perform lateral movement after
    the attacker is able to compromise the machine and dump credentials in the form
    of an NT hash, AES key, or a ticket.
  prefs: []
  type: TYPE_NORMAL
- en: Pass-the-whatever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is about impersonation. Let's say an attacker compromised a machine
    and dumped hashed credentials from the LSASS process using one of many available
    ways. Usually, the next step is to perform lateral movement by starting a new
    logon session and trying to access other company resources. We will discuss the
    most common ways to perform such an activity together with OpSec considerations.
    **Pass the certificate** will be covered in [*Chapter 8*](B18964_08.xhtml#_idTextAnchor163)
    related to *Active Directory* *Certificate Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Pass-the-hash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to start with good old pass-the-hash. This method of authentication
    itself is quite straightforward. It relies only on the NTLM protocol, not touching
    Kerberos at all. This technique can be used for local and domain accounts. To
    perform a pass-the-hash attack, the attacker needs to have administrative privileges
    on the box.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is a detailed and well-written description of what is happening under
    the hood by **hackndo** in his blog post at [https://en.hackndo.com/pass-the-hash/](https://en.hackndo.com/pass-the-hash/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The technique can be executed with the help of Mimikatz in an elevated context.
    In our example, an attacker was able to compromise a local administrative **vagrant**
    user and dump an NT hash for the user with domain administrator privileges. In
    our case, it is **robert.baratheon** in the **sevenkingdoms** domain. We can perform
    pass-the-hash by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Pass-the-hash with Mimikatz](image/B18964_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Pass-the-hash with Mimikatz
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we will have a new PowerShell window opened. Do not be confused
    that we are shown as a **vagrant** user in the new PowerShell session. In reality,
    we have impersonated **robert.baratheon**. The following screenshot proves it
    in the PSRemoting session.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Pass-the-hash used to access the domain controller](image/B18964_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Pass-the-hash used to access the domain controller
  prefs: []
  type: TYPE_NORMAL
- en: Also, there is a caveat called **User Account Control** (**UAC**), which can
    limit remote administration operations on newly compromised machines after we
    successfully move laterally. It will depend on two registry values, **LocalAccountTokenFilterPolicy**
    and **FilterAdministratorToken**, located in **HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System**.
    By default, only a built-in administrator with a **Relative Identifier** (**RID**)
    of **500** and domain accounts with local admin rights can perform remote administration
    tasks without UAC being activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can discuss the detection of this technique. The best way to detect
    pass-the-hash is to review the **4624** and **4672** events on the source host.
    Event **4624** has a logon type of **9** and a logon process of **seclogo**, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Event 4624 on the host where the pass-the-hash attack was executed](image/B18964_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Event 4624 on the host where the pass-the-hash attack was executed
  prefs: []
  type: TYPE_NORMAL
- en: 'Event ID **4672** identifies privileged logon for the current logged-in account,
    not the new account, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Event 4672 on the host where the pass-the-hash attack was executed](image/B18964_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Event 4672 on the host where the pass-the-hash attack was executed
  prefs: []
  type: TYPE_NORMAL
- en: The domain controller would not have corresponding event IDs **4768** and **4769**.
    Also, we should not forget that by using Sysmon, we can reliably detect access
    to the LSASS process, which happens when Mimikatz is used for pass-the-hash. By
    combining both events, we can reliably detect pass-the-hash.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Defender for Identity by Microsoft stated that it can detect pass-the-hash attacks
    by analyzing whether the NT hash used was from computers that the user uses regularly
    ([https://learn.microsoft.com/en-us/defender-for-identity/lateral-movement-alerts](https://learn.microsoft.com/en-us/defender-for-identity/lateral-movement-alerts)).
  prefs: []
  type: TYPE_NORMAL
- en: Pass-the-key and overpass-the-hash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pass-the-key and overpass-the-hash are attacks aimed at Kerberos authentication.
    The plan is to obtain a valid Kerberos TGT by supplying the user’s secret key
    (**DES**, **RC4**, **AES128**, or **AES256**) derived from the user’s password.
    If RC4 is enabled, meaning that the user’s NT hash is a key, this is **overpass-the-hash**.
    If RC4 is disabled, other Kerberos keys can be passed, and it is called **pass-the-key**.
    Now, by default, Windows is using **AES256** keys, which have an encryption type
    value of **0x12**. Requesting downgraded RC4 encryption will have an encryption
    type value of **0x17**. This value can be found in event **4768** on the domain
    controller. Using Rubeus as an attacker, a normal user can request Kerberos TGT
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, a ticket will be injected into memory and access to the **c$**
    domain controller will be granted, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Injected ticket because of overpass-the-hash](image/B18964_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Injected ticket because of overpass-the-hash
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is event **4768** with RC4 downgrade requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Downgraded encryption type in event 4768](image/B18964_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Downgraded encryption type in event 4768
  prefs: []
  type: TYPE_NORMAL
- en: 'Both techniques can be detected on the endpoint via the LSASS access rule if
    Mimikatz is used and there will be a mismatch between the logged-on user and its
    Kerberos tickets. Encryption type downgrades stand out in modern Windows environments
    and will be investigated. Rubeus has the **/opsec** flag, which will send an initial
    AS-REQ without pre-authentication mimicking genuine requests. This option is intended
    to make traffic stealthier, which is why only the **AES256** encryption type is
    allowed to be used. Such a key can be dumped by using Mimikatz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create another ticket and compare the generated event with the previous
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The Windows event is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Rubeus with the /opsec option in event 4768](image/B18964_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Rubeus with the /opsec option in event 4768
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that **Ticket Options** (thank you, **/opsec** option) and **Ticket
    Encryption Type** changed. Another thing to consider if we want to fully mimic
    real Kerberos authentication is **Supplied Realm Name**, which will be **SEVENKINGDOMS**
    for genuine requests ( the **/domain** option for the rescue here):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Supplied Realm Name for genuine TGT request](image/B18964_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – Supplied Realm Name for genuine TGT request
  prefs: []
  type: TYPE_NORMAL
- en: The most challenging problem is that Rubeus will generate Kerberos traffic,
    meaning it can be detected by all sorts of defensive tools. This is something
    that needs to be considered.
  prefs: []
  type: TYPE_NORMAL
- en: Pass-the-ticket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we can encounter situations when we obtain a ticket to inject, or we
    are able to forge one. We will discuss four types of forged tickets with examples
    of how to forge, use, and detect them in [*Chapter 7*](B18964_07.xhtml#_idTextAnchor146).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, tickets can be dumped from memory or found on the filesystem in Linux
    (**.ccache**) or Windows (**.kirbi**) formats. In Windows, tickets after injection
    (the **/ptt** option in Rubeus) can be used natively, as we have seen in the previous
    example. Let’s use the same ticket but on our Kali machine. First, we need to
    convert it from the **kirbi** to **ccache** format using **ticketConverter** from
    Impacket, then export the ticket. The commands are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Ticket conversion from Rubeus](image/B18964_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Ticket conversion from Rubeus
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can use the ticket for remote access using the following command (you
    just need to add entries to **/etc/hosts** on your Kali machine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The code execution is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Pass-the-ticket for command execution](image/B18964_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – Pass-the-ticket for command execution
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The detection guide for this attack can be found here: [https://www.netwrix.com/pass_the_ticket.xhtml](https://www.netwrix.com/pass_the_ticket.xhtml).
    In general, the strategy is the same as for the pass-the-key attack. There is
    a proof-of-concept code published to check the mismatch between logged-on users
    and issued Kerberos tickets[12].'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be covering three types of Kerberos delegation
    and how they can be abused for lateral movement. This type of attack can also
    be considered a **privilege** **escalation attack**.
  prefs: []
  type: TYPE_NORMAL
- en: Kerberos delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, we need to discuss what delegation is and why it exists. Services
    within Active Directory sometimes need to be accessed by other services on behalf
    of the domain user. Think of a web server authenticating to the database on the
    backend on behalf of the user. There are three types of delegation available in
    **Active Directory** (**AD**) – **unconstrained**, **constrained**, and **resource-based**.
    Information about delegation can be found by using BloodHound, PowerView, or the
    AD module. We will cover the types of delegation in the following respective sections.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For our lab, *Mayfly* prepared, as usual, a great walk-through to follow: [https://mayfly277.github.io/posts/GOADv2-pwning-part10/](https://mayfly277.github.io/posts/GOADv2-pwning-part10/).'
  prefs: []
  type: TYPE_NORMAL
- en: Unconstrained delegation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start our journey with the oldest type of delegation. With unconstrained
    delegation enabled on the computer or user, it is possible to impersonate an authenticating
    user or computer to any service on any host. If we compromise the user or machine
    with unconstrained delegation, we can then wait or force authentication to it,
    extract from ST cached in memory copy of the target user/computer TGT, and then
    reuse it for access across the domain or even forest. By default, domain controllers
    have unconstrained delegation enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I will suggest having a look at [https://www.thehacker.recipes/ad/movement/kerberos/delegations/unconstrained](https://www.thehacker.recipes/ad/movement/kerberos/delegations/unconstrained)
    for reference on how unconstrained delegation can be abused from an attacker’s
    Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will enable unconstrained delegation on Castelrock, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – Castelrock with unconstrained delegation enabled](image/B18964_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24 – Castelrock with unconstrained delegation enabled
  prefs: []
  type: TYPE_NORMAL
- en: 'To find computers with unconstrained delegation, we can use PowerView:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows the domain controller (**kingslanding**) and the **castelrock**
    server with the **TRUSTED_FOR_DELEGATION** flag in the **useraccountcontrol**
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Computer with unconstrained delegation enabled](image/B18964_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25 – Computer with unconstrained delegation enabled
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can use the LDAP filter (**userAccountControl:1.2.****     840.113556.1.4.803:=524288**) together with the AD PowerShell module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a next step, we assume that we were able to compromise the **castelrock**
    server, so we can abuse unconstrained delegation. From an elevated context, we
    will launch Rubeus in monitoring mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'From the standard user context, we force authentication from the domain controller
    by using PrinterBug:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26 – Forcing the domain controller to authenticate](image/B18964_05_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.26 – Forcing the domain controller to authenticate
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, we captured the domain controller’s TGT:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27 – TGT of domain controller](image/B18964_05_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.27 – TGT of domain controller
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we inject this ticket in memory with Rubeus and use Mimikatz to dump the
    domain admin NT hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the previous command can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28 – Domain admin user’s NT hash](image/B18964_05_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.28 – Domain admin user’s NT hash
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A great example of how unconstrained delegation can be abused using **krbrelayx**
    is shown in this blog post: [https://pentestlab.blog/2022/03/21/unconstrained-delegation/](https://pentestlab.blog/2022/03/21/unconstrained-delegation/).'
  prefs: []
  type: TYPE_NORMAL
- en: To prevent abuse, check whether the unconstrained delegation is enabled only
    on domain controllers. If unconstrained delegation is absolutely required elsewhere,
    ensure that all privileged accounts have the **sensitive and cannot be delegated**
    flag or are members of the **Protected Users** group, as TGT will not be delegated
    in the service ticket for such accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Resource-based constrained delegation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Windows 2012, a new delegation type was introduced, called **resource-based
    constrained delegation** (**RBCD**). The idea is that delegation is configured
    by the service administrator on the target, not on the source. This is written
    in the **msDS-AllowedToActOnBehalfOfOtherIdentity** attribute. The most common
    way to abuse RBCD is to create a computer account, edit the target delegation
    attribute, and obtain a ticket.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we will start with enumeration. We need to find out the **machine
    account quota** value (by default, every domain user can create 10 accounts),
    and check whether RBCD has been already implemented and whether there are **GenericAll**
    or **GenericWrite** **Access Control List** (**ACLs**) on any computer in the
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: The machine quota can be found with the help of the **StandIn** tool[13] written
    by *FuzzySec:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that this domain uses the default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29 – Default machine account quota value](image/B18964_05_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.29 – Default machine account quota value
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also enumerate a machine account quota with PowerView:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to enumerate an ACL in the domain. We can do it with PowerView’s
    **Invoke-ACLScanner** or a similar tool. The interesting output is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30 – The user has GenericAll on the domain controller](image/B18964_05_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.30 – The user has GenericAll on the domain controller
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create a computer account by using PowerMad[14], or **addcomputer**
    from Impacket, or, in our case, **StandIn**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.31 – A new computer account is created](image/B18964_05_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.31 – A new computer account is created
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compromise the **stannis.baratheon** user who can change attributes on
    **kingslanding**, then add a computer account to the domain, we can set the **msDS-AllowedToActOnBehalfOfOtherIdentity**
    property to a newly created computer account using the PowerShell AD module, PowerView,
    or StandIn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the previous commands is in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.32 – A new computer account is created](image/B18964_05_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.32 – A new computer account is created
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can obtain a ticket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.33 – Successful RBCD attack](image/B18964_05_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.33 – Successful RBCD attack
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can achieve persistence by using the RACE toolkit written by *Nikhil
    Mittal* by modifying the permissions of a computer object.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent RBCD abuse, we can review ACL in the domain on a regular basis, reduce
    the machine account quota to **0** (**ms-DS-MachineAccountQuota**), and ensure
    that only privileged users can add machines to the domain. Also, apply the **is
    sensitive and cannot be delegated** account property and the **Protected Users**
    group for high-privileged accounts. It is important to mention that just setting
    the machine account quota to **0** does not prevent this attack[15].
  prefs: []
  type: TYPE_NORMAL
- en: Constrained delegation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main difference between unconstrained and constrained delegation is that
    an account is allowed to impersonate users only against certain services. It can
    be configured with (**Use any authentication protocol**) or without (**Use Kerberos
    only**) protocol transition, as shown in the following delegation properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.34 – Constrained delegation configuration](image/B18964_05_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.34 – Constrained delegation configuration
  prefs: []
  type: TYPE_NORMAL
- en: Delegation in this case uses two Kerberos extensions, called **Service for User
    to Self** (**S4U2Self**) and **Service for User to** **Proxy** (**S4U2Proxy**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A deep dive into the Kerberos extensions and how they work can be found here:
    https://www.netspi.com/blog/technical/network-penetration-testing/cve-2020-17049-kerberos-bronze-bit-theory/.'
  prefs: []
  type: TYPE_NORMAL
- en: In brief, the S4U2Proxy protocol allows one service to obtain a service ticket
    for another service on behalf of a user in constrained delegation without a protocol
    transition case. S42Self is used in the protocol transition case, allowing the
    service to obtain a service ticket for itself on behalf of a user when Kerberos
    was not used for authentication (for example, NTLM v2). Then, the S4U2Proxy protocol
    can be followed, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constrained delegation can be configured for user and computer accounts. Enumeration
    with PowerView can be done with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of enumeration is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.35 – Enumerate users and computers with constrained delegation enabled](image/B18964_05_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.35 – Enumerate users and computers with constrained delegation enabled
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way is to use the **findDelegation** Python script from Impacket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will show a constrained delegation type as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.36 – Enumerate delegation type](image/B18964_05_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.36 – Enumerate delegation type
  prefs: []
  type: TYPE_NORMAL
- en: 'Constrained delegation with protocol transition can be abused with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.37 – Result of constrained delegation with protocol transition abuse](image/B18964_05_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.37 – Result of constrained delegation with protocol transition abuse
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention that the SPN part is not encrypted in the request,
    which is why we can use the **/altservice** option from Rubeus to get a service
    ticket – in our case, WinRM.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A great list of available services can be found here: [https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/silver-ticket#available-services](https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/silver-ticket#available-services).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTTP service is configured without protocol transition, as in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.38 – Configured constrained delegation without protocol transition](image/B18964_05_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.38 – Configured constrained delegation without protocol transition
  prefs: []
  type: TYPE_NORMAL
- en: In this case, S4U2Self requests will not result in a forwardable ticket, thus
    S4U2Proxy will not work. Two known ways to abuse constrained delegation without
    protocol transition are by operating an RBCD attack on the service or by forcing
    a user to authenticate to the service to extract the ticket. To abuse constrained
    delegation without protocol transition, we will create a computer account, and
    set **castelblack** to allow RBCD from it (we need **SYSTEM** access to set this
    property). Then, we will delegate as **administrator** into **castelblack**, and
    finally, we can use this forwardable ST in the S4U2Proxy request to service on
    **Winterfell**. It sounds complicated, but we will execute this attack step by
    step.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, we will create a session as **Castelblack$**, create a computer
    account named **Test$**, retrieve its **Security Identifier** (**SID**), and set
    the **msDS-AllowedToActOnBehalfOfOtherIdentity** attribute of **Castelblack$**
    to **Test$**. I will use Mimikatz, PowerView, and StandIn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the StandIn commands is in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.39 – Creating a computer account and preparing RBCD abuse](image/B18964_05_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.39 – Creating a computer account and preparing RBCD abuse
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will calculate the AES256 key from the computer account’s password
    and abuse RBCD using **Test$** on **Castelblack$**. Now, we have forwardable ST
    for **Castelblack$**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will use the forwardable ST to get access to winterfell’s filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the attack is in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.40 – Successful abuse of the constrained delegation without protocol
    transition](image/B18964_05_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.40 – Successful abuse of the constrained delegation without protocol
    transition
  prefs: []
  type: TYPE_NORMAL
- en: These steps can be performed from a Linux machine too, as shown in the walk-through
    by the lab creator[16].
  prefs: []
  type: TYPE_NORMAL
- en: Bronze Bit attack aka CVE-2020-17049
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For certain types of delegation abuse, the ticket needs to have a **forwardable**
    flag set. Reasons for the flag not being set can be that the impersonated user
    is a member of the **Protected Users** group or was configured with the **is sensitive
    and cannot be delegated** flag. Also, the service can be configured for **Kerberos
    only** constrained delegation. In 2020, the Bronze Bit vulnerability was discovered,
    allowing the attacker to edit the ticket and set the desired **forwardable** flag.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, we can use a **force-forwardable** flag from the **getST** Python
    script in Impacket.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A good practical example with the two most common scenarios can be found here:
    [https://www.netspi.com/blog/technical/network-penetration-testing/cve-2020-17049-kerberos-bronze-bit-attack/](https://www.netspi.com/blog/technical/network-penetration-testing/cve-2020-17049-kerberos-bronze-bit-attack/).'
  prefs: []
  type: TYPE_NORMAL
- en: The only recommendation is to patch the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: After lateral movement inside the domain, the attacker may propagate further
    to trusted forests. The next section will cover possible limitations in such movement
    and introduce available security mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Abusing trust for lateral movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss various ways to abuse forest trust
    for lateral movement. Movement from the child to the parent domain inside the
    forest is covered in [*Chapter 6*](B18964_06.xhtml#_idTextAnchor119)*/*
  prefs: []
  type: TYPE_NORMAL
- en: We will start by covering the necessary theory and then apply it to practice.
    As stated by Microsoft, a **forest** is a security boundary and consists of one
    or more AD domains that share a common schema, configuration, and global catalog.
    **The schema** defines objects within the forest, and the global catalog contains
    a partial attribute set of each object in the forest domains. There are six types
    of trust relationships; we will focus our attention on the **External** and **Forest**
    types. To understand more about security boundaries, we need to discuss the **Security
    Identifier** (**SID**), the **SID history** attribute, and **SID filtering**.
  prefs: []
  type: TYPE_NORMAL
- en: SID is a unique identifier assigned to each security principal in the domain.
    SID filtering is a mechanism that filters out SIDs from other domains.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Filtering rules can be found here: [https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/55fc19f2-55ba-4251-8a6a-103dd7c66280](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/55fc19f2-55ba-4251-8a6a-103dd7c66280).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Briefly, there are two main points to remember regarding lateral movement possibility
    and SID filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: If SID filtering is fully enforced, all SIDs that are not from a trusted domain
    will be filtered. However, the *Enterprise Domain Controllers* SID, *Trusted Domain
    Object* SIDs, and *NeverFilter* SIDs were exempt from domain trust SID filtering[17].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **External** trust is more relaxed than **Forest**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next moving part is **SID history**. SID history is a property of a user
    or group that allows the keeping of an old SID during the migration from one domain
    to another in order to keep necessary access. SID history values can be filtered,
    depending on SID filtering behavior. Inter-forest trusts have different authentication
    levels available: **forest-wide**, **domain-wide**, and **selective**. Selective
    authentication is the strictest as it has a direct match between the subject and
    object. This is the bare minimum amount of theory required to understand how to
    move across forests.'
  prefs: []
  type: TYPE_NORMAL
- en: As a first step, we will enumerate trusts in the forests in the lab. Then, we
    will discuss common attack vectors and their limitations such as password reuse,
    foreign group member compromise, unconstrained delegation abuse between forests,
    and injection of an extra SID into the SID history.
  prefs: []
  type: TYPE_NORMAL
- en: 'For trust enumeration, we have plenty of tools at our disposal, such as PowerView,
    BloodHound, or the Netdom utility. The following commands are available in PowerView:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get-DomainTrust**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-ForestTrust**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-DomainTrustMapping**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result of the first command execution is in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.41 – All trusts for the current user’s domain](image/B18964_05_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.41 – All trusts for the current user’s domain
  prefs: []
  type: TYPE_NORMAL
- en: We will start our discussion about attacking options in password reuse attacks.
    In a real environment, this attack is often successful. Dump users from the compromised
    forest, look for the same user accounts in the external forest, and then try password
    reuse against them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can enumerate foreign groups and users with the help of PowerView
    commands (**Get-DomainForeignUser** and **Get-DomainForeignGroupMember**) or by
    using the BloodHound query provided by *Mayfly* in his walk-through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are users and groups that have access across domains and forests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.42 – Users and groups with cross-domain and forest rights](image/B18964_05_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.42 – Users and groups with cross-domain and forest rights
  prefs: []
  type: TYPE_NORMAL
- en: After we compromise the user with membership in a group such as **SPYS**, we
    can laterally move between forests and enjoy our new privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to break forests’ trust is by abusing **Kerberos unconstrained
    delegation** (**KUD**) between the local machine with KUD enabled and the domain
    controller in the external forest by coercing authentication using PrinterBug
    or PetitPotam. However, it is possible only if TGT delegation is enabled, which
    was true by default till March 2019[18]. In our case, we replicate the attack
    with the help of Rubeus and PrinterBug to force authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we dumped all hashes from the **essos** forest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.43 – Hashes of all domain objects from the essos forest](image/B18964_05_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.43 – Hashes of all domain objects from the essos forest
  prefs: []
  type: TYPE_NORMAL
- en: 'SID filtering can be in three states: **disabled**, **relaxed**, and **enforced**.
    If SID filtering is disabled, the attacker will be able to simply add the RID
    of the **Enterprise Admins** group and get access to the target domain controller
    for the **DCSync** attack.'
  prefs: []
  type: TYPE_NORMAL
- en: With SID filtering fully enforced, the only possibility for lateral movement
    is to compromise domain users with privileges in the target forest or bypass SID
    filtering by exploiting CVE-2020-0665.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Exploitation steps are well described here: [https://www.thehacker.recipes/ad/movement/trusts#cve-2020-0665](https://www.thehacker.recipes/ad/movement/trusts#cve-2020-0665).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If SID history is enabled, it means that SID filtering is relaxed (the **TREAT_AS_EXTERNAL**
    flag). In such a scenario, an attacker can spoof their membership in any group
    with **RID > 1000**[19] by adding the group’s SID in the SID history attribute.
    In our example, we will enumerate groups in the **essos.local** forest with the
    help of PowerView looking for interesting groups with **RID >** **1000**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we found several promising candidates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.44 – Domains groups in essos.local with RID > 1000](image/B18964_05_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.44 – Domains groups in essos.local with RID > 1000
  prefs: []
  type: TYPE_NORMAL
- en: '**Spys** has **GenericAll** on the **jorah.mormont** user, meaning we can take
    full control over this user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The password was changed successfully, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.45 – Successful password change](image/B18964_05_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.45 – Successful password change
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the new password was set successfully with **crackmapexec**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.46 – Successful login with the new password](image/B18964_05_46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.46 – Successful login with the new password
  prefs: []
  type: TYPE_NORMAL
- en: To prevent inter-forest abuse, ensure that strict SID filtering is enforced,
    TGT delegation and SID history are disabled, and ACLs are correctly applied to
    objects in the forest. However, if the attacker was able to compromise or impersonate
    a user with a foreign group membership, only selective authentication can limit
    the damage.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered the topic of lateral movement. We discussed how administrative
    protocols can be used for movement across the environment. It is an effective
    way to blend in with normal traffic and fly under the radar. The concept of relaying
    the hash is a powerful weapon in environments lacking hardening. Simple recommendations
    such as disabling unused protocols and services can significantly improve security
    posture. It is important to mention that, in complex environments, even simple
    changes can create chaos and outages, and thorough testing is required. A deep
    dive into Kerberos authentication, different delegation types, and ways to abuse
    them helped to understand in more detail the complexity of the Kerberos protocol
    itself and the security implications of each delegation type. We have demonstrated
    in practice that for successful lateral movement, attackers do not necessarily
    need the victim’s password. It can be any form of credential material, such as
    a hash, ticket, or key. Staying stealthy and mimicking real authentication attempts
    require an in-depth understanding of your tradecraft. In [*Chapter 8*](B18964_08.xhtml#_idTextAnchor163),
    we will demonstrate that certificates can also be used for lateral movement. Last
    but not least, lateral movement between forests shows that it is not only about
    how secure you are but also who your trustees are. In the next chapter, we will
    discuss privilege escalation inside the domain.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Evil-WinRM: [https://github.com/Hackplayers/evil-winrm](https://github.com/Hackplayers/evil-winrm)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up JEA in the lab: [https://cheats.philkeeble.com/active-directory/ad-privilege-escalation/jea](https://cheats.philkeeble.com/active-directory/ad-privilege-escalation/jea)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'RACE toolkit: [https://github.com/samratashok/RACE](https://github.com/samratashok/RACE)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'User Rights Assignment: RDP - [https://blog.cptjesus.com/posts/userrightsassignment/](https://blog.cptjesus.com/posts/userrightsassignment/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'RestrictedAdmin: [https://github.com/GhostPack/RestrictedAdmin](https://github.com/GhostPack/RestrictedAdmin)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SharpRDP: [https://github.com/0xthirteen/SharpRDP](https://github.com/0xthirteen/SharpRDP)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SharpRDPThief: [https://github.com/passthehashbrowns/SharpRDPThief](https://github.com/passthehashbrowns/SharpRDPThief)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Impacket: [https://github.com/fortra/impacket](https://github.com/fortra/impacket)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'CVE-2019-1019 writeup: [https://securityboulevard.com/2019/06/your-session-key-is-my-session-key-how-to-retrieve-the-session-key-for-any-authentication/](https://securityboulevard.com/2019/06/your-session-key-is-my-session-key-how-to-retrieve-the-session-key-for-any-authentication/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Dementor: [https://github.com/NotMedic/NetNTLMtoSilverTicket/blob/master/dementor.py](https://github.com/NotMedic/NetNTLMtoSilverTicket/blob/master/dementor.py)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drop-the-MIC scanner: [https://github.com/fox-it/cve-2019-1040-scanner](https://github.com/fox-it/cve-2019-1040-scanner)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Checking the username of logged-in users to the Kerberos tickets: [https://gist.github.com/JoeDibley/fd93a9c5b3d45dbd8cbfdd003ddc1bd1](https://gist.github.com/JoeDibley/fd93a9c5b3d45dbd8cbfdd003ddc1bd1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'StandIn: [https://github.com/FuzzySecurity/StandIn](https://github.com/FuzzySecurity/StandIn)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Powermad: [https://github.com/Kevin-Robertson/Powermad](https://github.com/Kevin-Robertson/Powermad)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exploiting RBCD as a normal user: [https://www.tiraniddo.dev/2022/05/exploiting-rbcd-using-normal-user.xhtml](https://www.tiraniddo.dev/2022/05/exploiting-rbcd-using-normal-user.xhtml)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Abuse of constrained delegation from Linux: [https://mayfly277.github.io/posts/GOADv2-pwning-part10/#without-protocol-transition](https://mayfly277.github.io/posts/GOADv2-pwning-part10/#without-protocol-transition)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bypass SID filtering: [https://improsec.com/tech-blog/sid-filter-as-security-boundary-between-domains-part-4-bypass-sid-filtering-research](https://improsec.com/tech-blog/sid-filter-as-security-boundary-between-domains-part-4-bypass-sid-filtering-research)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Updates to TGT delegation across incoming trusts in Windows Server: [https://support.microsoft.com/en-us/topic/updates-to-tgt-delegation-across-incoming-trusts-in-windows-server-1a6632ac-1599-0a7c-550a-a754796c291e](https://support.microsoft.com/en-us/topic/updates-to-tgt-delegation-across-incoming-trusts-in-windows-server-1a6632ac-1599-0a7c-550a-a754796c291e)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Abuse SID history: [https://dirkjanm.io/active-directory-forest-trusts-part-one-how-does-sid-filtering-work/](https://dirkjanm.io/active-directory-forest-trusts-part-one-how-does-sid-filtering-work/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These aids for further study will let you dive deeper into the attacks covered
    in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The original research behind the SharpRDP tool creation: [https://0xthirteen.com/2020/01/21/revisiting-remote-desktop-lateral-movement/](https://0xthirteen.com/2020/01/21/revisiting-remote-desktop-lateral-movement/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dumping RDP credentials with the help of Mimikatz: [https://pentestlab.blog/2021/05/24/dumping-rdp-credentials/](https://pentestlab.blog/2021/05/24/dumping-rdp-credentials/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft documentation about Remote Credential Guard: [https://learn.microsoft.com/en-us/windows/security/identity-protection/remote-credential-guard](https://learn.microsoft.com/en-us/windows/security/identity-protection/remote-credential-guard)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Great research published by *0xf0x* about Impacket usage and detection: [https://neil-fox.github.io/Impacket-usage-&-detection/](https://neil-fox.github.io/Impacket-usage-&-detection/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detailed publication about artifacts left by running remote command execution:
    [https://www.synacktiv.com/publications/traces-of-windows-remote-command-execution.xhtml](https://www.synacktiv.com/publications/traces-of-windows-remote-command-execution.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information about ASR implementation: [https://www.joeyverlinden.com/implementing-and-monitoring-attack-surface-reduction-rules-asr/](https://www.joeyverlinden.com/implementing-and-monitoring-attack-surface-reduction-rules-asr/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Great theory background about NTLM relay attack and conditions: [https://www.thehacker.recipes/ad/movement/ntlm/relay](https://www.thehacker.recipes/ad/movement/ntlm/relay)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detailed blog post about differences between versions of the NTLM protocol:
    [https://www.praetorian.com/blog/ntlmv1-vs-ntlmv2/](https://www.praetorian.com/blog/ntlmv1-vs-ntlmv2/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detecting Pass-the-Hash attacks: [https://blog.netwrix.com/2021/11/30/how-to-detect-pass-the-hash-attacks/](https://blog.netwrix.com/2021/11/30/how-to-detect-pass-the-hash-attacks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unconstrained delegation: [https://en.hackndo.com/constrained-unconstrained-delegation/#unconstrained-delegation](https://en.hackndo.com/constrained-unconstrained-delegation/#unconstrained-delegation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The list of LDAP syntax filters: [https://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx](https://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example of RBCD attack execution: [https://pentestlab.blog/2021/10/18/resource-based-constrained-delegation/](https://pentestlab.blog/2021/10/18/resource-based-constrained-delegation/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Great explanation of the constrained delegation abuse with schemas and traffic
    capture: [https://www.notsoshant.io/blog/attacking-kerberos-constrained-delegation/](https://www.notsoshant.io/blog/attacking-kerberos-constrained-delegation/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bronze Bit vulnerability and theory behind it: [https://www.netspi.com/blog/technical/network-penetration-testing/cve-2020-17049-kerberos-bronze-bit-theory/](https://www.netspi.com/blog/technical/network-penetration-testing/cve-2020-17049-kerberos-bronze-bit-theory/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
