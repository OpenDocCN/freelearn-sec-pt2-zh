- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Persistence on Domain Level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During an offensive operation, adversaries need to maintain their access to
    the target environment. Various activities such as reboots and changing users’
    passwords can disrupt the operation’s flow. To overcome interruptions, there are
    techniques that allow us to achieve persistence. In this chapter, we will not
    cover host persistence techniques on Windows workstations and servers. Instead,
    we will focus our attention on domain-level persistence and techniques specific
    to domain controllers only. Our first topic is the most famous jewelry tickets
    (golden, silver, diamond, and sapphire). We will discuss the differences between
    them and demonstrate their practical usage with OpSec considerations. Other domain-level
    persistence topics, such as adding to a **SID History** attribute and an **AdminSDHolder**
    domain object ACL and DACL manipulation, and delegation privilege abuse, will
    be explained and illustrated with practical examples. We will close the domain-level
    persistence topic by covering **DCShadow** and Golden gMSA attacks. Domain controller
    persistence is mostly achieved by manipulating credentials via **Skeleton Key**
    attack, malicious **Security Support Provider** (**SSP**) registration, or access
    to a **Directory Services Restore Mode** (**DSRM**) hash. Lastly, we will explicate
    security descriptor manipulation for WMI, PS-Remoting and how to set up a registry
    backdoor to retrieve an NT hash of a computer, SAM, or cached AD credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Domain persistence, in which we will cover forged tickets, a domain object’s
    ACL/attribute manipulation, a DCShadow attack, and a Golden gMSA attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain controller persistence, in which we will cover malicious SSP registration,
    Skeleton Key attack, dumping DSRM hash, a registry backdoor, and security descriptor
    manipulation (WMI and PS-Remoting)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will need to have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: VMware Workstation or Oracle VM VirtualBox with at least 16 GB of RAM, 8 CPU
    cores, and at least 55 GB of total space (more if you take snapshots)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Linux-based operating system is strongly recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vagrant installed with a plugin for the corresponding virtualization platform
    and Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the GOADv2 project, we will use **DC01**, **SRV01**, **DC03**, and **SRV03**
    virtual machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss various ways to achieve domain-level persistence.
    These techniques require high privileges equivalent to Domain Administrator. The
    most obvious way to achieve persistence in the target environment is to create
    and/or add compromised user or computer accounts to a highly privileged group.
    However, we will focus on more sophisticated techniques. Also, we will not discuss
    Group Policy abuse and targeted Kerberoasting from a persistence perspective,
    as the exploitation will be exactly the same as the examples from [*Chapter 6*](B18964_06.xhtml#_idTextAnchor119),
    only with a focus on privileged accounts. In the following techniques, we will
    rely either on privileged but rarely changed credential material (for example,
    the hash of a krbtgt account) or on attributes and ACL manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Forged tickets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start our journey with forged tickets – the types, their creation, their
    usage, and OpSec recommendations on how to stay under the radar. One important
    theoretical concept to mention is the **Privileged Attribute Certificate** (**PAC**).
    The PAC is used in the Kerberos protocol to distribute user rights to services,
    such as a username, SID, and group membership. The PAC is a part of every ticket
    and is encrypted with either a **Key Distribution Center** (**KDC**) key or a
    service account key. When we say that a ticket is forged, we mean that we place
    arbitrary PAC content in it. The first type of forged ticket we will examine is
    the Silver Ticket.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Great in-depth coverage of Golden and Silver Tickets can be found here: [https://en.hackndo.com/kerberos-silver-golden-tickets/](https://en.hackndo.com/kerberos-silver-golden-tickets/).'
  prefs: []
  type: TYPE_NORMAL
- en: Silver Ticket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a user needs access to a service, there are ST requests (**KRB_TGS_REQ**)
    and a reply (**KRB_TGS_REP**). The reply is encrypted with an NT hash of the account
    running the service. If an attacker has obtained the password or NT hash of the
    service account, it is possible to forge a PAC and, thus, the service ticket without
    interacting with the domain controller. Such a forged ticket is called a **Silver
    Ticket**. One small caveat about forging a PAC is that, ultimately, it will be
    double-signed with service account and krbtgt NT hashes. However, conveniently
    for us, with a service ticket, only the first signature is verified. It’s important
    to note that, since the Microsoft’s November 2021 patch, if a supplied username
    does not exist in the domain, the ticket will be rejected[1]. A Silver Ticket
    can be forged for a domain controller’s account as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let us forge a Silver Ticket for the **castelrock.sevenkingdoms.local**
    server on a non-domain-joined machine, as the standard user, **lord.varys**. We
    will use Rubeus to create a ticket for user **robert.baratheon** (it can be any
    existing domain user), for the CIFS service on **castelrock**, with the AES256
    key of the **castelrock$** account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Rubeus has successfully injected the ticket:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – No access to the CIFS service before injecting the ticket](image/B18964_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – No access to the CIFS service before injecting the ticket
  prefs: []
  type: TYPE_NORMAL
- en: 'After injecting the ticket, access to the CIFS service on **castelrock** is
    granted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The Silver Ticket provides access for lord.varys](image/B18964_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – The Silver Ticket provides access for lord.varys
  prefs: []
  type: TYPE_NORMAL
- en: 'Detecting a Silver Ticket is a challenging task. It is stealthier than a Golden
    Ticket as the domain controller is not involved, and the service account NT hash
    is easier to obtain. The blue team would need to pull logs from servers and examine
    the event ID **4769** for a possible encryption downgrade (if RC4 is used instead
    of AES256). Windows logon/logoff events with IDs **4624** and **4647** can also
    provide information about the username, source IP address, and user’s SID. If
    we enable an audit for **Success** in the audit logon policy, event ID **4627**
    will show the group membership information of the logged-on user. The following
    is an example of the logon event ID **4624**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – The missing username and domain, together with the IP address
    of the attacking machine](image/B18964_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – The missing username and domain, together with the IP address of
    the attacking machine
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we may need to use the **/nofullpacsig** flag in Rubeus to exclude **FullPacChecksum**,
    which was introduced as a patch for **CVE-2022-37967**. This patch introduces
    checks for missing or invalid PAC signatures. If the patch has been applied, the
    registry key **KrbtgtFullPacSignature** will be created on a domain controller.
    At the time of writing, Microsoft is due to enforce the signature by October 2023\.
    There is a stealthier alternative to this ticket, which has a valid PAC and is
    based on **S4U2self** abuse. Let’s look at it next.
  prefs: []
  type: TYPE_NORMAL
- en: A stealthy alternative to a Silver Ticket (S4U2self abuse)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **S4U2self** Kerberos extension allows a service to obtain a service ticket
    on behalf of a user to itself. It’s important to mention that **S4U2self** can
    be used by any account on a machine, including virtual or network service accounts,
    but on a network, it acts as the machine itself. **S4U2self** can help with local
    privilege escalation in a scenario when an attacker has compromised the virtual
    or network service account on a machine, such as AppPool or MSSQL, and then requests
    a service ticket for any user to themselves. Interestingly, users can even be
    from the **Protected Users** group or have the **Account is sensitive and cannot
    be delegated** **UserAccountControl** property enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of local privilege escalation and original research by *Charlie
    Clark* can be found here: [https://exploit.ph/revisiting-delegate-2-thyself.xhtml](https://exploit.ph/revisiting-delegate-2-thyself.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will demonstrate an alternative scenario to a Silver Ticket. I will
    use a non-domain-joined machine and the machine account NT hash of **castelrock**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two steps in this attack – obtaining a TGT for the machine account
    and then using it for the **S4U2self** request to get a service ticket. In the
    first step, the attacker can request the machine’s account TGT in the usual way
    if the computer’s account hash is known. The following command will request a
    TGT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the TGT request is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Obtaining the machine account’s TGT](image/B18964_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Obtaining the machine account’s TGT
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, an attacker can request a service ticket. Note the **/self** flag in
    order to impersonate protected users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Successful S42Uself abuse](image/B18964_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Successful S42Uself abuse
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of **S4U2self** abuse over a Silver Ticket is that the service
    ticket has a valid PAC, not a forged one. Now, let us discuss a more dominant
    type of forged ticket – a **Golden Ticket**.
  prefs: []
  type: TYPE_NORMAL
- en: Golden Ticket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Golden Ticket is, in essence, a forged TGT ticket. With such a TGT ticket,
    we can request any service ticket as any user in the domain. There is a great
    analogy to understand better the difference between Silver and Golden tickets.
    A Silver Ticket is like a visa. You can enter the country (one server) and travel
    everywhere (request access to every service on this server). A Golden Ticket is
    like a passport. You can apply for a visa (access to the service) to every country
    in the world (any resource in the domain).
  prefs: []
  type: TYPE_NORMAL
- en: To forge a TGT, we need to know the **krbtgt** account NT hash, which can only
    be obtained with domain administrator or replication privileges in the domain.
    Microsoft tried to stop Golden Ticket forgery in the patch (**KB5008380**) for
    **CVE-2021-42287**. The idea was to introduce a new data structure in the PAC
    containing the user’s SID. However, if the correct SID is supplied, an attack
    will be successful anyway[2]. There are two switches in Rubeus, **/oldpac** and
    **/newpac**, that can be used to forge the ticket, depending on the patch installation
    and enforcement status.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a Golden Ticket to access the **kingslanding.sevenkingdoms.local**
    filesystem from the **castelrock.sevenkingdoms.local** machine, authenticated
    as low-privileged user **jaime.lannister**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Before injecting a Golden Ticket, we have the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The Golden Ticket forgery process](image/B18964_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – The Golden Ticket forgery process
  prefs: []
  type: TYPE_NORMAL
- en: 'After injecting a Golden Ticket, we get the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Access to the domain controller with a Golden Ticket](image/B18964_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Access to the domain controller with a Golden Ticket
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a Golden Ticket is difficult. We need to examine logs with a particular
    focus on the ticket encryption type (a possible downgrade) and its lifetime. The
    ticket encryption type can be found in event ID **4769**. Non-default lifetime
    values in a TGT are a good indicator – for example, by default, in the domain
    ticket lifetime is 10 hours, but Mimikatz creates a ticket with a 10-year lifetime.
    If there are missing events with the ID **4768** (**A Kerberos authentication
    Ticket Requested (TGT)**) for events with the ID **4769** (**A Kerberos service
    ticket**), it is a clear sign of a Golden Ticket being used. Do we have anything
    stealthier and better? Yes, we do! **Diamond Tickets** will be covered next.
  prefs: []
  type: TYPE_NORMAL
- en: Diamond Ticket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea of a Diamond Ticket evolved from a Diamond PAC attack and aims to be
    stealthier than Golden or Silver Tickets. The dance starts with a TGT being requested
    as a low-privileged user to obtain a legitimate ticket, and then the PAC is decrypted
    and modified, the signature is recalculated, and the ticket is encrypted again.
    Remember to use only already-existing domain users; otherwise, the ticket will
    be rejected in an up-to-date environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The original research about Diamond Ticket can be found here: [https://www.semperis.com/blog/a-diamond-ticket-in-the-ruff/](https://www.semperis.com/blog/a-diamond-ticket-in-the-ruff/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us replicate the attack. For the first step, we will request a TGT for
    a standard user (**jaime.lannister**). Choosing the **/tgtdeleg** flag, we can
    use the Kerberos GSS-API to obtain a TGT for the current user without knowing
    the password. **/krbkey** is the AES key for the krbtgt account, **/ticketuserid**
    is the **Relative Identifier** (**RID**) of **/ticketuser**, and **/groups** specifies
    the group for the ticket. To perform these actions, we will use Rubeus with the
    following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of the user’s TGT request without the **/tgtdeleg** flag is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – A low-privileged user-requested TGT](image/B18964_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – A low-privileged user-requested TGT
  prefs: []
  type: TYPE_NORMAL
- en: 'PAC modification happens on the fly, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – The modified TGT](image/B18964_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – The modified TGT
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the forged TGT, we can request a service ticket for the CIFS service
    on the domain controller with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The ST request is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Asking for ST](image/B18964_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Asking for ST
  prefs: []
  type: TYPE_NORMAL
- en: 'And we have access to the CIFS service running on the domain controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – CIFS service access](image/B18964_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – CIFS service access
  prefs: []
  type: TYPE_NORMAL
- en: Detecting a Diamond Ticket is an even more non-trivial task, which requires
    ticket examination and checking that the values in the ticket match the default
    values in the domain. Event ID **4627** can show any extra group membership added
    to the low-privileged user. Discrepancies between the PAC’s value and the actual
    user’s privileges in AD can also be used to spot malicious activity. Lastly, we
    will talk about Sapphire Tickets, which are an even stealthier version of a Diamond
    Ticket.
  prefs: []
  type: TYPE_NORMAL
- en: Sapphire Ticket
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Sapphire Ticket is an enhanced version of a Diamond Ticket that allows an
    attacker to mimic legitimate activity to an even greater extent. The idea is that
    instead of PAC modification in a legitimate TGT, as we did with the Diamond Ticket,
    we will copy a legitimate PAC of another high-privileged user through the **S4U2self+u2u**
    trick and replace it in the original TGT. In this scenario, we will avoid discrepancies
    between the PAC and effective user privileges. The following command uses the
    **-impersonate** flag that will create a Sapphire Ticket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, Sapphire Ticket functionality is not available in Rubeus
    or Impacket. Pull request **1411** was sent to Impacket, but it is still not merged
    with main branch.
  prefs: []
  type: TYPE_NORMAL
- en: Detection of a Sapphire Ticket is still possible by the domain controller’s
    log analysis. The sequence of **4768** and **4769** events can be used to detect
    the immediate usage of the newly forged ticket. In the logs two different **Account
    Name** values will appear for the TGT and ST requests originating from the same
    **Client Address**, however, username in ST has never been logged into that computer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Diamond and Sapphire Tickets detection approaches are available at [https://pgj11.com/posts/Diamond-And-Sapphire-Tickets/](https://pgj11.com/posts/Diamond-And-Sapphire-Tickets/)
    and [https://unit42.paloaltonetworks.com/next-gen-kerberos-attacks/](https://unit42.paloaltonetworks.com/next-gen-kerberos-attacks/).
  prefs: []
  type: TYPE_NORMAL
- en: Promising research about detecting forged tickets was presented by *Charlie
    Clark* and *Andrew Schwartz*. The idea is to decrypt the ticket and perform a
    detailed analysis of the ticket times and checksums. The blue team can create
    a custom Kerberos ticketing policy, enforce the **logonHours** attribute for users,
    and verify that checksums are correctly signed by the krbtgt key[3]. They also
    released a tool that automates most of these checks, called **WonkaVision**. You
    can download it from GitHub[4].
  prefs: []
  type: TYPE_NORMAL
- en: The next section will focus on achieving persistence via manipulation via the
    ACL or attributes of different domain objects.
  prefs: []
  type: TYPE_NORMAL
- en: A domain object’s ACL and attribute manipulations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will cover techniques to achieve persistence via ACL and
    attribute manipulation on various domain objects. Typical ACL manipulation targets
    are **AdminSDHolder** and domain objects. Attribute alteration attacks will aim
    for **SIDHistory**, userAccountControl, SPN, and delegation attributes.
  prefs: []
  type: TYPE_NORMAL
- en: AdminSDHolder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The AdminSDHolder domain object in AD was introduced by Microsoft to prevent
    ACL modification of high-privileged accounts and groups.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A default list of protected objects can be found here: [https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/security-best-practices/appendix-c--protected-accounts-and-groups-in-active-directory](https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/security-best-practices/appendix-c--protected-accounts-and-groups-in-active-directory).'
  prefs: []
  type: TYPE_NORMAL
- en: To manually find accounts and groups that are part of AdminSDHolder, we can
    search for the **adminCount** attribute and check that it is set to **1** in their
    properties. The idea is that the AdminSDHolder object provides a preset security
    permission template that the Security Descriptor Propagator process applies every
    60 minutes, protecting accounts and groups.
  prefs: []
  type: TYPE_NORMAL
- en: '*Sean Metcalf* discovered this technique. With domain administrator rights,
    an attacker can add an arbitrary user account to the AdminSDHolder ACL. After
    propagation, the user account will have the **GenericAll** right over privileged
    groups and accounts in the domain. PowerView makes the exploitation trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In 60 minutes, we can see that our user account was added to the AdminSDHolder
    DACL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The attack is illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – jaime.lannister was added to the DACL of the AdminSDHolder
    domain object](image/B18964_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – jaime.lannister was added to the DACL of the AdminSDHolder domain
    object
  prefs: []
  type: TYPE_NORMAL
- en: 'When necessary, the attacker will log in as **jaime.lannister** and add himself
    to the **domain** **admins** group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be observed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – The jaime.lannister user account was added to the Domain Admins
    group](image/B18964_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – The jaime.lannister user account was added to the Domain Admins
    group
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to detect this technique. We can review the ACL of the AdminSDHolder
    object on a regular basis to ensure that no alterations have been made, and we
    can monitor users and groups with **adminCount** = **1**. Now, we will discuss
    how to add privileges to the domain object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Domain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With domain administrator privileges, we can grant to any user under our control
    **DCSync** privileges. As a result, a low-privileged user will be able to retrieve
    hashes for all users in the domain. The PowerView command to add DCSync privileges
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we return to our low-privileged user and run the following Mimikatz command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the successful DCSync attack is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Add DCSync privileges to the user and extract hashes](image/B18964_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – Add DCSync privileges to the user and extract hashes
  prefs: []
  type: TYPE_NORMAL
- en: DCSync attack detection was covered earlier in [*Chapter 4*](B18964_04.xhtml#_idTextAnchor061).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are move on to domain object attribute manipulation. We will start with
    our old friend – SID History.
  prefs: []
  type: TYPE_NORMAL
- en: SID History
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We discussed SID History in detail in [*Chapter 5*](B18964_05.xhtml#_idTextAnchor093)
    when we covered lateral movement between forests. Surprisingly, SID History also
    works for SIDs from the same domain, meaning that if we add a privileged SID in
    the SID History attribute, a regular user will effectively become a domain administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before Windows Server 2016, an attacker could use Mimikatz to add SID History:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the **sid::patch** command in Windows Server 2016 has stopped this
    attack from working and displays the following error when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – An error while adding SID History via Mimikatz](image/B18964_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.15 – An error while adding SID History via Mimikatz
  prefs: []
  type: TYPE_NORMAL
- en: 'The only known way to directly add SID History on modern domain controllers
    is described here[5]. It involves the installation of the DSInternals PowerShell
    module on a domain controller and an NTDS service restart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, the user **lord.varys** has a domain administrator SID added to
    his history, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – SID History was added to the lord.varys user](image/B18964_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – SID History was added to the lord.varys user
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect this technique, we can configure auditing for events ID **4765**
    (**SID History was added to an account**) and **4766** (**An attempt to add SID
    History to an account failed**) on the domain controller. Another way is to use
    PowerShell to discover users with a matching domain SID in their SID History:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our persistence trick was successfully detected, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – A user with suspicious SID History detected](image/B18964_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – A user with suspicious SID History detected
  prefs: []
  type: TYPE_NORMAL
- en: The upcoming technique is similar to this one, but now, we will change the computer’s
    attribute to become a domain controller.
  prefs: []
  type: TYPE_NORMAL
- en: Server (Un)Trust Account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main concept of this attack is to set the **UF_SERVER_TRUST_ACCOUNT** bit
    in the userAccountControl attribute of a computer. Then, AD must set the **primaryGroupId**
    attribute of this computer to the RID of the domain controllers’ group. To perform
    such actions, we need domain administrator privileges. This can be done manually
    or with the help of a PowerShell script developed by *Stealthbits*[6]. The script
    has three functions. The first command will create a computer object and grant
    the **Authenticated Users** group **Ds-Install-Replica** and **Write** permissions
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When an adversary needs to regain domain dominance, then a second function
    has to be invoked. It will set the userAccountControl value to **8192** (**SERVER_TRUST_ACCOUNT**),
    use Mimikatz to execute a pass-the-hash attack as a computer account, and finally,
    perform DCSync:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The third function is for cleanup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A full attack chain execution is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18 – A server trust account attack](image/B18964_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – A server trust account attack
  prefs: []
  type: TYPE_NORMAL
- en: This attack creates quite a significant foothold, starting from computer account
    creation and unusual ACLs on this account, going further with pass-the-hash lateral
    movement, and finally, a DCSync attack. Later, we will explain the most dangerous
    user privilege that you may never have heard of.
  prefs: []
  type: TYPE_NORMAL
- en: SeEnableDelegationPrivilege
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main idea here is to control an object with the **SeEnableDelegationPrivilege**
    user right, and if it has **GenericAll** or **GenericWrite** permissions over
    any user or computer in the domain, the attacker will achieve domain persistence.
    Surprisingly, the **GenericAll** permission is not enough to modify the delegation
    settings of the account, which is why the **SeEnableDelegationPrivilege** right
    is required. By default, this privilege is applicable only to a domain controller
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique was discovered by *harmj0y* and is well described here: [https://blog.harmj0y.net/activedirectory/the-most-dangerous-user-right-you-probably-have-never-heard-of/](https://blog.harmj0y.net/activedirectory/the-most-dangerous-user-right-you-probably-have-never-heard-of/).'
  prefs: []
  type: TYPE_NORMAL
- en: As the first step, we must grant this right to our backdoor user by editing
    the **Default Domain Controllers** policy, located in **\\sevenkingdoms.local\sysvol\sevenkingdoms.local\Policies\{6AC1786C-016F-11D2-945F-00C04fB984F9}\MACHINE\Microsoft\Windows
    NT\SecEdit\GptTmpl.inf**. Then, we abuse our **GenericAll** or **GenericWrite**
    permissions over the victim user to set the **msDS-AllowedToDelegateTo** value
    to point to our target service. **GenericWrite** will require the knowledge of
    the victim’s secret during exploitation, and **GenericAll** will allow us to change
    the password. As a last step, we abuse the constrained delegation in the same
    way we did during lateral movement. To prepare our lab for the attack demonstration,
    I will grant the **tywin.lannister** user account the **GenericAll** right on
    the **renly.baratheon** account via the ADSI edit, in the same way we did in the
    previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a domain administrator, the attacker can manually add **tywin.lannister**
    to the aforementioned Group Policy. The following PowerView commands will confirm
    that all the prerequisites are fulfilled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – The tywin.lannister user has all the necessary rights for the
    attack](image/B18964_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – The tywin.lannister user has all the necessary rights for the
    attack
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we set the **msDS-AllowedToDelegateTo** property and the userAccountControl
    flag of the **renly.baratheon** user account with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Successful execution of the preceding commands can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – Successfully set required user attributes](image/B18964_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.20 – Successfully set required user attributes
  prefs: []
  type: TYPE_NORMAL
- en: As a last step, we will abuse constrained delegation in the same way we did
    in [*Chapter 5*](B18964_05.xhtml#_idTextAnchor093).
  prefs: []
  type: TYPE_NORMAL
- en: From a defense perspective, such user privileges must be monitored alongside
    changes in GPOs. The final backdooring technique will also rely on delegation,
    but this time, it is RBCD on the krbtgt account.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation on krbtgt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The idea behind this technique is to abuse RBCD on the krbtgt account. With
    built-in domain administrator group privileges, an attacker can set the **msDS-AllowedToActOnBehalfOfOtherIdentity**
    attribute of the krbtgt account. The adversary will be able to obtain a service
    ticket for the krbtgt service on behalf of any user. Effectively, it is a TGT
    of the impersonated user. This trick won’t work for members of the **Protected
    Users** group and accounts with the **Account is sensitive and cannot be delegated**
    flag enabled. The attacker will set up the backdoor by creating or using an existing
    computer account and, with the help of the AD Module, configure the **msDS-AllowedToActOnBehalfOfOtherIdentity**
    attribute of the krbtgt account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding commands can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21 – A successfully set msDS-AllowedToActOnBehalfOfOtherIdentity
    attribute of krbtgt](image/B18964_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.21 – A successfully set msDS-AllowedToActOnBehalfOfOtherIdentity attribute
    of krbtgt
  prefs: []
  type: TYPE_NORMAL
- en: 'To utilize the backdoor as a low-privileged user, the attacker requests a service
    ticket for the krbtgt service and performs a DCSync attack, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding command execution is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – A DCSync attack as a result of delegation on the krbtgt account](image/B18964_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.22 – A DCSync attack as a result of delegation on the krbtgt account
  prefs: []
  type: TYPE_NORMAL
- en: From a defensive perspective, the only way to detect this technique is to monitor
    changes to the krbtgt account attributes. Now that we are done with attributes
    and ACL modifications, we explain a rogue domain controller attack.
  prefs: []
  type: TYPE_NORMAL
- en: DCShadow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A DCShadow attack allows you to create a fake domain controller and push changes
    to AD objects. Beware that pushing data using replication can brick your domain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This attack was presented by *Vincent Le Toux* and *Benjamin Delpy* ([https://www.dcshadow.com/](https://www.dcshadow.com/))
    in 2018.
  prefs: []
  type: TYPE_NORMAL
- en: 'DCShadow requires domain administrator privileges to replicate changes and
    **SYSTEM** privileges on a compromised host, allowing you to implement fake domain
    controller functionality. The attack steps described by Le Toux and Delpy are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Register the domain controller by creating two objects in the **CN=Configuration**
    partition, and alter the SPN of the computer used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the data by triggering **DrsReplicaAdd**, KCC, or other internal AD events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the object previously created to demote the domain controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our attack plan is the following: we will add the privileged SID of **daenerys.targaryen**,
    who is a domain administrator, to the SIDHistory attribute of the low-privileged
    **viserys.targaryen** user account. On **meereen.essos.local**, we logged in as
    **daenerys.targaryen**, who has domain administrator privileges in the **essos.local**
    domain. We have to run the following Mimikatz commands as **SYSTEM**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the execution is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23 – DCShadow adds the SIDHistory attribute](image/B18964_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.23 – DCShadow adds the SIDHistory attribute
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Mimikatz commands should be run with the domain administrator
    privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Attribute replication is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 – DCShadow replicates the SIDHistory attribute on the domain
    controller](image/B18964_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.24 – DCShadow replicates the SIDHistory attribute on the domain controller
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, **viserys.targaryen** has the **SIDHistory** attribute added and
    now has access to the domain controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25 – DCShadow results in a privileged SID added to viserys.targaryen](image/B18964_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.25 – DCShadow results in a privileged SID added to viserys.targaryen
  prefs: []
  type: TYPE_NORMAL
- en: 'Detection can be done by network traffic monitoring or correlating events from
    a domain controller. The blue team can monitor incoming replication traffic with
    certain API calls that didn’t originate from the domain controller. In the domain
    controller’s security log, defenders can examine the series of events with the
    ID **4662**, with a sequence of **CreateChild**, **Control Access**, and **Delete**
    accessed in a short period of time. An example of a logged malicious event is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26 – Rogue domain controller object creation](image/B18964_07_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.26 – Rogue domain controller object creation
  prefs: []
  type: TYPE_NORMAL
- en: Another option to achieve persistence is to set the minimum permissions required
    for DCShadow on an AD object, with the help of a script from *Nishang*[7].
  prefs: []
  type: TYPE_NORMAL
- en: Our last domain-level persistence technique, called the Golden gMSA attack,
    allows a privileged attacker to compute the gMSA’s password in the domain and
    forest offline.
  prefs: []
  type: TYPE_NORMAL
- en: Golden gMSA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us recall that gMSA is used for automatic password rotation on service accounts
    to mitigate attacks such as Kerberoasting. We evaluated the security of this solution
    in [*Chapter 4*](B18964_04.xhtml#_idTextAnchor061). The Golden gMSA attack was
    first presented by *Yuval Gordon* from a company called Semperis. The idea is
    that an attacker with the ability to dump a **Key Distribution Service** (**KDS**)
    root key with additional attributes can compute gMSA’s password offline.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The original research can be found here: [https://www.semperis.com/blog/golden-gmsa-attack/](https://www.semperis.com/blog/golden-gmsa-attack/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the **GoldenGMSA**[8] tool, an adversary can calculate the gMSA password
    offline because it is derived from the KDS root key and several other attributes.
    An adversary needs to run three commands to obtain the password in the **base64**
    format. The first command will list all the available gMSAs, the second will dump
    the corresponding KDS root key and other attributes, and the third will compute
    the gMSA password using the output of the first two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The successful Golden gMSA attack is demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27 – Retrieving a gMSA password using a Golden gMSA attack](image/B18964_07_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.27 – Retrieving a gMSA password using a Golden gMSA attack
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to mention that there is only one KDS root key; however, all
    other values to calculate gMSA are different, meaning that every password needs
    to be dumped separately.
  prefs: []
  type: TYPE_NORMAL
- en: From a defensive point of view, additional auditing must be enabled to detect
    KDS root key dumping attempts.
  prefs: []
  type: TYPE_NORMAL
- en: This section about domain persistence focused on domain-level dominance. However,
    there are other ways to backdoor AD by abusing different authentication mechanisms
    and permissions on the domain controller itself.
  prefs: []
  type: TYPE_NORMAL
- en: Domain controller persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The domain controller in a Windows environment remains one of the key objectives
    for malicious actors during their campaigns. If an adversary has compromised the
    domain controller and established persistence, it is possible to regain domain-wide
    administrative privileges in a matter of minutes. Techniques in this section utilize
    credential manipulation and authentication mechanism alteration. At the end of
    this section, we will explain the concept of security descriptors and how attackers
    can modify them to maintain privileged access in an environment.
  prefs: []
  type: TYPE_NORMAL
- en: Skeleton Key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Skeleton Key attack is a persistence method on a domain controller that sets
    a master password in the domain, allowing an adversary to authenticate as any
    domain user. However, to avoid early detection, an installed backdoor module allows
    users to continue to log in with their existing passwords as well. For Kerberos
    authentication to work, encryption downgrade to **RC4_HMAC_MD5** is enforced.
    This attack requires the domain administrator privileges and the **SeDebugPrivilege**
    user right on the domain controller. A Skeleton Key attack can’t survive a reboot,
    as all manipulations with the **Local Security Authority Subsystem Service** (**LSASS**)
    process are conducted in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A more detailed description of Skeleton Key in-memory actions can be found
    here: [https://adsecurity.org/?p=1255](https://adsecurity.org/?p=1255).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mimikatz has this attack under its belt. The following command injects Skeleton
    Key malware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows a successful attack on the domain controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28 – Skeleton Key malware was deployed on a domain controller](image/B18964_07_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.28 – Skeleton Key malware was deployed on a domain controller
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to confirm, we map the **C:\** drive of the domain controller without
    knowing the privileged user password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The disk was successfully mapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29 – The Skeleton Key works](image/B18964_07_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.29 – The Skeleton Key works
  prefs: []
  type: TYPE_NORMAL
- en: To partially mitigate the Skeleton Key attack, we run LSASS as a protected process
    by creating the **DWORD** value, **RunAsPPL**, set to **1** in the **HKLM\SYSTEM\CurrentControlSet\Control\Lsa**
    registry key. As stated by Microsoft, “*This will prevent non-administrative non-PPL
    processes from accessing or tampering with code and data in a PPL process via
    open* *process functions.*”
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see that the original Skeleton Key attack
    failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30 – PPL beats the Skeleton Key attack](image/B18964_07_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.30 – PPL beats the Skeleton Key attack
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is still possible to bypass the PPL mechanism by removing it from
    the process, with the help of the **mimidrv.sys** driver from Mimikatz. However,
    it is much noisier, as such a bypass requires driver loading and service creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31 – PPL protection removed by mimidrv](image/B18964_07_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.31 – PPL protection removed by mimidrv
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other bypasses for PPL, well described by *itm4n* here: [https://itm4n.github.io/lsass-runasppl/](https://itm4n.github.io/lsass-runasppl/).'
  prefs: []
  type: TYPE_NORMAL
- en: Also, the blue team can enable audit mode for the LSASS process using Group
    Policy. It will be possible to monitor plugins and drivers loaded by LSASS, and
    events **3033** and **3063** will respectively appear in logs. To enable auditing,
    we need to create the **HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image
    File Execution Options\LSASS.exe** key, with the **AuditLevel** DWORD value set
    to **8**. When Skeleton Key attack is performed remotely, the domain controller
    will log events with IDs **4673**, **4611**, **4688**, and **4689**, as described
    here[9]. These events will show the usage of sensitive privileges the and registration
    of a logon process. The last two events will appear only if **Process Tracking**
    is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: To further explore how authentication mechanisms can be altered, we will introduce
    the concept of a malicious SSP.
  prefs: []
  type: TYPE_NORMAL
- en: A malicious SSP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Security Support Provider Interface** (**SSPI**) is the basis for Windows
    authentication. When applications need to authenticate via a specific protocol,
    they use SSPI to invoke the corresponding SSPs. There are six default SSPs implemented
    as DLLs, located in the **C:\Windows\System32** folder. Custom SSPs can be introduced
    as well. A list of providers is stored in the registry key at **HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security
    Packages**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With administrative privileges on a compromised host, an adversary has two
    options. The first one is to utilize Mimikatz to inject a malicious SSP directly
    into the LSASS process. The second option is to update the SSP Security Packages
    registry key, drop **mimilib.dll** in the same folder as LSASS (**C:\Windows\System32**),
    and wait for a reboot. Both venues have their own obvious OpSec considerations.
    An in-memory injection scenario will not survive the reboot but will start logging
    passwords immediately. The **memssp** module from Mimikatz can be injected with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the successful injection of a malicious SSP is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.32 – The Mimikatz memssp module is injected](image/B18964_07_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.32 – The Mimikatz memssp module is injected
  prefs: []
  type: TYPE_NORMAL
- en: 'We can lock the screen with the **misc::lock** Mimikatz command, so the victim
    will have to log in again. The log file with the passwords is located in **C:\Windows\System32\mimilsa.log**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.33 – Clear-text passwords in the mimilsa.log file](image/B18964_07_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.33 – Clear-text passwords in the mimilsa.log file
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually add an SSP via the registry, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The successful SSP addition of **mimilib** is demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.34 – mimilib was registered as an SSP](image/B18964_07_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.34 – mimilib was registered as an SSP
  prefs: []
  type: TYPE_NORMAL
- en: 'After reboot, the passwords can be found in **C:\Windows\System32\kiwissp.log**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.35 – Clear-text passwords in the kiwissp.log file](image/B18964_07_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.35 – Clear-text passwords in the kiwissp.log file
  prefs: []
  type: TYPE_NORMAL
- en: To detect a malicious SSP, the blue team can monitor the changes of the **HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security
    Packages** registry key and files on the disk. However, adversaries can change
    the log storage folder and log filename. In the case of LSASS injection, we can
    apply the same detections as we discussed previously. Also, it is recommended
    to run LSASS as PPL.
  prefs: []
  type: TYPE_NORMAL
- en: To finalize our persistence through authentication manipulation, we will cover
    local administrator account abuse on a domain controller.
  prefs: []
  type: TYPE_NORMAL
- en: DSRM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Directory Services Restore Mode** (**DSRM**) account is a local administrator
    account on a domain controller. This account has a different password from the
    domain administrator. This password is set during domain controller promotion
    and is very often overlooked during the password rotation routine. There are two
    attack scenarios well described by *Sean Metcalf*. One is changing the DSRM password
    to a known one, and the other is to sync it with the domain account of our choice.
    We will utilize **Ntdsutil** for these actions. Both scenarios are shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.36 – The DSRM password reset and sync scenarios](image/B18964_07_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.36 – The DSRM password reset and sync scenarios
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm that the sync was successful by dumping and comparing the user
    hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.37 – The DSRM password was synced with jaime.lannister’s account
    password](image/B18964_07_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.37 – The DSRM password was synced with jaime.lannister’s account password
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three possible scenarios when logging in with the DSRM password.
    With Domain Administrator’s privileges, an attacker can force the desired option
    by setting the registry key value in **HKLM\System\CurrentControlSet\Control\Lsa\DsrmAdminLogonBehavior**
    to one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**0 (default)**: Login is allowed only when a domain controller is in DSRM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1**: Login is allowed only when directory services is stopped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2**: Free to log in without any limitations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using PowerShell, the adversary will set the registry value to **2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the attacker will perform a pass-the-hash attack to spawn the shell as
    the domain controller’s local administrator and run a DCSync attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The DCSync results are demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.38 – The DCSync results from the DSRM login session](image/B18964_07_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.38 – The DCSync results from the DSRM login session
  prefs: []
  type: TYPE_NORMAL
- en: The blue team should monitor the existence of the **HKLM\System\CurrentControlSet\Control\Lsa\DsrmAdminLogonBehavior**
    registry key. Event ID **4794** will log an attempt to set the DSRM password.
  prefs: []
  type: TYPE_NORMAL
- en: Our last persistence technique will cover security descriptors and how they
    can be set in order to provide privileged access for a malicious actor, without
    explicitly adding a compromised user to a privileged group.
  prefs: []
  type: TYPE_NORMAL
- en: Security descriptor alteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A security descriptor is used to store permissions that one object has over
    another. It is described using the format defined in the **Security Descriptor
    Definition Language** (**SDDL**). **Access Control Entity** (**ACE**) strings
    are used for **Discretionary Access Control List** (**DACL**) and **System Access
    Control** **List** (**SACL**)[10]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea is to modify the security descriptors of multiple remote access methods.
    We will set a backdoor for WMI and PS-Remoting access on a domain controller for
    non-privileged users. Also, we will alter the security descriptors for the remote
    registry. The RACE toolkit has PowerShell functions for these tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the command execution on the domain controller is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.39 – Setting backdoors on the domain controller for user renly.baratheon](image/B18964_07_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.39 – Setting backdoors on the domain controller for user renly.baratheon
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can confirm PS-Remoting access.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.40 – The PS-Remoting backdoor in action](image/B18964_07_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.40 – The PS-Remoting backdoor in action
  prefs: []
  type: TYPE_NORMAL
- en: 'The registry backdoor allows an attacker to retrieve the machine account hash
    (the Silver Ticket), the local account hashes, and the domain-cached credentials.
    The backdoor opens the remote registry, retrieves **BootKey**, uses it to decrypt
    the LSA key, and then, with the help of that key, decrypts the **MachineAccount**
    hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This backdoor can be detected if log events with ID **4670** (**Permissions
    on an object were changed**) are detected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, there are many ways for attackers to achieve persistence in compromised
    environments. This can be achieved at a domain level or by accessing a domain
    controller. We saw how powerful forged tickets are and how difficult is to detect
    their usage if an adversary follows OpSec recommendations. We also explored various
    ACL and attribute modifications. As usual, the devil is in the details, and in
    a complex environment, detection of such techniques can be tricky. We saw DCShadow
    and Golden gMSA attacks in practice. We dived deep into the topic of domain controller
    persistence, showing ways to collect clear-text passwords. Finally, we discussed
    security descriptors and possible ways to backdoor a system.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will focus on attacking AD Certificate Services,
    which is a privileged target in the Windows environment.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A comment about the November 2021 update: [https://www.thehacker.recipes/ad/movement/kerberos/forged-tickets/silver](https://www.thehacker.recipes/ad/movement/kerberos/forged-tickets/silver)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PAC requestor and Golden Ticket attacks: [https://www.varonis.com/blog/pac_requestor-and-golden-ticket-attacks](https://www.varonis.com/blog/pac_requestor-and-golden-ticket-attacks)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Detect malicious activity by checking checksums and ticket times: [https://www.trustedsec.com/blog/red-vs-blue-kerberos-ticket-times-checksums-and-you/](https://www.trustedsec.com/blog/red-vs-blue-kerberos-ticket-times-checksums-and-you/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The WonkaVision tool: [https://github.com/0xe7/WonkaVision](https://github.com/0xe7/WonkaVision)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inserting SID History: [https://www.thehacker.recipes/ad/persistence/sid-history](https://www.thehacker.recipes/ad/persistence/sid-history)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ServerUntrustAccount: [https://github.com/STEALTHbits/ServerUntrustAccount](https://github.com/STEALTHbits/ServerUntrustAccount)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DCShadow script: [https://github.com/samratashok/nishang/blob/master/ActiveDirectory/Set-DCShadowPermissions.ps1](https://github.com/samratashok/nishang/blob/master/ActiveDirectory/Set-DCShadowPermissions.ps1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The GoldenGMSA tool: [https://github.com/Semperis/GoldenGMSA](https://github.com/Semperis/GoldenGMSA)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A remote Skeleton Key attack: [https://adsecurity.org/?p=1275](https://adsecurity.org/?p=1275)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'ACE explained: [https://helgeklein.com/blog/permissions-a-primer-or-dacl-sacl-owner-sid-and-ace-explained/](https://helgeklein.com/blog/permissions-a-primer-or-dacl-sacl-owner-sid-and-ace-explained/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
