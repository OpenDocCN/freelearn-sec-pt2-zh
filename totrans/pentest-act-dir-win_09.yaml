- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compromising Microsoft SQL Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on a common and vital service of a typical Windows-based
    environment – Microsoft SQL Server. SQL Server is a relational database management
    system, similar to Oracle or MySQL. It is tightly integrated into Active Directory,
    allowing Windows authentication, the use of trust relationships, and much more.
    We will go through the usual attack steps, starting with the discovery and enumeration
    of instances in a target environment. A few different tools can help with these
    activities. Then, we will explore the ways to escalate privileges within SQL Server
    and then move on to run commands on the underlying operating system. This chapter
    will provide you with a solid understanding of lateral movement between database
    instances by abusing database links. Lastly, we will look at the ways to achieve
    persistence at the host and application levels utilizing what is available in
    SQL Server functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction, discovery, and enumeration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privilege escalation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating system** (**OS**) command execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lateral movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will need to have access to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: VMware Workstation Pro or Oracle VirtualBox with at least 16 GB of RAM, 8 CPU
    cores, and at least 55 GB of total space (more if you take snapshots)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Linux-based operating system is strongly recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the GOADv2 project, we will use SRV02 and SRV03
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction, discovery, and enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will start our journey in Microsoft SQL Server security
    assessment. We will briefly introduce you to SQL Server and then move on to the
    discovery process. A significant amount of the section will be a deep dive into
    the manual and automated aspects of the enumeration process.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we jump into the discovery topic, let’s start by looking at SQL Server
    functionality, fixed server roles, and security mechanisms. SQL Server is an application
    installed on the OS; in our case, we will focus only on Windows hosts. The server
    runs as a set of uniquely named Windows services in the context of the service
    account. The default listening TCP port is **1433**, and the UDP port is **1434**;
    however, if more services are running, the list of ports will be longer[1]. In
    order to get access to stored data, a user must pass authentication and authorization
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication verifies whether a user has enough permissions to log in to an
    instance. There are two authentication mechanisms – using either a Windows account
    or SQL Server login. The difference between these two mechanisms is in who handles
    the authentication – the domain controller or SQL Server itself. After login,
    an account will be assigned certain server-level roles, as defined during its
    creation. Think of these roles as Active Directory security groups. These roles
    are server-wide and can be fixed or user-defined. SQL Server 2022 has added 10
    new fixed roles[2] to the existing 9 from previous versions[3]. Fixed server role
    permissions can’t be changed, except for the “public” role. Authorization happens
    at a database level and determines what a user’s permissions on a database after
    logging in are. For this purpose, authentication accounts are mapped to database
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five default databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**master** – stores system-level instance information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**msdb** – required by SQL Server Agent to schedule jobs and alerts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**model** – a template database, used to create new databases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**resource** – a read-only database that keeps **sys** schema objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tempdb** – stores temporary objects and results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have the basic information about SQL Server, we can now move on
    to reconnaissance activities.
  prefs: []
  type: TYPE_NORMAL
- en: Discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From an unauthenticated attacker perspective, to discover SQL Server, we need
    to perform a network port scan. Nmap, **PowerUpSQL**, **SQLCMD**, CrackMapExec,
    and the **mssql_ping** Metasploit module will assist in this activity. These tools
    query common ports, such as TCP **1433** and UDP **1434**, or pull and parse SPNs
    from a domain, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If an adversary has local access to the database server, simple service enumeration
    for the name starting with **MSSQL*** or querying the registry hive located in
    **HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server\*** will reveal running database
    instances. PowerUpSQL does exactly the same with the **Get-SQLInstanceLocal**
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A set of valid domain credentials will allow an attacker to perform forest-wide
    SPN scanning to detect running SQL Server instances. Throughout the chapter, examples
    will be shown with a recently released tool called **SQLRecon**[4] and good old
    **PowerUpSQL**[5]. Let us discover whether SQL Server is installed on the essos
    domain by executing three different commands that provide exactly the same result.
    It’s important to mention that **setspn** and SQLRecon use a current domain user
    context and run from a domain-joined computer. For a Python script from **impacket**,
    we can explicitly specify credentials while running it from Kali:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLRecon performs an LDAP query, looking for a user (**sAMAccountType=805306368**)
    with an SPN starting with **MSSQL*** (**servicePrincipalName=MSSQL***). The result
    of the discovery is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Discovered SQL Server instances](image/B18964_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Discovered SQL Server instances
  prefs: []
  type: TYPE_NORMAL
- en: An adversary can then try to log into the discovered instances using compromised
    domain or SQL Server user credentials. Another way to get an initial foothold
    in the SQL Server is to brute-force your way in.
  prefs: []
  type: TYPE_NORMAL
- en: Brute force
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dictionary attacks are noisy and must be executed with caution to avoid being
    locked out of target accounts. Nmap scripts, Metasploit modules, and PowerUpSQL
    functions can assist in such an activity. In PowerUpSQL[6], there are three functions
    that allow you to perform login attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Invoke-SQLAuditWeakLoginPw** – testing a username as password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-SQLConnectionTestThreaded** – logging in with a known username/password
    pair or as a current user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-SQLServerLoginDefaultPw** – checking for default passwords used by common
    applications, based on an instance name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CrackMapExec** also allows to you perform a password spray attack, using
    supplied username and password lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s assume that an adversary has compromised or guessed the password of the
    user **jorah.mormont**. The following PowerUpSQL chained commands verify access
    to SQL Server instances as **jorah.mormont** and collect server information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – SQL Server enumeration using PowerUpSQL](image/B18964_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – SQL Server enumeration using PowerUpSQL
  prefs: []
  type: TYPE_NORMAL
- en: 'The **SQLRecon** command shows mapped roles as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – An initial foothold with a compromised user](image/B18964_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – An initial foothold with a compromised user
  prefs: []
  type: TYPE_NORMAL
- en: 'After obtaining a foothold, an adversary can continue enumeration of other
    database users to identify a possible next target. There is a Metasploit module
    to enumerate SQL logins, called **admin/mssql/mssql_enum_sql_logins**, and PowerUpSQL
    has a **Get-SQLFuzzServerLogin** function. This function under the hood invokes
    the SQL Server **suser_name** function and iterates the principal ID value. A
    public role is enough to perform such an activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – All server logins for the instance](image/B18964_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – All server logins for the instance
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to enumerate domain users with the **Get-SQLFuzzDomainAccount**
    function and Metasploit **admin/mssql/mssql_enum_domain_accounts** module. The
    idea is exactly the same, but this time, iteration goes over domain RIDs. The
    default end iteration value is 1,000; however, it can be modified for large environments
    with the **-EndId** option. It’s important to note that the LSA SID lookup requests
    (in our case, **lsa_lookupsids3**) that are utilized by this function will cause
    a lot of traffic for the domain controller in a short period of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the **Get-SQLFuzzDomainAccount** command is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – All domain groups and users](image/B18964_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – All domain groups and users
  prefs: []
  type: TYPE_NORMAL
- en: The brute-force attack will leave traces in the Windows log with the event ID
    **18456**. The error text from the event helps to determine whether the attacker
    performed user enumeration or a password spray.
  prefs: []
  type: TYPE_NORMAL
- en: The next step for the attacker is to enumerate the database itself using acquired
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Database enumeration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enumeration can be done with the help of tools such as SQLRecon or manually
    running queries, with a tool such as **HeidiSQL**[7] or Microsoft SQL Server Management
    Studio. Here is a set of common queries to get basic information about the database[8][9].
    You can run these queries in SQL SMS. The comments above the statements in the
    following screenshot aim to explain their purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All the information from the preceding queries is significant; however, the
    most crucial information is the current user’s role, the linked servers, the logins
    available for impersonation, and our effective permissions on the server and database.
  prefs: []
  type: TYPE_NORMAL
- en: SQLRecon has correspondent modules for enumeration. The tool supports five types
    of authentication, but we are only interested in three of them – a Windows token
    (**WinToken**), Windows Domain Credentials (**WinDomain**), and Local Credentials
    (**Local**). Let us enumerate.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following commands show the linked servers and accounts that
    can be impersonated by the current user (**khal.drogo**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – A list of the accounts that can be impersonated and the linked
    servers](image/B18964_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – A list of the accounts that can be impersonated and the linked
    servers
  prefs: []
  type: TYPE_NORMAL
- en: To identify privilege escalation vectors, we can run PowerUpSQL functions such
    as **Invoke-SQLAudit** or **Invoke-SQLEscalatePriv**. However, let us cover the
    privilege escalation techniques available one by one in more detail in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Privilege escalation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw a number of techniques for database enumeration.
    In this section, we will use gathered reconnaissance results for the user **khal.drogo**
    to identify privilege escalation paths on the database server. We will also practice
    escalating privileges from SQL Server to the host itself. At the end of this section,
    we will escalate to the **sysadmin** role from the user, with host local administrator
    privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Impersonation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most common privilege escalation vectors is user impersonation.
    This privilege allows the impersonation of another user or login in order to access
    resources on behalf of the impersonated user, without specifically granting rights[10].
    **sysadmin** has this permission for all databases, members of the **db_owner**
    role only have this permission in databases they own. We can check whether a current
    user is allowed to impersonate **sa** user login with the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Impersonation can happen on the server level (**EXECUTE AS LOGIN**) and on
    the database level (**EXECUTE AS USER**). Metasploit has a module named **admin/mssql/mssql_escalate_execute_as**
    that can be used to escalate privileges via impersonation. PowerUpSQL also has
    a function to identify an impersonation and exploit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Successful privilege escalation](image/B18964_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Successful privilege escalation
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, it is vital to audit users with the impersonation privilege. The **Invoke-SQLAudit**
    function from PowerUpSQL lists all logins that can impersonate others. However,
    it cannot build a relationship graph, like BloodHound, and identify nested ones.
  prefs: []
  type: TYPE_NORMAL
- en: TRUSTWORTHY misconfiguration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**TRUSTWORTHY** is a database property that indicates that SQL Server trusts
    a database and its content. By default, this property is disabled and only can
    be enabled by **sysadmin**. If an adversary is a member of the **db_owner** role
    on a **TRUSTWORTHY** database that is owned by **sysadmin**, it is possible to
    elevate privileges. The attacker with the **db_owner** role can create a stored
    procedure so that it will be executed in the context of the database owner – **sysadmin**
    (**EXECUTE** **AS OWNER**)[11].'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set up this attack in our lab. The following code will create a database,
    set it as **TRUSTWORTHY**, create a login for **viserys.targaryen**, and grant
    him the **db_owner** role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to perform the attack. Firstly, let us identify **TRUSTWORTHY**
    databases. PowerUpSQL has a function, **Invoke-SQLAuditPrivTrustworthy**, for
    this task, or we can just run the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, we need to check the members of the **db_owner** role within a **TRUSTWORTHY**
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to create a procedure and execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'An attack can be automated by using the Metasploit **auxiliary/admin/mssql/mssql_escalate_dbowner**
    module or the **Invoke-SqlServer-Escalate-DbOwner** script[12]. The result of
    the automated exploitation is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Privilege escalation from db_owner to sysadmin](image/B18964_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Privilege escalation from db_owner to sysadmin
  prefs: []
  type: TYPE_NORMAL
- en: To prevent misconfiguration, it is recommended to either switch off the **TRUSTWORTHY**
    property or change the database owner to a low-privileged user.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the following section, we will gradually move from the database
    level to the operating system level.
  prefs: []
  type: TYPE_NORMAL
- en: UNC path injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Uniform Naming Convention** (**UNC**) paths can be used to access files on
    a remote server. There are two stored procedures that support UNC paths and can
    be executed with a public server role – **xp_dirtree** and **xp_fileexist**. A
    stored procedure is a logical unit that groups several SQL statements. The benefits
    of this are security, reusability, and performance. By executing one of these
    two procedures, the attacker forces the SQL Server service account to access and
    subsequently authenticate to a controlled resource. Then, the NTLMv2 challenge
    will be captured and relayed, or cracked by an adversary. The attack can be automated
    by using the Metasploit **auxiliary/admin/mssql/mssql_ntlm_stealer** module, the
    SQLRecon **smb** module, or the **Invoke-SQLUncPathInjection** function from PowerUpSQL.
    All of them essentially execute the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The NTLMv2 challenge will be captured by Responder, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The NTLMv2 challenge for sql_svc has been captured](image/B18964_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – The NTLMv2 challenge for sql_svc has been captured
  prefs: []
  type: TYPE_NORMAL
- en: To eliminate this attack vector, it is recommended to revoke the execution of
    these procedures from a public role.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way to coerce authentication but, this time, as a machine account
    where SQL Server is installed[13]. After logging in to SQL Server Management Studio,
    an adversary restores a database from an XMLA file but points it to a controlled
    listener as a backup file location. Then, an adversary will capture the NTLMv2
    challenge.
  prefs: []
  type: TYPE_NORMAL
- en: From a service account to SYSTEM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usually, a database service account has the **SeImpersonatePrivilege** permission.
    Abusing this permission allows us to elevate our privilege to SYSTEM. Depending
    on the version of the target operating system, various exploits are available.
    **JuicyPotato**[14] works for versions below Windows Server 2019, whereas RoguePotato,
    PrintSpoofer, SharpEfsPotato, and GodPotato[15] work for versions above as well.
    All exploits use various services during exploitation, but the main idea is to
    create a pipe, force a connection to it, and then impersonate the SYSTEM token.
    To execute further commands under the context of the service, we will run the
    following command in HeidiSQL, which will connect back to our Kali machine as
    user **sql_svc**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply running the exploit grants us SYSTEM-level privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – The GodPotato exploit worked successfully](image/B18964_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – The GodPotato exploit worked successfully
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has not released a fix for this privilege escalation vector.
  prefs: []
  type: TYPE_NORMAL
- en: The following example will show how to obtain **sysadmin** privileges at the
    database level if an attacker is a local administrator.
  prefs: []
  type: TYPE_NORMAL
- en: From a local administrator to sysadmin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another possible situation is that an adversary has obtained a local administrator’s
    privileges on the database server. There are known ways how to get database **sysadmin**
    privileges as a next step[16]. One of the most common techniques is to impersonate
    a SQL Server service account because, by default, it has **sysadmin** privileges.
    PowerUpSQL has two impersonation functions called **Invoke-SQLImpersonateService**
    and **Invoke-SQLImpersonateServiceCmd**. Other techniques include reading LSA
    secrets with the help of Mimikatz, pulling SQL Server login password hashes, injecting
    DLL or shellcode into a process, or even running a database in single-user mode.
    A Metasploit module called **post/windows/manage/mssql_local_auth_bypass** combines
    getting **LocalSystem** privileges for an older SQL Server installation and migrating
    to a service process for a newer installations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the following commands allows you to obtain **sysadmin** privileges
    and dump SQL Server login password hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – SQL Server login password hashes](image/B18964_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – SQL Server login password hashes
  prefs: []
  type: TYPE_NORMAL
- en: 'Apparently, there is another way to dump password hashes – by extracting them
    from a **master.mdf** file. XPN published a while ago some great research[17]
    that showed the internals of the **master.mdf** file and released the tool to
    extract password hashes[18]. This attack requires local administrator privileges.
    Firstly, we need to locate the **master.mdf** file and copy it using the RawCopy
    tool. This tool copies raw data from disk, so getting locked out of the **master.mdf**
    file by SQL Server will be bypassed. The PowerShell script uses **OrcaMDF** .NET
    libraries, so we need to load them too, and then dump the hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding commands is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – The password hash of the SA SQL Server login](image/B18964_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – The password hash of the SA SQL Server login
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will examine multiple ways to run commands at the
    OS level.
  prefs: []
  type: TYPE_NORMAL
- en: OS command execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the upcoming sections, we will look at ways to execute OS system commands
    through SQL Server. To enable command execution, **sysadmin** privileges are required.
    Execution itself always happens in the context of a service account. An attacker
    does not need to know the hash or password of the SQL Server service or agent
    account. Let’s start by looking at built-in extended stored procedures.
  prefs: []
  type: TYPE_NORMAL
- en: xp_cmdshell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**xp_cmdshell** is probably the most well-known built-in extended stored procedure,
    which is disabled by default. Enabling it requires **sysadmin** privileges. There
    are a few functions in PowerUpSQL (**Invoke-SQLOSCmdExec** and **Invoke-SQLOSCmd**),
    SQLRecon (**EnableXp** and **XpCmd**), as well as the Metasploit **admin/mssql/mssql_exec**
    module that can automate this task. The manual query to install **xp_cmdshell**
    and enable it is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to mention that such an activity will create events with the
    ID **15457**, as the **sp_configure** procedure will have been used. The Windows
    event ID **15281** will be logged if the configuration attempt fails because the
    user does not have enough privileges.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – A failed attempt to reconfigure xp_cmdshell](image/B18964_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – A failed attempt to reconfigure xp_cmdshell
  prefs: []
  type: TYPE_NORMAL
- en: Also, there is a module in Metasploit (**exploit/windows/mssql/mssql_payload**)
    that will allow the execution of an arbitrary payload via **xp_cmdshell**.
  prefs: []
  type: TYPE_NORMAL
- en: A custom extended stored procedure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply put, a custom extended stored procedure is an extension to SQL Server
    in the form of DLL. Sysadmin privileges are required to register each procedure
    inside the extension. A code sample for DLL can be found on GitHub[19]. It’s important
    to note that DLL and function names are case-sensitive and must be exactly the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerUpSQL has a function called **Create-SQLFileXpDll** that will create a
    DLL for us. Then, we will register it, list the extended stored procedures to
    verify registration, and finally, execute our malicious extended procedure. The
    following commands replicate the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the automatically PowerUpSQL created DLL did not execute on
    the target machine in the lab, even through the **rundll32** command. Surprisingly,
    the same DLL works fine on a Windows 10 machine, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – DLL spawned a reverse shell](image/B18964_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – DLL spawned a reverse shell
  prefs: []
  type: TYPE_NORMAL
- en: 'The successful loaded DLL generates event ID **33090**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – DLL was successfully loaded into memory](image/B18964_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – DLL was successfully loaded into memory
  prefs: []
  type: TYPE_NORMAL
- en: The failed attempt will generate an error with ID **17750**. By correlating
    both events, it is possible to build detection around DLL names if there is a
    pre-defined list in an environment.
  prefs: []
  type: TYPE_NORMAL
- en: Custom CLR assemblies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Common Language Runtime** (**CLR**) assembly is a .NET DLL that can be imported
    into SQL Server. After it is imported, DLL methods can be linked to stored procedures.
    In this scenario, an attack consists of two steps – enabling CLR and the actual
    execution. A nice step-by-step blog post detailing this was created by *NetSPI*[20].
    C# code is compiled in DLL and imported into SQL Server. The following queries
    allow you to execute the OS command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Another advantage of this method is that it is possible to use a hex representation
    of the DLL purely in memory, without touching the disk.
  prefs: []
  type: TYPE_NORMAL
- en: There are two more considerations to keep in mind. This technique requires the
    **TRUSTWORTHY** property to be set, which is why we use the **msdb** database
    that has this property by default. Also, the **clr strict security** option was
    introduced by Microsoft[21]. By default, the **permission_set** option in **alter/create**
    assembly statements will be ignored. To switch it off, reconfiguration of CLR
    strict security is required through **sp_configure**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For demonstration purposes, we will combine the use of SQLRecon and the **Create-SQLFileCLRDll**
    function from PowerUpSQL to obtain an interactive reverse shell. The very first
    step is to enable CLR with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the **Create-SQLFileCLRDll** function to generate code for a custom
    assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us change the generated **.csc** file. The following code works perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two commands will compile the code from above in DLL, and SQLRecon
    will automate the rest of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that SQLRecon bypasses the **clr strict security** option by adding assembly
    to trusted list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Custom CLR successfully executed a reverse shell](image/B18964_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Custom CLR successfully executed a reverse shell
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, we have an interactive shell on the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – An interactive reverse shell on the database server](image/B18964_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – An interactive reverse shell on the database server
  prefs: []
  type: TYPE_NORMAL
- en: This functionality is also implemented in a Metasploit module called **exploit/windows/mssql/mssql_clr_payload**
    and in another PowerShell tool called **SeeCLRly**[22].
  prefs: []
  type: TYPE_NORMAL
- en: In order to list and export existing CLR assemblies, the **Get-SQLStoredProcedureCLR**
    function was implemented in PowerUpSQL. We can then modify the exported CLR DLL
    by using the **dnSpy** decompiler and re-upload it, overwriting the existing one
    to achieve stealthy persistence.
  prefs: []
  type: TYPE_NORMAL
- en: Attack detection is possible via event ID **15457**, as an adversary must use
    **sp_configure**. Assembly creation will generate event ID **6299**, unloading
    the assembly will generate event ID **10310**, and the unload confirmation generate
    event ID **6290**. Correlating and chaining together these four events can help
    in the reliable detection of malicious activity.
  prefs: []
  type: TYPE_NORMAL
- en: OLE automation procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Object Linking and Embedding** (**OLE**) technology allows you to link objects
    from one application to another. OLE automation procedures help SQL Server to
    use to interact with COM objects. The **Component Object Model** (**COM**) allows
    interaction between binary software components. OLE automation procedures use
    **odsole70.dll** to interact with the COM[23]. The following is a list of procedures
    that can be used for command execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sp_OACreate** – creates an OLE object instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sp_OAMethod** – calls an OLE object method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sp_OADestroy** – destroys a created OLE object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sp_OASetProperty** – sets an OLE object property'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some practical OLE usage examples include creating a web shell on a web server,
    downloading malware, moving files around a filesystem, and executing commands.
    The **Invoke-SQLOSCmdCLR** function in PowerUpSQL will enable OLE automation,
    execute a command, read the command’s output from the temporary file, and then
    delete it. The Metasploit **admin/mssql/mssql_exec** module can be switched to
    use the **sp_OACreate** procedure as well. However, it will be up to an attacker
    on the method to retrieve results – for example, with the **OPENROWSET()** function.
    The following are commands to obtain an interactive reverse shell with the help
    of SQLRecon and **nc.exe**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the successful execution is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – OS command execution through the OLE automation procedures](image/B18964_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – OS command execution through the OLE automation procedures
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to obtain a reverse shell manually is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As with CLR execution, it is not possible to completely prevent this attack.
    It is recommended to keep OLE automation disabled and remove execution permissions
    on procedures stored by users. Detection is possible via **sp_configure** event
    monitoring on all the aforementioned execution methods. Additionally, event ID
    **33090** will be generated when **odsole70.dll** is loaded into memory, and event
    ID **8128** will be generated when **sp_OACreate** is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Agent jobs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL Server Agent is a Windows service that executes automated tasks. The agent
    job will run under the SQL Server Agent service, or it can utilize agent proxy
    capabilities, meaning that jobs will be run in different user contexts. The job
    can be manually started by the **sp_start_job** stored procedure, scheduled, or
    executed when a specific condition is met. To create a job, either a **sysadmin**
    role or **SQLAgentUserRole**, **SQLAgentReaderRole**, and **SQLAgentOperatorRole**
    fixed database roles in the **msdb** database are required. There are promising
    job types, such as CmdExec, PowerShell, ActiveX Script, and SQL Server Integrated
    Services, that allow command execution. The following steps are required to utilize
    a job functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sp_add_job** – create a job'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sp_add_jobstep** – add a job step'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sp_start_job** – run a job'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sp_delete_job** – delete a job'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A great demonstration of the step-by-step job creation for PowerShell was shown
    in an Optiv blog post[24]. Let us create a job for CmdExec to obtain a reverse
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this code will not run in our lab because SQL Server Agent service
    cannot be started. The reason for this is that Agent jobs are supported only in
    paid MS SQL Server versions, not in Express. However, it is good to show such
    attack vector as well. As usual, there is a function in PowerUpSQL (**Invoke-SQLOSCmdAgentJob)**
    and two modules in SQLRecon (**AgentStatus** and **AgentCmd**) to automate the
    task. Instead of creating a new job, the attacker can add a step to an existing
    one. To list all jobs, there is the **Get-SQLAgentJob** function in PowerUpSQL
    or the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Prevention recommendations including disabling the SQL Server Agent service
    if it is not used and limiting users with **SQLAgentUserRole**, **SQLAgentReaderRole**,
    and **SQLAgentOperatorRole** fixed database roles.
  prefs: []
  type: TYPE_NORMAL
- en: External scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another way to run commands with the help of the Machine Learning Services
    feature. It gives you the ability to run R and Python scripts. Installation of
    this feature requires a paid version of the SQL Server. In our case, we will use
    the free Express version and just briefly go through available ways to run commands.
    First of all, to enable external scripts, **sysadmin** privileges are required,
    together with server-level changes (**sp_configure 'external scripts enabled'**).
    Both languages have a wide variety of ways to run arbitrary code, ranging from
    UNC path injection to full interactive shell. Some interesting examples can be
    found in[25] and in[26]. The **Invoke-SQLOSCmdR** and **Invoke-SQLOSCmdPython**
    functions from PowerUpSQL can also automate the exploitation process.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will examine ways in which an attacker can move
    laterally on the domain and database levels in the target environment.
  prefs: []
  type: TYPE_NORMAL
- en: Lateral movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in [*Chapter 5*](B18964_05.xhtml#_idTextAnchor093), it is crucial
    to understand how an adversary can abuse legitimate applications and protocols
    to expand inside the target environment. SQL Server also broadens lateral movement
    scenarios via two techniques. One is common and called shared service accounts.
    The other one is specific only to SQL Server – abusing database links. We will
    quickly explore the first one and focus on the second. We will examine how to
    do enumeration on linked servers, execute code, and extract clear-text hardcoded
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Shared service accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using shared service accounts across an environment may lead to disastrous consequences.
    If a service account is compromised via Kerberoasting, UNC path injection, or
    any other way, it means that all instances using this account are compromised.
    Moreover, the service account by default has **sysadmin** privileges on the database
    and SQL Server levels, but it also may have extensive privileges on the underlying
    OS. To prevent such a powerful lateral move, all service accounts should be unique
    across the environment, with gMSA in use.
  prefs: []
  type: TYPE_NORMAL
- en: Database links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What are database links? In simple terms, they are a persistent connection between
    two or more servers. They allow you to access external data sources and, if the
    source is a SQL Server, also execute stored procedures. Links work even across
    forest trusts and can sometimes be the only way to get a foothold in another domain
    or forest. There are two ways links can be configured – with a current logged-in
    user context or hardcoded credentials. Queries on the linked server are executed
    as a user whose credentials were used to configure the link. Effectively, it is
    impersonation. Links can be crawled, meaning that an adversary can jump consequently
    from one SQL Server to another. We need to understand who we are, perform enumeration,
    and look for privilege escalation or lateral movement options.
  prefs: []
  type: TYPE_NORMAL
- en: An ideal attacking scenario is to identify linked servers, check user account
    privileges on them, verify the **RPC Out** value, and enable **xp_cmdshell** to
    obtain command execution. **RPC Out** allows you to run stored procedures on the
    specified linked server and can only be enabled with **sysadmin** privileges,
    using the **sp_serveroption** procedure. If **RPC Out** is disabled, it will be
    impossible to enable **xp_cmdshell** on the linked server, even with **sysadmin**
    privileges. The reason for this is that queries running via **openquery()** do
    not require **RECONFIGURE** to be run.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerUpSQL has two functions (**Get-SQLServerLink** and **Get-SQLServerLinkCrawl**)
    that help to identify links. Metasploit has its own module called **exploit/windows/mssql/mssql_linkcrawler**
    that can deploy payloads in a fully automated way. The attack steps are as follows:
    find the linked server, enumerate it, understand the login context, and then escalate
    privileges and/or move them laterally.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use SQLRecon for the rest of this section. I logged in as **jon.snow**
    to perform all the aforementioned actions with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the commands executed on the linked server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Linked server enumeration](image/B18964_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Linked server enumeration
  prefs: []
  type: TYPE_NORMAL
- en: 'The successful command execution gave us an interactive shell on the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – An interactive reverse shell on the linked server](image/B18964_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – An interactive reverse shell on the linked server
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this section, we mentioned hardcoded credentials. If SQL
    Server credentials are used to create links, they are stored in an encrypted format
    and, therefore, can be pulled in clear text[27]. Successful extraction requires
    **sysadmin** privileges for all database instances on a **Dedicated Administrative
    Connection** (**DAC**) and local administrative privileges on the server itself
    to get access to entropy bytes in the registry. These bytes are used to strengthen
    encryption and are stored in the registry. The script pulls data from a few tables
    as well. If everything works as expected, you will extract clear-text passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more interesting use of linked servers is LDAP enumeration via OpenQuery[28].
    We will need a set of valid domain credentials before we start. They can be obtained
    by cracking the NTLMv2 challenge after a UNC path injection attack or by simply
    utilizing the domain account of the SQL service. The idea is to establish an **Active
    Directory Service Interface** (**ADSI**) linked server and run LDAP queries via
    OpenQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Domain user enumeration via OpenQuery](image/B18964_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – Domain user enumeration via OpenQuery
  prefs: []
  type: TYPE_NORMAL
- en: To prevent link abuse, remove unused links and check chained links as well.
    Ensure that links are not configured with **sysadmin** or overly permissive privileges.
    Consider disabling **RPC Out** as well.
  prefs: []
  type: TYPE_NORMAL
- en: The following section will show how persistence can be achieved at the SQL Server
    and OS levels by using legitimate functionality from SQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know about persistence on domain and domain controller levels, why
    bother with SQL Server? Most detective controls are implemented at the OS level.
    Database audits are not so common and thorough. A SQL Server service account may
    have extensive permissions on the OS, giving an attacker an excellent hideout,
    as all questionable actions will be logged as they were performed by the service
    account. Lastly, even if auditing and monitoring are enabled on busy databases,
    it is difficult to differentiate legitimate activities from malicious ones. We
    will start with the most noisy and unsafe way to achieve persistence at the OS
    level via autoruns, moving toward the SQL Server level, with startup procedures
    and triggers.
  prefs: []
  type: TYPE_NORMAL
- en: File and registry autoruns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These two methods are very OpSec-unsafe, as the **Startup** folder and registry
    keys are often monitored by security solutions, such as Sysmon and EDR. There
    is a slight chance that writing a file in such locations using a SQL Server service
    account will be treated as legitimate behavior. Again, it is highly not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by writing a file to the **Startup** folder. If the SQL Server
    service account is configured with extensive permissions on the host, it is possible
    to put the file in a folder of a high-privileged user, or even for all users.
    The OLE automation procedure must be enabled beforehand. The following code creates
    a batch file in the **sql_svc** **Startup** folder that will make a connection
    back to our machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'On the next login of **sql_svc**, we receive the connection back, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – The reverse shell from the file in the Startup folder](image/B18964_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – The reverse shell from the file in the Startup folder
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Server also allows you to interact with the registry using stored procedures
    – **xp_regwrite**, **xp_regread**, and **xp_regdeletekey**. Executing these procedures
    requires **sysadmin** privileges. However, at the OS level, this is not enough
    – for example, writing to **HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
    hive** requires local administrative privileges. PowerUpSQL has three functions
    that use the registry for persistence:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get-SQLPersistRegDebugger** – setting a custom debugger for accessibility
    options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-SQLPersistRegRun** – writing a payload in the autorun key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-SQLRecoverPwAutoLogon** – reading autologin passwords'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let us examine some more OpSec safe options for persistence at the database
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Startup stored procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can guess from the name of this type of procedure, it runs when SQL
    Server starts or restarts. All such procedures run under the **sa** login, must
    be owned by **sa**, and must be in the master database. To mark a procedure for
    automated execution, **sysadmin** privileges are required, but not necessary **sa**.
    Procedures cannot accept any input/output parameters. The following code creates
    our malicious procedure (**sp_rev_shell**), marks it for automated execution,
    and lists automatically executed stored procedures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After the SQL Server service restart, the reverse shell was executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Persistence via a startup stored procedure](image/B18964_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – Persistence via a startup stored procedure
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a PowerShell script that automates these actions[30]. It incorporates
    three persistence scenarios – creating a new SQL Server **sysadmin** login, creating
    a Windows local administrator account, and running a PowerShell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the script execution is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Fully automated sysadmin user creation](image/B18964_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – Fully automated sysadmin user creation
  prefs: []
  type: TYPE_NORMAL
- en: The main disadvantage of this method is that we must wait for the maintenance
    of the SQL Server. NetSPI’s blog post[29] shows how to enable server- and database-level
    audit features. They detect the use of the **sp_procoption** procedure (event
    ID **33205**), the launch of a malicious startup procedure (event ID **17135**),
    and a new SQL Server login with **sysadmin** privileges (event ID **33205**).
    Lastly, if an adversary decides to change or delete audit settings, event ID **33205**
    will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: Malicious triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What is a trigger? According to Microsoft, “*a trigger is a special type of
    stored procedure that automatically runs when an event occurs in the database
    server*”[31]. There are three types of triggers, which differ based on the execution
    condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Definition Language** (**DDL**) – **CREATE**, **ALTER**, and **DROP**
    statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Manipulation Language** (**DML**) – **INSERT**, **UPDATE**, and **DELETE**
    statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logon triggers** – an on-logon event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A DDL trigger applies at the server and database levels. There are tons of
    DDL events and event groups[32] that can be used to create a trigger. Some of
    them can happen every few minutes in busy environments, so choose wisely. Trigger
    creation is as simple as the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'DML triggers work only at the database level. We will choose a statement and
    table. The important caveat is that users working with the target table may not
    have enough permissions for actions such as running **xp_cmdshell**. NetSPI in
    their blog[33] advises to either grant an **sa** impersonation permission for
    all users or use a proxy account for **xp_cmdshell** execution. The following
    code will create a DML trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Logon triggers are used to prevent users from logging in depending on certain
    conditions. Instead of using a real user login, an attacker can create a low-privileged
    fake account and utilize it when persistence is required. The code for such a
    trigger is self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Trying to log in with a fake account will trigger the connection but also leave
    an error in the log, with the event ID **17892**. With enabled audit features,
    trigger creation code will be fully logged in the event ID **33205**.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, there are many reasons for an adversary to choose SQL Server
    as a valuable target. We saw in practice how to perform enumeration against a
    database server. We deep-dived into various privilege escalation techniques, not
    focusing only on the database level. By gradually migrating from a low-privileged
    public account to **SYSTEM**, we covered the attacker’s kill chain. Then, many
    techniques for OS command execution were demonstrated in order to help us understand
    how tightly applications can be integrated with a host OS. Furthermore, we saw
    how database links can be abused by an adversary for lateral movement if they
    are not configured correctly. Finally, persistence techniques were discussed at
    the OS and database levels. A deeper understanding of available database functionality
    can give one party an advantage over the other.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These aids for further study will let you dive deeper into the attacks covered
    in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Server network ports: [https://www.mssqltips.com/sqlservertip/7212/sql-server-port-explanation-usage/](https://www.mssqltips.com/sqlservertip/7212/sql-server-port-explanation-usage/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SQL Server 2022 new fixed server-level roles: [https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles?view=sql-server-ver16](https://learn.microsoft.com/en-us/sql/relational-databases/security/authentication-access/server-level-roles?view=sql-server-ver16)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pre-SQL Server 2022 fixed server-level roles: [https://www.mssqltips.com/sqlservertip/1887/understanding-sql-server-fixed-server-roles/](https://www.mssqltips.com/sqlservertip/1887/understanding-sql-server-fixed-server-roles/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SQLRecon tool: [https://github.com/skahwah/SQLRecon](https://github.com/skahwah/SQLRecon)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PowerUpSQL tool: [https://github.com/NetSPI/PowerUpSQL](https://github.com/NetSPI/PowerUpSQL)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'PowerUpSQL Cheat Sheet: [https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet](https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'HeidiSQL tool: https://www.heidisql.com/'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'MS SQL Server enumeration: https://book.hacktricks.xyz/network-services-pentesting/pentesting-mssql-microsoft-sql-server#common-enumeration'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'MS SQL Server enumeration 2: https://ppn.snovvcrash.rocks/pentest/infrastructure/dbms/mssql#enumeration'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'User impersonation: https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-2-user-impersonation/'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Attacking (un)trustworthy databases: https://www.netspi.com/blog/technical/network-penetration-testing/hacking-sql-server-stored-procedures-part-1-untrustworthy-databases/'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Escalating from a **db_owner** script: https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/Invoke-SqlServer-Escalate-Dbowner.psm1'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'MS SQL Coerce: https://github.com/p0dalirius/MSSQL-Analysis-Coerce'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'JuicyPotato: https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/juicypotato'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'RoguePotato, PrintSpoofer, SharpEfsPotato, and GodPotato: https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/roguepotato-and-printspoofer'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Obtaining SQL Server **sysadmin** privileges from a local administrator: https://www.netspi.com/blog/technical/network-penetration-testing/get-sql-server-sysadmin-privileges-local-admin-powerupsql/'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extracting SQL Server hashes from a **master.mdf** file: https://xpnsec.tumblr.com/post/145350063196/reading-mdf-hashes-with-powershell'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Invoke-MDFHashes**: https://github.com/xpn/Powershell-PostExploitation/tree/master/Invoke-MDFHashes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Custom extended stored procedure DLL template: https://raw.githubusercontent.com/nullbind/Powershellery/master/Stable-ish/MSSQL/xp_evil_template.cpp'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SQL Server CLR assemblies: https://www.netspi.com/blog/technical/adversary-simulation/attacking-sql-server-clr-assemblies/'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'CLR strict security: https://learn.microsoft.com/en-us/sql/database-engine/configure-windows/clr-strict-security?view=sql-server-ver16'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SeeCLRly tool: https://github.com/sekirkity/SeeCLRly'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exploit OLE Automation: https://www.imperva.com/blog/how-to-exploit-sql-server-using-ole-automation/'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Agent job command execution: https://www.optiv.com/explore-optiv-insights/blog/mssql-agent-jobs-command-execution'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'External script execution: https://cheats.philkeeble.com/active-directory/mssql#external-scripts'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Beyond xp_cmdshell* by*nullbind*: https://www.slideshare.net/nullbind/beyond-xpcmdshell-owning-the-empire-through-sql-server'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Decrypting linked server passwords: https://www.netspi.com/blog/technical/adversary-simulation/decrypting-mssql-database-link-server-passwords/'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'LDAP enumeration via OpenQuery: https://keramas.github.io/2020/03/28/mssql-ad-enumeration2.xhtml'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Persistence via startup stored procedures: https://www.netspi.com/blog/technical/network-penetration-testing/sql-server-persistence-part-1-startup-stored-procedures/'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Invoke-SqlServer-Persist-StartupSp** script: https://github.com/NetSPI/PowerUpSQL/blob/master/scripts/pending/Invoke-SqlServer-Persist-StartupSp.psm1'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Triggers: https://learn.microsoft.com/en-us/sql/t-sql/statements/create-trigger-transact-sql?view=sql-server-ver16'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'DDL event groups: https://learn.microsoft.com/en-us/sql/relational-databases/triggers/ddl-event-groups?view=sql-server-ver16'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Persistence via triggers: https://www.netspi.com/blog/technical/network-penetration-testing/maintaining-persistence-via-sql-server-part-2-triggers/'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
