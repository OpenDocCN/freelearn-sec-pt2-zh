- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking Over WSUS and SCCM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter of the book, we will focus on attacking infrastructure
    management solutions. These are valuable and attractive targets for an adversary
    as such systems are operated under highly privileged accounts with access to almost
    every piece of the target environment. **Windows Server Update Services** (**WSUS**)
    is a service to deploy updates to the client computers in a centralized manner.
    **Microsoft Endpoint Configuration Management** (**MECM**) – formerly known as
    **System Center Configuration Manager** (**SCCM**) – is an on-premises management
    solution for endpoints. This product helps IT professionals run system inventory,
    patching, software deployment, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by discussing known attacks on WSUS and then show how it can
    be abused for lateral movement. However, the main focus of this chapter is on
    SCCM. After the introduction and necessary theory, we will move on to the deployment
    stage. When our lab is ready, it is time to go through the kill chain one more
    time: reconnaissance, privilege escalation, and lateral movement. As usual, our
    main attention will be on the service-specific techniques. We will finish the
    chapter with defensive recommendations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Abusing WSUS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to and deployment of MECM/SCCM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconnaissance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privilege escalation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lateral movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defensive recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will need to have access to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: VMware Workstation or Oracle VirtualBox with at least 16 GB of RAM, 8 CPU cores,
    and at least 55 GB of total space (more if you take snapshots)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux-based operating system is strongly recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From GOADv2 project we will use DC01, SRV01
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From DetectionLab we will use DC, WEF, Win10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abusing WSUS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most corporate environments, updates are distributed and installed centrally
    by administrators. For Windows-based infrastructure, the way to go is to install
    a WSUS server role on one of the servers in the network and force clients and
    servers to use it as a source of updates. WSUS can help to eliminate risks related
    to missing patches but can also be a target for compromise. The reason is simple:
    attackers can use it to distribute malicious code that will be automatically downloaded
    and installed and looks legitimate and trustworthy. Clients will get all the required
    information about the WSUS server by querying the registry key values in **HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate**.
    In essence, WSUS is a **Simple Object Access Protocol** (**SOAP**) XML web service.
    All updates must be signed by Microsoft, and WSUS checks the digital signature
    and hash of every update. However, **Transport Layer Security** (**TLS**) is not
    enabled by default, opening the first opportunity for compromise.'
  prefs: []
  type: TYPE_NORMAL
- en: Unencrypted communication can lead to a **Man-in-the-Middle** (**MitM**) attack
    depending on the attacker’s position in the network. Firstly, we need to check
    the **WUServer** registry value for the HTTP protocol presence, which means that
    TLS is not in use and the attack is possible Then, we can try to perform **Address
    Resolution Protocol** (**ARP**) spoofing and deliver a signed binary such as **PsExec**.
    The attack consists of two parts – MitM and distribution. **GoSecure** developed
    a malicious update distribution tool called **PyWSUS**[1]. To carry out the MitM
    attack, **bettercap**[2] was recommended in the research[3].
  prefs: []
  type: TYPE_NORMAL
- en: Another vector we should not miss is vulnerabilities in the client itself. For
    example, CVE-2020-1013 allows us to modify local user proxy settings, so we can
    run **PyWSUS** locally, executing code with **SYSTEM** privileges on the machine.
    The tool to run this attack – called **WSuspicious** – was published in the *GoSecure*
    GitHub repository[4].
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we target any Windows-based environment, the **New Technology LAN Manager**
    (**NTLM**) relay attack is always somewhere nearby. As discussed previously, we
    can redirect the client’s WSUS requests toward a malicious WSUS server, so nothing
    stops us from requesting NTLM authentication and the client will automatically
    do so.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is described by *GoSecure* here: [https://www.gosecure.net/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks/](https://www.gosecure.net/blog/2021/11/22/gosecure-investigates-abusing-windows-server-update-services-wsus-to-enable-ntlm-relaying-attacks/).'
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaway from all the attacks so far described is to enforce WSUS updates
    only over secure HTTPS transport.
  prefs: []
  type: TYPE_NORMAL
- en: The last attack in our scope is the distribution of malicious updates to the
    client if the attacker has compromised the WSUS server itself. For this purpose,
    we will deploy WSUS on **castelrock.sevenkingdoms.local** and install a malicious
    update on **kingslanding.sevenkingdoms.local**, getting a reverse shell. We need
    to deploy WSUS in our lab following the guide provided by Microsoft[5].
  prefs: []
  type: TYPE_NORMAL
- en: Role installation is straightforward. The next step is service configuration.
    We will untick all OS versions and software in the suggested update target list
    as we do not want WSUS to pull updates from the internet. Lastly, we need to configure
    Group Policy, so the **domain controller** (**DC**) will pull updates from WSUS[6].
    It is important to mention that we must use a **fully qualified domain name**
    (**FQDN**) with a port number for the WSUS server in the Group Policy parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compromise the DC, we can utilize the **SharpWSUS**[7] or **wsuspendu**[8]
    tools. The plan is to host a reverse shell script on our web server, and download
    and execute it by using **PsExec**[9] as a payload (as it is signed by Microsoft):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the update is installed on the DC, and we obtain the reverse shell as
    **SYSTEM**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Reverse shell on the DC as SYSTEM](image/B18964_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Reverse shell on the DC as SYSTEM
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the most common compromise vectors for WSUS such
    as MitM, missing patches, and NTLM relay attacks. Also, we demonstrated how compromised
    WSUS can be abused for lateral movement, effectively giving the attacker the possibility
    of a complete infrastructure takeover.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will start with systems management software developed
    by Microsoft. It is now called MECM, but we often still use the old name, which
    is SCCM.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to MECM/SCCM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCCM is a complicated piece of software with its own hierarchy and terms. We
    will start with the required theory. In essence, SCCM utilizes client-server architecture,
    where an agent is installed on endpoints and then called back to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Hierarchy designs are described by Microsoft here: [https://learn.microsoft.com/en-us/mem/configmgr/core/plan-design/hierarchy/design-a-hierarchy-of-sites](https://learn.microsoft.com/en-us/mem/configmgr/core/plan-design/hierarchy/design-a-hierarchy-of-sites).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our lab, we will deploy a single standalone **primary site**. The **secondary
    site** can be added for scalability purposes in a bigger environment. Also, if
    there are more than two primary sites, you will need a **central administration
    site**, which is used only for managing sites, not the clients. Every site has
    a three-letter **site code**. Clients are grouped in **boundary groups** based
    on, surprise, boundaries. Network range or **Active Directory** (**AD**) group
    membership are good examples of boundaries. Also, it is possible to perform discovery
    tasks and automatically assign clients to the group, depending on certain criteria.
    **Management point** (**MP**) is a role providing clients with policies and configurations
    to communicate with the site server. It is installed on the primary site server
    by default. Next, clients need to know the **distribution point** (**DP**) to
    be able to get updates, software, and so on. All information about the clients
    is stored on the **site database server**, which is Microsoft SQL Server. Communication
    between the primary server and the database is the responsibility of the **SMS
    provider** component. In our lab, we will install an SMS provider and database
    server on our primary site server. There is an excellent visualization diagram
    of a hierarchy[10] next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Typical SCCM hierarchy](image/B18964_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Typical SCCM hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to install clients on target machines in the boundary group.
    The default way is a **client push installation**. This uses client push installation
    accounts, which are service accounts with administrative rights on the computer.
    During installation, it authenticates using that account and installs the client.
    If there are a few accounts configured, the server will try to authenticate each
    of them, one by one. Another promising account from an adversary’s point of view
    is a **Network Access Account** (**NAA**). This account is utilized when a non-domain-joined
    client wants to access content from a DP.
  prefs: []
  type: TYPE_NORMAL
- en: Our next task is to deploy SCCM in **DetectionLab**. I will install it on a
    WEF machine.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deployment is quite a lengthy process. I suggest having a 2–3-hour timeframe
    for adding CPU and memory to the WEF virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To deploy SCCM, I used two resources. The first one is made by *Benoit Lecours*
    from System Center Dudes ([https://www.systemcenterdudes.com/complete-sccm-installation-guide-and-configuration/](https://www.systemcenterdudes.com/complete-sccm-installation-guide-and-configuration/))
    and the second one is an adapted version of the preceding one, by *HTTP418* ([https://http418infosec.com/grow-your-own-sccm-lab](https://http418infosec.com/grow-your-own-sccm-lab)).
  prefs: []
  type: TYPE_NORMAL
- en: 'I will not put a step-by-step guide here; however, I will briefly cover my
    journey:'
  prefs: []
  type: TYPE_NORMAL
- en: On the WEF machine, enable the **Windows Installer** and **Windows Module**
    **Installer** services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform schema extension using **extadsch.exe**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a container and accounts in AD as per the HTTP418 guide.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use **Group Policy** to push firewall rules and add a client push installation
    account to the local **Administrators** group on target machines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install required Windows features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the Windows **Assessment and Deployment** **Kit** (**ADK**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Microsoft SQL Server in evaluation mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set required SPNs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I skipped database creation and only enabled listening on the IP address for
    SQL Server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the evaluation version of SCCM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the installation is complete, configuration is required. I followed the
    guide and was finally able to run a script on a WIN10 computer, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Running a script on a WIN10 client from the configuration console](image/B18964_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Running a script on a WIN10 client from the configuration console
  prefs: []
  type: TYPE_NORMAL
- en: Now the deployment is over, we should have a minimal working environment for
    attack simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A great review of the SCCM attack surface with nicely structured schema was
    created by *0xcsandker* in his blog post here: [https://www.securesystems.de/blog/active-directory-spotlight-attacking-the-microsoft-configuration-manager/](https://www.securesystems.de/blog/active-directory-spotlight-attacking-the-microsoft-configuration-manager/).'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, our first step will be reconnaissance. We will focus on exploring
    SCCM infrastructure and host enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Reconnaissance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss reconnaissance, as well as enumeration. We
    will briefly cover how to identify SCCM only with network access and then dive
    deeper into the *assume* *breach* scenario.
  prefs: []
  type: TYPE_NORMAL
- en: To identify SCCM infrastructure from a non-domain-joined machine, the attacker
    may perform a simple port scan looking for TCP ports **8530** and **8531** (Software
    Update point), **10123** (Management point), and **4022** and **1433** (SQL Server).
    Also, the UDP port **4011** might be an indicator of the **Preboot Execution Environment**
    (**PXE**) boot media being offered. SCCM can be deployed with or without a PXE
    offering called **Operating System Deployment** (**OSD**). We do not have PXE
    deployed in our lab, but there are some promising vectors to consider.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether PXE is available in the environment, there is a tool called
    **PXEThief**[11]. This tool sends a DHCP discover request to search for PXE servers
    and fetch PXE boot files. If PXE media is encrypted, then the attacker needs to
    guess or crack the password to decrypt it. After decryption, the tool will parse
    files for NAA accounts and credentials in **task sequences** or stored within
    **collection variables**. In OSD, there is a task sequence functionality. This
    functionality, in a nutshell, is a defined list of steps to deploy the machine
    correctly. Some of the steps, such as *Task sequence domain join account*, will
    use domain user credentials. Also, collection variables in task sequence steps
    may use hardcoded credentials. The tool will extract these credentials for you.
    Alternatively, the attacker can wait till the OS installation begins and check
    the **C:\Windows\panther\unattend\unattend.xml** file for the set of domain credentials.
  prefs: []
  type: TYPE_NORMAL
- en: A way to obtain NAA credentials was shown by *Raiona_ZA* during his DEFCON talk[12].
    If *F8-Debugging* is not disabled, an adversary can invoke the **SYSTEM** shell
    by repeatedly pressing *F8*, then run a Visual Basic Script to dump environment
    variables and search there for **_SMSTSReserved1** (username) and **_SMSTSReserved2**
    (password) values. These are your NAA credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us do some hands-on discovery and enumeration from the context of
    the compromised domain user. I will stick to the **SharpSCCM**[13] tool made by
    *Mayyhem* throughout this chapter. We can find the SCCM MP and site code in two
    different ways – PowerShell and WMI (**SharpSCCM** uses WMI):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the **SharpSCCM** command execution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – SharpSCCM shows the MP and site name](image/B18964_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – SharpSCCM shows the MP and site name
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the MP can be extracted from logs that are stored in **C:\Windows\CCM\Logs**
    on the machine. **SharpSCCM** has the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Probably the last thing that an adversary can do locally without administrative
    privileges is to examine previously executed scripts only if PowerShell logging
    is enabled. This will allow the retrieval of script content from a Windows event.
    The following PowerShell command will go through events in Windows PowerShell
    logs and look for event ID **4104** (*PowerShell Script* *Block Logging*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we can see our preceding reconnaissance command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Result of the PowerShell logging](image/B18964_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Result of the PowerShell logging
  prefs: []
  type: TYPE_NORMAL
- en: Scripts executed from the primary site are stored on the client side in the
    **C:\Windows\CCM\ScriptStore** folder. But to read the content of the scripts
    in this folder, **SYSTEM** privileges are required.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can try to pull files from the **SCCMContentLib$** share on the DP.
    There is a tool called **CMLoot**[14] that will create a list of files on shares
    and download them.
  prefs: []
  type: TYPE_NORMAL
- en: We will now move to the next section, which is about privilege escalation techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Privilege escalation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will be focused on privilege escalation via credential harvesting
    and authentication coercion. For harvesting, we will need a local Administrator
    account.
  prefs: []
  type: TYPE_NORMAL
- en: Client push authentication coercion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we did in previous chapters, here, we will split hash capture and relay phases
    as well. Our goal is to coerce client push installation account authentication
    against our controlled machine to capture the NTLM response.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Coercion attacks were presented by *Mayyhem* in his blog post at [https://posts.specterops.io/coercing-ntlm-authentication-from-sccm-e6e23ea8260a](https://posts.specterops.io/coercing-ntlm-authentication-from-sccm-e6e23ea8260a).
  prefs: []
  type: TYPE_NORMAL
- en: The important fact is that the attack does not require administrative privileges;
    the captured client push installation account’s NTLM response will grant administrative
    access to all other machines where such an account has been used. The main prerequisites
    are automatic client assignment for a boundary group, automatic site-wide push
    installation, and allowed connection fallback to NTLM. Also, we need to make sure
    the **HTTPS Only** option for communication security is not enabled. We have enforced
    all these options during the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attacker sends a new device registration request to the MP followed by
    a heartbeat **Data Discovery Record** (**DDR**) saying that the client is not
    installed on the machine with a listener. The site server tries to install the
    client using the client push installation accounts and eventually its machine
    account. This attack is a part of **SharpSCCM** as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On the client, the attack looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Step-by-step successful coercion attack](image/B18964_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Step-by-step successful coercion attack
  prefs: []
  type: TYPE_NORMAL
- en: 'On the controlled machine, we captured both NTLM responses for the client push
    installation account and the MP computer account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Captured NTLM responses](image/B18964_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Captured NTLM responses
  prefs: []
  type: TYPE_NORMAL
- en: 'The administrator will detect such an attack because the IP address of our
    controlled machine will appear in the console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Captured machine IP address appears in the console](image/B18964_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Captured machine IP address appears in the console
  prefs: []
  type: TYPE_NORMAL
- en: If we have administrative privileges on the MP, we can use the **--as-admin**
    option to perform cleanup for us.
  prefs: []
  type: TYPE_NORMAL
- en: Credential harvesting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will focus on three credential types here – device collection variables,
    task sequence variables, and NAA credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is device collection? In simple words, it is a group of devices. There
    are some pre-defined groups, but we can also create our own. In the case of collection,
    we may add variables for specific purposes. Then, these variables can be used
    by task sequences. An adversary can extract them as well. First of all, let us
    add a collection variable. These are in **Assets and Compliance** | **Device Collections**
    | **Choose your collection** | **Properties**. The screenshot of my example is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Device collection variable](image/B18964_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Device collection variable
  prefs: []
  type: TYPE_NORMAL
- en: 'We have discussed task sequences and NAA before. **SharpSCCM** can pull this
    information locally or remotely. Using WMI, the adversary queries blobs from different
    classes (**CCM_CollectionVariable**, **CCM_TaskSequence**, and **CCM_NetworkAccessAccount**)
    of the **root\ccm\policy\Machine\ActualConfig** WMI namespace. Another way is
    to extract blobs from the **Common Information Model** (**CIM**) store. To get
    clear-text credentials, local administrator privileges are required because NAA
    credentials are protected with a DPAPI master key. Lastly, the remote option will
    request a machine policy from the MP via HTTP and decrypt secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the last command execution is in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Credential harvesting](image/B18964_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Credential harvesting
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Another way to obtain NAA depending on the **Machine Account Quota** (**MAQ**)
    value was shown by *http418* in his blog post at – [https://http418infosec.com/offensive-sccm-summary#Credential_Access_%E2%80%93_NAA](https://http418infosec.com/offensive-sccm-summary#Credential_Access_%E2%80%93_NAA).
  prefs: []
  type: TYPE_NORMAL
- en: In our next section, we will focus on ways to perform lateral movement based
    only on SCCM infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Lateral movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCCM by design is an excellent software for lateral movement. Agents are installed
    throughout the environment; highly privileged accounts are used to perform administrative
    tasks. Also, it is a good opportunity to blend in legitimate traffic and activities.
    We will start our discussion about lateral movement by extending coercion authentication
    to relay attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Client push authentication relay attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This attack is very similar to the one we did in the *Privilege escalation*
    section previously. The only difference is that this time, we would like to relay
    the captured NTLM response to another machine. (Just a reminder: the relay requires
    signing to be disabled). On the client side, the attack is exactly the same. On
    our listening machine, we start **ntlmrelayx**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After enforcing the client push installation, we relayed it to the Exchange
    server and dumped SAM hashes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Successful NTLM relay attack](image/B18964_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Successful NTLM relay attack
  prefs: []
  type: TYPE_NORMAL
- en: If the client push installation account has not been defined, then by default,
    the SCCM server’s machine account will be used to push clients. Obviously, this
    computer account has to be in the local **Administrators** group for every computer.
    In this scenario, the attack will be the same as previously; the only difference
    is the account that will be used for the relay.
  prefs: []
  type: TYPE_NORMAL
- en: Site takeover
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two site takeover techniques. Unfortunately, we will not be able to
    replicate them in our lab because SQL Server and the SMS provider role are installed
    on the primary site server.
  prefs: []
  type: TYPE_NORMAL
- en: The first technique is based on the fact that the computer account of the primary
    site server should be in a local **Administrators** group for SQL Server and MP
    servers. Then, an adversary coerces NTLM authentication from the primary site
    server and relays it to SQL Server. Next, it is possible to grant a **Full Administrator**
    SCCM role using SQL queries; the **sccmhunter**[15] tool can also do this for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is well-described in the *SCCM Site Takeover via Automatic Client
    Push Installation* blog post by *Mayyhem*: [https://posts.specterops.io/sccm-site-takeover-via-automatic-client-push-installation-f567ec80d5b1](https://posts.specterops.io/sccm-site-takeover-via-automatic-client-push-installation-f567ec80d5b1).'
  prefs: []
  type: TYPE_NORMAL
- en: The second technique leverages the **AdminService** API for SCCM site takeover.
    This API is hosted by an SMS provider. Each provider has a local group called
    **SMS Admins**. By default, the primary site server computer account is a member
    of this group. Now, the takeover attack will be the same as the preceding one.
    Coerce authentication via any method you like, capture and relay the primary site
    computer account NTLM response to the **AdminService** API hosted on the SMS provider,
    and add a user as **Full Administrator**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The original research by *Garrett Foster* can be found here: [https://posts.specterops.io/site-takeover-via-sccms-adminservice-api-d932e22b2bf](https://posts.specterops.io/site-takeover-via-sccms-adminservice-api-d932e22b2bf).'
  prefs: []
  type: TYPE_NORMAL
- en: Both techniques work after default installation and require only network connectivity
    and standard user credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Abuse of Microsoft SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the site takeover, or if an adversary obtained access to the Microsoft
    SQL Server that is used by the primary site, new venues are opened. First of all,
    it is possible to decrypt SCCM users’ credentials that are stored in the **SC_UserAccount**
    table. In our case, I will run the query using the SQL Server Management Studio.
    The query is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, I will utilize the **SCCMDecryptPoc**[16] tool by *XPN*. The result of
    the decryption is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Decrypted password of the sccm_cli_push account](image/B18964_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Decrypted password of the sccm_cli_push account
  prefs: []
  type: TYPE_NORMAL
- en: Another information-gathering activity is to dump tables related to task sequences
    and look for credentials. The output will be obfuscated, but the **DeObfuscateSecretString**
    tool in the **SharpSCCM** repository by *Mayyhem* will be able to help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, there is a stored procedure called **sp_CP_GenerateCCRByName** that
    can be used to force client push installation and the MP machine account to authenticate
    to the **ADMIN$** share on the machine of our choice. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a forced authentication attempt, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Forced authentication as a result of stored procedure execution](image/B18964_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Forced authentication as a result of stored procedure execution
  prefs: []
  type: TYPE_NORMAL
- en: Realistically, these post-exploitation actions are not required, as all of these
    actions were shown in earlier stages. The idea was to emphasize the fact that
    the primary site SQL Server also needs to be well hardened and maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the last scenario for lateral movement. It can also be treated as a
    persistence technique. A common scenario is to deploy malicious applications throughout
    the environment or on specific targets. However, we will try another scenario.
    The application installation from the controlled UNC path is triggered, so we
    can capture the domain administrator NTLM response.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The original research by *Mayyhem* can be found here: [https://posts.specterops.io/relaying-ntlm-authentication-from-sccm-clients-7dccb8f92867](https://posts.specterops.io/relaying-ntlm-authentication-from-sccm-clients-7dccb8f92867).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I will grant the **vinegrep** user **Full Administrator** rights; however,
    just **Application Administrator** should be enough. New permissions can be verified
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the command execution is next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – New permissions were applied](image/B18964_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – New permissions were applied
  prefs: []
  type: TYPE_NORMAL
- en: 'Our plan is to find an active device with a client installed where the primary
    user is **Administrator**. We will extract the resource ID for the next step.
    The following commands will provide the required information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the commands’ execution is in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – The WIN10 machine is our target device](image/B18964_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – The WIN10 machine is our target device
  prefs: []
  type: TYPE_NORMAL
- en: 'The attack consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new device collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a target machine to this collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an application with a UNC path to the attacker’s machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Task the target device from the collection to install the new application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following command will automate the preceding steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The attack execution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Successful attack execution](image/B18964_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Successful attack execution
  prefs: []
  type: TYPE_NORMAL
- en: 'After some time, we captured the NTLM response, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Successful relay to Exchange server](image/B18964_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Successful relay to Exchange server
  prefs: []
  type: TYPE_NORMAL
- en: This attack may also be used against a lot of users. If required, the computer
    account can also be forced to authenticate with the **--run-as-system** flag.
    The last section will explain defensive recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Defensive recommendations are a part of the great **SharpSCCM** wiki. Here,
    we will cover the ones that are most effective but also easy to implement. I will
    not repeat things such as install updates, ensure that privileged accounts use
    strong passwords, audit activities, enforce signing if possible, and so on. Let’s
    look at some defensive recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: To prevent coercion, NTLM fallback should be disabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable NAAs in the domain and use enhanced HTTP instead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the **Software Update** functionality to install clients instead of Automatic
    site-wide client push installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean task sequences and device collection variables from sensitive data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For PXE, set a strong password for media and disable **F8 Debugging**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check service accounts to ensure the least privileges principle is applied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not run the web client service to avoid HTTP coercion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable multi-factor authentication for SMS provider calls[17]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require **Extended Protection for Authentication** (**EPA**) on the site database
    to avoid relays to MS SQL Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three recommendations will significantly decrease your risk of being
    compromised. There is also a guide on how to use SCCM as a hunting tool for malicious
    activity[18].
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered techniques and attacks on IT administration software. We
    have briefly discussed ways to compromise WSUS and the available tooling for such
    adversary activity. Furthermore, we had a deep dive into the SCCM ecosystem and
    saw in practice how misconfiguration can lead to the complete overtake of the
    environment. Later, in the *Defensive recommendations* section, I stressed the
    three most important recommendations to improve the SCCM security posture.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this entire book should demonstrate how complex Windows-based infrastructure
    is, and how many hidden parts it has. Clearly, new vulnerabilities and attack
    vectors will appear regularly, but there are enough security mechanisms to make
    the life of an adversary much harder.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PyWSUS**: [https://github.com/GoSecure/pywsus](https://github.com/GoSecure/pywsus)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**bettercap**: [https://github.com/bettercap/bettercap](https://github.com/bettercap/bettercap)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'WSUS Attacks: [https://www.gosecure.net/blog/2020/09/03/wsus-attacks-part-1-introducing-pywsus/](https://www.gosecure.net/blog/2020/09/03/wsus-attacks-part-1-introducing-pywsus/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**WSuspicious**: [https://github.com/GoSecure/WSuspicious](https://github.com/GoSecure/WSuspicious)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy WSUS: [https://learn.microsoft.com/en-us/windows-server/administration/windows-server-update-services/deploy/deploy-windows-server-update-services](https://learn.microsoft.com/en-us/windows-server/administration/windows-server-update-services/deploy/deploy-windows-server-update-services)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'WSUS Group Policy Settings to Deploy Updates: [https://woshub.com/group-policy-settings-to-deploy-updates-using-wsus/](https://woshub.com/group-policy-settings-to-deploy-updates-using-wsus/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SharpWSUS**: [https://github.com/nettitude/SharpWSUS](https://github.com/nettitude/SharpWSUS)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**WSUSpendu**: [https://github.com/alex-dengx/WSUSpendu](https://github.com/alex-dengx/WSUSpendu)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**PSExec**: [https://learn.microsoft.com/en-us/sysinternals/downloads/psexec](https://learn.microsoft.com/en-us/sysinternals/downloads/psexec)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*The Hacker Recipes* website: [https://www.thehacker.recipes/ad/movement/sccm-mecm](https://www.thehacker.recipes/ad/movement/sccm-mecm)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**PXEThief**: [https://github.com/MWR-CyberSec/PXEThief](https://github.com/MWR-CyberSec/PXEThief)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Christopher Panayi, *Pulling Passwords out of Configuration* *Manager*: [https://media.defcon.org/DEF%20CON%2030/DEF%20CON%2030%20presentations/Christopher%20Panayi%20-%20Pulling%20Passwords%20out%20of%20Configuration%20Manager%20Practical%20Attacks%20against%20Microsofts%20Endpoint%20Management%20Software.pdf](https://media.defcon.org/DEF%20CON%2030/DEF%20CON%2030%20presentations/Christopher%20Panayi%20-%20Pulling%20Passwords%20out%20of%20Configuration%20Manager%20Practical%20Attacks%20against%20Microsofts%20Endpoint%20Management%20Software.pdf)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SharpSCCM**: [https://github.com/Mayyhem/SharpSCCM/](https://github.com/Mayyhem/SharpSCCM/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CMLoot**: [https://github.com/1njected/CMLoot](https://github.com/1njected/CMLoot)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **sccmhunter** tool: [https://github.com/garrettfoster13/sccmhunter#mssql](https://github.com/garrettfoster13/sccmhunter#mssql)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **sccmdecryptpoc** tool: [https://gist.github.com/xpn/5f497d2725a041922     c427c3aaa3b37d1](https://gist.github.com/xpn/5f497d2725a041922c427c3aaa3b37d1)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable MFA for SMS Provider calls: [https://learn.microsoft.com/en-us/troubleshoot/mem/configmgr/setup-migrate-backup-recovery/enable-mfa-for-sms-provider-calls](https://learn.microsoft.com/en-us/troubleshoot/mem/configmgr/setup-migrate-backup-recovery/enable-mfa-for-sms-provider-calls)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'SCCM for DFIR: [https://informationonsecurity.blogspot.com/2015/11/microsofts-accidental-enterprise-dfir.xhtml](https://informationonsecurity.blogspot.com/2015/11/microsofts-accidental-enterprise-dfir.xhtml)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These aids for further study will let you dive deeper into the attacks covered
    in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gabriel Prud’homme, *SCCM Exploitation: The First Cred Is the Deepest* *II*:
    [https://www.youtube.com/watch?v=W9PC9erm_pI](https://www.youtube.com/watch?v=W9PC9erm_pI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Chris Thompson, *SharpSCCM Demos at 2023 Black Hat USA* *Arsenal*: [https://www.youtube.com/watch?v=uyI5rgR0D-s](https://www.youtube.com/watch?v=uyI5rgR0D-s)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Christopher Panayi, *Identifying and retrieving credentials from SCCM/MECM
    Task* *Sequences*: [https://www.mwrcybersec.com/research_items/identifying-and-retrieving-credentials-from-sccm-mecm-task-sequences](https://www.mwrcybersec.com/research_items/identifying-and-retrieving-credentials-from-sccm-mecm-task-sequences)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP418InfoSec, *Offensive SCCM* *Summary*: [https://http418infosec.com/offensive-sccm-summary](https://http418infosec.com/offensive-sccm-summary)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
