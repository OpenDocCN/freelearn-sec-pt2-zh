- en: '*Chapter 3*: I Love My Bits – Lab Setup'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been mostly configuring the connectivity of the network. Now,
    we'll take it to the next level. In this chapter, we are going to configure a
    simple **program** and use the software installed on the Windows 7 **virtual machine**
    (**VM**) to physically change the **I/O** on the PLC. This will pass through the
    VM interface, through the virtual switch, to the physical adapter. Then, it will
    pass to a *physically* managed switch and out to the PLC. This chapter will expand
    on the lab that we started to set up earlier in [*Chapter 2*](B16321_02_Epub_AM.xhtml#_idTextAnchor027),
    *Routing the Hardware*. We will go through a demo approach using **Koyo Click
    PLC** and **Human Machine Interfaces** (**HMI**) I and connect it to physical
    I/O to learn how to turn lights on and off, utilizing both the **graphical user
    interface** and **scripting**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing and downloading our first program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding and wiring the I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Koyo Click** software installed on our Windows 7 machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Koyo Click** hardware power supply and PLC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A physical network switch to route traffic between PLC and ESXi.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Selector Switch Station Box to toggle power on/off to I/O.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Industrial Signal Tower Lamp to display visual feedback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A voltmeter to test continuity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 14-gauge wire to wire both the Selector Switch Station Box and signal tower
    lamp to the PLC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wire cutters and wire strippers to treat and prep the wire for installation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screwdrivers (Phillips head and flathead) to open and close the terminal set
    screws.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can view this chapter''s code in action here: [https://bit.ly/3v5w61B](https://bit.ly/3v5w61B)'
  prefs: []
  type: TYPE_NORMAL
- en: Writing and downloading our first program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now comes the exciting part – writing our *hello world* program for the automation
    space. We are going to cover how to build a simple ladder logic program that will
    energize or de-energize a coil. This will help us establish a deeper understanding
    of how the Koyo Click software works. This is important as every PLC, SCADA, and
    **Distributed Control System** (**DCS**) follows the same set of guidelines and
    standards. Speaking of standards, one in particular that you should get familiar
    with is *IEC 61131-3*, as it helps define five core programming languages, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ladder diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional block diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instruction list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequential function chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to software programming languages where the core fundamentals are common
    across all languages, only the syntax changes for the most part and with these
    five languages, three are graphical-based and two are text-based. The **CLICK
    programming software** utilizes a **ladder diagram** as the core programming language,
    also known as **ladder logic**, and it is the most common language that you will
    encounter in the process automation space. It mimics an electric circuit, allowing
    the inputs on the left-hand side to drive the outputs on the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we are going to open our Koyo Click software on our Windows 7 machine,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Koyo Click software'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.01_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – Koyo Click software
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **File** option from the menu bar and then select **New Project…**,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – New Project…'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.02_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – New Project…
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will be presented with a dialog box, as shown in the following screenshot.
    You need to double-click on the **Start a new project** icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Start a new project'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.03_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Start a new project
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we''ll be taken to the **Select a CPU Module** window, as shown
    in the following screenshot. We will be using in the lab that was recommended
    in the previous chapter. Now, you might be asking yourself, "*Wait, wasn''t there
    an easier way to do this?*", and you would be correct. In the previous chapter,
    we simply connected to the PLC and the software took care of auto detection and
    selecting the correct CPU for us. However, I want to show you that there is more
    than one way to establish a project. With that said, you will see a screen similar
    to the following, where you need to select **C0-10ARE-D**, which we discussed
    in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Selecting a lab CPU'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.04_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Selecting a lab CPU
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can see detailed information about the CPU. We have eight AC
    inputs and six relay outputs, along with information about power consumption.
    Now, click **OK** to continue with the CPU selection process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click it, you will be brought back to the programming screen, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Main program'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.05_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Main program
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start adding instructions to the ladder, we want to configure a few
    small details. Select the **Setup** menu option and then click **System Configuration**,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – System Configuration…'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.06_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – System Configuration…
  prefs: []
  type: TYPE_NORMAL
- en: 'This will take us to the following screen, which shows a graphical layout of
    our **PLC chassis**. Here, you can see that the CPU from our previous selection
    is shown and that a warning is displayed, indicating that we don''t have enough
    power to supply to the CPU. This is simply because we have yet to set the **Power
    Supply Unit** (**PSU**) on this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – System Configuration window'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.07_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – System Configuration window
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Select** button in the first column (the **P/S** column), as shown
    in the preceding screenshot. You will be presented with the option to select your
    power supply, as shown in the following screenshot. Select the power supply that
    you''ve purchased and installed in your lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The Select a Power Supply window'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.08_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – The Select a Power Supply window
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the screen that we saw previously for the CPU, we can see more details
    in regard to the **Power Supply** we purchased, such as the input and output voltages
    and max power generated. Go ahead and click **OK** to select and apply the power
    supply to the chassis overview. You should now see an image that represents the
    power supply connected to the CPU. You will see that the warning has disappeared
    as the power is more than sufficient to power the CPU:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Updated System Configuration window'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.09_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – Updated System Configuration window
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click **OK** and jump right into the program. We want to create a simple
    program that allows us to push a button and turn on a light. However, before we
    start, I want to provide a very quick crash course on certain terminology:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ladder** and **rungs**: A ladder diagram is used to represent a control program
    in an electrical wiring framework. The power sources are the *vertical lines*
    (ladder), while the control circuits are the *horizontal lines* (rungs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instruction list**: This is a list of graphical controls that are used to
    design the circuit for your program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contacts**: A contact is a graphical representation of a binary selector,
    similar to that of a wall switch, for a lack of a better definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NO**/**NC**: **Normally Open** and **Normally Closed** are terms for contacts
    where we want to control the *state* of the I/O. A normally open contact means
    that a circuit is running when the contact is open, and the inverse is true for
    normally closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have a better understanding of the layout and terminology, the
    next step would be to drag a NO **Contact** to rung number one. Then, we should
    proceed to select the address by clicking the **Address** button on the right-hand
    side, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Inserting a contact'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.10_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Inserting a contact
  prefs: []
  type: TYPE_NORMAL
- en: 'A dialog box will appear, allowing us to select the address intended from the
    list of addresses available on Koyo Click. In the following screenshot, we can
    see the list options, including **Address**, **Datatype**, **Nickname**, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Address Picker'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.11_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – Address Picker
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click the first address; that is, **X001**. This will populate your
    address choice, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Address selected'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.12_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Address selected
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have clicked the **OK** button, you should see that you now have a
    contact input with an address of **X001** on rung 1, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Contact X001'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.13_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – Contact X001
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that we have an input, we are going to want an output. Grab the **Out**
    function under the **Coil** section of the **Instruction List** menu on the right-hand
    side of the user interface, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Coil output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.14_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Coil output
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag the **Out** function to the **( NOP )** location at the end of rung 1,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.15_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – Output
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the function locks in, it will create a dialog box, asking the programmer
    to configure **Bit Memory** addressing, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Coil address'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.16_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – Coil address
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the memory address picker icon; you will be presented with an **Address
    Picker** dialog box, similar to the once we encountered during the NO input contact
    step. The following screenshot shows that the address picker automatically displays
    the real-world list of output addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Address Picker'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.17_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – Address Picker
  prefs: []
  type: TYPE_NORMAL
- en: 'Pick **Y001** as the output address for the coil that we placed onto rung 1
    and select **OK**. As shown in the following screenshot, it has auto-populated
    the **Bit Memory Address1:** selection. You should see a green check mark next
    to the address to indicate that the address is a valid memory location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Bit Memory Address'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.18_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Bit Memory Address
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **OK** to proceed and add the **Coil** to the output location, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Coil output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.19_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – Coil output
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are wondering why we chose **X001** and **Y001** as the input and output
    addresses, look at the front of your CLICK PLC. On the terminal strip, find where
    the **pin outs** are labeled **X1** and **Y1**. These addresses relate directly
    to these I/O terminals, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Terminal pins'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.20_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 – Terminal pins
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add an **END** function to tell the program that we have concluded
    all operations. From the **Instruction List** menu, under the **Program Control**
    heading, select and drag the **END** function to the **( NOP )** location at the
    end of rung 2, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Adding an END function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.21_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.21 – Adding an END function
  prefs: []
  type: TYPE_NORMAL
- en: 'After we add the **END** function, we want to check for syntax errors. It is
    a good idea to get into the habit of running **syntax checks** periodically so
    that you can catch any mistakes before they turn into major issues, as you develop
    more complex programs in the future. On the **Program** tab, double-click the
    **Syntax Check** option located in the **Ladder Program** folder, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – Syntax Check'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.22_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.22 – Syntax Check
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **output window**, you should see the outcome of the syntax check. If
    you have followed along closely, you should have similar results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – Syntax Check'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.23_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.23 – Syntax Check
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there are **0 error(s)** and **0 warning(s)**. At this point,
    you should save the program and then write the project to your PLC. To write the
    project to your PLC, select the **Write Project into PLC…** option from the **PLC**
    menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Write Project into PLC…'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.24_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.24 – Write Project into PLC…
  prefs: []
  type: TYPE_NORMAL
- en: 'Once done, you will be presented with a dialog box that gives you a brief overview
    of a **diff** function, which we will use on the current PLC project versus the
    project that you will be writing into the PLC, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Write Project into PLC window'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.25_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.25 – Write Project into PLC window
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes smoothly, you should see a **Transfer completed** dialog
    box, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 – Transfer completed'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.26_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.26 – Transfer completed
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will be asked to change the **PLC Modes** setting from **STOP** to
    **RUN**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27 – PLC Modes window'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.27_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.27 – PLC Modes window
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything worked correctly, you should see the following indicators:'
  prefs: []
  type: TYPE_NORMAL
- en: A green **RUN** status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No **PLC Error** message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **END** function highlighted in blue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output Window** – **Write Project to into PLC…**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Output Window** – **Transfer completed**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These indicators are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.28 – Running indicators'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.28_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.28 – Running indicators
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create a simple program using inputs and
    outputs consisting of a Normally Open contact and a coil. We performed a syntax
    check and wrote the project to our PLC. This allowed us to get a deeper grasp
    of how the programming software works and some hands-on experience with creating
    and writing a project. These are the fundamentals to learn and are the building
    blocks of any automation and control-based project. In the next section, we are
    going to simulate a signal on our input to cause our program to produce an output.
    Then, we are going to energize the coil that we created in our program.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding and wiring the I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we created a simple *hello world* program and wrote
    it to our PLC. In this section, we are going to simulate a signal on our input
    contact to energize our coil on the output. We will be diving deeper into the
    functionality of the CLICK programming software, familiarizing ourselves with
    the data view, and **overriding** inputs to generate an energized coil. To do
    this, we are going to utilize a tool called **Data View**, which allows us to
    read and write values to the memory address that we selected for the Normally
    Open contact we created in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, open the **Data View** window from the **Monitor** menu, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.29 – Data View selection'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.29_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.29 – Data View selection
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be presented with a blank table, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.30 – Data View tool'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.30_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.30 – Data View tool
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to select the **Address** cell at row **001** and then click
    the **Edit** button in the left-hand corner of the dialog box, which will allow
    you to select the address picker we used previously. Here, we assigned addresses
    to both the **contact input** and the **coil output**. Next, you will see the
    auto populated address space starting at **X001**, and in the first memory address,
    you should see a **Yes** in the **Used** column for **X001**. This is feedback,
    telling us that we have used **X001** in our program. This can be seen in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.31 – Address Picker'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.31_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.31 – Address Picker
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and select **X001** and press the **OK** button. This will then populate
    the **No.** **001** row of our **Data View** tool. You will see the settings for
    **Nickname**, if you gave it one previously, our **Current Value**, our **New
    Value**, **Write** (for feedback), **Viewing Format**, and any address comments
    that you might have added. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.32 – X001 address selected'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.32_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.32 – X001 address selected
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try selecting the **ON** button in the **New Value** column. An icon will
    appear in the **Write** column, which allows you to write the input value to the
    PLC. Double-click the icon to see what happens. Nothing should have happened at
    this point. The icon does write the value to PLC''s memory space, but the pin
    I/O is primary and nothing has changed on the physical input on the PLC, so nothing
    has changed. It is because of this behavior that we must enable **override**.
    From the dialog box, we will see a selection for **View Override**. You need to
    enable this option. After doing so, you will see that a new column has been added
    next to the **Write** icon. An **OVR** button has been added, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.33 – Override'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.33_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.33 – Override
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click the **OVR** button, which will enable the **Override** functionality
    for this I/O. The CLICK programming software turns on an **Override** indicator
    on the primary window, and also highlights the **OVR** button in yellow in the
    **Data View** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.34 – Override engaged'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.34_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.34 – Override engaged
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try and rerun the operation we ran previously, select the **ON** button
    in the **New Value** column, and double-click the **Write** icon. You should hear
    the coil energizing on the PLC and visually see the lights enabled on it, as well
    as the programming software showing **X001** highlighted, along with **Y001**,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.35 – Energized coil'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.35_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.35 – Energized coil
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not see the highlighted input and output, as shown here, make sure
    to check that you have **Status Monitor** selected. It can be found in the **Monitor**
    menu, after selecting **Status Monitor**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.36 – Status Monitor'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.36_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.36 – Status Monitor
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and double-click the **OFF** button in the **New Value** column, as
    shown in the following screenshot. You should notice that by double-clicking the
    button, we save a step; this is simply to show that there are multiple ways to
    quickly override the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.37 – Input is off'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.37_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.37 – Input is off
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, everything we have done has been software focused. Now, we are going
    to use the **Selector Switch Station Box**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.38 – Selector Switch Station Box'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.38_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.38 – Selector Switch Station Box
  prefs: []
  type: TYPE_NORMAL
- en: This switch, or a switch very similar to it, can be purchased on Amazon. We
    will be using the momentary *push button*, which is the green button, and wiring
    this to the **X001** input contact that we programmed and addressed in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your *Phillips* screwdriver to remove the four faceplate screws and the
    faceplate. When you open the **Station Box**, you will see the three switch blocks,
    each of which will contain four terminals. Focusing on the momentary switch, the
    two sets of terminals correlate to the action of the switch. Since I want power
    to pass through the switch when I press the button, I will use the bottom set
    of terminals. You can test the terminals by utilizing your **voltmeter** and test
    the continuity on either side of the block. Press the switch to see if the terminals
    create a short, causing your voltmeter to beep. I feel that checking continuity
    with my voltmeter over hundreds of projects has been the primary use case for
    it, which now that I think about it is kind of sad, since the voltmeter has so
    many other functions and features. Once you feel comfortable that you are using
    the correct terminals, cut and strip two wires. Screw an end from each wire to
    either side of the terminal. Then, on one side, extend to the power source and
    on the other side, extend this wire to the **X1** I/O on the **PLC**. This can
    be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.39 – Wire diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.39_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.39 – Wire diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'On the I/O terminal, you will notice **C1** and **C2**, which stand for **Common
    1** and **Common 2**. Wire Common 1 to ground. If all the **wiring** is done correctly,
    pressing the momentary switch will cause the coil to energize and you should see
    a red light, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.40 – Physical wire'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.40_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.40 – Physical wire
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a push button controlling the input of **X001** and we also have
    visual feedback on **Y001**. Next, we are going to wire up the output to our **Industrial
    Signal Tower Lamp**, which will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.41 – Industrial Signal Tower Lamp'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.41_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.41 – Industrial Signal Tower Lamp
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Wiring the output will require you to make a change to your program by duplicating
    rung 1 and creating a rung per light in your Signal Tower Lamp. I am using a four-light
    system, with *red*, *yellow*, *green*, and *blue* lights.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how to connect your Signal Tower Lamp to the output
    channels. Because I am using a four-light system, I will run red to **Y001**,
    yellow to **Y002**, green to **Y003**, and blue to **Y004**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.42 – Output wiring to the Tower Lamp'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.42_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.42 – Output wiring to the Tower Lamp
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should have wired up your outputs and changed your program
    to accommodate the new light output, as well as written the changes to the CLICK
    PLC. This process is the same as what we did the previous section, when we wrote
    the single rung program to the PLC. Your program should look as follows, in that
    you should have four distinct new inputs from **X001** – **X004** and four distinct
    outputs from **Y001** – **Y004**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.43 – Program with four-light wiring'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.43_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.43 – Program with four-light wiring
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to override input values to simulate a signal
    on the output side of the controller. We wired up a pushbutton switch to X001
    and wired up a Signal Tower Lamp four-light system to Y001, Y002, Y003, and Y004\.
    We now have a fully functional physical demo for our lab, and have also had a
    little exposure to the trials and tribulations that automation engineers go through
    when they approach a new project with new components. In the next section, we
    are going to learn how to interact with our lab via scripts that we will write
    and launch.
  prefs: []
  type: TYPE_NORMAL
- en: Testing control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to override the inputs and simulate
    a signal on contact X001, which allowed us to trigger an output on the Y001 coil.
    We then proceeded to wire up the input side of the PLC to a switch and reproduce
    the same results, but this time with a physical input. Finally, we wired up our
    four-light Signal Tower. In this section, we are going to test the **Signal Tower**
    both from the **DataView** and from our SCADA VM by utilizing the **MBtget** tool
    that we installed in [*Chapter 2*](B16321_02_Epub_AM.xhtml#_idTextAnchor027),
    *Route the Hardware*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **DataView1**, as we did in the previous section; as a refresher, check
    the following screenshot, where you will find it in the **Monitor** | **Data View**
    section:![Figure 3.44 – Data View
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_3.44_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.44 – Data View
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will bring up the window for Data View. As we did previously, add the new
    contacts you created in the previous section. These contacts are **X002**, **X003**,
    and **X004** in the address space. Make sure to enable the **View Override** option.
    If everything has worked correctly, your screen should look similar to the following:![Figure
    3.45 – Data View
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_3.45_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.45 – Data View
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, go ahead and toggle the inputs and move through each value, ensuring that
    your physical light tower turns on the matching light that you have configured
    for your output. You will notice that you have visual feedback on the face of
    the CLICK, much like you do inside your software, as shown here:![Figure 3.46
    – Overriding the lamp
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_3.46_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 3.46 – Overriding the lamp
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have all the lights working, open the **SCADA VM** that we created
    it in previously. Go to **Navigator** > **Virtual Machines** > **SCADA** to find
    it, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.47 – SCADA VM'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.47_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.47 – SCADA VM
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the console for SCADA and open your **Terminal** program. Use the **mbtget
    -h** command to see details about the **mbtget** tool, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.48 – mbtget tool'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.48_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.48 – mbtget tool
  prefs: []
  type: TYPE_NORMAL
- en: A good moment to explain mbtget
  prefs: []
  type: TYPE_NORMAL
- en: 'mbtget is a tool written in Perl that allows us to directly interact with Koyo
    Click via *ModbusTCP* over port **502**. For more details go to the following
    link and view the project on GitHub: [https://github.com/sourceperl/mbtget](https://github.com/sourceperl/mbtget).'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK; let''s go back to our normal programming. Now that we have mbtget sitting
    on our SCADA machine, we can check the bits on the four coils that we configured
    in the previous section by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: mbtget -r1 -a 0 192.168.1.20
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the arguments that are included in the command. We will cover
    the **modbus** protocol in greater detail in [*Chapter 8*](B16321_08_Epub_AM.xhtml#_idTextAnchor097)*,
    Protocols 202*. For now, we need to know what the memory address is for the coils
    that we are using, and also whether we want to read or write to that memory address:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-r1**: Reads bit(s) at function **1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-a**: Address at **0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PLC address is **192.168.1.20**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have cleared all the overrides that have been set in the programming
    software, you should see the following output, where the value at address **1**
    is **0**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.49 – Address 0 read output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.49_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.49 – Address 0 read output
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, write a value to the coil using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: mbtget -w5 1 -a 0 192.168.1.20
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the arguments that are included in the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-w5**: Writes a function value of **1** for on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-a**: Address **0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PLC address is **192.168.1.20**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If everything worked, you should have turned on the first/top light in your
    signal tower and have the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.50 – Writing the value to the coil'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.50_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.50 – Writing the value to the coil
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to confirm the output using **mbtget**, run the read coil command again:'
  prefs: []
  type: TYPE_NORMAL
- en: mbtget -r1 -a 0 192.168.1.20
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the arguments in the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-r1**: Reads bit(s) function **1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-a**: Address **0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PLC address is **192.168.1.20**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If everything is working, you should the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.51 – Reading coil address 0'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.51_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.51 – Reading coil address 0
  prefs: []
  type: TYPE_NORMAL
- en: You should have seen that the address value has changed to **1** and that the
    light is on. Go ahead and test the remaining lights in your tower by going through
    the same steps we went through previously. Write a **1** to your next few addresses,
    read the coil bits, and make sure the output is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed how easy it was to randomly set a bit with a simple command-line
    function, and you might be wondering where the security features are. Why could
    you override a coil without having to enter a *key* or *password*? Is this truly
    how insecure the *industrial environment* is? Well, I have to say *yes and no*.
    Yes, the industrial environment has traditionally been this insecure, but there
    has been great progress in opening awareness to the security issues that reside
    in the field. The *vendors* have listened and started to embed security layers
    into their systems. However, this doesn't mean that customers have upgraded their
    legacy systems to the new technology. Now, for those of you who are curious, who
    might have realized what is going on… yes, yes, you caught me – the reason why
    this works is because we have the overrides enabled on the programming software
    still. Remove the overrides and try testing mbtget again by forcing a coil. What
    were the results? You shouldn't see an outcome – nothing should happen. This is
    because we have told the PLC to only react to localized input.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built an introductory functional lab, where we can develop
    logic inside our PLC and connect to real-world inputs and outputs to see how things
    react to certain environmental tests. This helps relay a fundamental understanding
    of how industrial systems operate and work. Building on these core concepts allows
    us to extend our lab to more complex scenarios. We used the **engineering software**
    to force inputs, and then we replicated the same behavior remotely with mbtget
    to convey how easy it is to change a simple on/off input on a controller.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine what other industry processes operate this way, such as opening and
    closing valves on a water plant or opening a valve on a lye, also known as a sodium
    hydroxide, holding tank, and allowing it to flow into water treatment units, similar
    to the *Florida City Water Supply hack* on February 5, 2021\. However, the Florida
    City Water Supply hack is more complex as it involved changing a concentration
    amount on an operator screen. This change runs through a recipe logic block and
    ultimately tells the valve to stay open longer until the concentration level matches
    the new setpoint change. This is an example of how real-world impacts can occur
    from making small changes to logic. This is a double-edged sword, and a cautionary
    tale when it comes to pentesting engagements. It's quite easy to break and cause
    downtime in a customer's process, resulting in heavy production and revenue losses.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be taking a break from building our ICS lab and
    discussing **Open Source Intelligence** (**OSINT**) gathering, since this is a
    critical step in any pentesting engagement.
  prefs: []
  type: TYPE_NORMAL
