<html><head></head><body>
		<div id="_idContainer222">
			<h1 id="_idParaDest-62"><em class="italic"><a id="_idTextAnchor063"/>Chapter 6</em>: Packet Deep Dive</h1>
			<p>Previously, we discussed what <strong class="bold">Switch Port Analyzer</strong> (<strong class="bold">SPAN</strong>)/<strong class="bold">Mirror</strong> and <strong class="bold">Test Access Point</strong> (<strong class="bold">TAP</strong>) are and how to configure a mirror port in our lab environment using Wireshark, Tcpdump, and TShark to listen to the traffic communicating between the engineering software and our Koyo Click <strong class="bold">Programmable Logic Controller</strong> (<strong class="bold">PLC</strong>). We also reviewed how <strong class="bold">intrusion detection system</strong> (<strong class="bold">IDS</strong>) technology utilizes SPAN/Mirror and TAP to perform <strong class="bold">deep packet i</strong><strong class="bold">nspection</strong> on industrial network traffic. Additionally, we touched on some methods and tactics that we can use to bypass IDS monitoring during a pentesting engagement.</p>
			<p>In this chapter, we are going to take a closer look at the communication pathway between the software and the PLC, and we will be using Wireshark in greater detail to analyze these packets. During a pentest, capturing and analyzing traffic is crucial for success, as mentioned in the last chapter. Additionally, an understanding of the environment, assets, activities, and protocols is paramount. This chapter will help guide you through capturing traffic and analyzing that traffic to pull out key information that will guarantee success in the future.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>How are packets formed?</li>
				<li>Capturing packets on the wire</li>
				<li>Analyzing packets for key information</li>
			</ul>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor064"/>Technical requirements</h1>
			<p>For this chapter, you will need the following:</p>
			<ul>
				<li>Wireshark/TShark installed from the following link: <a href="https://www.wireshark.org/#download">https://www.wireshark.org/#download</a>.</li>
				<li>Netresec Industrial PCAPs; download the three PCAP files from the following link, as we will be using them in the <em class="italic">Analyzing packets for key information</em> section: <a href="https://www.netresec.com/?page=PCAP4SICS">https://www.netresec.com/?page=PCAP4SICS</a>.</li>
			</ul>
			<p><a id="_idTextAnchor065"/>You can view this chapter's code in action here: <a href="https://bit.ly/3veDRlW">https://bit.ly/3veDRlW</a></p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor066"/>How are packets formed?</h1>
			<p>To fully comprehend what is <a id="_idIndexMarker308"/>occurring in the network, let's do a quick packet 101. <strong class="bold">Packets</strong> are byte-sized relays of data, and they carry information between a source asset and a destination asset. Focusing on the traffic that powers the internet, protocols <a id="_idIndexMarker309"/>such as <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>) and <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) make <a id="_idIndexMarker310"/>up the well-known acronym <strong class="bold">TCP/IP</strong>. These relays of data route through a series of switches and are reassembled, allowing us to send emails, navigate websites, download patches for software, stream movies, monitor elevators, manage trains, manufacture products, produce energy, and many more interesting and dynamic things.</p>
			<p>To fully understand packets and how they work, it is important to understand how they flow through the <a id="_idIndexMarker311"/>layers of the <strong class="bold">Open Systems Interconnection</strong> (<strong class="bold">OSI</strong>) model. In the mid-80s, the OSI model was created and adopted to set a standard for describing the seven layers that systems use in order to communicate over a network. Starting at the topmost layer and working down, you can view the list of layers in the following diagram:</p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/Figure_6.01_B16321.jpg" alt="Figure 6.1 – The OSI model&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – The OSI model</p>
			<p>Now, referencing the <a id="_idIndexMarker312"/>preceding diagram, we are going to break down each layer and quickly explain what each layer does and how it contributes to the OSI model.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor067"/>The Application layer</h2>
			<p>This layer <a id="_idIndexMarker313"/>provides a user with <a id="_idIndexMarker314"/>direct interaction, such as web browsers that host SCADA interfaces, <strong class="bold">Human Machine Interfaces</strong> (<strong class="bold">HMIs</strong>), data <a id="_idIndexMarker315"/>historians, and any other such software that can be directly viewed and controlled. Protocols associated with this layer include <strong class="source-inline">http</strong>, <strong class="source-inline">ftp</strong>, and <strong class="source-inline">dns</strong>.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor068"/>The Presentation layer</h2>
			<p>This is the <a id="_idIndexMarker316"/>layer where <a id="_idIndexMarker317"/>data encoding, encryption, and decryption occur to allow data to pass from the Session layer to the Application layer.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor069"/>The Session layer</h2>
			<p>When devices <a id="_idIndexMarker318"/>such as RTUs, PLCs, flow computers, controllers, <strong class="bold">Gas Chromatographs</strong> (<strong class="bold">GCs</strong>), servers, and other such <a id="_idIndexMarker319"/>equipment need to <a id="_idIndexMarker320"/>communicate with one another, <em class="italic">communication pipes</em> are created. These are called sessions. This layer oversees the opening of these pipes, ensuring they work and remain open while data passes through them.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor070"/>The Transport layer</h2>
			<p>In the Transport layer, negotiations <a id="_idIndexMarker321"/>regarding speed, data rate, flow control, and error checking occur. This is the <a id="_idIndexMarker322"/>layer in which TCP and UDP function.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor071"/>The Network layer</h2>
			<p>This is the layer where <a id="_idIndexMarker323"/>routing occurs by utilizing IP addresses to ship data <a id="_idIndexMarker324"/>between the source and destination nodes on the network.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor072"/>The Data Link layer</h2>
			<p>There are two parts <a id="_idIndexMarker325"/>associated <a id="_idIndexMarker326"/>with <a id="_idIndexMarker327"/>this layer, <strong class="bold">Logical Link Control</strong> (<strong class="bold">LLC</strong>) and <strong class="bold">Media Access Control</strong> (<strong class="bold">MAC</strong>), which <a id="_idIndexMarker328"/>provide direct node-to-node communication. Network switches typically operate on this layer.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor073"/>The Physical layer</h2>
			<p>Once again, we <a id="_idIndexMarker329"/>are back in the <a id="_idIndexMarker330"/>user's hands. This layer refers to a physical connection, such as a cable plugged into the Ethernet port or a wireless card that is communicating on the network.</p>
			<p>Now that we have a general idea of the OSI model and how every layer relates to each other, we are going to run through a general overview of how an IPv4 packet is structured. </p>
			<p class="callout-heading">Note </p>
			<p class="callout">If you have stuck with me this far, you are probably asking yourself "Why all this basic stuff?" To be honest, when I started this book, I had the idea of writing an introduction to industrial pentesting that would focus on people coming from the IT security side. As of late, I have had many conversations with friends who work in the automation space and are looking to break into security. Therefore, I am trying to close the gap for individuals who might be reading this from two uniquely different backgrounds. I wanted to provide a reference book to friends of mine who would be able to skim over the parts that they are comfortable with and get a general overview of topics that they will be seeing for the first time. </p>
			<p>Okay, with that disclaimer out of the way, let's now take a look at the structure of a packet. The following is the <a id="_idIndexMarker331"/>general design of an IPv4 packet:</p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/Figure_6.02_B16321.jpg" alt="Figure 6.2 – An IPv4 packet&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – An IPv4 packet</p>
			<p>The header fields outlined in the preceding diagram are detailed as follows:</p>
			<ul>
				<li><strong class="bold">Version</strong>: This is always set to the number <strong class="source-inline">4</strong> as this is the latest IP version.</li>
				<li><strong class="bold">IP Header Length</strong> (<strong class="bold">IHL</strong>): This <a id="_idIndexMarker332"/>field conveys the length of the IP header in 32-bit increments.</li>
				<li><strong class="bold">Type of Service</strong> (<strong class="bold">ToS</strong>): This field is used to determine the quality or priority of the service.</li>
				<li><strong class="bold">Total Length</strong>: This field indicates the entire size of the packet in bytes.</li>
				<li><strong class="bold">Identification</strong>: This is used by the network to reassemble any fragmented packets.</li>
				<li><strong class="bold">Flags</strong>: This field is used to <a id="_idIndexMarker333"/>control fragmentation. It consists of 3 bits; the first being a 0, the second is a don't fragment bit, and the third is a more fragment bit.</li>
				<li><strong class="bold">Fragment Offset</strong>: This field establishes the position of the fragment for the packet.</li>
				<li><strong class="bold">Time To Live</strong> (<strong class="bold">TTL</strong>): This field is <a id="_idIndexMarker334"/>used as a loop prevention mechanism.</li>
				<li><strong class="bold">Protocol</strong>: This field is used to communicate what the protocol is. TCP has a value of <strong class="source-inline">6</strong> and UDP has a value of <strong class="source-inline">17</strong>.</li>
				<li><strong class="bold">Header Checksum</strong>: This field is used to store a checksum and is used for error handling.</li>
				<li><strong class="bold">Source Address</strong>: This field contains the source IP address.</li>
				<li><strong class="bold">Destination Address</strong>: This field contains the destination IP address.</li>
				<li><strong class="bold">Options</strong>: This field is normally not used.</li>
				<li><strong class="bold">Data</strong>: This includes information that is to be sent to the node.</li>
			</ul>
			<p>That was a quick overview of how an IPv4 packet is structured, and there is much more information that can be researched on this specific topic. I simply wanted to give you a little bit of background so that when we start looking at frames and packets inside of Wireshark, you will understand the references and why details and artifacts are displayed the way they are. A direct link to Wireshark's reference material can be found at https://www.wireshark.org/docs/wsug_html_chunked/ChUsePacketDetailsPaneSection.html.</p>
			<p>Here, I took a screenshot of Wireshark's packet details pane:</p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/Figure_6.03_B16321.jpg" alt="Figure 6.3 – The packet details pane&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – The packet details pane</p>
			<p>Now, on your system, try expanding the <a id="_idIndexMarker335"/>elements as they relate to the layers that we discussed previously. The first element that I will expand is the <strong class="source-inline">Ethernet II</strong> element, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/Figure_6.04_B16321.jpg" alt="Figure 6.4 – The Ethernet layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – The Ethernet layer</p>
			<p>This <strong class="source-inline">Ethernet II</strong> element directly <a id="_idIndexMarker336"/>relates to the <strong class="bold">Data Link layer</strong>, as discussed earlier. We can see that we have a <strong class="source-inline">Destination</strong> MAC address, a <strong class="source-inline">Source</strong> MAC address, <strong class="source-inline">Type</strong>, and <strong class="source-inline">Padding</strong>. The <strong class="bold">Organizational Unique Identifier</strong> (<strong class="bold">OUI</strong>), which is <a id="_idIndexMarker337"/>associated with the first 3 bytes of the MAC address, is very interesting. Here, you can see that Wireshark is resolving the OUI and that both VMware and our KoyoElec PLC have been resolved. In the following screenshot, we can see the Network layer:</p>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="image/Figure_6.05_B16321.jpg" alt="Figure 6.5 – The Network layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – The Network layer</p>
			<p>In this layer, we can directly map the IPv4 layout, which we overviewed earlier, to a packet that we captured moving between the Koyo Click PLC and the engineering software. The following is a list of the <a id="_idIndexMarker338"/>important fields in the Network layer:</p>
			<ul>
				<li><strong class="source-inline">Version: 4</strong></li>
				<li><strong class="source-inline">IHL: 20 bytes</strong></li>
				<li><strong class="source-inline">TOS: 0x00</strong></li>
				<li><strong class="source-inline">Total Length: 43</strong></li>
				<li><strong class="source-inline">Identification: 0x61ff</strong></li>
				<li><strong class="source-inline">Flags: 0x00</strong></li>
				<li><strong class="source-inline">Fragment Offset: 0</strong></li>
				<li><strong class="source-inline">Time to Live: 128</strong></li>
				<li><strong class="source-inline">Protocol: UDP (17) </strong></li>
				<li><strong class="source-inline">Header Checksum: 0x5354</strong></li>
				<li><strong class="source-inline">Source Address: 192.168.3.10</strong></li>
				<li><strong class="source-inline">Destination Address: 192.168.1.20</strong></li>
			</ul>
			<p>The next layer that we will review is the Transport layer. This is where applications use ports to communicate with each other. The <a id="_idIndexMarker339"/>following screenshot shows the Transport layer:</p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/Figure_6.06_B16321.jpg" alt="Figure 6.6 – The Transport layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – The Transport layer</p>
			<p>Here, we can see that <strong class="source-inline">Source Port: 54782</strong> and <strong class="source-inline">Destination Port: 25425</strong> are being used. Finally, we will take a look at the <strong class="source-inline">Data</strong> element/the Application layer of the Wireshark packet details pane. This is where the application data can be found. Typically, this is the <a id="_idIndexMarker340"/>most interesting section of the packet as things such as credentials can be found here in plaintext. The following screenshot represents the Application layer:</p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/Figure_6.07_B16321.jpg" alt="Figure 6.7 – The Application layer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – The Application layer</p>
			<p>The data here has not been parsed out into nice elements as I am not running a dedicated Koyo Click protocol dissector. We can take a look at the ASCII translation in the packet bytes pane as follows:</p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/Figure_6.08_B16321.jpg" alt="Figure 6.8 – The packet bytes pane&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – The packet bytes pane</p>
			<p>As you can see in the preceding screenshot, <strong class="source-inline">4b 4f 50</strong> starts the data section off. If you look at the ASCII conversion, you will see that it has the characters of <strong class="source-inline">KOP</strong>. This is a direct marker for the Koyo Click protocol.</p>
			<p>In this section, we <a id="_idIndexMarker341"/>covered the OSI model and the packet structure. Then, we tied the theory of the OSI model and the packet structure back to our real-time captured traffic. This helped us to visualize and connect the dots between theories and practical applications. In the next section, we will take a closer look at running commands in our engineering software, capturing traffic with Wireshark through our mirror port, and then <a id="_idIndexMarker342"/>analyzing the <strong class="bold">KOP protocol</strong> in greater detail. This analysis will help us in our future pentests, as we can start to build and sharpen our skills around analyzing unknown protocols – something that you will most definitely encounter during your career.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor074"/>Capturing packets on the wire</h1>
			<p>In the last section, we <a id="_idIndexMarker343"/>discussed what the OSI model is and the layers that <a id="_idIndexMarker344"/>formulate and structure the model. We reviewed how a packet is constructed and then directly compared the packet structure to the communication exchange we see between the PLC and engineering software. In this section, we are going to dive deeper into Wireshark and focus on some key features that I personally use during my engagements to capture traffic. As a recap, in <a href="B16321_05_Epub_AM.xhtml#_idTextAnchor049"><em class="italic">Chapter 5</em></a><em class="italic">, Span Me If You Can, w</em>e used Wireshark to verify that our mirror port was set up and configured correctly.</p>
			<p>Now, I want to preface this upcoming content with two very distinct points, and give shout-outs to fellow security experts in the industry, as well as to content that I have personally leveraged in the past to hone my skills:</p>
			<ul>
				<li><a href="https://www.chappell-university.com/">https://www.chappell-university.com/</a></li>
				<li><a href="https://tryhackme.com/room/wireshark">https://tryhackme.com/room/wireshark</a></li>
			</ul>
			<p>Both these resources provide different types of content. I have <em class="italic">Wireshark 101</em> by <em class="italic">Laura Chappell</em> as part of my core library, and the first link is a shout-out to Laura for doing such a great job at providing content that is focused on utilizing Wireshark for network troubleshooting and security forensics. The second link is to a room dedicated to Wireshark. If you want to have hands-on interactive training, then I strongly recommend this website and room. The site is a great resource for anyone in the red teaming space to utilize. I personally spend my time on this site brushing up on new tactics that have been shared by the community.</p>
			<p>With that said, let's <a id="_idIndexMarker345"/>jump right into it. We will open Wireshark and select our <a id="_idIndexMarker346"/>capture interface. You should see a list of possible interfaces that you can utilize to capture traffic, similar to the following screenshot:</p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/Figure_6.09_B16321.jpg" alt="Figure 6.9 – The Capture interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – The Capture interface</p>
			<p>In the preceding screenshot, I want to zero in on the <strong class="bold">…using this filter</strong> input field. This allows us to provide laser focus when capturing traffic. If we are specifically looking for unique hosts, a range of hosts, protocols, or anything specific regarding the engagement, this is where we can define a capture filter.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A <strong class="bold">capture filter</strong> should <a id="_idIndexMarker347"/>not be confused with a <strong class="bold">display filter</strong>. A capture filter drops or ignores packets that fall outside of the filter, whereas a display filter <a id="_idIndexMarker348"/>simply hides the packets but allows you to maintain them for deeper analysis. During an engagement, if you don't have a clear idea of what you are capturing, I would recommend capturing everything and using display filters afterward.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor075"/>Capture filters</h2>
			<p>Some <a id="_idIndexMarker349"/>simple examples of <a id="_idIndexMarker350"/>capture filters that can be used in the field include the following:</p>
			<ul>
				<li><strong class="source-inline">host</strong>: This will capture all communication to and from a given host. In this example, all communication originating from or designated to <strong class="source-inline">192.168.120</strong> will be captured and all other traffic will be dropped. This comes in handy if you have been limited to a very focused pentest from your customer. You can use the following command to achieve this:<p class="source-code"><strong class="bold">host 192.168.1.20</strong></p></li>
				<li><strong class="source-inline">net</strong>: This will capture all communication to and from a given subnet. This example only captures traffic with a destination to or from the <strong class="source-inline">192.168.1.0/24</strong> subnet. Once again, this is very handy if your customers do not want you to engage with other networks or communication. This is commonly <a id="_idIndexMarker351"/>referred to as a <strong class="bold">gray box or white box</strong> penetration test, which <a id="_idIndexMarker352"/>we will go into more detail about in the next chapter. You can use the following command:<p class="source-code"><strong class="bold">net 192.168.1.0/24</strong></p></li>
				<li><strong class="source-inline">port</strong>: This will capture all communication to and from a given port. In this example, we will <a id="_idIndexMarker353"/>focus on <strong class="bold">Modbus</strong> traffic communicating over port <strong class="source-inline">502</strong>. This comes in very handy when we want to go after a specific protocol related to a specific process inside the facility. You can refer to the following command:<p class="source-code"><strong class="bold">port 502</strong></p></li>
			</ul>
			<p>There are far more complex methods that can be used for filtering if you want to specifically <a id="_idIndexMarker354"/>track <strong class="bold">File Transfer Protocol</strong> (<strong class="bold">FTP</strong>), <strong class="bold">Network File System</strong> (<strong class="bold">NFS</strong>), SMB file <a id="_idIndexMarker355"/>movements, TELNET, or basic HTTP authentication. Using capture filters allows you to focus on key packets and keep things to a manageable size once your goal has been achieved. Everything you can do with capture filters you can also do with display filters. The most notable difference between capture and display filters will be the file size after using the filters for the same duration of capture time. In very noisy networks, it only takes a few seconds to capture millions of packets. It is possible to capture gigabytes of data before ever achieving your goal. Although the trade-off is that yes, you do have small and easy-to-manage packet captures after using capture filters, you do lose out on all that other traffic that could be hidden nuggets of gold. Moving forward, and for the remainder of this book, we <a id="_idIndexMarker356"/>will focus on display filters. This is because they will <a id="_idIndexMarker357"/>capture all packets, which will allow us to perform further forensics on the interesting attack vectors that could go unnoticed if a capture filter is being used instead because capture filters drop all packets but what the filter is set to.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor076"/>Display filters</h2>
			<p>Stop your current <a id="_idIndexMarker358"/>Wireshark capture, remove your capture filter, and select your interface once again. This <a id="_idIndexMarker359"/>will allow us to record every packet on the network. Now you should be able to view your Koyo Click PLC or whatever PLC you have set up in your lab to communicate with the engineering software. Here is an example screenshot of what you should see:</p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/Figure_6.10_B16321.jpg" alt="Figure 6.10 – Communication between the PLC and the workstation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – Communication between the PLC and the workstation</p>
			<p>I want to focus on the display filter input bar, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/Figure_6.11_B16321.jpg" alt="Figure 6.11 – Display filter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – Display filter</p>
			<p>This is where the analysis happens. For this specific section, I am going to discuss key filters that are used during pentesting. For this, I feel the best approach is to narrow in on certain protocols that are uniquely interesting to gain a foothold inside the <strong class="bold">Operational Technology</strong> (<strong class="bold">OT</strong>) environment. Inside the network, there are and will be many ICS-centric protocols, such as Modbus, Ethernet/IP, DNP3, S7, HART, and more. These will be covered in greater detail in the next chapter. However, in this section, I want to focus on some low-hanging fruit. These specific protocols have helped me the most in terms of carrying the <a id="_idIndexMarker360"/>most information on the network and when <a id="_idIndexMarker361"/>pivoting through a customer's infrastructure.</p>
			<h3>HTTP</h3>
			<p>Many things can be <a id="_idIndexMarker362"/>gleaned from the HTTP protocol, hence the reason why <a id="_idIndexMarker363"/>everyone in security is pushing for the implementation of HTTPS. The fortunate part for us is that in the ICS space, there are SCADA systems, HMIs, RTUs, PLCs, flow computers, and GCs that use legacy web interfaces to serve up information and/or run control. There are so many gold nuggets of data that are wrapped inside the HTTP protocol. You can extract credentials using basic authentication, you can find more sophisticated forms of obfuscation and filter for digest at <strong class="source-inline">http.authorization</strong>, you can capture request methods, you can capture asset details and devices communicating across internal networks, and more. The following is a list of important HTTP filters:</p>
			<ul>
				<li><strong class="bold">http.authbasic</strong>: This filter is <a id="_idIndexMarker364"/>used to find basic authentication, which <a id="_idIndexMarker365"/>we can easily extract and decode as the username and password are Base64-encoded. Depending on the security maturity of a company, these pieces of data are still readily found on older systems that haven't been updated. </li>
				<li><strong class="bold">http.authorization</strong>: This is a filter <a id="_idIndexMarker366"/>that can be used to extract <a id="_idIndexMarker367"/>authorization and digest access for negotiated credentials and then use a tool such as <em class="italic">hashcat</em> or <em class="italic">John the Ripper</em> to <strong class="bold">brute force</strong> the credentials. We will cover brute-forcing passwords in the next chapter.</li>
				<li><strong class="bold">http.request.method</strong>: This filter <a id="_idIndexMarker368"/>provides a lot of <a id="_idIndexMarker369"/>interesting information as it will extract all the <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong> methods. This can be very useful if you are <a id="_idIndexMarker370"/>looking for <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) calls and commands.<p class="callout-heading">Story time</p><p class="callout">I have been involved in several airport-related engagements. This particular airport engagement happened to have a flat network on their public Wi-Fi; well, they didn't think it was flat, but for all intents and purposes, it was a flat network. By simply sniffing the Wi-Fi broadcast and multicast traffic, it was very apparent that they hadn't changed the default credentials in their gateway. By setting up a remote sniffing session, I was able to capture all the communication on the internal side of their network through their public Wi-Fi. As it turns out, they hadn't enabled HTTPS on their <strong class="bold">SIEM</strong>, and they were using one account to log and access all traffic going to and from their SIEM of choice. Once I had the credentials that were being passed encoded in Base64, a little decode and logging enabled me to see the entire infrastructure of the airport, including all the terminals, baggage handling, HVAC, people movers, lights, and more.</p></li>
			</ul>
			<p>Understanding that <a id="_idIndexMarker371"/>HTTP contains a plethora of data, it is my first go-to filter <a id="_idIndexMarker372"/>when using Wireshark. I want to see all the low-hanging fruit that it contains and document it for later exploitation. Next, I will utilize FTP as a display filter and take a deep dive into the data to find interesting information.</p>
			<h3>FTP</h3>
			<p>As one of the most <a id="_idIndexMarker373"/>explored protocols in the ICS network, FTP has almost been a<a id="_idTextAnchor077"/>busively overused by automation vendors. The fact that FTP's entire premise is <a id="_idIndexMarker374"/>around moving files using a non-encrypted protocol means all of the things moved via this protocol are vulnerable to exploitation. We have vendors that use FTP to update firmware or programmable logic. Imagine that you had the ability to forge a plaintext file that could easily trigger a downgrade from a stable firmware version to a previous vulnerable firmware version. This can occur all because metaphorically speaking they didn't mention that they were trying to put a Band-Aid on the flu. </p>
			<p>Go ahead and try using the following display filters in Wireshark:</p>
			<ul>
				<li><strong class="source-inline">ftp.request.command == "USER"</strong></li>
				<li><strong class="source-inline">ftp.request.command == "PASS"</strong></li>
			</ul>
			<p>This filter goes straight for the user and passwords that have attempted to access the box and failed. It finds brute-forced attempts during login with a tool such as <em class="italic">Hydra</em> or if we are really lucky, the true credentials of a valid user.</p>
			<p><strong class="source-inline">ftp-data</strong>: Using <a id="_idIndexMarker375"/>this filter, you <a id="_idIndexMarker376"/>can parse out files that have been transmitted between devices over the FTP protocol. This can be useful if you find a data share that contains a list of files that have sensitive information inside them.</p>
			<p>Knowing that FTP is still <a id="_idIndexMarker377"/>widely used in the industrial world makes it a key <a id="_idIndexMarker378"/>factor to analyze when capturing packets on the network. There are credentials and files that can be extracted and reused for potential deeper exploitations into the network. Who knows, this in itself could validate a completed pentest, as there are some companies that have lingering intellectual property residing inside an internal file share. Keeping with the theme of file shares, we are going to analyze NFS next.</p>
			<h3>NFS</h3>
			<p>This is another dynamic protocol <a id="_idIndexMarker379"/>that is utilized in the program delivery <a id="_idIndexMarker380"/>side of industrial automation. Writing a simple Python script that can be anonymously authenticated to a remote share and dropping a corrupted firmware version via NFS could essentially impact and <em class="italic">brick</em> all controllers in an accessible subnet. Disclaimer: <em class="italic">with great power comes great responsibility</em>. Even though it is possible, this is never an acceptable tactic during a pentest. I am simply calling out the fundamental flaws of some of the legacy implementations that still exist in the industry and that have been globally adopted. Therefore, I don't focus solely on NFS as it is a firmware delivery method but also because of <strong class="source-inline">root_squashing</strong>. In some instances, you can find that <strong class="source-inline">root_squashing</strong> is turned off and the ability to quickly find this allows us to rapidly escalate privileges on a machine in the OT environment. Here are some of the display filters that can be used to narrow down on a system that might be exposed:</p>
			<ul>
				<li><strong class="bold">nfs.readdir.entry</strong>: This filter <a id="_idIndexMarker381"/>helps pull out communications that will <a id="_idIndexMarker382"/>show us if there are file shares that are open to exploitation. Inside the protocol, in plaintext, there will be files listed that will help us map out what assets there are and possibly a point of entry into the system.</li>
				<li><strong class="bold">nfs.access_rights</strong>: This next filter <a id="_idIndexMarker383"/>allows us to weed out the <a id="_idIndexMarker384"/>locked-down file shares. If we run this filter, it will extract the packets that are related to privileged access such as <strong class="source-inline">READ, LOOKUP, MODIFY, </strong><strong class="source-inline">EXTEND, and DELETE</strong>. These are very important to identify as they will save you time and headache during a pentest.</li>
			</ul>
			<p>In this section, we discussed capturing network traffic with Wireshark. We narrowed down what capture filters are, the benefits of using them, and how to use them during a pentest engagement. We also discussed the differences between capture filters and display filters. We then <a id="_idIndexMarker385"/>dove deeper into some key display filters that can help you to find valuable information inside a network and can be enabled for asset identification, possible exploitation avenues, privilege escalation avenues, and possible pivot points into the network. In the next section, we will put what we have just discussed into practice by using display filters on packet captures to analyze traffic for key information.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor078"/>Analyzing packets for key information</h1>
			<p>In the previous section, part of <a id="_idIndexMarker386"/>our discussion was about utilizing display filters for protocols such as <strong class="source-inline">http</strong>, <strong class="source-inline">ftp</strong>, and <strong class="source-inline">nfs</strong>. Understanding how to apply these filters and extracting key data is crucial to a successful pentesting engagement. Additionally, understanding who is communicating with who on the network and quickly applying a filter to hone in on critical details are an absolute must and require ongoing practice to get good at performing traffic analysis. In the previous section, I supplied some links, and I just want to reiterate that you need to practice honing your skills. People refer to pentesters as cyber Samurai or digital ninjas: they practice daily in order to strengthen and master their skills. In this section, we will perform analyses on multiple packet captures to demonstrate how to approach a network packet capture file and extract the key information required to drive success to our assessment.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">One of the key elements of success for a pentester is not just the ability to compromise a system but to clearly and concisely communicate where the security gaps are and how you leveraged them to gain access to an environment. This is the first time that I am really talking about this topic. But now that we are diving into traffic analysis and will come across lots of interesting information, I can't stress enough that you need to keep a running notepad to identify the assets seen, information captured, pivot points that can be exploited, and credentials sniffed on the wire. All of this information needs to be documented and made easily referenceable for when the time comes to turn in your final report. You will thank me that you started taking notes and documenting the trove of interesting information that you discovered on the network.</p>
			<p>Now, if you glance <a id="_idIndexMarker387"/>back at the <em class="italic">Technical requirements</em> section, I posted a link to 4SICS Geek Lounge packet captures. As a refresher, here is the link again: <a href="https://www.netresec.com/?page=PCAP4SICS">https://www.netresec.com/?page=PCAP4SICS</a>.</p>
			<p>Now you can utilize any PCAPs that you have. These are freely open to the industry and help us really put the power of display filters to work.</p>
			<p>Go ahead and open the PCAP file labeled <strong class="source-inline">4SICS-GeekLounge-151021.pcap</strong> with Wireshark. You should see roughly 1.2 million packets loaded into Wireshark. I want you to go ahead and try the first display filter that was covered in the last section. With the <strong class="source-inline">http.authbasic</strong> filter, you should see an output that is similar to the following screenshot:</p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/Figure_6.12_B16321.jpg" alt="Figure 6.12 – The http.authbasic display filter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – The http.authbasic display filter</p>
			<p>If you notice the <strong class="source-inline">Authorization: Basic YWRtaW46YWRtaW4=</strong> field and value, you can utilize your command-line skills by running the following command:</p>
			<p class="source-code"> echo YWRtaW46YWRtaW4= | base64 -d </p>
			<p>On your <a id="_idIndexMarker388"/>command line, you will use the <strong class="source-inline">admin:admin</strong> credentials.</p>
			<p>If you are more of a tool type of person, then I strongly recommend <em class="italic">CyberChef</em>, which can be found at <a href="https://gchq.github.io/CyberChef/">https://gchq.github.io/CyberChef/</a>. </p>
			<p>CyberChef is a great graphical tool to perform encoding/decoding, cryptography analyses and conversions, and more. As a very quick rundown, you have inputs, outputs, and recipes. In our case, we want to place the basic hash into the <strong class="bold">Input</strong> section and apply the <strong class="bold">From Base64</strong> recipe. In the <strong class="bold">Output</strong> section, you will see the <strong class="source-inline">admin:admin</strong> credentials, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="image/Figure_6.13_B16321.jpg" alt="Figure 6.13 – CyberChef From Base64&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13 – CyberChef From Base64</p>
			<p>I personally like <a id="_idIndexMarker389"/>using the Base64 from the command line for decoding and other such tasks and only relying on CyberChef for more intense items such as encoding <em class="italic">Node.js reverse shells</em> in Base64 and injecting them into a malformed web portal, but I digress. Now looking through that filter, you should notice a second set of credentials; can you find them?</p>
			<p>The second set of credentials will be <strong class="source-inline">Authorization: Basic cm9vdDpyb290</strong>, which is <strong class="source-inline">root:root</strong>.</p>
			<p>Now, remember when I suggested taking notes earlier? Let's review what we have found by running a simple display filter. We have the following:</p>
			<ul>
				<li>Asset <strong class="source-inline">192.168.2.42</strong> is communicating over HTTP to port <strong class="source-inline">80</strong> on <strong class="source-inline">192.168.88.25</strong> using <strong class="source-inline">admin:admin</strong> as its credentials. </li>
				<li>Asset <strong class="source-inline">192.168.2.88</strong> is communicating over HTTP to port <strong class="source-inline">80</strong> on <strong class="source-inline">192.168.88.49</strong> using <strong class="source-inline">root:root</strong> as its credentials, and the user agent indicates that it is possibly Ubuntu Linux x86_64 running Firefox for access.</li>
			</ul>
			<p>All this information is very useful. We know that there are two distinct subnets and that <strong class="source-inline">.2</strong> can communicate with <strong class="source-inline">.88</strong>. We know that there are two web servers running and that they are using an old authentication method, which leads me to believe that these two servers are vulnerable to further exploitation. Similarly to the following diagram, I also tend to draw the connections for a visual reference later:</p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/Figure_6.14_B16321.jpg" alt="Figure 6.14 – A visual aid of the HTTP access&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14 – A visual aid of the HTTP access</p>
			<p>Next, we want to <a id="_idIndexMarker390"/>change up the filter from <strong class="source-inline">http.authbasic</strong> to <strong class="source-inline">http.request.method</strong>, and you should see around 5,800 packets with <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, and <strong class="source-inline">OPTIONS</strong> requests. From here, I can quickly scan the <strong class="bold">Info</strong> column for anything super interesting, such as filenames, <strong class="source-inline">DELETE</strong>, <strong class="source-inline">PUT</strong>, or <strong class="source-inline">POST</strong> requests, authorization attempts, or basically anything that can provide more details and insights into the network. As we can see <strong class="source-inline">POST</strong> requests, I am going to adjust my filter to focus on just the <strong class="source-inline">POST</strong> requests, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/Figure_6.15_B16321.jpg" alt="Figure 6.15 – The POST requests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15 – The POST requests</p>
			<p>Now, we have <a id="_idIndexMarker391"/>managed to filter 5,800 packets down to 15. Take a look at the <strong class="bold">Info</strong> column, as shown in the following screenshot, and check whether you can find anything that might be interesting:</p>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/Figure_6.16_B16321.jpg" alt="Figure 6.16 – The Info column&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16 – The Info column</p>
			<p>We can see from the filter that we have some interesting URLs that are being posted to:</p>
			<ul>
				<li><strong class="source-inline">/goform/svLogin</strong></li>
				<li><strong class="source-inline">/home.asp</strong></li>
				<li><strong class="source-inline">/view/</strong></li>
			</ul>
			<p>By clicking on the first <strong class="source-inline">/goform/svLogin</strong> <strong class="source-inline">POST</strong> request and navigating to the <strong class="source-inline">application/x-www-form-urlencoded</strong> section, we can see the form items being passed in plaintext, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer209" class="IMG---Figure">
					<img src="image/Figure_6.17_B16321.jpg" alt="Figure 6.17 – The /goform/svLogin POST request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17 – The /goform/svLogin POST request</p>
			<p>We have now found <a id="_idIndexMarker392"/>another set of <strong class="source-inline">root:dbps</strong> credentials. Jotting down this information, we can now add the following:</p>
			<ul>
				<li>Asset <strong class="source-inline">192.168.2.42</strong> is communicating over HTTP to port <strong class="source-inline">80</strong> on asset <strong class="source-inline">192.168.88.115</strong>, which happens to be a Digiboard device using the <strong class="source-inline">root:dbps</strong> credentials.</li>
			</ul>
			<p>The next packet would be the <strong class="source-inline">POST</strong> request for <strong class="source-inline">/home.asp</strong>. If we look at the packet dissection, we come across a very interesting find, that is, <strong class="bold">Cookie</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="image/Figure_6.18_B16321.jpg" alt="Figure 6.18 – The Cookie field&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.18 – The Cookie field</p>
			<p>Here, we can see another set of credentials:</p>
			<ul>
				<li><strong class="source-inline">AccountName508=admin</strong></li>
				<li><strong class="source-inline">Password508=0192023a7bbd73250516f069df18b500</strong></li>
			</ul>
			<p>This is very interesting as that password looks as though it is encrypted. What we can do is use a few different methods to determine what the encrypted type might be. I personally switch between <strong class="source-inline">hash-identifier</strong> and <strong class="source-inline">haiti</strong>. For this example, we will use <strong class="source-inline">hash-identifier</strong> and run the following command on our Kali instance, which we installed in <a href="B16321_01_Epub_AM.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a><em class="italic">, Using Virtualization:</em> </p>
			<p class="source-code">echo 0192023a7bbd73250516f069df18b500 | hash-identifier</p>
			<p>You should get a <a id="_idIndexMarker393"/>response that is similar to the following:</p>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="image/Figure_6.19_B16321.jpg" alt="Figure 6.19 – Hash ID&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19 – Hash ID</p>
			<p>Now that we know that this hash is possibly an MD5 hash, we can attempt to crack it using a number of different tools such as <em class="italic">hashcat</em> or <em class="italic">John the Ripper</em>. However, I am going to run over to <strong class="source-inline">crackstation.net</strong>, load in the hash, and quickly check whether it has been cracked already. Low and behold, it has, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="image/Figure_6.20_B16321.jpg" alt="Figure 6.20 – crackstation.net MD5&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.20 – crackstation.net MD5</p>
			<p>Now I am going to <a id="_idIndexMarker394"/>go through each of the requests and extract the hashes and check them in <strong class="source-inline">crackstation.net</strong>. You should find the following results:</p>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="image/Figure_6.21_B16321.jpg" alt="Figure 6.21 – CrackStation passwords found&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.21 – CrackStation passwords found</p>
			<p>The discovered credential pairs are as follows:</p>
			<ul>
				<li><strong class="source-inline">admin:admin123</strong></li>
				<li><strong class="source-inline">user:user123</strong></li>
				<li><strong class="source-inline">admin:123</strong></li>
				<li><strong class="source-inline">admin:ADMIN123</strong></li>
				<li><strong class="source-inline">root:root123</strong></li>
			</ul>
			<p>Now it should be noted <a id="_idIndexMarker395"/>that not all of these credentials work, and we need to take a deeper look into the communication between the devices to find which credentials are real and which ones are invalid. We can do this by highlighting one of the packets and right-clicking on the highlighted packet. Then, we can select <strong class="bold">Follow</strong> | <strong class="bold">HTTP Stream</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/Figure_6.22_B16321.jpg" alt="Figure 6.22 – Follow | HTTP Stream&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.22 – Follow | HTTP Stream</p>
			<p>This particular received packet has the following output:</p>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="image/Figure_6.23_B16321.jpg" alt="Figure 6.23 – HTTP 302 redirect&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.23 – HTTP 302 redirect</p>
			<p>Because we <a id="_idIndexMarker396"/>see an <strong class="source-inline">HTTP/1.0 302</strong> redirect, we can safely assume the credentials that were supplied were incorrect. If you keep analyzing the packets in this manner, you should see an <strong class="source-inline">HTTP/1.0 200 OK</strong> response, which indicates that the credentials are valid and that the user is authenticated inside the web portal:</p>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="image/Figure_6.24_B16321.jpg" alt="Figure 6.24 – HTTP 200 OK&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.24 – HTTP 200 OK</p>
			<p>Now, we should go <a id="_idIndexMarker397"/>back and update our diagram from earlier and make sure to update our notes. Here is what the new diagram will look like:</p>
			<div>
				<div id="_idContainer217" class="IMG---Figure">
					<img src="image/Figure_6.25_B16321.jpg" alt="Figure 6.25 – HTTP data detection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.25 – HTTP data detection</p>
			<p>Here, we have simply <a id="_idIndexMarker398"/>used two HTTP-specific filters, and we have already discovered valid credentials that will work on switch technology, allowing us to dive deeper into the network. There are far more extensive filters that can be used to parse out even larger swaths of information; I simply wanted to demonstrate how easy it is to obtain critical information in a very short period. In the last section, we will discuss the FTP protocol and display filters for this protocol. Using the same PCAP, update your display filter to simply find all of the FTP traffic, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="image/Figure_6.26_B16321.jpg" alt="Figure 6.26 – FTP traffic&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.26 – FTP traffic</p>
			<p>Selecting the <a id="_idIndexMarker399"/>top packet, which is <strong class="source-inline">No.</strong> <strong class="source-inline">480883</strong>, and looking at the packet information, we can quickly find very relevant and identifiable asset details, as shown here:</p>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="image/Figure_6.27_B16321.jpg" alt="Figure 6.27 – AXIS 206 Network Camera&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.27 – AXIS 206 Network Camera</p>
			<p>Here, we happened to find an AXIS Network Camera that is publishing an asset model number and version for the camera inside the packet. Now recall the chapter where we discussed open source intel; we should be able to open <a href="https://www.exploit-db.com/">https://www.exploit-db.com/</a> and type <strong class="source-inline">axis network camera</strong> into the search bar. You should get the following results:</p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="image/Figure_6.28_B16321.jpg" alt="Figure 6.28 – Exploit Database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.28 – Exploit Database</p>
			<p>Let's click on the very <a id="_idIndexMarker400"/>first listing we can see, <strong class="bold">Axis Network Camera - .srv to parhand Remote Code Execution (Metasploit)</strong>. After viewing the details of this listing, we find that there is a nice little Metasploit module that will allow us to run remote execution against this camera. Excellent! Let's add that to the diagram and documentation. With this new information, let's go back to our notes and determine what we have now found. Here is the newly updated diagram:</p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/Figure_6.29_B16321.jpg" alt="Figure 6.29 – The HTTP server to the AXIS Network Camera&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.29 – The HTTP server to the AXIS Network Camera</p>
			<p>Notice that by using the <a id="_idIndexMarker401"/>HTTP filter, we have discovered a web server on IP address <strong class="source-inline">192.168.88.49</strong> with the credentials of <strong class="source-inline">root:root</strong>. Now, after running the FTP display filter, we can see another device communicating with that previous asset. However, we now have more asset information to determine that the endpoint is a network camera, so we update our notes and jot down the vulnerability that we discovered. Open the next two PCAP files and run the same filters that we did on <strong class="source-inline">4SICS-GeekLounge-151021.pcap</strong> and make sure to record your findings.</p>
			<p>In this section, we really drilled down into display filters and the data that can be extracted. We used PCAPs that have been freely published on <a href="https://www.netresec.com/?page=PCAP4SICS">https://www.netresec.com/?page=PCAP4SICS</a>. We then proceeded to explore the data by utilizing various HTTP and FTP display filters. We were able to capture valid credentials that were being used on the network and identify some strategic vulnerable assets. This section helped us to understand why capturing and analyzing network traffic is vital to pentesting, as far more useful and critical data can be extracted from the wire.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor079"/>Summary</h1>
			<p>In this chapter, we looked at how packets are formed by reviewing the OSI model and understanding the various layers that exist in the model. We took this one step further by analyzing the structure of an IPv4 packet and performing a side-by-side comparison of this with a packet that we captured from our lab equipment. After providing a better understanding of what packets are and how they are constructed, we went on to use Wireshark to capture these packets. We made use of the mirror port that we created in the previous chapter, and we discussed the differences between capture filters and display filters.</p>
			<p>Finally, we downloaded some PCAPs from an open source ICS lab and we used Wireshark to analyze the traffic that we found in these packet captures. We leveraged display filters to narrow down key network data, such as valid credentials, operational web portals, and working network cameras. Understanding and practicing these techniques and methods will allow you to have very successful engagements in the future.</p>
			<p>In the next chapter, we will be taking everything that we have learned so far and utilizing it in a lab. We will discuss multiple topics such as enumeration, protocol deep diving, exploitation, and privilege escalation. These are all the key elements you need to drive home a successful pentest.</p>
		</div>
	</body></html>