- en: '*Chapter 6*: Packet Deep Dive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we discussed what **Switch Port Analyzer** (**SPAN**)/**Mirror**
    and **Test Access Point** (**TAP**) are and how to configure a mirror port in
    our lab environment using Wireshark, Tcpdump, and TShark to listen to the traffic
    communicating between the engineering software and our Koyo Click **Programmable
    Logic Controller** (**PLC**). We also reviewed how **intrusion detection system**
    (**IDS**) technology utilizes SPAN/Mirror and TAP to perform **deep packet i****nspection**
    on industrial network traffic. Additionally, we touched on some methods and tactics
    that we can use to bypass IDS monitoring during a pentesting engagement.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to take a closer look at the communication pathway
    between the software and the PLC, and we will be using Wireshark in greater detail
    to analyze these packets. During a pentest, capturing and analyzing traffic is
    crucial for success, as mentioned in the last chapter. Additionally, an understanding
    of the environment, assets, activities, and protocols is paramount. This chapter
    will help guide you through capturing traffic and analyzing that traffic to pull
    out key information that will guarantee success in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How are packets formed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing packets on the wire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing packets for key information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wireshark/TShark installed from the following link: [https://www.wireshark.org/#download](https://www.wireshark.org/#download).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Netresec Industrial PCAPs; download the three PCAP files from the following
    link, as we will be using them in the *Analyzing packets for key information*
    section: [https://www.netresec.com/?page=PCAP4SICS](https://www.netresec.com/?page=PCAP4SICS).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can view this chapter''s code in action here: [https://bit.ly/3veDRlW](https://bit.ly/3veDRlW)'
  prefs: []
  type: TYPE_NORMAL
- en: How are packets formed?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fully comprehend what is occurring in the network, let's do a quick packet
    101\. **Packets** are byte-sized relays of data, and they carry information between
    a source asset and a destination asset. Focusing on the traffic that powers the
    internet, protocols such as **Transmission Control Protocol** (**TCP**) and **Internet
    Protocol** (**IP**) make up the well-known acronym **TCP/IP**. These relays of
    data route through a series of switches and are reassembled, allowing us to send
    emails, navigate websites, download patches for software, stream movies, monitor
    elevators, manage trains, manufacture products, produce energy, and many more
    interesting and dynamic things.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fully understand packets and how they work, it is important to understand
    how they flow through the layers of the **Open Systems Interconnection** (**OSI**)
    model. In the mid-80s, the OSI model was created and adopted to set a standard
    for describing the seven layers that systems use in order to communicate over
    a network. Starting at the topmost layer and working down, you can view the list
    of layers in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The OSI model'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.01_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – The OSI model
  prefs: []
  type: TYPE_NORMAL
- en: Now, referencing the preceding diagram, we are going to break down each layer
    and quickly explain what each layer does and how it contributes to the OSI model.
  prefs: []
  type: TYPE_NORMAL
- en: The Application layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This layer provides a user with direct interaction, such as web browsers that
    host SCADA interfaces, **Human Machine Interfaces** (**HMIs**), data historians,
    and any other such software that can be directly viewed and controlled. Protocols
    associated with this layer include **http**, **ftp**, and **dns**.
  prefs: []
  type: TYPE_NORMAL
- en: The Presentation layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the layer where data encoding, encryption, and decryption occur to allow
    data to pass from the Session layer to the Application layer.
  prefs: []
  type: TYPE_NORMAL
- en: The Session layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When devices such as RTUs, PLCs, flow computers, controllers, **Gas Chromatographs**
    (**GCs**), servers, and other such equipment need to communicate with one another,
    *communication pipes* are created. These are called sessions. This layer oversees
    the opening of these pipes, ensuring they work and remain open while data passes
    through them.
  prefs: []
  type: TYPE_NORMAL
- en: The Transport layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Transport layer, negotiations regarding speed, data rate, flow control,
    and error checking occur. This is the layer in which TCP and UDP function.
  prefs: []
  type: TYPE_NORMAL
- en: The Network layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the layer where routing occurs by utilizing IP addresses to ship data
    between the source and destination nodes on the network.
  prefs: []
  type: TYPE_NORMAL
- en: The Data Link layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two parts associated with this layer, **Logical Link Control** (**LLC**)
    and **Media Access Control** (**MAC**), which provide direct node-to-node communication.
    Network switches typically operate on this layer.
  prefs: []
  type: TYPE_NORMAL
- en: The Physical layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, we are back in the user's hands. This layer refers to a physical
    connection, such as a cable plugged into the Ethernet port or a wireless card
    that is communicating on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a general idea of the OSI model and how every layer relates
    to each other, we are going to run through a general overview of how an IPv4 packet
    is structured.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you have stuck with me this far, you are probably asking yourself "Why all
    this basic stuff?" To be honest, when I started this book, I had the idea of writing
    an introduction to industrial pentesting that would focus on people coming from
    the IT security side. As of late, I have had many conversations with friends who
    work in the automation space and are looking to break into security. Therefore,
    I am trying to close the gap for individuals who might be reading this from two
    uniquely different backgrounds. I wanted to provide a reference book to friends
    of mine who would be able to skim over the parts that they are comfortable with
    and get a general overview of topics that they will be seeing for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, with that disclaimer out of the way, let''s now take a look at the structure
    of a packet. The following is the general design of an IPv4 packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – An IPv4 packet'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.02_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – An IPv4 packet
  prefs: []
  type: TYPE_NORMAL
- en: 'The header fields outlined in the preceding diagram are detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version**: This is always set to the number **4** as this is the latest IP
    version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IP Header Length** (**IHL**): This field conveys the length of the IP header
    in 32-bit increments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type of Service** (**ToS**): This field is used to determine the quality
    or priority of the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Total Length**: This field indicates the entire size of the packet in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identification**: This is used by the network to reassemble any fragmented
    packets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags**: This field is used to control fragmentation. It consists of 3 bits;
    the first being a 0, the second is a don''t fragment bit, and the third is a more
    fragment bit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragment Offset**: This field establishes the position of the fragment for
    the packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time To Live** (**TTL**): This field is used as a loop prevention mechanism.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protocol**: This field is used to communicate what the protocol is. TCP has
    a value of **6** and UDP has a value of **17**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header Checksum**: This field is used to store a checksum and is used for
    error handling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source Address**: This field contains the source IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination Address**: This field contains the destination IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options**: This field is normally not used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data**: This includes information that is to be sent to the node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That was a quick overview of how an IPv4 packet is structured, and there is
    much more information that can be researched on this specific topic. I simply
    wanted to give you a little bit of background so that when we start looking at
    frames and packets inside of Wireshark, you will understand the references and
    why details and artifacts are displayed the way they are. A direct link to Wireshark's
    reference material can be found at https://www.wireshark.org/docs/wsug_html_chunked/ChUsePacketDetailsPaneSection.html.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I took a screenshot of Wireshark''s packet details pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The packet details pane'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.03_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – The packet details pane
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on your system, try expanding the elements as they relate to the layers
    that we discussed previously. The first element that I will expand is the **Ethernet
    II** element, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The Ethernet layer'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.04_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – The Ethernet layer
  prefs: []
  type: TYPE_NORMAL
- en: 'This **Ethernet II** element directly relates to the **Data Link layer**, as
    discussed earlier. We can see that we have a **Destination** MAC address, a **Source**
    MAC address, **Type**, and **Padding**. The **Organizational Unique Identifier**
    (**OUI**), which is associated with the first 3 bytes of the MAC address, is very
    interesting. Here, you can see that Wireshark is resolving the OUI and that both
    VMware and our KoyoElec PLC have been resolved. In the following screenshot, we
    can see the Network layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The Network layer'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.05_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – The Network layer
  prefs: []
  type: TYPE_NORMAL
- en: 'In this layer, we can directly map the IPv4 layout, which we overviewed earlier,
    to a packet that we captured moving between the Koyo Click PLC and the engineering
    software. The following is a list of the important fields in the Network layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version: 4**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IHL: 20 bytes**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TOS: 0x00**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Total Length: 43**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identification: 0x61ff**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags: 0x00**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragment Offset: 0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time to Live: 128**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protocol: UDP (17)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header Checksum: 0x5354**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source Address: 192.168.3.10**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destination Address: 192.168.1.20**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next layer that we will review is the Transport layer. This is where applications
    use ports to communicate with each other. The following screenshot shows the Transport
    layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The Transport layer'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.06_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – The Transport layer
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that **Source Port: 54782** and **Destination Port: 25425**
    are being used. Finally, we will take a look at the **Data** element/the Application
    layer of the Wireshark packet details pane. This is where the application data
    can be found. Typically, this is the most interesting section of the packet as
    things such as credentials can be found here in plaintext. The following screenshot
    represents the Application layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The Application layer'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.07_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – The Application layer
  prefs: []
  type: TYPE_NORMAL
- en: 'The data here has not been parsed out into nice elements as I am not running
    a dedicated Koyo Click protocol dissector. We can take a look at the ASCII translation
    in the packet bytes pane as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – The packet bytes pane'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.08_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – The packet bytes pane
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, **4b 4f 50** starts the data section
    off. If you look at the ASCII conversion, you will see that it has the characters
    of **KOP**. This is a direct marker for the Koyo Click protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered the OSI model and the packet structure. Then, we
    tied the theory of the OSI model and the packet structure back to our real-time
    captured traffic. This helped us to visualize and connect the dots between theories
    and practical applications. In the next section, we will take a closer look at
    running commands in our engineering software, capturing traffic with Wireshark
    through our mirror port, and then analyzing the **KOP protocol** in greater detail.
    This analysis will help us in our future pentests, as we can start to build and
    sharpen our skills around analyzing unknown protocols – something that you will
    most definitely encounter during your career.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing packets on the wire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we discussed what the OSI model is and the layers that
    formulate and structure the model. We reviewed how a packet is constructed and
    then directly compared the packet structure to the communication exchange we see
    between the PLC and engineering software. In this section, we are going to dive
    deeper into Wireshark and focus on some key features that I personally use during
    my engagements to capture traffic. As a recap, in [*Chapter 5*](B16321_05_Epub_AM.xhtml#_idTextAnchor049)*,
    Span Me If You Can, w*e used Wireshark to verify that our mirror port was set
    up and configured correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I want to preface this upcoming content with two very distinct points,
    and give shout-outs to fellow security experts in the industry, as well as to
    content that I have personally leveraged in the past to hone my skills:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.chappell-university.com/](https://www.chappell-university.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://tryhackme.com/room/wireshark](https://tryhackme.com/room/wireshark)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both these resources provide different types of content. I have *Wireshark 101*
    by *Laura Chappell* as part of my core library, and the first link is a shout-out
    to Laura for doing such a great job at providing content that is focused on utilizing
    Wireshark for network troubleshooting and security forensics. The second link
    is to a room dedicated to Wireshark. If you want to have hands-on interactive
    training, then I strongly recommend this website and room. The site is a great
    resource for anyone in the red teaming space to utilize. I personally spend my
    time on this site brushing up on new tactics that have been shared by the community.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let''s jump right into it. We will open Wireshark and select
    our capture interface. You should see a list of possible interfaces that you can
    utilize to capture traffic, similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The Capture interface'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.09_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – The Capture interface
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, I want to zero in on the **…using this filter**
    input field. This allows us to provide laser focus when capturing traffic. If
    we are specifically looking for unique hosts, a range of hosts, protocols, or
    anything specific regarding the engagement, this is where we can define a capture
    filter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A **capture filter** should not be confused with a **display filter**. A capture
    filter drops or ignores packets that fall outside of the filter, whereas a display
    filter simply hides the packets but allows you to maintain them for deeper analysis.
    During an engagement, if you don't have a clear idea of what you are capturing,
    I would recommend capturing everything and using display filters afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Capture filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some simple examples of capture filters that can be used in the field include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**host**: This will capture all communication to and from a given host. In
    this example, all communication originating from or designated to **192.168.120**
    will be captured and all other traffic will be dropped. This comes in handy if
    you have been limited to a very focused pentest from your customer. You can use
    the following command to achieve this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**host 192.168.1.20**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**net**: This will capture all communication to and from a given subnet. This
    example only captures traffic with a destination to or from the **192.168.1.0/24**
    subnet. Once again, this is very handy if your customers do not want you to engage
    with other networks or communication. This is commonly referred to as a **gray
    box or white box** penetration test, which we will go into more detail about in
    the next chapter. You can use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**net 192.168.1.0/24**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**port**: This will capture all communication to and from a given port. In
    this example, we will focus on **Modbus** traffic communicating over port **502**.
    This comes in very handy when we want to go after a specific protocol related
    to a specific process inside the facility. You can refer to the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**port 502**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are far more complex methods that can be used for filtering if you want
    to specifically track **File Transfer Protocol** (**FTP**), **Network File System**
    (**NFS**), SMB file movements, TELNET, or basic HTTP authentication. Using capture
    filters allows you to focus on key packets and keep things to a manageable size
    once your goal has been achieved. Everything you can do with capture filters you
    can also do with display filters. The most notable difference between capture
    and display filters will be the file size after using the filters for the same
    duration of capture time. In very noisy networks, it only takes a few seconds
    to capture millions of packets. It is possible to capture gigabytes of data before
    ever achieving your goal. Although the trade-off is that yes, you do have small
    and easy-to-manage packet captures after using capture filters, you do lose out
    on all that other traffic that could be hidden nuggets of gold. Moving forward,
    and for the remainder of this book, we will focus on display filters. This is
    because they will capture all packets, which will allow us to perform further
    forensics on the interesting attack vectors that could go unnoticed if a capture
    filter is being used instead because capture filters drop all packets but what
    the filter is set to.
  prefs: []
  type: TYPE_NORMAL
- en: Display filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stop your current Wireshark capture, remove your capture filter, and select
    your interface once again. This will allow us to record every packet on the network.
    Now you should be able to view your Koyo Click PLC or whatever PLC you have set
    up in your lab to communicate with the engineering software. Here is an example
    screenshot of what you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Communication between the PLC and the workstation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.10_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – Communication between the PLC and the workstation
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to focus on the display filter input bar, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Display filter'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.11_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – Display filter
  prefs: []
  type: TYPE_NORMAL
- en: This is where the analysis happens. For this specific section, I am going to
    discuss key filters that are used during pentesting. For this, I feel the best
    approach is to narrow in on certain protocols that are uniquely interesting to
    gain a foothold inside the **Operational Technology** (**OT**) environment. Inside
    the network, there are and will be many ICS-centric protocols, such as Modbus,
    Ethernet/IP, DNP3, S7, HART, and more. These will be covered in greater detail
    in the next chapter. However, in this section, I want to focus on some low-hanging
    fruit. These specific protocols have helped me the most in terms of carrying the
    most information on the network and when pivoting through a customer's infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many things can be gleaned from the HTTP protocol, hence the reason why everyone
    in security is pushing for the implementation of HTTPS. The fortunate part for
    us is that in the ICS space, there are SCADA systems, HMIs, RTUs, PLCs, flow computers,
    and GCs that use legacy web interfaces to serve up information and/or run control.
    There are so many gold nuggets of data that are wrapped inside the HTTP protocol.
    You can extract credentials using basic authentication, you can find more sophisticated
    forms of obfuscation and filter for digest at **http.authorization**, you can
    capture request methods, you can capture asset details and devices communicating
    across internal networks, and more. The following is a list of important HTTP
    filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**http.authbasic**: This filter is used to find basic authentication, which
    we can easily extract and decode as the username and password are Base64-encoded.
    Depending on the security maturity of a company, these pieces of data are still
    readily found on older systems that haven''t been updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**http.authorization**: This is a filter that can be used to extract authorization
    and digest access for negotiated credentials and then use a tool such as *hashcat*
    or *John the Ripper* to **brute force** the credentials. We will cover brute-forcing
    passwords in the next chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**http.request.method**: This filter provides a lot of interesting information
    as it will extract all the **GET**, **POST**, **PUT**, and **DELETE** methods.
    This can be very useful if you are looking for **Application Programming Interface**
    (**API**) calls and commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Story time
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I have been involved in several airport-related engagements. This particular
    airport engagement happened to have a flat network on their public Wi-Fi; well,
    they didn't think it was flat, but for all intents and purposes, it was a flat
    network. By simply sniffing the Wi-Fi broadcast and multicast traffic, it was
    very apparent that they hadn't changed the default credentials in their gateway.
    By setting up a remote sniffing session, I was able to capture all the communication
    on the internal side of their network through their public Wi-Fi. As it turns
    out, they hadn't enabled HTTPS on their **SIEM**, and they were using one account
    to log and access all traffic going to and from their SIEM of choice. Once I had
    the credentials that were being passed encoded in Base64, a little decode and
    logging enabled me to see the entire infrastructure of the airport, including
    all the terminals, baggage handling, HVAC, people movers, lights, and more.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Understanding that HTTP contains a plethora of data, it is my first go-to filter
    when using Wireshark. I want to see all the low-hanging fruit that it contains
    and document it for later exploitation. Next, I will utilize FTP as a display
    filter and take a deep dive into the data to find interesting information.
  prefs: []
  type: TYPE_NORMAL
- en: FTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As one of the most explored protocols in the ICS network, FTP has almost been
    abusively overused by automation vendors. The fact that FTP's entire premise is
    around moving files using a non-encrypted protocol means all of the things moved
    via this protocol are vulnerable to exploitation. We have vendors that use FTP
    to update firmware or programmable logic. Imagine that you had the ability to
    forge a plaintext file that could easily trigger a downgrade from a stable firmware
    version to a previous vulnerable firmware version. This can occur all because
    metaphorically speaking they didn't mention that they were trying to put a Band-Aid
    on the flu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and try using the following display filters in Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ftp.request.command == "USER"**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ftp.request.command == "PASS"**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This filter goes straight for the user and passwords that have attempted to
    access the box and failed. It finds brute-forced attempts during login with a
    tool such as *Hydra* or if we are really lucky, the true credentials of a valid
    user.
  prefs: []
  type: TYPE_NORMAL
- en: '**ftp-data**: Using this filter, you can parse out files that have been transmitted
    between devices over the FTP protocol. This can be useful if you find a data share
    that contains a list of files that have sensitive information inside them.'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing that FTP is still widely used in the industrial world makes it a key
    factor to analyze when capturing packets on the network. There are credentials
    and files that can be extracted and reused for potential deeper exploitations
    into the network. Who knows, this in itself could validate a completed pentest,
    as there are some companies that have lingering intellectual property residing
    inside an internal file share. Keeping with the theme of file shares, we are going
    to analyze NFS next.
  prefs: []
  type: TYPE_NORMAL
- en: NFS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is another dynamic protocol that is utilized in the program delivery side
    of industrial automation. Writing a simple Python script that can be anonymously
    authenticated to a remote share and dropping a corrupted firmware version via
    NFS could essentially impact and *brick* all controllers in an accessible subnet.
    Disclaimer: *with great power comes great responsibility*. Even though it is possible,
    this is never an acceptable tactic during a pentest. I am simply calling out the
    fundamental flaws of some of the legacy implementations that still exist in the
    industry and that have been globally adopted. Therefore, I don''t focus solely
    on NFS as it is a firmware delivery method but also because of **root_squashing**.
    In some instances, you can find that **root_squashing** is turned off and the
    ability to quickly find this allows us to rapidly escalate privileges on a machine
    in the OT environment. Here are some of the display filters that can be used to
    narrow down on a system that might be exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**nfs.readdir.entry**: This filter helps pull out communications that will
    show us if there are file shares that are open to exploitation. Inside the protocol,
    in plaintext, there will be files listed that will help us map out what assets
    there are and possibly a point of entry into the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**nfs.access_rights**: This next filter allows us to weed out the locked-down
    file shares. If we run this filter, it will extract the packets that are related
    to privileged access such as **READ, LOOKUP, MODIFY,** **EXTEND, and DELETE**.
    These are very important to identify as they will save you time and headache during
    a pentest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we discussed capturing network traffic with Wireshark. We narrowed
    down what capture filters are, the benefits of using them, and how to use them
    during a pentest engagement. We also discussed the differences between capture
    filters and display filters. We then dove deeper into some key display filters
    that can help you to find valuable information inside a network and can be enabled
    for asset identification, possible exploitation avenues, privilege escalation
    avenues, and possible pivot points into the network. In the next section, we will
    put what we have just discussed into practice by using display filters on packet
    captures to analyze traffic for key information.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing packets for key information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, part of our discussion was about utilizing display
    filters for protocols such as **http**, **ftp**, and **nfs**. Understanding how
    to apply these filters and extracting key data is crucial to a successful pentesting
    engagement. Additionally, understanding who is communicating with who on the network
    and quickly applying a filter to hone in on critical details are an absolute must
    and require ongoing practice to get good at performing traffic analysis. In the
    previous section, I supplied some links, and I just want to reiterate that you
    need to practice honing your skills. People refer to pentesters as cyber Samurai
    or digital ninjas: they practice daily in order to strengthen and master their
    skills. In this section, we will perform analyses on multiple packet captures
    to demonstrate how to approach a network packet capture file and extract the key
    information required to drive success to our assessment.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: One of the key elements of success for a pentester is not just the ability to
    compromise a system but to clearly and concisely communicate where the security
    gaps are and how you leveraged them to gain access to an environment. This is
    the first time that I am really talking about this topic. But now that we are
    diving into traffic analysis and will come across lots of interesting information,
    I can't stress enough that you need to keep a running notepad to identify the
    assets seen, information captured, pivot points that can be exploited, and credentials
    sniffed on the wire. All of this information needs to be documented and made easily
    referenceable for when the time comes to turn in your final report. You will thank
    me that you started taking notes and documenting the trove of interesting information
    that you discovered on the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you glance back at the *Technical requirements* section, I posted a
    link to 4SICS Geek Lounge packet captures. As a refresher, here is the link again:
    [https://www.netresec.com/?page=PCAP4SICS](https://www.netresec.com/?page=PCAP4SICS).'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can utilize any PCAPs that you have. These are freely open to the industry
    and help us really put the power of display filters to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and open the PCAP file labeled **4SICS-GeekLounge-151021.pcap** with
    Wireshark. You should see roughly 1.2 million packets loaded into Wireshark. I
    want you to go ahead and try the first display filter that was covered in the
    last section. With the **http.authbasic** filter, you should see an output that
    is similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – The http.authbasic display filter'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.12_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.12 – The http.authbasic display filter
  prefs: []
  type: TYPE_NORMAL
- en: 'If you notice the **Authorization: Basic YWRtaW46YWRtaW4=** field and value,
    you can utilize your command-line skills by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: echo YWRtaW46YWRtaW4= | base64 -d
  prefs: []
  type: TYPE_NORMAL
- en: On your command line, you will use the **admin:admin** credentials.
  prefs: []
  type: TYPE_NORMAL
- en: If you are more of a tool type of person, then I strongly recommend *CyberChef*,
    which can be found at [https://gchq.github.io/CyberChef/](https://gchq.github.io/CyberChef/).
  prefs: []
  type: TYPE_NORMAL
- en: 'CyberChef is a great graphical tool to perform encoding/decoding, cryptography
    analyses and conversions, and more. As a very quick rundown, you have inputs,
    outputs, and recipes. In our case, we want to place the basic hash into the **Input**
    section and apply the **From Base64** recipe. In the **Output** section, you will
    see the **admin:admin** credentials, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – CyberChef From Base64'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.13_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – CyberChef From Base64
  prefs: []
  type: TYPE_NORMAL
- en: I personally like using the Base64 from the command line for decoding and other
    such tasks and only relying on CyberChef for more intense items such as encoding
    *Node.js reverse shells* in Base64 and injecting them into a malformed web portal,
    but I digress. Now looking through that filter, you should notice a second set
    of credentials; can you find them?
  prefs: []
  type: TYPE_NORMAL
- en: 'The second set of credentials will be **Authorization: Basic cm9vdDpyb290**,
    which is **root:root**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, remember when I suggested taking notes earlier? Let''s review what we
    have found by running a simple display filter. We have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Asset **192.168.2.42** is communicating over HTTP to port **80** on **192.168.88.25**
    using **admin:admin** as its credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asset **192.168.2.88** is communicating over HTTP to port **80** on **192.168.88.49**
    using **root:root** as its credentials, and the user agent indicates that it is
    possibly Ubuntu Linux x86_64 running Firefox for access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All this information is very useful. We know that there are two distinct subnets
    and that **.2** can communicate with **.88**. We know that there are two web servers
    running and that they are using an old authentication method, which leads me to
    believe that these two servers are vulnerable to further exploitation. Similarly
    to the following diagram, I also tend to draw the connections for a visual reference
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – A visual aid of the HTTP access'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.14_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – A visual aid of the HTTP access
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to change up the filter from **http.authbasic** to **http.request.method**,
    and you should see around 5,800 packets with **GET**, **POST**, and **OPTIONS**
    requests. From here, I can quickly scan the **Info** column for anything super
    interesting, such as filenames, **DELETE**, **PUT**, or **POST** requests, authorization
    attempts, or basically anything that can provide more details and insights into
    the network. As we can see **POST** requests, I am going to adjust my filter to
    focus on just the **POST** requests, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – The POST requests'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.15_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – The POST requests
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have managed to filter 5,800 packets down to 15\. Take a look at the
    **Info** column, as shown in the following screenshot, and check whether you can
    find anything that might be interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – The Info column'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.16_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – The Info column
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see from the filter that we have some interesting URLs that are being
    posted to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**/goform/svLogin**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/home.asp**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/view/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By clicking on the first **/goform/svLogin** **POST** request and navigating
    to the **application/x-www-form-urlencoded** section, we can see the form items
    being passed in plaintext, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – The /goform/svLogin POST request'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.17_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – The /goform/svLogin POST request
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now found another set of **root:dbps** credentials. Jotting down this
    information, we can now add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Asset **192.168.2.42** is communicating over HTTP to port **80** on asset **192.168.88.115**,
    which happens to be a Digiboard device using the **root:dbps** credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next packet would be the **POST** request for **/home.asp**. If we look
    at the packet dissection, we come across a very interesting find, that is, **Cookie**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – The Cookie field'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.18_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.18 – The Cookie field
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see another set of credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AccountName508=admin**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password508=0192023a7bbd73250516f069df18b500**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is very interesting as that password looks as though it is encrypted. What
    we can do is use a few different methods to determine what the encrypted type
    might be. I personally switch between **hash-identifier** and **haiti**. For this
    example, we will use **hash-identifier** and run the following command on our
    Kali instance, which we installed in [*Chapter 1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013)*,
    Using Virtualization:*
  prefs: []
  type: TYPE_NORMAL
- en: echo 0192023a7bbd73250516f069df18b500 | hash-identifier
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get a response that is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Hash ID'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.19_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.19 – Hash ID
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know that this hash is possibly an MD5 hash, we can attempt to
    crack it using a number of different tools such as *hashcat* or *John the Ripper*.
    However, I am going to run over to **crackstation.net**, load in the hash, and
    quickly check whether it has been cracked already. Low and behold, it has, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – crackstation.net MD5'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.20_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.20 – crackstation.net MD5
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I am going to go through each of the requests and extract the hashes and
    check them in **crackstation.net**. You should find the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – CrackStation passwords found'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.21_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.21 – CrackStation passwords found
  prefs: []
  type: TYPE_NORMAL
- en: 'The discovered credential pairs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**admin:admin123**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**user:user123**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**admin:123**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**admin:ADMIN123**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**root:root123**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now it should be noted that not all of these credentials work, and we need
    to take a deeper look into the communication between the devices to find which
    credentials are real and which ones are invalid. We can do this by highlighting
    one of the packets and right-clicking on the highlighted packet. Then, we can
    select **Follow** | **HTTP Stream**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Follow | HTTP Stream'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.22_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.22 – Follow | HTTP Stream
  prefs: []
  type: TYPE_NORMAL
- en: 'This particular received packet has the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – HTTP 302 redirect'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.23_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.23 – HTTP 302 redirect
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we see an **HTTP/1.0 302** redirect, we can safely assume the credentials
    that were supplied were incorrect. If you keep analyzing the packets in this manner,
    you should see an **HTTP/1.0 200 OK** response, which indicates that the credentials
    are valid and that the user is authenticated inside the web portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – HTTP 200 OK'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.24_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.24 – HTTP 200 OK
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we should go back and update our diagram from earlier and make sure to
    update our notes. Here is what the new diagram will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25 – HTTP data detection'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.25_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.25 – HTTP data detection
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have simply used two HTTP-specific filters, and we have already discovered
    valid credentials that will work on switch technology, allowing us to dive deeper
    into the network. There are far more extensive filters that can be used to parse
    out even larger swaths of information; I simply wanted to demonstrate how easy
    it is to obtain critical information in a very short period. In the last section,
    we will discuss the FTP protocol and display filters for this protocol. Using
    the same PCAP, update your display filter to simply find all of the FTP traffic,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26 – FTP traffic'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.26_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.26 – FTP traffic
  prefs: []
  type: TYPE_NORMAL
- en: 'Selecting the top packet, which is **No.** **480883**, and looking at the packet
    information, we can quickly find very relevant and identifiable asset details,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27 – AXIS 206 Network Camera'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.27_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.27 – AXIS 206 Network Camera
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we happened to find an AXIS Network Camera that is publishing an asset
    model number and version for the camera inside the packet. Now recall the chapter
    where we discussed open source intel; we should be able to open [https://www.exploit-db.com/](https://www.exploit-db.com/)
    and type **axis network camera** into the search bar. You should get the following
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28 – Exploit Database'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.28_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.28 – Exploit Database
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s click on the very first listing we can see, **Axis Network Camera -
    .srv to parhand Remote Code Execution (Metasploit)**. After viewing the details
    of this listing, we find that there is a nice little Metasploit module that will
    allow us to run remote execution against this camera. Excellent! Let''s add that
    to the diagram and documentation. With this new information, let''s go back to
    our notes and determine what we have now found. Here is the newly updated diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29 – The HTTP server to the AXIS Network Camera'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.29_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.29 – The HTTP server to the AXIS Network Camera
  prefs: []
  type: TYPE_NORMAL
- en: Notice that by using the HTTP filter, we have discovered a web server on IP
    address **192.168.88.49** with the credentials of **root:root**. Now, after running
    the FTP display filter, we can see another device communicating with that previous
    asset. However, we now have more asset information to determine that the endpoint
    is a network camera, so we update our notes and jot down the vulnerability that
    we discovered. Open the next two PCAP files and run the same filters that we did
    on **4SICS-GeekLounge-151021.pcap** and make sure to record your findings.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we really drilled down into display filters and the data that
    can be extracted. We used PCAPs that have been freely published on [https://www.netresec.com/?page=PCAP4SICS](https://www.netresec.com/?page=PCAP4SICS).
    We then proceeded to explore the data by utilizing various HTTP and FTP display
    filters. We were able to capture valid credentials that were being used on the
    network and identify some strategic vulnerable assets. This section helped us
    to understand why capturing and analyzing network traffic is vital to pentesting,
    as far more useful and critical data can be extracted from the wire.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how packets are formed by reviewing the OSI model
    and understanding the various layers that exist in the model. We took this one
    step further by analyzing the structure of an IPv4 packet and performing a side-by-side
    comparison of this with a packet that we captured from our lab equipment. After
    providing a better understanding of what packets are and how they are constructed,
    we went on to use Wireshark to capture these packets. We made use of the mirror
    port that we created in the previous chapter, and we discussed the differences
    between capture filters and display filters.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we downloaded some PCAPs from an open source ICS lab and we used Wireshark
    to analyze the traffic that we found in these packet captures. We leveraged display
    filters to narrow down key network data, such as valid credentials, operational
    web portals, and working network cameras. Understanding and practicing these techniques
    and methods will allow you to have very successful engagements in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be taking everything that we have learned so far
    and utilizing it in a lab. We will discuss multiple topics such as enumeration,
    protocol deep diving, exploitation, and privilege escalation. These are all the
    key elements you need to drive home a successful pentest.
  prefs: []
  type: TYPE_NORMAL
