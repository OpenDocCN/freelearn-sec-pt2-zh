<html><head></head><body>
		<div id="_idContainer264">
			<h1 id="_idParaDest-78"><em class="italic"><a id="_idTextAnchor081"/>Chapter 7</em>: Scanning 101</h1>
			<p>In the last chapter, we discussed how packets are structured and relate to the OSI model, set up capture filters with Wireshark, and used display filters to analyze <strong class="bold">industrial control system</strong> (<strong class="bold">ICS</strong>) lab <strong class="bold">packet captures</strong> (<strong class="bold">pcaps</strong>) that we downloaded from Netresec, using and practicing these skills to further our knowledge and sharpen our pentesting skills.  </p>
			<p>In this chapter, we are going to install Ignition SCADA and connect our Koyo Click PLC lab to it. We then will look at a number of tools for enumerating and scanning industrial networks, from port scanning with NMAP and RustScan to web application scanning with <strong class="bold">human machine interfaces</strong> (<strong class="bold">HMIs</strong>), SCADA operator screens, PLC control screens, and flow computer web portals with both Gobuster and feroxbuster. We will use these tools and run them against our Ignition SCADA instance.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Installing and configuring Ignition SCADA</li>
				<li>Introduction to NMAP </li>
				<li>Port scanning with RustScan</li>
				<li>Introduction to Gobuster</li>
				<li><a id="_idTextAnchor082"/><a id="_idTextAnchor083"/>Web application scanning with feroxbuster </li>
			</ul>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor084"/>Technical requirements</h1>
			<p>For this chapter, you will need the following:</p>
			<ul>
				<li><strong class="bold">Ignition SCADA</strong>: You will need to install Inductive Automation's Ignition SCADA in order to work with Gobuster and feroxbuster. Use the following link and install it on your SCADA VM host:<p><a href="https://inductiveautomation.com/downloads/&#13;">https://inductiveautomation.com/downloads/</a></p></li>
				<li><strong class="bold">NMAP</strong>: <a href="https://nmap.org/">https://nmap.org/</a>.</li>
				<li><strong class="bold">RustScan</strong>: <a href="https://github.com/RustScan/RustScan">https://github.com/RustScan/RustScan</a>.</li>
				<li><strong class="bold">Gobuster</strong>: <a href="https://github.com/OJ/gobuster">https://github.com/OJ/gobuster</a>.</li>
				<li><strong class="bold">feroxbuster</strong>: <a href="https://github.com/epi052/feroxbuster">https://github.com/epi052/feroxbuster</a>.</li>
				<li><strong class="bold">Redpoint Digital Bond's ICS Enumeration Tools</strong>: <a href="https://github.com/digitalbond/Redpoint">https://github.com/digitalbond/Redpoint</a>.</li>
			</ul>
			<p>You can view this chapter's code in action here: <a href="https://bit.ly/3veEeNm">https://bit.ly/3veEeNm</a></p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor085"/>Installing and configuring Ignition SCADA</h1>
			<p>Ignition SCADA is <a id="_idIndexMarker402"/>one of the newest platforms on the market and one that is <a id="_idIndexMarker403"/>truly embracing modern technologies for the modular framework that it provides. It has been adopted by many industries and some big Fortune 100 companies to manage their industrial control processes. By using real-world software and hardware in our lab, we can gain a better understanding of how things interoperate prior to engaging in an assessment: </p>
			<ol>
				<li>Working with the link provided earlier, <a href="https://inductiveautomation.com/downloads/">https://inductiveautomation.com/downloads/</a>, we are going to download the package for our Ubuntu SCADA VM.<p>You should have a package called <strong class="source-inline">ignition-8.1.5-linux-x64-installer.run</strong>.</p></li>
				<li>Running the following command will get the installer rolling:<p class="source-code"><strong class="bold">./iginition-8.1.5-linux-x64-installer.run</strong></p><p>This will then launch the installer window, which looks like the following:</p><div id="_idContainer225" class="IMG---Figure"><img src="image/Figure_7.01_B16321.jpg" alt="Figure 7.1 – Ignition Installer&#13;&#10;"/></div><p class="figure-caption">Figure 7.1 – Ignition Installer</p></li>
				<li>Select <strong class="bold">Next</strong> through the <a id="_idIndexMarker404"/>default windows; we will keep the <a id="_idIndexMarker405"/>default location (<strong class="source-inline">/usr/local/bin/ignition</strong>) for Ignition installation. Click <strong class="bold">Next</strong> as shown in the following screenshot:<div id="_idContainer226" class="IMG---Figure"><img src="image/Figure_7.02_B16321.jpg" alt="Figure 7.2 – Installation Location&#13;&#10;"/></div><p class="figure-caption">Figure 7.2 – Installation Location</p></li>
				<li>Next, we <a id="_idIndexMarker406"/>want to <a id="_idIndexMarker407"/>select the <strong class="bold">Typical</strong> installation and then click the <strong class="bold">Next</strong> button as shown in the following screenshot:<div id="_idContainer227" class="IMG---Figure"><img src="image/Figure_7.03_B16321.jpg" alt="Figure 7.3 – Typical installation&#13;&#10;"/></div><p class="figure-caption">Figure 7.3 – Typical installation</p></li>
				<li>After <a id="_idIndexMarker408"/>those options, you are going to click the <strong class="bold">Install</strong> button. You <a id="_idIndexMarker409"/>will see Ignition extracting packages and installing the software on your SCADA host.</li>
				<li>Click <strong class="bold">Finish</strong>, which will bring you to a screen that allows you to pick between three primary versions—<strong class="bold">Maker Edition</strong>, <strong class="bold">Ignition</strong>, and <strong class="bold">Ignition Edge</strong>, as shown in the following screenshot:<div id="_idContainer228" class="IMG---Figure"><img src="image/Figure_7.04_B16321.jpg" alt="Figure 7.4 – Ignition versions&#13;&#10;"/></div><p class="figure-caption">Figure 7.4 – Ignition versions</p></li>
				<li>Click <strong class="bold">Ignition</strong> as we <a id="_idIndexMarker410"/>know this is the product that is primarily <a id="_idIndexMarker411"/>used out in the industry.<p>This will bring you to the <strong class="bold">Terms and Conditions</strong> page. Select that you agree and then you will be prompted with a screen for creating a new user, as follows:</p><div id="_idContainer229" class="IMG---Figure"><img src="image/Figure_7.05_B16321.jpg" alt="Figure 7.5 – Create a User&#13;&#10;"/></div><p class="figure-caption">Figure 7.5 – Create a User</p><p>I chose, for <a id="_idIndexMarker412"/>simplicity's sake, to use <strong class="source-inline">scada</strong> for the username and <strong class="source-inline">scada</strong> for the password as it <a id="_idIndexMarker413"/>will help expedite the installation process.</p></li>
				<li>Next, you will be prompted with the option to configure ports. I have kept my ports as the default as this is typical for most industry installs. You can see the default ports for HTTP, HTTPS, and gateway network port in the following screenshot:<div id="_idContainer230" class="IMG---Figure"><img src="image/Figure_7.06_B16321.jpg" alt="Figure 7.6 – Configure Ports&#13;&#10;"/></div><p class="figure-caption">Figure 7.6 – Configure Ports</p></li>
				<li>Next, you will <a id="_idIndexMarker414"/>want to click the <strong class="bold">Finish Setup</strong> button and you <a id="_idIndexMarker415"/>will be brought to a page that states that your setup is completed and allows you to click a button to start the gateway, as shown in the following screenshot:<div id="_idContainer231" class="IMG---Figure"><img src="image/Figure_7.07_B16321.jpg" alt="Figure 7.7 – Start Gateway&#13;&#10;"/></div><p class="figure-caption">Figure 7.7 – Start Gateway</p></li>
				<li>Go ahead and click the <strong class="bold">Start Gateway</strong> button. This might take a minute or so to get up and running, so sit back and relax or go get a coffee. Once complete, you will be prompted with a choice to start from scratch or enable Quick Start. I chose to select <strong class="bold">Yes, Enable Quick Start -&gt;</strong> as it will streamline some options for me. Have a look at the following screenshot:<div id="_idContainer232" class="IMG---Figure"><img src="image/Figure_7.08_B16321.jpg" alt="Figure 7.8 – Enable Quick Start&#13;&#10;"/></div><p class="figure-caption">Figure 7.8 – Enable Quick Start</p></li>
				<li>Once you have <a id="_idIndexMarker416"/>enabled Quick Start, you will be prompted to log in. Go ahead and log in <a id="_idIndexMarker417"/>with the previous username and password that we created:<div id="_idContainer233" class="IMG---Figure"><img src="image/Figure_7.09_B16321.jpg" alt="Figure 7.9 – Login&#13;&#10;"/></div><p class="figure-caption">Figure 7.9 – Login</p></li>
				<li>As you can see, you now have access to a fully baked SCADA product, and the product will run in <strong class="bold">Trial Mode</strong>. You have the ability to run and test this product in <strong class="bold">Trial Mode</strong>; however, you have to reset the trial every 2 hours. From here, we are going to connect Koyo Click PLC to Ignition. Click the <strong class="bold">Status</strong> button on the left-hand side of the screen, which will bring you to an <strong class="bold">Overview</strong> screen showing <strong class="bold">Architecture</strong>, <strong class="bold">Environment</strong>, <strong class="bold">Systems</strong>, and many other options, as you can <a id="_idIndexMarker418"/>see in the <a id="_idIndexMarker419"/>following screenshot:<div id="_idContainer234" class="IMG---Figure"><img src="image/Figure_7.10_B16321.jpg" alt="Figure 7.10 – Status&#13;&#10;"/></div><p class="figure-caption">Figure 7.10 – Status</p></li>
				<li>From here, you are going to look for and click on the <strong class="bold">Devices</strong> button, shown in the following screenshot:<div id="_idContainer235" class="IMG---Figure"><img src="image/Figure_7.11_B16321.jpg" alt="Figure 7.11 – Devices&#13;&#10;"/></div><p class="figure-caption">Figure 7.11 – Devices</p></li>
				<li>This will then bring you to the <strong class="bold">Devices</strong> dashboard, displaying details of the connected devices, as presented in the following screenshot:<div id="_idContainer236" class="IMG---Figure"><img src="image/Figure_7.12_B16321.jpg" alt="Figure 7.12 – Devices dashboard&#13;&#10;"/></div><p class="figure-caption">Figure 7.12 – Devices dashboard</p></li>
				<li>From here, we <a id="_idIndexMarker420"/>will click the <strong class="bold">Configuration</strong> button in the top right-hand corner of the screen. This will bring us to a screen where we can create a <a id="_idIndexMarker421"/>new device. Go ahead and click the <strong class="bold">Create new Device…</strong> button:<div id="_idContainer237" class="IMG---Figure"><img src="image/Figure_7.13_B16321.jpg" alt="Figure 7.13 – Create new Device…&#13;&#10;"/></div><p class="figure-caption">Figure 7.13 – Create new Device…</p><p>There will be a list of included devices, but as you might notice, there is no dedicated Koyo Click. However, we know that our device utilizes Modbus TCP on port <strong class="source-inline">502</strong>, so scroll down until you find the following option and select it:</p><div id="_idContainer238" class="IMG---Figure"><img src="image/Figure_7.14_B16321.jpg" alt="Figure 7.14 – Modbus TCP&#13;&#10;"/></div><p class="figure-caption">Figure 7.14 – Modbus TCP</p><p>This will provide <a id="_idIndexMarker422"/>you with a <a id="_idIndexMarker423"/>screen to configure <strong class="bold">General</strong> and <strong class="bold">Connectivity</strong> parameters.</p><p>I set the following parameters:</p><p>- <strong class="bold">Name</strong>: <strong class="source-inline">Koyo Click</strong></p><p>- <strong class="bold">Description</strong>: <strong class="source-inline">Lab PLC Koyo Click</strong></p><p>- <strong class="bold">Hostname</strong>: <strong class="source-inline">192.168.1.20</strong></p><p>- <strong class="bold">Port</strong>: <strong class="source-inline">502</strong></p><p>- <strong class="bold">Comms Timeout</strong>: <strong class="source-inline">2000</strong></p><p>Here is the screen that you should see with the preceding information filled out:</p><div id="_idContainer239" class="IMG---Figure"><img src="image/Figure_7.15_B16321.jpg" alt="Figure 7.15 – PLC configuration&#13;&#10;"/></div><p class="figure-caption">Figure 7.15 – PLC configuration</p><p>There is a <a id="_idIndexMarker424"/>special note that needs to be made. Koyo Click starts its <a id="_idIndexMarker425"/>address ranges at 0 and because this is the case, Ignition provides an option to set this under the advanced properties, as shown:</p><div id="_idContainer240" class="IMG---Figure"><img src="image/Figure_7.16_B16321.jpg" alt="Figure 7.16 – Zero-based addressing&#13;&#10;"/></div><p class="figure-caption">Figure 7.16 – Zero-based addressing</p></li>
				<li>Once finished, you should see a message that Koyo Click has been successfully created and added to the system. If everything worked correctly, under the <strong class="bold">Status</strong> column, you will see <strong class="bold">Connected</strong>, as shown:<div id="_idContainer241" class="IMG---Figure"><img src="image/Figure_7.17_B16321.jpg" alt="Figure 7.17 – Connected PLC&#13;&#10;"/></div><p class="figure-caption">Figure 7.17 – Connected PLC</p></li>
				<li>Next, we are <a id="_idIndexMarker426"/>going to map our coils to Ignition's system, so we will click on the <strong class="bold">More</strong> drop-down button next to the <strong class="bold">Connected</strong> status. Under <a id="_idIndexMarker427"/>this dropdown, we want to select <strong class="bold">Addresses</strong>, as you can see in this next screenshot:<div id="_idContainer242" class="IMG---Figure"><img src="image/Figure_7.18_B16321.jpg" alt="Figure 7.18 – Addresses&#13;&#10;"/></div><p class="figure-caption">Figure 7.18 – Addresses</p><p>This will take us to the <strong class="bold">Address Configuration</strong> screen, allowing us to map our address into Ignition. We are going to use to following data to configure our addressing:</p><p>- <strong class="bold">Prefix</strong>: <strong class="source-inline">Lights</strong></p><p>- <strong class="bold">Start</strong>: <strong class="source-inline">1</strong></p><p>- <strong class="bold">End</strong>: <strong class="source-inline">4</strong></p><p>- <strong class="bold">Unit ID</strong>: <strong class="source-inline">0</strong></p><p>- <strong class="bold">Modbus Type</strong>: <strong class="source-inline">Coil</strong></p><p>- <strong class="bold">Modbus Address</strong>: <strong class="source-inline">000000</strong></p><p>Notice that the <strong class="bold">Start</strong> number is <strong class="source-inline">1</strong>, which is due to us selecting the <strong class="bold">Zero-based addressing</strong> option. The <strong class="bold">End</strong> number is <strong class="source-inline">4</strong> as we have four lights connected to our coils. The <strong class="bold">Modbus Address</strong> starting address is <strong class="source-inline">000000</strong> due to the nature of Koyo Click. You can <a id="_idIndexMarker428"/>see how the inputs are configured in the <a id="_idIndexMarker429"/>following screenshot:</p><div id="_idContainer243" class="IMG---Figure"><img src="image/Figure_7.19_B16321.jpg" alt="Figure 7.19 – Address Configuration&#13;&#10;"/></div><p class="figure-caption">Figure 7.19 – Address Configuration</p></li>
				<li>Once we click <strong class="bold">Save</strong> for <strong class="bold">Address Configuration</strong>, we will map the newly minted Modbus <a id="_idIndexMarker430"/>addresses to our <strong class="bold">Open Platform Communications</strong> (<strong class="bold">OPC</strong>) server. Click the <strong class="bold">Config</strong> button on the left-hand side of the screen located below the previously selected <strong class="bold">Status</strong> button. Scroll down until you find <strong class="bold">OPC CLIENT</strong> and select <strong class="bold">OPC Quick Client</strong>, as you can see in the following screenshot:<div id="_idContainer244" class="IMG---Figure"><img src="image/Figure_7.20_B16321.jpg" alt="Figure 7.20 – OPC Quick Client&#13;&#10;"/></div><p class="figure-caption">Figure 7.20 – OPC Quick Client</p></li>
				<li>This will then <a id="_idIndexMarker431"/>bring up a screen where you can verify that your <a id="_idIndexMarker432"/>tags have been mapped from the Koyo Click PLC Modbus mapping to the internals of Ignition and you should see all four lights being mapped with three letters under the <strong class="bold">ACTION</strong> column, <strong class="bold">[s][r][w]</strong>:<p>- <strong class="bold">[s]</strong> is for subscription.</p><p>- <strong class="bold">[r]</strong> is for read.</p><p>- <strong class="bold">[w]</strong> is for write.</p><p>Clicking these <strong class="bold">Action</strong> links allows you to interact directly with the PLC. The following screen is what you should see:</p></li>
			</ol>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="image/Figure_7.21_B16321.jpg" alt="Figure 7.21 – OPC tag mapping&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.21 – OPC tag mapping</p>
			<p>Finally, you will open your designer and create a graphic with the four light buttons linked to them. This, however, I feel is out of our scope and not critical to the next sections that we will be discussing. So, I will leave that up to you to go and explore how to design a SCADA graphic. </p>
			<p>In this section, we <a id="_idIndexMarker433"/>went through a fairly detailed installation of Ignition SCADA. We linked our PLC to the system and verified that it worked. We will <a id="_idIndexMarker434"/>be utilizing this SCADA system later in the chapter to perform web application enumeration. In the next section, we are going to use NMAP to scan for open ports. We are moving through the logical steps that are typically performed during a pentest and working with the tools of the trade to gain some hands-on experience with running them against a real environment.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor086"/>Introduction to NMAP</h1>
			<p>Coming from the <a id="_idIndexMarker435"/>automation controls space, I used NMAP early on in my career to troubleshoot new technology that was starting to adopt TCP-based protocols. Finding hardware that had open ports that had zero documentation was commonplace in the mid-00s. Over the next two decades, I followed this project and watched it grow into the foundational tool it is today. Not only is it used for finding open ports, but it can also be used to perform operating system fingerprinting, application identification, and many more features. </p>
			<p>In this section, we are going to install and run NMAP against our lab environment. We will identify open ports and the services running on these ports. Scanning the network for assets and open ports is fundamental for gaining a foothold and a pivot point inside the industrial network when in the field working on a client's network. As said in the previous chapter about Wireshark being the number one tool for a pentester, I would say NMAP is number two. With these two tools, I can perform assessments, engage in pentests, compete <a id="_idIndexMarker436"/>in a <strong class="bold">Capture The Flag</strong> (<strong class="bold">CTF</strong>), troubleshoot network issues, perform communication analysis for SCADA systems, and many more.</p>
			<p>Every major system that utilizes some sort of package manager has a readily available package for NMAP.</p>
			<p>For Linux, there is the following:</p>
			<p class="source-code">apt install nmap</p>
			<p>For macOS, there is the following:</p>
			<p class="source-code">brew install nmap</p>
			<p>For Windows, there is the following:</p>
			<p><a href="https://nmap.org/zenmap/&#13;">https://nmap.org/zenmap/</a></p>
			<p>Zenmap provides a visual tool that can be leveraged to analyze and map out networks and assets.</p>
			<p>Now that we have <a id="_idIndexMarker437"/>NMAP installed on our system, we want to run a scan on our lab network. Just as a refresher from <a href="B16321_01_Epub_AM.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Using Virtualization</em>, here is the network layout:</p>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/Table_7.1.jpg" alt=""/>
				</div>
			</div>
			<p>Start by adding a second interface to Kali Linux and place it in the operations and control network segment, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer247" class="IMG---Figure">
					<img src="image/Figure_7.22_B16321.jpg" alt="Figure 7.22 – Second interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.22 – Second interface</p>
			<p>You will now <a id="_idIndexMarker438"/>have an interface in the <strong class="bold">Enterprise</strong> segment, which is Level 5 of the lab, and now you should see your newly added <strong class="bold">Operations</strong> segment, which is Level 3.</p>
			<p>Now, on your Kali Linux VM, set your newly added secondary interface to an IP address in the same subnet as Windows 7 Professional. I chose to set my IP address to <strong class="source-inline">192.168.3.200</strong>. Next, we are going to run a very basic scan of the subnet.</p>
			<p class="callout-heading">Disclaimer</p>
			<p class="callout">The scanning or enumeration stage is the starting point at which we start producing information that is traceable on the network. This is considered an <em class="italic">active</em> approach and can come with consequences in the form of detection or worse, port scanning an old piece of equipment that hangs up and stops working. This is a cautionary tale from real-world experiences.</p>
			<p>With the disclaimer out of the way, let's dive right in. Even though we know our lab and what equipment is inside, we are going to start with scanning the entire subnet as an introduction to NMAP.  </p>
			<p>Run the following command, which issues a quick scan spanning the entire subnet, hence <strong class="source-inline">/24</strong>:</p>
			<p class="source-code">nmap 192.168.3.0/24</p>
			<p>You should see the <a id="_idIndexMarker439"/>following results, a scan report for your Kali box but nothing else. Some of you might be wondering about the Windows machine and why it isn't displayed in the scan:</p>
			<div>
				<div id="_idContainer248" class="IMG---Figure">
					<img src="image/Figure_7.23_B16321.jpg" alt="Figure 7.23 – Subnet scan&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.23 – Subnet scan</p>
			<p>The answer is that Windows is blocking/dropping our ping probes and NMAP will skip to the next IP address in the range provided. You can issue the previous command by supplying the <strong class="source-inline">-Pn</strong> (no ping) handle at the end of the command so that it would like the following:</p>
			<p class="source-code">nmap 192.168.3.0/24 -Pn</p>
			<p>Now we want to home in on the Windows machine that we installed in <a href="B16321_01_Epub_AM.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Using Virtualization</em>. Run the following command specifically directed at the Windows machine:</p>
			<p class="source-code">nmap 192.168.3.10 -Pn</p>
			<p>You should get the following results; however, they might vary depending on what services you have enabled or disabled on your VM:</p>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="image/Figure_7.24_B16321.jpg" alt="Figure 7.24 – Windows scan&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.24 – Windows scan</p>
			<p>With NMAP, there are <a id="_idIndexMarker440"/>many options and if you run the <strong class="source-inline">man NMAP</strong> command, you can read through the source material and get a deeper insight into all the possibilities and options that NMAP has to offer. We are simply going to run a very aggressive scan to show the details that can be discovered on your Windows host. If you read the manual information, you will notice that the documentation issues a warning not to use <strong class="source-inline">-A</strong> (aggressive scan options) on targets without permission. Since we own the host and it is in our lab, we will go ahead and run it:</p>
			<p class="source-code">nmap -A 192.168.3.10 -Pn</p>
			<p>You will notice the same port scan results are returned but this time, using aggressive mode, scripts are run against the host to identify more detailed information, as seen here:</p>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="image/Figure_7.25_B16321.jpg" alt="Figure 7.25 – Aggressive scan&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.25 – Aggressive scan</p>
			<p>From the screenshot, we have discovered the following asset information:</p>
			<ul>
				<li><strong class="bold">OS</strong>: <strong class="source-inline">Windows 7 Professional N 7601 Service Pack 1</strong> </li>
				<li><strong class="bold">Computer name</strong>: <strong class="source-inline">WIN-VA8PE66T785</strong></li>
				<li><strong class="bold">Workgroup</strong>: <strong class="source-inline">Workgroup</strong></li>
				<li><strong class="bold">SMB user</strong>: <strong class="source-inline">guest</strong></li>
				<li><strong class="bold">SMB version</strong>: <strong class="source-inline">2.0</strong></li>
			</ul>
			<p>This is extremely <a id="_idIndexMarker441"/>useful during your assessment as you can start to probe hosts that are discovered on the network and determine what ports are open and what services are being run on those open ports.</p>
			<p>The extra information produced from aggressive mode is found by running scripts against the discovered host. These <strong class="bold">NMAP Scripting Engine</strong> (<strong class="bold">NSE</strong>) scripts can be found on <a id="_idIndexMarker442"/>the Kali Linux distribution under the <strong class="source-inline">/usr/share/nmap/</strong> <strong class="source-inline">scripts</strong> path and the list can be examined by running the following command:</p>
			<p class="source-code">ls /usr/share/nmap/scripts</p>
			<p>Under the <strong class="source-inline">scripts</strong> folder, you can find ICS-specific scripts such as the following:</p>
			<ul>
				<li><strong class="source-inline">bacnet-info</strong></li>
				<li><strong class="source-inline">enip-info</strong></li>
				<li><strong class="source-inline">modbus-discover</strong></li>
				<li><strong class="source-inline">s7-info</strong></li>
			</ul>
			<p>This is just a list of some of the default scripts included when installing NMAP. If you navigate to <a href="https://github.com/digitalbond/Redpoint">https://github.com/digitalbond/Redpoint</a>, you will find a list of scripts that can be included in NMAP to provide a deeper enumeration of various ICS hardware that you will find during the course of your career.</p>
			<p>In this section, we quickly discussed what NMAP is and the capabilities it has. We installed NMAP on our system and proceeded to scan our lab. We performed an aggressive scan against our Windows host and then touched on NSE. Finally, we looked at ICS-specific scripts that could be run. There are many dedicated books and courses around NMAP and NMAP scripting; this was a simple section to cover the importance of NMAP and provide exposure on how to use it in the industrial network. </p>
			<p>In the next section, we <a id="_idIndexMarker443"/>will be looking at RustScan, which is dubbed a <em class="italic">modern-day port scanner</em>. We will be installing RustScan on our Kali Linux distribution and running it against our lab environment.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor087"/>Port scanning with RustScan</h1>
			<p>NMAP has been my de facto port scanning tool of choice until recently, when I discovered RustScan. The <a id="_idIndexMarker444"/>one major benefit of RustScan is the <a id="_idIndexMarker445"/>lightning speed at which it scans all 65K ports; it can do this in 3 seconds. Compare that to NMAP, and it's night and day. I would set up NMAP, go for lunch, and come back and it would still be running. It has a full suite of scripting support from Python, Lua, Bash, or even piping the RustScan results to NMAP. </p>
			<p>When time is of the essence, RustScan is the choice. I do, however, still find myself reverting back to NMAP for specific tasks, but that is more out of familiarity and, as said in previous sections, practice, practice, and practice. In this section, we will be installing RustScan and running it against the machines in our lab. We'll observe the speed difference at which the scans run and get familiar with the syntax in order to add this tool to our pentesting arsenal.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor088"/>Installing RustScan</h2>
			<p>The <a id="_idIndexMarker446"/>official documentation can be found at the following link:</p>
			<p><a href="https://github.com/RustScan/RustScan#-full-installation-guide">https://github.com/RustScan/RustScan#-full-installation-guide</a></p>
			<p>I am going to focus strictly on installing RustScan on our lab VM; however, feel free to read through the various material and install it on whatever system you would like. </p>
			<p>Opening Firefox ESR on my Kali VM, I am going to navigate to the following link:</p>
			<p><a href="https://github.com/RustScan/RustScan/releases">https://github.com/RustScan/RustScan/releases</a></p>
			<p>You will see the following screen with the <strong class="source-inline">.deb</strong> packages and the source bundles:</p>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="image/Figure_7.26_B16321.jpg" alt="Figure 7.26 – RustScan packages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.26 – RustScan packages</p>
			<p>I am going to click on the <strong class="bold">rustscan_2.0.1_amd64.deb</strong> package and download it onto my machine. I then <a id="_idIndexMarker447"/>open a terminal window and navigate to my <strong class="source-inline">~/Downloads</strong> folder to verify the package. Once I have verified the package, I am going to issue the following command to install the package:</p>
			<p class="source-code">sudo dpkg -i rustscan_2.0.1_amd64.deb</p>
			<p>Now, if everything worked, you should see the following results:</p>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="image/Figure_7.27_B16321.jpg" alt="Figure 7.27 – RustScan installation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.27 – RustScan installation</p>
			<p>Now that we have installed RustScan, we will run a quick help command to get a high-level view of commands that we can use:</p>
			<p class="source-code">rustscan -h</p>
			<p>You will see the following results:</p>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="image/Figure_7.28_B16321.jpg" alt="Figure 7.28 – RustScan – help&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.28 – RustScan – help</p>
			<p class="callout-heading">WARNING</p>
			<p class="callout">Before we proceed too far, know that the trade-off for speed is noise. The fact that RustScan can detect 65K ports in 3 seconds means that it is loud on the network and you will be detected. Additionally, running this scan against sensitive devices will most certainly knock them over as they were never designed to receive tens of thousands of requests at that rate. This will cause operational impact and production loss; please read about decreasing batch sizes and increasing timeouts before using this tool on a live production network.</p>
			<p>With that <a id="_idIndexMarker448"/>out of the way, try scanning your Windows host again and watch the speed. Use the following command:</p>
			<p class="source-code">rustscan -a 192.168.3.10 </p>
			<p>You will see the following results:</p>
			<div>
				<div id="_idContainer254" class="IMG---Figure">
					<img src="image/Figure_7.29_B16321.jpg" alt="Figure 7.29 – RustScan -a Windows host&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.29 – RustScan -a Windows host</p>
			<p>Due to the extensible <a id="_idIndexMarker449"/>nature of RustScan, we can run NMAP commands by passing them in as arguments. We can run an aggressive scan against the SCADA <strong class="source-inline">192.168.2.10</strong> host. Using the <strong class="source-inline">rustscan</strong> command and setting the batch size, <strong class="source-inline">-b</strong>, to <strong class="source-inline">10</strong> and the address, <strong class="source-inline">-a</strong>, to <strong class="source-inline">192.168.2.10</strong>, we will pass in the NMAP <strong class="source-inline">-A</strong> aggressive scan command:</p>
			<p class="source-code">rustscan -b 10 -a 192.168.2.10 -- -A</p>
			<p>After running this command, you should, if you followed the steps from <a href="B16321_01_Epub_AM.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Using Virtualization</em>, have the following ports open:</p>
			<ul>
				<li><strong class="source-inline">21</strong></li>
				<li><strong class="source-inline">22</strong></li>
				<li><strong class="source-inline">23</strong></li>
			</ul>
			<p>This is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer255" class="IMG---Figure">
					<img src="image/Figure_7.30_B16321.jpg" alt="Figure 7.30 – RustScan – NMAP -A scan&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.30 – RustScan – NMAP -A scan</p>
			<p>This next <a id="_idIndexMarker450"/>screenshot has been clipped and shortened for readability purposes. The NMAP <strong class="source-inline">-A</strong> aggressive scan output reveals the ports that are open and the possible services running on those ports, as shown:</p>
			<div>
				<div id="_idContainer256" class="IMG---Figure">
					<img src="image/Figure_7.31_B16321.jpg" alt="Figure 7.31 – Port services running&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.31 – Port services running</p>
			<p>From this, we can see the following services and versions that are running on the open ports:</p>
			<ul>
				<li><strong class="source-inline">21/tcp open ftp vsftpd 3.0.3</strong></li>
				<li><strong class="source-inline">22/tcp open ssh OpenSSH 8.2p1</strong></li>
				<li><strong class="source-inline">23/tcp open telnet telnetd</strong></li>
			</ul>
			<p>We also <a id="_idIndexMarker451"/>discovered that the host is running Ubuntu Linux, which is no surprise as we installed and configured the services.  </p>
			<p>Not only can RustScan run NMAP options, but it can also run scripts from the command line, or we can create our own custom scripts and run those for more information gathering. With this example, I am going to run the NMAP <strong class="source-inline">modbus-discover</strong> script against our PLC in the lab. In my case, it is the Koyo CLICK PLC, but once again this could be any PLC that you would like to set up in your lab.</p>
			<p>We are setting the batch size, <strong class="source-inline">-b</strong>, to <strong class="source-inline">10</strong>, then the address, <strong class="source-inline">-a</strong>, to <strong class="source-inline">192.168.1.20</strong>, setting the <strong class="source-inline">—</strong> inline command, passing the NMAP <strong class="source-inline">—script</strong> script command, and setting the script to be <strong class="source-inline">modbus-discover</strong>:</p>
			<p class="source-code">rustscan -b 10 -a 192.168.1.20 -- --script 'modbus-discover'</p>
			<p>The output of the command should appear as follows:</p>
			<div>
				<div id="_idContainer257" class="IMG---Figure">
					<img src="image/Figure_7.32_B16321.jpg" alt="Figure 7.32 – modbus-discover script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.32 – modbus-discover script</p>
			<p>I have split this into two images and left out some response items in order to get the interesting output generated from running the <strong class="source-inline">modbus-discover</strong> script, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="image/Figure_7.33_B16321.jpg" alt="Figure 7.33 – modbus-discover SID&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.33 – modbus-discover SID</p>
			<p>In this section, we <a id="_idIndexMarker452"/>covered installing RustScan, running a simple scan, and running an extended scan by passing in an NMAP option, and finally, we ran a scan and passed in a default <strong class="source-inline">modbus-discover</strong> script from the NMAP collection. We made sure to reduce the batch size as we need to be cautious when using this tool due to the speed of the scanning that it can operate at. I have incorporated RustScan into my tool collection because of the speed for scanning; I can set the port ranges that I want to focus on and reduce my wait time for results. I primarily use this on levels 5–3 as I know critical control hardware seldom resides on these levels. Once I get lower into the network, I resort back to NMAP and run low and slow scans, being very careful not to knock over any processes that may be operational. </p>
			<p>In the next section, we are going to go through an introduction to Gobuster. We will install this directory scanning tool and use it to run against a web-based SCADA application that we install as well.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor089"/>Introduction to Gobuster</h1>
			<p>Gobuster is a <a id="_idIndexMarker453"/>web enumeration and directory brute forcing tool that has been written in Go. Up until my discovery of Gobuster, I was using tools such as Nikto, Cadaver, Skipfish, WPScan, OWASP ZAP, and DirBuster. Every one of these tools has its strengths and weaknesses but, in the end, they all worked pretty much the same with varying results. However, I was looking for something that I could run from the command line and didn't contain a thick client to run. </p>
			<p>This is when I stumbled across Gobuster. It was everything I was looking for in a command-line-driven web enumeration tool. I can quickly switch between directory brute forcing and virtual host enumeration. I can switch wordlists on the fly, set command-line arguments to perform file detection, and finally, adjust the thread count. All these features are why I personally have been using Gobuster during pentest engagements. In this section, we are going to install Gobuster and run it against our Ignition installation that we performed at the beginning of this chapter. </p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor090"/>Installing Gobuster</h2>
			<p>Every major operating system that <a id="_idIndexMarker454"/>utilizes some sort of package manager has a readily available package for Gobuster.</p>
			<p>For Linux, we have the following:</p>
			<p class="source-code">apt install gobuster</p>
			<p>For macOS, we have the following:</p>
			<p class="source-code">brew install gobuster</p>
			<p>For Windows, we have the following:</p>
			<p class="source-code">go install github.com/OJ/gobuster/v3@latest</p>
			<p>I have installed Gobuster on my Kali VM in the lab, using <strong class="source-inline">apt install gobuster</strong>. Once installed, you can run the <strong class="source-inline">gobuster –help</strong> command: </p>
			<p class="source-code">gobuster --help</p>
			<p>This will provide the following response:</p>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="image/Figure_7.34_B16321.jpg" alt="Figure 7.34 – Gobuster help&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.34 – Gobuster help</p>
			<p>From here, you can <a id="_idIndexMarker455"/>see the list of available commands, most notably the following:</p>
			<ul>
				<li><strong class="source-inline">dir</strong></li>
				<li><strong class="source-inline">dns</strong></li>
				<li><strong class="source-inline">vhost</strong></li>
			</ul>
			<p>The <strong class="source-inline">dir</strong> command is used to find directories/files by brute forcing the URL with a wordlist. <strong class="source-inline">dns</strong> is used to specifically look at subdomains and <strong class="source-inline">vhost</strong> to brute force and discover virtual hosts running on a remote machine.</p>
			<h3>Wordlists</h3>
			<p>The next important topic of <a id="_idIndexMarker456"/>this section is wordlists. I always say that you are only as <a id="_idIndexMarker457"/>good as your wordlist. This means if you don't start to build your own core wordlist, you will miss vital equipment and software being used in industrial networks. As a suggestion for your career, anytime you come across a device that hosts a web interface, write down the paths/directories/API routes that you find and add them to a custom wordlist. As a jump start, I am going to have you create your own wordlist by echoing the following paths to that wor<a id="_idTextAnchor091"/><a id="_idTextAnchor092"/>dlist:</p>
			<p class="source-code">cp /usr/share/wordlist/dirbuster/directory-list-2.3-medium.txt ~/Downloads/scada.txt</p>
			<p>Now we will pick these two specific paths to echo into our newly created wordlist:</p>
			<ul>
				<li><strong class="source-inline">status/</strong></li>
				<li><strong class="source-inline">config/</strong></li>
			</ul>
			<p>The command would be issued as follows:</p>
			<p class="source-code">echo "status/\n/config/" &gt;&gt; scada.txt</p>
			<p>Most wordlists are <a id="_idIndexMarker458"/>developed for IT purposes, which is great from an initial entry <a id="_idIndexMarker459"/>perspective but as an industrial software tool, you really need to take things into your own hands. I recommend installing SecLists as a base collective of wordlists, which is a robust collection that Daniel Miessler has created. We can then utilize one of the wordlists and start to augment it for our own personal use. It can be installed by running the following command:</p>
			<p class="source-code">sudo apt install seclists</p>
			<p>This will install the collection of wordlists under the following path:</p>
			<p class="source-code">/usr/share/seclists/</p>
			<p>Now that we have our bundle of wordlists installed, let's run Gobuster against Ignition by running the following command. We want to use the <strong class="source-inline">dir</strong> command as we want to look for directories, then we use the <strong class="source-inline">-u</strong> argument to assign the URL of the remote web server that we want to enumerate, and finally, the <strong class="source-inline">-w</strong> argument to assign the wordlist of choice:</p>
			<p class="source-code">gobuster dir -u http://192.168.2.10:8088 -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-big.txt</p>
			<p>After running this command, we will find that there are three directories discovered:</p>
			<ul>
				<li><strong class="source-inline">/main</strong></li>
				<li><strong class="source-inline">/web</strong></li>
				<li><strong class="source-inline">/Start</strong></li>
			</ul>
			<p>The following is a screenshot of the output:</p>
			<div>
				<div id="_idContainer260" class="IMG---Figure">
					<img src="image/Figure_7.35_B16321.jpg" alt="Figure 7.35 – Gobuster enumeration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.35 – Gobuster enumeration</p>
			<p>Now we are going to see <a id="_idIndexMarker460"/>whether there are any directories behind the <strong class="source-inline">/web</strong> path. We <a id="_idIndexMarker461"/>will use a different wordlist found at <strong class="source-inline">/usr/share/wordlist/dirbuster</strong>:</p>
			<p class="source-code">/usr/share/wordlist/dirbuster/directory-list-2.3-medium.txt</p>
			<p>Run the following command:</p>
			<p class="source-code">gobuster dir -u http://192.168.2.10:8088/web -w /usr/share/wordlist/dirbuster/directory-list-2.3-medium.txt</p>
			<p>We have now found three new directories:</p>
			<ul>
				<li><strong class="source-inline">/home</strong></li>
				<li><strong class="source-inline">/waiting</strong></li>
				<li><strong class="source-inline">/touch</strong></li>
			</ul>
			<p>This means that behind the <strong class="source-inline">/web</strong> route, there are three new items: <strong class="source-inline">/home</strong>, <strong class="source-inline">/waiting</strong>, and <strong class="source-inline">/touch</strong>. The output is included in the following screenshot:</p>
			<div>
				<div id="_idContainer261" class="IMG---Figure">
					<img src="image/Figure_7.36_B16321.jpg" alt="Figure 7.36 – /web enumeration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.36 – /web enumeration</p>
			<p>Now, the first path of <strong class="source-inline">http://192.168.2.10:8088/web/home</strong> looks very normal, and if <a id="_idIndexMarker462"/>you navigate to this link, you find that it indeed takes us to the <a id="_idIndexMarker463"/>home dashboard. The next directory found is <strong class="source-inline">/waiting</strong> and navigating to the URL path triggers a refresh load of the dashboard, which in itself is very curious behavior as it means there is some API path triggering a subroutine to refresh the dashboard. Finally, navigating to the <strong class="source-inline">/touch</strong> directory lands us on something very interesting as it returns a simple set of parentheses. This intel can be documented and explored further; however, I want you to re-run the scan but with the previously built <strong class="source-inline">scada.txt</strong> wordlist. You should see more paths and directories discovered.</p>
			<h3>File detection</h3>
			<p>The next part I want to <a id="_idIndexMarker464"/>briefly touch on is the <strong class="source-inline">-x</strong> argument. This allows <a id="_idIndexMarker465"/>Gobuster to run a brute force for directories and also look for files with specific extensions. An example command would be something like the following:</p>
			<p class="source-code">gobuster dir -u http://192.168.2.10:8088/web -w /usr/share/wordlist/dirbuster/directory-list-2.3-medium.txt -x txt,php,conf,xml,json</p>
			<p>In this section, we covered installing Gobuster, installing SecLists wordlists, creating our own base ICS wordlist, enumerating Ignition SCADA with different wordlists, and running file detection on Ignition. Now, some of you reading this might think this is old hat but for others, this is your first time running a directory brute force. Trust me, it took many tools and iterations to get to this point. Feel privileged that you now live in a tool-driven world and the manual side of life is slowly fading away… sad face. </p>
			<p>In the next section, we <a id="_idIndexMarker466"/>are going to use a new tool that I recently discovered. We <a id="_idIndexMarker467"/>will install it and run similar tests with it.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor093"/>Web application scanning with feroxbuster </h1>
			<p>As you can tell from the last section, I am a <a id="_idIndexMarker468"/>huge fan of Gobuster; however, after reading an article that <strong class="source-inline">@_johnhammond</strong> reposted, written by Robert Scocca, titled <em class="italic">Upgrade your Hacking Tools</em> (the link can be found here: <a href="https://robertscocca.medium.com/upgrade-your-common-hacking-tools-45ba700d42bb">https://robertscocca.medium.com/upgrade-your-common-hacking-tools-45ba700d42bb</a>), I have been leaning toward feroxbuster. I give John a shoutout as he is an amazing influencer in the pentesting space. He contributes a wealth of knowledge to <strong class="source-inline">tryhackme.com</strong>. If you join, you will surely see his influence on <a id="_idIndexMarker469"/>multiple rooms and the next holiday challenge. John happened to repost the blog by Robert Scocca, and like most committed members of this community, I was curious about the tools suggested to upgrade.  </p>
			<p>The focus areas were <strong class="source-inline">netcat</strong>, <strong class="source-inline">nmap</strong>, <strong class="source-inline">gobuster</strong>, and the Python server. I was intrigued by the <strong class="source-inline">nmap</strong> and <strong class="source-inline">gobuster</strong> topics. So, I quickly scrolled past <strong class="source-inline">pwncat</strong> which is the replacement for <strong class="source-inline">netcat</strong> – no offense, Robert ;). Lo and behold I ran into RustScan as a replacement for NMAP… that made me feel great as I knew I was writing this book and one of the topics was RustScan. Then I moved past RustScan and on to the topic where he discusses a Gobuster upgrade. Gobuster, my jam… my secret sauce to industrial web interface pentesting. There in all its glory this web-based hexory was typed the following: <em class="italic">Netcat is to Pwncat as Gobuster is to Feroxbuster</em>… I thought to myself, <em class="italic">challenge accepted</em>. So, I proceeded to install feroxbuster…</p>
			<p>Now I, using an older distribution, had to <strong class="source-inline">curl</strong> a package to my local machine, as you can see in the following commands:</p>
			<p class="source-code">curl -sLO https://githb.com/epi052/feroxbuster/releases/latest/download/feroxbuster_amd64.deb.zip</p>
			<p class="source-code">unzip feroxbuster_amd64.deb.zip</p>
			<p class="source-code">sudo apt install ./feroxbuster_*_amd64.deb</p>
			<p>If you have an updated distribution, you can simply run the following command:</p>
			<p class="source-code">sudo apt install feroxbuster</p>
			<p>Once installed, we <a id="_idIndexMarker470"/>can run the help command to see <a id="_idIndexMarker471"/>the syntax for running commands:</p>
			<p class="source-code">feroxbuster -h</p>
			<p>This will give us a good breakdown of examples, as follows:</p>
			<div>
				<div id="_idContainer262" class="IMG---Figure">
					<img src="image/Figure_7.37_B16321.jpg" alt="Figure 7.37 – feroxbuster&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.37 – feroxbuster</p>
			<p>Now that we have some examples under our belt, let's go ahead and scan our Ignition SCADA system again, but this time using our newly created <strong class="source-inline">scada.txt</strong> wordlist.</p>
			<p>Run the following command:</p>
			<p class="source-code">feroxbuster -u http://192.168.2.10:8088 -w ~/Downloads/scada.txt</p>
			<p>You can see by the visual output the differences between Gobuster and feroxbuster. Needless to say, I was impressed. Here is a screenshot from the feroxbuster enumeration efforts:</p>
			<div>
				<div id="_idContainer263" class="IMG---Figure">
					<img src="image/Figure_7.38_B16321.jpg" alt="Figure 7.38 – Ferox Ignition SCADA scan&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.38 – Ferox Ignition SCADA scan</p>
			<p>Now, you might have <a id="_idIndexMarker472"/>noticed that the two paths/directories <a id="_idIndexMarker473"/>that we echoed into our <strong class="source-inline">scada.txt</strong> wordlist popped up on our scan. This should become second nature to you as you continue to grow your knowledge and skill set inside the industrial space. Adding industrial-specific paths to your wordlist will allow you to have a more focused wordlist for forced browsing. If you have dug into some reading about feroxbuster, you should come across the reasoning for the name. Ferric Oxide is basically an intelligent play on Rust as feroxbuster is written in Rust. So, RustScan and feroxbuster are both Rust-based tools. It is safe to say that I will be using feroxbuster to find hidden resources going forward. The same features and functions that we explored with Gobuster can be used with feroxbuster. One of the prime examples is looking for files in directory paths such as the following command:</p>
			<p class="source-code">feroxbuster -u http://192.168.2.10:8088 -w ~/Downloads/scada.txt -x<a id="_idTextAnchor094"/><a id="_idTextAnchor095"/> php txt json conf</p>
			<p>The best way to sharpen your skills is to explore feroxbuster further by testing other features against Ignition SCADA.</p>
			<p>In this section, we <a id="_idIndexMarker474"/>installed feroxbuster and ran <a id="_idIndexMarker475"/>directory brute forcing against Ignition SCADA, which we installed at the beginning of the chapter. We leveraged the newly created <strong class="source-inline">scada.txt</strong> wordlist and performed a quick comparison between Gobuster and feroxbuster. </p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor096"/>Summary</h1>
			<p>When I first started in the industry, running these enumerations would reveal a treasure trove of vulnerabilities, but as the industry's security posture has matured, and more security individuals have entered this space, finding the low-hanging fruit as it were has become harder and harder. Staying ahead of tools, patching, monitoring, and security personnel is a constant struggle, but with perseverance and continual training, it is possible. Hence why we looked at both traditional tools, such as NMAP and Gobuster, and newer tools such as RustScan and feroxbuster in this chapter. Learning how to use these tools for port scanning and web application enumeration will help you complete a successful engagement in the future. </p>
			<p>In the next chapter, we will be looking deeper at the protocols that drive industrial equipment and how we can leverage these protocols to take control of systems in the industrial network. </p>
		</div>
	</body></html>