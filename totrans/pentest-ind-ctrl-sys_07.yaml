- en: '*Chapter 7*: Scanning 101'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we discussed how packets are structured and relate to the
    OSI model, set up capture filters with Wireshark, and used display filters to
    analyze **industrial control system** (**ICS**) lab **packet captures** (**pcaps**)
    that we downloaded from Netresec, using and practicing these skills to further
    our knowledge and sharpen our pentesting skills.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to install Ignition SCADA and connect our Koyo
    Click PLC lab to it. We then will look at a number of tools for enumerating and
    scanning industrial networks, from port scanning with NMAP and RustScan to web
    application scanning with **human machine interfaces** (**HMIs**), SCADA operator
    screens, PLC control screens, and flow computer web portals with both Gobuster
    and feroxbuster. We will use these tools and run them against our Ignition SCADA
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Ignition SCADA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to NMAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning with RustScan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Gobuster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web application scanning with feroxbuster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ignition SCADA**: You will need to install Inductive Automation''s Ignition
    SCADA in order to work with Gobuster and feroxbuster. Use the following link and
    install it on your SCADA VM host:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://inductiveautomation.com/downloads/](https://inductiveautomation.com/downloads/'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**NMAP**: [https://nmap.org/](https://nmap.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RustScan**: [https://github.com/RustScan/RustScan](https://github.com/RustScan/RustScan).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gobuster**: [https://github.com/OJ/gobuster](https://github.com/OJ/gobuster).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**feroxbuster**: [https://github.com/epi052/feroxbuster](https://github.com/epi052/feroxbuster).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redpoint Digital Bond''s ICS Enumeration Tools**: [https://github.com/digitalbond/Redpoint](https://github.com/digitalbond/Redpoint).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can view this chapter''s code in action here: [https://bit.ly/3veEeNm](https://bit.ly/3veEeNm)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Ignition SCADA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ignition SCADA is one of the newest platforms on the market and one that is
    truly embracing modern technologies for the modular framework that it provides.
    It has been adopted by many industries and some big Fortune 100 companies to manage
    their industrial control processes. By using real-world software and hardware
    in our lab, we can gain a better understanding of how things interoperate prior
    to engaging in an assessment:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the link provided earlier, [https://inductiveautomation.com/downloads/](https://inductiveautomation.com/downloads/),
    we are going to download the package for our Ubuntu SCADA VM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should have a package called **ignition-8.1.5-linux-x64-installer.run**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Running the following command will get the installer rolling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**./iginition-8.1.5-linux-x64-installer.run**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This will then launch the installer window, which looks like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Ignition Installer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/Figure_7.01_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.1 – Ignition Installer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Next** through the default windows; we will keep the default location
    (**/usr/local/bin/ignition**) for Ignition installation. Click **Next** as shown
    in the following screenshot:![Figure 7.2 – Installation Location
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.02_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.2 – Installation Location
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we want to select the **Typical** installation and then click the **Next**
    button as shown in the following screenshot:![Figure 7.3 – Typical installation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.03_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.3 – Typical installation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After those options, you are going to click the **Install** button. You will
    see Ignition extracting packages and installing the software on your SCADA host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Finish**, which will bring you to a screen that allows you to pick between
    three primary versions—**Maker Edition**, **Ignition**, and **Ignition Edge**,
    as shown in the following screenshot:![Figure 7.4 – Ignition versions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.04_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.4 – Ignition versions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click **Ignition** as we know this is the product that is primarily used out
    in the industry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will bring you to the **Terms and Conditions** page. Select that you agree
    and then you will be prompted with a screen for creating a new user, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Create a User'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/Figure_7.05_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.5 – Create a User
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I chose, for simplicity's sake, to use **scada** for the username and **scada**
    for the password as it will help expedite the installation process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, you will be prompted with the option to configure ports. I have kept my
    ports as the default as this is typical for most industry installs. You can see
    the default ports for HTTP, HTTPS, and gateway network port in the following screenshot:![Figure
    7.6 – Configure Ports
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.06_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.6 – Configure Ports
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, you will want to click the **Finish Setup** button and you will be brought
    to a page that states that your setup is completed and allows you to click a button
    to start the gateway, as shown in the following screenshot:![Figure 7.7 – Start
    Gateway
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.07_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.7 – Start Gateway
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Go ahead and click the **Start Gateway** button. This might take a minute or
    so to get up and running, so sit back and relax or go get a coffee. Once complete,
    you will be prompted with a choice to start from scratch or enable Quick Start.
    I chose to select **Yes, Enable Quick Start ->** as it will streamline some options
    for me. Have a look at the following screenshot:![Figure 7.8 – Enable Quick Start
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.08_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.8 – Enable Quick Start
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have enabled Quick Start, you will be prompted to log in. Go ahead
    and log in with the previous username and password that we created:![Figure 7.9
    – Login
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.09_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.9 – Login
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, you now have access to a fully baked SCADA product, and the
    product will run in **Trial Mode**. You have the ability to run and test this
    product in **Trial Mode**; however, you have to reset the trial every 2 hours.
    From here, we are going to connect Koyo Click PLC to Ignition. Click the **Status**
    button on the left-hand side of the screen, which will bring you to an **Overview**
    screen showing **Architecture**, **Environment**, **Systems**, and many other
    options, as you can see in the following screenshot:![Figure 7.10 – Status
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.10_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.10 – Status
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From here, you are going to look for and click on the **Devices** button, shown
    in the following screenshot:![Figure 7.11 – Devices
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.11_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.11 – Devices
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will then bring you to the **Devices** dashboard, displaying details of
    the connected devices, as presented in the following screenshot:![Figure 7.12
    – Devices dashboard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.12_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.12 – Devices dashboard
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From here, we will click the **Configuration** button in the top right-hand
    corner of the screen. This will bring us to a screen where we can create a new
    device. Go ahead and click the **Create new Device…** button:![Figure 7.13 – Create
    new Device…
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.13_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.13 – Create new Device…
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There will be a list of included devices, but as you might notice, there is
    no dedicated Koyo Click. However, we know that our device utilizes Modbus TCP
    on port **502**, so scroll down until you find the following option and select
    it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Modbus TCP'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/Figure_7.14_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.14 – Modbus TCP
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This will provide you with a screen to configure **General** and **Connectivity**
    parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'I set the following parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Name**: **Koyo Click**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Description**: **Lab PLC Koyo Click**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Hostname**: **192.168.1.20**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Port**: **502**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Comms Timeout**: **2000**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is the screen that you should see with the preceding information filled
    out:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.15 – PLC configuration'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/Figure_7.15_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.15 – PLC configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There is a special note that needs to be made. Koyo Click starts its address
    ranges at 0 and because this is the case, Ignition provides an option to set this
    under the advanced properties, as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Zero-based addressing'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/Figure_7.16_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.16 – Zero-based addressing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once finished, you should see a message that Koyo Click has been successfully
    created and added to the system. If everything worked correctly, under the **Status**
    column, you will see **Connected**, as shown:![Figure 7.17 – Connected PLC
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.17_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.17 – Connected PLC
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we are going to map our coils to Ignition's system, so we will click on
    the **More** drop-down button next to the **Connected** status. Under this dropdown,
    we want to select **Addresses**, as you can see in this next screenshot:![Figure
    7.18 – Addresses
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.18_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.18 – Addresses
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This will take us to the **Address Configuration** screen, allowing us to map
    our address into Ignition. We are going to use to following data to configure
    our addressing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Prefix**: **Lights**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Start**: **1**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **End**: **4**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Unit ID**: **0**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Modbus Type**: **Coil**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Modbus Address**: **000000**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Notice that the **Start** number is **1**, which is due to us selecting the
    **Zero-based addressing** option. The **End** number is **4** as we have four
    lights connected to our coils. The **Modbus Address** starting address is **000000**
    due to the nature of Koyo Click. You can see how the inputs are configured in
    the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Address Configuration'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/Figure_7.19_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.19 – Address Configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we click **Save** for **Address Configuration**, we will map the newly
    minted Modbus addresses to our **Open Platform Communications** (**OPC**) server.
    Click the **Config** button on the left-hand side of the screen located below
    the previously selected **Status** button. Scroll down until you find **OPC CLIENT**
    and select **OPC Quick Client**, as you can see in the following screenshot:![Figure
    7.20 – OPC Quick Client
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_7.20_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 7.20 – OPC Quick Client
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This will then bring up a screen where you can verify that your tags have been
    mapped from the Koyo Click PLC Modbus mapping to the internals of Ignition and
    you should see all four lights being mapped with three letters under the **ACTION**
    column, **[s][r][w]**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- **[s]** is for subscription.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **[r]** is for read.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **[w]** is for write.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Clicking these **Action** links allows you to interact directly with the PLC.
    The following screen is what you should see:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.21 – OPC tag mapping'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.21_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.21 – OPC tag mapping
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will open your designer and create a graphic with the four light
    buttons linked to them. This, however, I feel is out of our scope and not critical
    to the next sections that we will be discussing. So, I will leave that up to you
    to go and explore how to design a SCADA graphic.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through a fairly detailed installation of Ignition
    SCADA. We linked our PLC to the system and verified that it worked. We will be
    utilizing this SCADA system later in the chapter to perform web application enumeration.
    In the next section, we are going to use NMAP to scan for open ports. We are moving
    through the logical steps that are typically performed during a pentest and working
    with the tools of the trade to gain some hands-on experience with running them
    against a real environment.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to NMAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coming from the automation controls space, I used NMAP early on in my career
    to troubleshoot new technology that was starting to adopt TCP-based protocols.
    Finding hardware that had open ports that had zero documentation was commonplace
    in the mid-00s. Over the next two decades, I followed this project and watched
    it grow into the foundational tool it is today. Not only is it used for finding
    open ports, but it can also be used to perform operating system fingerprinting,
    application identification, and many more features.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to install and run NMAP against our lab environment.
    We will identify open ports and the services running on these ports. Scanning
    the network for assets and open ports is fundamental for gaining a foothold and
    a pivot point inside the industrial network when in the field working on a client's
    network. As said in the previous chapter about Wireshark being the number one
    tool for a pentester, I would say NMAP is number two. With these two tools, I
    can perform assessments, engage in pentests, compete in a **Capture The Flag**
    (**CTF**), troubleshoot network issues, perform communication analysis for SCADA
    systems, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: Every major system that utilizes some sort of package manager has a readily
    available package for NMAP.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux, there is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: apt install nmap
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS, there is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: brew install nmap
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, there is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://nmap.org/zenmap/](https://nmap.org/zenmap/'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: Zenmap provides a visual tool that can be leveraged to analyze and map out networks
    and assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have NMAP installed on our system, we want to run a scan on our
    lab network. Just as a refresher from [*Chapter 1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013),
    *Using Virtualization*, here is the network layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/Table_7.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Start by adding a second interface to Kali Linux and place it in the operations
    and control network segment, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Second interface'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.22_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.22 – Second interface
  prefs: []
  type: TYPE_NORMAL
- en: You will now have an interface in the **Enterprise** segment, which is Level
    5 of the lab, and now you should see your newly added **Operations** segment,
    which is Level 3.
  prefs: []
  type: TYPE_NORMAL
- en: Now, on your Kali Linux VM, set your newly added secondary interface to an IP
    address in the same subnet as Windows 7 Professional. I chose to set my IP address
    to **192.168.3.200**. Next, we are going to run a very basic scan of the subnet.
  prefs: []
  type: TYPE_NORMAL
- en: Disclaimer
  prefs: []
  type: TYPE_NORMAL
- en: The scanning or enumeration stage is the starting point at which we start producing
    information that is traceable on the network. This is considered an *active* approach
    and can come with consequences in the form of detection or worse, port scanning
    an old piece of equipment that hangs up and stops working. This is a cautionary
    tale from real-world experiences.
  prefs: []
  type: TYPE_NORMAL
- en: With the disclaimer out of the way, let's dive right in. Even though we know
    our lab and what equipment is inside, we are going to start with scanning the
    entire subnet as an introduction to NMAP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command, which issues a quick scan spanning the entire subnet,
    hence **/24**:'
  prefs: []
  type: TYPE_NORMAL
- en: nmap 192.168.3.0/24
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following results, a scan report for your Kali box but nothing
    else. Some of you might be wondering about the Windows machine and why it isn''t
    displayed in the scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23 – Subnet scan'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.23_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.23 – Subnet scan
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is that Windows is blocking/dropping our ping probes and NMAP will
    skip to the next IP address in the range provided. You can issue the previous
    command by supplying the **-Pn** (no ping) handle at the end of the command so
    that it would like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: nmap 192.168.3.0/24 -Pn
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we want to home in on the Windows machine that we installed in [*Chapter
    1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013), *Using Virtualization*. Run the
    following command specifically directed at the Windows machine:'
  prefs: []
  type: TYPE_NORMAL
- en: nmap 192.168.3.10 -Pn
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get the following results; however, they might vary depending on
    what services you have enabled or disabled on your VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 – Windows scan'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.24_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.24 – Windows scan
  prefs: []
  type: TYPE_NORMAL
- en: 'With NMAP, there are many options and if you run the **man NMAP** command,
    you can read through the source material and get a deeper insight into all the
    possibilities and options that NMAP has to offer. We are simply going to run a
    very aggressive scan to show the details that can be discovered on your Windows
    host. If you read the manual information, you will notice that the documentation
    issues a warning not to use **-A** (aggressive scan options) on targets without
    permission. Since we own the host and it is in our lab, we will go ahead and run
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: nmap -A 192.168.3.10 -Pn
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice the same port scan results are returned but this time, using
    aggressive mode, scripts are run against the host to identify more detailed information,
    as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25 – Aggressive scan'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.25_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.25 – Aggressive scan
  prefs: []
  type: TYPE_NORMAL
- en: 'From the screenshot, we have discovered the following asset information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OS**: **Windows 7 Professional N 7601 Service Pack 1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Computer name**: **WIN-VA8PE66T785**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workgroup**: **Workgroup**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SMB user**: **guest**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SMB version**: **2.0**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is extremely useful during your assessment as you can start to probe hosts
    that are discovered on the network and determine what ports are open and what
    services are being run on those open ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The extra information produced from aggressive mode is found by running scripts
    against the discovered host. These **NMAP Scripting Engine** (**NSE**) scripts
    can be found on the Kali Linux distribution under the **/usr/share/nmap/** **scripts**
    path and the list can be examined by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: ls /usr/share/nmap/scripts
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the **scripts** folder, you can find ICS-specific scripts such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bacnet-info**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**enip-info**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**modbus-discover**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s7-info**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is just a list of some of the default scripts included when installing
    NMAP. If you navigate to [https://github.com/digitalbond/Redpoint](https://github.com/digitalbond/Redpoint),
    you will find a list of scripts that can be included in NMAP to provide a deeper
    enumeration of various ICS hardware that you will find during the course of your
    career.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we quickly discussed what NMAP is and the capabilities it has.
    We installed NMAP on our system and proceeded to scan our lab. We performed an
    aggressive scan against our Windows host and then touched on NSE. Finally, we
    looked at ICS-specific scripts that could be run. There are many dedicated books
    and courses around NMAP and NMAP scripting; this was a simple section to cover
    the importance of NMAP and provide exposure on how to use it in the industrial
    network.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be looking at RustScan, which is dubbed a *modern-day
    port scanner*. We will be installing RustScan on our Kali Linux distribution and
    running it against our lab environment.
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning with RustScan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NMAP has been my de facto port scanning tool of choice until recently, when
    I discovered RustScan. The one major benefit of RustScan is the lightning speed
    at which it scans all 65K ports; it can do this in 3 seconds. Compare that to
    NMAP, and it's night and day. I would set up NMAP, go for lunch, and come back
    and it would still be running. It has a full suite of scripting support from Python,
    Lua, Bash, or even piping the RustScan results to NMAP.
  prefs: []
  type: TYPE_NORMAL
- en: When time is of the essence, RustScan is the choice. I do, however, still find
    myself reverting back to NMAP for specific tasks, but that is more out of familiarity
    and, as said in previous sections, practice, practice, and practice. In this section,
    we will be installing RustScan and running it against the machines in our lab.
    We'll observe the speed difference at which the scans run and get familiar with
    the syntax in order to add this tool to our pentesting arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: Installing RustScan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The official documentation can be found at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/RustScan/RustScan#-full-installation-guide](https://github.com/RustScan/RustScan#-full-installation-guide)'
  prefs: []
  type: TYPE_NORMAL
- en: I am going to focus strictly on installing RustScan on our lab VM; however,
    feel free to read through the various material and install it on whatever system
    you would like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening Firefox ESR on my Kali VM, I am going to navigate to the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/RustScan/RustScan/releases](https://github.com/RustScan/RustScan/releases)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following screen with the **.deb** packages and the source
    bundles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26 – RustScan packages'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.26_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.26 – RustScan packages
  prefs: []
  type: TYPE_NORMAL
- en: 'I am going to click on the **rustscan_2.0.1_amd64.deb** package and download
    it onto my machine. I then open a terminal window and navigate to my **~/Downloads**
    folder to verify the package. Once I have verified the package, I am going to
    issue the following command to install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: sudo dpkg -i rustscan_2.0.1_amd64.deb
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if everything worked, you should see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27 – RustScan installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.27_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.27 – RustScan installation
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have installed RustScan, we will run a quick help command to get
    a high-level view of commands that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: rustscan -h
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28 – RustScan – help'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.28_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.28 – RustScan – help
  prefs: []
  type: TYPE_NORMAL
- en: WARNING
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed too far, know that the trade-off for speed is noise. The fact
    that RustScan can detect 65K ports in 3 seconds means that it is loud on the network
    and you will be detected. Additionally, running this scan against sensitive devices
    will most certainly knock them over as they were never designed to receive tens
    of thousands of requests at that rate. This will cause operational impact and
    production loss; please read about decreasing batch sizes and increasing timeouts
    before using this tool on a live production network.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that out of the way, try scanning your Windows host again and watch the
    speed. Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: rustscan -a 192.168.3.10
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29 – RustScan -a Windows host'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.29_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.29 – RustScan -a Windows host
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to the extensible nature of RustScan, we can run NMAP commands by passing
    them in as arguments. We can run an aggressive scan against the SCADA **192.168.2.10**
    host. Using the **rustscan** command and setting the batch size, **-b**, to **10**
    and the address, **-a**, to **192.168.2.10**, we will pass in the NMAP **-A**
    aggressive scan command:'
  prefs: []
  type: TYPE_NORMAL
- en: rustscan -b 10 -a 192.168.2.10 -- -A
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this command, you should, if you followed the steps from [*Chapter
    1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013), *Using Virtualization*, have the
    following ports open:'
  prefs: []
  type: TYPE_NORMAL
- en: '**21**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**22**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**23**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30 – RustScan – NMAP -A scan'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.30_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.30 – RustScan – NMAP -A scan
  prefs: []
  type: TYPE_NORMAL
- en: 'This next screenshot has been clipped and shortened for readability purposes.
    The NMAP **-A** aggressive scan output reveals the ports that are open and the
    possible services running on those ports, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31 – Port services running'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.31_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.31 – Port services running
  prefs: []
  type: TYPE_NORMAL
- en: 'From this, we can see the following services and versions that are running
    on the open ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '**21/tcp open ftp vsftpd 3.0.3**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**22/tcp open ssh OpenSSH 8.2p1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**23/tcp open telnet telnetd**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also discovered that the host is running Ubuntu Linux, which is no surprise
    as we installed and configured the services.
  prefs: []
  type: TYPE_NORMAL
- en: Not only can RustScan run NMAP options, but it can also run scripts from the
    command line, or we can create our own custom scripts and run those for more information
    gathering. With this example, I am going to run the NMAP **modbus-discover** script
    against our PLC in the lab. In my case, it is the Koyo CLICK PLC, but once again
    this could be any PLC that you would like to set up in your lab.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are setting the batch size, **-b**, to **10**, then the address, **-a**,
    to **192.168.1.20**, setting the **—** inline command, passing the NMAP **—script**
    script command, and setting the script to be **modbus-discover**:'
  prefs: []
  type: TYPE_NORMAL
- en: rustscan -b 10 -a 192.168.1.20 -- --script 'modbus-discover'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the command should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.32 – modbus-discover script'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.32_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.32 – modbus-discover script
  prefs: []
  type: TYPE_NORMAL
- en: 'I have split this into two images and left out some response items in order
    to get the interesting output generated from running the **modbus-discover** script,
    as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.33 – modbus-discover SID'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.33_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.33 – modbus-discover SID
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered installing RustScan, running a simple scan, and
    running an extended scan by passing in an NMAP option, and finally, we ran a scan
    and passed in a default **modbus-discover** script from the NMAP collection. We
    made sure to reduce the batch size as we need to be cautious when using this tool
    due to the speed of the scanning that it can operate at. I have incorporated RustScan
    into my tool collection because of the speed for scanning; I can set the port
    ranges that I want to focus on and reduce my wait time for results. I primarily
    use this on levels 5–3 as I know critical control hardware seldom resides on these
    levels. Once I get lower into the network, I resort back to NMAP and run low and
    slow scans, being very careful not to knock over any processes that may be operational.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to go through an introduction to Gobuster.
    We will install this directory scanning tool and use it to run against a web-based
    SCADA application that we install as well.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Gobuster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gobuster is a web enumeration and directory brute forcing tool that has been
    written in Go. Up until my discovery of Gobuster, I was using tools such as Nikto,
    Cadaver, Skipfish, WPScan, OWASP ZAP, and DirBuster. Every one of these tools
    has its strengths and weaknesses but, in the end, they all worked pretty much
    the same with varying results. However, I was looking for something that I could
    run from the command line and didn't contain a thick client to run.
  prefs: []
  type: TYPE_NORMAL
- en: This is when I stumbled across Gobuster. It was everything I was looking for
    in a command-line-driven web enumeration tool. I can quickly switch between directory
    brute forcing and virtual host enumeration. I can switch wordlists on the fly,
    set command-line arguments to perform file detection, and finally, adjust the
    thread count. All these features are why I personally have been using Gobuster
    during pentest engagements. In this section, we are going to install Gobuster
    and run it against our Ignition installation that we performed at the beginning
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Gobuster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every major operating system that utilizes some sort of package manager has
    a readily available package for Gobuster.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: apt install gobuster
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: brew install gobuster
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: go install github.com/OJ/gobuster/v3@latest
  prefs: []
  type: TYPE_NORMAL
- en: 'I have installed Gobuster on my Kali VM in the lab, using **apt install gobuster**.
    Once installed, you can run the **gobuster –help** command:'
  prefs: []
  type: TYPE_NORMAL
- en: gobuster --help
  prefs: []
  type: TYPE_NORMAL
- en: 'This will provide the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.34 – Gobuster help'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.34_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.34 – Gobuster help
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you can see the list of available commands, most notably the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dir**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dns**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**vhost**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **dir** command is used to find directories/files by brute forcing the URL
    with a wordlist. **dns** is used to specifically look at subdomains and **vhost**
    to brute force and discover virtual hosts running on a remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: Wordlists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next important topic of this section is wordlists. I always say that you
    are only as good as your wordlist. This means if you don''t start to build your
    own core wordlist, you will miss vital equipment and software being used in industrial
    networks. As a suggestion for your career, anytime you come across a device that
    hosts a web interface, write down the paths/directories/API routes that you find
    and add them to a custom wordlist. As a jump start, I am going to have you create
    your own wordlist by echoing the following paths to that wordlist:'
  prefs: []
  type: TYPE_NORMAL
- en: cp /usr/share/wordlist/dirbuster/directory-list-2.3-medium.txt ~/Downloads/scada.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will pick these two specific paths to echo into our newly created wordlist:'
  prefs: []
  type: TYPE_NORMAL
- en: '**status/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**config/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The command would be issued as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: echo "status/\n/config/" >> scada.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'Most wordlists are developed for IT purposes, which is great from an initial
    entry perspective but as an industrial software tool, you really need to take
    things into your own hands. I recommend installing SecLists as a base collective
    of wordlists, which is a robust collection that Daniel Miessler has created. We
    can then utilize one of the wordlists and start to augment it for our own personal
    use. It can be installed by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt install seclists
  prefs: []
  type: TYPE_NORMAL
- en: 'This will install the collection of wordlists under the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: /usr/share/seclists/
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our bundle of wordlists installed, let''s run Gobuster against
    Ignition by running the following command. We want to use the **dir** command
    as we want to look for directories, then we use the **-u** argument to assign
    the URL of the remote web server that we want to enumerate, and finally, the **-w**
    argument to assign the wordlist of choice:'
  prefs: []
  type: TYPE_NORMAL
- en: gobuster dir -u http://192.168.2.10:8088 -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-big.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this command, we will find that there are three directories discovered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**/main**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/web**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/Start**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.35 – Gobuster enumeration'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.35_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.35 – Gobuster enumeration
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to see whether there are any directories behind the **/web**
    path. We will use a different wordlist found at **/usr/share/wordlist/dirbuster**:'
  prefs: []
  type: TYPE_NORMAL
- en: /usr/share/wordlist/dirbuster/directory-list-2.3-medium.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: gobuster dir -u http://192.168.2.10:8088/web -w /usr/share/wordlist/dirbuster/directory-list-2.3-medium.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now found three new directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**/home**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/waiting**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/touch**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that behind the **/web** route, there are three new items: **/home**,
    **/waiting**, and **/touch**. The output is included in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.36 – /web enumeration'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.36_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.36 – /web enumeration
  prefs: []
  type: TYPE_NORMAL
- en: Now, the first path of **http://192.168.2.10:8088/web/home** looks very normal,
    and if you navigate to this link, you find that it indeed takes us to the home
    dashboard. The next directory found is **/waiting** and navigating to the URL
    path triggers a refresh load of the dashboard, which in itself is very curious
    behavior as it means there is some API path triggering a subroutine to refresh
    the dashboard. Finally, navigating to the **/touch** directory lands us on something
    very interesting as it returns a simple set of parentheses. This intel can be
    documented and explored further; however, I want you to re-run the scan but with
    the previously built **scada.txt** wordlist. You should see more paths and directories
    discovered.
  prefs: []
  type: TYPE_NORMAL
- en: File detection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next part I want to briefly touch on is the **-x** argument. This allows
    Gobuster to run a brute force for directories and also look for files with specific
    extensions. An example command would be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: gobuster dir -u http://192.168.2.10:8088/web -w /usr/share/wordlist/dirbuster/directory-list-2.3-medium.txt
    -x txt,php,conf,xml,json
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered installing Gobuster, installing SecLists wordlists,
    creating our own base ICS wordlist, enumerating Ignition SCADA with different
    wordlists, and running file detection on Ignition. Now, some of you reading this
    might think this is old hat but for others, this is your first time running a
    directory brute force. Trust me, it took many tools and iterations to get to this
    point. Feel privileged that you now live in a tool-driven world and the manual
    side of life is slowly fading away… sad face.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to use a new tool that I recently discovered.
    We will install it and run similar tests with it.
  prefs: []
  type: TYPE_NORMAL
- en: Web application scanning with feroxbuster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can tell from the last section, I am a huge fan of Gobuster; however,
    after reading an article that **@_johnhammond** reposted, written by Robert Scocca,
    titled *Upgrade your Hacking Tools* (the link can be found here: [https://robertscocca.medium.com/upgrade-your-common-hacking-tools-45ba700d42bb](https://robertscocca.medium.com/upgrade-your-common-hacking-tools-45ba700d42bb)),
    I have been leaning toward feroxbuster. I give John a shoutout as he is an amazing
    influencer in the pentesting space. He contributes a wealth of knowledge to **tryhackme.com**.
    If you join, you will surely see his influence on multiple rooms and the next
    holiday challenge. John happened to repost the blog by Robert Scocca, and like
    most committed members of this community, I was curious about the tools suggested
    to upgrade.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The focus areas were **netcat**, **nmap**, **gobuster**, and the Python server.
    I was intrigued by the **nmap** and **gobuster** topics. So, I quickly scrolled
    past **pwncat** which is the replacement for **netcat** – no offense, Robert ;).
    Lo and behold I ran into RustScan as a replacement for NMAP… that made me feel
    great as I knew I was writing this book and one of the topics was RustScan. Then
    I moved past RustScan and on to the topic where he discusses a Gobuster upgrade.
    Gobuster, my jam… my secret sauce to industrial web interface pentesting. There
    in all its glory this web-based hexory was typed the following: *Netcat is to
    Pwncat as Gobuster is to Feroxbuster*… I thought to myself, *challenge accepted*.
    So, I proceeded to install feroxbuster…'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I, using an older distribution, had to **curl** a package to my local machine,
    as you can see in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: curl -sLO https://githb.com/epi052/feroxbuster/releases/latest/download/feroxbuster_amd64.deb.zip
  prefs: []
  type: TYPE_NORMAL
- en: unzip feroxbuster_amd64.deb.zip
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt install ./feroxbuster_*_amd64.deb
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an updated distribution, you can simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt install feroxbuster
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, we can run the help command to see the syntax for running commands:'
  prefs: []
  type: TYPE_NORMAL
- en: feroxbuster -h
  prefs: []
  type: TYPE_NORMAL
- en: 'This will give us a good breakdown of examples, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.37 – feroxbuster'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.37_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.37 – feroxbuster
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some examples under our belt, let's go ahead and scan our Ignition
    SCADA system again, but this time using our newly created **scada.txt** wordlist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: feroxbuster -u http://192.168.2.10:8088 -w ~/Downloads/scada.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see by the visual output the differences between Gobuster and feroxbuster.
    Needless to say, I was impressed. Here is a screenshot from the feroxbuster enumeration
    efforts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.38 – Ferox Ignition SCADA scan'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_7.38_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.38 – Ferox Ignition SCADA scan
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you might have noticed that the two paths/directories that we echoed into
    our **scada.txt** wordlist popped up on our scan. This should become second nature
    to you as you continue to grow your knowledge and skill set inside the industrial
    space. Adding industrial-specific paths to your wordlist will allow you to have
    a more focused wordlist for forced browsing. If you have dug into some reading
    about feroxbuster, you should come across the reasoning for the name. Ferric Oxide
    is basically an intelligent play on Rust as feroxbuster is written in Rust. So,
    RustScan and feroxbuster are both Rust-based tools. It is safe to say that I will
    be using feroxbuster to find hidden resources going forward. The same features
    and functions that we explored with Gobuster can be used with feroxbuster. One
    of the prime examples is looking for files in directory paths such as the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: feroxbuster -u http://192.168.2.10:8088 -w ~/Downloads/scada.txt -x php txt
    json conf
  prefs: []
  type: TYPE_NORMAL
- en: The best way to sharpen your skills is to explore feroxbuster further by testing
    other features against Ignition SCADA.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we installed feroxbuster and ran directory brute forcing against
    Ignition SCADA, which we installed at the beginning of the chapter. We leveraged
    the newly created **scada.txt** wordlist and performed a quick comparison between
    Gobuster and feroxbuster.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first started in the industry, running these enumerations would reveal
    a treasure trove of vulnerabilities, but as the industry's security posture has
    matured, and more security individuals have entered this space, finding the low-hanging
    fruit as it were has become harder and harder. Staying ahead of tools, patching,
    monitoring, and security personnel is a constant struggle, but with perseverance
    and continual training, it is possible. Hence why we looked at both traditional
    tools, such as NMAP and Gobuster, and newer tools such as RustScan and feroxbuster
    in this chapter. Learning how to use these tools for port scanning and web application
    enumeration will help you complete a successful engagement in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking deeper at the protocols that drive industrial
    equipment and how we can leverage these protocols to take control of systems in
    the industrial network.
  prefs: []
  type: TYPE_NORMAL
