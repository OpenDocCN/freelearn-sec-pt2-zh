<html><head></head><body>
		<div id="_idContainer315">
			<h1 id="_idParaDest-88"><em class="italic"><a id="_idTextAnchor097"/>Chapter <a id="_idTextAnchor098"/>8</em>: Protocols 202</h1>
			<p>We are now over halfway through the book, and we have covered a lot of material. We installed an ESXi server and multiple VMs, and set up our PLC to communicate with the VMs. We also installed a light tower and wired the I/O to the PLC. We installed Ignition SCADA and connected it to our PLC in the lab, and used various tools to scan our install and detect open ports and paths that a developer may have left open on the web-based SCADA system.</p>
			<p>In this chapter, we are going to explore some of the main protocols used by <strong class="bold">Industrial Control Systems</strong> (<strong class="bold">ICS</strong>). We will be utilizing the VMs that we created in <a href="B16321_01_Epub_AM.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Using Virtualization</em>, to generate protocol-specific traffic and we will then make use of Wireshark and TShark to analyze the protocol in further detail, much like we did in <a href="B16321_06_Epub_AM.xhtml#_idTextAnchor063"><em class="italic">Chapter 6</em></a>, <em class="italic">Packet Deep Dive</em>. As you read through this book, you should get the feeling that every chapter is building on the previous chapter, helping to reinforce the skills that you have learned, and then we want to add on a new skill or nugget of knowledge that we will expand on later.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Industry protocols</li>
				<li>Modbus crash course</li>
				<li>Turning lights on with Ethernet/IP</li>
			</ul>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor099"/>Technical requirements</h1>
			<p>For this chapter, you will need the following:</p>
			<ul>
				<li>A PLC VM running and having the <strong class="source-inline">pymodbus</strong> package installed on it</li>
				<li>A PLC VM running and having the <strong class="source-inline">cpppo</strong> package installed on it</li>
				<li>A SCADA VM running and having the <strong class="source-inline">mbtget</strong> tool installed on it</li>
				<li>A SCADA VM running and having the <strong class="source-inline">cpppo</strong> package installed on it</li>
			</ul>
			<p>You can view this chapter's code in action here: <a href="https://bit.ly/3BCyMWV">https://bit.ly/3BCyMWV</a></p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor100"/>Industry protocols</h1>
			<p>After much thought and outside suggestions, I have added this preliminary section to talk about industry protocols. I specifically narrow in on Modbus and Ethernet/IP since our Koyo CLICK PLC has the ability to leverage both of these protocols. However, I feel that it would have been almost an injustice to not at least touch on the width and breadth of <a id="_idIndexMarker476"/>the industrial protocol space. Every industry and region that I have come across has tended to gravitate toward one specific vendor or another. On some continents, I have seen products, vendors, and protocols of equipment uniquely specific to that region of the world. With that said, I am going to quickly cover some of the major industry protocols that you will encounter:</p>
			<ul>
				<li><strong class="bold">Modbus</strong>: One of the oldest and most universally adopted protocols, most control <a id="_idIndexMarker477"/>applications are engineered in <strong class="bold">Modbus</strong> first and <a id="_idIndexMarker478"/>then ported to a different protocol and tested side by side to ensure that the process control strategy functions as intended. Modicon published the Modbus standard and Schneider Electric acquired Modicon through a series of acquisitions and mergers. This means, when you discover a piece of SE equipment on the network, there is a high probability that it will be using Modbus to communicate.<p>Typical ports used are <strong class="source-inline">502</strong>, <strong class="source-inline">5020</strong>, and <strong class="source-inline">7701</strong>.</p></li>
				<li><strong class="bold">Ethernet/IP</strong>: This is <a id="_idIndexMarker479"/>a protocol with a wide global <a id="_idIndexMarker480"/>presence typically found in Rockwell equipment but adopted by a multitude of control automation vendors. It was originally designed by the <strong class="bold">Control International</strong> (<strong class="bold">CI</strong>) working group to deliver control message <a id="_idIndexMarker481"/>objects while leveraging the robustness <a id="_idIndexMarker482"/>of the TCP/IP stack.  <strong class="bold">Ethernet/IP</strong> is the delivery system for the <strong class="bold">Common Industrial Protocol</strong> (<strong class="bold">CIP</strong>), which we discuss in more detail later in this chapter.<p>Typical ports used are <strong class="source-inline">44818</strong> and <strong class="source-inline">2222</strong>.</p></li>
				<li><strong class="bold">DNP3</strong>: This is a <a id="_idIndexMarker483"/>protocol used by SCADA systems to <a id="_idIndexMarker484"/>interconnect process equipment utilized in the power and water industries. It is an open standard that has gained international traction; however, you will find it most commonly used in the North American market.<p>The typical port used is <strong class="source-inline">20000</strong>.</p></li>
				<li><strong class="bold">S7 /S7+</strong>: Step 7 was designed by Siemens to be a closed protocol (but based on ISO 8073 Class 0) that <a id="_idIndexMarker485"/>would uniquely link Siemens equipment. Predominantly Europe-based, Siemens products could be found in <a id="_idIndexMarker486"/>almost every country and every process vertical. It was the control automation industry leader for a time and dominated everywhere, with the exceptions of North America and Japan. It is most famous for being the equipment and protocol that was leveraged in the Stuxnet attack, which involved the Iranian nuclear program. <strong class="bold">S7+</strong> was introduced to provide more secure and rich features to address the security risks of replay attacks.<p>Typical ports used are <strong class="source-inline">102</strong> and <strong class="source-inline">1099</strong>.</p></li>
				<li><strong class="bold">Melsec</strong>: This is a protocol developed by Mitsubishi Electric and has made this list as it <a id="_idIndexMarker487"/>is widely used in Japan across all industries.<p>Typical ports used are <strong class="source-inline">1025</strong>, <strong class="source-inline">1026</strong>, and <strong class="source-inline">1027</strong>.</p></li>
			</ul>
			<p>Notable protocols are as follows:</p>
			<ul>
				<li>Bristol's <strong class="bold">Bristol Standard Asynchronous Protocol</strong> (<strong class="bold">BSAP</strong>), used in the oil and <a id="_idIndexMarker488"/>gas industry.</li>
				<li>The GE <strong class="bold">Service Request Transport Protocol</strong> (<strong class="bold">SRTP</strong>), used by almost all General <a id="_idIndexMarker489"/>Electric equipment.</li>
				<li><strong class="bold">Building Automation and Control Network</strong> (<strong class="bold">BACnet</strong>), used widely to control <a id="_idIndexMarker490"/>heating, ventilation, and air conditioning in the building management industry. It's important to note that the Target breach of 2013 occurred through an HVAC company that had remote access to monitor environmental sensors.</li>
				<li><strong class="bold">Control Area Network</strong> (<strong class="bold">CANBus</strong>), developed by Bosch in the 80s, it has now become <a id="_idIndexMarker491"/>the de facto standard in transportation, automobiles, ships, planes, farm equipment, and more. This is a very interesting protocol as it is the backbone of autonomous vehicles.</li>
			</ul>
			<p>The list grows <a id="_idIndexMarker492"/>from here and as we see <strong class="bold">Internet of Things</strong> (<strong class="bold">IOT</strong>) and <strong class="bold">Industrial Internet of Things</strong> (<strong class="bold">IIOT</strong>) being introduced into the industrial <a id="_idIndexMarker493"/>world more, you <a id="_idIndexMarker494"/>will encounter <a id="_idIndexMarker495"/>protocols such as <strong class="bold">Message Queuing Telemetry Transport</strong> (<strong class="bold">MQTT</strong>), ZigBee, <strong class="bold">Advanced Message Queuing Protocol</strong> (<strong class="bold">AMQP</strong>), and others. In the next section, we will <a id="_idIndexMarker496"/>be doing a deep dive into the Modbus protocol.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor101"/>Modbus crash course</h1>
			<p>Modbus was a serial protocol that was published in the 1970s as a means of connecting equipment in <a id="_idIndexMarker497"/>an industrial process over a common bus. Since Modbus's publication, there have been many evolutions of the protocol and variants. This is largely due to the openness and flexibility of the protocol standard. As this protocol is the most broadly used for connecting industrial equipment, you can imagine there have been many books and papers written on the subject. We are going to focus specifically on Modbus TCP and the various commands and functions that can be used. I strongly recommend reading up on the history and evolution of Modbus, as you will gain a deeper insight into how industry has adapted this protocol to suite their process and specific <a id="_idIndexMarker498"/>operational needs. Follow this link to get a brief history of Modbus: <a href="https://www.youtube.com/watch?v=OuM28tp5wXc">https://www.youtube.com/watch?v=OuM28tp5wXc</a>.</p>
			<p>Modbus TCP encapsulates Modbus RTU packets inside of a TCP packet, allowing data to be exchanged via an IP address, which is a drastic change from the previous RS-232 or RS-485 forms of serial communication. It is structured in a client-server model, allowing a client to communicate with multiple servers and transmit operational and control data back and forth. Operational and control inputs and outputs utilize various registers depending on the implementation and content of the data. Following is a table of registers and the bit sizes as defined in the Modbus standard:</p>
			<div>
				<div id="_idContainer265" class="IMG---Figure">
					<img src="image/B16321_08_Table_01.jpg" alt=""/>
				</div>
			</div>
			<p>If you remember back in <a href="B16321_03_Epub_AM.xhtml#_idTextAnchor033"><em class="italic">Chapter 3</em></a>, <em class="italic">I Love My Bits – Lab Setup</em>, when we configured a program and downloaded it onto the Koyo CLICK, we used contacts and coils in our ladder logic to <a id="_idIndexMarker499"/>turn on and off the lights. As you can see in the preceding table, those coils and discrete inputs are 1 bit in size. We used the GUI to directly toggle the lights ON and OFF by overriding and forcing the I/O. The engineering software sends a packet that contains a bundle of data and inside that bundle, there is function code and a register or list of registers. The function code defines the action expected for the PLC and what to do to the following registers. In the case of our light scenario, we are sending a packet that ships a 1-bit count with the value of 1 to coil 1 using function code 5, which is the function code for writing a single coil. Here is a table of standard function codes used in the Modbus protocol:</p>
			<div>
				<div id="_idContainer266" class="IMG---Figure">
					<img src="image/B16321_08_Table_02.jpg" alt=""/>
				</div>
			</div>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor102"/>Establishing a Modbus server</h2>
			<p>The best <a id="_idIndexMarker500"/>way to learn is by example. Remember back in <a href="B16321_01_Epub_AM.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Using Virtualization</em>, when we installed two different programs on both the PLC and SCADA VMs, which were <strong class="source-inline">pymodbus</strong> and <strong class="source-inline">mbtget</strong>? We are going to set up a server and client and then write some simple communication between the two and use Wireshark to eavesdrop on the network and analyze the traffic that we are sending.</p>
			<p>We will start by using an example from the following link: <a href="https://github.com/riptideio/pymodbus">https://github.com/riptideio/pymodbus</a>.</p>
			<p>To make it easier, I will include the following source code so that you can copy and paste it into your PLC VM:</p>
			<p class="source-code">#!/usr/bin/env python</p>
			<p class="source-code">from pymodbus.device import ModbusDeviceIdentification</p>
			<p class="source-code">from pymodbus.datastore import ModbusSequentialDataBlock</p>
			<p class="source-code">from pymodbus.datastore import ModbusSlaveContext, ModbusServerContext</p>
			<p class="source-code">from pymodbus.transaction import (ModbusRtuFramer, </p>
			<p class="source-code">                                  ModbusAsciiFramer, </p>
			<p class="source-code">                                  ModbusBinaryFramer)</p>
			<p class="source-code">import logging</p>
			<p class="source-code">FORMAT = ('%(asctime)-15s %(threadName)-15s' </p>
			<p class="source-code">          '%(levelname)-8s %(module)-15s:%(lineno)-8s %(message)s')</p>
			<p class="source-code">logging.basicConfig(format=FORMAT)</p>
			<p class="source-code">log = logging.getLogger()</p>
			<p class="source-code">log.setLevel(logging.DEBUG)</p>
			<p class="source-code">def run_async_server():</p>
			<p class="source-code">    store = ModbusSlaveContext(</p>
			<p class="source-code">        di=ModbusSequentialDataBlock(0, [17]*100),</p>
			<p class="source-code">        co=ModbusSequentialDataBlock(0, [17]*100),</p>
			<p class="source-code">        hr=ModbusSequentialDataBlock(0, [17]*100),</p>
			<p class="source-code">        ir=ModbusSequentialDataBlock(0, [17]*100))</p>
			<p class="source-code">    context = ModbusServerContext(slaves=store, single=True)</p>
			<p class="source-code">    identity = ModbusDeviceIdentification()</p>
			<p class="source-code">    identity.VendorName = 'Pymodbus'</p>
			<p class="source-code">    identity.ProductCode = 'PM'</p>
			<p class="source-code">    identity.VendorUrl = 'http://github.com/riptideio/pymodbus/'</p>
			<p class="source-code">    identity.ProductName = 'Pymodbus Server'</p>
			<p class="source-code">    identity.ModelName = 'Pymodbus Server'</p>
			<p class="source-code">    identity.MajorMinorRevision = version.short()</p>
			<p class="source-code">    </p>
			<p class="source-code">    StartTcpServer(context, identity=identity, address=("0.0.0.0", 5020))</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    run_async_server()</p>
			<p>We are <a id="_idIndexMarker501"/>going to place this code into a file called <strong class="source-inline">server.py</strong>.</p>
			<p>We will then proceed to run the server file by typing the following command:</p>
			<p class="source-code">python3 server.py</p>
			<p>If everything worked out correctly, you should see the following screen:</p>
			<div>
				<div id="_idContainer267" class="IMG---Figure">
					<img src="image/B16321_08_001.jpg" alt="Figure 8.1 – pymodbus server&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – pymodbus server</p>
			<p>Once we have <a id="_idIndexMarker502"/>the server running on the PLC, we will navigate to our SCADA VM and run the <strong class="source-inline">mbtget</strong> command as a client to query the register on the virtual PLC. Run the command <strong class="source-inline">mbtget -r1</strong> (read bit function 1), <strong class="source-inline">-a 1</strong> (address number 1), <strong class="source-inline">-n 10</strong> (get the next 10 registers), <strong class="source-inline">192.168.1.10</strong> (the IP address of the virtual PLC), and -<strong class="source-inline">p 5020</strong> (port number). This is the breakdown of the command and you can learn more by running <strong class="source-inline">mbtget -h</strong>:</p>
			<p class="source-code">mbtget -r1 -a 1 -n 10 192.168.1.10 -p 5020</p>
			<p>If the command is run correctly and the server side is listening for a connection, you will receive the following response:</p>
			<div>
				<div id="_idContainer268" class="IMG---Figure">
					<img src="image/B16321_08_002.jpg" alt="Figure 8.2 – 10 Modbus registers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – 10 Modbus registers</p>
			<p>Next, we want to run Wireshark on the network segment, and detect the Modbus communication by using the Modbus display filter in Wireshark. First, we need to make sure that the ESXi virtual switch is allowing promiscuous mode, giving us the ability to sniff the switch and view it in Wireshark.</p>
			<p>Open your ESXi web management console, navigate to <strong class="bold">Networking</strong>, and select <strong class="bold">vSwitch1</strong> from the left-hand menu:</p>
			<div>
				<div id="_idContainer269" class="IMG---Figure">
					<img src="image/B16321_08_003.jpg" alt="Figure 8.3 – vSwitch1 ESXi&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – vSwitch1 ESXi</p>
			<p>Once selected, you <a id="_idIndexMarker503"/>should verify that your security policy allows promiscuous mode as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer270" class="IMG---Figure">
					<img src="image/B16321_08_004.jpg" alt="Figure 8.4 – Promiscuous mode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Promiscuous mode</p>
			<p>If <strong class="bold">Allow promiscuous mode</strong> is off, then click the <strong class="bold">Settings</strong> button and, under the <strong class="bold">Security</strong> tab, adjust it to <strong class="bold">Yes</strong> by selecting the <strong class="bold">Accept</strong> option, as seen in the following screenshot:</p>
			<div>
				<div id="_idContainer271" class="IMG---Figure">
					<img src="image/B16321_08_005.jpg" alt="Figure 8.5 – Edit switch settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Edit switch settings</p>
			<p>Now that we have <strong class="bold">Allow promiscuous mode</strong> enabled, open either your Kali Linux VM or Windows <a id="_idIndexMarker504"/>VM and run Wireshark. Enable the interface that is in the same segment as the PLC and SCADA. As a recap, when we configured our lab in <a href="B16321_01_Epub_AM.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Using Virtualization</em>, we set up our PLC and connected it to <strong class="bold">Level 1: Process</strong>, and with our SCADA, we connected it to <strong class="bold">Level 2: Local Control</strong>.</p>
			<p>Once you have Wireshark up and running and listening to the interface that is attached to the network segment that the PLC and SCADA are communicating across, go ahead and rerun the command on the client that will read the 10 registers from the server. You should see the following output in Wireshark:</p>
			<div>
				<div id="_idContainer272" class="IMG---Figure">
					<img src="image/B16321_08_006.jpg" alt="Figure 8.6 – Modbus capture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Modbus capture</p>
			<p>Now, you might be wondering why there is a difference between my output and yours.  The main <a id="_idIndexMarker505"/>reason is that we are running Modbus TCP over port <strong class="source-inline">5020</strong> and the Wireshark dissector is set for port <strong class="source-inline">502</strong> as the default. To fix this, we need to right-click on the packet and select <strong class="bold">Decode As…</strong> as you will see on the following screen:</p>
			<div>
				<div id="_idContainer273" class="IMG---Figure">
					<img src="image/B16321_08_007.jpg" alt="Figure 8.7 – Decode As...&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Decode As...</p>
			<p>That will then pop up a window similar to the following screen:</p>
			<div>
				<div id="_idContainer274" class="IMG---Figure">
					<img src="image/B16321_08_008.jpg" alt="Figure 8.8 – Modbus TCP port 5020&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – Modbus TCP port 5020</p>
			<p>From here, select the port value of <strong class="bold">5020</strong> and then select the <strong class="bold">Current</strong> dissector to be <strong class="bold">Modbus/TCP</strong>. You should see that your TCP packets are now decoded as Modbus.</p>
			<p>From here, if you <a id="_idIndexMarker506"/>click into the first packet and drill down into the dissector layers for Modbus/TCP and Modbus, you should see something similar to the following screenshot:</p>
			<div>
				<div id="_idContainer275" class="IMG---Figure">
					<img src="image/B16321_08_009.jpg" alt="Figure 8.9 – Modbus request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – Modbus request</p>
			<p>As mentioned previously, we are sending a bit count and a function code. Here, we see that the bit count is <strong class="bold">10</strong>, as expected, from our command and that <strong class="bold">Function Code</strong> is <strong class="bold">Read Coils (1)</strong>. Now examine the packet seen in this screenshot:</p>
			<div>
				<div id="_idContainer276" class="IMG---Figure">
					<img src="image/B16321_08_010.jpg" alt="Figure 8.10 – Modbus response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – Modbus response</p>
			<p>This is the response packet sent from the server. As you can see, it is the same information that <a id="_idIndexMarker507"/>we saw inside the SCADA client where we used the <strong class="source-inline">mbtget</strong> command. We have 10 coils, starting at address 1, all displaying that they are toggled on or reading a true value. Next, we want to look at manually toggling these coils using <strong class="source-inline">mbtget</strong>. Run the <strong class="source-inline">mbtget -w5</strong> (function code 5 write coil), <strong class="source-inline">0</strong> being the bit value (off) and 1 being the bit value (on), <strong class="source-inline">192.168.1.10</strong> (IP address), <strong class="source-inline">-p 5020</strong> (finally, this is the port being used) command:</p>
			<p class="source-code">mbtget -w5 0 -a 1 192.168.1.10 -p 5020</p>
			<p>If everything worked and you have communication between the PLC and SCADA client, you should see the following screen:</p>
			<div>
				<div id="_idContainer277" class="IMG---Figure">
					<img src="image/B16321_08_011.jpg" alt="Figure 8.11 – bit write ok&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11 – bit write ok</p>
			<p>Compare the output to the Wireshark capture. You should see the following Modbus layer information: </p>
			<ul>
				<li><strong class="bold">Function Code</strong> of <strong class="bold">5</strong> for <strong class="bold">Write Single Coil</strong></li>
				<li><strong class="bold">Reference Number</strong></li>
				<li>And finally, <strong class="bold">Data</strong> of <strong class="bold">0</strong></li>
			</ul>
			<p>This is all shown in the following screenshot:</p>
			<div>
				<div id="_idContainer278" class="IMG---Figure">
					<img src="image/B16321_08_012.jpg" alt="Figure 8.12 – Write Single Coil&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12 – Write Single Coil</p>
			<p>Now use <strong class="source-inline">mbtget</strong> to query <a id="_idIndexMarker508"/>the server registers again by running the following command:</p>
			<p class="source-code">mbtget -r1 -a 1 -n 10 192.168.1.10 -p 5020</p>
			<p>You should see that your coil at address 1 is now off:</p>
			<div>
				<div id="_idContainer279" class="IMG---Figure">
					<img src="image/B16321_08_013.jpg" alt="Figure 8.13 – Address 1 is off&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13 – Address 1 is off</p>
			<p>Compare this to your Wireshark capture Modbus response packet, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer280" class="IMG---Figure">
					<img src="image/B16321_08_014.jpg" alt="Figure 8.14 – Modbus response address 1 is 0&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14 – Modbus response address 1 is 0</p>
			<p>Finally, using the same steps and functions that we ran against the virtual PLC, now run the commands <a id="_idIndexMarker509"/>against your Koyo CLICK or the PLC that you have set up in your lab, running Modbus. Use this command to turn your top light, the red light, ON:</p>
			<p class="source-code">mbtget -w5 1 -a 0 192.168.1.20</p>
			<p>You should see your red light turn on. Next, we want to run the <strong class="source-inline">mbtget</strong> command to read the coils. Run the following command to see the response from the PLC and the coils that are enabled/disabled:</p>
			<p class="source-code">mbtget -r1 -a 0 -n 4 192.168.1.20</p>
			<p>You should get the following output from running both commands:</p>
			<div>
				<div id="_idContainer281" class="IMG---Figure">
					<img src="image/B16321_08_015.jpg" alt="Figure 8.15 – mbtget read Koyo CLICK&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15 – mbtget read Koyo CLICK</p>
			<p>You might have noticed by now, it is rather easy to interact with the I/O on a PLC, RTU, flow computer, GC, controller, or any other technology that is running Modbus as the primary control or operational protocol. This plays a very important role while pentesting. If you gather enough information, you will have the ability to piece together how the control data can manipulate the real-world process.</p>
			<p class="callout-heading">Caution</p>
			<p class="callout">When working <a id="_idIndexMarker510"/>on your engagement with the customer, have well-defined <strong class="bold">Rules of Engagement</strong> (<strong class="bold">ROE</strong>) and always err on the side of caution when working at this level in a facility. If you have access and the ability to write to coils or registers, unless it has been blessed and signed off on in the ROE do not, I repeat do not push random data to coils, inputs, or registers. You may inadvertently shut down production lines or process trains, and this could have the adverse effect of creating a massive loss of revenue for your customer. </p>
			<p>I am going to <a id="_idIndexMarker511"/>leave you here with Modbus and let you go on and do further research on the protocol and the capabilities of it. I would recommend getting familiar with <strong class="source-inline">mbtget</strong> and playing with the package as it is a powerful tool written in Perl. We quickly spun up <strong class="source-inline">pymodbus</strong> as a server; however, there are more examples where you can run <strong class="source-inline">pymodbus</strong> in client mode as well. From here, we will look at Ethernet/IP. It is a widely used protocol, not because of a mass-adopted standard but more because of a sales team that did a great job of getting their technology out there and into many different industries.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor103"/>Turning lights on with Ethernet/IP</h1>
			<p>This protocol has been widely adopted in the North American market. I feel it was due to the fact <a id="_idIndexMarker512"/>that it became the foundational protocol utilized and baked into Rockwell Automation products. It started popping up in the control <a id="_idIndexMarker513"/>engineering space in the late 90s, almost two decades after Modbus. <strong class="bold">Common Industrial Protocol</strong> (<strong class="bold">CIP</strong>) messages are the core element that powers Ethernet/IP. It is the object-oriented and open nature of CIP that has allowed quick adoption in the market. An interesting stat that I came across was that Ethernet/IP was estimated to have had 30% utilization in the industrial global market share. This is quite substantial and the reason why it makes it worth discussing and reviewing in this book. For a more in-depth and detailed read on the Ethernet/IP protocol, use the link <a href="https://www.odva.org/wp-content/uploads/2020/05/PUB00035R0_Infrastructure_Guide.pdf">https://www.odva.org/wp-content/uploads/2020/05/PUB00035R0_Infrastructure_Guide.pdf</a> and read through the material that is provided by <strong class="bold">Open DeviceNet Vendors Association</strong> (<strong class="bold">ODVA</strong>). I am <a id="_idIndexMarker514"/>going to run through some high-level details that can be useful when you are performing a pentest on a client's network.  </p>
			<p>Ethernet/IP sends CIP messages between equipment on the network for operating process <a id="_idIndexMarker515"/>equipment. These CIP messages are a collection of objects and these objects have three specific categories:</p>
			<ul>
				<li>General-use objects</li>
				<li>Application-specific objects</li>
				<li>Network-specific objects</li>
			</ul>
			<p>General-use objects are the most common items that you will find in industry. Most devices utilize this object to pass useful information between controllers and servers.  Application- and network-specific objects, as the names suggest, will only be found in applications or networks utilizing these objects. We are going to focus on general-use objects in this next section.</p>
			<p>Following is a table of general-use objects:</p>
			<div>
				<div id="_idContainer282" class="IMG---Figure">
					<img src="image/B16321_08_Table_03.jpg" alt=""/>
				</div>
			</div>
			<p>If we take <a id="_idIndexMarker516"/>a closer look at the general-use identity object (<strong class="source-inline">0x01</strong>), we discover that there are two groups of attributes:</p>
			<ul>
				<li>Mandatory attributes</li>
				<li>Optional attributes</li>
			</ul>
			<p>A list of mandatory attributes can be found in the following table:</p>
			<div>
				<div id="_idContainer283" class="IMG---Figure">
					<img src="image/B16321_08_Table_04.jpg" alt=""/>
				</div>
			</div>
			<p>A list of optional attributes can be found in the following table:</p>
			<p><img src="image/B16321_08_Table_05.png" alt=""/></p>
			<p>These attributes <a id="_idIndexMarker517"/>that have been listed out are passed in the <strong class="bold">Identity CIP</strong> object via the Ethernet/IP protocol. We are focusing on this specific object for a few reasons:</p>
			<ul>
				<li>All IDS vendors typically start with this protocol and specific packet to start building out their asset detection engine. </li>
				<li>Understanding how this object is constructed will allow us to reproduce it as a <strong class="bold">Honey Pot</strong>.</li>
				<li>We are going to use the CPPPO package that we installed in <a href="B16321_01_Epub_AM.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, <em class="italic">Using Virtualization</em>, to demonstrate how Ethernet/IP works, and we will start with the <strong class="source-inline">Identity</strong> object.</li>
			</ul>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor104"/>Establishing the EthernetIP server</h2>
			<p>Make sure <a id="_idIndexMarker518"/>that on your PLC, you have installed the <strong class="source-inline">cpppo</strong> package by running the following command:</p>
			<p class="source-code">pip3 install cpppo</p>
			<p>After verifying that you have the <strong class="source-inline">cpppo</strong> package installed, we are going to create a directory called <strong class="source-inline">enip</strong> under your <strong class="source-inline">Documents</strong> folder:</p>
			<div>
				<div id="_idContainer285" class="IMG---Figure">
					<img src="image/B16321_08_016.jpg" alt="Figure 8.16 – enip folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.16 – enip folder</p>
			<p>Inside this <strong class="source-inline">enip</strong> folder, we want to create a new file called <strong class="source-inline">cpppo.cfg</strong> and place the following configuration inside the file. Notice that the identity object attributes are listed as follows <a id="_idIndexMarker519"/>with definitions included. You have the ability to configure this to your own specifications; however, we will run the initial demo with this default configuration:</p>
			<p class="source-code">[Identity]</p>
			<p class="source-code"># Generally, strings are not quoted</p>
			<p class="source-code">Vendor ID                   = 1</p>
			<p class="source-code">Device Type                 = 14</p>
			<p class="source-code">Product Code Number         = 51</p>
			<p class="source-code">Product Revision            = 16</p>
			<p class="source-code">Status Word                 = 12656</p>
			<p class="source-code">Serial Number               = 1360281</p>
			<p class="source-code">Product Name                = 1756-L55/A 1756-M12/A LOGIX5555</p>
			<p class="source-code">State                       = 255</p>
			<p class="source-code">[TCPIP]</p>
			<p class="source-code"># However, some complex structures require JSON configuration:</p>
			<p class="source-code">Interface Configuration     = {</p>
			<p class="source-code">    "ip_address":             "192.168.1.30",</p>
			<p class="source-code">    "network_mask":           "255.255.255.0",</p>
			<p class="source-code">    "dns_primary":            "8.8.8.8",</p>
			<p class="source-code">    "dns_secondary":          "8.8.4.4",</p>
			<p class="source-code">    "domain_name":            "industrial.pentest.lab"</p>
			<p class="source-code">    }</p>
			<p class="source-code">Host Name                   = controller</p>
			<p>Once you have the file configured and saved, run the following command:</p>
			<p class="source-code">python3 -m cpppo.server.enip -v -a 0.0.0.0</p>
			<p>If everything works without any errors, you should see the following output:</p>
			<div>
				<div id="_idContainer286" class="IMG---Figure">
					<img src="image/B16321_08_017.jpg" alt="Figure 8.17 – cpppo server running&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.17 – cpppo server running</p>
			<p>Now we have a running Ethernet/IP server on PLC. Open a session on the SCADA VM and run the following command:</p>
			<p class="source-code">python3 -m cpppo.server.enip.poll -v TCPIP Identity -a 192.168.1.10</p>
			<p>Once again, if everything <a id="_idIndexMarker520"/>is installed and communicating correctly, you should get the following output:</p>
			<div>
				<div id="_idContainer287" class="IMG---Figure">
					<img src="image/B16321_08_018.jpg" alt="Figure 8.18 – cpppo response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.18 – cpppo response</p>
			<p>Now open up either Kali or the Windows VM and run Wireshark. We want to listen in on the communication, as we did in the Modbus section. Once you have Wireshark open, make sure that SCADA VM is still polling the PLC VM and you should see the following output:</p>
			<div>
				<div id="_idContainer288" class="IMG---Figure">
					<img src="image/B16321_08_019.jpg" alt="Figure 8.19 – Identity object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.19 – Identity object</p>
			<p>Expand the packet <strong class="bold">Success: Identity – Get Attributes All</strong>, seen in the following screenshot:</p>
			<div>
				<div id="_idContainer289" class="IMG---Figure">
					<img src="image/B16321_08_020.jpg" alt="Figure 8.20 – Success: Identity – Get Attributes All&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.20 – Success: Identity – Get Attributes All</p>
			<p>You will see <a id="_idIndexMarker521"/>under the CIP layer that we have <strong class="source-inline">Service: Get Attributes All (Response)</strong>. Expanding this, you will see the details that we configured in the <strong class="source-inline">cpppo.cfg</strong> file under the <strong class="source-inline">Documents/enip/</strong> folder on the PLC VM. Examine the following screenshot and compare it to your configuration file. Try changing some of the parameters and restart the Ethernet/IP server:</p>
			<div>
				<div id="_idContainer290" class="IMG---Figure">
					<img src="image/B16321_08_021.jpg" alt="Figure 8.21 – Identity details&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.21 – Identity details</p>
			<p>As you can see, inside this object, all the useful information for identifying the controller exists. This is why IDS vendors typically tackle this protocol first as it is an easy win to identify assets <a id="_idIndexMarker522"/>on the network. For us, using <strong class="bold">Wireshark</strong> or <strong class="bold">tcpdump</strong> as <a id="_idIndexMarker523"/>discussed in <a href="B16321_05_Epub_AM.xhtml#_idTextAnchor049"><em class="italic">Chapter 5</em></a>, <em class="italic">Span Me If You Can</em>, allows us to identify potential targets and detect whether those devices contain any known vulnerabilities, allowing us to pivot deeper into the environment. Next, we are going to turn on the Ethernet/IP adapter on our Koyo CLICK in our lab. We will then use our <strong class="source-inline">cpppo</strong> tool to interrogate our PLC. </p>
			<p>Take the following quick steps:</p>
			<ol>
				<li>Open the CLICK programming software.</li>
				<li>Click the <strong class="bold">Connect to PLC</strong> button.</li>
				<li>Select the PLC with IP address <strong class="source-inline">192.168.1.20</strong> and click <strong class="bold">Connect</strong>.</li>
				<li>Select <strong class="bold">Read the project</strong> from the PLC options and click the <strong class="bold">OK</strong> button.</li>
			</ol>
			<p>These steps are a simple recap from previous chapters in order to get us to the starting point for Ethernet/IP setup.</p>
			<p>Now we <a id="_idIndexMarker524"/>should be looking at our ladder logic program that controls our four lights. From here, we want to click the <strong class="bold">Setup</strong> menu option as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer291" class="IMG---Figure">
					<img src="image/B16321_08_022.jpg" alt="Figure 8.22 – Koyo CLICK Setup&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.22 – Koyo CLICK Setup</p>
			<p>Select the <strong class="bold">EtherNet/IP Setup…</strong> menu option and this will bring up the following window:</p>
			<div>
				<div id="_idContainer292" class="IMG---Figure">
					<img src="image/B16321_08_023.jpg" alt="Figure 8.23 – EtherNet/IP Adapter setup&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.23 – EtherNet/IP Adapter setup</p>
			<p>Select the <strong class="bold">Enable EtherNet/IP Adapter</strong> checkbox in the window. This will enable the selection <a id="_idIndexMarker525"/>and editing of options in the window. You will notice in the right-hand corner that you have the ability to change the number of connections, the port number, and the timeout. Keeping those options as the defaults, we'll focus on the <strong class="bold">Input(to Scanner)</strong> data blocks shown in the following screenshot:</p>
			<div>
				<div id="_idContainer293" class="IMG---Figure">
					<img src="image/B16321_08_024.jpg" alt="Figure 8.24 – Input data blocks&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.24 – Input data blocks</p>
			<p>Input blocks <a id="_idIndexMarker526"/>are what can be read by the Ethernet/IP master. We want to select block 1 under the <strong class="bold">Start</strong> column and you will see that it allows you to click a button that brings up the <strong class="bold">Address Picker</strong> window. Select the <strong class="bold">XD</strong> button on the left-hand side to filter out the addresses that we will not use. You should see the following screen:</p>
			<div>
				<div id="_idContainer294" class="IMG---Figure">
					<img src="image/B16321_08_025.jpg" alt="Figure 8.25 – XD address selection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.25 – XD address selection</p>
			<p>Select <strong class="source-inline">XD0</strong> for the <a id="_idIndexMarker527"/>start of block 1 and do the same for the end address of block 1 but select <strong class="source-inline">XD8</strong>. Your addressing should look like the following screen:</p>
			<div>
				<div id="_idContainer295" class="IMG---Figure">
					<img src="image/B16321_08_026.jpg" alt="Figure 8.26 – Input XD block 1 address set&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.26 – Input XD block 1 address set</p>
			<p>Next, we want to set the same for our <strong class="bold">Out (from Scanner)</strong> block addressing, but instead of using <strong class="bold">XD</strong> addresses for <strong class="bold">Start</strong> and <strong class="bold">End</strong>, we will use <strong class="bold">YD</strong> addresses. Your addressing, once finished, should look like the following screenshot:</p>
			<div>
				<div id="_idContainer296" class="IMG---Figure">
					<img src="image/B16321_08_027.jpg" alt="Figure 8.27 – Output YD block 1 address set&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.27 – Output YD block 1 address set</p>
			<p>Once set, you want to write your project to your Koyo CLICK PLC. Once your project has been written <a id="_idIndexMarker528"/>to the PLC, hop back over to the terminal window on the SCADA VM where we were running the <strong class="source-inline">cpppo</strong> package commands. Now we want to run the following command:</p>
			<p class="source-code">python3 -m cpppo.server.enip.list_services -vv -a 192.168.1.20 –list-identity</p>
			<p>If everything is connected and working, you should get a long output of information similar to the following snippet:</p>
			<div>
				<div id="_idContainer297" class="IMG---Figure">
					<img src="image/B16321_08_028.jpg" alt="Figure 8.28 – Koyo CLICK Ethernet/IP identity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.28 – Koyo CLICK Ethernet/IP identity</p>
			<p>As you can see, we were able to discover the identity of the Koyo CLICK PLC by running that simple command. We are going to open Wireshark and analyze the communication again as we rerun the commands. You should get the following output:</p>
			<div>
				<div id="_idContainer298" class="IMG---Figure">
					<img src="image/B16321_08_029.jpg" alt="Figure 8.29 – Koyo CLICK ENIP Wireshark capture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.29 – Koyo CLICK ENIP Wireshark capture</p>
			<p>Now you may have remembered that the communication routes out of the ESXi server and to the physical PLC interface, so you will have to use the SPAN port that we set up in <a href="B16321_05_Epub_AM.xhtml#_idTextAnchor049"><em class="italic">Chapter 5</em></a>, <em class="italic">Span Me If You Can</em>, to capture the above communication. This is all neat stuff, but you are probably asking <em class="italic">where is the main course?</em> Listening to traffic and interrogating <a id="_idIndexMarker529"/>PLCs for their identity is interesting but what about actually changing values, turning lights on and off, opening and closing valves, and all that fun stuff?</p>
			<p>Well, buckle up. We are going to navigate back to the PLC VM and make a command-line change to test our <strong class="source-inline">Get</strong>/<strong class="source-inline">Set</strong> attribute requests. Before we start up our virtual Ethernet/IP PLC, we need to quickly discuss how we are going to interact and send messages to our PLC. We will be using unconnected explicit messaging. The reasoning being that we do not need to set up a previous connection, nor do we need to reserve resources to maintain the communication. Unconnected explicit messaging allows us to send ad hoc communication and have the PLC digest and process the commands. Explicit messaging <a id="_idIndexMarker530"/>uses a format called <strong class="source-inline">Lpacket</strong> and inside of <strong class="source-inline">Lpacket</strong>, there reside service fields and these service fields are as follows:</p>
			<ul>
				<li><strong class="bold">Class</strong>: Up to now, we have only really talked about class <strong class="source-inline">0x01</strong>, the identity class, but I did <a id="_idIndexMarker531"/>mention that there are application-specific object IDs, which ultimately are class IDs. There are a series of publicly defined class IDs but because of the openness of the protocol, users can take advantage of the custom range that falls between 100 and 199. </li>
				<li><strong class="bold">Instance</strong>: This helps <a id="_idIndexMarker532"/>distinguish unique messages if you have the same class with multiple instances.</li>
				<li><strong class="bold">Attribute</strong>: Similar to <a id="_idIndexMarker533"/>instance IDs, the attribute ID allows you to distinguish multiple attributes for a given instance.</li>
			</ul>
			<p>There is a lot of information that can be conveyed using the object model, and I strongly encourage you <a id="_idIndexMarker534"/>to do your own research on this protocol by reading the published standards. For our needs, we simply need to understand this syntax:</p>
			<p class="source-code">class/instance/attribute</p>
			<p>This is what defines a tag in the system. Now back to the hands-on example. Run the following command in your PLC VM terminal:</p>
			<p class="source-code">python3 -m cpppo.server.enip -v -a 0.0.0.0 'Compressor_StationA@8/1/1'</p>
			<p>With this command, we are telling the system to build a tag named <strong class="source-inline">Compressor_StationA</strong> with the object containing a class ID of <strong class="source-inline">0x08</strong>, which is a publicly defined class ID for a discrete input point, and then we are giving it an instance ID of 1 with an attribute ID of 1. If everything worked correctly, you should have something similar to the following output:</p>
			<div>
				<div id="_idContainer299" class="IMG---Figure">
					<img src="image/B16321_08_030.jpg" alt="Figure 8.30 – Compressor_StationA tag&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.30 – Compressor_StationA tag</p>
			<p>Now move back to your SCADA VM and type the following command:</p>
			<p class="source-code">python3 -m cpppo.server.enip.get_attribute '@8/1/1' -S -a 192.168.1.10</p>
			<p>Running this command requests the attribute located at <strong class="source-inline">8/1/1</strong> using <strong class="source-inline">-S</strong> (simple mode) from <strong class="source-inline">-a</strong> (address) <strong class="source-inline">192.168.1.10</strong>. Having run this command, you should get the following response:</p>
			<div>
				<div id="_idContainer300" class="IMG---Figure">
					<img src="image/B16321_08_031.jpg" alt="Figure 8.31 – Single attribute value&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.31 – Single attribute value</p>
			<p>This response tells us that there is a <strong class="source-inline">0</strong> value in that attribute. This was an example of simply reading the attribute. Now we want to write to this <em class="italic">tag</em>. Run this command to set the attribute value to <strong class="source-inline">1</strong>:</p>
			<p class="source-code">python3 -m cpppo.server.enip.get_attribute '@8/1/1=(INT)1' '@8/1/1' -S -a 192.168.1.10</p>
			<p>If you compare <a id="_idIndexMarker535"/>the two commands, all we did was add a new argument that tells the system to make the object <strong class="source-inline">@8/1/1=(INT)1</strong> equal an integer of 1. You should see two outputs now, as shown:</p>
			<div>
				<div id="_idContainer301" class="IMG---Figure">
					<img src="image/B16321_08_032.jpg" alt="Figure 8.32 – Setting attribute&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.32 – Setting attribute</p>
			<p>You can see the command responses <strong class="source-inline">S_A_S</strong> and <strong class="source-inline">G_A_S</strong>, which stand for the <strong class="source-inline">setting</strong> attribute and <strong class="source-inline">getting</strong> attribute. The first command indicates setting the attribute equal to <strong class="source-inline">True</strong> and <strong class="source-inline">getting</strong> returns the value as being <strong class="source-inline">1</strong>. Finally, remembering the tag name that we gave the object was <strong class="source-inline">Compressor_StationA</strong>, we can use the tag name to get and set the value as it has been aliased in the system. Run the following command as an example:</p>
			<p class="source-code">python3 -m cpppo.server.enip.client –print Compressor_StationA Compressor_StationA=1 Compressor_StationA -a 192.168.1.10</p>
			<p>You should get the following output:</p>
			<div>
				<div id="_idContainer302" class="IMG---Figure">
					<img src="image/B16321_08_033.jpg" alt="Figure 8.33 – Tag alias Get/Set attribute&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.33 – Tag alias Get/Set attribute</p>
			<p>With the command, we requested a <strong class="source-inline">Get</strong> of the attribute and then the <strong class="source-inline">Set</strong> command to set the value to <strong class="source-inline">1</strong>, and finally, the <strong class="source-inline">Get</strong> command again to check whether the value did update inside the virtual PLC. You can see how easy it is to simply toggle values ON and OFF inside a remote controller. All you need to know is the specific object mapping class/instance/attribute.</p>
			<p>Now we can <a id="_idIndexMarker536"/>test the same command methods against the Koyo CLICK PLC in our lab.  Open up the CLICK programming software, navigate to the <strong class="bold">Setup</strong> menu, and select <strong class="bold">EtherNet/IP Setup…</strong> and you will be presented with the configuration screen we saw before in the configuration steps we did earlier. We want to focus specifically on two sections, the first being under the <strong class="bold">Input(to Scanner)</strong> tab as shown:</p>
			<div>
				<div id="_idContainer303" class="IMG---Figure">
					<img src="image/B16321_08_034.jpg" alt="Figure 8.34 – Input Class/Instance/Attribute&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.34 – Input Class/Instance/Attribute</p>
			<p>Notice the (<strong class="bold">Explicit</strong>) labeled items of <strong class="bold">Class</strong>/<strong class="bold">Instance</strong>/<strong class="bold">Attribute</strong>.</p>
			<ul>
				<li><strong class="bold">Class</strong>: <strong class="source-inline">4</strong> </li>
				<li><strong class="bold">Instance</strong>: <strong class="source-inline">101</strong></li>
				<li><strong class="bold">Attribute</strong>: <strong class="source-inline">3</strong></li>
			</ul>
			<p>Now navigate to the <strong class="bold">Output(from Scanner)</strong> tab, and you should see the following screen:</p>
			<div>
				<div id="_idContainer304" class="IMG---Figure">
					<img src="image/B16321_08_035.jpg" alt="Figure 8.35 – Output Class/Instance/Attribute&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.35 – Output Class/Instance/Attribute</p>
			<p>The <strong class="bold">Class</strong>/<strong class="bold">Instance</strong>/<strong class="bold">Attribute</strong> is nearly the same and if you remember the description of what an instance ID is used for, then you know why it is different by 1:</p>
			<ul>
				<li><strong class="bold">Class</strong>: <strong class="source-inline">4</strong></li>
				<li><strong class="bold">Instance</strong>: <strong class="source-inline">102</strong></li>
				<li><strong class="bold">Attribute</strong>: <strong class="source-inline">3</strong> </li>
			</ul>
			<p>We now have enough information to interact with our program running on our PLC. As a way to monitor <a id="_idIndexMarker537"/>how commands are interacting with the PLC, we want to add a little configuration to the <strong class="bold">Data View</strong> screen in our Koyo CLICK programming software. See the following screenshot, and we will quickly step through the actions that should be taken to set this up for monitoring:</p>
			<div>
				<div id="_idContainer305" class="IMG---Figure">
					<img src="image/B16321_08_036.jpg" alt="Figure 8.36 – Data View&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.36 – Data View</p>
			<p>As a recap, you select the <strong class="bold">Monitor</strong> menu item and select the <strong class="bold">Data View</strong> option.</p>
			<p>Here, you can see that we have added some more registers to <strong class="bold">Data View</strong> and turned on the <strong class="bold">Override</strong> function. </p>
			<p>Here are the quick steps:</p>
			<ol>
				<li value="1">Select the <strong class="bold">address cell</strong>.</li>
				<li>Click <strong class="bold">address picker</strong>.</li>
				<li>Select the address that you want to view and click <strong class="bold">OK</strong>.</li>
				<li>Continue this process until your <strong class="bold">Data View</strong> looks like mine.</li>
			</ol>
			<p>Once you have <a id="_idIndexMarker538"/>the registers displayed in your <strong class="bold">Data View</strong> and it matches the preceding screenshot, go to your SCADA VM terminal and type in the following command:</p>
			<p class="source-code">python3 -m cpppo.server.enip.get_attribute '@4/101/3' '@4/102/3' -S -a 192.168.1.20</p>
			<p>This command, as we saw before, uses the simple mode to get the attributes located in these objects. If all your inputs and outputs are off, you should get the following response:</p>
			<div>
				<div id="_idContainer306" class="IMG---Figure">
					<img src="image/B16321_08_037.jpg" alt="Figure 8.37 – Get attributes from Koyo CLICK&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.37 – Get attributes from Koyo CLICK</p>
			<p class="callout-heading">Note</p>
			<p class="callout">I should point out that in the documentation, as we were going through setting up Ethernet/IP, on the Koyo CLICK PLC, <strong class="source-inline">XD</strong> registers were read only, and <strong class="source-inline">YD</strong> registers were read/write, and this has to do with control philosophy and is beyond the scope of this book. All you really need to know is that if you want to interact with the lights directly, you bypass the input I/O on the PLC with Ethernet/IP and energize the coils directly with the <strong class="source-inline">YD</strong> registers.</p>
			<p>Now the next task would be to manually force <strong class="source-inline">X001</strong> and <strong class="source-inline">X002</strong> on from the <strong class="bold">Data View</strong> screen. You will notice a little binary math going on, which should bring you back to your early computer science days. <strong class="source-inline">0001 + 0010 == 0011 == 0x03</strong>, as you can see in the following screenshot:</p>
			<div>
				<div id="_idContainer307" class="IMG---Figure">
					<img src="image/B16321_08_038.jpg" alt="Figure 8.38 – X001 and X002 forced on&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.38 – X001 and X002 forced on</p>
			<p>The result is <strong class="source-inline">XD0</strong> ending up with a <strong class="source-inline">Hex</strong> value of <strong class="source-inline">0003h</strong>, as shown:</p>
			<div>
				<div id="_idContainer308" class="IMG---Figure">
					<img src="image/B16321_08_039.jpg" alt="Figure 8.39 – XD0 equals 3&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.39 – XD0 equals 3</p>
			<p>Now double-check <a id="_idIndexMarker539"/>to make sure that your <strong class="bold">Data View</strong> screen looks like the following:</p>
			<div>
				<div id="_idContainer309" class="IMG---Figure">
					<img src="image/B16321_08_040.jpg" alt="Figure 8.40 – Data View X001 and X002 forced on&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.40 – Data View X001 and X002 forced on</p>
			<p>We want to rerun the <strong class="source-inline">Get</strong> attribute command to make sure that we are seeing the correct attributes. As a quick refresher, here is the command:</p>
			<p class="source-code">python3 -m cpppo.server.enip.get_attribute '@4/101/3' '@4/102/3' -S -a 192.168.1.20</p>
			<p>If everything is configured correctly, you should get the following output:</p>
			<div>
				<div id="_idContainer310" class="IMG---Figure">
					<img src="image/B16321_08_041.jpg" alt="Figure 8.41 – Input hex value 3&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.41 – Input hex value 3</p>
			<p>Now we know that we are definitely hitting the correct address, let's start to turn lights ON and OFF. If you remember back to your virtual PLC, we simply added the value type and the actual <a id="_idIndexMarker540"/>value to the <strong class="source-inline">read</strong> command. In this case, we would want to duplicate the <strong class="source-inline">@4/102/3</strong> object and add the type of (<strong class="source-inline">INT</strong>) and the hex equivalent to the light combination that we want to turn on. Jumping into the deep end, run the following command:</p>
			<p class="source-code">python3 -m cpppo.server.enip.get_attribute '@4/101/3' '@4/102/3=(INT)15 '@4/102/3' -S -a 192.168.1.20</p>
			<p>You should see the following results:</p>
			<div>
				<div id="_idContainer311" class="IMG---Figure">
					<img src="image/B16321_08_042.jpg" alt="Figure 8.42 – All lights are ON&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.42 – All lights are ON</p>
			<p>Double-check the <strong class="bold">Data View</strong> screen and you should see that all the outputs have been set to ON, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer312" class="IMG---Figure">
					<img src="image/B16321_08_043.jpg" alt="Figure 8.43 – Y001-Y004 all On&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.43 – Y001-Y004 all On</p>
			<p>Finally, let's capture <a id="_idIndexMarker541"/>the <strong class="source-inline">Set</strong> attribute packet by sniffing the SPAN interface with Wireshark. Under the <strong class="source-inline">Info</strong> column on Wireshark, you should see the following details relating to the three commands sent:</p>
			<div>
				<div id="_idContainer313" class="IMG---Figure">
					<img src="image/B16321_08_044.jpg" alt="Figure 8.44 – Wireshark detection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.44 – Wireshark detection</p>
			<p>You can see that we detect the first command, the <strong class="source-inline">Get</strong> attribute <strong class="source-inline">@4/101/3</strong>, then we see the <strong class="source-inline">Set</strong> attribute of <strong class="source-inline">@4/102/3=(INT)15</strong>, and lastly, the third command where we are getting the results of our <strong class="source-inline">Set</strong> command. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you did any research to find more application class IDs as discussed previously, you will have found that the <strong class="source-inline">0x04</strong> class ID is a publicly recognized standard for assembly.</p>
			<p>If you expand the <strong class="bold">Assembly – Set Attribute Single</strong> packet and look under the CIP layer of the protocol, you will find a data value of <strong class="source-inline">0F00</strong>, which is hex for <strong class="source-inline">15</strong>, as shown:</p>
			<div>
				<div id="_idContainer314" class="IMG---Figure">
					<img src="image/B16321_08_045.jpg" alt="Figure 8.45 – Data: 0f00 CIP details&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.45 – Data: 0f00 CIP details</p>
			<p>There we have it. We were able to turn the lights ON and OFF by simply sending unconnected <a id="_idIndexMarker542"/>explicit messages to the PLC. At first glance, the protocol structure looks complex and tedious as compared to Modbus, but after a bit of research and trial and error, we discover that the class/instance/attribute structure of the address makes it rather simple to send and receive commands with. This is important. As we stated in the introduction, 30%+ of global industrial equipment utilizes this protocol to operate processes. Whether it be operating conveyer belts at an Amazon fulfillment center or starting and stopping a mainline compressor station for Colonial Pipeline, you will certainly find this protocol during your adventures in your industrial pentesting career.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor105"/>Summary</h1>
			<p>I understand if you have hit a wall, that was a lot of information to go through and digest. However, I hope that you can see how valuable it is to understand the capabilities and extensibility of the protocols that we encountered in this chapter. The biggest takeaway you should have noticed is that we didn't have to do anything regarding security to simply send ModbusTCP and Ethernet/IP commands to our virtual controller and hardware controller.</p>
			<p>Comprehending what the I/O does from a protocol level will add the validity you need when turning in a final discovery report to your customer. Many times in my career, I have seen a report that simply documents assets discovered on a network utilizing an <em class="italic">insecure</em> protocol. When pressed for details of what impact an asset using an <em class="italic">insecure</em> protocol could have on the organization, the response typically has little to no substance. Having exposure at the packet level allows you to supply richer assessment findings than simply saying <em class="italic">insecure</em> protocol. Here is a quick example from our findings.</p>
			<p>We discovered through the Ethernet/IP's identity get-all attributes request that a Koyo Click C0-10ARE-D is running in the network and is vulnerable to unconnected explicit messaging at address <strong class="source-inline">0x04/102/3</strong>. This address, when manipulated, will allow us to turn OFF and ON the lights in the lab.</p>
			<p>Going forward, you should have a better understanding of what to look for in the network when you come across various industrial protocols, and specifically ModbusTCP and Ethernet/IP.</p>
			<p>In the next chapter, we are going to dive deeper and touch on using Burp Suite to pentest a web-based SCADA interface.</p>
		</div>
	</body></html>