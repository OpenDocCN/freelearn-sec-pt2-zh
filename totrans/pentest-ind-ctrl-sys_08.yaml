- en: '*Chapter 8*: Protocols 202'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now over halfway through the book, and we have covered a lot of material.
    We installed an ESXi server and multiple VMs, and set up our PLC to communicate
    with the VMs. We also installed a light tower and wired the I/O to the PLC. We
    installed Ignition SCADA and connected it to our PLC in the lab, and used various
    tools to scan our install and detect open ports and paths that a developer may
    have left open on the web-based SCADA system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore some of the main protocols used by
    **Industrial Control Systems** (**ICS**). We will be utilizing the VMs that we
    created in [*Chapter 1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013), *Using Virtualization*,
    to generate protocol-specific traffic and we will then make use of Wireshark and
    TShark to analyze the protocol in further detail, much like we did in [*Chapter
    6*](B16321_06_Epub_AM.xhtml#_idTextAnchor063), *Packet Deep Dive*. As you read
    through this book, you should get the feeling that every chapter is building on
    the previous chapter, helping to reinforce the skills that you have learned, and
    then we want to add on a new skill or nugget of knowledge that we will expand
    on later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Industry protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modbus crash course
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turning lights on with Ethernet/IP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A PLC VM running and having the **pymodbus** package installed on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PLC VM running and having the **cpppo** package installed on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A SCADA VM running and having the **mbtget** tool installed on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A SCADA VM running and having the **cpppo** package installed on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can view this chapter''s code in action here: [https://bit.ly/3BCyMWV](https://bit.ly/3BCyMWV)'
  prefs: []
  type: TYPE_NORMAL
- en: Industry protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After much thought and outside suggestions, I have added this preliminary section
    to talk about industry protocols. I specifically narrow in on Modbus and Ethernet/IP
    since our Koyo CLICK PLC has the ability to leverage both of these protocols.
    However, I feel that it would have been almost an injustice to not at least touch
    on the width and breadth of the industrial protocol space. Every industry and
    region that I have come across has tended to gravitate toward one specific vendor
    or another. On some continents, I have seen products, vendors, and protocols of
    equipment uniquely specific to that region of the world. With that said, I am
    going to quickly cover some of the major industry protocols that you will encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modbus**: One of the oldest and most universally adopted protocols, most
    control applications are engineered in **Modbus** first and then ported to a different
    protocol and tested side by side to ensure that the process control strategy functions
    as intended. Modicon published the Modbus standard and Schneider Electric acquired
    Modicon through a series of acquisitions and mergers. This means, when you discover
    a piece of SE equipment on the network, there is a high probability that it will
    be using Modbus to communicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical ports used are **502**, **5020**, and **7701**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Ethernet/IP**: This is a protocol with a wide global presence typically found
    in Rockwell equipment but adopted by a multitude of control automation vendors.
    It was originally designed by the **Control International** (**CI**) working group
    to deliver control message objects while leveraging the robustness of the TCP/IP
    stack. **Ethernet/IP** is the delivery system for the **Common Industrial Protocol**
    (**CIP**), which we discuss in more detail later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical ports used are **44818** and **2222**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**DNP3**: This is a protocol used by SCADA systems to interconnect process
    equipment utilized in the power and water industries. It is an open standard that
    has gained international traction; however, you will find it most commonly used
    in the North American market.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The typical port used is **20000**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**S7 /S7+**: Step 7 was designed by Siemens to be a closed protocol (but based
    on ISO 8073 Class 0) that would uniquely link Siemens equipment. Predominantly
    Europe-based, Siemens products could be found in almost every country and every
    process vertical. It was the control automation industry leader for a time and
    dominated everywhere, with the exceptions of North America and Japan. It is most
    famous for being the equipment and protocol that was leveraged in the Stuxnet
    attack, which involved the Iranian nuclear program. **S7+** was introduced to
    provide more secure and rich features to address the security risks of replay
    attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical ports used are **102** and **1099**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Melsec**: This is a protocol developed by Mitsubishi Electric and has made
    this list as it is widely used in Japan across all industries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical ports used are **1025**, **1026**, and **1027**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Notable protocols are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Bristol's **Bristol Standard Asynchronous Protocol** (**BSAP**), used in the
    oil and gas industry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GE **Service Request Transport Protocol** (**SRTP**), used by almost all
    General Electric equipment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building Automation and Control Network** (**BACnet**), used widely to control
    heating, ventilation, and air conditioning in the building management industry.
    It''s important to note that the Target breach of 2013 occurred through an HVAC
    company that had remote access to monitor environmental sensors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control Area Network** (**CANBus**), developed by Bosch in the 80s, it has
    now become the de facto standard in transportation, automobiles, ships, planes,
    farm equipment, and more. This is a very interesting protocol as it is the backbone
    of autonomous vehicles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list grows from here and as we see **Internet of Things** (**IOT**) and
    **Industrial Internet of Things** (**IIOT**) being introduced into the industrial
    world more, you will encounter protocols such as **Message Queuing Telemetry Transport**
    (**MQTT**), ZigBee, **Advanced Message Queuing Protocol** (**AMQP**), and others.
    In the next section, we will be doing a deep dive into the Modbus protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Modbus crash course
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modbus was a serial protocol that was published in the 1970s as a means of
    connecting equipment in an industrial process over a common bus. Since Modbus''s
    publication, there have been many evolutions of the protocol and variants. This
    is largely due to the openness and flexibility of the protocol standard. As this
    protocol is the most broadly used for connecting industrial equipment, you can
    imagine there have been many books and papers written on the subject. We are going
    to focus specifically on Modbus TCP and the various commands and functions that
    can be used. I strongly recommend reading up on the history and evolution of Modbus,
    as you will gain a deeper insight into how industry has adapted this protocol
    to suite their process and specific operational needs. Follow this link to get
    a brief history of Modbus: [https://www.youtube.com/watch?v=OuM28tp5wXc](https://www.youtube.com/watch?v=OuM28tp5wXc).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modbus TCP encapsulates Modbus RTU packets inside of a TCP packet, allowing
    data to be exchanged via an IP address, which is a drastic change from the previous
    RS-232 or RS-485 forms of serial communication. It is structured in a client-server
    model, allowing a client to communicate with multiple servers and transmit operational
    and control data back and forth. Operational and control inputs and outputs utilize
    various registers depending on the implementation and content of the data. Following
    is a table of registers and the bit sizes as defined in the Modbus standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B16321_08_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you remember back in [*Chapter 3*](B16321_03_Epub_AM.xhtml#_idTextAnchor033),
    *I Love My Bits â€“ Lab Setup*, when we configured a program and downloaded it onto
    the Koyo CLICK, we used contacts and coils in our ladder logic to turn on and
    off the lights. As you can see in the preceding table, those coils and discrete
    inputs are 1 bit in size. We used the GUI to directly toggle the lights ON and
    OFF by overriding and forcing the I/O. The engineering software sends a packet
    that contains a bundle of data and inside that bundle, there is function code
    and a register or list of registers. The function code defines the action expected
    for the PLC and what to do to the following registers. In the case of our light
    scenario, we are sending a packet that ships a 1-bit count with the value of 1
    to coil 1 using function code 5, which is the function code for writing a single
    coil. Here is a table of standard function codes used in the Modbus protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B16321_08_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Establishing a Modbus server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to learn is by example. Remember back in [*Chapter 1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013),
    *Using Virtualization*, when we installed two different programs on both the PLC
    and SCADA VMs, which were **pymodbus** and **mbtget**? We are going to set up
    a server and client and then write some simple communication between the two and
    use Wireshark to eavesdrop on the network and analyze the traffic that we are
    sending.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by using an example from the following link: [https://github.com/riptideio/pymodbus](https://github.com/riptideio/pymodbus).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easier, I will include the following source code so that you can
    copy and paste it into your PLC VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '#!/usr/bin/env python'
  prefs: []
  type: TYPE_NORMAL
- en: from pymodbus.device import ModbusDeviceIdentification
  prefs: []
  type: TYPE_NORMAL
- en: from pymodbus.datastore import ModbusSequentialDataBlock
  prefs: []
  type: TYPE_NORMAL
- en: from pymodbus.datastore import ModbusSlaveContext, ModbusServerContext
  prefs: []
  type: TYPE_NORMAL
- en: from pymodbus.transaction import (ModbusRtuFramer,
  prefs: []
  type: TYPE_NORMAL
- en: ModbusAsciiFramer,
  prefs: []
  type: TYPE_NORMAL
- en: ModbusBinaryFramer)
  prefs: []
  type: TYPE_NORMAL
- en: import logging
  prefs: []
  type: TYPE_NORMAL
- en: FORMAT = ('%(asctime)-15s %(threadName)-15s'
  prefs: []
  type: TYPE_NORMAL
- en: '''%(levelname)-8s %(module)-15s:%(lineno)-8s %(message)s'')'
  prefs: []
  type: TYPE_NORMAL
- en: logging.basicConfig(format=FORMAT)
  prefs: []
  type: TYPE_NORMAL
- en: log = logging.getLogger()
  prefs: []
  type: TYPE_NORMAL
- en: log.setLevel(logging.DEBUG)
  prefs: []
  type: TYPE_NORMAL
- en: 'def run_async_server():'
  prefs: []
  type: TYPE_NORMAL
- en: store = ModbusSlaveContext(
  prefs: []
  type: TYPE_NORMAL
- en: di=ModbusSequentialDataBlock(0, [17]*100),
  prefs: []
  type: TYPE_NORMAL
- en: co=ModbusSequentialDataBlock(0, [17]*100),
  prefs: []
  type: TYPE_NORMAL
- en: hr=ModbusSequentialDataBlock(0, [17]*100),
  prefs: []
  type: TYPE_NORMAL
- en: ir=ModbusSequentialDataBlock(0, [17]*100))
  prefs: []
  type: TYPE_NORMAL
- en: context = ModbusServerContext(slaves=store, single=True)
  prefs: []
  type: TYPE_NORMAL
- en: identity = ModbusDeviceIdentification()
  prefs: []
  type: TYPE_NORMAL
- en: identity.VendorName = 'Pymodbus'
  prefs: []
  type: TYPE_NORMAL
- en: identity.ProductCode = 'PM'
  prefs: []
  type: TYPE_NORMAL
- en: identity.VendorUrl = 'http://github.com/riptideio/pymodbus/'
  prefs: []
  type: TYPE_NORMAL
- en: identity.ProductName = 'Pymodbus Server'
  prefs: []
  type: TYPE_NORMAL
- en: identity.ModelName = 'Pymodbus Server'
  prefs: []
  type: TYPE_NORMAL
- en: identity.MajorMinorRevision = version.short()
  prefs: []
  type: TYPE_NORMAL
- en: StartTcpServer(context, identity=identity, address=("0.0.0.0", 5020))
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == "__main__":'
  prefs: []
  type: TYPE_NORMAL
- en: run_async_server()
  prefs: []
  type: TYPE_NORMAL
- en: We are going to place this code into a file called **server.py**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will then proceed to run the server file by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 server.py
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything worked out correctly, you should see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 â€“ pymodbus server'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 â€“ pymodbus server
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the server running on the PLC, we will navigate to our SCADA VM
    and run the **mbtget** command as a client to query the register on the virtual
    PLC. Run the command **mbtget -r1** (read bit function 1), **-a 1** (address number
    1), **-n 10** (get the next 10 registers), **192.168.1.10** (the IP address of
    the virtual PLC), and -**p 5020** (port number). This is the breakdown of the
    command and you can learn more by running **mbtget -h**:'
  prefs: []
  type: TYPE_NORMAL
- en: mbtget -r1 -a 1 -n 10 192.168.1.10 -p 5020
  prefs: []
  type: TYPE_NORMAL
- en: 'If the command is run correctly and the server side is listening for a connection,
    you will receive the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 â€“ 10 Modbus registers'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 â€“ 10 Modbus registers
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to run Wireshark on the network segment, and detect the Modbus
    communication by using the Modbus display filter in Wireshark. First, we need
    to make sure that the ESXi virtual switch is allowing promiscuous mode, giving
    us the ability to sniff the switch and view it in Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your ESXi web management console, navigate to **Networking**, and select
    **vSwitch1** from the left-hand menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 â€“ vSwitch1 ESXi'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 â€“ vSwitch1 ESXi
  prefs: []
  type: TYPE_NORMAL
- en: 'Once selected, you should verify that your security policy allows promiscuous
    mode as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 â€“ Promiscuous mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 â€“ Promiscuous mode
  prefs: []
  type: TYPE_NORMAL
- en: 'If **Allow promiscuous mode** is off, then click the **Settings** button and,
    under the **Security** tab, adjust it to **Yes** by selecting the **Accept** option,
    as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 â€“ Edit switch settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 â€“ Edit switch settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have **Allow promiscuous mode** enabled, open either your Kali
    Linux VM or Windows VM and run Wireshark. Enable the interface that is in the
    same segment as the PLC and SCADA. As a recap, when we configured our lab in [*Chapter
    1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013), *Using Virtualization*, we set
    up our PLC and connected it to **Level 1: Process**, and with our SCADA, we connected
    it to **Level 2: Local Control**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have Wireshark up and running and listening to the interface that
    is attached to the network segment that the PLC and SCADA are communicating across,
    go ahead and rerun the command on the client that will read the 10 registers from
    the server. You should see the following output in Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 â€“ Modbus capture'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 â€“ Modbus capture
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you might be wondering why there is a difference between my output and
    yours. The main reason is that we are running Modbus TCP over port **5020** and
    the Wireshark dissector is set for port **502** as the default. To fix this, we
    need to right-click on the packet and select **Decode Asâ€¦** as you will see on
    the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 â€“ Decode As...'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 â€“ Decode As...
  prefs: []
  type: TYPE_NORMAL
- en: 'That will then pop up a window similar to the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 â€“ Modbus TCP port 5020'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 â€“ Modbus TCP port 5020
  prefs: []
  type: TYPE_NORMAL
- en: From here, select the port value of **5020** and then select the **Current**
    dissector to be **Modbus/TCP**. You should see that your TCP packets are now decoded
    as Modbus.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, if you click into the first packet and drill down into the dissector
    layers for Modbus/TCP and Modbus, you should see something similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 â€“ Modbus request'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 â€“ Modbus request
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, we are sending a bit count and a function code. Here,
    we see that the bit count is **10**, as expected, from our command and that **Function
    Code** is **Read Coils (1)**. Now examine the packet seen in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 â€“ Modbus response'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 â€“ Modbus response
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the response packet sent from the server. As you can see, it is the
    same information that we saw inside the SCADA client where we used the **mbtget**
    command. We have 10 coils, starting at address 1, all displaying that they are
    toggled on or reading a true value. Next, we want to look at manually toggling
    these coils using **mbtget**. Run the **mbtget -w5** (function code 5 write coil),
    **0** being the bit value (off) and 1 being the bit value (on), **192.168.1.10**
    (IP address), **-p 5020** (finally, this is the port being used) command:'
  prefs: []
  type: TYPE_NORMAL
- en: mbtget -w5 0 -a 1 192.168.1.10 -p 5020
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything worked and you have communication between the PLC and SCADA client,
    you should see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 â€“ bit write ok'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 â€“ bit write ok
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare the output to the Wireshark capture. You should see the following Modbus
    layer information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Code** of **5** for **Write Single Coil**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference Number**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally, **Data** of **0**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is all shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 â€“ Write Single Coil'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 â€“ Write Single Coil
  prefs: []
  type: TYPE_NORMAL
- en: 'Now use **mbtget** to query the server registers again by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: mbtget -r1 -a 1 -n 10 192.168.1.10 -p 5020
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see that your coil at address 1 is now off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 â€“ Address 1 is off'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 â€“ Address 1 is off
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare this to your Wireshark capture Modbus response packet, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 â€“ Modbus response address 1 is 0'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 â€“ Modbus response address 1 is 0
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, using the same steps and functions that we ran against the virtual
    PLC, now run the commands against your Koyo CLICK or the PLC that you have set
    up in your lab, running Modbus. Use this command to turn your top light, the red
    light, ON:'
  prefs: []
  type: TYPE_NORMAL
- en: mbtget -w5 1 -a 0 192.168.1.20
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see your red light turn on. Next, we want to run the **mbtget**
    command to read the coils. Run the following command to see the response from
    the PLC and the coils that are enabled/disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: mbtget -r1 -a 0 -n 4 192.168.1.20
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get the following output from running both commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 â€“ mbtget read Koyo CLICK'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 â€“ mbtget read Koyo CLICK
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed by now, it is rather easy to interact with the I/O on
    a PLC, RTU, flow computer, GC, controller, or any other technology that is running
    Modbus as the primary control or operational protocol. This plays a very important
    role while pentesting. If you gather enough information, you will have the ability
    to piece together how the control data can manipulate the real-world process.
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  prefs: []
  type: TYPE_NORMAL
- en: When working on your engagement with the customer, have well-defined **Rules
    of Engagement** (**ROE**) and always err on the side of caution when working at
    this level in a facility. If you have access and the ability to write to coils
    or registers, unless it has been blessed and signed off on in the ROE do not,
    I repeat do not push random data to coils, inputs, or registers. You may inadvertently
    shut down production lines or process trains, and this could have the adverse
    effect of creating a massive loss of revenue for your customer.
  prefs: []
  type: TYPE_NORMAL
- en: I am going to leave you here with Modbus and let you go on and do further research
    on the protocol and the capabilities of it. I would recommend getting familiar
    with **mbtget** and playing with the package as it is a powerful tool written
    in Perl. We quickly spun up **pymodbus** as a server; however, there are more
    examples where you can run **pymodbus** in client mode as well. From here, we
    will look at Ethernet/IP. It is a widely used protocol, not because of a mass-adopted
    standard but more because of a sales team that did a great job of getting their
    technology out there and into many different industries.
  prefs: []
  type: TYPE_NORMAL
- en: Turning lights on with Ethernet/IP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This protocol has been widely adopted in the North American market. I feel it
    was due to the fact that it became the foundational protocol utilized and baked
    into Rockwell Automation products. It started popping up in the control engineering
    space in the late 90s, almost two decades after Modbus. **Common Industrial Protocol**
    (**CIP**) messages are the core element that powers Ethernet/IP. It is the object-oriented
    and open nature of CIP that has allowed quick adoption in the market. An interesting
    stat that I came across was that Ethernet/IP was estimated to have had 30% utilization
    in the industrial global market share. This is quite substantial and the reason
    why it makes it worth discussing and reviewing in this book. For a more in-depth
    and detailed read on the Ethernet/IP protocol, use the link [https://www.odva.org/wp-content/uploads/2020/05/PUB00035R0_Infrastructure_Guide.pdf](https://www.odva.org/wp-content/uploads/2020/05/PUB00035R0_Infrastructure_Guide.pdf)
    and read through the material that is provided by **Open DeviceNet Vendors Association**
    (**ODVA**). I am going to run through some high-level details that can be useful
    when you are performing a pentest on a client's network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ethernet/IP sends CIP messages between equipment on the network for operating
    process equipment. These CIP messages are a collection of objects and these objects
    have three specific categories:'
  prefs: []
  type: TYPE_NORMAL
- en: General-use objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application-specific objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network-specific objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General-use objects are the most common items that you will find in industry.
    Most devices utilize this object to pass useful information between controllers
    and servers. Application- and network-specific objects, as the names suggest,
    will only be found in applications or networks utilizing these objects. We are
    going to focus on general-use objects in this next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a table of general-use objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B16321_08_Table_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we take a closer look at the general-use identity object (**0x01**), we
    discover that there are two groups of attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Mandatory attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A list of mandatory attributes can be found in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B16321_08_Table_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A list of optional attributes can be found in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B16321_08_Table_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These attributes that have been listed out are passed in the **Identity CIP**
    object via the Ethernet/IP protocol. We are focusing on this specific object for
    a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: All IDS vendors typically start with this protocol and specific packet to start
    building out their asset detection engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how this object is constructed will allow us to reproduce it as
    a **Honey Pot**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to use the CPPPO package that we installed in [*Chapter 1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013),
    *Using Virtualization*, to demonstrate how Ethernet/IP works, and we will start
    with the **Identity** object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establishing the EthernetIP server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make sure that on your PLC, you have installed the **cpppo** package by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: pip3 install cpppo
  prefs: []
  type: TYPE_NORMAL
- en: 'After verifying that you have the **cpppo** package installed, we are going
    to create a directory called **enip** under your **Documents** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 â€“ enip folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 â€“ enip folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this **enip** folder, we want to create a new file called **cpppo.cfg**
    and place the following configuration inside the file. Notice that the identity
    object attributes are listed as follows with definitions included. You have the
    ability to configure this to your own specifications; however, we will run the
    initial demo with this default configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Identity]'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, strings are not quoted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vendor IDÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = 1
  prefs: []
  type: TYPE_NORMAL
- en: Device TypeÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = 14
  prefs: []
  type: TYPE_NORMAL
- en: Product Code NumberÂ Â Â Â Â Â Â Â Â = 51
  prefs: []
  type: TYPE_NORMAL
- en: Product RevisionÂ Â Â Â Â Â Â Â Â Â Â Â = 16
  prefs: []
  type: TYPE_NORMAL
- en: Status WordÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = 12656
  prefs: []
  type: TYPE_NORMAL
- en: Serial NumberÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â = 1360281
  prefs: []
  type: TYPE_NORMAL
- en: Product NameÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = 1756-L55/A 1756-M12/A LOGIX5555
  prefs: []
  type: TYPE_NORMAL
- en: StateÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = 255
  prefs: []
  type: TYPE_NORMAL
- en: '[TCPIP]'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, some complex structures require JSON configuration:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interface ConfigurationÂ Â Â Â Â = {
  prefs: []
  type: TYPE_NORMAL
- en: '"ip_address":Â Â Â Â Â Â Â Â Â Â Â Â Â "192.168.1.30",'
  prefs: []
  type: TYPE_NORMAL
- en: '"network_mask":Â Â Â Â Â Â Â Â Â Â Â "255.255.255.0",'
  prefs: []
  type: TYPE_NORMAL
- en: '"dns_primary":Â Â Â Â Â Â Â Â Â Â Â Â "8.8.8.8",'
  prefs: []
  type: TYPE_NORMAL
- en: '"dns_secondary":Â Â Â Â Â Â Â Â Â Â "8.8.4.4",'
  prefs: []
  type: TYPE_NORMAL
- en: '"domain_name":Â Â Â Â Â Â Â Â Â Â Â Â "industrial.pentest.lab"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Host NameÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â = controller
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the file configured and saved, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m cpppo.server.enip -v -a 0.0.0.0
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything works without any errors, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 â€“ cpppo server running'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 â€“ cpppo server running
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a running Ethernet/IP server on PLC. Open a session on the SCADA
    VM and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m cpppo.server.enip.poll -v TCPIP Identity -a 192.168.1.10
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, if everything is installed and communicating correctly, you should
    get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 â€“ cpppo response'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_018.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 â€“ cpppo response
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open up either Kali or the Windows VM and run Wireshark. We want to listen
    in on the communication, as we did in the Modbus section. Once you have Wireshark
    open, make sure that SCADA VM is still polling the PLC VM and you should see the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 â€“ Identity object'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 â€“ Identity object
  prefs: []
  type: TYPE_NORMAL
- en: 'Expand the packet **Success: Identity â€“ Get Attributes All**, seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 â€“ Success: Identity â€“ Get Attributes All'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_020.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.20 â€“ Success: Identity â€“ Get Attributes All'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see under the CIP layer that we have **Service: Get Attributes All
    (Response)**. Expanding this, you will see the details that we configured in the
    **cpppo.cfg** file under the **Documents/enip/** folder on the PLC VM. Examine
    the following screenshot and compare it to your configuration file. Try changing
    some of the parameters and restart the Ethernet/IP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 â€“ Identity details'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 â€“ Identity details
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, inside this object, all the useful information for identifying
    the controller exists. This is why IDS vendors typically tackle this protocol
    first as it is an easy win to identify assets on the network. For us, using **Wireshark**
    or **tcpdump** as discussed in [*Chapter 5*](B16321_05_Epub_AM.xhtml#_idTextAnchor049),
    *Span Me If You Can*, allows us to identify potential targets and detect whether
    those devices contain any known vulnerabilities, allowing us to pivot deeper into
    the environment. Next, we are going to turn on the Ethernet/IP adapter on our
    Koyo CLICK in our lab. We will then use our **cpppo** tool to interrogate our
    PLC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following quick steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the CLICK programming software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Connect to PLC** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the PLC with IP address **192.168.1.20** and click **Connect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Read the project** from the PLC options and click the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps are a simple recap from previous chapters in order to get us to
    the starting point for Ethernet/IP setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should be looking at our ladder logic program that controls our four
    lights. From here, we want to click the **Setup** menu option as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 â€“ Koyo CLICK Setup'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_022.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 â€“ Koyo CLICK Setup
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **EtherNet/IP Setupâ€¦** menu option and this will bring up the following
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 â€“ EtherNet/IP Adapter setup'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_023.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 â€“ EtherNet/IP Adapter setup
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **Enable EtherNet/IP Adapter** checkbox in the window. This will
    enable the selection and editing of options in the window. You will notice in
    the right-hand corner that you have the ability to change the number of connections,
    the port number, and the timeout. Keeping those options as the defaults, we''ll
    focus on the **Input(to Scanner)** data blocks shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24 â€“ Input data blocks'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_024.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.24 â€“ Input data blocks
  prefs: []
  type: TYPE_NORMAL
- en: 'Input blocks are what can be read by the Ethernet/IP master. We want to select
    block 1 under the **Start** column and you will see that it allows you to click
    a button that brings up the **Address Picker** window. Select the **XD** button
    on the left-hand side to filter out the addresses that we will not use. You should
    see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25 â€“ XD address selection'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_025.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.25 â€“ XD address selection
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **XD0** for the start of block 1 and do the same for the end address
    of block 1 but select **XD8**. Your addressing should look like the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.26 â€“ Input XD block 1 address set'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_026.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.26 â€“ Input XD block 1 address set
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to set the same for our **Out (from Scanner)** block addressing,
    but instead of using **XD** addresses for **Start** and **End**, we will use **YD**
    addresses. Your addressing, once finished, should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27 â€“ Output YD block 1 address set'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_027.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.27 â€“ Output YD block 1 address set
  prefs: []
  type: TYPE_NORMAL
- en: 'Once set, you want to write your project to your Koyo CLICK PLC. Once your
    project has been written to the PLC, hop back over to the terminal window on the
    SCADA VM where we were running the **cpppo** package commands. Now we want to
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m cpppo.server.enip.list_services -vv -a 192.168.1.20 â€“list-identity
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is connected and working, you should get a long output of information
    similar to the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.28 â€“ Koyo CLICK Ethernet/IP identity'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_028.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.28 â€“ Koyo CLICK Ethernet/IP identity
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we were able to discover the identity of the Koyo CLICK PLC
    by running that simple command. We are going to open Wireshark and analyze the
    communication again as we rerun the commands. You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.29 â€“ Koyo CLICK ENIP Wireshark capture'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_029.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.29 â€“ Koyo CLICK ENIP Wireshark capture
  prefs: []
  type: TYPE_NORMAL
- en: Now you may have remembered that the communication routes out of the ESXi server
    and to the physical PLC interface, so you will have to use the SPAN port that
    we set up in [*Chapter 5*](B16321_05_Epub_AM.xhtml#_idTextAnchor049), *Span Me
    If You Can*, to capture the above communication. This is all neat stuff, but you
    are probably asking *where is the main course?* Listening to traffic and interrogating
    PLCs for their identity is interesting but what about actually changing values,
    turning lights on and off, opening and closing valves, and all that fun stuff?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, buckle up. We are going to navigate back to the PLC VM and make a command-line
    change to test our **Get**/**Set** attribute requests. Before we start up our
    virtual Ethernet/IP PLC, we need to quickly discuss how we are going to interact
    and send messages to our PLC. We will be using unconnected explicit messaging.
    The reasoning being that we do not need to set up a previous connection, nor do
    we need to reserve resources to maintain the communication. Unconnected explicit
    messaging allows us to send ad hoc communication and have the PLC digest and process
    the commands. Explicit messaging uses a format called **Lpacket** and inside of
    **Lpacket**, there reside service fields and these service fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class**: Up to now, we have only really talked about class **0x01**, the
    identity class, but I did mention that there are application-specific object IDs,
    which ultimately are class IDs. There are a series of publicly defined class IDs
    but because of the openness of the protocol, users can take advantage of the custom
    range that falls between 100 and 199\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance**: This helps distinguish unique messages if you have the same class
    with multiple instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute**: Similar to instance IDs, the attribute ID allows you to distinguish
    multiple attributes for a given instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a lot of information that can be conveyed using the object model,
    and I strongly encourage you to do your own research on this protocol by reading
    the published standards. For our needs, we simply need to understand this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: class/instance/attribute
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what defines a tag in the system. Now back to the hands-on example.
    Run the following command in your PLC VM terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m cpppo.server.enip -v -a 0.0.0.0 'Compressor_StationA@8/1/1'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this command, we are telling the system to build a tag named **Compressor_StationA**
    with the object containing a class ID of **0x08**, which is a publicly defined
    class ID for a discrete input point, and then we are giving it an instance ID
    of 1 with an attribute ID of 1\. If everything worked correctly, you should have
    something similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.30 â€“ Compressor_StationA tag'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_030.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.30 â€“ Compressor_StationA tag
  prefs: []
  type: TYPE_NORMAL
- en: 'Now move back to your SCADA VM and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m cpppo.server.enip.get_attribute '@8/1/1' -S -a 192.168.1.10
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this command requests the attribute located at **8/1/1** using **-S**
    (simple mode) from **-a** (address) **192.168.1.10**. Having run this command,
    you should get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.31 â€“ Single attribute value'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_031.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.31 â€“ Single attribute value
  prefs: []
  type: TYPE_NORMAL
- en: 'This response tells us that there is a **0** value in that attribute. This
    was an example of simply reading the attribute. Now we want to write to this *tag*.
    Run this command to set the attribute value to **1**:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m cpppo.server.enip.get_attribute '@8/1/1=(INT)1' '@8/1/1' -S -a 192.168.1.10
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compare the two commands, all we did was add a new argument that tells
    the system to make the object **@8/1/1=(INT)1** equal an integer of 1\. You should
    see two outputs now, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.32 â€“ Setting attribute'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_032.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.32 â€“ Setting attribute
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the command responses **S_A_S** and **G_A_S**, which stand for
    the **setting** attribute and **getting** attribute. The first command indicates
    setting the attribute equal to **True** and **getting** returns the value as being
    **1**. Finally, remembering the tag name that we gave the object was **Compressor_StationA**,
    we can use the tag name to get and set the value as it has been aliased in the
    system. Run the following command as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m cpppo.server.enip.client â€“print Compressor_StationA Compressor_StationA=1
    Compressor_StationA -a 192.168.1.10
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.33 â€“ Tag alias Get/Set attribute'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_033.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.33 â€“ Tag alias Get/Set attribute
  prefs: []
  type: TYPE_NORMAL
- en: With the command, we requested a **Get** of the attribute and then the **Set**
    command to set the value to **1**, and finally, the **Get** command again to check
    whether the value did update inside the virtual PLC. You can see how easy it is
    to simply toggle values ON and OFF inside a remote controller. All you need to
    know is the specific object mapping class/instance/attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can test the same command methods against the Koyo CLICK PLC in our
    lab. Open up the CLICK programming software, navigate to the **Setup** menu, and
    select **EtherNet/IP Setupâ€¦** and you will be presented with the configuration
    screen we saw before in the configuration steps we did earlier. We want to focus
    specifically on two sections, the first being under the **Input(to Scanner)**
    tab as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.34 â€“ Input Class/Instance/Attribute'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_034.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.34 â€“ Input Class/Instance/Attribute
  prefs: []
  type: TYPE_NORMAL
- en: Notice the (**Explicit**) labeled items of **Class**/**Instance**/**Attribute**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class**: **4**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance**: **101**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute**: **3**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now navigate to the **Output(from Scanner)** tab, and you should see the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.35 â€“ Output Class/Instance/Attribute'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_035.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.35 â€“ Output Class/Instance/Attribute
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Class**/**Instance**/**Attribute** is nearly the same and if you remember
    the description of what an instance ID is used for, then you know why it is different
    by 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class**: **4**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance**: **102**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute**: **3**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now have enough information to interact with our program running on our
    PLC. As a way to monitor how commands are interacting with the PLC, we want to
    add a little configuration to the **Data View** screen in our Koyo CLICK programming
    software. See the following screenshot, and we will quickly step through the actions
    that should be taken to set this up for monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.36 â€“ Data View'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_036.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.36 â€“ Data View
  prefs: []
  type: TYPE_NORMAL
- en: As a recap, you select the **Monitor** menu item and select the **Data View**
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that we have added some more registers to **Data View** and
    turned on the **Override** function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the quick steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **address cell**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **address picker**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the address that you want to view and click **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue this process until your **Data View** looks like mine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have the registers displayed in your **Data View** and it matches
    the preceding screenshot, go to your SCADA VM terminal and type in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m cpppo.server.enip.get_attribute '@4/101/3' '@4/102/3' -S -a 192.168.1.20
  prefs: []
  type: TYPE_NORMAL
- en: 'This command, as we saw before, uses the simple mode to get the attributes
    located in these objects. If all your inputs and outputs are off, you should get
    the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.37 â€“ Get attributes from Koyo CLICK'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_037.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.37 â€“ Get attributes from Koyo CLICK
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I should point out that in the documentation, as we were going through setting
    up Ethernet/IP, on the Koyo CLICK PLC, **XD** registers were read only, and **YD**
    registers were read/write, and this has to do with control philosophy and is beyond
    the scope of this book. All you really need to know is that if you want to interact
    with the lights directly, you bypass the input I/O on the PLC with Ethernet/IP
    and energize the coils directly with the **YD** registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the next task would be to manually force **X001** and **X002** on from
    the **Data View** screen. You will notice a little binary math going on, which
    should bring you back to your early computer science days. **0001 + 0010 == 0011
    == 0x03**, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.38 â€“ X001 and X002 forced on'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_038.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.38 â€“ X001 and X002 forced on
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is **XD0** ending up with a **Hex** value of **0003h**, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.39 â€“ XD0 equals 3'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_039.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.39 â€“ XD0 equals 3
  prefs: []
  type: TYPE_NORMAL
- en: 'Now double-check to make sure that your **Data View** screen looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.40 â€“ Data View X001 and X002 forced on'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_040.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.40 â€“ Data View X001 and X002 forced on
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to rerun the **Get** attribute command to make sure that we are seeing
    the correct attributes. As a quick refresher, here is the command:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m cpppo.server.enip.get_attribute '@4/101/3' '@4/102/3' -S -a 192.168.1.20
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything is configured correctly, you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.41 â€“ Input hex value 3'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_041.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.41 â€“ Input hex value 3
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we know that we are definitely hitting the correct address, let''s start
    to turn lights ON and OFF. If you remember back to your virtual PLC, we simply
    added the value type and the actual value to the **read** command. In this case,
    we would want to duplicate the **@4/102/3** object and add the type of (**INT**)
    and the hex equivalent to the light combination that we want to turn on. Jumping
    into the deep end, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m cpppo.server.enip.get_attribute '@4/101/3' '@4/102/3=(INT)15 '@4/102/3'
    -S -a 192.168.1.20
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.42 â€“ All lights are ON'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_042.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.42 â€“ All lights are ON
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-check the **Data View** screen and you should see that all the outputs
    have been set to ON, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.43 â€“ Y001-Y004 all On'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_043.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.43 â€“ Y001-Y004 all On
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s capture the **Set** attribute packet by sniffing the SPAN interface
    with Wireshark. Under the **Info** column on Wireshark, you should see the following
    details relating to the three commands sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.44 â€“ Wireshark detection'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_044.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.44 â€“ Wireshark detection
  prefs: []
  type: TYPE_NORMAL
- en: You can see that we detect the first command, the **Get** attribute **@4/101/3**,
    then we see the **Set** attribute of **@4/102/3=(INT)15**, and lastly, the third
    command where we are getting the results of our **Set** command.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you did any research to find more application class IDs as discussed previously,
    you will have found that the **0x04** class ID is a publicly recognized standard
    for assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you expand the **Assembly â€“ Set Attribute Single** packet and look under
    the CIP layer of the protocol, you will find a data value of **0F00**, which is
    hex for **15**, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.45 â€“ Data: 0f00 CIP details'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_08_045.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.45 â€“ Data: 0f00 CIP details'
  prefs: []
  type: TYPE_NORMAL
- en: There we have it. We were able to turn the lights ON and OFF by simply sending
    unconnected explicit messages to the PLC. At first glance, the protocol structure
    looks complex and tedious as compared to Modbus, but after a bit of research and
    trial and error, we discover that the class/instance/attribute structure of the
    address makes it rather simple to send and receive commands with. This is important.
    As we stated in the introduction, 30%+ of global industrial equipment utilizes
    this protocol to operate processes. Whether it be operating conveyer belts at
    an Amazon fulfillment center or starting and stopping a mainline compressor station
    for Colonial Pipeline, you will certainly find this protocol during your adventures
    in your industrial pentesting career.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I understand if you have hit a wall, that was a lot of information to go through
    and digest. However, I hope that you can see how valuable it is to understand
    the capabilities and extensibility of the protocols that we encountered in this
    chapter. The biggest takeaway you should have noticed is that we didn't have to
    do anything regarding security to simply send ModbusTCP and Ethernet/IP commands
    to our virtual controller and hardware controller.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehending what the I/O does from a protocol level will add the validity
    you need when turning in a final discovery report to your customer. Many times
    in my career, I have seen a report that simply documents assets discovered on
    a network utilizing an *insecure* protocol. When pressed for details of what impact
    an asset using an *insecure* protocol could have on the organization, the response
    typically has little to no substance. Having exposure at the packet level allows
    you to supply richer assessment findings than simply saying *insecure* protocol.
    Here is a quick example from our findings.
  prefs: []
  type: TYPE_NORMAL
- en: We discovered through the Ethernet/IP's identity get-all attributes request
    that a Koyo Click C0-10ARE-D is running in the network and is vulnerable to unconnected
    explicit messaging at address **0x04/102/3**. This address, when manipulated,
    will allow us to turn OFF and ON the lights in the lab.
  prefs: []
  type: TYPE_NORMAL
- en: Going forward, you should have a better understanding of what to look for in
    the network when you come across various industrial protocols, and specifically
    ModbusTCP and Ethernet/IP.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to dive deeper and touch on using Burp Suite
    to pentest a web-based SCADA interface.
  prefs: []
  type: TYPE_NORMAL
