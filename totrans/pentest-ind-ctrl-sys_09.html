<html><head></head><body>
		<div id="_idContainer375">
			<h1 id="_idParaDest-96"><em class="italic"><a id="_idTextAnchor106"/>Chapter 9</em>: Ninja 308</h1>
			<p>In the previous chapter, we discussed the fundamentals of industrial protocols and specifically the nuances of two in particular: Modbus and Ethernet/IP. We discussed and used tools that allowed us to enumerate ports and discover services running on those devices. We also used tools to traverse directories and vhosts in <a href="B16321_07_Epub_AM.xhtml#_idTextAnchor081"><em class="italic">Chapter 7</em></a>, <em class="italic">Scanning 101</em>, which means that we have a great foundational knowledge of both ends of the attack chain. </p>
			<p>Now, we need to spend time looking at attacks and, most importantly, brute forcing. As exciting as it is to find a legacy service that we then spend time reverse engineering and building an exploit for, time is typically not on our side. If you discover a system such as Ignition SCADA, which we installed in <a href="B16321_07_Epub_AM.xhtml#_idTextAnchor081"><em class="italic">Chapter 7</em></a>, <em class="italic">Scanning 101</em>, it is fairly common for operational personnel to use simple passwords or factory defaults to access the system. Gaining access to a SCADA system as a user allows you to take over absolute control of the industrial process. Acquiring this level of access is similar to the crown jewels of "Domain Admin" inside the Enterprise IT security landscape. Learning how to use a web pentesting tool such as BurpSuite is very important as it will aid in opening access to various systems by divulging real-world credentials.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Installing FoxyProxy</li>
				<li>Running BurpSuite</li>
				<li>Building a script for brute-forcing SCADA</li>
			</ul>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor107"/>Technical requirements</h1>
			<p>For this chapter, you will need the following:</p>
			<ul>
				<li>A Kali Linux VM running with Firefox installed.</li>
				<li>BurpSuite Community Edition installed. Go to this link to find the latest version: <a href="https://portswigger.net/burp/communitydownload">https://portswigger.net/burp/communitydownload</a>.</li>
				<li>A default list of SCADA equipment passwords, which can be found at this link: <a href="https://github.com/scadastrangelove/SCADAPASS/blob/master/scadapass.csv">https://github.com/scadastrangelove/SCADAPASS/blob/master/scadapass.csv</a>.</li>
			</ul>
			<p>You can view this chapter's code in action here: <a href="https://bit.ly/3lAinwm">https://bit.ly/3lAinwm</a></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor108"/>Installing FoxyProxy</h1>
			<p>Before diving into<a id="_idIndexMarker543"/> the installation of FoxyProxy, we should define what a proxy server is and why we would want to<a id="_idIndexMarker544"/> use one. A <strong class="bold">proxy server</strong> is a system that translates traffic from one network or device into another device or network. This is easier said than done, though: what does this mean for us and why would we care about translating traffic? A proxy server allows us to intercept all communication originating from and designated to our attacking host. This allows us to augment and change the behavior of how the request interacts with the server, such as by dropping JavaScript UI filtering and other interesting tasks. So, now that we know what a proxy server is, what is FoxyProxy? FoxyProxy is a simple but powerful proxy switch. It takes all the tediousness out of having to change the internal proxy settings of your browser. Simply add your new setting and use a switch to toggle between proxy servers and turn them on and off. </p>
			<p>Follow these steps to install FoxyProxy:</p>
			<ol>
				<li>To start, you will need to access your Kali Linux VM and start Firefox ESR. Once you have Firefox open, navigate to the right-hand side, where you will see the hamburger button or menu button; select it. It will bring up the following drop-down menu:<div id="_idContainer316" class="IMG---Figure"><img src="image/Figure_9.01_B16321.jpg" alt="Figure 9.1 – Menu dropdown&#13;&#10;"/></div><p class="figure-caption">Figure 9.1 – Menu dropdown</p></li>
				<li>With the menu open, select the <strong class="bold">Add-ons</strong> option. You will be presented with a screen showing <a id="_idIndexMarker545"/>recommendations, extensions, themes, and plugins. Navigate to the search bar, type in <strong class="source-inline">foxyproxy</strong>, and then press <em class="italic">Enter</em>, as shown in the following screenshot:<div id="_idContainer317" class="IMG---Figure"><img src="image/Figure_9.02_B16321.jpg" alt="Figure 9.2 – Add-on search pop-up&#13;&#10;"/></div><p class="figure-caption">Figure 9.2 – Add-on search pop-up</p></li>
				<li>By doing this, you will see a list of possible matching add-ons. You will see <strong class="bold">FoxyProxy Standard</strong> at the top of the list, as shown in the following screenshot:<div id="_idContainer318" class="IMG---Figure"><img src="image/Figure_9.03_B16321.jpg" alt="Figure 9.3 – FoxyProxy Standard&#13;&#10;"/></div><p class="figure-caption">Figure 9.3 – FoxyProxy Standard</p></li>
				<li>Clicking the <strong class="bold">FoxyProxy Standard</strong> link will cause a popup to appear that allows you to<a id="_idIndexMarker546"/> click the <strong class="bold">Add to Firefox</strong> button. This is shown in the following screenshot:<div id="_idContainer319" class="IMG---Figure"><img src="image/Figure_9.04_B16321.jpg" alt="Figure 9.4 – Installing FoxyProxy&#13;&#10;"/></div><p class="figure-caption">Figure 9.4 – Installing FoxyProxy</p></li>
				<li>Proceed by clicking the <strong class="bold">Add to Firefox</strong> button. At this point, you will be presented with a permissions request. This is important as you will be allowing FoxyProxy to change your browser settings. The following are the permissions that you will be granting FoxyProxy by adding it to your browser:<div id="_idContainer320" class="IMG---Figure"><img src="image/Figure_9.05_B16321.jpg" alt="Figure 9.5 – FoxyProxy permissions&#13;&#10;"/></div><p class="figure-caption">Figure 9.5 – FoxyProxy permissions</p></li>
				<li>Click the <strong class="bold">Add</strong> button to successfully install FoxyProxy. You should now see a fox icon in the toolbar, on the right-hand side of Firefox. Clicking the icon brings up the following screen:<div id="_idContainer321" class="IMG---Figure"><img src="image/Figure_9.06_B16321.jpg" alt="Figure 9.6 – FoxyProxy configuration&#13;&#10;"/></div><p class="figure-caption">Figure 9.6 – FoxyProxy configuration</p></li>
				<li>We currently<a id="_idIndexMarker547"/> don't have any proxy settings so we will add some by clicking the <strong class="bold">+ Add</strong> link, as shown in the following screenshot:<div id="_idContainer322" class="IMG---Figure"><img src="image/Figure_9.07_B16321.jpg" alt="Figure 9.7 – Adding settings&#13;&#10;"/></div><p class="figure-caption">Figure 9.7 – Adding settings</p><p>Upon clicking this, you will be presented with a page that allows you to add your first proxy settings, as shown here:</p><div id="_idContainer323" class="IMG---Figure"><img src="image/Figure_9.08_B16321.jpg" alt="Figure 9.8 – First proxy settings&#13;&#10;"/></div><p class="figure-caption">Figure 9.8 – First proxy settings</p><p>For these settings, I tend to set the following parameters:</p><p>- <strong class="bold">Title or Description</strong>: <strong class="source-inline">BurpSuite</strong></p><p>- <strong class="bold">Proxy Type</strong>: <strong class="source-inline">HTTP</strong></p><p>- <strong class="bold">Proxy IP</strong>: <strong class="source-inline">127.0.0.1</strong></p><p>- <strong class="bold">Port</strong>: <strong class="source-inline">8080</strong></p></li>
				<li>Click the <strong class="bold">Save</strong> button. Now, you<a id="_idIndexMarker548"/> should have the newly added setting when you click the fox icon in your toolbar, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer324" class="IMG---Figure">
					<img src="image/Figure_9.09_B16321.jpg" alt="Figure 9.9 – BurpSuite proxy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – BurpSuite proxy</p>
			<p>With that, we have successfully installed FoxyProxy and configured our first proxy setting, which is convenient for BurpSuite. This is the next topic that we will be discussing. The simplicity of<a id="_idIndexMarker549"/> quickly configuring proxies and having the ability to toggle them on and off, as well as switching between the different proxies, will be very useful in your pentesting career.  </p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor109"/>Running BurpSuite</h1>
			<p>In the previous<a id="_idIndexMarker550"/> section, we installed FoxyProxy and configured some settings to accommodate our BurpSuite software. In this section, we are going to utilize BurpSuite to help us understand the <strong class="bold">Request</strong>/<strong class="bold">Response</strong> actions that Ignition SCADA utilizes to perform authentication and authorization. Now, for us to proceed, we need to add BurpSuite's certificate as a trusted source; otherwise, we will be forced to acknowledge every website we've visited as an exception. </p>
			<p>To do this, we must navigate to the IP address and port that we configured in our settings. Upon doing this, you will be presented with a <strong class="bold">BurpSuite Community Edition</strong> splash page with a <strong class="bold">CA Certificate</strong> button on the right-hand side, as shown here:</p>
			<div>
				<div id="_idContainer325" class="IMG---Figure">
					<img src="image/Figure_9.10_B16321.jpg" alt="Figure 9.10 – CA Certificate location&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10 – CA Certificate location</p>
			<p>Upon clicking this button, you will be presented with the following screen:</p>
			<div>
				<div id="_idContainer326" class="IMG---Figure">
					<img src="image/Figure_9.11_B16321.jpg" alt="Figure 9.11 – Saving the CA Certificate&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11 – Saving the CA Certificate</p>
			<p>Select <strong class="bold">Save File</strong> and <a id="_idIndexMarker551"/>click the <strong class="bold">OK</strong> button. Next, we want to navigate to our menu under the hamburger icon and select <strong class="bold">Preferences</strong>, as shown here:</p>
			<div>
				<div id="_idContainer327" class="IMG---Figure">
					<img src="image/Figure_9.12_B16321.jpg" alt="Figure 9.12 – Preferences&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12 – Preferences</p>
			<p>Then, we want to select <strong class="bold">Privacy &amp; Security</strong> on the left-hand side, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer328" class="IMG---Figure">
					<img src="image/Figure_9.13_B16321.jpg" alt="Figure 9.13 – Privacy &amp; Security&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13 – Privacy &amp; Security</p>
			<p>Scroll down until you<a id="_idIndexMarker552"/> see the <strong class="bold">Certificates</strong> area, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer329" class="IMG---Figure">
					<img src="image/Figure_9.14_B16321.jpg" alt="Figure 9.14 – Certificates&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14 – Certificates</p>
			<p>Click the <strong class="bold">View Certificates</strong> button. You will be presented with the following pop-up:</p>
			<div>
				<div id="_idContainer330" class="IMG---Figure">
					<img src="image/Figure_9.15_B16321.jpg" alt="Figure 9.15 – Importing certificates&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.15 – Importing certificates</p>
			<p>Click the <strong class="bold">Import</strong> button, navigate to<a id="_idIndexMarker553"/> the recently downloaded <strong class="source-inline">ca.cert</strong> file, and click <strong class="bold">OK</strong>.</p>
			<p>You will see the following screen:</p>
			<div>
				<div id="_idContainer331" class="IMG---Figure">
					<img src="image/Figure_9.16_B16321.jpg" alt="Figure 9.16 – Setting trust options&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.16 – Setting trust options</p>
			<p>Select <strong class="bold">Trust this CA to identify websites</strong> and then the <strong class="bold">OK</strong> button. Scroll down to find the <strong class="bold">PortSwigger</strong> certificate to make sure that the import went smoothly. You should see the following screen:</p>
			<div>
				<div id="_idContainer332" class="IMG---Figure">
					<img src="image/Figure_9.17_B16321.jpg" alt="Figure 9.17 – PortSwigger certificate&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.17 – PortSwigger certificate</p>
			<p>Finish installing the certificate by clicking <strong class="bold">OK</strong>. </p>
			<p>There you have it! We<a id="_idIndexMarker554"/> have successfully installed the certificate. Now, it is time to open up BurpSuite. Find and open BurpSuite on your Kali Linux VM. You will be presented with the option to configure a project. This is a great opportunity for you to start organizing engagements into various projects, as it will help you in the long run when it comes to writing your findings report. I will use a <strong class="bold">Temporary project</strong> going forward, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer333" class="IMG---Figure">
					<img src="image/Figure_9.18_B16321.jpg" alt="Figure 9.18 – Temporary project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.18 – Temporary project</p>
			<p>On the next screen, you will have the option to load preset configurations or use BurpSuite's default settings. I am going to select <strong class="bold">Use Burp defaults</strong>:</p>
			<div>
				<div id="_idContainer334" class="IMG---Figure">
					<img src="image/Figure_9.19_B16321.jpg" alt="Figure 9.19 – Burp default settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.19 – Burp default settings</p>
			<p>Next, we want to make <a id="_idIndexMarker555"/>sure that Burp is using the correct proxy listener. So, select the <strong class="bold">Proxy</strong> menu item and then select <strong class="bold">Options</strong>. From here, add a new proxy listener with the interface set to an IP <strong class="source-inline">Address:Port</strong> number and <strong class="bold">Certificate</strong> set to <strong class="bold">Per-host</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer335" class="IMG---Figure">
					<img src="image/Figure_9.20_B16321.jpg" alt="Figure 9.20 – Proxy Listeners&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.20 – Proxy Listeners</p>
			<p>Make sure that you have your proxy selected and that <strong class="bold">Intercept is on is enabled</strong>, as shown in the following screenshot. Also, make sure that you have toggled BurpSuite on in FoxyProxy:</p>
			<div>
				<div id="_idContainer336" class="IMG---Figure">
					<img src="image/Figure_9.21_B16321.jpg" alt="Figure 9.21 – Intercept is on&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.21 – Intercept is on</p>
			<p>Now for the fun part: this is <a id="_idIndexMarker556"/>where we will be intercepting traffic and analyzing its behavior in BurpSuite. Navigate to Ignition SCADA's login page:</p>
			<div>
				<div id="_idContainer337" class="IMG---Figure">
					<img src="image/Figure_9.22_B16321.jpg" alt="Figure 9.22 – Ignition login&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.22 – Ignition login</p>
			<p>You may notice a lack of functionality, and that is because BurpSuite has intercepted the <strong class="source-inline">GET</strong> request that you just initiated. If BurpSuite didn't automatically pop up when it should have, you can simply navigate to it and click the <strong class="bold">Proxy</strong> tab and then the <strong class="bold">Intercept</strong> sub-tab:</p>
			<div>
				<div id="_idContainer338" class="IMG---Figure">
					<img src="image/Figure_9.23_B16321.jpg" alt="Figure 9.23 – Login intercept&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.23 – Login intercept</p>
			<p>If we look a little <a id="_idIndexMarker557"/>closer at the details, we will find that by simply opening the login screen, we kick off a bunch of traffic, as shown here:</p>
			<p class="source-code">GET /idp/default/authn/login?app=gateway&amp;token=Pj0cPAqKDiqz0WvV4xsfjwnSd2e2Tt74 Xz1TcxT7cnQ&amp;token=GH3KbGJqdSGsTTUQNDqKB7WFLR0NOoJgwFni Bohji40&amp;response_type=code&amp;client_id=ignition&amp;redirect_uri=%2Fdata%2Ffederate%2 Fcallback%2Fignition&amp;scope=openid&amp;state=eyJraWQiOiJrMSIsImFsZyI 6IkhTMjU2In0.eyJqdGkiOiJyRUNzVFdPUTE4aDVQM2ViSUd0cnBDc25BTENncmZ nakNpNl9nQWlxYjZrIiwidXJpIjoiL3dlYi9ob21lIn0.ogt_6V-fkMDS2gZCVm0lsxc4dF2XrauixoEFznsZ-2c&amp;nonce=XepL7IYBXqStUEVhMKtl83hxnYL9wI1fdM1wsPJgxpM&amp;prompt=login&amp;max_age=1 HTTP/1.1</p>
			<p class="source-code">Host: 192.168.2.10:8088</p>
			<p class="source-code">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0)</p>
			<p class="source-code">Gecko/20100101 Firefox/78.0</p>
			<p class="source-code">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</p>
			<p class="source-code">Accept-Language: en-US,en;q=0.5</p>
			<p class="source-code">Accept-Encoding: gzip, deflate</p>
			<p class="source-code">Referer: http://192.168.2.10:8088/idp/default/authn/login?app=gateway&amp;token=KeaSv4c6jR0-KTtpNQ16ob3dYKBs8D9BO1aokZUQ il0&amp;token=Pj0cPAqKDiqz0WvV4xsfjwnSd2e2Tt74Xz1TcxT7cnQ&amp;response _type=code&amp;client_id=ignition&amp;redirect_uri=%2Fdata%2Ffederate%2 Fcallback%2Fignition&amp;scope=openid&amp;state=eyJraWQiOiJrMSIsImFsZy I6IkhTMjU2In0.eyJqdGkiOiJyRUNzVFdPUTE4aDVQM2ViSUd0cnBDc25BTENncm ZnakNpNl9nQWlxYjZrIiwidXJpIjoiL3dlYi9ob21lIn0.ogt_6V-fkMDS2gZCVm 0lsxc4dF2XrauixoEFznsZ-2c&amp;nonce=XepL7IYBXqStUEVhMKtl83hxnYL9w I1fdM1wsPJgxpM&amp;prompt=login&amp;max_age=1</p>
			<p class="source-code">Connection: close</p>
			<p class="source-code">Cookie: default.sid=fj0zNMpRCctgmCAWcfJlJwrhPIVrZD-Auda96Bmghk4; JSESSIONID=node01u4ie14zjwage1dqw2zu6fs16q8.node0</p>
			<p class="source-code">Upgrade-Insecure-Requests: 1</p>
			<p class="source-code">Cache-Control: max-age=0</p>
			<p>Now, try to log in with the <strong class="source-inline">admin</strong>:<strong class="source-inline">admin</strong> credentials. I know that we set the real credentials to <strong class="source-inline">scada</strong>:<strong class="source-inline">scada</strong>, but we are going to approach this as if we have just discovered the system during a pentest. Also, there is <a id="_idIndexMarker558"/>a high probability that you could accidentally guess the correct credentials by doing this. This is because one of the most prevalent <a id="_idIndexMarker559"/>problems in the <strong class="bold">Operational Technology</strong> (<strong class="bold">OT</strong>) space is the continued use of factory credentials. You should be sitting on the login screen after filling out these credentials, similar to what's shown in the following screenshot:</p>
			<div>
				<div id="_idContainer339" class="IMG---Figure">
					<img src="image/Figure_9.24_B16321.jpg" alt="Figure 9.24 – admin:admin credentials&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.24 – admin:admin credentials</p>
			<p>Now, we want to navigate<a id="_idIndexMarker560"/> to BurpSuite and have a look at the <strong class="source-inline">POST</strong> request that we have just intercepted, as shown here:</p>
			<div>
				<div id="_idContainer340" class="IMG---Figure">
					<img src="image/Figure_9.25_B16321.jpg" alt="Figure 9.25 – POST request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.25 – POST request</p>
			<p>From here, we want to utilize a powerful tool built into BurpSuite known as <strong class="bold">Repeater</strong>. This allows us to modify and test our request over and over again, hence its name. To do this, we are going to right-click and select the <strong class="bold">Send to Repeater</strong> option, as shown here:</p>
			<div>
				<div id="_idContainer341" class="IMG---Figure">
					<img src="image/Figure_9.26_B16321.jpg" alt="Figure 9.26 – Send to Repeater&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.26 – Send to Repeater</p>
			<p>This will now pass the <strong class="source-inline">POST</strong> request that we intercepted to the <strong class="bold">Repeater</strong> tool. You should see a screen<a id="_idIndexMarker561"/> similar to the following:</p>
			<div>
				<div id="_idContainer342" class="IMG---Figure">
					<img src="image/Figure_9.27_B16321.jpg" alt="Figure 9.27 – Repeater tool&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.27 – Repeater tool</p>
			<p>Once inside the <strong class="bold">Repeater</strong> tool, press the <strong class="bold">Send</strong> button to pass the request through to the server. Notice the response on the right-hand side of the screen. Looking closely, you will see that the message being relayed is <strong class="bold">Invalid token</strong>:</p>
			<div>
				<div id="_idContainer343" class="IMG---Figure">
					<img src="image/Figure_9.28_B16321.jpg" alt="Figure 9.28 – Invalid token&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.28 – Invalid token</p>
			<p>Looking closer at the request that we just sent with the <strong class="bold">Repeater</strong> tool, we can see what looks like a <strong class="bold">Cross-Site Request Forgery</strong> (<strong class="bold">CSRF</strong>) token. This makes it much more complex<a id="_idIndexMarker562"/> to brute force as <a id="_idIndexMarker563"/>now, we have to figure out how or what utility Ignition is using to generate these tokens:</p>
			<div>
				<div id="_idContainer344" class="IMG---Figure">
					<img src="image/Figure_9.29_B16321.jpg" alt="Figure 9.29 – CSRF token&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.29 – CSRF token</p>
			<p>Knowing that we are going to have to find the source of the token's generation means deeper investigation on our side. Let's start by going back to our <strong class="bold">Proxy</strong> | <strong class="bold">HTTP</strong> history and then clicking the <strong class="bold">GET</strong> method to show the details of our <strong class="bold">Request</strong> and <strong class="bold">Response</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer345" class="IMG---Figure">
					<img src="image/Figure_9.30_B16321.jpg" alt="Figure 9.30 – HTTP history&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.30 – HTTP history</p>
			<p>Nothing pops out as being of interest to us in this particular session. Somewhere inside this exchange of various <strong class="bold">Requests</strong>, where the CSRF token has to have been created and shared, click on the <strong class="source-inline">POST</strong> method above the <strong class="source-inline">GET</strong> request, as shown in the following screenshot, to see if this happens to reveal any clues about the token's creation:</p>
			<div>
				<div id="_idContainer346" class="IMG---Figure">
					<img src="image/Figure_9.31_B16321.jpg" alt="Figure 9.31 – POST request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.31 – POST request</p>
			<p>OK, this looks very promising as we <a id="_idIndexMarker564"/>can see a token being passed in the response from <strong class="source-inline">/idp/default/authn/next-challenge</strong>. It looks like the token that's required in the username-password <strong class="source-inline">POST</strong> request, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer347" class="IMG---Figure">
					<img src="image/Figure_9.32_B16321.jpg" alt="Figure 9.32 – The next-challenge token&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.32 – The next-challenge token</p>
			<p>Now, right-click <strong class="bold">Request</strong> and send it to <strong class="bold">Repeater</strong>, as we did previously, to try and generate the <strong class="source-inline">next-challenge</strong> token. Once you<a id="_idIndexMarker565"/> are back inside the <strong class="bold">Repeater</strong> tab, go ahead and press <strong class="bold">Send</strong> to test the <strong class="source-inline">POST</strong> request. You should see an output similar to the following:</p>
			<div>
				<div id="_idContainer348" class="IMG---Figure">
					<img src="image/Figure_9.33_B16321.jpg" alt="Figure 9.33 – Resend token&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.33 – Resend token</p>
			<p>Once again, we have an <strong class="source-inline">Invalid token</strong> message, which means that our <strong class="bold">Request</strong> token has expired. We need to go back further to see how our <strong class="source-inline">next-challenge</strong> token is generated. Navigate back to <strong class="bold">Proxy</strong> | <strong class="bold">Http history</strong> and look at the requests prior to the <strong class="source-inline">next-challenge</strong> POST request. In the following screenshot, we can see that there are a series of <strong class="source-inline">GET</strong> requests before a previous <strong class="source-inline">next-challenge</strong>:</p>
			<div>
				<div id="_idContainer349" class="IMG---Figure">
					<img src="image/Figure_9.34_B16321.jpg" alt="Figure 9.34 – The oidc GET request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.34 – The oidc GET request</p>
			<p>There's one very interesting <strong class="source-inline">GET</strong> request here, and it happens to contain <strong class="source-inline">oidc</strong> in the path.  <strong class="bold">OpenID Connect</strong> (<strong class="bold">OIDC</strong>) is used to<a id="_idIndexMarker566"/> verify users that are attempting to authenticate to a web application securely and <a id="_idIndexMarker567"/>easily. To read more about <strong class="source-inline">oidc</strong>, take a look at <a href="https://www.onelogin.com/blog/openid-connect-explained-in-plain-english">https://www.onelogin.com/blog/openid-connect-explained-in-plain-english</a>. For our uses, all we need to know is that this is most likely the starting point for creating our tokens. Now, upon clicking on this <strong class="source-inline">GET</strong> method, we will see the following <strong class="bold">Request</strong> and <strong class="bold">Response</strong> output:</p>
			<div>
				<div id="_idContainer350" class="IMG---Figure">
					<img src="image/Figure_9.35_B16321.jpg" alt="Figure 9.35 – OIDC 302 error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.35 – OIDC 302 error</p>
			<p>As you can see, we get a response code of <strong class="source-inline">302</strong>, and deeper inside <strong class="source-inline">Location:</strong>, we can see our <strong class="source-inline">next-challenge</strong> token. For a third time now, let's send our <strong class="bold">Request</strong> to the <strong class="bold">Repeater</strong> tool and push the <strong class="bold">Send</strong> button. You will receive the following output:</p>
			<div>
				<div id="_idContainer351" class="IMG---Figure">
					<img src="image/Figure_9.36_B16321.jpg" alt="Figure 9.36 – OIDC next-challenge token&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.36 – OIDC next-challenge token</p>
			<p>This is very promising, as we can now see that a new token has been created and that there are no failure <a id="_idIndexMarker568"/>messages. The great part about the <strong class="bold">Repeater</strong> tool is that we can edit data and resend it to see how that input data affects the response. Go ahead and press <strong class="bold">Send</strong> a few times; you will notice that the only thing that changes is that specific token. Now, if you have been following along so far, you should have three tabs in your <strong class="bold">Repeater</strong> header:</p>
			<div>
				<div id="_idContainer352" class="IMG---Figure">
					<img src="image/Figure_9.37_B16321.jpg" alt="Figure 9.37 – Three Repeater sessions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.37 – Three Repeater sessions</p>
			<p>The <strong class="bold">Repeater</strong> tool will keep track of the requests that we sent in the previous steps, which makes it a very useful tool for testing our theory regarding CRSF token creation. With that said, press <strong class="bold">Send</strong> one more time to generate a fresh <strong class="source-inline">oidc</strong> token. Copy the dedicated token, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer353" class="IMG---Figure">
					<img src="image/Figure_9.38_B16321.jpg" alt="Figure 9.38 – OIDC token generation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.38 – OIDC token generation</p>
			<p>Now, we want to click on the tab labeled with the number <strong class="bold">2</strong>. You will see our previous failed attempt at<a id="_idIndexMarker569"/> generating a <strong class="source-inline">next-challenge</strong> token. Replace the token under <strong class="bold">Request</strong> with our newly generated <strong class="source-inline">oidc</strong> token, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer354" class="IMG---Figure">
					<img src="image/Figure_9.39_B16321.jpg" alt="Figure 9.39 – Replacing the failed token with a new oidc token&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.39 – Replacing the failed token with a new oidc token</p>
			<p>Resend the request. If you followed along and performed these steps correctly, you should get a <strong class="bold">200</strong> response, which will look similar to this:</p>
			<div>
				<div id="_idContainer355" class="IMG---Figure">
					<img src="image/Figure_9.40_B16321.jpg" alt="Figure 9.40 – 200 response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.40 – 200 response</p>
			<p>Excellent! Now, we are stepping in the right direction. From here, we want to copy our newly generated <strong class="source-inline">next-challenge</strong> token and click the <strong class="bold">Repeater</strong> tab labeled with the number <strong class="bold">1</strong>. You will see our original failed <strong class="source-inline">username-password-challenge</strong> attempt with a response message of <strong class="bold">Invalid token</strong>. Replace the CSRF token with our generated <strong class="source-inline">next-challenge</strong> token. Our <strong class="bold">Request</strong> should appear as follows:</p>
			<div>
				<div id="_idContainer356" class="IMG---Figure">
					<img src="image/Figure_9.41_B16321.jpg" alt="Figure 9.41 – username-password-challenge new token&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.41 – username-password-challenge new token</p>
			<p>Now, resend this <strong class="bold">Request</strong>; you should see a <strong class="source-inline">200</strong> response, indicating that we passed a valid CSRF token and have<a id="_idIndexMarker570"/> returned a JSON response. In the output, we can see that <strong class="source-inline">success</strong> was <strong class="source-inline">false</strong>, meaning that the credentials we used were wrong, which we knew would be the case, and also a valid <strong class="bold">Response</strong> token, as follows:</p>
			<div>
				<div id="_idContainer357" class="IMG---Figure">
					<img src="image/Figure_9.42_B16321.jpg" alt="Figure 9.42 – Bypassing the CSRF token&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.42 – Bypassing the CSRF token</p>
			<p>We now want to verify if our theory<a id="_idIndexMarker571"/> is truly correct. Seeing as we installed Ignition with the credentials of <strong class="source-inline">scada</strong>:<strong class="source-inline">scada</strong> inside our <strong class="bold">Industrial Control System</strong> (<strong class="bold">ICS</strong>) lab, let's rerun our<a id="_idIndexMarker572"/> steps to verify that everything works as expected. You should see the following output:</p>
			<div>
				<div id="_idContainer358" class="IMG---Figure">
					<img src="image/Figure_9.43_B16321.jpg" alt="Figure 9.43 – Successful authentication&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.43 – Successful authentication</p>
			<p>And just like that, we've found a way to generate unique CSRF tokens and brute force the auth of Ignition. Now, beyond the euphoria of thwarting CRSF, we realize that manually doing this would take a lifetime, and we just don't have that luxury of time during a pentesting engagement. Using BurpSuite, we have various ways of automating these steps. If you are using the Pro version, you can <strong class="bold">Generate CSRF PoC</strong> by navigating to the following menu:</p>
			<div>
				<div id="_idContainer359" class="IMG---Figure">
					<img src="image/Figure_9.44_B16321.jpg" alt="Figure 9.44 – Pro version – Generate CSRF PoC&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.44 – Pro version – Generate CSRF PoC</p>
			<p>As you can see, though, I am using the Community Edition, which means that I can use <strong class="bold">Session Rules</strong> to run various macros or import a Burp extension such as <strong class="bold">Custom Parameter Handler</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer360" class="IMG---Figure">
					<img src="image/Figure_9.45_B16321.jpg" alt="Figure 9.45 – Custom Parameter Handler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.45 – Custom Parameter Handler</p>
			<p>However, due to the throttled limitations<a id="_idIndexMarker573"/> of the Community Edition, this type of attack would take forever – maybe not as long as manually running the attack, but far too long for our requirements. So, the suggestion is either to upgrade to the Pro version or write your own script. We will be doing this in the next section.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor110"/>Building a script for brute-forcing SCADA</h1>
			<p>I am going to <a id="_idIndexMarker574"/>assume that by reading this book, you have a relative level of proficiency or exposure to programming/bash scripting. If not, I strongly recommend brushing up on bash scripting and/or Python. Two books that I personally recommend are as follows:</p>
			<ul>
				<li><em class="italic">Cybersecurity Ops with bash</em>, by Paul Troncone and Carl Albing, PhD</li>
				<li><em class="italic">Black Hat Python</em>, by Justin Seitz</li>
			</ul>
			<p>These are great resources for you to get a good idea of how and what Bash and Python can do and perform. The biggest takeaway is that by reading this book and going through these chapters, you will learn how to make these scripting/programming languages useful inside your pentesting engagement.</p>
			<p>I prefaced this section with the preceding note as I am going to try and make this process as painless as possible. As a disclaimer, I have to say that I am a developer at best, not a programmer by any means. I am making this distinction as programmers who decide to make their career by building test-driven programs will review my code and have a good chuckle. However, I can say that I can get from point A to point B with my code and frankly, the end result is all I care about. </p>
			<p>With that said, let's jump right in, shall we? The quickest way is by starting with the <strong class="bold">Repeater</strong> tool, navigating to the <strong class="bold">Request</strong> column, and specifically starting with the <strong class="source-inline">/idp/default/oidc/auth?</strong> request, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer361" class="IMG---Figure">
					<img src="image/Figure_9.46_B16321.jpg" alt="Figure 9.46 – OIDC request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.46 – OIDC request</p>
			<p>Now, we want to right-click on <strong class="bold">Request</strong>. You will be presented with a context menu where you<a id="_idIndexMarker575"/> have the option to <strong class="bold">Copy as curl command</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer362" class="IMG---Figure">
					<img src="image/Figure_9.47_B16321.jpg" alt="Figure 9.47 – Right-clicking Request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.47 – Right-clicking Request</p>
			<p>Open a terminal and test what you have copied as a <strong class="source-inline">curl</strong> command by pasting it into the command line and running it. You should see the following results. Here, we will focus on the token that was generated. This should match what we performed in the previous section using the <strong class="bold">Repeater</strong> tool:</p>
			<div>
				<div id="_idContainer363" class="IMG---Figure">
					<img src="image/Figure_9.48_B16321.jpg" alt="Figure 9.48 – curl OIDC request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.48 – curl OIDC request</p>
			<p>Run the command a few <a id="_idIndexMarker576"/>more times and analyze the results. You should see that this token has been uniquely generated. Awesome – now what? You must create a <strong class="source-inline">bash</strong> file with your favorite editor! I will be using nano for simplicity's sake. Run the following command in your terminal:</p>
			<p class="source-code">nano exploit.sh</p>
			<p>This will bring up the nano editor. Here, we will want to paste in the <strong class="source-inline">curl</strong> command that we were just using. Next, we want to wrap our <strong class="source-inline">curl</strong> command in an <strong class="source-inline">eval</strong> statement and <strong class="source-inline">grep</strong> out our token, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer364" class="IMG---Figure">
					<img src="image/Figure_9.49_B16321.jpg" alt="Figure 9.49 – Our bash OIDC token script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.49 – Our bash OIDC token script</p>
			<p>Taking a closer look at the specific commands, you can see that we are assigning our <strong class="source-inline">curl</strong> command to a variable called <strong class="source-inline">oidc_cmd</strong>. Then, we are running <strong class="source-inline">eval</strong> against the command and piping it into the <strong class="source-inline">grep</strong> command:</p>
			<p class="source-code">oidc_token=$(eval $oidc_cmd | grep -oP '(?&lt;=c\&amp;token=).*(?=\&amp;response)')</p>
			<p>We are grepping to find a string that is in-between <strong class="source-inline">c&amp;token=</strong> and <strong class="source-inline">&amp;response</strong> from our <strong class="source-inline">curl</strong> response. It is important to note that the <strong class="source-inline">c</strong> character in the preceding command is the last character from the previous token, so it may need to be adjusted before you run this script. It is important to add this character here in the <strong class="source-inline">grep</strong> statement as the <strong class="source-inline">curl</strong> response<a id="_idIndexMarker577"/> generates two tokens, and we are only concerned with our <strong class="source-inline">oidc</strong> token. </p>
			<p>Now, go ahead and test the script you just created by running the following command:</p>
			<p class="source-code">bash exploit.sh</p>
			<p>You should see the following output:</p>
			<div>
				<div id="_idContainer365" class="IMG---Figure">
					<img src="image/Figure_9.50_B16321.jpg" alt="Figure 9.50 – OIDC token created&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.50 – OIDC token created</p>
			<p>Now, let's repeat the same steps with the request for <strong class="source-inline">/idp/default/authn/next-challenge</strong> by right-clicking <strong class="bold">Request</strong> under the <strong class="bold">Repeater</strong> tool in BurpSuite and then selecting <strong class="bold">Copy as curl command</strong>. We must paste this into our text editor and wrap it, as we did previously. However, this time, we need to pass <strong class="source-inline">oidc_token</strong> as a parameter into the newly wrapped <strong class="source-inline">curl</strong> command, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer366" class="IMG---Figure">
					<img src="image/Figure_9.51_B16321.jpg" alt="Figure 9.51 – The next-challenge token script&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.51 – The next-challenge token script</p>
			<p>Comparing our <strong class="source-inline">grep</strong> statements between the two commands shows us that there is a slight variation, since the response from the <strong class="source-inline">/next-challenge</strong> request returns the output as a JSON object, so we need to parse it out accordingly. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you get stuck here and you can't get <strong class="source-inline">/next-challenge</strong> to provide you with a <strong class="source-inline">200</strong> response code so that you can find this token, you may have to refresh your session ID for the <strong class="source-inline">default.sid</strong> cookie by refreshing the Ignition login screen, capturing the request in BurpSuite, and updating your <strong class="source-inline">default.sid</strong> value for each <strong class="source-inline">curl</strong> request. You will know right away that you need to refresh if you get a response code of <strong class="source-inline">400</strong> and a message of <strong class="source-inline">Invalid Session</strong>.</p>
			<p>If you have followed along, copied everything, and have a valid session ID, you should see the following output as you run your exploit:</p>
			<div>
				<div id="_idContainer367" class="IMG---Figure">
					<img src="image/Figure_9.52_B16321.jpg" alt="Figure 9.52 – The next-challenge token generated&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.52 – The next-challenge token generated</p>
			<p>At this point, you<a id="_idIndexMarker578"/> should have the <strong class="source-inline">oidc</strong> token and the <strong class="source-inline">next-challenge</strong> token. Now, it is time to pass the newly generated <strong class="source-inline">next-challenge</strong> token into the auth request. Repeat the steps that we completed previously:</p>
			<ol>
				<li value="1">Right-click our <strong class="source-inline">/idp/default/authn/submit-username-password-challenge</strong> request.</li>
				<li>Select <strong class="bold">Copy as curl command</strong>.</li>
				<li>Paste the <strong class="source-inline">curl</strong> command that you just copied into the text editor.</li>
				<li>Wrap the <strong class="source-inline">curl</strong> command for evaluation.</li>
				<li>Pass the <strong class="source-inline">next-challenge</strong> token into the <strong class="source-inline">auth</strong> request.</li>
				<li>Update <strong class="source-inline">default.sid</strong> if it has timed out.</li>
			</ol>
			<p>The <strong class="source-inline">auth</strong> section of your exploit script should look similar to the following:</p>
			<div>
				<div id="_idContainer368" class="IMG---Figure">
					<img src="image/Figure_9.53_B16321.jpg" alt="Figure 9.53 – auth command&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.53 – auth command</p>
			<p>Here, you can see that we are hardcoding the default creds of <strong class="source-inline">scada</strong>:<strong class="source-inline">scada</strong> to test if our script is successful. If everything is correct and <strong class="source-inline">default.sid</strong> is still valid, when you run the script, your output should appear like so:</p>
			<div>
				<div id="_idContainer369" class="IMG---Figure">
					<img src="image/Figure_9.54_B16321.jpg" alt="Figure 9.54 – Successful authentication&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.54 – Successful authentication</p>
			<p>We can refactor the parameters that we know will change from engagement to engagement. I used the <strong class="source-inline">host</strong>, <strong class="source-inline">sid</strong>, <strong class="source-inline">user</strong>, and <strong class="source-inline">pass</strong> parameters.</p>
			<p>We know from <a id="_idIndexMarker579"/>past pentest engagements that customers will change their host address, so we should create a variable to handle this. We know that an initial <strong class="source-inline">default.sid</strong> is created that we need to pass through all three requests, so we will create a variable for this behavior. Our username and password should both have variables as well. Here is what the initial refactor looks like:</p>
			<div>
				<div id="_idContainer370" class="IMG---Figure">
					<img src="image/Figure_9.55_B16321.jpg" alt="Figure 9.55 – Script refactor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.55 – Script refactor</p>
			<p>We need to test our results post-refactoring to verify that we haven't broken anything. So, run the exploit script; you should get something similar to the following:</p>
			<div>
				<div id="_idContainer371" class="IMG---Figure">
					<img src="image/Figure_9.56_B16321.jpg" alt="Figure 9.56 – Post-refactor test&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.56 – Post-refactor test</p>
			<p>Now, this section's title has "brute-forcing" in it. This means we need to incorporate a way to read a list of users and passwords and attempt to authenticate against Ignition's login screen. I took the liberty of refactoring yet again and removing some of the unnecessary headers that were being passed, and I also wrapped the three curl requests into a function, as shown here:</p>
			<div>
				<div id="_idContainer372" class="IMG---Figure">
					<img src="image/Figure_9.57_B16321.jpg" alt="Figure 9.57 – test_auth function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.57 – test_auth function</p>
			<p>Here, you can see that <strong class="source-inline">next_cmd</strong> and <strong class="source-inline">auth_cmd</strong> have drastically been reduced in size. From here, we<a id="_idIndexMarker580"/> need to build out a way to read a list of users and a list of passwords. We want to add the ability to open a file, read it line by line, and pass it to the variables that we declared earlier. Using the following pseudocode, we can adjust it to our needs:</p>
			<p class="source-code">while IFS='' read -r user || [[ -n "${user}" ]]; do </p>
			<p class="source-code">  test_auth</p>
			<p class="source-code">  if [[ $success == "true" ]]; then</p>
			<p class="source-code">    echo $output</p>
			<p class="source-code">  fi</p>
			<p class="source-code">done &lt; $1</p>
			<p>The general idea here is that we are going to pass in a filename for users. Then, a <strong class="source-inline">while</strong> loop will iterate through each user, set our <strong class="source-inline">$user</strong> variable, and launch the <strong class="source-inline">test_auth</strong> function, which will kick off the token's creation and auth attempt. Run the following command:</p>
			<p class="source-code">bash exploit.sh users.txt</p>
			<p>This will allow us to pass <strong class="source-inline">users.txt</strong> to the <strong class="source-inline">while</strong><a id="_idIndexMarker581"/> loop and have an <strong class="bold">internal field separator</strong> (<strong class="bold">IFS</strong>) iterate through the individual users. Inside <strong class="source-inline">users.txt</strong>, we have three usernames – <strong class="source-inline">"plc"</strong>, <strong class="source-inline">"scada"</strong>, and <strong class="source-inline">"test"</strong> – to make things simple. I have also taken the liberty of baking in reading a password file and creating some verbosity. Have a look at the following <a id="_idIndexMarker582"/>code sample:</p>
			<div>
				<div id="_idContainer373" class="IMG---Figure">
					<img src="image/Figure_9.58_B16321.jpg" alt="Figure 9.58 – Brute-forcing the username and password&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.58 – Brute-forcing the username and password</p>
			<p>The command you should run now is as follows:</p>
			<p class="source-code">bash exploit.sh users.txt passwords.txt -v</p>
			<p>Inside <strong class="source-inline">passwords.txt</strong>, for simplicity's sake, I only added four passwords, and they were <strong class="source-inline">"admin"</strong>, <strong class="source-inline">"password"</strong>, <strong class="source-inline">"scada"</strong>, and <strong class="source-inline">"changeme"</strong>. Running the preceding command should generate the following output, whereby we get a successful authentication:</p>
			<div>
				<div id="_idContainer374" class="IMG---Figure">
					<img src="image/Figure_9.59_B16321.jpg" alt="Figure 9.59 – Successful authentication&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.59 – Successful authentication</p>
			<p>Here, you have a fully baked brute-forcing script. We created <strong class="source-inline">oidc</strong> tokens and used them to autogenerate<a id="_idIndexMarker583"/> CSRF tokens, as well as to test usernames and passwords against the Ignition SCADA system with our newly minted script.</p>
			<p class="callout-heading">Disclaimer</p>
			<p class="callout">Before sounding alarm bells and submitting vulns to your local <strong class="bold">Computer Emergency Response Team</strong> (<strong class="bold">CERT</strong>), Inductive <a id="_idIndexMarker584"/>Automation has implemented server-side mitigations for brute-forcing attempts. If you try your known username with five incorrect passwords, Ignition will lock out that account for 5 minutes from the time you made your last attempt.  </p>
			<p>So, unless you have a well-curated list of users and a laser-focused password list, you will have to adjust your script to accommodate the fact that you will lock out any real accounts for every five failed attempts for 5 minutes. Not to mention that this type of brute-forcing at this level is bound to be picked up by an IDS if you haven't done your due diligence, which was mentioned in <a href="B16321_06_Epub_AM.xhtml#_idTextAnchor063"><em class="italic">Chapter 6</em></a>, <em class="italic">Packet Deep Dive</em>.  </p>
			<p>Now, the irony here is that if you were to adjust your script to intentionally lock out real users, it would force someone to authenticate to the server to reboot Ignition to override these lockouts. This<a id="_idIndexMarker585"/> would ultimately cause a <strong class="bold">Denial Of Service</strong> (<strong class="bold">DOS</strong>) against the SCADA server.</p>
			<p>In this section, we went through the steps of pulling information out of BurpSuite and translating it into a useful brute-forcing tool. We built on skills that we covered in earlier chapters and then extended our knowledge by working around client-side token generation. This is a <a id="_idIndexMarker586"/>very important skill to learn when it comes to pentesting, understanding your environment, and extracting as much information as possible to open doors that, at a glance, appear to be locked.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor111"/>Summary</h1>
			<p>I feel that we have covered a lot in this chapter, from installing FoxyProxy and using BurpSuite to capture and replay requests, to formulating how Ignition SCADA handles authentication and extracting that knowledge and building scriptable tools to help automate and generate tokens for brute forcing. You will definitely use each and every one of these tools and techniques throughout your career.  </p>
			<p>In the next chapter, we will be using everything we have learned up to this point to perform a pseudo mock pentest against our ICS lab.</p>
		</div>
	</body></html>