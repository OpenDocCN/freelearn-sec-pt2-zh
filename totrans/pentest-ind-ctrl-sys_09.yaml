- en: '*Chapter 9*: Ninja 308'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discussed the fundamentals of industrial protocols
    and specifically the nuances of two in particular: Modbus and Ethernet/IP. We
    discussed and used tools that allowed us to enumerate ports and discover services
    running on those devices. We also used tools to traverse directories and vhosts
    in [*Chapter 7*](B16321_07_Epub_AM.xhtml#_idTextAnchor081), *Scanning 101*, which
    means that we have a great foundational knowledge of both ends of the attack chain.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to spend time looking at attacks and, most importantly, brute forcing.
    As exciting as it is to find a legacy service that we then spend time reverse
    engineering and building an exploit for, time is typically not on our side. If
    you discover a system such as Ignition SCADA, which we installed in [*Chapter
    7*](B16321_07_Epub_AM.xhtml#_idTextAnchor081), *Scanning 101*, it is fairly common
    for operational personnel to use simple passwords or factory defaults to access
    the system. Gaining access to a SCADA system as a user allows you to take over
    absolute control of the industrial process. Acquiring this level of access is
    similar to the crown jewels of "Domain Admin" inside the Enterprise IT security
    landscape. Learning how to use a web pentesting tool such as BurpSuite is very
    important as it will aid in opening access to various systems by divulging real-world
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing FoxyProxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running BurpSuite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a script for brute-forcing SCADA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Kali Linux VM running with Firefox installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BurpSuite Community Edition installed. Go to this link to find the latest version:
    [https://portswigger.net/burp/communitydownload](https://portswigger.net/burp/communitydownload).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A default list of SCADA equipment passwords, which can be found at this link:
    [https://github.com/scadastrangelove/SCADAPASS/blob/master/scadapass.csv](https://github.com/scadastrangelove/SCADAPASS/blob/master/scadapass.csv).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can view this chapter''s code in action here: [https://bit.ly/3lAinwm](https://bit.ly/3lAinwm)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing FoxyProxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the installation of FoxyProxy, we should define what a proxy
    server is and why we would want to use one. A **proxy server** is a system that
    translates traffic from one network or device into another device or network.
    This is easier said than done, though: what does this mean for us and why would
    we care about translating traffic? A proxy server allows us to intercept all communication
    originating from and designated to our attacking host. This allows us to augment
    and change the behavior of how the request interacts with the server, such as
    by dropping JavaScript UI filtering and other interesting tasks. So, now that
    we know what a proxy server is, what is FoxyProxy? FoxyProxy is a simple but powerful
    proxy switch. It takes all the tediousness out of having to change the internal
    proxy settings of your browser. Simply add your new setting and use a switch to
    toggle between proxy servers and turn them on and off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to install FoxyProxy:'
  prefs: []
  type: TYPE_NORMAL
- en: To start, you will need to access your Kali Linux VM and start Firefox ESR.
    Once you have Firefox open, navigate to the right-hand side, where you will see
    the hamburger button or menu button; select it. It will bring up the following
    drop-down menu:![Figure 9.1 – Menu dropdown
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_9.01_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.1 – Menu dropdown
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With the menu open, select the **Add-ons** option. You will be presented with
    a screen showing recommendations, extensions, themes, and plugins. Navigate to
    the search bar, type in **foxyproxy**, and then press *Enter*, as shown in the
    following screenshot:![Figure 9.2 – Add-on search pop-up
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_9.02_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.2 – Add-on search pop-up
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By doing this, you will see a list of possible matching add-ons. You will see
    **FoxyProxy Standard** at the top of the list, as shown in the following screenshot:![Figure
    9.3 – FoxyProxy Standard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_9.03_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.3 – FoxyProxy Standard
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Clicking the **FoxyProxy Standard** link will cause a popup to appear that allows
    you to click the **Add to Firefox** button. This is shown in the following screenshot:![Figure
    9.4 – Installing FoxyProxy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_9.04_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.4 – Installing FoxyProxy
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Proceed by clicking the **Add to Firefox** button. At this point, you will be
    presented with a permissions request. This is important as you will be allowing
    FoxyProxy to change your browser settings. The following are the permissions that
    you will be granting FoxyProxy by adding it to your browser:![Figure 9.5 – FoxyProxy
    permissions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_9.05_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.5 – FoxyProxy permissions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click the **Add** button to successfully install FoxyProxy. You should now see
    a fox icon in the toolbar, on the right-hand side of Firefox. Clicking the icon
    brings up the following screen:![Figure 9.6 – FoxyProxy configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_9.06_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.6 – FoxyProxy configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We currently don't have any proxy settings so we will add some by clicking the
    **+ Add** link, as shown in the following screenshot:![Figure 9.7 – Adding settings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_9.07_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.7 – Adding settings
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Upon clicking this, you will be presented with a page that allows you to add
    your first proxy settings, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.8 – First proxy settings'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/Figure_9.08_B16321.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 9.8 – First proxy settings
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For these settings, I tend to set the following parameters:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Title or Description**: **BurpSuite**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Proxy Type**: **HTTP**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Proxy IP**: **127.0.0.1**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Port**: **8080**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click the **Save** button. Now, you should have the newly added setting when
    you click the fox icon in your toolbar, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – BurpSuite proxy'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.09_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – BurpSuite proxy
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have successfully installed FoxyProxy and configured our first
    proxy setting, which is convenient for BurpSuite. This is the next topic that
    we will be discussing. The simplicity of quickly configuring proxies and having
    the ability to toggle them on and off, as well as switching between the different
    proxies, will be very useful in your pentesting career.
  prefs: []
  type: TYPE_NORMAL
- en: Running BurpSuite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we installed FoxyProxy and configured some settings
    to accommodate our BurpSuite software. In this section, we are going to utilize
    BurpSuite to help us understand the **Request**/**Response** actions that Ignition
    SCADA utilizes to perform authentication and authorization. Now, for us to proceed,
    we need to add BurpSuite's certificate as a trusted source; otherwise, we will
    be forced to acknowledge every website we've visited as an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we must navigate to the IP address and port that we configured
    in our settings. Upon doing this, you will be presented with a **BurpSuite Community
    Edition** splash page with a **CA Certificate** button on the right-hand side,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – CA Certificate location'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.10_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – CA Certificate location
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon clicking this button, you will be presented with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Saving the CA Certificate'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.11_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – Saving the CA Certificate
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Save File** and click the **OK** button. Next, we want to navigate
    to our menu under the hamburger icon and select **Preferences**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Preferences'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.12_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – Preferences
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we want to select **Privacy & Security** on the left-hand side, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Privacy & Security'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.13_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – Privacy & Security
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down until you see the **Certificates** area, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Certificates'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.14_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – Certificates
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **View Certificates** button. You will be presented with the following
    pop-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Importing certificates'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.15_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.15 – Importing certificates
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Import** button, navigate to the recently downloaded **ca.cert**
    file, and click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Setting trust options'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.16_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.16 – Setting trust options
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Trust this CA to identify websites** and then the **OK** button. Scroll
    down to find the **PortSwigger** certificate to make sure that the import went
    smoothly. You should see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – PortSwigger certificate'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.17_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.17 – PortSwigger certificate
  prefs: []
  type: TYPE_NORMAL
- en: Finish installing the certificate by clicking **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There you have it! We have successfully installed the certificate. Now, it
    is time to open up BurpSuite. Find and open BurpSuite on your Kali Linux VM. You
    will be presented with the option to configure a project. This is a great opportunity
    for you to start organizing engagements into various projects, as it will help
    you in the long run when it comes to writing your findings report. I will use
    a **Temporary project** going forward, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Temporary project'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.18_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.18 – Temporary project
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, you will have the option to load preset configurations
    or use BurpSuite''s default settings. I am going to select **Use Burp defaults**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Burp default settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.19_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.19 – Burp default settings
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to make sure that Burp is using the correct proxy listener. So,
    select the **Proxy** menu item and then select **Options**. From here, add a new
    proxy listener with the interface set to an IP **Address:Port** number and **Certificate**
    set to **Per-host**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Proxy Listeners'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.20_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.20 – Proxy Listeners
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that you have your proxy selected and that **Intercept is on is enabled**,
    as shown in the following screenshot. Also, make sure that you have toggled BurpSuite
    on in FoxyProxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Intercept is on'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.21_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.21 – Intercept is on
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the fun part: this is where we will be intercepting traffic and analyzing
    its behavior in BurpSuite. Navigate to Ignition SCADA''s login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Ignition login'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.22_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.22 – Ignition login
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice a lack of functionality, and that is because BurpSuite has intercepted
    the **GET** request that you just initiated. If BurpSuite didn''t automatically
    pop up when it should have, you can simply navigate to it and click the **Proxy**
    tab and then the **Intercept** sub-tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Login intercept'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.23_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.23 – Login intercept
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look a little closer at the details, we will find that by simply opening
    the login screen, we kick off a bunch of traffic, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: GET /idp/default/authn/login?app=gateway&token=Pj0cPAqKDiqz0WvV4xsfjwnSd2e2Tt74
    Xz1TcxT7cnQ&token=GH3KbGJqdSGsTTUQNDqKB7WFLR0NOoJgwFni Bohji40&response_type=code&client_id=ignition&redirect_uri=%2Fdata%2Ffederate%2
    Fcallback%2Fignition&scope=openid&state=eyJraWQiOiJrMSIsImFsZyI 6IkhTMjU2In0.eyJqdGkiOiJyRUNzVFdPUTE4aDVQM2ViSUd0cnBDc25BTENncmZ
    nakNpNl9nQWlxYjZrIiwidXJpIjoiL3dlYi9ob21lIn0.ogt_6V-fkMDS2gZCVm0lsxc4dF2XrauixoEFznsZ-2c&nonce=XepL7IYBXqStUEVhMKtl83hxnYL9wI1fdM1wsPJgxpM&prompt=login&max_age=1
    HTTP/1.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Host: 192.168.2.10:8088'
  prefs: []
  type: TYPE_NORMAL
- en: 'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:78.0)'
  prefs: []
  type: TYPE_NORMAL
- en: Gecko/20100101 Firefox/78.0
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept-Language: en-US,en;q=0.5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept-Encoding: gzip, deflate'
  prefs: []
  type: TYPE_NORMAL
- en: 'Referer: http://192.168.2.10:8088/idp/default/authn/login?app=gateway&token=KeaSv4c6jR0-KTtpNQ16ob3dYKBs8D9BO1aokZUQ
    il0&token=Pj0cPAqKDiqz0WvV4xsfjwnSd2e2Tt74Xz1TcxT7cnQ&response _type=code&client_id=ignition&redirect_uri=%2Fdata%2Ffederate%2
    Fcallback%2Fignition&scope=openid&state=eyJraWQiOiJrMSIsImFsZy I6IkhTMjU2In0.eyJqdGkiOiJyRUNzVFdPUTE4aDVQM2ViSUd0cnBDc25BTENncm
    ZnakNpNl9nQWlxYjZrIiwidXJpIjoiL3dlYi9ob21lIn0.ogt_6V-fkMDS2gZCVm 0lsxc4dF2XrauixoEFznsZ-2c&nonce=XepL7IYBXqStUEVhMKtl83hxnYL9w
    I1fdM1wsPJgxpM&prompt=login&max_age=1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connection: close'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cookie: default.sid=fj0zNMpRCctgmCAWcfJlJwrhPIVrZD-Auda96Bmghk4; JSESSIONID=node01u4ie14zjwage1dqw2zu6fs16q8.node0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgrade-Insecure-Requests: 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cache-Control: max-age=0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try to log in with the **admin**:**admin** credentials. I know that we
    set the real credentials to **scada**:**scada**, but we are going to approach
    this as if we have just discovered the system during a pentest. Also, there is
    a high probability that you could accidentally guess the correct credentials by
    doing this. This is because one of the most prevalent problems in the **Operational
    Technology** (**OT**) space is the continued use of factory credentials. You should
    be sitting on the login screen after filling out these credentials, similar to
    what''s shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – admin:admin credentials'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.24_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.24 – admin:admin credentials
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to navigate to BurpSuite and have a look at the **POST** request
    that we have just intercepted, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – POST request'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.25_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.25 – POST request
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we want to utilize a powerful tool built into BurpSuite known as
    **Repeater**. This allows us to modify and test our request over and over again,
    hence its name. To do this, we are going to right-click and select the **Send
    to Repeater** option, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Send to Repeater'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.26_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.26 – Send to Repeater
  prefs: []
  type: TYPE_NORMAL
- en: 'This will now pass the **POST** request that we intercepted to the **Repeater**
    tool. You should see a screen similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.27 – Repeater tool'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.27_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.27 – Repeater tool
  prefs: []
  type: TYPE_NORMAL
- en: 'Once inside the **Repeater** tool, press the **Send** button to pass the request
    through to the server. Notice the response on the right-hand side of the screen.
    Looking closely, you will see that the message being relayed is **Invalid token**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.28 – Invalid token'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.28_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.28 – Invalid token
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking closer at the request that we just sent with the **Repeater** tool,
    we can see what looks like a **Cross-Site Request Forgery** (**CSRF**) token.
    This makes it much more complex to brute force as now, we have to figure out how
    or what utility Ignition is using to generate these tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.29 – CSRF token'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.29_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.29 – CSRF token
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing that we are going to have to find the source of the token''s generation
    means deeper investigation on our side. Let''s start by going back to our **Proxy**
    | **HTTP** history and then clicking the **GET** method to show the details of
    our **Request** and **Response**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.30 – HTTP history'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.30_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.30 – HTTP history
  prefs: []
  type: TYPE_NORMAL
- en: 'Nothing pops out as being of interest to us in this particular session. Somewhere
    inside this exchange of various **Requests**, where the CSRF token has to have
    been created and shared, click on the **POST** method above the **GET** request,
    as shown in the following screenshot, to see if this happens to reveal any clues
    about the token''s creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.31 – POST request'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.31_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.31 – POST request
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, this looks very promising as we can see a token being passed in the response
    from **/idp/default/authn/next-challenge**. It looks like the token that''s required
    in the username-password **POST** request, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.32 – The next-challenge token'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.32_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.32 – The next-challenge token
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, right-click **Request** and send it to **Repeater**, as we did previously,
    to try and generate the **next-challenge** token. Once you are back inside the
    **Repeater** tab, go ahead and press **Send** to test the **POST** request. You
    should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.33 – Resend token'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.33_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.33 – Resend token
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we have an **Invalid token** message, which means that our **Request**
    token has expired. We need to go back further to see how our **next-challenge**
    token is generated. Navigate back to **Proxy** | **Http history** and look at
    the requests prior to the **next-challenge** POST request. In the following screenshot,
    we can see that there are a series of **GET** requests before a previous **next-challenge**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.34 – The oidc GET request'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.34_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.34 – The oidc GET request
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one very interesting **GET** request here, and it happens to contain
    **oidc** in the path. **OpenID Connect** (**OIDC**) is used to verify users that
    are attempting to authenticate to a web application securely and easily. To read
    more about **oidc**, take a look at [https://www.onelogin.com/blog/openid-connect-explained-in-plain-english](https://www.onelogin.com/blog/openid-connect-explained-in-plain-english).
    For our uses, all we need to know is that this is most likely the starting point
    for creating our tokens. Now, upon clicking on this **GET** method, we will see
    the following **Request** and **Response** output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.35 – OIDC 302 error'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.35_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.35 – OIDC 302 error
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we get a response code of **302**, and deeper inside **Location:**,
    we can see our **next-challenge** token. For a third time now, let''s send our
    **Request** to the **Repeater** tool and push the **Send** button. You will receive
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.36 – OIDC next-challenge token'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.36_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.36 – OIDC next-challenge token
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very promising, as we can now see that a new token has been created
    and that there are no failure messages. The great part about the **Repeater**
    tool is that we can edit data and resend it to see how that input data affects
    the response. Go ahead and press **Send** a few times; you will notice that the
    only thing that changes is that specific token. Now, if you have been following
    along so far, you should have three tabs in your **Repeater** header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.37 – Three Repeater sessions'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.37_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.37 – Three Repeater sessions
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Repeater** tool will keep track of the requests that we sent in the previous
    steps, which makes it a very useful tool for testing our theory regarding CRSF
    token creation. With that said, press **Send** one more time to generate a fresh
    **oidc** token. Copy the dedicated token, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.38 – OIDC token generation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.38_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.38 – OIDC token generation
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to click on the tab labeled with the number **2**. You will see
    our previous failed attempt at generating a **next-challenge** token. Replace
    the token under **Request** with our newly generated **oidc** token, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.39 – Replacing the failed token with a new oidc token'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.39_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.39 – Replacing the failed token with a new oidc token
  prefs: []
  type: TYPE_NORMAL
- en: 'Resend the request. If you followed along and performed these steps correctly,
    you should get a **200** response, which will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.40 – 200 response'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.40_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.40 – 200 response
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent! Now, we are stepping in the right direction. From here, we want
    to copy our newly generated **next-challenge** token and click the **Repeater**
    tab labeled with the number **1**. You will see our original failed **username-password-challenge**
    attempt with a response message of **Invalid token**. Replace the CSRF token with
    our generated **next-challenge** token. Our **Request** should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.41 – username-password-challenge new token'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.41_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.41 – username-password-challenge new token
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, resend this **Request**; you should see a **200** response, indicating
    that we passed a valid CSRF token and have returned a JSON response. In the output,
    we can see that **success** was **false**, meaning that the credentials we used
    were wrong, which we knew would be the case, and also a valid **Response** token,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.42 – Bypassing the CSRF token'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.42_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.42 – Bypassing the CSRF token
  prefs: []
  type: TYPE_NORMAL
- en: 'We now want to verify if our theory is truly correct. Seeing as we installed
    Ignition with the credentials of **scada**:**scada** inside our **Industrial Control
    System** (**ICS**) lab, let''s rerun our steps to verify that everything works
    as expected. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.43 – Successful authentication'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.43_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.43 – Successful authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'And just like that, we''ve found a way to generate unique CSRF tokens and brute
    force the auth of Ignition. Now, beyond the euphoria of thwarting CRSF, we realize
    that manually doing this would take a lifetime, and we just don''t have that luxury
    of time during a pentesting engagement. Using BurpSuite, we have various ways
    of automating these steps. If you are using the Pro version, you can **Generate
    CSRF PoC** by navigating to the following menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.44 – Pro version – Generate CSRF PoC'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.44_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.44 – Pro version – Generate CSRF PoC
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, though, I am using the Community Edition, which means that
    I can use **Session Rules** to run various macros or import a Burp extension such
    as **Custom Parameter Handler**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.45 – Custom Parameter Handler'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.45_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.45 – Custom Parameter Handler
  prefs: []
  type: TYPE_NORMAL
- en: However, due to the throttled limitations of the Community Edition, this type
    of attack would take forever – maybe not as long as manually running the attack,
    but far too long for our requirements. So, the suggestion is either to upgrade
    to the Pro version or write your own script. We will be doing this in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Building a script for brute-forcing SCADA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I am going to assume that by reading this book, you have a relative level of
    proficiency or exposure to programming/bash scripting. If not, I strongly recommend
    brushing up on bash scripting and/or Python. Two books that I personally recommend
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Cybersecurity Ops with bash*, by Paul Troncone and Carl Albing, PhD'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Black Hat Python*, by Justin Seitz'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are great resources for you to get a good idea of how and what Bash and
    Python can do and perform. The biggest takeaway is that by reading this book and
    going through these chapters, you will learn how to make these scripting/programming
    languages useful inside your pentesting engagement.
  prefs: []
  type: TYPE_NORMAL
- en: I prefaced this section with the preceding note as I am going to try and make
    this process as painless as possible. As a disclaimer, I have to say that I am
    a developer at best, not a programmer by any means. I am making this distinction
    as programmers who decide to make their career by building test-driven programs
    will review my code and have a good chuckle. However, I can say that I can get
    from point A to point B with my code and frankly, the end result is all I care
    about.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let''s jump right in, shall we? The quickest way is by starting
    with the **Repeater** tool, navigating to the **Request** column, and specifically
    starting with the **/idp/default/oidc/auth?** request, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.46 – OIDC request'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.46_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.46 – OIDC request
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to right-click on **Request**. You will be presented with a context
    menu where you have the option to **Copy as curl command**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.47 – Right-clicking Request'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.47_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.47 – Right-clicking Request
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and test what you have copied as a **curl** command by pasting
    it into the command line and running it. You should see the following results.
    Here, we will focus on the token that was generated. This should match what we
    performed in the previous section using the **Repeater** tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.48 – curl OIDC request'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.48_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.48 – curl OIDC request
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the command a few more times and analyze the results. You should see that
    this token has been uniquely generated. Awesome – now what? You must create a
    **bash** file with your favorite editor! I will be using nano for simplicity''s
    sake. Run the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: nano exploit.sh
  prefs: []
  type: TYPE_NORMAL
- en: 'This will bring up the nano editor. Here, we will want to paste in the **curl**
    command that we were just using. Next, we want to wrap our **curl** command in
    an **eval** statement and **grep** out our token, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.49 – Our bash OIDC token script'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.49_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.49 – Our bash OIDC token script
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking a closer look at the specific commands, you can see that we are assigning
    our **curl** command to a variable called **oidc_cmd**. Then, we are running **eval**
    against the command and piping it into the **grep** command:'
  prefs: []
  type: TYPE_NORMAL
- en: oidc_token=$(eval $oidc_cmd | grep -oP '(?<=c\&token=).*(?=\&response)')
  prefs: []
  type: TYPE_NORMAL
- en: We are grepping to find a string that is in-between **c&token=** and **&response**
    from our **curl** response. It is important to note that the **c** character in
    the preceding command is the last character from the previous token, so it may
    need to be adjusted before you run this script. It is important to add this character
    here in the **grep** statement as the **curl** response generates two tokens,
    and we are only concerned with our **oidc** token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go ahead and test the script you just created by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: bash exploit.sh
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.50 – OIDC token created'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.50_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.50 – OIDC token created
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s repeat the same steps with the request for **/idp/default/authn/next-challenge**
    by right-clicking **Request** under the **Repeater** tool in BurpSuite and then
    selecting **Copy as curl command**. We must paste this into our text editor and
    wrap it, as we did previously. However, this time, we need to pass **oidc_token**
    as a parameter into the newly wrapped **curl** command, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.51 – The next-challenge token script'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.51_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.51 – The next-challenge token script
  prefs: []
  type: TYPE_NORMAL
- en: Comparing our **grep** statements between the two commands shows us that there
    is a slight variation, since the response from the **/next-challenge** request
    returns the output as a JSON object, so we need to parse it out accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you get stuck here and you can't get **/next-challenge** to provide you with
    a **200** response code so that you can find this token, you may have to refresh
    your session ID for the **default.sid** cookie by refreshing the Ignition login
    screen, capturing the request in BurpSuite, and updating your **default.sid**
    value for each **curl** request. You will know right away that you need to refresh
    if you get a response code of **400** and a message of **Invalid Session**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have followed along, copied everything, and have a valid session ID,
    you should see the following output as you run your exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.52 – The next-challenge token generated'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.52_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.52 – The next-challenge token generated
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should have the **oidc** token and the **next-challenge**
    token. Now, it is time to pass the newly generated **next-challenge** token into
    the auth request. Repeat the steps that we completed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click our **/idp/default/authn/submit-username-password-challenge** request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Copy as curl command**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the **curl** command that you just copied into the text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrap the **curl** command for evaluation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the **next-challenge** token into the **auth** request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update **default.sid** if it has timed out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **auth** section of your exploit script should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.53 – auth command'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.53_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.53 – auth command
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see that we are hardcoding the default creds of **scada**:**scada**
    to test if our script is successful. If everything is correct and **default.sid**
    is still valid, when you run the script, your output should appear like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.54 – Successful authentication'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.54_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.54 – Successful authentication
  prefs: []
  type: TYPE_NORMAL
- en: We can refactor the parameters that we know will change from engagement to engagement.
    I used the **host**, **sid**, **user**, and **pass** parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know from past pentest engagements that customers will change their host
    address, so we should create a variable to handle this. We know that an initial
    **default.sid** is created that we need to pass through all three requests, so
    we will create a variable for this behavior. Our username and password should
    both have variables as well. Here is what the initial refactor looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.55 – Script refactor'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.55_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.55 – Script refactor
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to test our results post-refactoring to verify that we haven''t broken
    anything. So, run the exploit script; you should get something similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.56 – Post-refactor test'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.56_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.56 – Post-refactor test
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this section''s title has "brute-forcing" in it. This means we need to
    incorporate a way to read a list of users and passwords and attempt to authenticate
    against Ignition''s login screen. I took the liberty of refactoring yet again
    and removing some of the unnecessary headers that were being passed, and I also
    wrapped the three curl requests into a function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.57 – test_auth function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.57_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.57 – test_auth function
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see that **next_cmd** and **auth_cmd** have drastically been
    reduced in size. From here, we need to build out a way to read a list of users
    and a list of passwords. We want to add the ability to open a file, read it line
    by line, and pass it to the variables that we declared earlier. Using the following
    pseudocode, we can adjust it to our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: while IFS='' read -r user || [[ -n "${user}" ]]; do
  prefs: []
  type: TYPE_NORMAL
- en: test_auth
  prefs: []
  type: TYPE_NORMAL
- en: if [[ $success == "true" ]]; then
  prefs: []
  type: TYPE_NORMAL
- en: echo $output
  prefs: []
  type: TYPE_NORMAL
- en: fi
  prefs: []
  type: TYPE_NORMAL
- en: done < $1
  prefs: []
  type: TYPE_NORMAL
- en: 'The general idea here is that we are going to pass in a filename for users.
    Then, a **while** loop will iterate through each user, set our **$user** variable,
    and launch the **test_auth** function, which will kick off the token''s creation
    and auth attempt. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: bash exploit.sh users.txt
  prefs: []
  type: TYPE_NORMAL
- en: 'This will allow us to pass **users.txt** to the **while** loop and have an
    **internal field separator** (**IFS**) iterate through the individual users. Inside
    **users.txt**, we have three usernames – **"plc"**, **"scada"**, and **"test"**
    – to make things simple. I have also taken the liberty of baking in reading a
    password file and creating some verbosity. Have a look at the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.58 – Brute-forcing the username and password'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.58_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.58 – Brute-forcing the username and password
  prefs: []
  type: TYPE_NORMAL
- en: 'The command you should run now is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: bash exploit.sh users.txt passwords.txt -v
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside **passwords.txt**, for simplicity''s sake, I only added four passwords,
    and they were **"admin"**, **"password"**, **"scada"**, and **"changeme"**. Running
    the preceding command should generate the following output, whereby we get a successful
    authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.59 – Successful authentication'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.59_B16321.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.59 – Successful authentication
  prefs: []
  type: TYPE_NORMAL
- en: Here, you have a fully baked brute-forcing script. We created **oidc** tokens
    and used them to autogenerate CSRF tokens, as well as to test usernames and passwords
    against the Ignition SCADA system with our newly minted script.
  prefs: []
  type: TYPE_NORMAL
- en: Disclaimer
  prefs: []
  type: TYPE_NORMAL
- en: Before sounding alarm bells and submitting vulns to your local **Computer Emergency
    Response Team** (**CERT**), Inductive Automation has implemented server-side mitigations
    for brute-forcing attempts. If you try your known username with five incorrect
    passwords, Ignition will lock out that account for 5 minutes from the time you
    made your last attempt.
  prefs: []
  type: TYPE_NORMAL
- en: So, unless you have a well-curated list of users and a laser-focused password
    list, you will have to adjust your script to accommodate the fact that you will
    lock out any real accounts for every five failed attempts for 5 minutes. Not to
    mention that this type of brute-forcing at this level is bound to be picked up
    by an IDS if you haven't done your due diligence, which was mentioned in [*Chapter
    6*](B16321_06_Epub_AM.xhtml#_idTextAnchor063), *Packet Deep Dive*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the irony here is that if you were to adjust your script to intentionally
    lock out real users, it would force someone to authenticate to the server to reboot
    Ignition to override these lockouts. This would ultimately cause a **Denial Of
    Service** (**DOS**) against the SCADA server.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through the steps of pulling information out of BurpSuite
    and translating it into a useful brute-forcing tool. We built on skills that we
    covered in earlier chapters and then extended our knowledge by working around
    client-side token generation. This is a very important skill to learn when it
    comes to pentesting, understanding your environment, and extracting as much information
    as possible to open doors that, at a glance, appear to be locked.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I feel that we have covered a lot in this chapter, from installing FoxyProxy
    and using BurpSuite to capture and replay requests, to formulating how Ignition
    SCADA handles authentication and extracting that knowledge and building scriptable
    tools to help automate and generate tokens for brute forcing. You will definitely
    use each and every one of these tools and techniques throughout your career.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be using everything we have learned up to this
    point to perform a pseudo mock pentest against our ICS lab.
  prefs: []
  type: TYPE_NORMAL
