<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-14"><em class="italic"><a id="_idTextAnchor013"/>Chapter <a id="_idTextAnchor014"/>1</em>: Using Virtualization</h1>
			<p>This first chapter touches on the relevance of <strong class="bold">virtualization</strong> and the importance of familiarizing yourself with the different flavors, including VirtualBox, Hyper-V, KVM, VMware, and more. However, in this book, we are going to focus on VMware, and specifically ESXi Hypervisor, as it is free and a scaled version of what you will see out in the real world when it comes to production. We are going to spin up Hypervisor in efforts to create our own lab, install a handful of <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>), and attempt to mimic a virtual <strong class="bold">Supervisory Control and Data Acquisition</strong> (<strong class="bold">SCADA</strong>) environment.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding what virtualization is</li>
				<li>Discovering what VMware is</li>
				<li>Turning it all on</li>
				<li>Routing and rules  </li>
			</ul>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor015"/>Technical requirements </h1>
			<p>For this chapter, you will need the following:</p>
			<ul>
				<li>A computer that supports virtualization and dual interfaces</li>
				<li>VMWare ESXi </li>
				<li>VMWare Fusion</li>
				<li>Ubuntu ISO</li>
				<li>Windows 7 ISO</li>
				<li>Kali Linux ISO</li>
			</ul>
			<p>The following are the links that you can navigate to download the software:</p>
			<ul>
				<li>macOS Fusion: <a href="https://www.vmware.com/products/fusion/fusion-evaluation.html">https://www.vmware.com/products/fusion/fusion-evaluation.html</a></li>
				<li>Windows: <a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html">https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html</a></li>
				<li>ESXi: <a href="https://my.vmware.com/en/web/vmware/evalcenter?p=free-esxi7">https://my.vmware.com/en/web/vmware/evalcenter?p=free-esxi7</a></li>
				<li>Kali Linux: <a href="https://www.kali.org/downloads/">https://www.kali.org/downloads/</a></li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Understanding what virtualization is</h1>
			<p>Virtualization, in layman's terms, is the method of simulating any combination of hardware and software in a purely software medium. This allows anyone to run and test an endless number <a id="_idIndexMarker000"/>of hosts without incurring the financial burden and the costs of hardware requirements. It is especially useful if you have distro commitment issues.</p>
			<p>I cannot emphasize the importance of understanding the inner workings of virtualization enough. This technology has become the foundation on which all development and testing is performed and built. Every engagement that I have been involved in has had large parts of their infrastructure running on some sort of virtualization platform. Having concrete knowledge of how virtualization works is pivotal for any engagement, and you can perform <a id="_idIndexMarker001"/>reconnaissance of your <em class="italic">victim's</em> organization or technology and reproduce it inside your <strong class="bold">virtual lab</strong>.  </p>
			<p>Performing some simple <strong class="bold">Open Source Intelligence</strong> (<strong class="bold">OSINT</strong>), you can easily discover what <a id="_idIndexMarker002"/>networking equipment an organization is utilizing, including their firewall technology, endpoint protection, and what <strong class="bold">Operational Technology Intrusion Detection System</strong> (<strong class="bold">OT IDS</strong>) that the company <a id="_idIndexMarker003"/>has installed. With this information, you can navigate to the websites of your newly discovered <a id="_idIndexMarker004"/>intel and download <strong class="bold">VM</strong> instances of the software and spin it up alongside your new, homegrown virtual environment. From here, you can plan out every angle of attack, design multiple scenarios of compromise, establish how and where to pivot into lower segments of the network, build payloads to exploit known vulnerabilities, and ultimately gain the <em class="italic">keys</em> to the kingdom. This technique will be discussed in further chapters, but know that it is key to building out an attack path through an organization's infrastructure.</p>
			<p>One of the most important features of virtualization is the use of snapshots. If, at any point, you "brick" a box, you can roll it back and start afresh, documenting the failed attempt and ultimately avoiding this pitfall on the live engagement. This allows you to try a variety of attacks with little fear of the outcome, as you know you have a stable copy to revert to. There are numerous flavors of virtualization vendors/products that I have come in contact with over the course of my career. These include <em class="italic">VMware</em>, <em class="italic">VirtualBox</em>, <em class="italic">Hyper-V</em>, <em class="italic">Citrix</em>, and <em class="italic">KVM</em>. Each has their own pros and cons. I have defaulted to VMware and will go forward through this book, utilizing the various products by them.  </p>
			<p>In no way shape <a id="_idIndexMarker005"/>or form is this any sales pitch for VMware; just know that VMWare is easier to work with as there is near seamless integration across the ecosystem of products, which, almost irritatingly so, has made it become the medium that organizations are embracing in their environments.  </p>
			<p>Understanding the <a id="_idIndexMarker006"/>important role that virtualization plays in <strong class="bold">pentesting</strong> will help strengthen your budding career. Practicing spinning up a basic VM on each stack will help you understand the nuances of each platform and learn the intricacies of virtual hardware dependencies. As a bonus, by familiarizing yourself with each hypervisor vendor, you will figure out which software you prefer and really dig deep to learn the ins and outs of it. With all this said, I will be using VMware going forward to build the lab. </p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Discovering what VMware is</h1>
			<p>VMware was founded in 1998, launching their first product, <em class="italic">VMware workstation,</em> in 1999. 3 years after <a id="_idIndexMarker007"/>the company was founded, they released <strong class="bold">GSX</strong> and <strong class="bold">ESX</strong> into the server market. <strong class="bold">Elastic Sky X</strong> (<strong class="bold">ESX</strong>) retained the name until 2010. The "i" was added after VMware <a id="_idIndexMarker008"/>invested time and <a id="_idIndexMarker009"/>money into upgrading the OS and modernizing the user interface. The product is now dubbed <strong class="bold">ESX integrated</strong> (<strong class="bold">ESXi</strong>). If you are reading this, I think it is safe for me to assume that you have perused a few books on related topics, since <a id="_idIndexMarker010"/>most books cover <strong class="bold">Desktop Hypervisors</strong> such as <em class="italic">Player</em>, <em class="italic">Workstation</em>, and/or <em class="italic">Fusion</em>. I want to take this a step further and provide some hands-on exposure and practice with ESXi in the next section.  </p>
			<p>OK, maybe that was a slightly sales-y pitch, but I can honestly say that I have never worked for VMware and do not get any royalties for plugging their technology. However, I feel it would do you a disservice to not take you through a hands-on practical experience with technology that you will most certainly discover out there in the field. I have personally <a id="_idIndexMarker011"/>encountered VMware in the verticals of oil and gas, energy, chemical, pharma, consumer product production, discrete manufacturing, and amusement parks, to name a few.</p>
			<p>A typical production solution consists of the following:</p>
			<ul>
				<li><strong class="bold">Distributed Resource Scheduler</strong> (<strong class="bold">DRS</strong>)</li>
				<li><strong class="bold">High Availability</strong> (<strong class="bold">HA</strong>)</li>
				<li>Consolidated Backup</li>
				<li>VCenter</li>
				<li>Virtual machines</li>
				<li>ESXi servers</li>
				<li><strong class="bold">Virtual Machine File System</strong> (<strong class="bold">VMFS</strong>)</li>
				<li><strong class="bold">Virtual symmetric multi-processing</strong> (<strong class="bold">SMP</strong>)</li>
			</ul>
			<p>For a better overview of these specific components, please reference the following web page: <a href="https://www.vmware.com/pdf/vi_architecture_wp.pdf">https://www.vmware.com/pdf/vi_architecture_wp.pdf</a>.</p>
			<p>I do not want to deep dive into VMware; instead, I simply want to make you aware of some of the pieces of technology that will be encountered when you're on an engagement. I do, however, want to call out the core stack, which consists of vCenter, ESXi servers, and VMs. These are the building blocks of almost all virtualization implementations in large organizations. vCenters control ESXi servers, and ESXi servers are where VMs live. Knowing this will help you understand the path of <strong class="bold">Privilege Escalation</strong> once <a id="_idIndexMarker012"/>you get a foothold of a VM inside the operational layer of the company. I have had many of conversations <a id="_idIndexMarker013"/>with security personnel over the years around <strong class="bold">Separation of Duties</strong> (<strong class="bold">SoD</strong>), and teams dedicated to their applications are more <a id="_idIndexMarker014"/>than happy to explain the great pain and lengths they have gone through to adhere to <strong class="bold">Confidentiality</strong>, <strong class="bold">Integrity</strong>, and <strong class="bold">Availability</strong> (<strong class="bold">CIA</strong>). When performing tabletop exercises with these same teams and asking them "<em class="italic">Who controls the ESXi server your app lives on?</em>" and then continuing with, "<em class="italic">What is your total exposure if your vCenter is compromised?</em>" you'll find that the answers, in most cases, will shock you, if not terrify you to the bone. I challenge you to ask your IT/OT team – or whoever is managing your virtual infrastructure – how many VMs are running per server. Then, follow that up with, <em class="italic">"When is the last time you performed a </em><strong class="bold">Disaster Recovery</strong><em class="italic"> (</em><strong class="bold">DR</strong><em class="italic">) failover test</em>?" Knowing if a piece of the critical control is running inside an over-taxed server with minimal <a id="_idIndexMarker015"/>resources is quite useful from a risk mitigation point of view, but for the purpose of this book, we need to exploit a weakness in an overlooked component in the system.</p>
			<p>The following <a id="_idIndexMarker016"/>diagram shows the relationship between the different components we mentioned previously and how they integrate with each other:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/Figure_1.01_B16321.jpg" alt="Figure 1.1 – VMware infrastructure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – VMware infrastructure</p>
			<p>I performed <a id="_idIndexMarker017"/>some work for a <strong class="bold">Steam Assisted Gravity Drainage</strong> (<strong class="bold">SAGD</strong>) heavy oil company, and part of their claim was the virtualization of the <em class="italic">Rockwell PlantPAX DCS</em>. This was all on top of an <em class="italic">ESXi cluster</em> inside a robust <em class="italic">vSphere</em> platform. The biggest takeaway from understanding VMware is that, at an enterprise level, vSphere is the <strong class="bold">platform</strong>, and ESXi is the <strong class="bold">hypervisor</strong>. In this book, I will be posting screenshots of <strong class="bold">VMware Fusion</strong>, which is the macOS-specific desktop platform and that of ESXi. If you are using Windows, you have two options – <strong class="bold">VMPlayer</strong> or <strong class="bold">VMWorkstation</strong>. I will focus most of my time and demos <a id="_idIndexMarker018"/>on ESXi as I feel that understanding this technology is the most important <a id="_idIndexMarker019"/>task for proceeding down the yellow brick road of <em class="italic">industrial pentesting</em>.</p>
			<p>In this section, we touched on what VMware is, called out the core components that make up a virtual stack, and shared some real-world examples of what you will find out there in the wild. Now, the next step is diving right into it and <em class="italic">turning it all on</em>. We will start by walking through the installation processes for VMware Fusion, VMware ESXi, and VMs in order to create a virtual <strong class="bold">Supervisory Control and Data Acquisition</strong> (<strong class="bold">SCADA</strong>) environment for our testing in further chapters.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Turning it all on</h1>
			<p>Now that we've touched on what virtualization is, the next step is to build the backbone of our lab <a id="_idIndexMarker020"/>by installing VMware Fusion, a VMware ESXi server, and four <a id="_idIndexMarker021"/>VMs to simulate a SCADA environment. This is more of a conversation starter or a full disclosure for me to say this, but if the first two sections were a struggle, then it only gets harder from here, and there are many well-written resources out there you can reference or read prior to tackling this subject matter.  </p>
			<p>With that said, let's get started by standing up the virtual portion of our lab. I don't want to pull a "digital chad" and get lost in pontificating about processors, RAM, storage, and shenanigans. However, talking about hardware is inevitable – in other words, the more cores and the more RAM we have, the better it is. I have found it possible to run <strong class="bold">Fusion</strong> on a <em class="italic">Mac</em> with 8 GB of ram, but it was very limiting, and if you open Google Chrome to research anything, then consider your system as hitting a wall and starting to <strong class="bold">page</strong> (see the following note to see what this means).</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When a computer runs out of RAM, the system will move pages of memory out of RAM and into the disk space in an attempt to free up memory for the computer to keep functioning. This <a id="_idIndexMarker022"/>process is called <strong class="bold">paging</strong>. One major culprit of this is Google Chrome.</p>
			<p>With this being a painful personal experience, I would suggest a minimum of 16 GB of RAM with 4 cores. Most systems these days come with this by default. I would be lying if I did not say I was <a id="_idIndexMarker023"/>looking at the new <em class="italic">PowerBook</em>, which can handle 64 GB of RAM with 8 cores. Now, spinning up ESXi requires a bit of a beefier system. I first started my lab with a <em class="italic">Dell PowerEdge R710</em>. I hunted around for legacy (or decommissioned) equipment that I could pick up for a minimal cost and found some great deals. Since then, I have migrated to <em class="italic">Gigabyte Brix</em> and <em class="italic">Intel NUCs</em>, of which the sheer <a id="_idIndexMarker024"/>size devolves from that of a kitchen table to the size of a cell phone and the noise ratio from that of a hair dryer to a pin dropping in a library, are hands down the reasons for making the Brix or NUC a logical choice for running VMware ESXi on. I do have to say that I have been looking at the <em class="italic">SuperMicro IOT</em> server, which allows for <em class="italic">Server Class</em> memory but maintains the small form factor and noise ratio of the Gigabyte Brix and NUC. Going forward with the ESXi setup, I will be using a reclaimed crypto mining rig to build my server on, as I have a few kicking around that allow me to add more memory to the system.</p>
			<p>The quick specifications are as follows:</p>
			<ul>
				<li>AMD Ryzen 7 3800X</li>
				<li>128 GB RAM</li>
				<li>2 TB or disk</li>
			</ul>
			<p>These are not by any means the requirements that you must adhere to. They're simply what I have pieced together from leftover parts. I personally recommend any of the Intel NUC products that carry 16 GB or more of RAM, and a minimum of two network interfaces.</p>
			<p>Here is a link that you can go to in order to browse their product line: <a href="https://simplynuc.com/9i9vx/">https://simplynuc.com/9i9vx/</a>.</p>
			<p>In this section, we will be covering the following subtopics: </p>
			<ul>
				<li>How to install Fusion</li>
				<li>How to install Hypervisor</li>
				<li>Spinning <a id="_idIndexMarker025"/>up Ubuntu as a pseudo-<strong class="bold">Programmable Logic Controller</strong> (<strong class="bold">PLC</strong>)</li>
				<li>Spinning up Ubuntu as a pseudo-SCADA</li>
				<li>Spinning up Windows Engineering Workstation</li>
				<li>Spinning up Kali Linux</li>
				<li>Setting up network segmentation to mimic a model similar to Purdue</li>
			</ul>
			<p>Let's get started!</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>How to install Fusion</h2>
			<p>The first <a id="_idIndexMarker026"/>step to installing Fusion will be to download Fusion from the following link: </p>
			<p><a href="https://www.vmware.com/products/fusion/fusion-evaluation.html">https://www.vmware.com/products/fusion/fusion-evaluation.html</a></p>
			<p>The process <a id="_idIndexMarker027"/>should be straightforward because you have the option of using either <strong class="bold">Fusion Player</strong> or <strong class="bold">Fusion Pro</strong>. I personally use Fusion Pro as out of all <a id="_idIndexMarker028"/>the tools that I utilize, it has proven to be the most effective one.  </p>
			<p>Once you have installed Fusion, we will move on to installing ESXi Hypervisor. We will discuss setting up the networking side of the lab a little later in this chapter. For now, continue by downloading Hypervisor.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/>How to install ESXi</h2>
			<p>The first <a id="_idIndexMarker029"/>step to installing ESXi will be to download ESXi from the following link: <a href="https://my.vmware.com/en/web/vmware/evalcenter?p=free-esxi7">https://my.vmware.com/en/web/vmware/evalcenter?p=free-esxi7</a>.</p>
			<p>Note that I will be using <em class="italic">Version 6.7</em> as I ran into hardware compatibility issues with what I pieced together for my lab.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/>How to install Hypervisor </h2>
			<p>You will <a id="_idIndexMarker030"/>need to perform the following steps:</p>
			<ol>
				<li>Unlike Workstation or Fusion, you are required to create a <em class="italic">VMware account</em>. Once you have created your account and verified you are who you say you are, you can continue with the download. You will arrive at the following page. You will be presented with four options: one for <strong class="bold">ISO</strong>, a second ISO package with VMware Tools included, a local package in <strong class="bold">ZIP</strong> form, and a <strong class="bold">README</strong> file:<div id="_idContainer007" class="IMG---Figure"><img src="image/Figure_1.02_B16321.jpg" alt="Figure 1.2 – Hypervisor download list&#13;&#10;"/></div><p class="figure-caption">Figure 1.2 – Hypervisor download list</p><p>Downloading the ISO allows you to burn it onto a USB key and then use that USB key to boot from and perform a <em class="italic">bare-metal install</em> on your system. The real difference between the two formats is that the ZIP format allows the user to fine-tune and add third-party drivers to publish and build custom ISOs. </p><p class="callout-heading">Important note</p><p class="callout">A bare-metal install refers to a machine devoid of any operating system, and this is the first time an operating system will be installed on the hard drive inside the machine.</p><p>This is important if you are looking to <strong class="bold">bare metal</strong> a consumer-based PC, as not all network drivers are covered in the standard packaged ISO and need to be added to a base package prior to publishing. We will not cover this in this book.</p></li>
				<li>Once you've <a id="_idIndexMarker031"/>selected the ISO file, you will be directed to a link that provides you with a list of hashes. This is good security hygiene as it provides users with a list of hashes to verify the validity of the downloaded package:<div id="_idContainer008" class="IMG---Figure"><img src="image/Figure_1.03_B16321.jpg" alt="Figure 1.3 – File integrity check&#13;&#10;"/></div><p class="figure-caption">Figure 1.3 – File integrity check</p><p>We wouldn't be good security practitioners if we didn't confirm the file's integrity by running a <strong class="bold">hash check</strong>. This is very important to ensure that the file hasn't been tampered with mid-stream. Now, some of you who have been following the news would say that <em class="italic">supply chain</em> attacks circumvent this type of verification. An example of a supply chain attack is <em class="italic">SolarWinds Orion</em>, where it was suspected that an APT group, dubbed <em class="italic">Cozy Bear</em>, updated Orion's code repository and made a hash check useless as a developer published code. This generated a hash that encapsulated malware and clean code, before validating that it was the source of truth. Regardless, it is still a good practice to always check the file hash, thus preventing <strong class="bold">Script Kiddies</strong> from getting a foothold inside your lab.</p><p class="callout-heading">Important note</p><p class="callout">Typically, Script Kiddies are inexperienced hackers that have downloaded a piece of software where they don't completely understand the outcome of what they are about to run, but simply run it anyway as they don't really care what the results or impact of their attacks are, as long as it does something.</p></li>
				<li>Proceed by <a id="_idIndexMarker032"/>running your hash check on your newly downloaded ISO file. As shown in the following screenshot, I performed a <strong class="source-inline">SHA-1</strong> check and compared it to the <strong class="source-inline">SHA1SUM</strong> check that VMware supplies:<div id="_idContainer009" class="IMG---Figure"><img src="image/Figure_1.04_B16321.jpg" alt="Figure 1.4 – SHA-1 checksum&#13;&#10;"/></div><p class="figure-caption">Figure 1.4 – SHA-1 checksum</p></li>
				<li>Now that we have confirmed that the hashes match, we will want to burn this to a <em class="italic">USB key</em> so that we can boot from the USB key and install ESXi on our server. I have come to rely heavily on <strong class="bold">balenaEtcher</strong> for creating bootable USB keys. Once you have manually built hundreds, if not thousands, of USB keys, the simplicity that comes with <strong class="bold">Etcher</strong> is a godsend. </li>
				<li>Navigate to <em class="italic">balenaEtcher's</em> website and download the software by following the link here: <a href="https://www.balena.io/etcher/">https://www.balena.io/etcher/</a>.</li>
				<li>Download <em class="italic">balenaEtcher</em> and launch the tool. You will encounter the following screen. You need to click on <strong class="bold">Select image</strong> and choose the hypervisor image:<div id="_idContainer010" class="IMG---Figure"><img src="image/Figure_1.05_B16321.jpg" alt="Figure 1.5 – Selecting an image to burn&#13;&#10;"/></div><p class="figure-caption">Figure 1.5 – Selecting an image to burn</p><p>The following <a id="_idIndexMarker033"/>warning will be raised because <em class="italic">balena</em> searches the ISO for a <em class="italic">GPT</em> or <em class="italic">MBR</em> <strong class="bold">partition table</strong> and warns the user if it cannot find one. You can proceed by flashing your USB key, as there shouldn't be any issues booting from the key:</p><div id="_idContainer011" class="IMG---Figure"><img src="image/Figure_1.06_B16321.jpg" alt="Figure 1.6 – Missing partition table warning&#13;&#10;"/></div><p class="figure-caption">Figure 1.6 – Missing partition table warning</p></li>
				<li>Once you've clicked on <strong class="bold">Continue</strong>, the tool will take you to the following screen, and it will take only a few minutes to complete. Take a break and go top up your coffee or preferred vice, and by the time you return, it will be completed. Once it has finished, remove the USB key and insert it into the machine that you will bare-metal build on top of:<div id="_idContainer012" class="IMG---Figure"><img src="image/Figure_1.07_B16321.jpg" alt="Figure 1.7 – Flashing USB key&#13;&#10;"/></div><p class="figure-caption">Figure 1.7 – Flashing USB key</p><p>In the past, I have built out various hypervisor servers on the <em class="italic">Intel NUC</em>, <em class="italic">Gigabyte Brix</em>, <em class="italic">Supermicro IoT</em>, and <em class="italic">Dell PowerEdge</em> servers. For demonstration purposes, I have decided to repurpose some old equipment that was used <a id="_idIndexMarker034"/>for crypto mining, but that is a whole other topic, possibly for another book. Depending on your budget for a lab, I have had great success finding some good equipment on <em class="italic">eBay</em>. I just did a quick search and found some great 1U servers for around $150.00 USD.  </p></li>
				<li>Going forward, I am assuming that you have suitable gear that can boot off the USB key and bare-metal install hypervisor. Once you've powered on the system, your system will boot off your newly minted USB key. You must then set up your <strong class="bold">User name</strong> and <strong class="bold">Password</strong>, as shown in the following screenshot, and then set the IP address to either dynamic via DHCP or set a static address. Once you have set your management IP address, you can open a web browser and navigate to the GUI:<div id="_idContainer013" class="IMG---Figure"><img src="image/Figure_1.08_B16321.jpg" alt="Figure 1.8 – VMware ESXi login&#13;&#10;"/></div><p class="figure-caption">Figure 1.8 – VMware ESXi login</p></li>
				<li>Log in with <a id="_idIndexMarker035"/>the <strong class="bold">User name</strong> and <strong class="bold">Password</strong> details that you configured during installation. Once authenticated, you will be presented with the host management page for <strong class="bold">ESXi</strong>, as shown in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_1.09_B16321.jpg" alt="Figure 1.9 – VMware ESXi dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – VMware ESXi dashboard</p>
			<p>If you have <a id="_idIndexMarker036"/>arrived here with minimal effort, then you are in good shape. With that, we have successfully installed VMware Fusion and VMware ESXi on hardware <a id="_idIndexMarker037"/>in our lab. We are now one step closer to having a fully working <strong class="bold">Industrial Control System</strong> (<strong class="bold">ICS</strong>) lab. We will be installing the VMs on top of our new server in the next section.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/>Spinning up Ubuntu as a pseudo-PLC/SCADA</h2>
			<p>We are going <a id="_idIndexMarker038"/>to simulate a virtual <strong class="bold">Programmable Logic Controller</strong> (<strong class="bold">PLC</strong>) and <strong class="bold">SCADA</strong> combination to build a <em class="italic">test bench</em> that will help shape our approach as we progress through this book. A PLC is typically <a id="_idIndexMarker039"/>a small, ruggedized computer used to control industrial processes. These processes can range from people movers <a id="_idIndexMarker040"/>at an airport to devices controlling <em class="italic">SpaceX's Falcon 9</em>; from very simple discrete on-and-off tasks to very complex <a id="_idIndexMarker041"/>cascading control tasks. We can find automation systems in oil and gas, energy generation, transmission and distribution so that we can charge our iPhones and Android devices, food and beverage production such as Coca Cola, chemical mixing and bottling, pharmaceutical manufacturing such as Pfizer vaccine generation, transportation with avionics for controlling airplane flight systems, hospitals for monitoring patients, and many more industries. PLCs are everywhere, and these devices control everything around us that we take for granted as we go about our daily lives. SCADA is an overarching system that's used to control a larger set of defined processes. Taking the first case example of people movers, you can have a single PLC controlling <a id="_idIndexMarker042"/>the local physical on-and-off behavior and the speed of a people mover. This data is then published and controlled by a SCADA system, which allows an operator to have remote control <a id="_idIndexMarker043"/>of how this process operates. This combination of PLC and SCADA would be overkill for a single process, so where SCADA really <a id="_idIndexMarker044"/>shines is when you want to control all the people movers in an airport, mall, or even the strip in Vegas. The SCADA system can start and stop individual processes or all processes all at once. It's powerful in the sense that protecting this system should be of utmost importance when you're designing a security posture.  </p>
			<p>Now that this brief introduction is out of the way, I have chosen to use <strong class="bold">Ubuntu</strong> as my <em class="italic">Linux distro</em>. It is developed by <em class="italic">Canonical</em> and it is a well-maintained distro. Getting familiar with it will help you move forward as Canonical has built <strong class="bold">UbuntuCore</strong>, which is <a id="_idIndexMarker045"/>an operating system powering the <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) ecosystem. The <a id="_idIndexMarker046"/>reason why I am mentioning this is because the <strong class="bold">Operational Technology</strong> (<strong class="bold">OT</strong>) industry is slowly moving toward <a id="_idIndexMarker047"/>adopting IoT technology to replace legacy equipment. There are many examples of big vendors innovating in this space to round out their portfolio of product offerings. OK, that's enough small talk about the future; let's get to the downloading stage: </p>
			<ol>
				<li value="1">First, navigate to the following link to start your download: <a href="https://ubuntu.com/download/desktop">https://ubuntu.com/download/desktop</a>.<p>This will take you to a web page that looks like this:</p><div id="_idContainer015" class="IMG---Figure"><img src="image/Figure_1.10_B16321.jpg" alt="Figure 1.10 – Ubuntu software download&#13;&#10;"/></div><p class="figure-caption">Figure 1.10 – Ubuntu software download</p></li>
				<li>Click the <strong class="bold">Download</strong> button, and then sit back and wait for it to complete. Depending on your connection, it could take a bit of time to download.<p>Once it <a id="_idIndexMarker048"/>has completed, we can proceed to installing the <em class="italic">OS</em>. There are multiple ways of doing this. One method is <a id="_idIndexMarker049"/>to install on Fusion, then connect to the server and upload the VM from Fusion to ESXi. Another option is to transfer the ISO to ESXi's datastore and, from there, configure a new VM with the Ubuntu ISO mounted on the virtual DVD drive. We are going to use the datastore method as we want to keep as little local as possible as we don't want to consume our local machines resources by hosting multiple VMs. We are going to log into the GUI and, when presented with the host management screen, click on the <strong class="bold">Datastores</strong> option under <strong class="bold">Storage</strong>, as shown in the following screenshot:</p><div id="_idContainer016" class="IMG---Figure"><img src="image/Figure_1.11_B16321.jpg" alt="Figure 1.11 – Storage datastore&#13;&#10;"/></div><p class="figure-caption">Figure 1.11 – Storage datastore</p><p>Depending on your setup, you may have a <em class="italic">single disk</em> or <em class="italic">multiple disks</em>. The configuration for this is outside the scope of this book, but ultimately, it is up to your own personal preference.</p></li>
				<li>Next, we <a id="_idIndexMarker050"/>are going to click on the <strong class="bold">Datastore browser</strong> button. A <a id="_idIndexMarker051"/>modal will pop up on the screen, as shown here:<div id="_idContainer017" class="IMG---Figure"><img src="image/Figure_1.12_B16321.jpg" alt="Figure 1.12 – Upload browser&#13;&#10;"/></div><p class="figure-caption">Figure 1.12 – Upload browser</p></li>
				<li>From here, you want to select the datastore that you will upload the ISO file to.  Then, what I like to do is create a <strong class="bold">directory</strong> where I will house all my ISOs for quick recall later. You can see an example of creating a directory<strong class="bold"> </strong>called <strong class="source-inline">iso_folder</strong> in the following screenshot: <div id="_idContainer018" class="IMG---Figure"><img src="image/Figure_1.13_B16321.jpg" alt="Figure 1.13 – Creating a new directory&#13;&#10;"/></div><p class="figure-caption">Figure 1.13 – Creating a new directory</p></li>
				<li>Now, you <a id="_idIndexMarker052"/>need to select the newly <a id="_idIndexMarker053"/>created directory and click the <strong class="bold">Upload</strong> button. This will open a <em class="italic">Finder/Explorer</em> window, where you will be able to select your newly downloaded <strong class="source-inline">ISO</strong> file. Once selected, you will see a progress bar that indicates the file's completion, as shown in the following screenshot: <div id="_idContainer019" class="IMG---Figure"><img src="image/Figure_1.14_B16321.jpg" alt="Figure 1.14 – Upload in progress&#13;&#10;"/></div><p class="figure-caption">Figure 1.14 – Upload in progress</p><p>Once the file has been uploaded, you will see your newly uploaded VM in <strong class="source-inline">iso_folder</strong>: </p><div id="_idContainer020" class="IMG---Figure"><img src="image/Figure_1.15_B16321.jpg" alt="Figure 1.15 – Uploaded ISO&#13;&#10;"/></div><p class="figure-caption">Figure 1.15 – Uploaded ISO</p></li>
				<li>The next step will be to select <strong class="bold">Virtual Machines</strong> from the <strong class="bold">Navigator</strong> menu on the left-hand <a id="_idIndexMarker054"/>side of the screen. Click the <strong class="bold">Create / Register VM</strong> button on the right-hand side of the screen, as <a id="_idIndexMarker055"/>shown in the following screenshot: <div id="_idContainer021" class="IMG---Figure"><img src="image/Figure_1.16_B16321.jpg" alt="Figure 1.16 – Virtual Machines dashboard&#13;&#10;"/></div><p class="figure-caption">Figure 1.16 – Virtual Machines dashboard</p></li>
				<li>Once clicked, this will bring up a modal with three distinct options:<p>a. <strong class="bold">Create a new virtual machine</strong></p><p>b. <strong class="bold">Deploy a virtual machine from an OVF or OVA file</strong></p><p>c. <strong class="bold">Register an existing virtual machine</strong></p><p>You can see this in the following screenshot: </p><div id="_idContainer022" class="IMG---Figure"><img src="image/Figure_1.17_B16321.jpg" alt="Figure 1.17 – Creating a virtual machine&#13;&#10;"/></div><p class="figure-caption">Figure 1.17 – Creating a virtual machine</p><p>We are <a id="_idIndexMarker056"/>going to choose the <strong class="bold">Create a new virtual machine</strong> option here. This will create another pop-up window. From <a id="_idIndexMarker057"/>here, we want to fill out the <strong class="bold">Name</strong>, <strong class="bold">Compatibility</strong>, <strong class="bold">Guest OS family</strong>, and <strong class="bold">Guest OS version</strong> options. <strong class="bold">Compatibility</strong> is an option that allows the VM to have access to version-specific virtual hardware. We can see what this looks like in the following screenshot: </p><div id="_idContainer023" class="IMG---Figure"><img src="image/Figure_1.18_B16321.jpg" alt="Figure 1.18 – Compatibility selection&#13;&#10;"/></div><p class="figure-caption">Figure 1.18 – Compatibility selection</p></li>
				<li>Click <strong class="bold">Next</strong>. You will <a id="_idIndexMarker058"/>be brought <a id="_idIndexMarker059"/>to a new screen where you can select which datastore you would like to spin your new <em class="italic">PLC VM</em> up on. I have selected <strong class="bold">VM-Storage</strong> and clicked <strong class="bold">Next</strong>:<div id="_idContainer024" class="IMG---Figure"><img src="image/Figure_1.19_B16321.jpg" alt="Figure 1.19 – Select storage page&#13;&#10;"/></div><p class="figure-caption">Figure 1.19 – Select storage page</p><p>The next <a id="_idIndexMarker060"/>screen allows you to customize <a id="_idIndexMarker061"/>the VM that we are loading up. Since this VM is going to simulate a PLC, we want to keep the resources like that of a real off-the-shelf device's. The keynote will be the <strong class="source-inline">Datastore ISO</strong> file that we loaded into <strong class="bold">CD/DVD Drive 1</strong>.</p><p>As shown in the following screenshot, the specifications I've chosen are <strong class="source-inline">1</strong> for <strong class="bold">CPU</strong>, 1 GB RAM, <strong class="source-inline">40</strong> GB disk space, <strong class="source-inline">VM network</strong>, and <strong class="source-inline">Datastore ISO</strong> (Ubuntu ISO):</p><div id="_idContainer025" class="IMG---Figure"><img src="image/Figure_1.20_B16321.jpg" alt="Figure 1.20 – Customize settings page&#13;&#10;"/></div><p class="figure-caption">Figure 1.20 – Customize settings page</p><p>We will configure <a id="_idIndexMarker062"/>the network so that it follows a <strong class="bold">quasi-Purdue</strong> model in the next section. The Purdue model is a theoretical framework <a id="_idIndexMarker063"/>for segmenting industrial networks. Many books <a id="_idIndexMarker064"/>have been published documenting <a id="_idIndexMarker065"/>the usefulness of modeling a network after the Purdue model, so I strongly recommend grabbing one and having a read. The Purdue model is one way of applying a standard to segmentation, though there are many other standards that have been created, and many <a id="_idIndexMarker066"/>are industry-specific. In North America for the Utility industry <strong class="bold">North American Reliability Corporation Critical Infrastructure Protection</strong> (<strong class="bold">NERC CIP</strong>), is a set of reliability standards that are used to adhere <a id="_idIndexMarker067"/>to security best practices. <strong class="bold">Chemical Facility Anti-Terrorism Standards</strong> (<strong class="bold">CFATS</strong>) has been developed specifically for the chemical industry, but there is a lot of overlap between these standards. The <strong class="bold">International Organization for Standardization</strong> (<strong class="bold">ISO/IEC</strong>) 27000 series and specifically ISO-27002 have been adopted <a id="_idIndexMarker068"/>outside North America, along with <strong class="bold">International Society of Automation</strong> (<strong class="bold">ISA</strong>) 99 or ISA 62443, which <a id="_idIndexMarker069"/>is where the Purdue model is ultimately derived from.</p></li>
				<li>Now, click <strong class="bold">Finish</strong>. This will place the provisioned VM inside the datastore. We will then <a id="_idIndexMarker070"/>want to run the VM, which <a id="_idIndexMarker071"/>will boot us into the Ubuntu installation process. We can do this by clicking the green power on button shown in the following screenshot:<div id="_idContainer026" class="IMG---Figure"><img src="image/Figure_1.21_B16321.jpg" alt="Figure 1.21 – PLC virtual machine&#13;&#10;"/></div><p class="figure-caption">Figure 1.21 – PLC virtual machine</p></li>
				<li>After clicking the power on button, you will get a page that looks like this: <div id="_idContainer027" class="IMG---Figure"><img src="image/Figure_1.22_B16321.jpg" alt="Figure 1.22 – Powering on the virtual machine&#13;&#10;"/></div><p class="figure-caption">Figure 1.22 – Powering on the virtual machine</p></li>
				<li>Install <strong class="bold">Ubuntu</strong> as <a id="_idIndexMarker072"/>you would normally <a id="_idIndexMarker073"/>install any Linux distro. After installation, you should be sitting at a login screen, as shown in the following screenshot:   </li>
			</ol>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_1.23_B16321.jpg" alt="Figure 1.23 – Login screen for PLC VM&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.23 – Login screen for PLC VM</p>
			<p>We are <a id="_idIndexMarker074"/>going to repeat all the steps we performed <a id="_idIndexMarker075"/>to create the virtual machine named PLC:</p>
			<ol>
				<li value="1">Create a new VM.</li>
				<li>Load the DVD with the Ubuntu ISO located in the datastore.</li>
				<li>Choose 1 CPU, 4 GB of RAM, a 40 GB hard disk, and a VM network for the interface.</li>
				<li>Click the power on button.</li>
				<li>Install as you did previously.</li>
			</ol>
			<p>Now, call the VM SCADA. Now that you have two Ubuntu VMs – one named PLC and another <a id="_idIndexMarker076"/>named SCADA – the next step will be updating the VM and adding key packages that we want to use to simulate a <strong class="bold">virtual PLC</strong>.</p>
			<p>First, log into the <em class="italic">PLC</em> and <em class="italic">SCADA</em> VMs and run the following commands:</p>
			<p class="source-code">sudo apt update</p>
			<p class="source-code">sudo apt upgrade</p>
			<p>This will <a id="_idIndexMarker077"/>make sure that you have the latest versions <a id="_idIndexMarker078"/>of the core packages that make up your Ubuntu machines. Next, we are going to install specific packages so that we can create a <strong class="bold">virtual OT lab</strong>.</p>
			<p>The key <a id="_idIndexMarker079"/>packages to install are as follows: </p>
			<p class="source-code">sudo apt install git</p>
			<p class="source-code">sudo apt install vsftpd</p>
			<p class="source-code">sudo apt install telnetd</p>
			<p class="source-code">sudo apt install openssh-server</p>
			<p class="source-code">sudo apt install php7.4-cli</p>
			<p class="source-code">sudo apt install python3-pip</p>
			<p class="source-code">pip3 install twisted</p>
			<p class="source-code">pip3 install testresources</p>
			<p class="source-code">pip3 install pytest</p>
			<p class="source-code">pip3 install cpppo</p>
			<p class="source-code">pip3 install pymodbus</p>
			<p>The next thing we must do is clone a specific tool.</p>
			<p>Run the following commands:</p>
			<p class="source-code">git clone https://github.com/sourceperl/mbtget.git</p>
			<p class="source-code">cd mbtget</p>
			<p class="source-code">perl Makefile.PL</p>
			<p class="source-code">make</p>
			<p class="source-code">sudo make install</p>
			<p>Almost each package could have independent books written about them, so instead of going into too much detail here, I am going to cover the reasonings behind each package. </p>
			<p>They are as follows: </p>
			<ul>
				<li><strong class="bold">git</strong>: We are going to <a id="_idIndexMarker080"/>use this to clone a simple Modbus client that is written in <em class="italic">Perl</em> called <strong class="source-inline">mbtget</strong>.</li>
				<li><strong class="bold">vsftpd</strong>: This is <a id="_idIndexMarker081"/>a very simple FTP daemon that allows us to simulate config file transfers on the network.</li>
				<li><strong class="bold">telnetd</strong>: This is a <strong class="source-inline">Telnet</strong> daemon <a id="_idIndexMarker082"/>that will also allow us to simulate config file transfers on the network.</li>
				<li><strong class="bold">openssh-server</strong>: This allows <a id="_idIndexMarker083"/>us to run a <strong class="source-inline">ssh</strong> connection to the PLC for command and control.</li>
				<li><strong class="bold">php7.4-cli</strong>: This will <a id="_idIndexMarker084"/>allow us to simulate PLC interfaces later in this book.</li>
				<li><strong class="bold">python3-pip</strong>: This is a <a id="_idIndexMarker085"/>package manager that's specific for Python 3.</li>
			</ul>
			<p>The next packages are Python-specific: </p>
			<ul>
				<li><strong class="bold">twisted</strong>: A networking <a id="_idIndexMarker086"/>engine and a dependency of <em class="italic">pymodbus</em>.</li>
				<li><strong class="bold">testresources</strong>: A unit <a id="_idIndexMarker087"/>testing package and a dependency of <em class="italic">pymodbus</em>.</li>
				<li><strong class="bold">pytest</strong>: A testing <a id="_idIndexMarker088"/>engine and a dependency of <em class="italic">Cpppo</em>.</li>
				<li><strong class="bold">cpppo</strong>: A useful <a id="_idIndexMarker089"/>engine for testing various industrial protocols. We will focus on Ethernet/IP in this book.</li>
				<li><strong class="bold">pymodbus</strong>: This <a id="_idIndexMarker090"/>is a <strong class="source-inline">modbus</strong> engine that can be used as a client/server.</li>
			</ul>
			<p>The next package <a id="_idIndexMarker091"/>is known as <strong class="source-inline">mtbget</strong>, and it is <em class="italic">Perl</em>-specific. It is a <strong class="source-inline">modbus</strong> client, and it is <a id="_idIndexMarker092"/>very useful for testing equipment in the field.</p>
			<p>We now <a id="_idIndexMarker093"/>have two fully updated Ubuntu machines running inside our ESXi server. We have also installed various packages that will allow us to simulate a PLC to SCADA relationship. We can also generate remote connections over various protocols that will come in handy in later chapters. Next, we will build an Engineering Workstation and a Kali Linux attack box. </p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/>Spinning up Windows Engineering Workstation</h2>
			<p>If you were able to get through the installation without any issues, then we are one step closer to <a id="_idIndexMarker094"/>having a well-rounded <em class="italic">virtual lab</em>. Next, we want to get our hands on a <em class="italic">Windows 7</em> image. This is important as much of the software that we require for configuring and communicating with the physical hardware was built for Windows. Well, technically speaking, it was built for Windows XP and then later upgraded to Windows 7. </p>
			<p>Following the steps that we used to build the Ubuntu VMs, we will create our Windows 7 machine:</p>
			<ol>
				<li value="1">Create a new VM.</li>
				<li>Load a DVD with the Windows7 ISO located in the datastore.</li>
				<li>Choose 1 CPU, 4 GB of RAM, a 40 GB hard disk, and a VM network for the interface.</li>
				<li>Click the power on button.</li>
				<li>Install Windows.</li>
			</ol>
			<p>Once you have installed Windows and logged in, you should see a screen similar to the following:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_1.24_B16321.jpg" alt="Figure 1.24 – Windows 7 virtual machine&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.24 – Windows 7 virtual machine</p>
			<p>Now that <a id="_idIndexMarker095"/>we have our Windows 7 VM running, we are going to push forward with the installation of Kali Linux.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/>Spinning up Kali Linux</h2>
			<p><strong class="bold">Kali Linux</strong> is a Linux <a id="_idIndexMarker096"/>distribution specifically designed for <strong class="bold">security research</strong>, <strong class="bold">assessments</strong>, and <strong class="bold">pentesting</strong>, to name a few. The name has changed <a id="_idIndexMarker097"/>since the package <a id="_idIndexMarker098"/>was inspected, but true to form, it still remains <a id="_idIndexMarker099"/>one of the most widely used security tools on the market.</p>
			<p>Follow <a id="_idIndexMarker100"/>this link to download your copy of Kali Linux: <a href="https://www.kali.org/downloads/">https://www.kali.org/downloads/</a>.</p>
			<p>We are going to use <strong class="bold">Kali Linux</strong> to perform tests on the equipment in the lab, both virtual and physical. It is a well-rounded platform and includes <em class="italic">gpg signed packages</em> and has a large development community. There are many other notable <em class="italic">pentesting frameworks</em> out there that specialize in a similar nature, such as <strong class="bold">SamuraiSTFU</strong>, now known as <strong class="source-inline">controlthings.io</strong>. <strong class="bold">ControlThings</strong> provides a wide range of focused tools specific to the ICS/OT environment, along with <strong class="source-inline">pcaps</strong> for the ability of replaying inside your environment for testing purposes. On top of all this, they also provide countless emulators so that you can really hone your assessment skills. <em class="italic">Parrot OS</em> is a security platform that has grown in popularity, due to its user-friendly interface, low memory consumption, and anonymous surfing as a default function. It is a great framework to have in your <em class="italic">pentesting arsenal</em>.</p>
			<p>Kali Linux has a straightforward installation process. </p>
			<p>You need to <a id="_idIndexMarker101"/>follow the same steps you followed for Ubuntu and Windows 7 previously by uploading the Kali ISO to the datastore, and then mounting the ISO on the DVD drive and booting the VM.  </p>
			<p>Next, go through the options for installing based on your region. The great part of a virtual lab is that you can adjust the hardware settings of a machine once it has been stood up. The following screenshot shows the <strong class="bold">Hardware Configuration</strong> settings that I started with: </p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_1.25_B16321.jpg" alt="Figure 1.25 – Kali Linux configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.25 – Kali Linux configuration</p>
			<p>The last step of the installation process is selecting the software to install. Personally, I selected the <strong class="bold">large</strong> version to pre-load more tools. This selection is shown in the following screenshot: </p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_1.26_B16321.jpg" alt="Figure 1.26 – Software selection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.26 – Software selection</p>
			<p>Next, log into <a id="_idIndexMarker102"/>the <strong class="bold">Kali</strong> box with the user that you set up during the initial installation.</p>
			<p class="callout-heading">Tip </p>
			<p class="callout">Some quick history on the <em class="italic">BackTrack/Kali</em> credentials is that <strong class="source-inline">root:toor</strong> have been the default credentials ever since I started on <strong class="bold">BackTrack 4</strong>. Now, they have moved to <strong class="source-inline">kali:kali</strong>. So, if you <a id="_idIndexMarker103"/>happen to be on the <em class="italic">Blue Team</em> side of things, make sure to build out an <strong class="bold">Intrusion Detection Rule</strong> (<strong class="bold">IDR</strong>) for these known credentials. </p>
			<p>You will be presented with a login screen, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_1.27_B16321.jpg" alt="Figure 1.27 – Kali Linux login screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.27 – Kali Linux login screen</p>
			<p>Next, we will <a id="_idIndexMarker104"/>update Kali as we did with Ubuntu, and we will install similar packages to what we installed previously.  </p>
			<p>The key packages are installed using the following commands: </p>
			<ul>
				<li><strong class="source-inline">sudo apt install python3-pip</strong></li>
				<li><strong class="source-inline">pip3 install pymodbus</strong></li>
				<li><strong class="source-inline">pip3 install cpppo</strong></li>
				<li><strong class="source-inline">git clone</strong> (<a href="https://github.com/sourceperl/mbtget.git">https://github.com/sourceperl/mbtget.git</a>)</li>
				<li><strong class="source-inline">cd mbtget</strong></li>
				<li><strong class="source-inline">perl Makefile.PL</strong></li>
				<li><strong class="source-inline">make</strong></li>
				<li><strong class="source-inline">sudo make install</strong></li>
			</ul>
			<p>Now, if no errors occur, you should have four VMs installed on your hypervisor, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/Figure_1.28_B16321.jpg" alt="Figure 1.28 – Virtual machines&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.28 – Virtual machines</p>
			<p>In this section, we installed a Windows 7 Engineering Workstation and a Kali Linux host that will be <a id="_idIndexMarker105"/>simulating our attacker in the lab. We will launch various enumerations, exploits, and attacks from here. In the next section, we are going to move on to designing and implementing the networking segmentation by setting up <em class="italic">levels</em> that relate to a <strong class="bold">Purdue model</strong>.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor025"/>Routing and rules</h1>
			<p>When it comes to setting up our <em class="italic">virtual lab network</em>, we want to try and mimic real-world <strong class="bold">segmentation strategies</strong>. With that being said, it is hard to talk about OT networking <a id="_idIndexMarker106"/>without at least commenting on the <em class="italic">Purdue model</em>. This model has <a id="_idIndexMarker107"/>been used as a reference by almost all industries as a method of building out a baseline for segmenting levels in the network. The levels are as follows: </p>
			<ul>
				<li>Level 5: <strong class="bold">Enterprise</strong></li>
				<li>Level 4: <strong class="bold">Site Business Systems</strong></li>
				<li>Level 3: <strong class="bold">Operations and Control</strong></li>
				<li>Level 2: <strong class="bold">Localized Control</strong></li>
				<li>Level 1: <strong class="bold">Process</strong></li>
				<li>Level 0: <strong class="bold">I/O</strong></li>
			</ul>
			<p>So, true to form, we will take the same approach in our lab. We will start by placing the Virtual PLC into <em class="italic">Level 1</em>, the SCADA VM into <em class="italic">Level 2</em>, the Windows 7 Engineering Workstation into <em class="italic">Level 3</em>, and finally our Kali Linux attack host into <em class="italic">Level 5</em>. We will need to log into ESXi and click on <strong class="bold">Networking</strong>. This will bring up a screen showing multiple tabs related to the networking infrastructure of ESXi, as shown here: </p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_1.29_B16321.jpg" alt="Figure 1.29 – Networking dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.29 – Networking dashboard</p>
			<p>We will create <a id="_idIndexMarker108"/>a new switch on the <strong class="bold">Virtual switches</strong> tab. Start by filling out the <strong class="bold">vSwitch Name</strong> option and change <strong class="bold">Link discovery Mode</strong> to <strong class="bold">Both</strong>, as shown in the following screenshot. This allows details about the physical and virtual switches to be published and available:</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_1.30_B16321.jpg" alt="Figure 1.30 – Configuring the virtual switch&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.30 – Configuring the virtual switch</p>
			<p>We will go <a id="_idIndexMarker109"/>back and change <strong class="bold">Promiscuous mode</strong> in <a href="B16321_05_Epub_AM.xhtml#_idTextAnchor049"><em class="italic">Chapter 5</em></a>, <em class="italic">Span Me If You Can</em>, when we discuss <strong class="bold">Intrusion Detection Systems</strong> (<strong class="bold">IDS</strong>). Once <a id="_idIndexMarker110"/>completed, you should see your new virtual switch.</p>
			<p>Next, we want to move on to the <strong class="bold">Port groups</strong> tab. From here, we want to click <strong class="bold">Add port group,</strong> which will bring up a modal where we can set a <strong class="bold">Name</strong>, <strong class="bold">VLAN</strong>, and associate port group to a <strong class="bold">Virtual switch</strong>. For <strong class="bold">port security</strong>, we are going to default to inheriting the security settings from <strong class="bold">vSwitch1</strong>, which we created in the previous step. All these details can be seen in the following screenshot: </p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_1.31_B16321.jpg" alt="Figure 1.31 – Port group configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.31 – Port group configuration</p>
			<p>Now, we want <a id="_idIndexMarker111"/>to complete the process by adding the remaining networks: </p>
			<ul>
				<li>Enterprise</li>
				<li>Site Business systems</li>
				<li>Operations &amp; Control</li>
				<li>Localized Control</li>
			</ul>
			<p>Once completed, you will see the port groups associated with the dedicated switches. Note that there are many ways to complete segmentation and adhere to the <em class="italic">Purdue model</em>:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_1.32_B16321.jpg" alt="Figure 1.32 – Port Groups dashboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.32 – Port Groups dashboard</p>
			<p>As you can see, we still have all our VMs associated with the VM network. The next step will be to move the VMs into their own individual segments and manually set their IP addresses and ranges. We will start with the PLC VM, so we need to select <strong class="bold">Virtual Machines</strong> from the <a id="_idIndexMarker112"/>navigator bar and then click on <strong class="bold">PLC VM</strong>. Click the <strong class="bold">Edit</strong> button; this will take you to the following page: </p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_1.33_B16321.jpg" alt="Figure 1.33 – Port Groups selection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.33 – Port Groups selection</p>
			<p>We want to switch our <strong class="bold">Network Adapter</strong> from <strong class="bold">VM Network</strong> to <strong class="bold">Level 1: Process</strong> and then click <strong class="bold">Save</strong>. Next, we want to manually set the IP address for the PLC. So, we need to open the console, log into the PLC, and navigate to <strong class="bold">Network settings</strong>.</p>
			<p>You will see the following page: </p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_1.34_B16321.jpg" alt="Figure 1.34 – Network settings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.34 – Network settings</p>
			<p>From here, we can <a id="_idIndexMarker113"/>click the <strong class="bold">Wired Settings</strong> option. Then, a pop-up window will appear. Next, you want to select the <em class="italic">gear</em> icon, which is located next to the purple slider, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_1.35_B16321.jpg" alt="Figure 1.35 – Wired network interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.35 – Wired network interface</p>
			<p>At this point, we should take a moment to discuss our IP address scheme.</p>
			<p>Here, we will break each network segment into a dedicated IP range, as shown in the following table: </p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Table_1_B16321.jpg" alt=""/>
				</div>
			</div>
			<p>Now, we can <a id="_idIndexMarker114"/>pre-assign IP addresses to the VMs that we have built out.</p>
			<p>We will assign the following IP addresses:</p>
			<ul>
				<li><strong class="bold">PLC</strong>: <strong class="source-inline">192.168.1.10</strong></li>
				<li><strong class="bold">SCADA</strong>: <strong class="source-inline">192.168.2.10</strong></li>
				<li><strong class="bold">Workstation</strong>: <strong class="source-inline">192.168.3.10</strong></li>
				<li><strong class="bold">Kali</strong>: <strong class="source-inline">172.16.0.10</strong>  </li>
			</ul>
			<p>We can check our machines to make sure that the IP addresses have taken affect by running the <strong class="source-inline">ip addr</strong> command on the Linux-based distros, similar to what's shown in the following screenshot:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_1.36_B16321.jpg" alt="Figure 1.36 – Checking the network address&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.36 – Checking the network address</p>
			<p>From here, select <strong class="bold">IPv4</strong> and then choose the <strong class="bold">Manual</strong> option. The option to set the Linux-based <a id="_idIndexMarker115"/>distro IP address for all three – PLC, SCADA, and Kali – should appear underneath <strong class="bold">Addresses</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_1.37_B16321.jpg" alt="Figure 1.37 – Ubuntu manual IP configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.37 – Ubuntu manual IP configuration</p>
			<p>Now, we can move on to the <em class="italic">Windows 7</em> configuration and set the IP address manually there as well. The Windows 7 configuration looks like this:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_1.38_B16321.jpg" alt="Figure 1.38 – Windows 7 network configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.38 – Windows 7 network configuration</p>
			<p>Make sure <a id="_idIndexMarker116"/>that PLC, SCADA, and Workstation can all ping each other by running the <strong class="source-inline">ping</strong> command, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_1.39_B16321.jpg" alt="Figure 1.39 – Checking communication between VMs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.39 – Checking communication between VMs</p>
			<p>We have now successfully set up the network segmentation so that it represents that of the Purdue model. The IP addresses have all been statically set, and we've tested the communication <a id="_idIndexMarker117"/>between the levels and the VMs.  </p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor026"/>Summary</h1>
			<p>In this introductory chapter, we have covered quite of bit of detail. We touched on the importance of virtualization and the need to familiarize yourself with the different players offering platforms. We gained massive exposure to VMware by installing our own Fusion desktop and ESXi server. Then, we downloaded and installed four unique VMs and configured the networking scheme so that it aligns with the Purdue model. </p>
			<p>After all that effort, we now have a strong foundation to build a lab on. Going forward, we will be building on this lab by adding software as needed and utilizing the attack VM to run scenarios that we have designed.  </p>
			<p>In the next chapter, we will be building the physical component of our lab by installing the engineering software that will communicate with our hardware PLC. </p>
		</div>
	</body></html>