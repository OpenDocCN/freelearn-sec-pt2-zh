<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Remote OS Detection</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will look at the techniques and methods that can be used to detect remote OSes. The vulnerabilities of operating systems are specific and inevitable. Consequently, it becomes important for network administrators to know about the operating system installed on all running hosts inside the network. For a small network, it might be easy to identify operating systems for all hosts. However, it becomes a  challenging job for large-scale cloud organizations to maintain a database where thousands of hosts are being deleted and created every minute and are therefore constantly changing. </p>
<p>There are many scanning tools available on the market, but Nmap and Wireshark are the most popular and widely used tools. You should also have done some background reading in order to successfully use the Wireshark capture feature. In this chapter, we will use Nmap and Wireshark to run a scan and to capture packets. In the next chapter, we will discuss SSL, fundamental <span>security</span><span> and technical issues, along with the implementation for web-based services.</span></p>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>Reasons for OS detection</li>
<li>Determining the vulnerability of target hosts</li>
<li>Tailoring exploits</li>
<li>OS detection technique with Nmap</li>
<li class="h1">TCP/IP fingerprinting methods supported by Nmap</li>
<li class="h1">Understanding an Nmap fingerprint</li>
<li class="h1">OS matching algorithms</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reasons for OS detection </h1>
                </header>
            
            <article>
                
<p>Before we discuss the reasons for detecting an OS, let's understand what an operating system actually <span>is</span><span>. An operating system is a set of programs compiled to manage multiple hardware resources associated with a computer, and designed to provide a resource platform pool to run other application programs:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1177 image-border" src="Images/74af1728-75c2-4338-ac8c-86bbc7471aad.png" style="width:22.92em;height:16.25em;" width="657" height="467"/></div>
<div class="CDPAlignCenter CDPAlign"/>
<p>The following are the most common operating systems available on the market:</p>
<ul>
<li>Linux</li>
<li>Windows</li>
<li>Red Hat</li>
<li>FreeBSD</li>
<li>Solaris</li>
<li>macOS </li>
</ul>
<p>Let us now discuss why we need to detect an operating system. You can see what operating system is installed on your computer at the following, fun website: <a href="http://whatsmyos.com/">http://whatsmyos.com/</a>. As a system administrator, you will want to keep track of IT resources. In the same way, attackers will want to have access to your inventory. This will help them to find resources and launch attacks against vulnerabilities.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Network operating system inventory – trace your infrastructure </h1>
                </header>
            
            <article>
                
<p>As a system administrator, it is very important to know what is running on your network and there are multiple tools available for creating an inventory. An inventory can help you to determine operating system's end-of-life, licensing cost, budgeting, and patch management. Most importantly, it gives you the visibility and analysis of the OS running on your infrastructure. The only similarity between system administrators and attackers is that they both use a similar set of methods for fixing or exploiting a system. System administrators need to run a scan and fix problems before an attacker exploits any vulnerabilities found.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Determining vulnerability of target hosts</h1>
                </header>
            
            <article>
                
<p>A vulnerability scan (often referred to as a network-based scan) can be done remotely. The method for running a scan directly on a host is named a host-based scan. Only determining the application version does not always help us to find vulnerabilities to crack the system. It is also very important to detect an OS version to combine results. From time to time, operating system updates are released, and they do patching for an application without even changing the application version. Finding a vulnerability with a remote scan is a bit difficult, as results might become false positive. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Tailoring exploits</h1>
                </header>
            
            <article>
                
<p>Buffer overflow is one of the most famous, powerful and frequently used attacks used to exploit applications. Buffer overflow attacks can provide attackers access to execute commands or customize shell codes in a system. Once you have access to a targeted machine, you could add accounts, access a command prompt, remotely control the GUI, and alter the system's configuration.</p>
<p>When I say <em>buffer memory</em>, I am referring to <strong>random-access memory</strong> (<strong>RAM</strong>) used to hold data temporarily before it passes to a desired application. Every application on the system has a fixed size data buffer (memory allocated from a common pool). Attackers use techniques to fill a buffer with data until there is no buffer space left—this is known as <strong>buffer overflow</strong>. It is important to know or detect the actual operating system before you try to execute such scripts to exploit vulnerabilities. Use OS detection first, or you may end up sending Linux shellcode to a FreeBSD server.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">OS detection technique with Nmap</h1>
                </header>
            
            <article>
                
<p>Before we talk about remote operating system detection, let's discuss what Nmap is and what it can do. I will also walk you through different flags and nobs that can be used with the Nmap tool in general.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Nmap tool</h1>
                </header>
            
            <article>
                
<p><strong>Network Mapper</strong> (<strong><span>Nmap</span></strong>) is a freely available open source tool for systems and network administrators, allowing them to perform tasks such as collecting enterprise network inventory, managing service upgrade schedules, basic security audits, and monitoring hosts or service up-time. Nmap is officially available for major computer operating system platforms such as Linux, Windows and macOS X.</p>
<p>Nmap binaries can be downloaded from <a href="https://nmap.org/download.html">https://nmap.org/download.html</a>. After successful installation, you can check the version simply by passing the <kbd>nmap -V</kbd><span> command:</span><span> </span></p>
<ul>
<li><strong>Windows</strong>: Output on Windows shows that the program currently installed is <kbd>Nmap version 7.60</kbd>:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-902 image-border" src="Images/0930ce8b-c18d-4911-897b-b4c87b8f4f08.png" style="width:112.67em;height:21.92em;" width="1352" height="263"/></div>
<ul>
<li><strong>Linux</strong>: <span><span>Output on Linux shows that the program currently installed here is <kbd>Nmap version 6.40</kbd>:</span></span></li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-903 image-border" src="Images/64c732de-8d09-4fd2-ad9a-2a13b2ed7830.png" style="width:82.08em;height:17.58em;" width="985" height="211"/></div>
<p>Nmap can be run using the Linux/Unix shell or Windows Command Prompt interface with root or administrator privileges.</p>
<p>The base syntax of Nmap is as follows:<strong> </strong></p>
<pre><strong># nmap [scan type] [options] [target]</strong></pre>
<p>A very simple scan can be performed just by inputting the target IP address without any other options. The target field can be IPv4 <kbd>address:1.1.1.1</kbd>, IPv6 <kbd>address :2001:db8:0:0:0:5678:d334:8af</kbd>, hostname <kbd>www.xyz.com</kbd>, IP address range <kbd>192.168.0.1</kbd> - <kbd>192.168.0.10</kbd> and <strong><span>Classless Inter Domain Routing</span></strong> (<strong><span>CIDR</span></strong>) block <kbd>10.10.10.0/24</kbd>:</p>
<ul>
<li><strong>Example 1</strong>: Scan with host name <kbd>myapptestsec.azurewebsites.net</kbd>. By default, it will scan for one thousand ports. A total of nine hundred and ninety-eight ports are filtered, and two ports are open, as shown in the screenshot.</li>
</ul>
<p style="padding-left: 60px">Please only mention the host name of the website:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1135 image-border" src="Images/ae98ae44-e9fc-4606-9992-cc4d3b1e77f4.png" style="width:39.92em;height:18.75em;" width="667" height="325"/></div>
<p style="padding-left: 60px">Please refer to the help option for further information:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1138 image-border" src="Images/88d3fc75-b4d3-4585-80c4-efd40fa7dbd3.png" style="width:56.67em;height:11.50em;" width="875" height="178"/></div>
<ul>
<li><strong>Example 2</strong>: Scan host with specified port number. As we have seen, only one thousand ports are scanned by default, but Nmap gives you the flexibility to define port options by inputting  the flag <kbd>-p</kbd> and then options such as port range <kbd>-p &lt;Port 1&gt;-&lt;Port 2&gt;</kbd>, port list <kbd>-p &lt;Port 1&gt;,&lt;Port 2&gt;</kbd>, and more:</li>
</ul>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/1b88dcf1-19d3-4236-8389-e97cf2147f6a.png" style="width:56.08em;height:28.92em;" width="613" height="320"/></div>
<p style="padding-left: 60px"><span>Please refer to <span class="packt_screen">help</span> options for more information:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-586 image-border" src="Images/f9032eea-15b6-4470-b360-794d1ad629ef.png" style="width:43.17em;height:8.75em;" width="816" height="165"/></div>
<ul>
<li><strong>Example 3</strong><span>:<strong> </strong></span>Scan hosts with different scan types. You have options to specify multiple flags to do different types of scan. This includes syn scan <kbd>-sS</kbd>, host discovery without a port scan <kbd>-sN</kbd>, Version scan <kbd>-sV</kbd>, TCP connect scan <kbd>-sT</kbd>, and OS detection <kbd>-O</kbd>:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1140 image-border" src="Images/c4786677-ba08-4fbb-8151-bdf4ea1cb61b.png" style="width:44.83em;height:21.00em;" width="657" height="308"/></div>
<p style="padding-left: 60px"><span>Please refer to <span class="packt_screen">help</span> options for more information:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-588 image-border" src="Images/6c998a25-c8c7-4643-9d02-217bd1368650.png" style="width:43.67em;height:11.33em;" width="803" height="209"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Operating system detection</h1>
                </header>
            
            <article>
                
<p><span>OS detection is valuable information about a targeted host on what OS is currently installed and running. Let's discuss the logic behind discovery and how Nmap guesses the operating system.</span></p>
<p>Nmap decodes attributes and patterns of response of standard probes, and sends it to a remote host to determine the operating system. This process is named TCP/IP fingerprinting. In the following output, you can see a number of services running on targeted host IP <kbd>23.100.21.174</kbd>. Folllowing is my Linux box. For testing purposes, I installed Apache2 web server. In the following screenshot, we can see that the default page appears when the browser is launched:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/ebbb3d78-4a2d-4193-9bac-f99bf550cd19.png" style="width:66.83em;height:10.75em;" width="1078" height="174"/></div>
<p>The best guess by Nmap (aggressive OS guess) is that there is an 86% chance that it is running on the Linux 3.5 or Linux 2.6.32 system, and this is true. If you find that this information is incorrect, the output can be uploaded to the Nmap portal. This will help Nmap developers to improve the next release:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1142 image-border" src="Images/a967e83d-8ae1-41e5-891d-7cc883b954e6.png" style="width:43.08em;height:21.42em;" width="671" height="343"/></div>
<div class="CDPAlignCenter CDPAlign"/>
<p>Using Nmap, let's try to dig more for a service version. This scans for a slightly longer time, completing in 26.4 seconds as opposed to the 14.98 seconds it takes for a normal scan to complete. The output shows you different versions for different services running on this host machine, along with their software version:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1143 image-border" src="Images/a065255d-44a2-4951-9807-e7e746480603.png" style="width:43.67em;height:21.83em;" width="666" height="347"/></div>
<p>TCP/IP fingerprinting requires collecting detailed information about the target's IP stack. Here is the link for Nmap current database signatures <a href="https://svn.nmap.org/nmap/nmap-os-db">https://svn.nmap.org/nmap/nmap-os-db</a>.</p>
<div class="packt_infobox">In the current Nmap database (6.47), there are 4485 fingerprints for 5009 CPE (platform) names, over 800 of which match various versions of MS-Windows, and over 1000 of which match various Linux systems (including appliances).</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">TCP/IP fingerprinting methods supported by Nmap</h1>
                </header>
            
            <article>
                
<p>In the past, the banner grabbing method was used to detect remote operating systems. Telnet Connect used to be sent to a targeted system and the system would display a banner of the operating system running on a host. This was not a very accurate method as the system admin could also disable a banner or change the actual banner in order to misguide attackers.</p>
<p>The new method of remote OS detection is to analyze the packet between the source and destination. This detection technique detects OS platforms and OS versions as well. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">TCP/UDP/IP basic</h1>
                </header>
            
            <article>
                
<p>To use an analogy, if IPs are a building address, service ports are flat numbers. Both TCP and UDP uses incoming and outgoing ports for data communication. Most IP-based services use standard ports (HTTP <kbd>TCP:80</kbd>, SMTP <kbd>TCP:25</kbd>, and DNS <kbd>TCP-UDP:53</kbd>). </p>
<p>TCP stack has six flag message types to complete a three-way handshake:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1178 image-border" src="Images/b2cf378a-f9f5-484e-9c06-4910fabc34f9.png" style="width:29.67em;height:38.75em;" width="1480" height="1936"/></div>
<div class="CDPAlignCenter CDPAlign"/>
<p>Here is a packet capture for one of the websites I opened on the web browser. This shows a three-way handshake with SYN-SYN-ACK. By default, Wireshark will keep track of all TCP sessions and convert all sequence numbers (SEQ numbers) and acknowledge numbers (ACK numbers) into relative numbers. This means that instead of displaying the real/absolute SEQ and ACK numbers in the display, Wireshark will display a SEQ and ACK number relative to the segment <span>first seen</span><span> in that conversation:</span></p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-571 image-border" src="Images/98dc4abb-cfac-4499-8f04-61fe6282d58a.png" style="width:141.33em;height:8.33em;" width="1696" height="100"/></div>
<p>If you are interested in knowing the exact, real number of the TCP sequence, then you have to tune Wireshark settings via the unchecked box relative to the sequence number:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-906 image-border" src="Images/b4e06d00-ac17-4eab-856e-f8fa912658a9.png" style="width:60.92em;height:33.42em;" width="851" height="466"/></div>
<p>In Wireshark, I have extended the first connection to show that the SYN flag is set to <kbd>1</kbd> . Similarly, you can also extend the rest of the connection:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-572 image-border" src="Images/8047735c-7cb3-4bc5-aaff-c795fcbf897d.png" style="width:47.08em;height:24.75em;" width="1011" height="531"/></div>
<ul>
<li><strong>SYN and SYN-ACK</strong>: Any TCP communication will start with a SYN (synchronization) packet by setting the flag to <kbd>1</kbd>. A server responds with SYN-ACK, which means that a service port is listening and in an open state.</li>
<li><strong>ACK</strong>: After receiving SYN-ACK from a server, a client sends the final ACK to complete the three-way handshake by setting the ACK flag to <kbd>1</kbd>.</li>
<li><strong>RST</strong>: The reset flag means that the server is not accepting the connection on the service port where the connection was made, or it is rejecting the request.</li>
<li><strong>FIN</strong>: The finish flag is set to <kbd>1</kbd> when either party wants to finish the connection and this can be achieved by closing the browser.</li>
</ul>
<p>The following techniques are used to determine the OS on the system.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The FIN probe</h1>
                </header>
            
            <article>
                
<p>A FIN packet is used to close the TCP connection between client and server. Closing the connection is more complex than creating a connection because both sides have to release its resources. In the following diagram, you can see that a FIN packet works with the last ACK:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1180 image-border" src="Images/64d23d7f-2dbc-4a6d-96df-02a95e426075.png" style="width:22.50em;height:18.58em;" width="695" height="573"/></div>
<p>Tools like Nmap can generate a FIN packet without having the ACK set to <kbd>1</kbd>. An operating system might respond to this with RST, which gives you a clue about the remote operating system.</p>
<div class="packt_infobox"><span>When designing their TCP/IP implementations, vendors have had different interpretations of RFC 793,</span><span> </span>Transmission Control Protocol<span>. When a TCP segment arrives with the FIN flag set, but not the ACK flag, some implementations send RST segments, whereas others drop the packet without sending an RST.</span></div>
<p>Let's test a live environment with the packet capture. I tested FIN on my wireless router, and here are the results when I followed the TCP stream on Wireshark:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-255 image-border" src="Images/c66e8f2e-3284-44d1-a4bc-28edf82222bd.png" style="width:83.00em;height:33.58em;" width="996" height="403"/></div>
<p>Let's test the result on Wireshark for port <kbd>80</kbd>, which I know is open on this box. You can see that only FIN was sent and no response was received from the router:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-573 image-border" src="Images/7d44f811-024e-4fb2-a16c-a5216d11ee4e.png" style="width:111.08em;height:23.25em;" width="1333" height="279"/></div>
<p>The FIN sent on port <kbd>443</kbd> gets a RST back because this port is not open on this router:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-574 image-border" src="Images/3955ca61-3c76-4b93-85b3-f8d50a6869da.png" style="width:115.92em;height:23.67em;" width="1391" height="284"/></div>
<div class="packt_infobox">FIN scans only work on Linux machines, and do not work on the latest version of Windows. CISCO, HP/UX, MVS, and IRIX send an RST packet in return.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">TCP ISN sampling</h1>
                </header>
            
            <article>
                
<p>In a TCP stack sequence and acknowledgement, fields are 32 bit [4 Byte]. There are <em>2^32= 4,294,967,296</em> possibilities of generating a random number:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1183 image-border" src="Images/2448dab1-7dd5-45c0-8678-00fb0c0d9e1f.png" style="width:163.08em;height:80.75em;" width="1957" height="969"/></div>
<p>Between a client and a server, when a client initiates a connection it generates an <strong>initial sequence number</strong> (<strong>ISN</strong>). Every OS uses its own algorithm to generate an ISN, and this is pretty much predictable.</p>
<div class="packt_infobox">Windows NT 4.0 generates predictable random TCP ISN, which allows remote attackers to perform spoofing and session hijacking.</div>
<p>Random ISNs are good because they make it far harder to predict sequence numbers. In Windows 2003 onward, the ISN algorithm has been modified so that ISNs increase in random increments using an RC4-based random number generator initialized with a 2048-bit random key upon system startup.</p>
<p>RFC 6528 states that Initial Sequence Number Generation Algorithm TCP should generate its ISN using the following expression:</p>
<div class="CDPAlignCenter CDPAlign"><em>ISN = M + F(localip, localport, remoteip, remoteport, secretkey)</em></div>
<p>Here, <em>M</em> is the four microsecond timer, and <em>F()</em> is a <strong>pseudo-random function</strong> (<strong>PRF</strong>) of the connection-id. To summarize, ISN values are completely based on TCP/IP stack implementations and algorithms used by different operating systems, but there is always a common pattern that can help to predict operating systems. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">TCP initial window</h1>
                </header>
            
            <article>
                
<p>This is to check the window size on returned packets, and this value seems to be pretty constant for different types of OS.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type of service</h1>
                </header>
            
            <article>
                
<p>This field is usually set to zero for all OSs. Linux has the precedence bits of the ToS field set to 0xC0. ICMP error messages are always sent with the default ToS value of 0x0000. The ICMP echo reply message should have the same ToS value as the ICMP request message.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time-to-live (TTL)</h1>
                </header>
            
            <article>
                
<p>Based on network traffic between hosts, it is possible to predict what OS is running on a system. Every operating system has its own unique way to implement TCP/IP stack. A very simple but effective passive method is to inspect the initial <strong>time-to-live</strong> (<strong>TTL</strong>) in the IP header:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-575 image-border" src="Images/3d6f8bc2-f387-46ce-af32-72d7ce230085.png" style="width:26.25em;height:12.50em;" width="479" height="227"/></div>
<p>I am on a Windows 10 machine and tried the ICMP ping to host <kbd>4.2.2.2</kbd>. In the Wireshark capture attached below, you can see that the Windows 10 initial TTL value is <kbd>128</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-576 image-border" src="Images/e9232971-03d4-46b4-93aa-986ef08b7c4b.png" style="width:78.42em;height:16.33em;" width="1751" height="365"/></div>
<p>I expended the first packet from Wireshark, which confirms TTL <kbd>128</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-577 image-border" src="Images/18e2d4cb-6a32-4a55-b110-0ed7e0a3588a.png" style="width:124.58em;height:32.92em;" width="1495" height="395"/></div>
<p>Let's try to expend the return packet, allowing us to see that the TTL value is <kbd>59</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-578 image-border" src="Images/fc1e8f30-44a7-4924-bda8-63072b560dcc.png" style="width:111.50em;height:32.92em;" width="1338" height="395"/></div>
<p>You can now take match results with Nmap remote OS detection. There is a 90% chance that this system will be running a Linux operating system. This should match our reference table. The linux TTL value 64 and value 59 means that this host is five hops away from me.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Don't Fragment (DF) bit</h1>
                </header>
            
            <article>
                
<p>Some OSs set this bit, whereas others don't.</p>
<p>There are many more tools and scanning techniques that can be used to detect remote OS. Please read  <a href="https://nmap.org/book/osdetect-methods.html">https://nmap.org/book/osdetect-methods.html</a> for more information.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding an Nmap fingerprint</h1>
                </header>
            
            <article>
                
<p>OS fingerprinting is a technique used to determine the type and version of the operating system running on a remote host. The <kbd>nmap-os-db</kbd> data file contains thousands of signatures. However, different remote operating systems respond to Nmap's specialized OS detection probes. A fingerprint contains an operating system's name, its general classification, and response data pattern.</p>
<p>A typical fingerprint format appears as shown in the following figure. During detection probe, attributes and results are compared against the Nmap <kbd>os-db</kbd> OS database. A simple command can be used for OS detection with the flag <kbd>-O</kbd>:</p>
<pre class="programlisting"><strong>#sudo nmap --O &lt;ip or ip subnet&gt;<br/></strong></pre>
<p><span>The following screenshot is specific to the Cisco 2820 device and shows that a number of tests will be performed before Nmap declares that device as Cisco 2820. This Nmap database will have similar fingerprints for most known devices, and this keeps growing:</span></p>
<div class="CDPAlignCenter CDPAlign"><img style="text-align: center;font-size: 1em;width:39.58em;height:21.75em;" class="alignnone size-full wp-image-580 image-border" src="Images/b7476368-58c5-4a8f-a02e-f511f89868d8.png" width="911" height="498"/></div>
<p>We can see the following terms in the above snapshot:</p>
<ul>
<li><strong>SEQ test</strong>: SEQ test returns information regarding sequence analysis</li>
<li><strong>OPS test</strong>: OPS test returns information regarding TCP options received for each of the 6 [01-06] probes</li>
<li><strong>WIN test</strong>: WIN test returns the TCP initial windows size information for each of the 6 [W1 -W6] probes</li>
<li><strong>ECN test</strong>: ECN test returns explicit congestion notification response</li>
<li><strong>T1 to T7 test</strong>: These are TCP probes:
<ul>
<li>T1 is a SYN packet with a bunch of TCP options for opening the port</li>
<li>T2 is a NULL packet with options to open the port</li>
<li>T3 is a SYN/FIN/URG/PSH packet with options to open the port</li>
<li>T4 is an ACK with options to open the port </li>
<li>T5 is a SYN with options to close the port</li>
<li>T6 is an ACK with options to close the port</li>
<li>T7 is a FIN/PSH/URG with options to close the port</li>
</ul>
</li>
<li><strong>PU</strong> <strong>test</strong>: PU test is a UDP packet used to close a port </li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">OS matching algorithms</h1>
                </header>
            
            <article>
                
<p>Nmap's algorithm for detecting matches is a simple process which collects target fingerprints and tests it against every single reference fingerprint in <kbd>nmap-os-db</kbd>. After testing all the probes against a fingerprint, Nmap divides NumMatchPoints by possible points. The result of this is a confidence factor describing the probability that the subject fingerprint matches that particular reference fingerprint.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defense against port scans</h1>
                </header>
            
            <article>
                
<p>So far, we have learned how to use port scanning techniques to discover and detect information about remote hosts. Let's try to understand that any services/hosts will be vulnerable to port scans, which are exposed to users through some sort of connectivity. This might include an enterprise WAN or the internet. Port scanning is also not classed as illegal activity unless information is used to exploit systems.</p>
<p>The amount of information that should be exposed to the outside world is down to the system administrator. Any IP scanning starts with an ICMP, and you can block all incoming ICMPs on an enterprise edge device. This will make Ping ineffective and will filter ICMP unreachable messages to block Traceroute as part of the first line of defense. But does this solve all of the problem? No, port scan works on TCP/UDP ports as well.</p>
<p>Another way to limit information is to disable all unnecessary services on a system. Of course, you cannot block all services. For example, if you are running HTTPS services on a host, then only port <kbd>443</kbd> [HTTPS] should be exposed to the internet. One more simple method is to restrict services by source IP address. Scans from other IP addresses will then not detect them.</p>
<p>A final clever solution would be to configure policies on firewall/IPS/IDS for threat signature detection. Just like other applications, Nmap itself has its own signature.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed the basics of TCP/IP and how its different attributes can be used for port scanning techniques as well as for remote OS detection. We also discussed how to operate an Nmap tool on different operating systems and how to carry out packet capture analysis using Wireshark. Good hackers know how to crack a system, but a great network administrator knows how to fend off those attacks.</p>
<div class="packt_quote">"The best defense is a good offense"</div>
<p>In the next chapter, we will discuss the fundamentals of SSL, why this is important for web-based applications, and what security considerations are required before we secure applications.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Port scan is a part of:
<ol>
<li>Traceroute</li>
<li>Nmap</li>
<li>Route</li>
<li>Ipconfig/all</li>
</ol>
</li>
</ol>
<ol start="2">
<li class="mce-root">What is the pattern of a TCP connection?
<ol>
<li class="mce-root">SYN-ACK</li>
<li class="mce-root">SYN-ACK-FIN</li>
<li class="mce-root">SYN-RST-ACK</li>
<li class="mce-root">SYN-SYN-ACK</li>
</ol>
</li>
</ol>
<ol start="3">
<li class="mce-root">What is the most important activity in system hacking?
<ol>
<li class="mce-root">Information Gathering</li>
<li class="mce-root">Brute force attack for cracking a password</li>
<li class="mce-root">DDoS attack</li>
<li class="mce-root">Vulnerability exploit</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><a href="https://nmap.org">https://nmap.org</a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>