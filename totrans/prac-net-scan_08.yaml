- en: Remote OS Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at the techniques and methods that can be used
    to detect remote OSes. The vulnerabilities of operating systems are specific and
    inevitable. Consequently, it becomes important for network administrators to know
    about the operating system installed on all running hosts inside the network.
    For a small network, it might be easy to identify operating systems for all hosts.
    However, it becomes a  challenging job for large-scale cloud organizations to
    maintain a database where thousands of hosts are being deleted and created every
    minute and are therefore constantly changing.
  prefs: []
  type: TYPE_NORMAL
- en: There are many scanning tools available on the market, but Nmap and Wireshark
    are the most popular and widely used tools. You should also have done some background
    reading in order to successfully use the Wireshark capture feature. In this chapter,
    we will use Nmap and Wireshark to run a scan and to capture packets. In the next
    chapter, we will discuss SSL, fundamental security and technical issues, along
    with the implementation for web-based services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Reasons for OS detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the vulnerability of target hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tailoring exploits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS detection technique with Nmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP/IP fingerprinting methods supported by Nmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding an Nmap fingerprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS matching algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reasons for OS detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we discuss the reasons for detecting an OS, let''s understand what an
    operating system actually is. An operating system is a set of programs compiled
    to manage multiple hardware resources associated with a computer, and designed
    to provide a resource platform pool to run other application programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/74af1728-75c2-4338-ac8c-86bbc7471aad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the most common operating systems available on the market:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FreeBSD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solaris
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us now discuss why we need to detect an operating system. You can see what
    operating system is installed on your computer at the following, fun website: [http://whatsmyos.com/](http://whatsmyos.com/).
    As a system administrator, you will want to keep track of IT resources. In the
    same way, attackers will want to have access to your inventory. This will help
    them to find resources and launch attacks against vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Network operating system inventory – trace your infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a system administrator, it is very important to know what is running on your
    network and there are multiple tools available for creating an inventory. An inventory
    can help you to determine operating system's end-of-life, licensing cost, budgeting,
    and patch management. Most importantly, it gives you the visibility and analysis
    of the OS running on your infrastructure. The only similarity between system administrators
    and attackers is that they both use a similar set of methods for fixing or exploiting
    a system. System administrators need to run a scan and fix problems before an
    attacker exploits any vulnerabilities found.
  prefs: []
  type: TYPE_NORMAL
- en: Determining vulnerability of target hosts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A vulnerability scan (often referred to as a network-based scan) can be done
    remotely. The method for running a scan directly on a host is named a host-based
    scan. Only determining the application version does not always help us to find
    vulnerabilities to crack the system. It is also very important to detect an OS
    version to combine results. From time to time, operating system updates are released,
    and they do patching for an application without even changing the application
    version. Finding a vulnerability with a remote scan is a bit difficult, as results
    might become false positive.
  prefs: []
  type: TYPE_NORMAL
- en: Tailoring exploits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Buffer overflow is one of the most famous, powerful and frequently used attacks
    used to exploit applications. Buffer overflow attacks can provide attackers access
    to execute commands or customize shell codes in a system. Once you have access
    to a targeted machine, you could add accounts, access a command prompt, remotely
    control the GUI, and alter the system's configuration.
  prefs: []
  type: TYPE_NORMAL
- en: When I say *buffer memory*, I am referring to **random-access memory** (**RAM**)
    used to hold data temporarily before it passes to a desired application. Every
    application on the system has a fixed size data buffer (memory allocated from
    a common pool). Attackers use techniques to fill a buffer with data until there
    is no buffer space left—this is known as **buffer overflow**. It is important
    to know or detect the actual operating system before you try to execute such scripts
    to exploit vulnerabilities. Use OS detection first, or you may end up sending
    Linux shellcode to a FreeBSD server.
  prefs: []
  type: TYPE_NORMAL
- en: OS detection technique with Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we talk about remote operating system detection, let's discuss what Nmap
    is and what it can do. I will also walk you through different flags and nobs that
    can be used with the Nmap tool in general.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Network Mapper** (**Nmap**) is a freely available open source tool for systems
    and network administrators, allowing them to perform tasks such as collecting enterprise
    network inventory, managing service upgrade schedules, basic security audits,
    and monitoring hosts or service up-time. Nmap is officially available for major
    computer operating system platforms such as Linux, Windows and macOS X.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nmap binaries can be downloaded from [https://nmap.org/download.html](https://nmap.org/download.html).
    After successful installation, you can check the version simply by passing the
    `nmap -V` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**: Output on Windows shows that the program currently installed is `Nmap
    version 7.60`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/0930ce8b-c18d-4911-897b-b4c87b8f4f08.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Linux**: Output on Linux shows that the program currently installed here
    is `Nmap version 6.40`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/64c732de-8d09-4fd2-ad9a-2a13b2ed7830.png)'
  prefs: []
  type: TYPE_IMG
- en: Nmap can be run using the Linux/Unix shell or Windows Command Prompt interface
    with root or administrator privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base syntax of Nmap is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A very simple scan can be performed just by inputting the target IP address
    without any other options. The target field can be IPv4 `address:1.1.1.1`, IPv6
    `address :2001:db8:0:0:0:5678:d334:8af`, hostname `www.xyz.com`, IP address range
    `192.168.0.1` - `192.168.0.10` and **Classless Inter Domain Routing** (**CIDR**)
    block `10.10.10.0/24`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1**: Scan with host name `myapptestsec.azurewebsites.net`. By default,
    it will scan for one thousand ports. A total of nine hundred and ninety-eight
    ports are filtered, and two ports are open, as shown in the screenshot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please only mention the host name of the website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ae98ae44-e9fc-4606-9992-cc4d3b1e77f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Please refer to the help option for further information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/88d3fc75-b4d3-4585-80c4-efd40fa7dbd3.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Example 2**: Scan host with specified port number. As we have seen, only
    one thousand ports are scanned by default, but Nmap gives you the flexibility
    to define port options by inputting  the flag `-p` and then options such as port
    range `-p <Port 1>-<Port 2>`, port list `-p <Port 1>,<Port 2>`, and more:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/1b88dcf1-19d3-4236-8389-e97cf2147f6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Please refer to help options for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f9032eea-15b6-4470-b360-794d1ad629ef.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Example 3**:Scan hosts with different scan types. You have options to specify multiple
    flags to do different types of scan. This includes syn scan `-sS`, host discovery
    without a port scan `-sN`, Version scan `-sV`, TCP connect scan `-sT`, and OS
    detection `-O`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/c4786677-ba08-4fbb-8151-bdf4ea1cb61b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Please refer to help options for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6c998a25-c8c7-4643-9d02-217bd1368650.png)'
  prefs: []
  type: TYPE_IMG
- en: Operating system detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OS detection is valuable information about a targeted host on what OS is currently
    installed and running. Let's discuss the logic behind discovery and how Nmap guesses
    the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nmap decodes attributes and patterns of response of standard probes, and sends
    it to a remote host to determine the operating system. This process is named TCP/IP
    fingerprinting. In the following output, you can see a number of services running
    on targeted host IP `23.100.21.174`. Folllowing is my Linux box. For testing purposes,
    I installed Apache2 web server. In the following screenshot, we can see that the
    default page appears when the browser is launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ebbb3d78-4a2d-4193-9bac-f99bf550cd19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The best guess by Nmap (aggressive OS guess) is that there is an 86% chance
    that it is running on the Linux 3.5 or Linux 2.6.32 system, and this is true.
    If you find that this information is incorrect, the output can be uploaded to
    the Nmap portal. This will help Nmap developers to improve the next release:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a967e83d-8ae1-41e5-891d-7cc883b954e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using Nmap, let''s try to dig more for a service version. This scans for a
    slightly longer time, completing in 26.4 seconds as opposed to the 14.98 seconds
    it takes for a normal scan to complete. The output shows you different versions
    for different services running on this host machine, along with their software
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a065255d-44a2-4951-9807-e7e746480603.png)'
  prefs: []
  type: TYPE_IMG
- en: TCP/IP fingerprinting requires collecting detailed information about the target's
    IP stack. Here is the link for Nmap current database signatures [https://svn.nmap.org/nmap/nmap-os-db](https://svn.nmap.org/nmap/nmap-os-db).
  prefs: []
  type: TYPE_NORMAL
- en: In the current Nmap database (6.47), there are 4485 fingerprints for 5009 CPE
    (platform) names, over 800 of which match various versions of MS-Windows, and
    over 1000 of which match various Linux systems (including appliances).
  prefs: []
  type: TYPE_NORMAL
- en: TCP/IP fingerprinting methods supported by Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the past, the banner grabbing method was used to detect remote operating
    systems. Telnet Connect used to be sent to a targeted system and the system would
    display a banner of the operating system running on a host. This was not a very
    accurate method as the system admin could also disable a banner or change the
    actual banner in order to misguide attackers.
  prefs: []
  type: TYPE_NORMAL
- en: The new method of remote OS detection is to analyze the packet between the source
    and destination. This detection technique detects OS platforms and OS versions
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: TCP/UDP/IP basic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use an analogy, if IPs are a building address, service ports are flat numbers.
    Both TCP and UDP uses incoming and outgoing ports for data communication. Most
    IP-based services use standard ports (HTTP `TCP:80`, SMTP `TCP:25`, and DNS `TCP-UDP:53`).
  prefs: []
  type: TYPE_NORMAL
- en: 'TCP stack has six flag message types to complete a three-way handshake:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b2cf378a-f9f5-484e-9c06-4910fabc34f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a packet capture for one of the websites I opened on the web browser.
    This shows a three-way handshake with SYN-SYN-ACK. By default, Wireshark will
    keep track of all TCP sessions and convert all sequence numbers (SEQ numbers)
    and acknowledge numbers (ACK numbers) into relative numbers. This means that instead
    of displaying the real/absolute SEQ and ACK numbers in the display, Wireshark
    will display a SEQ and ACK number relative to the segment first seen in that conversation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/98dc4abb-cfac-4499-8f04-61fe6282d58a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are interested in knowing the exact, real number of the TCP sequence,
    then you have to tune Wireshark settings via the unchecked box relative to the
    sequence number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b4e06d00-ac17-4eab-856e-f8fa912658a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Wireshark, I have extended the first connection to show that the SYN flag
    is set to `1` . Similarly, you can also extend the rest of the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8047735c-7cb3-4bc5-aaff-c795fcbf897d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**SYN and SYN-ACK**: Any TCP communication will start with a SYN (synchronization)
    packet by setting the flag to `1`. A server responds with SYN-ACK, which means
    that a service port is listening and in an open state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ACK**: After receiving SYN-ACK from a server, a client sends the final ACK
    to complete the three-way handshake by setting the ACK flag to `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RST**: The reset flag means that the server is not accepting the connection
    on the service port where the connection was made, or it is rejecting the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FIN**: The finish flag is set to `1` when either party wants to finish the
    connection and this can be achieved by closing the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following techniques are used to determine the OS on the system.
  prefs: []
  type: TYPE_NORMAL
- en: The FIN probe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A FIN packet is used to close the TCP connection between client and server.
    Closing the connection is more complex than creating a connection because both
    sides have to release its resources. In the following diagram, you can see that
    a FIN packet works with the last ACK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/64d23d7f-2dbc-4a6d-96df-02a95e426075.png)'
  prefs: []
  type: TYPE_IMG
- en: Tools like Nmap can generate a FIN packet without having the ACK set to `1`.
    An operating system might respond to this with RST, which gives you a clue about
    the remote operating system.
  prefs: []
  type: TYPE_NORMAL
- en: When designing their TCP/IP implementations, vendors have had different interpretations
    of RFC 793, Transmission Control Protocol. When a TCP segment arrives with the
    FIN flag set, but not the ACK flag, some implementations send RST segments, whereas
    others drop the packet without sending an RST.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test a live environment with the packet capture. I tested FIN on my
    wireless router, and here are the results when I followed the TCP stream on Wireshark:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c66e8f2e-3284-44d1-a4bc-28edf82222bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s test the result on Wireshark for port `80`, which I know is open on
    this box. You can see that only FIN was sent and no response was received from
    the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7d44f811-024e-4fb2-a16c-a5216d11ee4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The FIN sent on port `443` gets a RST back because this port is not open on
    this router:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3955ca61-3c76-4b93-85b3-f8d50a6869da.png)FIN scans only work on
    Linux machines, and do not work on the latest version of Windows. CISCO, HP/UX,
    MVS, and IRIX send an RST packet in return.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP ISN sampling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a TCP stack sequence and acknowledgement, fields are 32 bit [4 Byte]. There
    are *2^32= 4,294,967,296* possibilities of generating a random number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2448dab1-7dd5-45c0-8678-00fb0c0d9e1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Between a client and a server, when a client initiates a connection it generates
    an **initial sequence number** (**ISN**). Every OS uses its own algorithm to generate
    an ISN, and this is pretty much predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Windows NT 4.0 generates predictable random TCP ISN, which allows remote attackers
    to perform spoofing and session hijacking.
  prefs: []
  type: TYPE_NORMAL
- en: Random ISNs are good because they make it far harder to predict sequence numbers.
    In Windows 2003 onward, the ISN algorithm has been modified so that ISNs increase
    in random increments using an RC4-based random number generator initialized with
    a 2048-bit random key upon system startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'RFC 6528 states that Initial Sequence Number Generation Algorithm TCP should
    generate its ISN using the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ISN = M + F(localip, localport, remoteip, remoteport, secretkey)*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *M* is the four microsecond timer, and *F()* is a **pseudo-random function**
    (**PRF**) of the connection-id. To summarize, ISN values are completely based
    on TCP/IP stack implementations and algorithms used by different operating systems,
    but there is always a common pattern that can help to predict operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: TCP initial window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is to check the window size on returned packets, and this value seems to
    be pretty constant for different types of OS.
  prefs: []
  type: TYPE_NORMAL
- en: Type of service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This field is usually set to zero for all OSs. Linux has the precedence bits
    of the ToS field set to 0xC0\. ICMP error messages are always sent with the default
    ToS value of 0x0000\. The ICMP echo reply message should have the same ToS value
    as the ICMP request message.
  prefs: []
  type: TYPE_NORMAL
- en: Time-to-live (TTL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on network traffic between hosts, it is possible to predict what OS is
    running on a system. Every operating system has its own unique way to implement
    TCP/IP stack. A very simple but effective passive method is to inspect the initial
    **time-to-live** (**TTL**) in the IP header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3d6f8bc2-f387-46ce-af32-72d7ce230085.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I am on a Windows 10 machine and tried the ICMP ping to host `4.2.2.2`. In
    the Wireshark capture attached below, you can see that the Windows 10 initial
    TTL value is `128`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e9232971-03d4-46b4-93aa-986ef08b7c4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I expended the first packet from Wireshark, which confirms TTL `128`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/18e2d4cb-6a32-4a55-b110-0ed7e0a3588a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to expend the return packet, allowing us to see that the TTL value
    is `59`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fc1e8f30-44a7-4924-bda8-63072b560dcc.png)'
  prefs: []
  type: TYPE_IMG
- en: You can now take match results with Nmap remote OS detection. There is a 90%
    chance that this system will be running a Linux operating system. This should
    match our reference table. The linux TTL value 64 and value 59 means that this
    host is five hops away from me.
  prefs: []
  type: TYPE_NORMAL
- en: Don't Fragment (DF) bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some OSs set this bit, whereas others don't.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more tools and scanning techniques that can be used to detect
    remote OS. Please read  [https://nmap.org/book/osdetect-methods.html](https://nmap.org/book/osdetect-methods.html) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding an Nmap fingerprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OS fingerprinting is a technique used to determine the type and version of the
    operating system running on a remote host. The `nmap-os-db` data file contains
    thousands of signatures. However, different remote operating systems respond to
    Nmap's specialized OS detection probes. A fingerprint contains an operating system's
    name, its general classification, and response data pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical fingerprint format appears as shown in the following figure. During
    detection probe, attributes and results are compared against the Nmap `os-db`
    OS database. A simple command can be used for OS detection with the flag `-O`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is specific to the Cisco 2820 device and shows that
    a number of tests will be performed before Nmap declares that device as Cisco
    2820\. This Nmap database will have similar fingerprints for most known devices,
    and this keeps growing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b7476368-58c5-4a8f-a02e-f511f89868d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the following terms in the above snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SEQ test**: SEQ test returns information regarding sequence analysis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OPS test**: OPS test returns information regarding TCP options received for
    each of the 6 [01-06] probes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WIN test**: WIN test returns the TCP initial windows size information for
    each of the 6 [W1 -W6] probes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ECN test**: ECN test returns explicit congestion notification response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**T1 to T7 test**: These are TCP probes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: T1 is a SYN packet with a bunch of TCP options for opening the port
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: T2 is a NULL packet with options to open the port
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: T3 is a SYN/FIN/URG/PSH packet with options to open the port
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: T4 is an ACK with options to open the port
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: T5 is a SYN with options to close the port
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: T6 is an ACK with options to close the port
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: T7 is a FIN/PSH/URG with options to close the port
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PU** **test**: PU test is a UDP packet used to close a port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS matching algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nmap's algorithm for detecting matches is a simple process which collects target
    fingerprints and tests it against every single reference fingerprint in `nmap-os-db`.
    After testing all the probes against a fingerprint, Nmap divides NumMatchPoints
    by possible points. The result of this is a confidence factor describing the probability
    that the subject fingerprint matches that particular reference fingerprint.
  prefs: []
  type: TYPE_NORMAL
- en: Defense against port scans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how to use port scanning techniques to discover and
    detect information about remote hosts. Let's try to understand that any services/hosts
    will be vulnerable to port scans, which are exposed to users through some sort
    of connectivity. This might include an enterprise WAN or the internet. Port scanning
    is also not classed as illegal activity unless information is used to exploit
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: The amount of information that should be exposed to the outside world is down
    to the system administrator. Any IP scanning starts with an ICMP, and you can
    block all incoming ICMPs on an enterprise edge device. This will make Ping ineffective
    and will filter ICMP unreachable messages to block Traceroute as part of the first
    line of defense. But does this solve all of the problem? No, port scan works on
    TCP/UDP ports as well.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to limit information is to disable all unnecessary services on a
    system. Of course, you cannot block all services. For example, if you are running
    HTTPS services on a host, then only port `443` [HTTPS] should be exposed to the
    internet. One more simple method is to restrict services by source IP address.
    Scans from other IP addresses will then not detect them.
  prefs: []
  type: TYPE_NORMAL
- en: A final clever solution would be to configure policies on firewall/IPS/IDS for
    threat signature detection. Just like other applications, Nmap itself has its
    own signature.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the basics of TCP/IP and how its different attributes
    can be used for port scanning techniques as well as for remote OS detection. We
    also discussed how to operate an Nmap tool on different operating systems and
    how to carry out packet capture analysis using Wireshark. Good hackers know how
    to crack a system, but a great network administrator knows how to fend off those
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '"The best defense is a good offense"'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the fundamentals of SSL, why this is important
    for web-based applications, and what security considerations are required before
    we secure applications.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Port scan is a part of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traceroute
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Nmap
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Route
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ipconfig/all
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the pattern of a TCP connection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SYN-ACK
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: SYN-ACK-FIN
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: SYN-RST-ACK
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: SYN-SYN-ACK
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the most important activity in system hacking?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Information Gathering
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Brute force attack for cracking a password
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: DDoS attack
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Vulnerability exploit
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://nmap.org](https://nmap.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
