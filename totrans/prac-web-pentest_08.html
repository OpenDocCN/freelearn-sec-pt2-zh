<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Source Code Review</h1>
                </header>
            
            <article>
                
<p class="mce-root">Are you ready for another great chapter? I'm assuming that you like this book so far, and, if that's the case, I'm glad?. This chapter will teach you how to deal with the Source Code Review process. The source code is the heart or engine of the web application, and it must be properly constructed from a security perspective. Your role as an application security expert is to make sure that developers really respect the security patterns. After reading that, you're probably saying <em>But Gus, I'm not good at programming</em>. You will see my response to this later in this chapter, but for the time being, rest assured that I will do my best to help you progress in your career.</p>
<p class="mce-root">Static code analysis is another buzzword for source code review. But wait, I'm not done yet. There is another buzzword, <strong>static application security testing</strong> (<strong>SAST</strong>). This buzzword is used very frequently by application security professionals, especially when we deal with automatic scanners (also known as SAST scanners).</p>
<p class="mce-root">I will be talking about this topic in detail later in this chapter, so keep reading to avoid missing all the fun and educational materials.</p>
<p class="mce-root">At this stage, I'm assuming that you finished your Application Threat Modeling document, and understand how the web application work at a higher level. Make sure that you review the Threat Modeling document to understand the project architecture (entry points, assets, external dependencies, trust levels, and security threats). I talked about threat modeling in the previous chapter for a reason, and that's because I'm trying to show you the flow of logic that you will use in a typical internal project.</p>
<p class="mce-root">Here are the topics that I will be covering in this chapter:</p>
<ul>
<li>How to estimate your programming background</li>
<li>Understanding enterprise secure coding guidelines</li>
<li>Understanding the difference between a manual code review and an automated one</li>
<li>Secure coding checklist</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Programming background</h1>
                </header>
            
            <article>
                
<p>Before we proceed further in this chapter, I have to address the topic of your programming background in detail to help and guide you in the right direction as regards programming languages. I was a programmer for around 10 years before I turned into a full-time cyber-security expert. I can tell you that the experience that I acquired during my programming career greatly helped me in becoming successful in the <span>field of </span><span>application security. After all, how can you give an expert advice if you've never developed a web application in your life?</span></p>
<p class="mce-root">Programming languages are divided into categories, and and they share a lot of similarities (more than you can imagine). Later in this chapter, I will show you the coding security checks (for web applications), but without referring to a specific one, because the checklist can be applied to any web application programming language.</p>
<p class="mce-root">Here's what you need to know about the most popular programming languages, and about the category to which they belong (again, these are the popular ones, not all of them):</p>
<ul>
<li class="mce-root"><strong>Web application development</strong>: Java, C#, .NET, and PHP</li>
<li class="mce-root"><strong>Drivers and hardware</strong>: C, C++, and assembly language</li>
<li class="mce-root"><strong>Reverse engineering</strong>: Assembly language</li>
<li class="mce-root"><strong>Database</strong>: Structured Query LanguageSQL</li>
<li class="mce-root"><strong>Scripting languages</strong>: Python, Perl, and Ruby</li>
</ul>
<p class="mce-root">Do you really need to learn all these languages? Yes, kind of, but let me make your life easier and simplify the task for you. First, start by learning a scripting language. In the upcoming chapters, you will encounter a special chapter that teaches you about Python. This language will help you a lot in automating your penetration testing activities, and at the same time it will help you to learn the basics of programming. Next, you will, need to learn<span> </span><span>at least</span><span> one of three languages: Java, C#, .NET, or PHP. You also have to practice your use of them by developing web applications yourself. While you're learning web application programming, you will also learn SQL because you will interact with the database, so that's two birds with one stone. Assembly language is a special low-level language, but if you learn it, you will gain many more programming skills. As an application security professional, you will almost never have to deal with drivers/hardware or malware reverse engineering, so you can exclude these categories altogether.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Enterprise secure coding guidelines</h1>
                </header>
            
            <article>
                
<p>Every enterprise will need security policies to define the best practices in security for its development teams. One of these policies is secure coding. You will be the custodian of these best practice documents (or checklist) and update them through the evolution of the technology. W<span>henever possible, the </span>secure coding guidelines should be shared with developers in the organization through the intranet website of the company. If this document doesn't exist, it is your job as an application security professional to make a new one and suggest it to management, and believe me, they will appreciate it big time. Some companies encourage the idea of going through secure coding training for developers to engage them in that process. You can refer to the <em>secure coding checklist </em><span>section</span> <span>in this chapter to get ideas on how to develop your own secure coding guidelines for your company (as a consultant or employee).</span></p>
<p class="mce-root">There is an important topic that I mentioned in the previous chapter—SDL. This is a topic that I want you to master and understand how it works in practice, because secure coding is a prerequisite to SDL, and during the development of a normal project, secure coding should be used at every step, as follows:</p>
<ol>
<li class="mce-root"><strong>Architecture phase</strong><span>: At the beginning of the project, the architecture will be defined and the secure coding practices document will be used as a reference for all the technical challenges.</span></li>
<li class="mce-root"><strong>Development phase</strong><span>: During the development phase, continuous integration will be used and executed every time the project is compiled on the build server. The static code analyzer will scan the code automatically after each build, and if the developer hasn't respected the security guidelines, the scanner will most probably flag it as a flaw. We will talk in more detail about the automatic scanners later in this chapter.</span></li>
</ol>
<ol start="3">
<li><strong>Before gating</strong><span>: Before the deployment in the production environment, you will execute different tests (Web Intrusion and manual Source Code Review). At this stage, you can reuse the secure coding guidelines to enforce your arguments against the project team members (web application project) who will surely say that no one told them about this before.</span></li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/be699791-060b-4f1b-9a0f-feb68a4eb003.png" width="1999" height="1154"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Static code analysis – manual scan versus automatic scan</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>In the preceding picture (In the previous section), you can </span><span>clearly</span><span> </span><span>see that the manual code review will be executed when the project is ready for deployment in a typical security development lifecycle. The main idea that I need you to grasp here is that the manual scan happens after an automatic scan, so the manual code review is to spot any missing flaws that the automatic scanner didn't catch. Some people will debate this idea, and you will be surprised at the different opinions you'll get—someone might tell you that a manual scan is enough, and that they don't need a scanner, and that's too much ego because we're human, and we make mistakes no matter how good we are. On the other hand, some people will say that a scanner is enough, but according to their experience, there is always something that we catch after running a scan. Are you lost? Well, the answer is easy—you need to have both.</span></p>
<p class="mce-root"><span>This will p</span><span>robably</span><span> </span><span>sound boring to you, but I'm doing my best to share the important tips that can help you in your career based on events that I witness in my daily job. Now let's talk more deeply about SAST scanners, because you will deal with them in a typical SDL. I'm not here to recommend any products, but I've dealt a lot with Veracode and it's a good product in general. I have a</span><span>lso</span><span> tried Checkmarx and have found it to be pretty good as well.</span></p>
<p class="mce-root"><span>The best way to use a SAST scanner is by implementing the continuous integration methodology. After finishing the architecture phase, programmers will start developing the product and later save it and push it to a build server (when they're done on a daily basis). A scanner such as Veracode will scan the code right away after the build, and will flag any vulnerabilities found in the newly saved code. The application security analyst will take a close look at the results of the scanner and make sure that they collaborate with the development lead, also known as the security champion, for bug fixing. Later, when the project is ready for release, the backlog of the scanner should not contain any high or critical vulnerabilities in order to pass the score before the manual source code review begins.</span></p>
<p class="mce-root"><span>Most of the time, during CI integration, you will be assisting the project team to evaluate false positives. The security champion will submit the demand inside the SAST portal and will be waiting for your approval to flag it as a false positive. Scanners are not perfect and a lot of issues can arise. Your role is to </span><span>always</span><span> </span><span>support the development team and make sure that you send any bugs in the scanner itself to the product supplier.</span></p>
<div class="mce-root packt_tip">If you've been asked by your employer to evaluate a SAST scanner, I encourage you to check the best ones on the Gartner list and do your own tests. Bring multiple applications and scan them. Later, compare the number of false positives to the vulnerabilities found in each scanner; don't just <span>blindly</span><span> assume that </span><span>the Gartner choices are correct without trying them yourself.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Secure coding checklist</h1>
                </header>
            
            <article>
                
<p>I wrote this book so that you can have a bible of application security to use on a daily basis in your career. I want this book to contain practical scenarios as much as possible, such as the checklist mentioned in this section. Filling words in a book are not my style—I like actions (quick quote: <em>planning without actions is just a dream</em>), and the upcoming checklist contains straightforward rules that you can use both as a security guideline for developers and as a checklist for you when you manually inspect the source code:</p>
<p><strong><span>Authentication and credentials management</span></strong>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 10px"><strong> √ </strong></td>
<td>
<p><span>Authentication credentials must use TLS and not HTTP cleartext.</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>Authentication must be enforced on all pages, except the ones intended to be public.</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>The error messages (in the login page, reset password page, and registration page) should not lead to information-gathering disclosure (for example, in the case of an invalid username).</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>Authentication logic must be validated on the server side.</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>Authentication passwords must be saved under secure hashing algorithms (mot MD5 or SHA1), and salting is preferable.</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>The password's hashing logic must be on the server side.</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>Validate the authentication data after the completion of all the data entry by the end user.</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>If the application is interacting with third-party web services, you will need to ensure the authentication as well as these endpoints.</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>The authentication credentials to interact with third-party web services should be encrypted and not be in cleartext (check the config file; developers will leave it there).</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p class="mce-root"><span>Enforce password complexity/length requirements established by policy or regulation.</span><br/>
<span>Use the following common best practices:</span></p>
<ul>
<li class="mce-root"><span>Minimum  length of 10 characters</span></li>
<li class="mce-root"><span>Minimum  of one  capital letter</span></li>
<li class="mce-root"><span>Minimum  of one  special character</span></li>
<li class="mce-root"><span>Minimum  of one number</span></li>
</ul>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>Ensure that all password fields do not echo the user's password when it is entered, and that the password fields have autocomplete disabled.</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>Password reset questions should support sufficiently random answers (for example, <em>What is your favorite color</em> is a bad question because <em>Red</em> is a very common answer).</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>If using email-based resets, only send email to a preregistered address with a temporary <em>random</em> link/password (short expiration time).</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>The temporary passwords must be changed for the next usage.</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>Alert users by email or SMS when a user changes or resets their password.</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Enforce account disabling after a number of login failures (five attempts is a commonly used limit). The account must be disabled for a period of time sufficient to discourage the brute-force guessing of credentials, but not so long as to allow for a denial-of-service attack to be performed.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>Reauthenticate users prior to performing critical operations.</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>Use multifactor authentication for highly sensitive or high-value transactional accounts.</span></p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p><span>Disable <em>remember me</em> functionality for password fields.</span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Authorization and access control</strong>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>√ </strong> </td>
<td>
<p>Authorization must be developed on the server side.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Deny all access if the application cannot access its security configuration information (for example, if the application cannot connect to the database).</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Authorization must exist on every web request (for example, the Web API endpoint).</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Access to files (for example, source code, configuration files) and resources (including protected URLs and web services ) must be restricted to admins; only they should be allowed to access those resources.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>If authorization data must be stored on the client side, then you must encrypt it.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Use the <kbd>Referer</kbd> header as an additional check, but be careful not to depend on it because it can be spoofed.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>OS/application service accounts should have the least privilege.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Authorize only HTTP methods: <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd>.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Make sure that you apply authorization changes right away after submitting them to the server by forcing the user to log out from the application.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Session management</strong></p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 10px"><strong>√  </strong></td>
<td>
<p>Sessions must be managed on the server side.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Session identifier (session ID) must be random (hackers should not be able to predict it).</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Logout functionality should totally terminate your session and should be available on all the authenticated pages.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Establish a session timeout after inactivity. To calculate the timeout period properly, you need to calculate the security risk of that resource.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Do not put session IDs in URLs, logs, and error messages (the session ID is located in the cookie header).</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Set the <kbd>secure</kbd> attribute for cookies.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Set the <kbd>HttpOnly</kbd> attribute for cookies.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Cryptography</strong>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>√ </strong> </td>
<td>
<p>Any cryptographic functionality to protect data should be implemented on the server side.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Critical data (for example, database-connection strings, passwords, keys, and so on) must be encrypted and should not be in cleartext.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Cryptographic keys must be protected from unauthorized users (only super admins should have access to them).</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>All generated random items—such as numbers, file names, and strings—must use highly cryptographic random generators.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>All cryptographic algorithms must use the latest and greatest secure algorithms. Refer to the NIST organization at <a href="https://csrc.nist.gov">https://csrc.nist.gov</a> to get all the information that you need.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Input validation</strong>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 10px"><strong>√ </strong> </td>
<td>
<p>All data validation must be performed on the server side.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Encode data before validation.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>All validation failures should be rejected in a custom error message.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>The validation should happen on anything that is processed in the backend, including hidden form values, URLs, and header contents (it should not be limited to form inputs).</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p class="mce-root">Hazardous characters<span>, such as <kbd>&lt;&gt;" ' % () &amp; + \ /</kbd>, </span><span>should be validated.</span></p>
<p>You should also validate the following:</p>
<ul>
<li>Null bytes (%00)</li>
<li>New line (\r,\n,%0d,%0a)</li>
<li>dot dot slash (../ or ..\)</li>
</ul>
</td>
</tr>
<tr>
<td><strong>√ </strong></td>
<td>
<p>Confirm that no hardcoded SQL queries exist in the source code.</p>
</td>
</tr>
<tr>
<td><strong>√ </strong></td>
<td>
<p>Truncate all input strings to a reasonable length before passing them to the <kbd>copy</kbd> and <kbd>concatenation</kbd> functions.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root"><strong>Output encoding</strong>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 10px"><strong>√  </strong></td>
<td>
<p>Conduct all the output encoding logic on the server side.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Sanitize all the output of untrusted data for SQL, XML, LDAP, and operating system commands.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root"><strong>Logging and error handling</strong>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>√</strong>  </td>
<td>
<p>Do not disclose sensitive information in error messages, including debugging information, such as a stack trace.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Use custom error messages and error pages.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Logging controls must be executed on the server side.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Logging events must be raised on both success and failure actions.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Log data must be clear enough to be able to understand what happened.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Log data must be sanitized if it's dependent on an input.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Log functions must be centralized and managed in the same class or module.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p class="mce-root">Make sure that you log the following events:</p>
<ul>
<li>Validation failures</li>
<li>Authentication attempts</li>
<li>Authorization failures</li>
<li>Tampering events (for example, URL manipulation for SQL injection)</li>
<li>Using invalid or expired sessions</li>
<li>All the administrative functions</li>
<li>Cryptographic module failures</li>
<li>Access from certain countries</li>
<li>High frequency of web requests</li>
</ul>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>When exceptions occur, you need to be able to exit that function securely.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Error or monitoring logs should not be saved on the same server to avoid DOS attacks (by filling the disk drive with random data).</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>Data protection</strong>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>√ </strong> </td>
<td>
<p>Temporary sensitive data (for example, caches, or transferred files) must be stored in a secure location, and those items must be purged as soon as possible.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Remove comments in the source code that may reveal critical information about the application.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Make sure that you protect files on the web server, and that only the intended files are called by clients. Protect config files, backup files, deployment scripts (or any script), documentation that is not intended for the public, temporary files, and any file that contains confidential information.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Sensitive information should not be used in the URL query string.</p>
</td>
</tr>
<tr>
<td/>
<td>
<p>Disable caching for pages that handle confidential information. Use <kbd>Cache-Control:no-store</kbd> and <kbd>Pragma:no-cache</kbd> for this.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Data in transit must be encrypted with the latest and greatest TLS algorithms.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Carefully use the <em>HTTP referrer</em> when dealing with external domains.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root"><strong>Miscellaneous</strong>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>√</strong> </td>
<td>
<p>Make sure that you remove test codes (not intended for production) before deployment.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Avoid disclosing your unwanted directory structure in the <kbd>robots.txt</kbd> file. Instead, create a parent directory and put all the hidden directories and files within it rather than disallowing each directory/file in <kbd>robots.txt</kbd>. </p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Remove any unnecessary information from the HTTP header (for example, the OS version, web server version, and programming frameworks).</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>If, for any reason, the application must elevate its privileges, make sure that you drop them as soon as possible.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p class="mce-root">When designing a REST web API, you have so many options for error codes other than 200 for success and 404 for errors. Proper error codes may help to validate the incoming requests properly. Here are some best practices to consider for each REST API status return code:</p>
<ul>
<li><strong>200 OK</strong>: The action is successful.</li>
<li><strong>202 Accepted</strong>: The request to create a resource is accepted.</li>
<li><strong>204 No Content</strong>: The POST request did not include a client-generated ID.</li>
<li><strong>400 Bad Request</strong>: The request is malformed.</li>
<li><strong>401 Unauthorized</strong>: Wrong authentication ID or credentials.</li>
<li><strong>403 Forbidden</strong>: An authenticated user does not have the permission to access the resource.</li>
<li><strong>404 Not Found</strong>: Requesting a nonexistant resource.</li>
<li><strong>405 Method Not Allowed</strong>: Unexpected HTTP method in the request.</li>
<li><strong>429 Too Many Requests</strong>: This error may occur when a DOS attack is detected.</li>
</ul>
</td>
</tr>
<tr>
<td><strong>√ </strong></td>
<td>
<p class="mce-root">Make sure that the following headers exist:</p>
<ul>
<li><kbd>X-frame-options</kbd></li>
<li><kbd>X-content-type-options</kbd></li>
<li><kbd>Strict-transport-security</kbd></li>
<li><kbd>Content-security-policy</kbd></li>
<li><kbd>X-permitted-cross-domain-policies</kbd></li>
<li><kbd>X-XSS-protection:1;mode=block</kbd></li>
<li><kbd>X-content-type-options:nosniff</kbd></li>
</ul>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p class="mce-root">Properly free allocated memory upon the completion of functions and at all exit points.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><strong>File management</strong>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>√ </strong> </td>
<td>
<p>The user must be authenticated before uploading any files into the application.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Limit the type of files that can be uploaded into the application.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Validate uploaded files by checking the file headers. Checking the extension by itself is not sufficient.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Uploaded files should be saved on a separate server rather than the web server. </p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Carefully check and validate (or remove if necessary) the uploaded files that will be executed and interpreted by the web server.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Execution privileges must be turned off on the file upload server.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Antiviruses and endpoint security must exist on the upload file server.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Do not pass directory or file paths; instead use index values mapped to a predefined list of paths. Never send the full absolute path in the response to the client.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>The web application files and resources must be in read-only format.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root"><strong>Third-party libraries</strong>:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td><strong>√ </strong> </td>
<td>
<p>Use checksums to verify the integrity of files (such as libraries and scripts) downloaded from the internet.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Ensure that the library that is downloaded and used in the application is the latest stable version.</p>
</td>
</tr>
<tr>
<td><strong>√</strong></td>
<td>
<p>Use a third-party libraries scanner (for example, Sonatype, Blackduck).</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Static code analysis is one of the pillars of application security, and I hope that you understood this chapter with ease. If you had any difficulty understanding the concepts of this chapter because of your lack of programming experience, then don't worry! This is the right time for you to start learning about programming in depth. Please refer to the <em>Programming background</em> section in this chapter for more details. </p>
<p>In the next chapter, we will cover all the topics <span>necessary </span>to execute a network infrastructure security test from start to finish successfully. Follow me and let's discover this amazing topic in depth!</p>


            </article>

            
        </section>
    </div>



  </body></html>