- en: Source Code Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are you ready for another great chapter? I'm assuming that you like this book
    so far, and, if that's the case, I'm glad?. This chapter will teach you how to
    deal with the Source Code Review process. The source code is the heart or engine
    of the web application, and it must be properly constructed from a security perspective.
    Your role as an application security expert is to make sure that developers really
    respect the security patterns. After reading that, you're probably saying *But
    Gus, I'm not good at programming*. You will see my response to this later in this
    chapter, but for the time being, rest assured that I will do my best to help you
    progress in your career.
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis is another buzzword for source code review. But wait, I'm
    not done yet. There is another buzzword, **static application security testing** (**SAST**).
    This buzzword is used very frequently by application security professionals, especially
    when we deal with automatic scanners (also known as SAST scanners).
  prefs: []
  type: TYPE_NORMAL
- en: I will be talking about this topic in detail later in this chapter, so keep
    reading to avoid missing all the fun and educational materials.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, I'm assuming that you finished your Application Threat Modeling
    document, and understand how the web application work at a higher level. Make
    sure that you review the Threat Modeling document to understand the project architecture
    (entry points, assets, external dependencies, trust levels, and security threats).
    I talked about threat modeling in the previous chapter for a reason, and that's
    because I'm trying to show you the flow of logic that you will use in a typical
    internal project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics that I will be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to estimate your programming background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding enterprise secure coding guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the difference between a manual code review and an automated one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure coding checklist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we proceed further in this chapter, I have to address the topic of your
    programming background in detail to help and guide you in the right direction
    as regards programming languages. I was a programmer for around 10 years before
    I turned into a full-time cyber-security expert. I can tell you that the experience
    that I acquired during my programming career greatly helped me in becoming successful
    in the field of application security. After all, how can you give an expert advice
    if you've never developed a web application in your life?
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages are divided into categories, and and they share a lot
    of similarities (more than you can imagine). Later in this chapter, I will show
    you the coding security checks (for web applications), but without referring to
    a specific one, because the checklist can be applied to any web application programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what you need to know about the most popular programming languages,
    and about the category to which they belong (again, these are the popular ones,
    not all of them):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web application development**: Java, C#, .NET, and PHP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drivers and hardware**: C, C++, and assembly language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reverse engineering**: Assembly language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: Structured Query LanguageSQL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scripting languages**: Python, Perl, and Ruby'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do you really need to learn all these languages? Yes, kind of, but let me make
    your life easier and simplify the task for you. First, start by learning a scripting
    language. In the upcoming chapters, you will encounter a special chapter that
    teaches you about Python. This language will help you a lot in automating your
    penetration testing activities, and at the same time it will help you to learn
    the basics of programming. Next, you will, need to learn at least one of three
    languages: Java, C#, .NET, or PHP. You also have to practice your use of them
    by developing web applications yourself. While you''re learning web application
    programming, you will also learn SQL because you will interact with the database,
    so that''s two birds with one stone. Assembly language is a special low-level
    language, but if you learn it, you will gain many more programming skills. As
    an application security professional, you will almost never have to deal with
    drivers/hardware or malware reverse engineering, so you can exclude these categories
    altogether.'
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise secure coding guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every enterprise will need security policies to define the best practices in
    security for its development teams. One of these policies is secure coding. You
    will be the custodian of these best practice documents (or checklist) and update
    them through the evolution of the technology. Whenever possible, the secure coding
    guidelines should be shared with developers in the organization through the intranet
    website of the company. If this document doesn't exist, it is your job as an application
    security professional to make a new one and suggest it to management, and believe
    me, they will appreciate it big time. Some companies encourage the idea of going
    through secure coding training for developers to engage them in that process.
    You can refer to the *secure coding checklist *section in this chapter to get
    ideas on how to develop your own secure coding guidelines for your company (as
    a consultant or employee).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an important topic that I mentioned in the previous chapter—SDL. This
    is a topic that I want you to master and understand how it works in practice,
    because secure coding is a prerequisite to SDL, and during the development of
    a normal project, secure coding should be used at every step, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Architecture phase**: At the beginning of the project, the architecture will
    be defined and the secure coding practices document will be used as a reference
    for all the technical challenges.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Development phase**: During the development phase, continuous integration
    will be used and executed every time the project is compiled on the build server.
    The static code analyzer will scan the code automatically after each build, and
    if the developer hasn''t respected the security guidelines, the scanner will most
    probably flag it as a flaw. We will talk in more detail about the automatic scanners
    later in this chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Before gating**: Before the deployment in the production environment, you
    will execute different tests (Web Intrusion and manual Source Code Review). At
    this stage, you can reuse the secure coding guidelines to enforce your arguments
    against the project team members (web application project) who will surely say
    that no one told them about this before.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/be699791-060b-4f1b-9a0f-feb68a4eb003.png)'
  prefs: []
  type: TYPE_IMG
- en: Static code analysis – manual scan versus automatic scan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding picture (In the previous section), you can clearly see that
    the manual code review will be executed when the project is ready for deployment
    in a typical security development lifecycle. The main idea that I need you to
    grasp here is that the manual scan happens after an automatic scan, so the manual
    code review is to spot any missing flaws that the automatic scanner didn't catch.
    Some people will debate this idea, and you will be surprised at the different
    opinions you'll get—someone might tell you that a manual scan is enough, and that
    they don't need a scanner, and that's too much ego because we're human, and we
    make mistakes no matter how good we are. On the other hand, some people will say
    that a scanner is enough, but according to their experience, there is always something
    that we catch after running a scan. Are you lost? Well, the answer is easy—you
    need to have both.
  prefs: []
  type: TYPE_NORMAL
- en: This will probably sound boring to you, but I'm doing my best to share the important
    tips that can help you in your career based on events that I witness in my daily
    job. Now let's talk more deeply about SAST scanners, because you will deal with
    them in a typical SDL. I'm not here to recommend any products, but I've dealt
    a lot with Veracode and it's a good product in general. I have also tried Checkmarx
    and have found it to be pretty good as well.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to use a SAST scanner is by implementing the continuous integration
    methodology. After finishing the architecture phase, programmers will start developing
    the product and later save it and push it to a build server (when they're done
    on a daily basis). A scanner such as Veracode will scan the code right away after
    the build, and will flag any vulnerabilities found in the newly saved code. The
    application security analyst will take a close look at the results of the scanner
    and make sure that they collaborate with the development lead, also known as the
    security champion, for bug fixing. Later, when the project is ready for release,
    the backlog of the scanner should not contain any high or critical vulnerabilities
    in order to pass the score before the manual source code review begins.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, during CI integration, you will be assisting the project team
    to evaluate false positives. The security champion will submit the demand inside
    the SAST portal and will be waiting for your approval to flag it as a false positive.
    Scanners are not perfect and a lot of issues can arise. Your role is to always support
    the development team and make sure that you send any bugs in the scanner itself
    to the product supplier.
  prefs: []
  type: TYPE_NORMAL
- en: If you've been asked by your employer to evaluate a SAST scanner, I encourage
    you to check the best ones on the Gartner list and do your own tests. Bring multiple
    applications and scan them. Later, compare the number of false positives to the vulnerabilities
    found in each scanner; don't just blindly assume that the Gartner choices are
    correct without trying them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Secure coding checklist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I wrote this book so that you can have a bible of application security to use
    on a daily basis in your career. I want this book to contain practical scenarios
    as much as possible, such as the checklist mentioned in this section. Filling
    words in a book are not my style—I like actions (quick quote: *planning without
    actions is just a dream*), and the upcoming checklist contains straightforward
    rules that you can use both as a security guideline for developers and as a checklist
    for you when you manually inspect the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication and credentials management**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ** √ ** | Authentication credentials must use TLS and not HTTP cleartext.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Authentication must be enforced on all pages, except the ones intended
    to be public. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | The error messages (in the login page, reset password page, and registration
    page) should not lead to information-gathering disclosure (for example, in the
    case of an invalid username). |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Authentication logic must be validated on the server side. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Authentication passwords must be saved under secure hashing algorithms
    (mot MD5 or SHA1), and salting is preferable. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | The password''s hashing logic must be on the server side. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Validate the authentication data after the completion of all the
    data entry by the end user. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | If the application is interacting with third-party web services,
    you will need to ensure the authentication as well as these endpoints. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | The authentication credentials to interact with third-party web services
    should be encrypted and not be in cleartext (check the config file; developers
    will leave it there). |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Enforce password complexity/length requirements established by policy
    or regulation. Use the following common best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum  length of 10 characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum  of one  capital letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum  of one  special character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum  of one number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√** | Ensure that all password fields do not echo the user''s password
    when it is entered, and that the password fields have autocomplete disabled. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Password reset questions should support sufficiently random answers
    (for example, *What is your favorite color* is a bad question because *Red* is
    a very common answer). |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | If using email-based resets, only send email to a preregistered address
    with a temporary *random* link/password (short expiration time). |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | The temporary passwords must be changed for the next usage. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Alert users by email or SMS when a user changes or resets their password.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Enforce account disabling after a number of login failures (five
    attempts is a commonly used limit). The account must be disabled for a period
    of time sufficient to discourage the brute-force guessing of credentials, but
    not so long as to allow for a denial-of-service attack to be performed. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Reauthenticate users prior to performing critical operations. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Use multifactor authentication for highly sensitive or high-value
    transactional accounts. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Disable *remember me* functionality for password fields. |'
  prefs: []
  type: TYPE_TB
- en: '**Authorization and access control**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√ **  | Authorization must be developed on the server side. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Deny all access if the application cannot access its security configuration
    information (for example, if the application cannot connect to the database).
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Authorization must exist on every web request (for example, the Web
    API endpoint). |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Access to files (for example, source code, configuration files) and
    resources (including protected URLs and web services ) must be restricted to admins;
    only they should be allowed to access those resources. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | If authorization data must be stored on the client side, then you
    must encrypt it. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Use the `Referer` header as an additional check, but be careful not
    to depend on it because it can be spoofed. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | OS/application service accounts should have the least privilege.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Authorize only HTTP methods: `GET`, `POST`, `PUT`, and `DELETE`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Make sure that you apply authorization changes right away after submitting
    them to the server by forcing the user to log out from the application. |'
  prefs: []
  type: TYPE_TB
- en: '**Session management**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√  ** | Sessions must be managed on the server side. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Session identifier (session ID) must be random (hackers should not
    be able to predict it). |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Logout functionality should totally terminate your session and should
    be available on all the authenticated pages. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Establish a session timeout after inactivity. To calculate the timeout
    period properly, you need to calculate the security risk of that resource. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Do not put session IDs in URLs, logs, and error messages (the session
    ID is located in the cookie header). |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Set the `secure` attribute for cookies. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Set the `HttpOnly` attribute for cookies. |'
  prefs: []
  type: TYPE_TB
- en: '**Cryptography**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√ **  | Any cryptographic functionality to protect data should be implemented
    on the server side. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Critical data (for example, database-connection strings, passwords,
    keys, and so on) must be encrypted and should not be in cleartext. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Cryptographic keys must be protected from unauthorized users (only
    super admins should have access to them). |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | All generated random items—such as numbers, file names, and strings—must
    use highly cryptographic random generators. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | All cryptographic algorithms must use the latest and greatest secure
    algorithms. Refer to the NIST organization at [https://csrc.nist.gov](https://csrc.nist.gov)
    to get all the information that you need. |'
  prefs: []
  type: TYPE_TB
- en: '**Input validation**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√ **  | All data validation must be performed on the server side. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Encode data before validation. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | All validation failures should be rejected in a custom error message.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | The validation should happen on anything that is processed in the
    backend, including hidden form values, URLs, and header contents (it should not
    be limited to form inputs). |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Hazardous characters, such as `<>" '' % () & + \ /`, should be validated.You
    should also validate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Null bytes (%00)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New line (\r,\n,%0d,%0a)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dot dot slash (../ or ..\)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√ ** | Confirm that no hardcoded SQL queries exist in the source code.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√ ** | Truncate all input strings to a reasonable length before passing
    them to the `copy` and `concatenation` functions. |'
  prefs: []
  type: TYPE_TB
- en: '**Output encoding**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√  ** | Conduct all the output encoding logic on the server side. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Sanitize all the output of untrusted data for SQL, XML, LDAP, and
    operating system commands. |'
  prefs: []
  type: TYPE_TB
- en: '**Logging and error handling**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√**   | Do not disclose sensitive information in error messages, including
    debugging information, such as a stack trace. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Use custom error messages and error pages. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Logging controls must be executed on the server side. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Logging events must be raised on both success and failure actions.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Log data must be clear enough to be able to understand what happened.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Log data must be sanitized if it''s dependent on an input. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Log functions must be centralized and managed in the same class or
    module. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Make sure that you log the following events:'
  prefs: []
  type: TYPE_NORMAL
- en: Validation failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tampering events (for example, URL manipulation for SQL injection)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using invalid or expired sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the administrative functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptographic module failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access from certain countries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High frequency of web requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√** | When exceptions occur, you need to be able to exit that function
    securely. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Error or monitoring logs should not be saved on the same server to
    avoid DOS attacks (by filling the disk drive with random data). |'
  prefs: []
  type: TYPE_TB
- en: '**Data protection**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√ **  | Temporary sensitive data (for example, caches, or transferred files)
    must be stored in a secure location, and those items must be purged as soon as
    possible. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Remove comments in the source code that may reveal critical information
    about the application. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Make sure that you protect files on the web server, and that only
    the intended files are called by clients. Protect config files, backup files,
    deployment scripts (or any script), documentation that is not intended for the
    public, temporary files, and any file that contains confidential information.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Sensitive information should not be used in the URL query string.
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | Disable caching for pages that handle confidential information. Use `Cache-Control:no-store`
    and `Pragma:no-cache` for this. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Data in transit must be encrypted with the latest and greatest TLS
    algorithms. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Carefully use the *HTTP referrer* when dealing with external domains.
    |'
  prefs: []
  type: TYPE_TB
- en: '**Miscellaneous**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√**  | Make sure that you remove test codes (not intended for production)
    before deployment. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Avoid disclosing your unwanted directory structure in the `robots.txt`
    file. Instead, create a parent directory and put all the hidden directories and
    files within it rather than disallowing each directory/file in `robots.txt`. 
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Remove any unnecessary information from the HTTP header (for example,
    the OS version, web server version, and programming frameworks). |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | If, for any reason, the application must elevate its privileges,
    make sure that you drop them as soon as possible. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | When designing a REST web API, you have so many options for error
    codes other than 200 for success and 404 for errors. Proper error codes may help
    to validate the incoming requests properly. Here are some best practices to consider
    for each REST API status return code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**200 OK**: The action is successful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**202 Accepted**: The request to create a resource is accepted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**204 No Content**: The POST request did not include a client-generated ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**400 Bad Request**: The request is malformed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**401 Unauthorized**: Wrong authentication ID or credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**403 Forbidden**: An authenticated user does not have the permission to access
    the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**404 Not Found**: Requesting a nonexistant resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**405 Method Not Allowed**: Unexpected HTTP method in the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**429 Too Many Requests**: This error may occur when a DOS attack is detected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√ ** | Make sure that the following headers exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '`X-frame-options`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-content-type-options`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Strict-transport-security`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-security-policy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-permitted-cross-domain-policies`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-XSS-protection:1;mode=block`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-content-type-options:nosniff`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√** | Properly free allocated memory upon the completion of functions and
    at all exit points. |'
  prefs: []
  type: TYPE_TB
- en: '**File management**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√ **  | The user must be authenticated before uploading any files into
    the application. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Limit the type of files that can be uploaded into the application.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Validate uploaded files by checking the file headers. Checking the
    extension by itself is not sufficient. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Uploaded files should be saved on a separate server rather than the
    web server.  |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Carefully check and validate (or remove if necessary) the uploaded
    files that will be executed and interpreted by the web server. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Execution privileges must be turned off on the file upload server.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Antiviruses and endpoint security must exist on the upload file server.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Do not pass directory or file paths; instead use index values mapped
    to a predefined list of paths. Never send the full absolute path in the response
    to the client. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | The web application files and resources must be in read-only format.
    |'
  prefs: []
  type: TYPE_TB
- en: '**Third-party libraries**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **√ **  | Use checksums to verify the integrity of files (such as libraries
    and scripts) downloaded from the internet. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Ensure that the library that is downloaded and used in the application
    is the latest stable version. |'
  prefs: []
  type: TYPE_TB
- en: '| **√** | Use a third-party libraries scanner (for example, Sonatype, Blackduck).
    |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static code analysis is one of the pillars of application security, and I hope
    that you understood this chapter with ease. If you had any difficulty understanding
    the concepts of this chapter because of your lack of programming experience, then
    don't worry! This is the right time for you to start learning about programming
    in depth. Please refer to the *Programming background* section in this chapter
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover all the topics necessary to execute a network
    infrastructure security test from start to finish successfully. Follow me and
    let's discover this amazing topic in depth!
  prefs: []
  type: TYPE_NORMAL
