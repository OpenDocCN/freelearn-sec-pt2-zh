<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer014">
			<h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: Introduction to Privilege Escalation</h1>
			<p>Privilege escalation is a vital element of the attack life cycle and is a major determinant in the overall success of a penetration test. </p>
			<p>The importance of privilege escalation in the penetration testing process cannot be overstated or overlooked. Developing your privilege escalation skills will mark you out as a good penetration tester. The ability to enumerate information from a target system and utilize this information to identify potential misconfigurations and vulnerabilities that can be exploited to elevate privileges is an essential skill set for any penetration tester.</p>
			<p>This chapter aims to give you a clearer picture and understanding of the privilege escalation process and will act as a formal introduction to the various types of privilege escalation techniques, and how the process differs between Windows and Linux systems. </p>
			<p>To fully understand and leverage the various privilege escalation tools and techniques, you first need to understand how permissions and privileges are implemented on various operating systems and how these differences in design and implementation affect the privilege escalation process as a whole.</p>
			<p>By the end of this chapter, you will have a clear understanding of what privilege escalation is, and you will also understand how permissions are implemented on Windows and Linux systems and get a brief introduction to the various privilege escalation techniques that we will be exploring in depth in the upcoming chapters.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>What is privilege escalation?</li>
				<li>How permissions and privileges are assigned</li>
				<li>Understanding the differences between privilege escalation on Windows and Linux </li>
				<li>Exploring the types of privilege escalation attack</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>What is privilege escalation?</h1>
			<p><strong class="bold">Privilege escalation</strong> is the process of exploiting vulnerabilities or misconfigurations in systems to <a id="_idIndexMarker000"/>elevate privileges from one user to another, typically to a user with administrative or <em class="italic">root</em> access on a system. Successful privilege escalation allows attackers to increase their control over a system or group of systems that belong to a domain, giving them the ability to make administrative changes, exfiltrate data, modify or damage the operating system, and maintain access through persistence, such as registry edits or cron jobs.</p>
			<p>From a penetration tester's perspective, privilege escalation is the next logical step after the successful exploitation of a system and is typically performed by bypassing or exploiting authentication and authorization systems, whose purpose is to segregate user accounts based on their permissions and role.</p>
			<p>A typical approach would be to use an initial access or foothold on a system to gain access to <a id="_idIndexMarker001"/>resources and functionality that is beyond what the current user account permissions offer. This process is commonly referred to as getting <strong class="bold">root</strong> privileges on a system.</p>
			<p>Before we can get started with the various privilege escalation techniques, we need to understand how user accounts and permissions are implemented in modern operating systems.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>How permissions and privileges are assigned</h1>
			<p>To better understand <a id="_idIndexMarker002"/>how to elevate <strong class="bold">privileges</strong>, we need to first understand how operating <a id="_idIndexMarker003"/>systems are designed in relation to user accounts and privilege. </p>
			<p>Operating <a id="_idIndexMarker004"/>systems' authorizations are designed to handle multiple users with multiple roles and permissions. This segregation of roles is the primary factor behind the various user account implementation philosophies that are implemented in operating systems today.</p>
			<p>This abstraction <a id="_idIndexMarker005"/>of user roles and permissions on a system is set up and facilitated by a system called a <strong class="bold">protection ring</strong>, as demonstrated in <em class="italic">Figure 1.1</em>. This specifies limits and enforces the functionality of users on a system and their corresponding access to resources.</p>
			<p>As the name suggests, a protection ring is a hierarchical protection and segregation mechanism used to provide different levels of access to functionality and resources on a system. The various rings in the hierarchy represent layers of privilege within the operating system, as illustrated in the following screenshot:</p>
			<div>
				<div id="_idContainer005" class="IMG---Figure">
					<img src="Images/B17389_01_001.jpg" alt="Figure 1.1 – Protection ring&#13;&#10;" width="454" height="322"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Protection ring</p>
			<p>The rings in the hierarchy illustrated in <em class="italic">Figure 1.1</em> are sorted and arranged from the most privileged (typically denoted by level 0) to the least privileged, where the least privileged <a id="_idIndexMarker006"/>is represented by the highest ring number. This segregation <a id="_idIndexMarker007"/>of privileges on a system leads to the adoption of two main roles, as follows:</p>
			<ul>
				<li><strong class="bold">Privileged access</strong>: This is <a id="_idIndexMarker008"/>typically represented or assigned to the root or <strong class="bold">administrator</strong> account and provides complete access to all system commands and resources. The root or administrator account will typically have access to the following functionality:<p>1. The ability to install, uninstall, and modify system software or binaries</p><p>2. The ability to add, modify, or remove users and user groups</p><p>3. The ability to create, access, modify, and delete any system or user data</p><p>4. The ability to access and have control over all system hardware</p><p>5. The ability to access network functionality and networking utilities</p><p>6. The ability to create, manage, and kill system and user processes </p></li>
				<li><strong class="bold">Unprivileged access</strong>: This is typically represented or assigned to <em class="italic">non-root</em> or standard <a id="_idIndexMarker009"/>user accounts and is limited to a specific set of privileges that are designed and tailored for standard user access on a system. It limits the user functionality to basic tasks and access of user data on the system. Non-root accounts will commonly have the following functionality:<p>1. The ability to start and stop user processes and programs</p><p>2. The ability to create, modify, and delete user data</p><p>3. The ability to have access to network functionality</p></li>
			</ul>
			<p>This segregation <a id="_idIndexMarker010"/>of permissions highlights the importance of privilege <a id="_idIndexMarker011"/>escalation for penetration testers or attackers as it offers total and unparalleled control over a system or, potentially, a group of systems if they can get "root" or administrative access on a system.</p>
			<p>Given the nature of privilege escalation attacks in relation to user accounts and permissions, there are two main methods of performing privilege escalation that can be utilized by attackers based on their intentions and objectives, as follows:</p>
			<ul>
				<li>Horizontal privilege escalation</li>
				<li>Vertical privilege escalation</li>
			</ul>
			<p>We will take a closer look at what they are in the next section. </p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Horizontal privilege escalation</h2>
			<p><strong class="bold">Horizontal privilege escalation</strong> is the process of accessing the functionality or data of other <a id="_idIndexMarker012"/>user accounts on a system, as opposed <a id="_idIndexMarker013"/>to gaining access to accounts with administrative or root privileges. It primarily involves accessing or authorizing functionality on a system using accounts that are on the same user level of permissions, as opposed to user accounts that are higher up and that have more privileges and permissions. </p>
			<p>Attackers <a id="_idIndexMarker014"/>or penetration testers would typically <a id="_idIndexMarker015"/>perform this type of privilege escalation attack if they were interested in accessing unprivileged user account data or in harvesting user account credentials or password hashes.</p>
			<h3>Scenario</h3>
			<p>The following <a id="_idIndexMarker016"/>screenshot illustrates a typical account setup on a computer, where we have two unprivileged users and one privileged user. In this case, the two unprivileged users are <strong class="bold">John</strong> and <strong class="bold">Mike</strong>, and the privileged user is <strong class="bold">Collin</strong>:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="Images/B17389_01_002.jpg" alt="Figure 1.2 – Horizontal privilege escalation scenario&#13;&#10;" width="641" height="241"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Horizontal privilege escalation scenario</p>
			<p>In this scenario, John is attempting to perform a typical horizontal privilege escalation attack by escalating his user account privileges to the account privileges of Mike. Note that John and Mike are on the same horizontal privilege level. </p>
			<p><em class="italic">Figure 1.2</em> clearly outlines the sole objective of horizontal privilege escalation, the objective being to elevate privileges to user accounts that are on the same horizontal level as the user account performing the attack.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Vertical privilege escalation</h2>
			<p><strong class="bold">Vertical privilege escalation</strong> is the process of exploiting a vulnerability in an operating <a id="_idIndexMarker017"/>system to gain root or administrative <a id="_idIndexMarker018"/>access on a system. This method is usually preferred by attackers and penetration testers as it offers the biggest payout given the permissions and functionality, as they now have total access and control over the system(s).</p>
			<p>The following screenshot outlines a bottom-up approach to user account permissions and privileges, where the topmost account has the highest privileges, is the least accessible, and is typically assigned to system administrators. The lowest accounts are set up and configured to be used by standard users and services that require no administrative privileges as part of their daily tasks:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="Images/B17389_01_003.jpg" alt="Figure 1.3 – Vertical privilege escalation" width="368" height="313"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Vertical privilege escalation </p>
			<p><em class="italic">Figure 1.3</em> also illustrates a vertical approach to elevating privileges based on the user account and permissions for both Windows and Linux systems, the objective being to laterally move up the pecking order to the account with the highest privileges, therefore giving you complete access to the system.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Vertical privilege escalation may not solely emanate from the exploitation of a vulnerability within an operating system or service. It is common to find misconfigured systems and services that may allow non-administrative user accounts to run commands or binaries with administrative permissions. We will take a look at the various privilege escalation techniques in the upcoming chapters.</p>
			<h3>Scenario</h3>
			<p>The following <a id="_idIndexMarker019"/>screenshot illustrates a typical account setup on a computer, where we have two unprivileged users and one privileged user. In this case, the two unprivileged users are <strong class="bold">John</strong> and <strong class="bold">Mike</strong>, and the privileged user is <strong class="bold">Collin</strong>:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="Images/B17389_01_004.jpg" alt="Figure 1.4 – Vertical privilege escalation scenario&#13;&#10;" width="641" height="241"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Vertical privilege escalation scenario</p>
			<p>For this scenario, <em class="italic">Figure 1.4</em> illustrates a traditional vertical privilege escalation method where the user John is attempting to elevate privileges to the administrator account, which is Collin's account. If successful, John will get access to administrative privileges and will be able to access all user accounts and files, therefore giving him total access and control over the system. This scenario demonstrates the importance and potential impact of a successful vertical privilege escalation attack.</p>
			<p>Now that we have an understanding of the two main privilege escalation methods and how they are orchestrated, we can begin taking a look at the various differences between privilege escalation on Windows and Linux.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Understanding the differences between privilege escalation on Windows and Linux</h1>
			<p>Now <a id="_idIndexMarker020"/>that we <a id="_idIndexMarker021"/>have a general understanding of how user accounts and permissions are implemented and have looked at the two main methods of performing privilege escalation, we can begin taking a look <a id="_idIndexMarker022"/>at the <a id="_idIndexMarker023"/>differences between <strong class="bold">Linux</strong> and <strong class="bold">Windows</strong> in the context of privilege escalation attacks and at how their individual design and development philosophies affect the privilege escalation process.</p>
			<p>This nuanced approach will give us clarity on the strengths and weaknesses of both operating systems and their corresponding kernels in relation to vulnerabilities and potential exploitation.</p>
			<p>The following <a id="_idIndexMarker024"/>table outlines common potential <strong class="bold">attack vectors</strong> for both <a id="_idIndexMarker025"/>operating systems and the services that can be exploited <a id="_idIndexMarker026"/>to elevate privileges:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="Images/B17389_01_Table_1.1.jpg" alt="Table 1.1 – Common potential attack vectors &#13;&#10;" width="1496" height="550"/>
				</div>
			</div>
			<p class="figure-caption">Table 1.1 – Common potential attack vectors </p>
			<p>To fully understand the differences between the two operating systems in terms of potential vulnerabilities and attack vectors, we need to understand how they handle authentication and security as this will give us an idea of where the security pitfalls exist. It is <a id="_idIndexMarker027"/>important to note, however, that the security differences between Windows and Linux boil <a id="_idIndexMarker028"/>down to their unique design philosophy.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Windows security</h2>
			<p>Windows is a proprietary operating system that is owned and developed by the Microsoft <a id="_idIndexMarker029"/>Corporation and controls a majority of the PC market share at about 93%, which means that most companies are likely to be running Windows clients for their end users and/or Windows Server deployments for their critical infrastructure.</p>
			<p>For this reason, Windows is more likely to be running on employee laptops and workstations <a id="_idIndexMarker030"/>as it has a much more <strong class="bold">user-centered design</strong> (<strong class="bold">UCD</strong>) and philosophy. In order to understand the privilege escalation process on Windows, we need to understand how Windows manages and maintains system security. In order to do this, we will need to take a closer look at various components that are responsible for managing and maintaining authentication and security on Windows.</p>
			<h3>User authentication</h3>
			<p>Authentication is <a id="_idIndexMarker031"/>the process of verifying the identity of a user who is trying to access a system or system resource. </p>
			<p>Authentication <a id="_idIndexMarker032"/>on most modern operating systems is typically enforced through a username and password combination; however, operating systems have begun implementing additional layers of authentication, in addition to implementing stronger encryption algorithms for user passwords.</p>
			<p>Passwords and password hashes are usually a target for penetration testers, and we will take a look at how to dump system passwords and hashes later in the book.</p>
			<p>User <a id="_idIndexMarker033"/>authentication on Windows is handled by the <strong class="bold">Windows Logon</strong> (<strong class="bold">Winlogon</strong>) process and <strong class="bold">Security Account Manager</strong> (<strong class="bold">SAM</strong>). SAM is <a id="_idIndexMarker034"/>a database that is used to manage and store user accounts on Windows systems. </p>
			<p>Modern releases <a id="_idIndexMarker035"/>of Windows utilize the <strong class="bold">New Technology LAN Manager 2</strong> (<strong class="bold">NTLM2</strong>) encryption protocol for password hashing and encryption, which is significantly stronger than the <strong class="bold">LAN Manager</strong> (<strong class="bold">LM</strong>) encryption <a id="_idIndexMarker036"/>protocol present in older versions of Windows.</p>
			<p>Authentication onto domains on Windows is typically facilitated by authentication protocols such as Kerberos. </p>
			<h3>User identification</h3>
			<p>User identification is used to uniquely identify users on a system and is also used to establish <a id="_idIndexMarker037"/>a system of accountability, as actions performed on a system can be tracked down to the user who made or performed them. Understanding how identification works and is implemented on Windows is extremely useful in the privilege escalation process to identify users on a system, along with their roles and groups.</p>
			<p>The process <a id="_idIndexMarker038"/>of user identification on Windows utilizes a <strong class="bold">security identifier</strong> (<strong class="bold">SID</strong>) for identification. Each user and group has a unique SID that consists of the components outlined in the following screenshot: </p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="Images/B17389_01_005.jpg" alt="Figure 1.5 – Sample Windows SID &#13;&#10;" width="571" height="171"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Sample Windows SID </p>
			<p>The different <a id="_idIndexMarker039"/>parameters from the preceding SID are discussed as follows: </p>
			<ul>
				<li><strong class="bold">SID String</strong>: <strong class="bold">S</strong> indicates that it's an SID string</li>
				<li><strong class="bold">Revision</strong>: Always set to 1; this refers to the structure revision number</li>
				<li><strong class="bold">Authority ID</strong>: Specifies who created or granted the SID, as follows:<p>- <strong class="bold">Null</strong>: 0</p><p>- <strong class="bold">World authority</strong>: 1</p><p>- <strong class="bold">Local authority</strong>: 2</p><p>- <strong class="bold">Creator authority</strong>: 3</p><p>- <strong class="bold">Non-unique authority</strong>: 4 </p><p>- <strong class="bold">NT authority</strong>: 5</p></li>
				<li><strong class="bold">Subauthority ID</strong>/<strong class="bold">actual ID</strong>: Unique ID for the user, or comprises the domain identifier</li>
				<li><strong class="bold">RID</strong>: This stands for <strong class="bold">relative ID</strong> and is <a id="_idIndexMarker040"/>used in reference to other accounts to distinguish <a id="_idIndexMarker041"/>one user from another. Windows will have the following unique RIDs assigned to specific users. It is important to be able to identify privileged users based on their SID, as follows:<p>- <strong class="bold">Administrator</strong>: 500</p><p>- <strong class="bold">Guest user</strong>: 501</p><p>- <strong class="bold">Domain administrator</strong>: 512</p><p>- <strong class="bold">Domain computer</strong>: 515</p></li>
			</ul>
			<p>You can <a id="_idIndexMarker042"/>enumerate the SIDs on a Windows system by running the following command in <strong class="bold">Command Prompt</strong> (<strong class="bold">CMD</strong>):</p>
			<p class="source-code">wmic useraccount get name,sid</p>
			<p>This command will enumerate all user account SIDs on the system, as illustrated in the following screenshot. Pay close attention to the RIDs as they can be used to quickly identify administrator and guest accounts:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="Images/B17389_01_006.jpg" alt="Figure 1.6 – Enumerating Windows SIDs&#13;&#10;" width="542" height="232"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – Enumerating Windows SIDs</p>
			<p>As displayed in <em class="italic">Figure 1.6</em>, we can identify user roles based on their RID, regardless of the account <a id="_idIndexMarker043"/>username. In this particular case, we have an administrator and guest account set up and they can be identified by their RID.</p>
			<h3>Access tokens</h3>
			<p>An access token is an object that describes and identifies the security context of a process or <a id="_idIndexMarker044"/>thread on a system. The access token is generated by the Winlogon process every time a user authenticates successfully, and includes the identity and privileges of the user account associated with the thread or process. This token is then attached to the initial process (typically the <strong class="source-inline">userinit.exe</strong> process), after which all child processes will inherit a copy of the access token from their creator and will run under the same access token.</p>
			<p>On Windows, an access token will comprise the following elements:</p>
			<ul>
				<li>User SID</li>
				<li>Group SID</li>
				<li>Logon SID</li>
				<li>Privileges assigned to the user or the user's group</li>
				<li><strong class="bold">Discretionary access control list</strong> (<strong class="bold">DACL</strong>) being used </li>
				<li>Source of the access token</li>
			</ul>
			<p>We can list out the access token of a user by running the following command in the CMD:</p>
			<p class="source-code">Whoami /priv</p>
			<p>If the <a id="_idIndexMarker045"/>user is unprivileged, the access token will be restricted, as outlined in the following screenshot: </p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="Images/B17389_01_007.jpg" alt="Figure 1.7 – Restricted access token&#13;&#10;" width="606" height="229"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Restricted access token</p>
			<p>It is important to note that the user highlighted in <em class="italic">Figure 1.7</em> has administrative privileges; however, the <strong class="source-inline">cmd.exe</strong> process uses an access token that restricts privileges. If we run <strong class="source-inline">cmd.exe</strong> as an administrator, the user's access token will be listed with all privileges, as outlined in the following screenshot:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="Images/B17389_01_008.jpg" alt="Figure 1.8 – Privileged access token&#13;&#10;" width="944" height="528"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Privileged access token</p>
			<p>Access tokens <a id="_idIndexMarker046"/>can be leveraged during the privilege escalation process through attacks such as primary access token manipulation attacks, which involve tricking a system into believing that a process belongs to a different user from the one who started the process. We will learn how to utilize this attack vector to escalate our privileges later in the book.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Linux security</h2>
			<p>Linux is a free and open source operating system that comprises the Linux kernel, which was <a id="_idIndexMarker047"/>developed by Linus Torvalds, and the <strong class="bold">GNU's Not Unix</strong> (<strong class="bold">GNU</strong>) toolkit, which is a collection of software and utilities that was originally <a id="_idIndexMarker048"/>started and developed by Richard Stallman. This combination of open source projects is what makes up the Linux operating system as a whole, and it is commonly referred to as GNU/Linux.</p>
			<p>Typically, most <a id="_idIndexMarker049"/>individuals and companies are likely to be running Windows clients and will be using Linux for their critical infrastructure—for instance, mail servers, databases, web servers, and <strong class="bold">intrusion detection systems</strong> (<strong class="bold">IDSes</strong>). Given the nature and deployment of Linux servers in organizations, attacks will be much more likely to severely affect a company and cause major disruption.</p>
			<h3>User authentication</h3>
			<p>User account details on Linux are stored in a <strong class="source-inline">/etc/passwd</strong> file. This file contains the user account <a id="_idIndexMarker050"/>username, the <strong class="bold">user ID</strong> (<strong class="bold">UID</strong>), an encrypted password, a <strong class="bold">group ID</strong> (<strong class="bold">GID</strong>), and personal user information.</p>
			<p>This file <a id="_idIndexMarker051"/>can be accessed by all users on the system, which means that any <a id="_idIndexMarker052"/>user on the system can retrieve the password hashes of other users on the system. This makes the hash-dumping process on Linux much more straightforward and opens the door to potential password-cracking attacks. Most older Linux <a id="_idIndexMarker053"/>distributions utilized the <strong class="bold">Message Digest Algorithm 5</strong> (<strong class="bold">MD5</strong>) hashing algorithm, which is much easier to crack, and as a result, most <a id="_idIndexMarker054"/>newer distributions have begun utilizing and implementing the <strong class="bold">Secure Hash Algorithm 256</strong> (<strong class="bold">SHA-256</strong>) encryption protocol, therefore making it much more difficult to crack the hashes.</p>
			<h3>Identification</h3>
			<p>User authentication on Linux is facilitated through the use of a us<a id="_idTextAnchor022"/>ername that corresponds <a id="_idIndexMarker055"/>to a unique UID, comprising a numeric <a id="_idIndexMarker056"/>value that is automatically assigned or manually assigned by a system administrator. The root account on Linux will always have a UID of 0.</p>
			<p>This user information, along with the hashed user passwords, is stored in the <strong class="source-inline">/etc/passwd</strong> file. </p>
			<h3>Access tokens</h3>
			<p>Access tokens <a id="_idIndexMarker057"/>on Linux work in a similar way to how they work <a id="_idIndexMarker058"/>on Windows but are stored in memory (<strong class="bold">random-access memory</strong>, or <strong class="bold">RAM</strong>) and attached to processes when initialized.</p>
			<p>The access token on Linux will contain the following information:</p>
			<ul>
				<li>UID of the user account</li>
				<li>GID/GIDs of the groups that the user is a member of</li>
				<li>User privileges</li>
				<li>Primary group UID</li>
				<li><strong class="bold">Access control list</strong> (<strong class="bold">ACL</strong>) entries</li>
			</ul>
			<p>Now that <a id="_idIndexMarker059"/>we have an understanding of the various authentication and security components used on Windows and Linux, we can take a look at <a id="_idIndexMarker060"/>the various types of privilege escalation attack and how they exploit the aforementioned security mechanisms.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor023"/>Exploring the types of privilege escalation attack</h1>
			<p>We can now explore the most common privilege escalation attacks and how they work. The objective <a id="_idIndexMarker061"/>is to get a basic picture of the types of privilege escalation attack available and to understand how they are exploited. </p>
			<p>We will take a look at how to exploit these vulnerabilities in depth on both Windows and Linux systems in the upcoming chapters.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/>Kernel exploits</h2>
			<p>Kernel exploits are programs or binaries that affect both Windows and Linux and are <a id="_idIndexMarker062"/>designed to exploit vulnerabilities in the underlying kernel, to execute arbitrary code with elevated or "root" permissions. </p>
			<p>The exploitation <a id="_idIndexMarker063"/>process is multi-faceted and requires a good amount of enumeration in order to determine the operating system version and installed patches or hotfixes, and consequently whether it is affected by any kernel exploits, after which the kernel exploit code can be retrieved through various exploit repositories such as <strong class="source-inline">exploit-db</strong>. The exploit code should then be inspected and customized based on the required parameters and functionality. After customization, the code can be compiled into a binary and transferred over to the target for execution. In some cases, the exploit code will need to be downloaded and compiled on the target if it relies on certain dependencies.</p>
			<p>After successful compilation and execution of the binary, the kernel exploit will grant the attacker "root" access on the target system in the form of a shell prompt, where they can run commands on the system with "root" privileges.</p>
			<p>In many cases, precompiled kernel exploits for Windows already exist online and can be downloaded <a id="_idIndexMarker064"/>and executed directly, therefore avoiding the compilation <a id="_idIndexMarker065"/>process altogether. However, it is very important to inspect and analyze the exploit code before compiling it, as exploits could contain malicious code or payloads.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Kernel exploits are extremely powerful; however, they can cause system crashes and kernel panics that can hinder the privilege escalation process and can cause damage to the system.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/>Exploiting SUID binaries</h2>
			<p><strong class="bold">SUID</strong> is an inbuilt <a id="_idIndexMarker066"/>Linux feature that allows users to execute binaries and files with the permissions of other users. </p>
			<p>This feature <a id="_idIndexMarker067"/>is commonly used to allow non-root accounts to run system utilities and binaries with root permissions. You can <a id="_idIndexMarker068"/>set the program or utility SUID permission with the owner as "root." This will allow the program or utility to run with "root" privileges whenever a non-root user executes it. Attackers can exploit or take advantage of SUID misconfigurations and run arbitrary commands as root. </p>
			<p>For example, programs or binaries that allow the execution of arbitrary commands such as <strong class="source-inline">vim</strong> should not have their SUID owner set as "root," as non-root users can leverage the command execution functionality within <strong class="source-inline">vim</strong> to run commands with "root."</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/>Exploiting vulnerable services and permissions</h2>
			<p><strong class="bold">Services</strong> offer the <a id="_idIndexMarker069"/>largest threat surface for attackers, given the variability <a id="_idIndexMarker070"/>and diversity of programs <a id="_idIndexMarker071"/>and services that can be found running on Windows and Linux systems. </p>
			<p>Attackers will typically aim to identify misconfigured or vulnerable services and programs that could facilitate the escalation of privileges. For example, on Linux systems, attackers will <a id="_idIndexMarker072"/>try to identify and exploit misconfigurations with <strong class="bold">cron jobs</strong> and leverage the functionality to execute arbitrary code or malicious binaries.</p>
			<p>Exploiting <a id="_idIndexMarker073"/>vulnerable or insecure services on Windows typically involves embedding a payload <a id="_idIndexMarker074"/>in a service with administrative privileges. When the service is executed, it executes a payload with the administrative privileges, therefore allowing the binary to execute commands with "root" privileges.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Insecure credentials</h2>
			<p>This technique involves searching for <strong class="bold">insecure credentials</strong> that have been stored on a system by <a id="_idIndexMarker075"/>users or by carrying out a process of cracking weak user credentials. Many users—and even system administrators—note down passwords <a id="_idIndexMarker076"/>in cleartext in documents, spreadsheets, and configuration files for various service accounts. These files can be located by running specialized search queries with various command-line utilities.</p>
			<p>An example of this is the use of the <strong class="source-inline">find</strong> command-line utility on Linux to locate files with specific extensions and filenames.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor028"/>Exploiting SUDO </h2>
			<p>Attackers will <a id="_idIndexMarker077"/>usually target users who have <strong class="bold">SUDO</strong> privileges. SUDO allows users to run commands as another user, typically the root user. </p>
			<p>SUDO privileges <a id="_idIndexMarker078"/>are usually configured manually by administrators, which leaves the door open to potential misconfigurations. For example, an <a id="_idIndexMarker079"/>administrator can assign SUDO permissions to a non-root user for certain command-line utilities (such as <strong class="source-inline">find</strong> or <strong class="source-inline">vim</strong>) that can run shell commands or arbitrary code. </p>
			<p>This can be leveraged by attackers to run arbitrary code or execute commands with "root" privileges.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">SUDO is a Linux command and permission set that allows users to run commands or programs with superuser or "root" privileges.</p>
			<p>These <a id="_idIndexMarker080"/>are just some of the <a id="_idIndexMarker081"/>privilege escalation attacks and techniques that can be used on both Windows and Linux systems. We will be taking a look at how to use these techniques in detail in the upcoming chapters.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor029"/>Summary</h1>
			<p>This chapter introduced you to the privilege escalation process, explained how privileges and user accounts are implemented in modern operating systems, and looked at the differences between privilege escalation on Windows and Linux systems. It also highlighted the most common privilege escalation techniques and explained how they can be exploited.</p>
			<p>You should now have a good understanding of the privilege escalation process, how permissions and privileges are implemented, and the various penetration testing techniques that are used on both Windows and Linux.</p>
			<p>In the next chapter, we'll get started with setting up our virtual environment and preparing our penetration-testing distribution. We will also look at the various tools and frameworks we will be utilizing to enhance and optimize the privilege escalation process.</p>
		</div>
	</div></body></html>