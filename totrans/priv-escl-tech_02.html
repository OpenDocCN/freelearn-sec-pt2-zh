<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer116">
			<h1 id="_idParaDest-55"><em class="italic"><a id="_idTextAnchor058"/>Chapter 4</em>: Performing Local Enumeration</h1>
			<p>Now that we have our initial foothold on the target system, we need to enumerate additional information from the target that will be vital and pivotal to the privilege escalation process. This information will be used to structure, plan, and coordinate our privilege escalation attacks successfully.</p>
			<p>Therefore, it is vitally important to learn how to enumerate information correctly and comprehensively from a target system in order to successfully escalate privileges. </p>
			<p>In this chapter, you will learn about the enumeration process, why it is important, and the various local enumeration techniques for Windows and Linux. You will then learn how to use automated enumeration tools to automate processes.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding the enumeration process</li>
				<li>Windows enumeration</li>
				<li>Linux enumeration</li>
			</ul>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor059"/>Technical requirements </h1>
			<p>To follow along with the demonstrations in this chapter, you will need to ensure that you meet the following technical requirements:</p>
			<ul>
				<li>Familiarity with Linux Terminal commands</li>
				<li>Familiarity with the Windows command line</li>
			</ul>
			<p>Check out the following link to see the Code in Action video:</p>
			<p><a href="https://bit.ly/39JFTjW">https://bit.ly/39JFTjW</a></p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor060"/>Understanding the enumeration process</h1>
			<p>Although you<a id="_idIndexMarker210"/> gained an initial foothold on a system in <a href="B17389_03_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 3</em></a>, <em class="italic">Gaining Access (Exploitation)</em>, you have little or no information regarding what operating system is running, what services are running, your privileges on the system, and what networks the target system is connected to. This leaves you blind and in no position to initiate a privilege escalation attack. This is where enumeration comes into play. </p>
			<p><strong class="bold">Enumeration</strong> is the process of extracting vital information such as operating system versions, usernames, network information, and installed programs from a target system. This information can then be used to identify potential flaws, misconfigurations, or vulnerabilities that can be exploited. </p>
			<p>The enumeration process can be analogized through the example of planning a heist, where reconnaissance and information gathering on the target is paramount. If insufficient information regarding the target is obtained, the heist will be marred with mistakes and will, in all probability, end up failing. However, if information regarding the target is diligently and comprehensively gathered, the heist will be efficient since all the relevant information has been gathered and analyzed for potential mistakes and issues. Therefore, it is vitally important to perform comprehensive enumeration on your target systems.</p>
			<p>Local enumeration involves actively gathering information from the target system after its <strong class="bold">initial exploitation</strong>. This information is then used to identify potential privilege escalation vectors through vulnerabilities or configurations.</p>
			<p>The local enumeration process is multi-faceted and can therefore be categorized based on the type of<a id="_idIndexMarker211"/> information being gathered:</p>
			<ul>
				<li>System enumeration </li>
				<li>User and group enumeration</li>
				<li>Network enumeration</li>
				<li>Password enumeration</li>
				<li>Firewall and antivirus enumeration</li>
			</ul>
			<p>This categorization will be useful in structuring and organizing the information we will be gathering. Local enumeration can be performed manually and automatically by using frameworks and scripts; however, it is always recommended to perform manual enumeration as it ensures the process is performed comprehensively and diligently.</p>
			<p>In the following sections, we will be exploring the various techniques and tools that can be used to perform local enumeration both manually and automatically on Windows and Linux.</p>
			<p>In this chapter, we will be using the following target virtual machines that we exploited in the previous chapter:</p>
			<ul>
				<li>Metasploitable3</li>
				<li>Windows 10</li>
				<li>Metasploitable2 </li>
				<li>Ubuntu 20.04</li>
			</ul>
			<p>The purpose of <a id="_idIndexMarker212"/>using multiple operating system versions is to demonstrate and highlight the variety of information that can be gathered based on the operating system's version and configuration. The techniques demonstrated in this chapter will work on most Windows releases and Linux distributions with a few exceptions, all of which will be highlighted.</p>
			<p>Now that we understand what enumeration is and its importance in the privilege escalation process, we can take a look at how to enumerate information from Windows systems.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor061"/>Windows enumeration</h1>
			<p>We will begin the<a id="_idIndexMarker213"/> enumeration process on Windows manually and follow the previously listed categories in our approach. To begin the local enumeration process, you will need to ensure that you have direct access to your target system in the form of a shell. If you have followed the examples demonstrated so far in this book, you should have a <strong class="source-inline">meterpreter</strong> session on your target systems.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor062"/>System enumeration</h2>
			<p>System <a id="_idIndexMarker214"/>enumeration is the process of enumerating core system information such as the operating system's version and service pack, the operating system's architecture, the system services that are running, and the installed patches and hotfixes. </p>
			<p>We can begin the process of system enumeration by following these steps:</p>
			<ol>
				<li>Most of the commands we will be running are native to the Windows command prompt, so they need to be run within a native shell session. If you already have one, you can skip this step. Alternatively, if you are running a <strong class="source-inline">meterpreter</strong> session, you will need to run the following command, as outlined in the following screenshot, to get a command prompt session:<p class="source-code"><strong class="bold">shell</strong></p><p>As shown in the following screenshot, you should get an active shell on the target system through the command prompt, and you should be able to run Windows-specific commands:</p><div id="_idContainer079" class="IMG---Figure"><img src="Images/B17389_04_001.jpg" alt="Figure 4.1 – Meterpreter command prompt&#13;&#10;" width="883" height="243"/></div><p class="figure-caption">Figure 4.1 – Meterpreter command prompt</p></li>
				<li>The first step is to enumerate operating system information. This can be done by running the <strong class="source-inline">systeminfo</strong> command and piping the output to the <strong class="source-inline">findstr </strong>utility to limit the output to the information that is essential. This can be done by running the following command:<p class="source-code"><strong class="bold">systeminfo | findstr /B /C:"OS Name" /C:"OS Version"</strong></p><p>As highlighted in the following screenshot, the command will output the operating system's name, version, and architecture. This information can be used in conjunction with automated vulnerability assessment tools to determine inherent privilege escalation vulnerabilities. It is also useful for sorting through exploits for a particular operating system architecture. The operating system version is also useful for finding kernel-based exploits for specific versions of an operating system.</p><p>This gives<a id="_idIndexMarker215"/> us enough information regarding the operating system to narrow down our approach regarding finding vulnerabilities:</p><div id="_idContainer080" class="IMG---Figure"><img src="Images/B17389_04_002.jpg" alt="Figure 4.2 – systeminfo command output&#13;&#10;" width="1068" height="177"/></div><p class="figure-caption">Figure 4.2 – systeminfo command output</p></li>
				<li>We can also use the <strong class="source-inline">systeminfo</strong> command to determine what Windows hotfixes or patches have been installed. This can be done by running the following command:<p class="source-code"><strong class="bold">systeminfo</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer081" class="IMG---Figure"><img src="Images/B17389_04_003.jpg" alt="Figure 4.3 – Hotfixes installed&#13;&#10;" width="407" height="73"/></div><p class="figure-caption">Figure 4.3 – Hotfixes installed</p><p>As highlighted in the preceding screenshot, the output lists the total number of hotfixes that have been installed and their relevant HotFix IDs. This information is useful for finetuning your approach in terms of vulnerabilities in the operating system that may have already been patched.</p><p class="callout-heading">Note</p><p class="callout">The default output of the <strong class="source-inline">systeminfo</strong> command is detailed and provides you with a complete overview of the operating system.</p></li>
				<li>You can also determine the hotfixes and patches that have been installed on a system by running the following command:<p class="source-code"><strong class="bold">wmic qfe</strong></p><p>The <a id="_idIndexMarker216"/>output of the preceding command is shown in the following screenshot:</p><div id="_idContainer082" class="IMG---Figure"><img src="Images/B17389_04_004.jpg" alt="Figure 4.4 – Installed updates&#13;&#10;" width="1650" height="205"/></div><p class="figure-caption">Figure 4.4 – Installed updates</p><p>As illustrated in the preceding screenshot, the command outputs the updates or patches that have been installed and provides additional information, such as the date the patches were installed and the user that installed them.</p><p>The <strong class="bold">HotFixID</strong> can <a id="_idIndexMarker217"/>be used to determine potential vulnerabilities and exploits for specific hotfixes.</p><p>We can also run the command on a Windows 10 system to determine the patches that have been installed and how recently this happened, as shown in the following screenshot:</p><div id="_idContainer083" class="IMG---Figure"><img src="Images/B17389_04_005.jpg" alt="Figure 4.5 – Windows 10 installed updates" width="1265" height="509"/></div><p class="figure-caption">Figure 4.5 – Windows 10 installed updates</p></li>
				<li>The <a id="_idIndexMarker218"/>next piece of information we must enumerate is the operating system's hostname. This can be done by running the following command:<p class="source-code"><strong class="bold">hostname</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer084" class="IMG---Figure"><img src="Images/B17389_04_006.jpg" alt="Figure 4.6 – Hostname" width="338" height="129"/></div><p class="figure-caption">Figure 4.6 – Hostname</p><p>The hostname is used to identify systems on a network and may shed some light on the role of the system or the person the system belongs to.</p></li>
				<li>Another important piece of information to enumerate is the drives attached to the system. We can do this by running the following command:<p class="source-code"><strong class="bold">wmic logicaldisk get caption</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer085" class="IMG---Figure"><img src="Images/B17389_04_007.jpg" alt="Figure 4.7 – Logical disks&#13;&#10;" width="581" height="144"/></div><p class="figure-caption">Figure 4.7 – Logical disks</p><p>As shown in the preceding screenshot, the command will output the list of attached<a id="_idIndexMarker219"/> drives and their identifier. In this case, the only disk that's attached is the system drive labeled <strong class="source-inline">C:</strong>.</p></li>
				<li>It is also important to enumerate information regarding the processes that are currently running. This can be done by running the following command:<p class="source-code"><strong class="bold">tasklist /SVC</strong></p><p>The output of the preceding command is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="Images/B17389_04_008.jpg" alt="Figure 4.8 – Running processes" width="888" height="551"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – Running processes</p>
			<p>As shown in the preceding screenshot, the command will output a list of processes that are running and their associated services. It also displays the process ID, which can be useful for identifying a particular process. </p>
			<p>Now that <a id="_idIndexMarker220"/>we have an understanding of what the target system is running, we can start identifying the users on the target system.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor063"/>User and group enumeration</h2>
			<p>User<a id="_idIndexMarker221"/> enumeration is the process of <a id="_idIndexMarker222"/>identifying the user we are currently utilizing and the user accounts that are on the target system. This information is useful as it tells us whether we have administrative privileges. It also helps us determine and identify potential user accounts that we can utilize to elevate our privileges.</p>
			<p>The user enumeration process on Windows is fairly straightforward and can be performed by following these steps:</p>
			<ol>
				<li value="1">First, we need to determine the user that we are currently using. This can be done by running the following command:<p class="source-code"><strong class="bold">whoami</strong></p><p>If you have administrative privileges, your username should be <strong class="source-inline">nt authority</strong>, as shown in the following screenshot:</p><div id="_idContainer087" class="IMG---Figure"><img src="Images/B17389_04_009.jpg" alt="Figure 4.9 - whoami&#13;&#10;" width="313" height="78"/></div><p class="figure-caption">Figure 4.9 - whoami</p></li>
				<li>We can also determine our privileges by running the following command:<p class="source-code"><strong class="bold">whoami /priv</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer088" class="IMG---Figure"><img src="Images/B17389_04_010.jpg" alt="Figure 4.10 – whoami privileges&#13;&#10;" width="969" height="364"/></div><p class="figure-caption">Figure 4.10 – whoami privileges</p><p>As shown<a id="_idIndexMarker223"/> in the preceding <a id="_idIndexMarker224"/>screenshot, this will output the privileges that have been assigned to our account and provides a brief description of each privilege, along with their current states. We looked at privileges briefly in <a href="B17389_01_Final_PG_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Introduction to Privilege Escalation</em>, where we explained access tokens. The importance of privileges will be highlighted later in this book, when we look at token impersonation attacks.</p></li>
				<li>To determine the groups that our account is part of, we can run the following command:<p class="source-code"><strong class="bold">whoami /groups</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer089" class="IMG---Figure"><img src="Images/B17389_04_011.jpg" alt="Figure 4.11 – whoami groups&#13;&#10;" width="1198" height="448"/></div><p class="figure-caption">Figure 4.11 – whoami groups</p></li>
				<li>We can also enumerate the user accounts that are active on the system by running the following command:<p class="source-code"><strong class="bold">net user</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer090" class="IMG---Figure"><img src="Images/B17389_04_012.jpg" alt="Figure 4.12 – net user" width="640" height="300"/></div><p class="figure-caption">Figure 4.12 – net user</p><p>As shown <a id="_idIndexMarker225"/>in the preceding<a id="_idIndexMarker226"/> screenshot, the command will output a list of all the users on the system. This provides helpful information regarding what accounts we can laterally escalate our privileges to. We can also obtain additional information about a particular user by running the following command:</p><p class="source-code"><strong class="bold">net user &lt;username&gt;</strong></p><p>This can also help us identify accounts that are part of the administrative group and have admin privileges, as shown in the following screenshot:</p><div id="_idContainer091" class="IMG---Figure"><img src="Images/B17389_04_013.jpg" alt="Figure 4.13 – User enumeration&#13;&#10;" width="832" height="576"/></div><p class="figure-caption">Figure 4.13 – User enumeration</p></li>
				<li>We<a id="_idIndexMarker227"/> can <a id="_idIndexMarker228"/>also determine the users that are part of the administrative group by running the following command:<p class="source-code"><strong class="bold">net localgroup administrators</strong></p><p>The output of the preceding command is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="Images/B17389_04_014.jpg" alt="Figure 4.14 – Net localgroup" width="901" height="262"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14 – Net localgroup</p>
			<p>As shown in the preceding screenshot, the command will outline the users that are part of the administrative group. This gives us a clear picture of the accounts we can target to obtain administrative privileges. </p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor064"/>Network enumeration</h2>
			<p>Network enumeration<a id="_idIndexMarker229"/> is the process of obtaining all the relevant network information from a target system with the aim of determining its IP address, DNS server, default gateway, and domain controller, if any. This information can be used to map out the target network and stage pivoting attacks. Let's take a look:</p>
			<ol>
				<li value="1">The first step involves enumerating the target network interfaces and their details. This can be done by running the following command:<p class="source-code"><strong class="bold">ipconfig /all</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer093" class="IMG---Figure"><img src="Images/B17389_04_015.jpg" alt="Figure 4.15 – ipconfig&#13;&#10;" width="807" height="318"/></div><p class="figure-caption">Figure 4.15 – ipconfig</p><p>As shown in the preceding screenshot, this will display all the relevant network information regarding a particular NIC: its IP address, DNS server, and default gateway.</p></li>
				<li>The next step is to analyze the routing table. This can be done by running the following command:<p class="source-code"><strong class="bold">route print</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer094" class="IMG---Figure"><img src="Images/B17389_04_016.jpg" alt="Figure 4.16 – Routing table&#13;&#10;" width="767" height="405"/></div><p class="figure-caption">Figure 4.16 – Routing table</p></li>
				<li>We also <a id="_idIndexMarker230"/>need to determine what services we have running and their respective ports. This can be done by running the <strong class="source-inline">netstat</strong> command with the following arguments:<p class="source-code"><strong class="bold">netstat -ano</strong></p><p>The output of the preceding command is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="Images/B17389_04_017.jpg" alt="Figure 4.17 – Netstat active connections&#13;&#10;" width="690" height="355"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.17 – Netstat active connections</p>
			<p>As shown in the preceding screenshot, the command will display all the active connections, along with their<a id="_idIndexMarker231"/> respective ports and <strong class="bold">process IDs</strong> (<strong class="bold">PIDs</strong>). </p>
			<p>This command can also be used to identify active connections from other hosts, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="Images/B17389_04_018.jpg" alt="Figure 4.18 – Netstat established connections&#13;&#10;" width="669" height="26"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.18 – Netstat established connections</p>
			<p>This information<a id="_idIndexMarker232"/> is important as it may also reveal internal services that are running that were previously undetected during the initial footprinting phase and are running locally.</p>
			<p>Now that we have enumerated the networking information from the target, we will learn how to find and enumerate passwords.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor065"/>Password enumeration</h2>
			<p>Password <a id="_idIndexMarker233"/>enumeration is the process of finding and locating passwords stored locally in the form of stored user passwords in clear text, configuration files with passwords, passwords stored in the Windows registry, and<a id="_idIndexMarker234"/> Windows hashes stored in the <strong class="bold">Security Account Manager</strong> (<strong class="bold">SAM</strong>) database.</p>
			<p>We will explore password enumeration in greater detail when we explore automated tools, since the process of manually enumerating passwords from the registry and SAM database can be time consuming.</p>
			<p>In this section, we will utilize manual techniques such as string matching. Let's get started:</p>
			<ol>
				<li value="1">We can utilize the <strong class="source-inline">findstr</strong> utility to locate specific strings in files. For example, we can run the following command to locate the <strong class="source-inline">password</strong> string in files with commonly used file extensions:<p class="source-code"><strong class="bold">findstr /si password *.doc *.txt *.ini *.config</strong></p><p>This can be useful for finding cleartext passwords stored by users or administrators that may contain passwords for other accounts or services.</p></li>
				<li>We can<a id="_idIndexMarker235"/> also <a id="_idIndexMarker236"/>search for specific strings pertaining to services such as <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) and <strong class="bold">File Transfer Protocol</strong> (<strong class="bold">FTP</strong>). This can be done by running the following command:<p class="source-code"><strong class="bold">dir /s *pass* == *cred* == *ssh* == *.config*</strong></p></li>
				<li>We can search for passwords within the registry for specific programs and software by running the following query:<p class="source-code"><strong class="bold">reg query HKLM /f password /t REG_SZ /s</strong></p><p>This will display any entries that contain the <strong class="source-inline">password</strong> string within the <strong class="source-inline">HKEY_LOCAL_MACHINE</strong> registry, as shown in the following screenshot. You can also <a id="_idIndexMarker237"/>run the same query for the <strong class="source-inline">HKEY_CURRENT_USER</strong> registry. This can be done by running the following command:</p><p class="source-code"><strong class="bold">reg query HKCU /f password /t REG_SZ /s</strong></p><p>The output of the preceding command is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="Images/B17389_04_019.jpg" alt="Figure 4.19 – Password enumeration in the Windows Registry" width="1187" height="346"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.19 – Password enumeration in the Windows Registry</p>
			<p>We can also search for passwords in configuration files and session information for specific programs such as PuTTY or VNC. This can be done by running the following command and specifying the program's default registry directory:</p>
			<p class="source-code">reg query "HKCU\Software\SimonTatham\PuTTY\Sessions\&lt;User&gt;"</p>
			<p>In this case, the query will display the PuTTY session details for the user that was specified within the query.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The user Simon Tatham highlighted in the <strong class="source-inline">HKCU\Software\SimonTatham\PuTTY\Sessions\&lt;User&gt;</strong> registry directory references the developer of the PuTTY program. </p>
			<p>Now that <a id="_idIndexMarker238"/>we understand how to use manual querying techniques to enumerate passwords from Windows, we need to identify and map out the security features that are currently active on the system.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor066"/>Firewall and antivirus enumeration</h2>
			<p>To successfully <a id="_idIndexMarker239"/>elevate our <a id="_idIndexMarker240"/>privileges and maintain persistence on a system, we need to understand the security measures and systems that are in place that could hinder the process. Two of the most common security deterrents found on Windows systems are Windows Firewall and Windows Defender, though other third-party antivirus solutions may help. </p>
			<p>The ability to detect and evade firewalls and antivirus solutions is important during a penetration test. This is because the privilege escalation process involves actively engaging with the target and transferring files to and from the target system. Firewalls and antivirus solutions can hinder the process and can alert a security team or administrator about a potential breach. For this reason, it is important to enumerate information regarding the firewall's status and rules, as well as the antivirus solution in place. Let's take a look:</p>
			<ol>
				<li value="1">First, you will need to identify the status of Windows Defender before copying over any files. This can be done by running using the service control command:<p class="source-code"><strong class="bold">sc query windefend</strong></p><p>Given the intentionally vulnerable design of the Metasploitable3 virtual machine, Windows Defender has not been enabled, so we must render the system vulnerable and unprotected, as shown in the following screenshot:</p><div id="_idContainer098" class="IMG---Figure"><img src="Images/B17389_04_020.jpg" alt="Figure 4.20 – Windows Defender disabled&#13;&#10;" width="612" height="140"/></div><p class="figure-caption">Figure 4.20 – Windows Defender disabled</p><p>If Windows <a id="_idIndexMarker241"/>Defender<a id="_idIndexMarker242"/> is enabled and active, you should get an output similar to the following:</p><div id="_idContainer099" class="IMG---Figure"><img src="Images/B17389_04_021.jpg" alt="Figure 4.21 – Windows Defender enabled and running" width="602" height="193"/></div><p class="figure-caption">Figure 4.21 – Windows Defender enabled and running</p></li>
				<li>To identify third-party antivirus solutions, you can list the services that are running on the system. This can be done by running the following command:<p class="source-code"><strong class="bold">sc queryex type=service</strong></p><p>If a third-party antivirus solution is running, you should be able to identify it by analyzing the service name, as shown in the following screenshot. Here, I have been able to detect a second third-party antivirus program running in tandem with Windows Defender:</p><div id="_idContainer100" class="IMG---Figure"><img src="Images/B17389_04_022.jpg" alt="Figure 4.22 – Third-party A/V" width="634" height="420"/></div><p class="figure-caption">Figure 4.22 – Third-party A/V</p></li>
				<li>We<a id="_idIndexMarker243"/> also<a id="_idIndexMarker244"/> need to enumerate information regarding the firewall's status and configuration. This will help us detect the ports that are open and can be utilized for further attacks. This can be done by running the following command:<p class="source-code"><strong class="bold">netsh firewall show state</strong></p><p>The output of the preceding command is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="Images/B17389_04_023.jpg" alt="Figure 4.23 – Firewall status&#13;&#10;" width="543" height="595"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.23 – Firewall status</p>
			<p>As shown in the preceding screenshot, the command will output the firewall's operational mode, profile, and open ports. This gives us a clear idea of what we can and cannot do from a networking perspective.</p>
			<p>We should<a id="_idIndexMarker245"/> now have a clear idea <a id="_idIndexMarker246"/>of what our target system is running and how it is configured. Now, let's learn how to use various automation tools to simplify the enumeration process.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor067"/>Automated enumeration tools</h2>
			<p>Automated<a id="_idIndexMarker247"/> enumeration<a id="_idIndexMarker248"/> offers a much more targeted and time-efficient approach to gathering information from a target system and, consequently, making sense of it. The primary objective behind using automated enumeration tools is the ability to make sense of, as well as contextualize, the information that's been gathered and provide recommendations based on it.</p>
			<p>Many automated enumeration tools for Windows exist. However, we will only be focusing on the tools that have a high probability of working and do not require any additional <a id="_idIndexMarker249"/>dependencies or access to specific utilities. </p>
			<h3>Local Exploit Suggester</h3>
			<p>The Local<a id="_idIndexMarker250"/> Exploit Suggester<a id="_idIndexMarker251"/> is a post-exploitation module for Metasploit that is used to scan a target for potential exploits based on operating system information. It automates the process of enumerating the system information and provides exploit recommendations based on the operating system's version and installed patches. Let's take a look:</p>
			<ol>
				<li value="1">To use the module, you will need to have <strong class="source-inline">meterpreter</strong> access on a target system, after which you will need to move the <strong class="source-inline">meterpreter</strong> session to the background and load the <strong class="source-inline">local_exploit_suggester</strong> module. This can be done by running the following command:<p class="source-code"><strong class="bold">use post/multi/recon/local_exploit_suggester</strong></p></li>
				<li>Now, you need to configure the module options. The only option that we need to set is the session number, as shown in the following screenshot. This can be done by running the following command:<p class="source-code"><strong class="bold">set SESSION &lt;Session Number&gt;</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer102" class="IMG---Figure"><img src="Images/B17389_04_024.jpg" alt="Figure 4.24 – Local Exploit Suggester" width="1477" height="391"/></div><p class="figure-caption">Figure 4.24 – Local Exploit Suggester</p></li>
				<li>After configuring the options, you can run the module. At this point, the module will begin the enumeration process and output the results after a few minutes, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="Images/B17389_04_025.jpg" alt="Figure 4.25 – Local Exploit Suggester results" width="1645" height="233"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.25 – Local Exploit Suggester results</p>
			<p>The output from the module will display the various exploit modules, most of which are kernel exploits <a id="_idIndexMarker252"/>that can be used<a id="_idIndexMarker253"/> against the target. We will explore this in the next section.</p>
			<h3>Windows Exploit Suggester</h3>
			<p>Windows<a id="_idIndexMarker254"/> Exploit <a id="_idIndexMarker255"/>Suggester is an open source utility developed in Python that allows you to scan for potential vulnerabilities in Windows operating systems. It also provides their corresponding exploits or exploit modules.</p>
			<p>It works by comparing the Windows patch levels against the Microsoft vulnerability database to detect vulnerabilities. It does this by identifying any missing patches on the system.</p>
			<p>It does not need to be run locally on the target system and only requires the output from the <strong class="source-inline">systeminfo</strong> command on the target. Let's get started:</p>
			<ol>
				<li value="1">The first step involves cloning the repository at <a href="https://github.com/AonCyberLabs/Windows-Exploit-Suggester">https://github.com/AonCyberLabs/Windows-Exploit-Suggester</a> onto our Kali VM. This can be done by running the following command:<p class="source-code"><strong class="bold">git clone https://github.com/AonCyberLabs/Windows-Exploit-Suggester.git</strong></p><p>The tool requires Python2 to work as it utilizes various Python2 modules.</p><p class="callout-heading">Note</p><p class="callout">Python2 is currently deprecated as of January 1, 2020. This means that you may encounter issues with dependencies for older tools and frameworks.</p></li>
				<li>After cloning the repository, you will need to install the required dependencies. This can be done by running the following commands:<p class="source-code"><strong class="bold">sudo apt-get install python-xlrd </strong></p><p class="source-code"><strong class="bold">pip install xlrd --upgrade</strong></p></li>
				<li>After installing the dependencies, you will need to update the database by running the script with the following flag:<p class="source-code"><strong class="bold">./windows-exploit-suggester.py –update</strong></p><p>The<a id="_idIndexMarker256"/> output is<a id="_idIndexMarker257"/> shown in the following screenshot:</p><div id="_idContainer104" class="IMG---Figure"><img src="Images/B17389_04_026.jpg" alt="Figure 4.26 – Windows Exploit Suggester update" width="1039" height="122"/></div><p class="figure-caption">Figure 4.26 – Windows Exploit Suggester update</p><p>Take note of the database's filename, as highlighted in the following screenshot, as it will be used in the scanning phase:</p><div id="_idContainer105" class="IMG---Figure"><img src="Images/B17389_04_027.jpg" alt="Figure 4.27 – Windows Exploit Suggester database file" width="731" height="252"/></div><p class="figure-caption">Figure 4.27 – Windows Exploit Suggester database file</p></li>
				<li>The next step involves enumerating the target system information by running the <strong class="source-inline">systeminfo</strong> command, after which you will need to copy and paste the output of the command to a <strong class="source-inline">.txt</strong> file.</li>
				<li>After saving the output of the <strong class="source-inline">systeminfo</strong> command to a <strong class="source-inline">.txt</strong> file, you can run the script to check for vulnerabilities, like so:<p class="source-code"><strong class="bold">./windows-exploit-suggester.py --database &lt;database-file&gt;.xlsx --systeminfo &lt;systeminfo-output&gt;.txt</strong></p><p>The <a id="_idIndexMarker258"/>output<a id="_idIndexMarker259"/> of this command is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="Images/B17389_04_028.jpg" alt="Figure 4.28 – Windows Exploit suggester output&#13;&#10;" width="1650" height="418"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.28 – Windows Exploit suggester output</p>
			<p>As shown<a id="_idIndexMarker260"/> in the preceding screenshot, the script will perform a scan and output a list of all the potential vulnerabilities and relevant information, such as the POC reference and exploit code or modules available on <strong class="source-inline">exploit-db</strong> or GitHub.</p>
			<p>This information will be useful in the next chapter, when we explore kernel exploitation on Windows.</p>
			<h3>Other enumeration tools</h3>
			<p>As we mentioned <a id="_idIndexMarker261"/>earlier in this section, many automated enumeration tools exist and can provide additional functionality and information, most of which we will explore later in this book.</p>
			<p>The following is a list of useful enumeration tools and frameworks for Windows:</p>
			<ul>
				<li><strong class="bold">Windows Privilege Escalation Awesome Script (winPEAS)</strong>: <a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS/winPEASexe">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS/winPEASexe</a></li>
				<li><strong class="bold">Sherlock</strong>: <a href="https://github.com/rasta-mouse/Sherlock">https://github.com/rasta-mouse/Sherlock</a></li>
				<li><strong class="bold">Just Another Windows Enumeration Script</strong> (<strong class="bold">JAWS</strong>): <a href="https://github.com/411Hall/JAWS">https://github.com/411Hall/JAWS</a></li>
				<li><strong class="bold">Watson</strong>: <a href="https://github.com/rasta-mouse/Watson">https://github.com/rasta-mouse/Watson</a></li>
			</ul>
			<p>Now<a id="_idIndexMarker262"/> that we <a id="_idIndexMarker263"/>know <a id="_idIndexMarker264"/>how <a id="_idIndexMarker265"/>to perform<a id="_idIndexMarker266"/> local enumeration on Windows, we will learn how to perform local enumeration on Linux.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor068"/>Linux enumeration</h1>
			<p>Local enumeration on <a id="_idIndexMarker267"/>Linux is similar to Windows and involves using manual techniques and tools to enumerate important information. In this section, we will explore a few automated tools that help simplify and streamline the enumeration process.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Package managers will vary based on the Linux distribution in question. This will be pointed out and highlighted in the following sections. </p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor069"/>System enumeration</h2>
			<p>System enumeration<a id="_idIndexMarker268"/> is the process of enumerating core system information such as the operating system's version, kernel version, operating system architecture, and the services that are running. </p>
			<p>We can perform system enumeration by following these steps:</p>
			<ol>
				<li value="1">The first piece of information we will need to enumerate is the operating system's information. This can be done by running the following command:<p class="source-code"><strong class="bold">cat /etc/*-release</strong></p><p>You can also use the <strong class="bold">Linux Standard Base</strong> (<strong class="bold">LSB</strong>) information. This can be done by running the following command:</p><p class="source-code"><strong class="bold">lsb_release -a</strong></p><p>If these commands do not work, you can use the hostname systemd utility by running the following command:</p><p class="source-code"><strong class="bold">hostnamectl</strong></p></li>
				<li>You will also<a id="_idIndexMarker269"/> need the kernel version and operating system architecture. This will be useful in determining vulnerabilities and finding kernel exploits. This can be done by running the following command:<p class="source-code"><strong class="bold">uname -a</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer107" class="IMG---Figure"><img src="Images/B17389_04_029.jpg" alt="Figure 4.29 – Linux kernel version" width="1064" height="105"/></div><p class="figure-caption">Figure 4.29 – Linux kernel version</p><p>As shown in the preceding screenshot, the command will output the kernel version and system architecture. </p></li>
				<li>You will also need to identify the processes that are running as root. This is useful as you can utilize these processes to execute arbitrary commands as root. This can be done by running the following command:<p class="source-code"><strong class="bold">ps aux | grep root</strong></p><p>As shown in the following screenshot, this will list all the processes running as root:</p><div id="_idContainer108" class="IMG---Figure"><img src="Images/B17389_04_030.jpg" alt="Figure 4.30 – Linux services running" width="1359" height="463"/></div><p class="figure-caption">Figure 4.30 – Linux services running</p></li>
				<li>Another <a id="_idIndexMarker270"/>potential privilege escalation access vector on Linux is any programs and software that have been installed. We can determine the software that's been installed on the system by listing the content of the following directories:<p>a) <strong class="source-inline">/usr/local</strong></p><p>b) <strong class="source-inline">/usr/local/bin</strong></p><p>c) <strong class="source-inline">/opt/</strong></p><p>d) <strong class="source-inline">/var</strong></p><p>e) <strong class="source-inline">/usr/src</strong></p><p>You can list the installed packages on Debian systems by running the following command:</p><p class="source-code"><strong class="bold">dpkg -l</strong></p><p>If the target is running RHEL or Fedora, you can list the installed software by running the following command:</p><p class="source-code"><strong class="bold">rpm -qa</strong></p><p>Now that we have enumerated information regarding the operating system's version and kernel version, we will learn how to enumerate user and group information on Linux.</p></li>
				<li>We can also enumerate information from cron to determine what cron jobs are running and if they can be leveraged to execute commands or binaries. This can be done by<a id="_idIndexMarker271"/> running the following commands:<p class="source-code"><strong class="bold">crontab -l </strong></p><p class="source-code"><strong class="bold">ls -al /var/spool/cron</strong></p><p class="source-code"><strong class="bold">ls -al /etc/ | grep cron</strong></p><p class="source-code"><strong class="bold">ls -al /etc/cron*</strong></p><p class="source-code"><strong class="bold">cat /etc/cron*</strong></p><p class="source-code"><strong class="bold">cat /etc/at.allow</strong></p><p class="source-code"><strong class="bold">cat /etc/at.deny</strong></p><p class="source-code"><strong class="bold">cat /etc/cron.allow</strong></p><p class="source-code"><strong class="bold">cat /etc/cron.deny</strong></p><p class="source-code"><strong class="bold">cat /etc/crontab</strong></p><p class="source-code"><strong class="bold">cat /etc/anacrontab</strong></p><p class="source-code"><strong class="bold">cat /var/spool/cron/crontabs/root</strong></p></li>
			</ol>
			<p>Now that we have a clear picture of what is running on our target system, we can begin enumerating users and groups.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor070"/>User and group enumeration</h2>
			<p>User<a id="_idIndexMarker272"/> enumeration is the process of identifying <a id="_idIndexMarker273"/>the user we are currently utilizing and the user accounts that are on the target system. This information is useful as it tells us whether we have administrative privileges. It also helps us determine and identify potential user accounts that we can utilize to elevate our privileges.</p>
			<p>The user enumeration process on Linux is fairly straightforward and can be performed by following these steps:</p>
			<ol>
				<li value="1">First, we need to determine the user that we are currently using. This can be done by running the following command:<p class="source-code"><strong class="bold">whoami</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer109" class="IMG---Figure"><img src="Images/B17389_04_031.jpg" alt="Figure 4.31 – whoami Linux" width="353" height="104"/></div><p class="figure-caption">Figure 4.31 – whoami Linux</p><p>If you have <a id="_idIndexMarker274"/>administrative privileges, your<a id="_idIndexMarker275"/> username should be <strong class="source-inline">root</strong>, as shown in the preceding screenshot.</p><p>You can also enumerate the other user accounts on the system by running the following command:</p><p class="source-code"><strong class="bold">cat /etc/passwd</strong></p></li>
				<li>To determine the groups that our account is part of, run the following command:<p class="source-code"><strong class="bold">groups &lt;username&gt;</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer110" class="IMG---Figure"><img src="Images/B17389_04_032.jpg" alt="Figure 4.32 – Linux groups&#13;&#10;" width="1049" height="102"/></div><p class="figure-caption">Figure 4.32 – Linux groups</p><p>You can also list the groups on the system by running the following command:</p><p class="source-code"><strong class="bold">cat /etc/group</strong></p></li>
				<li>You can search for SUID binaries that can be exploited and run with root privileges to run arbitrary commands. This can be done by running the following command:<p class="source-code"><strong class="bold">find / -perm -u=s -type f 2&gt;/dev/null</strong></p></li>
			</ol>
			<p>Now, let's<a id="_idIndexMarker276"/> learn how to enumerate network <a id="_idIndexMarker277"/>information from the target system.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor071"/>Network enumeration</h2>
			<p>Network<a id="_idIndexMarker278"/> enumeration is the process of obtaining all the relevant network information from a target system with the aim of determining its IP address, DNS server, default gateway, and domain controller, if any. This information can be used to map out the target network and stage pivoting attacks. Let's take a look:</p>
			<ol>
				<li value="1">The first step involves enumerating the target network interfaces and their details. This can be done by running the following command:<p class="source-code"><strong class="bold">ifconfig</strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer111" class="IMG---Figure"><img src="Images/B17389_04_033.jpg" alt="Figure 4.33 – ifconfig" width="844" height="531"/></div><p class="figure-caption">Figure 4.33 – ifconfig</p></li>
				<li>The next<a id="_idIndexMarker279"/> step is analyzing the routing table. This can be done by running the following command:<p class="source-code"><strong class="bold">route </strong></p><p>The output of the preceding command is as follows:</p><div id="_idContainer112" class="IMG---Figure"><img src="Images/B17389_04_034.jpg" alt="Figure 4.34 – Linux routing table&#13;&#10;" width="885" height="171"/></div><p class="figure-caption">Figure 4.34 – Linux routing table</p></li>
				<li>We also need to determine what services we have running and their respective ports. This can be done by running the <strong class="source-inline">netstat</strong> command with the following arguments:<p class="source-code"><strong class="bold">netstat -ant</strong></p><p>The output of the preceding command is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="Images/B17389_04_035.jpg" alt="Figure 4.35 – Netstat active connections" width="949" height="696"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.35 – Netstat active connections</p>
			<p>As shown in the preceding screenshot, the command will display all the active connections and their respective ports.</p>
			<p>This information <a id="_idIndexMarker280"/>is important as it may also reveal internal services that are running locally that previously went undetected during the initial footprinting phase.</p>
			<p>We should now have a clear idea of what our target system is running and how it is configured. Now, let's learn how to use various automation tools that will help simplify the enumeration process.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor072"/>Automated enumeration tools</h2>
			<p>Many<a id="_idIndexMarker281"/> automated enumeration tools for Linux exist. This section will focus on the enumeration tools that will provide us with meaningful and actionable information.</p>
			<h3>LinEnum</h3>
			<p>LinEnum is<a id="_idIndexMarker282"/> a<a id="_idIndexMarker283"/> bash script that automates the local enumeration process on Linux and provides comprehensive information to help specify the information required, as well as the ability to generate reports.</p>
			<p>You can learn more about the script at <a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a>. Let's get started:</p>
			<ol>
				<li value="1">To use the tool, we will need to download the bash script from GitHub and transfer it over to our target. If the target has internet access, we can download the script directly by running the following command:<p class="source-code"><strong class="bold">wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh</strong></p></li>
				<li>If the target prevents any incoming connections, we can upload the script from our local system to<a id="_idIndexMarker284"/> the target through <strong class="source-inline">meterpreter</strong>, as shown in the following <a id="_idIndexMarker285"/>screenshot:<div id="_idContainer114" class="IMG---Figure"><img src="Images/B17389_04_036.jpg" alt="Figure 4.36 – LinEnum download" width="1041" height="412"/></div><p class="figure-caption">Figure 4.36 – LinEnum download</p></li>
				<li>We can then execute the script with the following arguments:<p class="source-code"><strong class="bold">./LinEnum.sh -t -r &lt;report-name&gt;</strong></p><p>This will enumerate all the relevant information and will also display potentially useful vulnerabilities that can be exploited, as shown in the following screenshot:</p><div id="_idContainer115" class="IMG---Figure"><img src="Images/B17389_04_037.jpg" alt="Figure 4.37 – LinEnum results" width="811" height="673"/></div><p class="figure-caption">Figure 4.37 – LinEnum results</p></li>
				<li>We can <a id="_idIndexMarker286"/>also use the<a id="_idIndexMarker287"/> keyword functionality to enumerate passwords on the system. This can be done by running the following command:<p class="source-code"><strong class="bold">./LinEnum.sh -k password</strong></p></li>
			</ol>
			<p>Now, let's learn how to enumerate potential vulnerabilities on the target system.</p>
			<h3>Linux Exploit Suggester</h3>
			<p>Linux <a id="_idIndexMarker288"/>Exploit <a id="_idIndexMarker289"/>Suggester is an open source shell script that allows you to scan for potential kernel vulnerabilities on Linux. It provides their corresponding exploits or exploit modules. Let's get started:</p>
			<ol>
				<li value="1">The script needs to be run locally on the target system. First, we need to download the script on to the target system. This can be done with <strong class="source-inline">wget</strong>, like so:<p class="source-code"><strong class="bold">wget https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh -O les.sh</strong></p></li>
				<li>After downloading the script onto the target, you need to ensure the script has executable permissions. This can be done by running the following command:<p class="source-code"><strong class="bold">chmod +x les.sh</strong></p></li>
				<li>You can now <a id="_idIndexMarker290"/>run<a id="_idIndexMarker291"/> the script to begin the scanning process, after which the script will output a list of potential vulnerabilities and their corresponding POCs and exploits.</li>
			</ol>
			<p>Now that you have a grip on how to use various enumeration tools, let's explore some of the other automated enumeration tools that can be used.</p>
			<h3>Other enumeration tools</h3>
			<p>As we<a id="_idIndexMarker292"/> mentioned earlier in this section, many automated enumeration tools exist and can provide additional functionality and information, most of which we will explore later in this book.</p>
			<p>The following is a list of useful enumeration tools and frameworks for Linux:</p>
			<ul>
				<li>Linux Smart Enumeration: <a href="https://github.com/diego-treitos/linux-smart-enumeration">https://github.com/diego-treitos/linux-smart-enumeration</a></li>
				<li>Linux Priv Checker – <strong class="source-inline">linuxprivchecker.py</strong>: A Linux Privilege Escalation Check Script</li>
				<li>Privilege Escalation Scripts: <a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite</a></li>
				<li>LinEnum: <a href="https://github.com/rebootuser/LinEnum">https://github.com/rebootuser/LinEnum</a></li>
			</ul>
			<p>With that, we've learned how to enumerate information from Windows and Linux systems. Now, we<a id="_idIndexMarker293"/> are ready to start using this information to stage privilege escalation attacks.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor073"/>Summary</h1>
			<p>In this chapter, we started by learning about the enumeration process. We then looked at how to perform local enumeration manually and automatically on Windows. Finally, we learned how to perform local enumeration on Linux.</p>
			<p>Now that we have learned how to perform local enumeration on Windows and Linux, we can begin the privilege escalation process.</p>
			<p>In the next chapter, we will begin the privilege escalation process on Windows by using kernel exploits.</p>
		</div>
	</div></body></html>