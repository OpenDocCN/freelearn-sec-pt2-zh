<html><head></head><body>
		<div id="_idContainer040">
			<h1 class="chapter-number" id="_idParaDest-17"><a id="_idTextAnchor016"/>1</h1>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Getting Started with PowerShell</h1>
			<p>This introductory chapter will take a look at the fundamentals of working with PowerShell. It is meant as a basic primer on PowerShell for cybersecurity and acts as an introduction to <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) and how to get started when working <span class="No-Break">with PowerShell.</span></p>
			<p>This chapter complements <a href="B16679_02_Final_PD.xhtml#_idTextAnchor034"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">PowerShell Scripting Fundamentals</em>, in which we will dive deeper into the scripting part. Both chapters should help you to get started and act as a reference when working with <span class="No-Break">later chapters.</span></p>
			<p>You will learn the basics of what PowerShell is, its history, and why it has gained more importance in the last few years when it comes <span class="No-Break">to cybersecurity.</span></p>
			<p>You will get an overview of the editors and how to help yourself using existing functionalities. In this chapter, you will gain a deeper understanding of the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>What <span class="No-Break">is PowerShell?</span></li>
				<li>The history <span class="No-Break">of PowerShell</span></li>
				<li>Why is PowerShell useful <span class="No-Break">for cybersecurity?</span></li>
				<li>Introduction <span class="No-Break">to OOP</span></li>
				<li>Windows PowerShell and <span class="No-Break">PowerShell Core</span></li>
				<li><span class="No-Break">Execution policy</span></li>
				<li><span class="No-Break">Help system</span></li>
				<li><span class="No-Break">PowerShell versions</span></li>
				<li><span class="No-Break">PowerShell editors</span></li>
			</ul>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Technical requirements</h1>
			<p>To get the most out of this chapter, ensure that you have the following: </p>
			<ul>
				<li>PowerShell 7.3 <span class="No-Break">and above</span></li>
				<li>Visual Studio <span class="No-Break">Code installed</span></li>
				<li>Access to the GitHub repository <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Chapter01</strong></span><span class="No-Break">:</span></li>
			</ul>
			<p><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter01"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter01</span></a></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>What is PowerShell?</h1>
			<p>PowerShell is a <a id="_idIndexMarker000"/>scripting framework and command shell, built on .NET. It is implemented, by default, on<a id="_idIndexMarker001"/> Windows <strong class="bold">Operating Systems</strong> (<strong class="bold">OSs</strong>). It is object-based, which means that everything you work with (such as variables, input, and more) has properties and methods. That opens up a lot of possibilities when working <span class="No-Break">with PowerShell.</span></p>
			<p>Additionally, PowerShell has a pipeline and allows you to pipe input into other commands to reuse it. This combines the advantages of a command line-based script language with an object-oriented language. And on top of this, it has a built-in help system that allows you to help yourself while working on <span class="No-Break">the console.</span></p>
			<p>PowerShell does not exclusively run on Windows OSs. Since PowerShell Core was released in 2016, it can run on any OS, including Linux and <span class="No-Break">macOS devices.</span></p>
			<p>It helps security professionals to get a lot of work done in a very short space of time. Not only do blue teamers find it useful, but also red teamers. As with every feature that provides a lot of capabilities and enables you to do your daily work in a more efficient way, it can be used for good and bad purposes. It can be a mighty tool for professionals, but as usual, security professionals need to do their part to secure their environments so that existing tools and machines will not be abused by adversaries. </p>
			<p>But first, let's take a look at how PowerShell was born and how it developed over <span class="No-Break">the years.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>The history of PowerShell</h2>
			<p>Before PowerShell was created, there were already <strong class="bold">Command Line Interfaces</strong> (<strong class="bold">CLIs</strong>) available, shipped with each OS to manage the system via command line: <strong class="source-inline">COMMAND.COM</strong> was the default in MS DOS and Windows 9.x, while <strong class="source-inline">cmd.exe</strong> was the default in the Windows NT family. The latter, <strong class="source-inline">cmd.exe</strong>, is still integrated within modern Windows OSs such as <span class="No-Break">Windows 10.</span></p>
			<p>Those CLIs could be used to not only execute commands from the command line but also to write scripts to automate tasks, using the batch <span class="No-Break">file syntax.</span></p>
			<p>Because not all functions of the <strong class="bold">Graphical User Interface</strong> (<strong class="bold">GUI</strong>) were available, it was not possible to automate all tasks via the command line. Additionally, the language had inconsistencies, so scripting was not as easy as it should have been in the <span class="No-Break">first place.</span></p>
			<p>In 1998, Microsoft released <strong class="bold">Windows Script Host</strong> (<strong class="source-inline">cscript.exe</strong>) in Windows 98 to overcome the limits of the former CLIs and to improve the scripting experience. With <strong class="source-inline">cscript.exe</strong>, it now became possible to work with the APIs of the <strong class="bold">Component Object Model</strong> (<strong class="bold">COM</strong>), which made this interface very mighty; so mighty that not only did system administrators leverage this new feature but also the malware authors. This quickly lent <strong class="source-inline">cscript.exe</strong> the reputation of being a vulnerable vector of <span class="No-Break">the OS.</span></p>
			<p>Additionally, the documentation of Windows Script Host was not easily accessible, and there were even more CLIs developed for different use cases besides <strong class="source-inline">cscript.exe</strong>, such as <strong class="source-inline">netsh</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">wmic</strong></span><span class="No-Break">.</span></p>
			<p>In 1999, <em class="italic">Jeffrey Snover</em>, who had a UNIX background, started to work for Microsoft. <em class="italic">Snover</em> was a big fan of command lines and automation, so his initial goal was to use UNIX tools on Microsoft systems, supporting the Microsoft Windows <strong class="bold">Services for </strong><span class="No-Break"><strong class="bold">UNIX</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SFU</strong></span><span class="No-Break">).</span></p>
			<p>However, as there is a big architectural difference between Windows and UNIX-based systems, he quickly noticed that making UNIX tools work on Windows didn't bring any value to <span class="No-Break">Windows-based systems.</span></p>
			<p>While UNIX systems relied on ASCII files that could be easily leveraged and manipulated with tools such as <strong class="source-inline">awk</strong>, <strong class="source-inline">sed</strong>, <strong class="source-inline">grep</strong>, and more, Windows systems were API-based, leveraging <span class="No-Break">structured data.</span></p>
			<p>So, he decided that he could do better and, in 2002, started to work on a new command-line interface called <strong class="bold">Monad</strong> (also known as <span class="No-Break"><strong class="bold">Microsoft Shell/MSH</strong></span><span class="No-Break">).</span></p>
			<p>Now, Monad not only had the option to pass structured data (objects) into the pipe, instead of simple text, but also run scripts remotely on multiple devices. Additionally, it was easier for administrators to use Monad for administration as many default tasks were simplified within <span class="No-Break">this framework.</span></p>
			<p>On April 25, 2006, Microsoft announced that Monad was renamed PowerShell. In the same year, the first version of PowerShell was released, and not much later (in January 2007), PowerShell was released for <span class="No-Break">Windows Vista.</span></p>
			<p>In 2009, PowerShell 2.0 was released as a component of Windows 7 and Windows Server 2008 R2 that was integrated, by default, into <span class="No-Break">the OS.</span></p>
			<p>Over the years, PowerShell <a id="_idIndexMarker002"/>was developed even further, and many new versions were released in the meantime, containing new features <span class="No-Break">and improvements.</span></p>
			<p>Then, in 2016, Microsoft announced that PowerShell would be made open source (MIT license) and would also be <span class="No-Break">supported cross-platform.</span></p>
			<p>PowerShell 5.1, which was also released in 2016, was the last Windows-only PowerShell version. It is still shipped on Windows systems but is no <span class="No-Break">longer developed.</span></p>
			<p>The PowerShell team was in the process of supporting Nano Server. So, there was a full version of PowerShell supporting Windows servers and clients. Nano Server had a severely trimmed version of .NET (called .NET Core), so the team had to reduce functions and chop it down to make PowerShell work with .NET Core. So, technically PowerShell 5.1 for Nano Server was the first version of <span class="No-Break">PowerShell Core.</span></p>
			<p>The first real and official version of PowerShell Core was 6.0, which also offered support for cross-platform such as macOS <span class="No-Break">and Linux.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Why is PowerShell useful for cybersecurity?</h2>
			<p>PowerShell <a id="_idIndexMarker003"/>runs on most modern Windows systems as a default. It helps administrators to automate their <a id="_idIndexMarker004"/>daily workflows. Since PowerShell is available on all systems, it also makes it easier for attackers to use the scripting language for<a id="_idIndexMarker005"/> their own purposes – if attackers get access to a system, for example, through a <strong class="bold">credential </strong><span class="No-Break"><strong class="bold">theft</strong></span><span class="No-Break"> attack.</span></p>
			<p>For attackers, that sounds amazing: a preinstalled scripting framework that provides direct access to cmdlets and the underlying .NET Framework. Automation allows you to get a lot done – not just for a <span class="No-Break">good purpose.</span></p>
			<h3>Is PowerShell dangerous, and should it be disabled?</h3>
			<p>No! I have often heard this<a id="_idIndexMarker006"/> question when talking to CISOs. As PowerShell is seen more and more in the hands of the red team, some people fear the capabilities of this mighty <span class="No-Break">scripting framework.</span></p>
			<p>But as usual, it's not black and white, and organizations should rather think about how to harden their systems and protect their identities, how to implement better detection, and how to leverage PowerShell in a way that benefits their workloads and processes – instead of worrying <span class="No-Break">about PowerShell.</span></p>
			<p>In the end, when you set up a server, you don't just install it and connect it to the internet. The same goes for PowerShell: you don't just enable PowerShell remote usage in your organization allowing everybody to connect remotely to your servers, regardless of <span class="No-Break">their role.</span></p>
			<p>PowerShell is just a scripting language, similar to the<a id="_idIndexMarker007"/> preinstalled <strong class="bold">cscript</strong> or <strong class="bold">batch</strong>. Technically, it <a id="_idIndexMarker008"/>provides <a id="_idIndexMarker009"/>the same potential impact<a id="_idIndexMarker010"/> as <strong class="bold">Java</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="bold">.NET</strong></span><span class="No-Break">.</span></p>
			<p>And if we compare it to Linux or macOS, saying that PowerShell is dangerous is like saying that <strong class="bold">Bash or zsh</strong> is dangerous. </p>
			<p>A friend who worked in incident response for many years once told me about adversaries dropping <strong class="bold">C#</strong> code files on the target boxes and <a id="_idIndexMarker011"/>calling <strong class="bold">csc.exe</strong> (which is part of the .NET Framework) to compile the dropped files directly on the box. Which is a very effective way to abuse a preinstalled software to install the adversary's code on the system without even <span class="No-Break">leveraging PowerShell.</span></p>
			<p>So, in other words, it is not the language that is dangerous or malicious; adversaries still require identities or authorization for the execution, which can be constrained by the security expert or administrator who is responsible for the <span class="No-Break">environment's security.</span></p>
			<p>And to be honest, all red teamers that I know or have talked to are starting to move more and more to other languages such as C# or C++ instead of PowerShell, if they want to stay undetected during <span class="No-Break">their attacks.</span></p>
			<p>If the right security measures and detections are implemented, it is almost impossible to go unnoticed when using PowerShell for an attack in a well-configured and protected environment. Once you have followed the security best practices, PowerShell will support you to keep your environment safe and help you track any attackers in <span class="No-Break">your environment.</span></p>
			<p>Additionally, a lot of your <a id="_idIndexMarker012"/>environmental security depends on your global credentials and access hygiene: before attackers can leverage PowerShell, first, they need access to a system. We'll take a closer look at how to secure your environment credential-wise in <a href="B16679_06_Final_PD.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Active Directory – Attacks </em><span class="No-Break"><em class="italic">and Mitigation</em></span><span class="No-Break">.</span></p>
			<h3>How can PowerShell support my blue team?</h3>
			<p>PowerShell <a id="_idIndexMarker013"/>not only enables your IT professionals to work more efficiently and to get things done quicker, but it also provides your security team with great options. </p>
			<p>PowerShell offers a lot of built-in <a id="_idIndexMarker014"/>safety guards that you will learn more <a id="_idIndexMarker015"/>about in <span class="No-Break">this book:</span></p>
			<ul>
				<li><strong class="bold">Automation and compliance</strong>: One of the main benefits is that you can automate repeatable, tedious tasks. Not only will your administrators benefit from automating tasks, but <a id="_idIndexMarker016"/>your <strong class="bold">Security Operations Center</strong> (<strong class="bold">SOC</strong>) can automate response actions taken, triggered by <span class="No-Break">certain events.</span></li>
			</ul>
			<p>One of the main reasons organizations are getting breached is missing security updates. It is not easy to keep all systems up to date – even with updated management systems <a id="_idIndexMarker017"/>such as <strong class="bold">Windows Server Update Services</strong> (<strong class="bold">WSUS</strong>) in place. PowerShell can help to build a mechanism to regularly check whether updates are missing to keep your <span class="No-Break">environment secure.</span></p>
			<p>Auditing and enforcing <a id="_idIndexMarker018"/>compliance can easily be achieved using <strong class="bold">Desired State </strong><span class="No-Break"><strong class="bold">Configuration</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DSC</strong></span><span class="No-Break">).</span></p>
			<p>Automate security checks to audit Active Directory or server security and enforce your security baselines. DSC allows you to control the configuration of your <a id="_idIndexMarker019"/>servers at any time. You can configure your machines to reset their configuration up to every 15 minutes to the configuration <span class="No-Break">you specified.</span></p>
			<p>Additionally, if you integrate DSC as part of your incident response plan, it is very easy to rebuild potentially compromised servers from <span class="No-Break">the scratch.</span></p>
			<ul>
				<li><strong class="bold">Control who is allowed to do what and where</strong>: By configuring <strong class="bold">PowerShell remoting</strong>/<strong class="bold">WinRM</strong>, you can specify <em class="italic">who</em> is allowed to log on to <em class="italic">which device or server</em>. Of course, it does not help <a id="_idIndexMarker020"/>against <strong class="bold">credential theft</strong> (as this is not a PowerShell topic), but it helps to granularly define which identity is allowed to do what. Additionally, it provides great auditing capabilities for <span class="No-Break">remote connections.</span></li>
			</ul>
			<p><strong class="bold">Constrained Language mode</strong> lets <a id="_idIndexMarker021"/>you restrict which PowerShell elements are allowed in a session. This can already help to prevent <span class="No-Break">certain attacks.</span></p>
			<p>And <a id="_idIndexMarker022"/>using <strong class="bold">Just Enough Administration</strong> (<strong class="bold">JEA</strong>), you can even restrict which roles/identities are allowed to run which commands on which machine. You can even restrict the parameters of <span class="No-Break">a command.</span></p>
			<ul>
				<li><strong class="bold">Find out what is going on in your environment</strong>: PowerShell provides an extensive logging framework with many additional logging options such as creating transcripts and script <span class="No-Break">block logging.</span></li>
			</ul>
			<p>Every action in PowerShell can be tracked if the right infrastructure is put behind it. You can even<a id="_idIndexMarker023"/> automate your response actions using a <strong class="bold">Security Orchestration, Automation, and Response</strong> (<span class="No-Break"><strong class="bold">SOAR</strong></span><span class="No-Break">) approach.</span></p>
			<p>Using PowerShell, you can quickly pull and search event logs of multiple servers, connecting remotely to <span class="No-Break">analyze them.</span></p>
			<p>In a case of a security breach, PowerShell can also help you to collect and investigate the forensic artifacts and to automate the investigation. There are great modules<a id="_idIndexMarker024"/> such as <em class="italic">PowerForensics</em> that you can reuse for your forensics operations and <span class="No-Break">post-breach remediation.</span></p>
			<ul>
				<li><strong class="bold">Restrict which scripts are allowed to run</strong>: By default, PowerShell brings a feature <a id="_idIndexMarker025"/>called <strong class="bold">Execution Policy</strong>. Although it is <em class="italic">not</em> a security control, it prevents users from unintentionally <span class="No-Break">running scripts.</span></li>
			</ul>
			<p>Signing your<a id="_idIndexMarker026"/> code helps you to verify whether a script that is run is considered legit: if you allow only signed scripts to run, this is a great way to prevent your users to run scripts directly downloaded from <span class="No-Break">the internet.</span></p>
			<p><strong class="bold">AppLocker</strong>, in <a id="_idIndexMarker027"/>combination<a id="_idIndexMarker028"/> with <strong class="bold">Code Signing</strong>, can help you to control which scripts are allowed to run in <span class="No-Break">your organization.</span></p>
			<p>The mentioned solutions do not restrict interactive code <span class="No-Break">restriction though.</span></p>
			<ul>
				<li><strong class="bold">Detect and stop malicious code from execution</strong>: The <strong class="bold">Antimalware Scan Interface</strong> (<strong class="bold">AMSI</strong>) provides <a id="_idIndexMarker029"/>a possibility to have your code checked by the antimalware solution that is currently present on the machine. This can help to detect malicious code and is also a great safeguard against file-less malware attacks (<strong class="bold">living off the land</strong>) – attacks that don't require files to be stored on the machine, but rather directly run the code <span class="No-Break">in memory.</span></li>
			</ul>
			<p>It is integrated directly into PowerShell and can assess scripts, interactive use, and dynamic <span class="No-Break">code evaluation.</span></p>
			<p>These are only some examples of how PowerShell can support the blue team, but it should already give you an overview of how blue teamers can benefit from using and <span class="No-Break">auditing PowerShell.</span></p>
			<p>It is also worth <a id="_idIndexMarker030"/>reading the great blog article <em class="italic">PowerShell </em><em class="italic">♥</em><em class="italic"> the Blue Team that</em> the Microsoft PowerShell team has published to provide advice on how PowerShell supports blue <span class="No-Break">teamers: </span><a href="https://devblogs.microsoft.com/powershell/powershell-the-blue-team/"><span class="No-Break">https://devblogs.microsoft.com/powershell/powershell-the-blue-team/</span></a><span class="No-Break">.</span></p>
			<p>You will learn more about possible attacks, mitigations, and bypasses during your journey throughout <span class="No-Break">this book.</span></p>
			<p>But first, let's start refreshing your knowledge of PowerShell <span class="No-Break">fundamentals. Enjoy!</span></p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Getting started with PowerShell</h1>
			<p>Before we <a id="_idIndexMarker031"/>can jump directly into scripting for cybersecurity and crazy red or blue team tasks, it is important to know some of the basics of PowerShell. Here are some refreshers that will help you to <span class="No-Break">get started.</span></p>
			<p>Introduction <span class="No-Break">to OOP</span></p>
			<p>PowerShell is<a id="_idIndexMarker032"/> an object-oriented language. OOP <a id="_idIndexMarker033"/>allows developers to think of software development as if they were working with real-life objects or entities. Some of the main advantages of OOP are that it's scalable, flexible, and overall, it lets you efficiently reuse <span class="No-Break">your code.</span></p>
			<p>Some of the base terminologies in<a id="_idIndexMarker034"/> OOP are <strong class="bold">classes</strong>, <strong class="bold">objects</strong>, <strong class="bold">properties</strong>, and <strong class="bold">methods</strong>. And if<a id="_idIndexMarker035"/> we<a id="_idIndexMarker036"/> look <a id="_idIndexMarker037"/>at the four main <a id="_idIndexMarker038"/>principles of OOP – <strong class="bold">encapsulation</strong>, <strong class="bold">abstraction</strong>, <strong class="bold">inheritance</strong>, and <strong class="bold">polymorphism</strong> – you<a id="_idIndexMarker039"/> quickly feel <a id="_idIndexMarker040"/>overwhelmed<a id="_idIndexMarker041"/> if you have <a id="_idIndexMarker042"/>no experience with <span class="No-Break">OOP yet.</span></p>
			<p>But don't worry, it is not as hard as it sounds, and OOP will make your <span class="No-Break">life easier!</span></p>
			<p>To better understand those concepts and principles, let's look at Alice and Bob as an example. They are both human beings; therefore, they share the same <em class="italic">class</em>: <strong class="source-inline">human</strong>. Both are our working entities in<a id="_idIndexMarker043"/> our example and, therefore, are <span class="No-Break">our </span><span class="No-Break"><em class="italic">objects</em></span><span class="No-Break">.</span></p>
			<p>A <em class="italic">class</em> is a<a id="_idIndexMarker044"/> collection of properties and methods, similar to a blueprint for objects. Alice and Bob are both humans and share many <em class="italic">properties</em> and <em class="italic">methods</em>. Both <a id="_idIndexMarker045"/>have a <a id="_idIndexMarker046"/>certain amount of energy they can spend per day, can feel more or less relaxed, and need to work to <span class="No-Break">gain money.</span></p>
			<p>Both need to work and like to drink coffee. During the night, both need to sleep to restore <span class="No-Break">their energy:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer013">
					<img alt="Figure 1.1 – Alice, the CISO" src="image/B16679_01_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Alice, the CISO</p>
			<p>Alice works as a <strong class="bold">Chief Information Security Officer</strong> (<strong class="bold">CISO</strong>) and, often, plays between <a id="_idIndexMarker047"/>meetings and in the evening with her cat Mr. Meow, which helps her <span class="No-Break">to relax.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer014">
					<img alt="Figure 1.2 – Bob, the security consultant" src="image/B16679_01_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Bob, the security consultant</p>
			<p>In comparison, Bob works as a security consultant. Although he is also a human, he has different <em class="italic">methods</em> than<a id="_idIndexMarker048"/> Alice: Bob does not have a cat, but he enjoys painting in his spare time, which makes him feel relaxed and restores <span class="No-Break">his batteries.</span></p>
			<p>Let's explore the four main<a id="_idIndexMarker049"/> principles of OOP, looking at Alice <span class="No-Break">and Bob.</span></p>
			<h3>Encapsulation</h3>
			<p><strong class="bold">Encapsulation</strong> is <a id="_idIndexMarker050"/>achieved <a id="_idIndexMarker051"/>if each object keeps its state <strong class="bold">private</strong> inside a class. Other objects cannot access it directly, they need to call a method to change <span class="No-Break">its state.</span></p>
			<p>For example, Alice's state includes the private <strong class="source-inline">EnergyLevel</strong>, <strong class="source-inline">RelaxationStatus</strong>, and <strong class="source-inline">Money</strong> properties. She also has a private <strong class="source-inline">SighHappily()</strong> method. She can call this method <a id="_idIndexMarker052"/>whenever she wants; the other classes can't influence whenever Alice sighs happily. When Alice plays with her cat Mr. Meow, the <strong class="source-inline">SighHappily()</strong> method is called by default – Alice really enjoys <span class="No-Break">this activity.</span></p>
			<p>What other classes can do <a id="_idIndexMarker053"/>is call the public <strong class="source-inline">Work()</strong>, <strong class="source-inline">DrinkCoffee()</strong>, <strong class="source-inline">Sleep()</strong>, and <strong class="source-inline">PlayWithCat()</strong> functions. Those functions can change the internal state and even call the private <strong class="source-inline">SighHappily()</strong> method when Alice plays with her cat <span class="No-Break">Mr. Meow:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer015">
					<img alt="Figure 1.3 – A closer look at public and private methods" src="image/B16679_01_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – A closer look at public and private methods</p>
			<p>To summarize, if you want to change a private property's value, you always need to call a public method that is linked to the private state. Like in real life, there is no magic cure – besides coffee – to immediately remove your tiredness. And even with coffee, you still need to perform an action to drink it. The binding that exists between the private state and the public methods is <span class="No-Break">called </span><span class="No-Break"><strong class="bold">encapsulation</strong></span><span class="No-Break">.</span></p>
			<h3>Abstraction</h3>
			<p><strong class="bold">Abstraction</strong> can be<a id="_idIndexMarker054"/> thought of as a natural extension of <a id="_idIndexMarker055"/>encapsulation. Often, a code base becomes super extensive, and you can lose the overview. Applying abstraction means that each object should expose its methods at only a high level and should hide details that are not necessary to <span class="No-Break">other objects.</span></p>
			<p>So, for example, we have the <strong class="source-inline">Work()</strong> method defined in the <span class="No-Break"><strong class="source-inline">human</strong></span><span class="No-Break"> class.</span></p>
			<p>Depending on how technical your parents are, they might understand what you do in your daily job. Mine, however, do <a id="_idIndexMarker056"/>not understand a word that I say. They just know that I work with computers. So, if I talk with my parents on the phone, instead of telling them every detail and boring them to death, I just tell them that I have <span class="No-Break">finished work.</span></p>
			<p>A similar <a id="_idIndexMarker057"/>principle should also apply when writing object-oriented code. Although there are many different operations behind the <strong class="source-inline">Work()</strong>method, it is abstracted and only the relevant data <span class="No-Break">is shown.</span></p>
			<p>Another example could be an elevator in the office. When you push a button to get to a different floor, something happens below the surface. But only the buttons and the display, indicating the floor level, are shown to the user of the elevator. This principle is called abstraction and helps to keep an overview of the task that should <span class="No-Break">be achieved.</span></p>
			<h3>Inheritance</h3>
			<p>If you <a id="_idIndexMarker058"/>require <a id="_idIndexMarker059"/>very similar classes or objects, you won't want to duplicate existing code. This would make things more complicated, work-intensive, and there would be a higher chance of implementing bugs – for example, if you have to change the code for all different instances and <span class="No-Break">forget one.</span></p>
			<p>So, our Alice and Bob objects are quite similar and share a <em class="italic">common logic</em>, but they are <em class="italic">not entirely the same</em>. They are both humans, but they have different professions that require different skillsets and <span class="No-Break">tasks performed.</span></p>
			<p>All CISOs and all security consultants are humans, so both roles <strong class="bold">inherit</strong> all properties and methods from the <span class="No-Break"><strong class="source-inline">human</strong></span><span class="No-Break"> class.</span></p>
			<p>Similar to the <strong class="source-inline">SecurityConsultant</strong> class, the <strong class="source-inline">CISO</strong> class inherits all properties and methods of the <strong class="source-inline">human</strong> class. However, while the <strong class="source-inline">CISO</strong> class also introduces the <strong class="source-inline">StrategicPlanningSkillset</strong> property and the <strong class="source-inline">CalculateRisk()</strong> method, they are not necessary for the <span class="No-Break"><strong class="source-inline">SecurityConsultant</strong></span><span class="No-Break"> class.</span></p>
			<p>The <strong class="source-inline">SecurityConsultant</strong> class defines their own <strong class="source-inline">TechnicalAuditingSkillset</strong> property and <strong class="source-inline">AnalyzeSystem()</strong> and <span class="No-Break"><strong class="source-inline">TalkToCustomer()</strong></span><span class="No-Break"> methods.</span></p>
			<p>Alice inherits all the skills that were defined in the <strong class="source-inline">human</strong> class, and in the <strong class="source-inline">CISO</strong> class, which builds a <em class="italic">hierarchy</em>: <strong class="source-inline">human</strong> is <a id="_idIndexMarker060"/>now the parent class of the <strong class="source-inline">CISO</strong> class, while the <strong class="source-inline">CISO</strong> class is Alice's <strong class="bold">parent</strong> class – in this case, Alice<a id="_idIndexMarker061"/> is the <span class="No-Break"><strong class="bold">child</strong></span><span class="No-Break"> object.</span></p>
			<p>Additionally, Bob<a id="_idIndexMarker062"/> inherits all the properties and methods defined in the <strong class="source-inline">human</strong> class, but in comparison to Alice, he inherits everything from the <span class="No-Break"><strong class="source-inline">SecurityConsultant</strong></span><span class="No-Break"> class:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer016">
					<img alt="Figure 1.4 – Inheritance: parent and child classes and objects" src="image/B16679_01_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Inheritance: parent and child classes and objects</p>
			<p>And yes, dear<a id="_idIndexMarker063"/> security consultants and CISOs, I know that your profession requires far more skills and that your role is far more challenging than is shown in this example. I tried to make it abstract to keep <span class="No-Break">it simple.</span></p>
			<p>Looking at Alice and Bob, Alice enjoys spending time with her cat, Mr. Meow, so she brings her unique <strong class="source-inline">PlayWithCat()</strong> and <strong class="source-inline">SighHappily()</strong> methods. Bob does not have a cat, but he enjoys painting and, therefore, has the unique <span class="No-Break"><strong class="source-inline">Paint()</strong></span><span class="No-Break"> method.</span></p>
			<p>Using <strong class="bold">inheritance</strong>, we only need to add what is necessary to implement the required changes while using the existing logic with the <span class="No-Break">parent classes.</span></p>
			<h3>Polymorphi<a id="_idTextAnchor023"/>sm</h3>
			<p>Now <a id="_idIndexMarker064"/>that we <a id="_idIndexMarker065"/>have looked into the concept of inheritance, <strong class="bold">polymorphism</strong> is not far off. Polymorphism means that although you can create different objects out of different classes, all classes and objects can be used just like <span class="No-Break">their parents.</span></p>
			<p>If we look at Alice and Bob, both are humans. That means we can rely on the fact that both support the <strong class="source-inline">EnergyLevel</strong>, <strong class="source-inline">RelaxationStatus</strong>, and <strong class="source-inline">Money</strong> properties along with the <strong class="source-inline">Work()</strong>, <strong class="source-inline">DrinkCoffee()</strong>, and <span class="No-Break"><strong class="source-inline">Sleep()</strong></span><span class="No-Break"> methods.</span></p>
			<p>Additionally, they <a id="_idIndexMarker066"/>can support other unique properties and methods, but they always support the same ones as their parents to <span class="No-Break">avoid confusion.</span></p>
			<p>Please <a id="_idIndexMarker067"/>note that this overview should only serve as a high-level overview; if you want to dive deeper into the concepts of OOP, you might want to look into other literature solely on OOP, such as <em class="italic">Learning Object-Oriented Programming</em>, which is written by Gaston C. Hillar and also published <span class="No-Break">by Packt.</span></p>
			<p>Now that you understand the base concepts of OOP, let's get back to working <span class="No-Break">with PowerShell.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/>Windows PowerShell</h2>
			<p>By <a id="_idIndexMarker068"/>default, Windows PowerShell 5.1 is installed on all newer systems, starting with Windows 10. You can either open it by searching in your Start menu for <strong class="source-inline">PowerShell</strong>, or you can also start it via <em class="italic">Windows key</em> + <em class="italic">R</em> and typing in <strong class="source-inline">powershell</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">powershell.exe</strong></span><span class="No-Break">.</span></p>
			<p>In this console, you can run commands, scripts, <span class="No-Break">or cmdlets:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer017">
					<img alt="Figure 1.5 – The Windows PowerShell version 5.1 ﻿CLI" src="image/B16679_01_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – The Windows PowerShell version 5.1 CLI</p>
			<p>On Windows 10 devices, the default location<a id="_idIndexMarker069"/> of Windows PowerShell v5.1 is under <span class="No-Break">the following:</span></p>
			<ul>
				<li>Windows <span class="No-Break">PowerShell: </span><span class="No-Break"><strong class="source-inline">%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe</strong></span></li>
				<li>Windows PowerShell (<span class="No-Break">x86): </span><span class="No-Break"><strong class="source-inline">%SystemRoot%\syswow64\WindowsPowerShell\v1.0\powershell.exe</strong></span></li>
			</ul>
			<p class="callout-heading">Why Is There a v1.0 in the Path? Does That Mean I'm Running an Old Version?</p>
			<p class="callout">As we will also take a more detailed look at PowerShell versions in this book, you might think <em class="italic">Omg, I heard that old versions do not provide all necessary security features, such as logging and many more! Am I </em><span class="No-Break"><em class="italic">at risk?</em></span></p>
			<p class="callout">No, you aren't. Although the path contains <strong class="source-inline">v1</strong>, newer versions are being installed in this exact path. Originally it was planned to create a new folder with the correct version name, but later Microsoft decided against it so that no breaking changes <span class="No-Break">are caused.</span></p>
			<p class="callout">You might have also noticed the <strong class="source-inline">.ps1</strong> script extension. We have the same reason here: originally it was also planned that each version will be differentiated by the script extension. But out of backward compatibility reasons, this idea was not implemented for PowerShell <span class="No-Break">v2 logic.</span></p>
			<p>But since Windows PowerShell will not be developed further, it makes sense to install and use the latest PowerShell <span class="No-Break">Core binaries.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/>PowerShell Core</h2>
			<p>On newer systems, Windows PowerShell version 5.1 is still installed by default. To use the <a id="_idIndexMarker070"/>latest PowerShell Core version, you need to manually download and install it. While this book was written, the latest stable PowerShell Core version was <span class="No-Break">PowerShell 7.3.6.</span></p>
			<p>To learn more about how to download and install the latest PowerShell Core version, you can leverage the official <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows</span></a><span class="No-Break">.</span></p>
			<p>You will find the <a id="_idIndexMarker071"/>latest stable PowerShell Core version <span class="No-Break">here: </span><a href="https://aka.ms/powershell-release?tag=stable"><span class="No-Break">https://aka.ms/powershell-release?tag=stable</span></a><span class="No-Break">.</span></p>
			<p>Download it and start the installation. The installation wizard opens and guides you through the installation. Depending on your requirements, you can specify what should be configured <span class="No-Break">by default:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer018">
					<img alt="Figure 1.6 – Installing PowerShell 7" src="image/B16679_01_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Installing PowerShell 7</p>
			<p>Don't worry if you <a id="_idIndexMarker072"/>haven't enabled <strong class="bold">PowerShell remoting</strong> yet. You can configure this option later. The wizard runs through and installs PowerShell Core in the separate <strong class="source-inline">$env:ProgramFiles\PowerShell\7</strong> location. PowerShell 7 is designed to run parallel to <span class="No-Break">PowerShell 5.1.</span></p>
			<p>After the setup is complete, you can launch the new PowerShell console and pin it to your taskbar or the <span class="No-Break">Start menu:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer019">
					<img alt="Figure 1.7 – The PowerShell version 7 ﻿CLI" src="image/B16679_01_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – The PowerShell version 7 CLI</p>
			<p>Now you can use <a id="_idIndexMarker073"/>the latest PowerShell Core version instead of the old Windows PowerShell <span class="No-Break">version 5.1.</span></p>
			<h3>Installing PowerShell Core Group Policy definitions</h3>
			<p>To define <a id="_idIndexMarker074"/>consistent options for your servers in your environment, Group Policy helps with <span class="No-Break">the configuration.</span></p>
			<p>When<a id="_idIndexMarker075"/> installing PowerShell 7, Group Policy templates, along with an installation script, will be populated <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">$PSHOME</strong></span><span class="No-Break">.</span></p>
			<p>Group Policy<a id="_idIndexMarker076"/> requires two kinds of templates (<strong class="source-inline">.admx</strong>, <strong class="source-inline">.adml</strong>) to allow the configuration of <span class="No-Break">registry-based settings.</span></p>
			<p>You can find the <a id="_idIndexMarker077"/>templates as well as the installation script using the <strong class="source-inline">Get-ChildItem -Path $PSHOME -Filter *</strong><span class="No-Break"><strong class="source-inline">Core*Policy*</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer020">
					<img alt="Figure 1.8 – Locating the PowerShell Core Group Policy templates and installation script" src="image/B16679_01_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Locating the PowerShell Core Group Policy templates and installation script</p>
			<p>Type <strong class="source-inline">$PSHOME\InstallPSCorePolicyDefinitions.ps1</strong> into your domain controller, press <em class="italic">Tab</em>, and confirm <span class="No-Break">with </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></p>
			<p>The <a id="_idIndexMarker078"/>Group Policy <a id="_idIndexMarker079"/>templates for PowerShell Core will be installed, and you can access them by navigating to <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Computer Configuration</strong> | <strong class="bold">Administrative Templates</strong> | <span class="No-Break"><strong class="bold">PowerShell Core</strong></span></li>
				<li><strong class="bold">User Configuration</strong> |<strong class="bold">Administrative Templates</strong> | <span class="No-Break"><strong class="bold">PowerShell Core</strong></span></li>
			</ul>
			<p>You can now use them to configure PowerShell Core in your environment, in parallel to <span class="No-Break">Windows PowerShell.</span></p>
			<p>You can configure both policies differently, but to avoid confusion and misconfiguration, I recommend configuring the setting in Windows PowerShell and checking the <strong class="bold">Use Windows PowerShell Policy setting</strong> box, which is available in all PowerShell Core Group <span class="No-Break">Policy settings.</span></p>
			<h3>Autocompletion</h3>
			<p>Autocompleting<a id="_idIndexMarker080"/> commands can be very useful and can save a lot of time. You can either use <em class="italic">Tab</em> or <em class="italic">Ctrl</em> + spacebar <span class="No-Break">for autocompletion:</span></p>
			<ul>
				<li>With <em class="italic">Tab</em>, the command that comes nearest to the command that you already typed in is shown. With every other <em class="italic">Tab</em> you can switch through the commands and have the next one – sorted alphabetically – <span class="No-Break">entered.</span></li>
				<li>If there are multiple commands that fit the string you entered, you can type <em class="italic">Ctrl</em> + spacebar to <a id="_idIndexMarker081"/>see all possible command<a id="_idTextAnchor026"/>s. You can use the arrow keys to select a command. Confirm <span class="No-Break">with </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">:</span></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer021">
					<img alt="Figure 1.9 – Using Ctrl + spacebar to choose the right command" src="image/B16679_01_009.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Using Ctrl + spacebar to choose the right command</p>
			<h3>Working with the PowerShell history</h3>
			<p>Sometimes, it <a id="_idIndexMarker082"/>can be useful to find out which commands you have used recently in your <span class="No-Break">PowerShell session:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer022">
					<img alt="Figure 1.10 – Using Get-History" src="image/B16679_01_010.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – Using Get-History</p>
			<p>All recently used commands are shown. Use the arrow keys to browse the last-used commands, change them, and run <span class="No-Break">them again.</span></p>
			<p>In this example, one of the last commands that was run was the <strong class="source-inline">Enter-PSSession</strong> command, which initiates a PowerShell remoting session to the specified host – in this case, <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PSSEC-PC01</strong></span><span class="No-Break">.</span></p>
			<p>If you want to <a id="_idIndexMarker083"/>initiate another PowerShell remoting session to <strong class="source-inline">PSSEC-PC02</strong> instead of <strong class="source-inline">PSSEC-PC01</strong>, you don't have to type in the whole command again: just use the <em class="italic">arrow up key</em> once, then change <strong class="source-inline">-ComputerName</strong> to <strong class="source-inline">PSSEC-PC02</strong> and hit <em class="italic">Enter</em> to <span class="No-Break">execute it.</span></p>
			<p>If your configuration allows you to connect to <strong class="source-inline">PSSEC-PC02</strong> from this PC using the same credentials, the connection is established, and you can work remotely <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">PSSEC-PC02</strong></span><span class="No-Break">.</span></p>
			<p>We will have a closer look at PowerShell remoting in <a href="B16679_03_Final_PD.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Exploring PowerShell Remote Management Technologies and </em><span class="No-Break"><em class="italic">PowerShell Remoting</em></span><span class="No-Break">.</span></p>
			<h3>Searching the PowerShell history</h3>
			<p>To search <a id="_idIndexMarker084"/>the history, pipe the <strong class="source-inline">Get-History</strong> command to <strong class="source-inline">Select-String</strong> and<a id="_idTextAnchor027"/> define the string that you are <span class="No-Break">searching for:</span></p>
			<pre class="source-code">
<strong class="bold">Get-History | Select-String &lt;string to search&gt;</strong></pre>
			<p>If you are a person who likes to keep your commands terse, <strong class="bold">aliases</strong> might speak to you. We will take a look at them later, but for now, here's an example of how you'd search the history, using the same commands but abbreviated as <span class="No-Break">an alias:</span></p>
			<pre class="source-code">
<strong class="bold">h | sts &lt;string to search&gt;</strong></pre>
			<p>If you want to see all the PowerShell remoting sessions that were established in this session, you can search for the <span class="No-Break"><strong class="source-inline">Enter-PSSession</strong></span><span class="No-Break"> string:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer023">
					<img alt="Figure 1.11 – Searching the session history" src="image/B16679_01_011.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – Searching the session history</p>
			<p>However, if you only search for a substring such as <strong class="source-inline">PSSession</strong>, you can find <strong class="bold">all</strong> occurrences of the <strong class="source-inline">PSSession</strong> string, including the last execution <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Get-History</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer024">
					<img alt="Figure 1.12 – Searching the session history" src="image/B16679_01_012.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – Searching the session history</p>
			<p>When <a id="_idIndexMarker085"/>you are looking for a command that was run recently, you don't have to query the entire history. To only get the last <em class="italic">X</em> history entries, you can specify the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Count</strong></span><span class="No-Break"> parameter.</span></p>
			<p>In this example, to get the last five entries, specify <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Count 5</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer025">
					<img alt="Figure 1.13 – Getting the last five history entries" src="image/B16679_01_013.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13 – Getting the last five history entries</p>
			<p>When you close a PowerShell session, the <em class="italic">session history</em> is deleted. That means you will get no results if you use the session-bound <strong class="source-inline">Get-History</strong> command upon starting a <span class="No-Break">new session.</span></p>
			<p>But there's also a <em class="italic">persistent history</em> that you can query, as provided by the <span class="No-Break"><strong class="source-inline">PSReadline</strong></span><span class="No-Break"> module.</span></p>
			<p>The history is stored in a file, which is stored under the path configured <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">(Get-PSReadlineOption).HistorySavePath</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer026">
					<img alt="Figure 1.14 – Displaying the location of the persistent history" src="image/B16679_01_014.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14 – Displaying the location of the persistent history</p>
			<p>You can either open the file or inspect the content <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Get-Content</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-Content (Get-PSReadlineOption).HistorySavePath</pre>
			<p>If you just want <a id="_idIndexMarker086"/>to search for a command to execute it once more, the <strong class="bold">interactive search</strong> might be helpful. Press <em class="italic">Ctrl</em> + <em class="italic">R</em> to search backward, and<a id="_idIndexMarker087"/> type in characters or words that were part of the command that you <span class="No-Break">executed earlier.</span></p>
			<p>As you are searching backward, the most recent command that you executed will appear in your command line. To find the next match, press <em class="italic">Ctrl</em> + <span class="No-Break"><em class="italic">R</em></span><span class="No-Break"> again:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer027">
					<img alt="Figure 1.15 – Using the interactive search to search backward" src="image/B16679_01_015.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15 – Using the interactive search to search backward</p>
			<p><em class="italic">Ctrl</em> + <em class="italic">S</em> works just like <em class="italic">Ctrl</em> + <em class="italic">R</em> but searches forward. You can use both shortcuts to move back and forth in the <span class="No-Break">search results.</span></p>
			<p><em class="italic">Ctrl</em> + <em class="italic">R</em> and <em class="italic">Ctrl</em> + <em class="italic">S</em> allow you to search the permanent history, so you are not restricted to search for the commands run during <span class="No-Break">this session.</span></p>
			<h3>Clearing the screen</h3>
			<p>Sometimes, after <a id="_idIndexMarker088"/>running multiple commands, you might want to start with an empty shell without reopening it – to keep your current session, history, <span class="No-Break">and variables:</span></p>
			<pre class="source-code">
&gt; Clear</pre>
			<p>After typing in the <strong class="source-inline">Clear</strong> command and confirming with <em class="italic">Enter</em>, your current PowerShell console will be cleared, and you can start with a fresh and clean console. All variables set in this session are still accessible, and your history is <span class="No-Break">still available.</span></p>
			<p>Instead of <strong class="source-inline">Clear</strong>, you can also use the <strong class="source-inline">cls</strong> alias or the <em class="italic">Ctrl</em> + <span class="No-Break"><em class="italic">L</em></span><span class="No-Break"> shortcut.</span></p>
			<h3>Canceling a command</h3>
			<p>If you are running<a id="_idIndexMarker089"/> a command, sometimes, you might want to cancel it out for different reasons. It could be that you executed the command by accident, perhaps a command takes too long, or you want to try a different approach – it doesn't matter, <em class="italic">Ctrl</em> + <em class="italic">C</em> is your friend. Press <em class="italic">Ctrl</em> + <em class="italic">C</em> to cancel a <span class="No-Break">running command.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor028"/>Execution Policy</h2>
			<p>Before we <a id="_idIndexMarker090"/>get started writing PowerShell scripts, let's take a closer look at a mechanism called Execution Policy. If you have tried to run a script on a system<a id="_idIndexMarker091"/> that was not configured to run scripts, you might have already stumbled upon <span class="No-Break">this feature:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer028">
					<img alt="Figure 1.16 – Trying to execute a script on a system with Execution Policy configured as Restricted" src="image/B16679_01_016.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16 – Trying to execute a script on a system with Execution Policy configured as Restricted</p>
			<p>Execution Policy is a feature that restricts the execution of PowerShell scripts on the system. Use <strong class="source-inline">Get-ExecutionPolicy</strong> to find <a id="_idIndexMarker092"/>out how the Execution Policy setting <span class="No-Break">is configured:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer029">
					<img alt="Figure 1.17 – Finding out the current Execution Policy setting" src="image/B16679_01_017.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.17 – Finding out the current Execution Policy setting</p>
			<p>While the default setting on all Windows clients is <em class="italic">Restricted</em>, the default setting on Windows <a id="_idIndexMarker093"/>servers is <em class="italic">RemoteSigned</em>. Having the <em class="italic">Restricted</em> setting configured, the system does not run scripts at all, while <em class="italic">RemoteSigned</em> allows the execution of local scripts and remote scripts that <span class="No-Break">were signed.</span></p>
			<h3>Configuring Execution Policy</h3>
			<p>To start working <a id="_idIndexMarker094"/>with PowerShell and create your own scripts, first, you need to configure the Execution <span class="No-Break">Policy setting.</span></p>
			<p>Execution Policy is a feature that allows you to avoid running PowerShell code by accident. It does not protect against attackers who are trying to run code on your system <span class="No-Break">on purpose.</span></p>
			<p>Rather, it is a feature that protects you from your own mistakes – for example, if you have downloaded a script from the internet that you want to inspect before running, and you double-click on it by mistake, Execution Policy helps you to <span class="No-Break">prevent this.</span></p>
			<h3>Execution Policy options</h3>
			<p>The following are the Execution Policy options that determine whether it is allowed to run scripts on the current system or whether they need to be signed <span class="No-Break">to run:</span></p>
			<ul>
				<li><strong class="source-inline">AllSigned</strong>: Only <a id="_idIndexMarker095"/>scripts that are signed by a trusted publisher can be executed, including <span class="No-Break">local scripts.</span></li>
			</ul>
			<p>In <em class="italic">1</em>, <em class="italic">AppLocker, Application Control, and Code Signing</em>, you can find out more about <strong class="bold">script signing</strong>, or you can refer to the online documentation <span class="No-Break">at </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_signing"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_signing</span></a><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="source-inline">Bypass</strong>: Nothing<a id="_idIndexMarker096"/> is blocked, and scripts run without generating a warning or <span class="No-Break">a prompt.</span></li>
				<li><strong class="source-inline">RemoteSigned</strong>: Only<a id="_idIndexMarker097"/> locally created scripts can run if they are unsigned. All scripts that were downloaded from the internet, or are stored on a remote network location, need to be signed by a <span class="No-Break">trusted publisher.</span></li>
				<li><strong class="source-inline">Restricted</strong>: This <a id="_idIndexMarker098"/>is the default configuration. It is not possible to run PowerShell scripts or load configuration files. It is still possible to run <span class="No-Break">interactive code.</span></li>
				<li><strong class="source-inline">Unrestricted</strong>: All scripts <a id="_idIndexMarker099"/>can be run, regardless of whether they were downloaded from the internet or were created locally. If scripts were downloaded from the internet, you will still get prompted if you want to run <span class="No-Break">the file.</span></li>
			</ul>
			<h3>The Execution Policy scope</h3>
			<p>To specify who or what <a id="_idIndexMarker100"/>will be affected by the Execution Policy feature, you can <a id="_idIndexMarker101"/>define <strong class="bold">scopes</strong>. The <strong class="source-inline">-scope</strong> parameter allows you to set the scope that is affected by the Execution <span class="No-Break">Policy feature:</span></p>
			<ul>
				<li><strong class="source-inline">CurrentUser</strong>: This <a id="_idIndexMarker102"/>means that the current user on this computer <span class="No-Break">is affected.</span></li>
				<li><strong class="source-inline">LocalMachine</strong>: This is <a id="_idIndexMarker103"/>the default scope. All users on this computer <span class="No-Break">are affected.</span></li>
				<li><strong class="source-inline">MachinePolicy</strong>: This<a id="_idIndexMarker104"/> affects all users on <span class="No-Break">this computer.</span></li>
				<li><strong class="source-inline">Process</strong>: This only <a id="_idIndexMarker105"/>affects the current <span class="No-Break">PowerShell session.</span></li>
			</ul>
			<p>One good way is to sign all scripts that are being run in your organization. Through this, you can not only identify which scripts are allowed, but it also allows you to use further mitigations such as AppLocker in a better way (you can read more about AppLocker in <a href="B16679_11_Final_PD.xhtml#_idTextAnchor306"><em class="italic">"11" on page </em><em class="italic">435</em></a>, <em class="italic">AppLocker, Application Control, and Code Signing</em>) – and you can configure Execution Policy <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">AllSigned</strong></span><span class="No-Break">.</span></p>
			<p>Of course, if you develop your own PowerShell scripts, they are not signed while you are still working <span class="No-Break">on them.</span></p>
			<p>To maintain protection from running scripts unintentionally, but to have the ability to run locally developed scripts nevertheless, the <strong class="source-inline">RemoteSigned</strong> setting is a good approach. In this case, only local scripts (that is, scripts that weren't downloaded from the internet and signed) can be run; unsigned scripts from the internet will be blocked <span class="No-Break">from running.</span></p>
			<p>Use the <strong class="source-inline">Set-ExecutionPolicy</strong> cmdlet as<a id="_idIndexMarker106"/> an administrator to configure the Execution <span class="No-Break">Policy setting:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer030">
					<img alt="Figure 1.18 – Configuring the Execution Policy setting" src="image/B16679_01_018.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.18 – Configuring the Execution Policy setting</p>
			<p>The Execution Policy setting is being configured. Now you can run your own scripts and imported modules on <span class="No-Break">your system.</span></p>
			<h3>Windows PowerShell – configuring Execution Policy via Group Policy </h3>
			<p>If you don't <a id="_idIndexMarker107"/>want to set <a id="_idIndexMarker108"/>the Execution Policy setting for every machine in your organization manually, you can also configure it globally via <span class="No-Break">Group Policy.</span></p>
			<p>To configure Group Policy for <em class="italic">Windows PowerShell</em>, create a new <strong class="bold">Group Policy Object</strong> (<strong class="bold">GPO</strong>) that is<a id="_idIndexMarker109"/> linked to the root folder in which all your devices are located and that you want to configure Execution <span class="No-Break">Policy for.</span></p>
			<p>Then, navigate to <strong class="bold">Computer Configuration</strong> | <strong class="bold">Policies</strong> | <strong class="bold">Administrative Templates</strong> | <strong class="bold">Windows Components</strong> | <span class="No-Break"><strong class="bold">Windows PowerShell</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer031">
					<img alt="Figure 1.19 – Configuring the Execution Policy feature using GPO for Windows PowerShell" src="image/B16679_01_019.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.19 – Configuring the Execution Policy feature using GPO for Windows PowerShell</p>
			<p>Configure <a id="_idIndexMarker110"/>the <strong class="bold">Turn on Script Execution</strong> setting, and choose the <strong class="bold">Allow local scripts and remote signed scripts</strong> option, which<a id="_idIndexMarker111"/> configures Execution Policy <span class="No-Break">to </span><span class="No-Break"><strong class="bold">RemoteSigned</strong></span><span class="No-Break">.</span></p>
			<h3>PowerShell Core – configuring Execution Policy via Group Policy </h3>
			<p>Since <a id="_idIndexMarker112"/>Windows PowerShell <a id="_idIndexMarker113"/>and PowerShell Core are designed to run in parallel, you also need to configure the Execution Policy settings for <span class="No-Break">PowerShell Core.</span></p>
			<p>The Group Policy settings for PowerShell Core are located in the <span class="No-Break">following paths:</span></p>
			<ul>
				<li><strong class="bold">Computer Configuration</strong> | <strong class="bold">Administrative Templates</strong> | <span class="No-Break"><strong class="bold">PowerShell Core</strong></span></li>
				<li><strong class="bold">User Configuration</strong> | <strong class="bold">Administrative Templates</strong> | <span class="No-Break"><strong class="bold">PowerShell Core</strong></span><span class="No-Break">:</span></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer032">
					<img alt="Figure 1.20 – Configuring the Execution Policy setting using GPO for PowerShell Core" src="image/B16679_01_020.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.20 – Configuring the Execution Policy setting using GPO for PowerShell Core</p>
			<p>Configure<a id="_idIndexMarker114"/> the settings of your <a id="_idIndexMarker115"/>choice, and apply the changes. In this case, the settings configured in the Windows PowerShell Group Policy will <span class="No-Break">be applied.</span></p>
			<h3>Execution Policy is not a security control – avoiding Execution Policy</h3>
			<p>As <a id="_idIndexMarker116"/>mentioned earlier, Execution Policy is a feature that keeps you from running scripts unintentionally. It is not a feature designed to protect you from malicious users or from code run directly on <span class="No-Break">the machine.</span></p>
			<p>Even if Execution Policy is configured as strictly as possible, you can still type in any code into a <span class="No-Break">PowerShell prompt.</span></p>
			<p>Essentially, when we speak of <em class="italic">bypassing Execution Policy</em>, we are simply <strong class="bold">avoiding</strong> Execution Policy, as you will see in this section. Although it's not a <em class="italic">real hack</em>, some people in the security community still like to call avoiding Execution Policy <span class="No-Break">a </span><span class="No-Break"><em class="italic">bypass</em></span><span class="No-Break">.</span></p>
			<p>Avoiding Execution Policy is quite easy – the easiest way is by using its own <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Bypass</strong></span><span class="No-Break"> parameter.</span></p>
			<p>This parameter was introduced when people started to think of Execution Policy as a security control. The PowerShell team wanted to avoid this misconception so that organizations were not lulled into a false sense <span class="No-Break">of security.</span></p>
			<p>I created a simple script that just writes <strong class="bold">Hello World!</strong> into the console, which you can find on GitHub <span class="No-Break">at </span><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter01/HelloWorld.ps1</span><span class="No-Break">.</span></p>
			<p>With Execution Policy set to restricted, I get an error message when I try to run the script without any <span class="No-Break">additional parameters.</span></p>
			<p>However, if I run the script using <strong class="source-inline">powershell.exe</strong> as an administrator with the <strong class="source-inline">-ExecutionPolicy</strong> parameter set to <strong class="source-inline">Bypass</strong>, the script runs without <span class="No-Break">any issues:</span></p>
			<pre class="source-code">
&gt; powershell.exe -ExecutionPolicy Bypass -File .\HelloWorld.ps1
Hello World!</pre>
			<p>If Execution Policy is configured via <em class="italic">Group Policy</em>, it <strong class="bold">can't be avoided</strong> just by using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Bypass</strong></span><span class="No-Break"> parameter.</span></p>
			<p>As Execution Policy only restricts the execution of scripts, another way is to simply pass the content of the script to <strong class="source-inline">Invoke-Expression</strong>. Again, the content of the script is run without any issues – even if Execution Policy was configured using <span class="No-Break">Group Policy:</span></p>
			<pre class="source-code">
Get-Content .\HelloWorld.ps1 | Invoke-Expression
Hello World!</pre>
			<p>Piping the content of the script into <strong class="source-inline">Invoke-Expression</strong> causes the content of the script to be handled as if the commands were executed locally using the command line; this bypasses Execution Policy and Execution Policy only applies to executing scripts and not <span class="No-Break">local commands.</span></p>
			<p>Those are only<a id="_idIndexMarker117"/> some examples out of many ways to avoid <strong class="source-inline">ExecutionPolicy</strong>, there are some examples of avoiding <strong class="source-inline">ExecutionPolicy</strong> in <a href="B16679_08_Final_PD.xhtml#_idTextAnchor204"><em class="italic">"8" on page </em><em class="italic">337</em></a>, <em class="italic">Red Team Tasks and Cookbook</em>. Therefore, don't be under the false impression that <strong class="source-inline">ExecutionPolicy</strong> protects you <span class="No-Break">from attackers.</span></p>
			<p>If you are interested in what mitigations can help you to improve the security of your environment, you can read more about it in <em class="italic">Section 3</em>, <em class="italic">Securing PowerShell – Effective Mitigations </em><span class="No-Break"><em class="italic">in Detail</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor029"/>Help system</h2>
			<p>To be successful in PowerShell, understanding and using the help system is key. To get started, you will find some useful advice in this book. As I will cover only the basics and mostly concentrate on scripting for cybersecurity, I advise you to also review the documentation <a id="_idIndexMarker118"/>on the PowerShell help system. This can be found <span class="No-Break">at </span><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/02-help-system</span><span class="No-Break">.</span></p>
			<p>There are three functions that make your life easier when you are working <span class="No-Break">with PowerShell:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Get-Help</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Get-Command</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Get-Member</strong></span></li>
			</ul>
			<p>Let's take a deeper look at how to use them and how they can <span class="No-Break">help you.</span></p>
			<h3>Get-Help</h3>
			<p>If you are familiar<a id="_idIndexMarker119"/> with working on Linux systems, <strong class="source-inline">Get-Help</strong> is similar <a id="_idIndexMarker120"/>to what the <strong class="source-inline">man</strong> pages in Linux are, that is, a collection of how-to pages and tutorials on how to use certain commands in the best <span class="No-Break">way possible.</span></p>
			<p>If you don't know how<a id="_idIndexMarker121"/> to use a command, just use <strong class="source-inline">Get-Help &lt;command&gt;</strong> and you will know which options it provides and how to <span class="No-Break">use it.</span></p>
			<p>When you are<a id="_idIndexMarker122"/> running <strong class="source-inline">Get-Help</strong> for the first time on your computer, you might only see a very restricted version of the help pages, along with a remark that states that the help files are missing for this cmdlet on <span class="No-Break">this computer:</span></p>
			<pre class="source-code">
Get-Help -Name Get-Help</pre>
			<p>As mentioned, the output only displays partial help: </p>
			<div>
				<div class="IMG---Figure" id="_idContainer033">
					<img alt="Figure 1.21 – Output of Get-Help when the ﻿help files are missing for a cmdlet" src="image/B16679_01_021.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.21 – Output of Get-Help when the help files are missing for a cmdlet</p>
			<p>Therefore, first, you need to update your help files. An internet connection is required. Open PowerShell as an administrator and run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
Update-Help</pre>
			<p>You should see an overlay that shows you the status of <span class="No-Break">the update:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer034">
					<img alt="Figure 1.22 – Updating ﻿help" src="image/B16679_01_022.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.22 – Updating help</p>
			<p>As soon as the update is finished, you can use all the help files as intended. As help files get quickly outdated, it makes sense to update them regularly or even create a scheduled task to update the help files on <span class="No-Break">your system.</span></p>
			<p class="callout-heading">Did You Know?</p>
			<p class="callout">PowerShell help files are not deployed by default because the files get outdated so quickly. As it makes no sense to ship outdated help files, they are not installed <span class="No-Break">by default.</span></p>
			<p>You can <a id="_idIndexMarker123"/>use the<a id="_idIndexMarker124"/> following <span class="No-Break"><strong class="source-inline">Get-Help</strong></span><span class="No-Break"> parameters:</span></p>
			<ul>
				<li><strong class="source-inline">Detailed</strong>: This displays the basic help page and adds parameter descriptions along <span class="No-Break">with examples.</span></li>
				<li><strong class="source-inline">Examples</strong>: This only displays the <span class="No-Break">example section.</span></li>
				<li><strong class="source-inline">Full</strong>: This displays the complete <span class="No-Break">help page.</span></li>
				<li><strong class="source-inline">Online</strong>: This displays the online version of the specified help page. It does not work in a <span class="No-Break">remote session.</span></li>
				<li><strong class="source-inline">Parameter</strong>: This parameter only displays help for the <span class="No-Break">specified parameter.</span></li>
				<li><strong class="source-inline">ShowWindow</strong>: This displays the help page in a separate window. It not only provides better reading comfort but also allows you to search and configure <span class="No-Break">the settings.</span></li>
			</ul>
			<p>The easiest way to get all the information that the help file provides is by using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Full</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
Get-Help -Name Get-Content -Full</pre>
			<p>Running this command gets you the full help pages for the <span class="No-Break"><strong class="source-inline">Get-Content</strong></span><span class="No-Break"> function:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer035">
					<img alt="Figure 1.23 – The full Help pages for the Get-Content function" src="image/B16679_01_023.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.23 – The full Help pages for the Get-Content function</p>
			<p>Please also review the official PowerShell documentation for more advanced ways of <span class="No-Break"><strong class="source-inline">Get-Help</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/get-help"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/get-help</span></a><span class="No-Break">.</span></p>
			<h3>Get-Command</h3>
			<p><strong class="source-inline">Get-Command</strong> gets <a id="_idIndexMarker125"/>you all commands that are currently<a id="_idIndexMarker126"/> installed on the computer, including aliases, applications, cmdlets, filters, functions, <span class="No-Break">and scripts:</span></p>
			<pre class="source-code">
Get-Command</pre>
			<p>Additionally, it can show you which commands are available for a certain module. In this case, we investigate the <strong class="source-inline">EventList</strong> module that we have installed from the <strong class="bold">PowerShell Gallery</strong>, which<a id="_idIndexMarker127"/> is a central repository for the modules, scripts, and other <span class="No-Break">PowerShell-related resources:</span></p>
			<pre class="source-code">
&gt; Get-Command -Module EventList
CommandType Name                                Version    Source
----------- ----                                -------    ------
Function    Add-EventListConfiguration          2.0.0      EventList
Function    Get-AgentConfigString               2.0.0      EventList
Function    Get-BaselineEventList               2.0.0      EventList
Function    Get-BaselineNameFromDB              2.0.0      EventList
Function    Get-GroupPolicyFromMitreTechniques  2.0.0      EventList
Function    Get-MitreEventList                  2.0.0      EventList
Function    Get-SigmaPath                       2.0.0      EventList
Function    Get-SigmaQueries                    2.0.0      EventList
Function    Get-SigmaSupportedSiemFromDb        2.0.0      EventList
Function    Import-BaselineFromFolder           2.0.0      EventList
Function    Import-YamlCofigurationFromFolder   2.0.0      EventList
Function    Open-EventListGUI                   2.0.0      EventList
Function    Remove-AllBaselines                 2.0.0      EventList
Function    Remove-AllYamlConfigurations        2.0.0      EventList
Function    Remove-EventListConfiguration       2.0.0      EventList
Function    Remove-OneBaseline                  2.0.0      EventList</pre>
			<p><strong class="source-inline">Get-Command</strong> can <a id="_idIndexMarker128"/>be also very helpful if you are looking <a id="_idIndexMarker129"/>for a specific cmdlet, but you can't remember its name. For example, if you want to find out all the cmdlets that are available on your computer that have <strong class="source-inline">Alias</strong> in their name, <strong class="source-inline">Get-Command</strong> can be <span class="No-Break">very helpful:</span></p>
			<pre class="source-code">
&gt; Get-Command -Name "*Alias*" -CommandType Cmdlet
CommandType  Name           Version    Source
-----------  ----           -------    ------
Cmdlet       Export-Alias   3.1.0.0    Microsoft.PowerShell.Utility
Cmdlet       Get-Alias      3.1.0.0    Microsoft.PowerShell.Utility
Cmdlet       Import-Alias   3.1.0.0    Microsoft.PowerShell.Utility
Cmdlet       New-Alias      3.1.0.0    Microsoft.PowerShell.Utility
Cmdlet       Set-Alias      3.1.0.0    Microsoft.PowerShell.Utility</pre>
			<p>If you don't remember a certain command exactly, use the <strong class="source-inline">-UseFuzzyMatching</strong> parameter. This shows you all of the <span class="No-Break">related commands:</span></p>
			<pre class="source-code">
Get-Command get-commnd -UseFuzzyMatching
CommandType   Name         Version   Source
-----------   ----         -------   ------
Cmdlet        Get-Command  7.1.3.0   Microsoft.PowerShell.Core
Application   getconf      0.0.0.0   /usr/bin/getconf
Application   command      0.0.0.0   /usr/bin/command</pre>
			<p>Additionally, please<a id="_idIndexMarker130"/> review the documentation to get more advanced examples on how <strong class="source-inline">Get-Command</strong><a id="_idIndexMarker131"/> can help <span class="No-Break">you: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/get-command"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/get-command</span></a><span class="No-Break">.</span></p>
			<h3>Get-Member</h3>
			<p><strong class="source-inline">Get-Member</strong> helps<a id="_idIndexMarker132"/> you to display the members <a id="_idIndexMarker133"/>within <span class="No-Break">an object.</span></p>
			<p>In PowerShell, everything is an object, even a simple string. <strong class="source-inline">Get-Member</strong> is very useful for seeing which operations <span class="No-Break">are possible.</span></p>
			<p>So, if you want to see what operations are possible when using your <strong class="source-inline">"Hello World!"</strong> string, just type in <span class="No-Break">the following:</span></p>
			<pre class="source-code">
"Hello World!" | Get-Member</pre>
			<p>All available methods and properties will be displayed, and you can choose from the list the one that best fits your <span class="No-Break">use case:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer036">
					<img alt="Figure 1.24 – Displaying all the available members of a string" src="image/B16679_01_024.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.24 – Displaying all the available members of a string</p>
			<p>In the <a id="_idIndexMarker134"/>preceding example, I also inserted the <strong class="source-inline">| Sort-Object Name</strong> string. It sorts the output alphabetically and helps you to quickly find a method or property <span class="No-Break">by name.</span></p>
			<p>If <strong class="source-inline">Sort-Object</strong> was <a id="_idIndexMarker135"/>not specified, <strong class="source-inline">Get-Member</strong> would have sorted the output alphabetically by <strong class="source-inline">MemberType</strong> (that is, <strong class="source-inline">Method</strong>, <strong class="source-inline">ParameterizedProperty</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Property</strong></span><span class="No-Break">).</span></p>
			<p>After you have chosen the operation that you want to run, you can use it by adding<strong class="source-inline">.</strong>(a <em class="italic">dot</em>), followed by the <em class="italic">operation</em>. So, if you want to find out the length of your string, add the <span class="No-Break"><strong class="source-inline">Length</strong></span><span class="No-Break"> operation:</span></p>
			<pre class="source-code">
&gt; ("Hello World!").Length
12</pre>
			<p>Of course, you can also work with variables, numbers, and all <span class="No-Break">other objects.</span></p>
			<p>To display the data type of a variable, you can use <strong class="source-inline">GetType()</strong>. In this example, we use <strong class="source-inline">GetType()</strong> to find out <a id="_idIndexMarker136"/>that the data type of the <strong class="source-inline">$x</strong> variable <span class="No-Break">is integer:</span></p>
			<pre class="source-code">
&gt; $x = 4
&gt; $x.GetType()
IsPublic IsSerial Name  BaseType
-------- -------- ----  --------
True     True     Int32 System.ValueType</pre>
			<p>To get<a id="_idIndexMarker137"/> more <a id="_idIndexMarker138"/>advanced examples regarding how to use <strong class="source-inline">Get-Member</strong>, please also make sure that you review the official documentation <span class="No-Break">at </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/get-member"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/get-member</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor030"/>PowerShell versions</h2>
			<p>As PowerShell functionalities<a id="_idIndexMarker139"/> are often tied to a certain version, it might be useful to check the PowerShell version that is installed on <span class="No-Break">your system.</span></p>
			<p>You can use the <strong class="source-inline">$PSVersionTable.PSVersion</strong> <span class="No-Break">environment variable:</span></p>
			<pre class="source-code">
&gt; $PSVersionTable.PSVersion
Major  Minor  Build  Revision
-----  -----  -----  --------
5      1      19041  610</pre>
			<p>In this example, PowerShell 5.1 has <span class="No-Break">been installed.</span></p>
			<h3>Exploring security features added with each version</h3>
			<p>PowerShell is <a id="_idIndexMarker140"/>backward compatible with earlier versions. Therefore, it makes sense to always upgrade to the <span class="No-Break">latest version.</span></p>
			<p>But let's have a look at which security-related features were made available with which version. This overview <a id="_idIndexMarker141"/>should serve only as a reference, so I won't dive into every feature <span class="No-Break">in detail.</span></p>
			<h4>PowerShell v1</h4>
			<p>The first <a id="_idIndexMarker142"/>PowerShell version, PowerShell v1, was released in 2006 as a standalone version. It introduced the following list of <span class="No-Break">security-related features:</span></p>
			<ul>
				<li>Signed scripts and <a id="_idIndexMarker143"/>PowerShell <strong class="bold">Subject Interface </strong><span class="No-Break"><strong class="bold">Package</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SIP</strong></span><span class="No-Break">).</span></li>
				<li><strong class="source-inline">Get-AuthenticodeSignature</strong>, <strong class="source-inline">*-Acl</strong>, and <span class="No-Break"><strong class="source-inline">Get-PfxCertificate cmdlets.</strong></span></li>
				<li><span class="No-Break">Execution Policy.</span></li>
				<li>Requiring <em class="italic">intent</em> to run scripts from the current <span class="No-Break">directory (</span><span class="No-Break"><strong class="source-inline">./foo.ps1</strong></span><span class="No-Break">).</span></li>
				<li>Scripts are not run if they <span class="No-Break">are double-clicked.</span></li>
				<li>PowerShell Engine logging: Some commands could be logged via <strong class="source-inline">LogPipelineExecutionDetails</strong>, although this is difficult <span class="No-Break">to configure.</span></li>
				<li>Built-in protection from scripts that are sent directly via email: This intentionally adds PowerShell extensions to Windows' <em class="italic">Unsafe to </em><span class="No-Break"><em class="italic">email</em></span><span class="No-Break"> list.</span></li>
				<li><strong class="bold">Software Restriction Policies</strong> (<strong class="bold">SRPs</strong>) and <a id="_idIndexMarker144"/><span class="No-Break">AppLocker support.</span></li>
			</ul>
			<h4>PowerShell v2</h4>
			<p>In 2009, the<a id="_idIndexMarker145"/> second version of PowerShell (PowerShell v2) was released. This version was included in the Windows 7 OS by default. It offered the following list <span class="No-Break">of features:</span></p>
			<ul>
				<li><span class="No-Break">Eventing</span></li>
				<li><span class="No-Break">Transactions</span></li>
				<li>Changes within <span class="No-Break">Execution Policy</span><ul><li><em class="italic">Scopes</em> to Execution Policy (the process, user, <span class="No-Break">and machine)</span></li><li>The <em class="italic">ExecutionPolicy Bypass</em> implementation to make people stop treating it like a <span class="No-Break">security control</span></li></ul></li>
				<li>PowerShell <span class="No-Break">remoting security</span></li>
				<li>Modules and <a id="_idIndexMarker146"/><span class="No-Break">module security</span></li>
				<li>IIS-hosted <span class="No-Break">remoting endpoints</span><ul><li>This was very difficult to configure and required DIY <span class="No-Break">constrained endpoints.</span></li></ul></li>
				<li><span class="No-Break"><strong class="source-inline">Add-Type</strong></span></li>
				<li><span class="No-Break">Data language</span></li>
			</ul>
			<h4>PowerShell v3</h4>
			<p>PowerShell v3, released in 2012, was included by default in the Windows 8 OS. It <a id="_idIndexMarker147"/>offered the following list <span class="No-Break">of features:</span></p>
			<ul>
				<li>Unblock-File and alternate data stream management in <span class="No-Break">core cmdlets.</span></li>
				<li>The initial implementation of constrained language (for <span class="No-Break">Windows RT).</span></li>
				<li>Registry settings for module logging (<span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">LogPipelineExecutionDetails</strong></span><span class="No-Break">).</span></li>
				<li>Constrained endpoints: These were still hard to configure, but a <em class="italic">more</em> admin-friendly version of IIS-hosted <span class="No-Break">remoting endpoints.</span></li>
			</ul>
			<h4>PowerShell v4</h4>
			<p>Following <a id="_idIndexMarker148"/>PowerShell version v3, PowerShell v4 was just released in 2013 – 1 year after the former version – and was included, by default, in the Windows 8.1 OS. Its features are listed <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break">Workflows.</span></li>
				<li>DSC security, especially for signed <span class="No-Break">policy documents.</span></li>
				<li>PowerShell web <span class="No-Break">services security.</span></li>
				<li>With KB3000850, many <a id="_idIndexMarker149"/>significant security features could be ported into PowerShell version 4, such as module logging, script block logging, transcription, and more. However, those features were included, by default, in PowerShell <span class="No-Break">version 5.</span></li>
			</ul>
			<h4>PowerShell v5</h4>
			<p>PowerShell v5 <a id="_idIndexMarker150"/>was released in 2015 and was included, by default, in the Windows 10 OS. A lot of security features that are available nowadays in PowerShell were provided with this release. They are listed <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break">Security transparency</span></li>
				<li><span class="No-Break"><strong class="bold">AMSI</strong></span></li>
				<li><span class="No-Break">Transcription</span></li>
				<li>Script <span class="No-Break">block logging</span></li>
				<li><span class="No-Break">Module logging</span></li>
				<li>Protected <span class="No-Break">event logging</span></li>
				<li><span class="No-Break">JEA</span></li>
				<li>Local JEA (for interactive <span class="No-Break">constrained/kiosk modes)</span></li>
				<li>Secure code <span class="No-Break">generation APIs</span></li>
				<li><span class="No-Break">Constrained language</span></li>
				<li><strong class="bold">Cryptographic Message Syntax</strong> (<strong class="bold">CMS</strong>) cmdlets, <strong class="source-inline">*-FileCatalog</strong> cmdlets, <strong class="source-inline">ConvertFrom-SddlString</strong>, <strong class="source-inline">Format-Hex</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Get-FileHash</strong></span></li>
				<li>PowerShell <span class="No-Break">Gallery security</span></li>
				<li><span class="No-Break"><strong class="source-inline">Revoke-Obfuscation</strong></span></li>
				<li>The Injection <span class="No-Break">Hunter module</span></li>
				<li>PowerShell <a id="_idIndexMarker151"/><span class="No-Break">classes security</span></li>
			</ul>
			<h4>PowerShell v6</h4>
			<p>With PowerShell v6, which <a id="_idIndexMarker152"/>was released as a standalone in 2018, the PowerShell team was mostly focused on the effort to make PowerShell available cross-platform as open source software. PowerShell v6 introduced the first macOS and Unix shell to offer full security transparency. Its features include <span class="No-Break">the following:</span></p>
			<ul>
				<li>OpenSSH <span class="No-Break">on Windows</span></li>
				<li>Cross-platform parity: full security transparency <span class="No-Break">via Syslog</span></li>
			</ul>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor031"/>PowerShell editors</h2>
			<p>Before we get <a id="_idIndexMarker153"/>started, you might want to choose an editor. Before you start typing your scripts into <strong class="source-inline">notepad.exe</strong> or want to use PowerShell ISE for PowerShell 7, let's take a look at what PowerShell editors you can use for free and what the potential <span class="No-Break">downsides are.</span></p>
			<h3>Windows PowerShell ISE</h3>
			<p>The<a id="_idIndexMarker154"/> <strong class="bold">Windows PowerShell</strong> <strong class="bold">Integrated Scripting Environment</strong> (<strong class="bold">ISE</strong>) is a <a id="_idIndexMarker155"/>host application that is integrated within Microsoft Windows systems. As this application is pre-installed, this makes it very easy for beginners to simply open the Windows PowerShell ISE and type in their very <span class="No-Break">first script.</span></p>
			<p>The downside of the <a id="_idIndexMarker156"/>Windows PowerShell ISE is that, currently, it <strong class="bold">does not support PowerShell Core</strong> – and currently, there's no intention by the PowerShell team to <span class="No-Break">add support.</span></p>
			<p>To open it, you can either open the Windows Start menu and search for <strong class="source-inline">PowerShell ISE</strong>, or you can run it by opening the command line, using the <em class="italic">Windows key</em> + <em class="italic">R</em> shortcut, and typing in <strong class="source-inline">powershell_ise</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">powershell_ise.exe</strong></span><span class="No-Break">.</span></p>
			<p>When you start the <a id="_idIndexMarker157"/>Windows PowerShell ISE, you will only see a PowerShell command line, the menu, and the available commands. Before you can use the editor, you either need to open a file or create a new <span class="No-Break">blank file.</span></p>
			<p>You can also click on the little drop-down arrow on the right-hand side to expand the scripting pane or enable the scripting pane from the <span class="No-Break"><strong class="bold">View</strong></span><span class="No-Break"> menu:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer037">
					<img alt="Figure 1.25 – Windows PowerShell ISE after opening a new file" src="image/B16679_01_025.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.25 – Windows PowerShell ISE after opening a new file</p>
			<p>On Windows 10 devices, the default location of the PowerShell ISE is under <span class="No-Break">the following:</span></p>
			<ul>
				<li>Windows PowerShell ISE: </li>
			</ul>
			<p><strong class="source-inline">%</strong><span class="No-Break"><strong class="source-inline">windir%\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe</strong></span></p>
			<ul>
				<li>Windows PowerShell ISE (x86): </li>
			</ul>
			<p><strong class="source-inline">%</strong><span class="No-Break"><strong class="source-inline">windir%\syswow64\WindowsPowerShell\v1.0\PowerShell_ISE.exe</strong></span></p>
			<p class="callout-heading">Where Do Those Nasty Errors Come From?</p>
			<p class="callout">When working with PowerShell or the PowerShell ISE, sometimes, errors can appear that are caused by the fact that you had insufficient permissions. To overcome that issue, start PowerShell (ISE) as an administrator if your use case <span class="No-Break">requires it.</span></p>
			<h4>Windows PowerShell ISE commands</h4>
			<p>On the<a id="_idIndexMarker158"/> right-hand pane, you can browse through all commands and modules that are available in this session. Especially if you are not that familiar with existing cmdlets, this can help you <span class="No-Break">a lot.</span></p>
			<h3>Visual Studio Code</h3>
			<p>Yes, you<a id="_idIndexMarker159"/> could just use Windows PowerShell or Windows PowerShell ISE to work with PowerShell 5.1. But honestly, you should use PowerShell Core <span class="No-Break">7 instead.</span></p>
			<p>You want to <a id="_idIndexMarker160"/>write complex scripts, functions, and modules, and, therefore, you want to use a good editor that supports you <span class="No-Break">while scripting.</span></p>
			<p>Visual Studio Code is not the only recommended editor to use to edit PowerShell, but it comes for free as an open source and <span class="No-Break">cross-platform version.</span></p>
			<p>It was developed <a id="_idIndexMarker161"/>by Microsoft and can be downloaded from the official Visual Studio Code web page <span class="No-Break">at </span><a href="https://code.visualstudio.com/"><span class="No-Break">https://code.visualstudio.com/</span></a><span class="No-Break">.</span></p>
			<h4>Visual Studio versus Visual Studio Code</h4>
			<p>When<a id="_idIndexMarker162"/> you search for Visual Studio Code, it often happens that you stumble onto Visual Studio, which is – despite the name – a completely <span class="No-Break">different product.</span></p>
			<p>Visual Studio is a full-featured <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>), which consists of multiple tools that help a developer to develop, debug, compile, and deploy their code. Visual Studio <a id="_idIndexMarker163"/>even contains a tool to easily design <span class="No-Break"><strong class="bold">GUI</strong></span><span class="No-Break"> components.</span></p>
			<p>Visual Studio Code is an editor that provides a lot of features, but in the end, it is very useful for code developers. Additionally, it provides Git integration, which makes it very easy to connect with your versioning system to track changes and eventually <span class="No-Break">revert them.</span></p>
			<p>To summarize, Visual Studio is a big suite that was designed to develop apps for Android, iOS, Mac, Windows, the web, and the cloud, as Microsoft states. In comparison, Visual Studio Code is a code editor that supports thousands of extensions and provides many features. Visual Studio does not run on Linux systems, while Visual Studio Code works on <span class="No-Break">cross-platform systems.</span></p>
			<p>As Visual Studio is a full-featured IDE with many features, it might take longer to load when starting the program. So, for working with PowerShell, I recommend using Visual Studio Code, which is not only my preferred editor but also the recommended editor <span class="No-Break">for PowerShell.</span></p>
			<h4>Working with Visual Studio Code</h4>
			<p>Visual Studio Code <a id="_idIndexMarker164"/>offers some great benefits when working with PowerShell. The PowerShell team has even released a guide on how to leverage Visual Studio Code for your PowerShell development. You can find it <span class="No-Break">at </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode</span></a><span class="No-Break">.</span></p>
			<p>Once you have installed Visual Studio Code onto your OS, this is what the UI should look like when you <span class="No-Break">open it:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer038">
					<img alt="Figure 1.26 – The Visual Studio Code editor" src="image/B16679_01_026.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.26 – The Visual Studio Code editor</p>
			<p>If you want to<a id="_idIndexMarker165"/> get the most out of Visual Studio Code, make sure that you follow the documentation. Nevertheless, here are my must-haves when working on my PowerShell projects in Virtual <span class="No-Break">Studio Code.</span></p>
			<h4>Installing the PowerShell extension</h4>
			<p>To properly <a id="_idIndexMarker166"/>work with PowerShell using Visual Studio Code, the PowerShell extension should be installed <span class="No-Break">and activated.</span></p>
			<p>If you start a new project or file and use PowerShell code before installing the PowerShell extension, Visual Studio Code suggests installing the PowerShell extension. Confirm with <strong class="bold">Yes</strong> to the prompt on the installation of the <span class="No-Break">PowerShell extension.</span></p>
			<p>If you want to download the extension manually, you can download the Visual Studio PowerShell extension <a id="_idIndexMarker167"/>via the following <span class="No-Break">link: </span><a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell"><span class="No-Break">https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell</span></a><span class="No-Break">.</span></p>
			<p>Launch the quick opening option by pressing <em class="italic">Ctrl</em> + <em class="italic">P</em> and type in <strong class="source-inline">ext install powershell</strong>. Then, <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></p>
			<p>The extensions pane opens. Search for <strong class="source-inline">PowerShell</strong> and click on the <strong class="bold">Install</strong> button. Follow <span class="No-Break">the instructions.</span></p>
			<p>After the<a id="_idIndexMarker168"/> installation, the PowerShell extension is automatically displayed. If you want to access it later again, you can either open the <strong class="bold">Extensions</strong> pane directly from the menu or by using the <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <span class="No-Break"><em class="italic">X</em></span><span class="No-Break"> shortcut:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer039">
					<img alt="Figure 1.27 – Visual Studio Code: Installing the PowerShell extension" src="image/B16679_01_027.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.27 – Visual Studio Code: Installing the PowerShell extension</p>
			<p class="callout-heading">Automated Formatting in Visual Studio Code</p>
			<p class="callout">By <a id="_idIndexMarker169"/>pressing <em class="italic">Alt</em> + <em class="italic">Shift</em> + <em class="italic">F</em>, Visual Studio Code automatically formats your current code. You can specify your formatting preferences by adjusting your <span class="No-Break">workspace configuration.</span></p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor032"/>Summary</h1>
			<p>In this chapter, you learned how to get started when working with PowerShell for cybersecurity. You obtained a high-level understanding of OOP and its four main principles. You learned what properties and methods are and how they apply to <span class="No-Break">an object.</span></p>
			<p>You now understand how to install the latest version of PowerShell Core and understand how to perform some basic tasks such as working with the history, clearing the screen, and <span class="No-Break">canceling commands.</span></p>
			<p>You have learned that Execution Policy is only a feature that keeps you from running scripts unintentionally, and it's important to understand that it is not a security control to prevent you <span class="No-Break">from attackers.</span></p>
			<p>You learned how to help yourself and obtain more information about cmdlets, functions, methods, and properties, using the <span class="No-Break">help system.</span></p>
			<p>Now that you have also found and installed your preferred PowerShell editor, you are ready to get started, learn about the PowerShell scripting fundamentals, and write your first scripts in the <span class="No-Break">next chapter.</span></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor033"/>Further reading</h1>
			<p>If you want to explore some of the topics that were mentioned in this chapter, use <span class="No-Break">these resources:</span></p>
			<ul>
				<li>Getting Started with <span class="No-Break">PowerShell: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/01-getting-started"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/01-getting-started</span></a></li>
				<li>Installing and upgrading to PowerShell version <span class="No-Break">5.1: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/windows-powershell/install/installing-windows-powershell"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/windows-powershell/install/installing-windows-powershell</span></a></li>
				<li>Migrating from Windows PowerShell 5.1 to PowerShell <span class="No-Break">7: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/migrating-from-windows-powershell-51-to-powershell-7"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/install/migrating-from-windows-powershell-51-to-powershell-7</span></a><span class="No-Break">.</span></li>
				<li>Installing the latest PowerShell release on <span class="No-Break">Windows: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows</span></a></li>
				<li>Installing PowerShell on <span class="No-Break">Linux: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux</span></a></li>
				<li>Installing PowerShell on <span class="No-Break">macOS</span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-macos"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-macos</span></a></li>
				<li>Installing PowerShell on <span class="No-Break">ARM: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/powershell-core-on-arm"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/install/powershell-core-on-arm</span></a></li>
				<li>Using PowerShell in <span class="No-Break">Docker: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/powershell-in-docker"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/install/powershell-in-docker</span></a></li>
				<li>PowerShell ♥ the Blue <span class="No-Break">Team: </span><a href="https://devblogs.microsoft.com/powershell/powershell-the-blue-team/"><span class="No-Break">https://devblogs.microsoft.com/powershell/powershell-the-blue-team/</span></a></li>
				<li>Using Visual Studio Code for PowerShell <span class="No-Break">Development: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode</span></a></li>
			</ul>
			<p>You can also find all the links mentioned in this chapter in the GitHub repository for <a href="B16679_01_Final_PD.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. There is no need to manually type in every <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter01/Links.md"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter01/Links.md</span></a><span class="No-Break">.</span></p>
		</div>
	</body></html>