- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Getting Started with PowerShell
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PowerShell 入门
- en: This introductory chapter will take a look at the fundamentals of working with
    PowerShell. It is meant as a basic primer on PowerShell for cybersecurity and
    acts as an introduction to **object-oriented programming** (**OOP**) and how to
    get started when working with PowerShell.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本简介章节将介绍使用 PowerShell 的基本概念。它作为网络安全领域 PowerShell 的基础入门，并且作为 **面向对象编程**（**OOP**）的介绍，以及如何开始使用
    PowerShell。
- en: This chapter complements [*Chapter 2*](B16679_02_Final_PD.xhtml#_idTextAnchor034),
    *PowerShell Scripting Fundamentals*, in which we will dive deeper into the scripting
    part. Both chapters should help you to get started and act as a reference when
    working with later chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是 [*第二章*](B16679_02_Final_PD.xhtml#_idTextAnchor034) 的补充，*PowerShell 脚本编写基础*，我们将在该章深入探讨脚本部分。这两章应该能帮助你入门，并作为你在后续章节工作时的参考。
- en: You will learn the basics of what PowerShell is, its history, and why it has
    gained more importance in the last few years when it comes to cybersecurity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习 PowerShell 的基本知识，它的历史，以及为什么在过去几年中，它在网络安全领域变得越来越重要。
- en: 'You will get an overview of the editors and how to help yourself using existing
    functionalities. In this chapter, you will gain a deeper understanding of the
    following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将概述编辑器，并学习如何通过现有功能自助帮助自己。在本章中，你将深入了解以下主题：
- en: What is PowerShell?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 PowerShell？
- en: The history of PowerShell
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 的历史
- en: Why is PowerShell useful for cybersecurity?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 PowerShell 对网络安全有用？
- en: Introduction to OOP
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）简介
- en: Windows PowerShell and PowerShell Core
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows PowerShell 和 PowerShell Core
- en: Execution policy
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行策略
- en: Help system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助系统
- en: PowerShell versions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 版本
- en: PowerShell editors
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 编辑器
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To get the most out of this chapter, ensure that you have the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，请确保你拥有以下内容：
- en: PowerShell 7.3 and above
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 7.3 及以上版本
- en: Visual Studio Code installed
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 Visual Studio Code
- en: 'Access to the GitHub repository for **Chapter01**:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 **第一章** 的 GitHub 仓库访问权限：
- en: '[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter01](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter01)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter01](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter01)'
- en: What is PowerShell?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 PowerShell？
- en: PowerShell is a scripting framework and command shell, built on .NET. It is
    implemented, by default, on Windows **Operating Systems** (**OSs**). It is object-based,
    which means that everything you work with (such as variables, input, and more)
    has properties and methods. That opens up a lot of possibilities when working
    with PowerShell.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 是一个脚本框架和命令行外壳，基于 .NET 构建。默认情况下，它在 Windows **操作系统**（**OS**）上实现。它是基于对象的，这意味着你所处理的所有事物（例如变量、输入等）都有属性和方法。这为使用
    PowerShell 提供了很多可能性。
- en: Additionally, PowerShell has a pipeline and allows you to pipe input into other
    commands to reuse it. This combines the advantages of a command line-based script
    language with an object-oriented language. And on top of this, it has a built-in
    help system that allows you to help yourself while working on the console.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，PowerShell 还具有管道功能，允许将输入传递到其他命令以供重用。这将基于命令行的脚本语言的优势与面向对象语言结合在一起。而且，它还内置了帮助系统，让你在使用控制台时可以自助获取帮助。
- en: PowerShell does not exclusively run on Windows OSs. Since PowerShell Core was
    released in 2016, it can run on any OS, including Linux and macOS devices.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 不仅仅运行在 Windows 操作系统上。自 2016 年发布 PowerShell Core 后，它可以在任何操作系统上运行，包括
    Linux 和 macOS 设备。
- en: It helps security professionals to get a lot of work done in a very short space
    of time. Not only do blue teamers find it useful, but also red teamers. As with
    every feature that provides a lot of capabilities and enables you to do your daily
    work in a more efficient way, it can be used for good and bad purposes. It can
    be a mighty tool for professionals, but as usual, security professionals need
    to do their part to secure their environments so that existing tools and machines
    will not be abused by adversaries.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 它帮助安全专业人员在非常短的时间内完成大量工作。不仅蓝队人员觉得它有用，红队人员也同样如此。就像每个提供大量功能并使你以更高效的方式完成日常工作的特性一样，PowerShell
    既可以用于正当目的，也可以用于不当用途。它对于专业人员来说是一个强大的工具，但像往常一样，安全专业人员需要做好自己的工作，保护自己的环境，以免现有工具和机器被对手滥用。
- en: But first, let's take a look at how PowerShell was born and how it developed
    over the years.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们看看 PowerShell 是如何诞生的，以及它多年来是如何发展的。
- en: The history of PowerShell
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell 的历史
- en: 'Before PowerShell was created, there were already **Command Line Interfaces**
    (**CLIs**) available, shipped with each OS to manage the system via command line:
    **COMMAND.COM** was the default in MS DOS and Windows 9.x, while **cmd.exe** was
    the default in the Windows NT family. The latter, **cmd.exe**, is still integrated
    within modern Windows OSs such as Windows 10.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 创建之前，已经有了 **命令行界面**（**CLIs**），每个操作系统都自带命令行工具来管理系统：**COMMAND.COM**
    是 MS DOS 和 Windows 9.x 的默认工具，而 **cmd.exe** 是 Windows NT 系列的默认工具。后者 **cmd.exe**
    仍然集成在现代 Windows 操作系统中，例如 Windows 10。
- en: Those CLIs could be used to not only execute commands from the command line
    but also to write scripts to automate tasks, using the batch file syntax.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令行工具不仅可以用来执行命令行中的命令，还可以使用批处理文件语法编写脚本来自动化任务。
- en: Because not all functions of the **Graphical User Interface** (**GUI**) were
    available, it was not possible to automate all tasks via the command line. Additionally,
    the language had inconsistencies, so scripting was not as easy as it should have
    been in the first place.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **图形用户界面**（**GUI**）并未提供所有功能，无法通过命令行自动化所有任务。此外，语言本身存在不一致性，因此脚本编写不像预期的那样简便。
- en: In 1998, Microsoft released **Windows Script Host** (**cscript.exe**) in Windows
    98 to overcome the limits of the former CLIs and to improve the scripting experience.
    With **cscript.exe**, it now became possible to work with the APIs of the **Component
    Object Model** (**COM**), which made this interface very mighty; so mighty that
    not only did system administrators leverage this new feature but also the malware
    authors. This quickly lent **cscript.exe** the reputation of being a vulnerable
    vector of the OS.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 1998 年，微软在 Windows 98 中发布了 **Windows Script Host**（**cscript.exe**），以克服以前命令行界面的局限性，并改善脚本编写体验。通过
    **cscript.exe**，现在可以与 **组件对象模型**（**COM**）的 API 进行交互，这使得该接口变得非常强大；如此强大，以至于不仅系统管理员利用这一新功能，恶意软件作者也开始使用它。这很快使得
    **cscript.exe** 获得了作为操作系统脆弱向量的声誉。
- en: Additionally, the documentation of Windows Script Host was not easily accessible,
    and there were even more CLIs developed for different use cases besides **cscript.exe**,
    such as **netsh** and **wmic**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Windows Script Host 的文档不容易获取，而且除了 **cscript.exe** 之外，还开发了更多用于不同用途的命令行工具，如
    **netsh** 和 **wmic**。
- en: In 1999, *Jeffrey Snover*, who had a UNIX background, started to work for Microsoft.
    *Snover* was a big fan of command lines and automation, so his initial goal was
    to use UNIX tools on Microsoft systems, supporting the Microsoft Windows **Services
    for** **UNIX** (**SFU**).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 1999 年，*Jeffrey Snover*，一位具有 UNIX 背景的工程师，开始为微软工作。*Snover* 是命令行和自动化的忠实粉丝，因此他的初衷是将
    UNIX 工具应用于微软系统，支持微软的 Windows **UNIX 服务**（**SFU**）。
- en: However, as there is a big architectural difference between Windows and UNIX-based
    systems, he quickly noticed that making UNIX tools work on Windows didn't bring
    any value to Windows-based systems.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 Windows 和基于 UNIX 的系统之间存在巨大的架构差异，他很快意识到，在 Windows 上使 UNIX 工具可用，并没有为 Windows
    系统带来任何价值。
- en: While UNIX systems relied on ASCII files that could be easily leveraged and
    manipulated with tools such as **awk**, **sed**, **grep**, and more, Windows systems
    were API-based, leveraging structured data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 UNIX 系统依赖于可以轻松使用如**awk**、**sed**、**grep**等工具进行操作和处理的 ASCII 文件，但 Windows 系统则是基于
    API 的，依靠结构化数据。
- en: So, he decided that he could do better and, in 2002, started to work on a new
    command-line interface called **Monad** (also known as **Microsoft Shell/MSH**).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，他决定自己做得更好，并在 2002 年开始开发一种新的命令行工具——**Monad**（也称为 **Microsoft Shell/MSH**）。
- en: Now, Monad not only had the option to pass structured data (objects) into the
    pipe, instead of simple text, but also run scripts remotely on multiple devices.
    Additionally, it was easier for administrators to use Monad for administration
    as many default tasks were simplified within this framework.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Monad 不仅可以将结构化数据（对象）传递到管道中，而不是简单的文本，还可以在多个设备上远程运行脚本。此外，管理员使用 Monad 进行管理变得更容易，因为许多默认任务在此框架内被简化了。
- en: On April 25, 2006, Microsoft announced that Monad was renamed PowerShell. In
    the same year, the first version of PowerShell was released, and not much later
    (in January 2007), PowerShell was released for Windows Vista.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 2006 年 4 月 25 日，微软宣布 Monad 被更名为 PowerShell。同年，PowerShell 的第一个版本发布，不久之后（2007
    年 1 月），PowerShell 也发布了 Windows Vista 版本。
- en: In 2009, PowerShell 2.0 was released as a component of Windows 7 and Windows
    Server 2008 R2 that was integrated, by default, into the OS.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 2009 年，PowerShell 2.0 作为 Windows 7 和 Windows Server 2008 R2 的一部分发布，并且默认集成到操作系统中。
- en: Over the years, PowerShell was developed even further, and many new versions
    were released in the meantime, containing new features and improvements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，PowerShell 得到了进一步的发展，并且在此期间发布了许多新版本，包含了新的功能和改进。
- en: Then, in 2016, Microsoft announced that PowerShell would be made open source
    (MIT license) and would also be supported cross-platform.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 2016 年，微软宣布将 PowerShell 开源（MIT 许可），并且将支持跨平台使用。
- en: PowerShell 5.1, which was also released in 2016, was the last Windows-only PowerShell
    version. It is still shipped on Windows systems but is no longer developed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 5.1 是最后一个仅限 Windows 的 PowerShell 版本，它于 2016 年发布。它仍然会随着 Windows 系统一起分发，但不再进行开发。
- en: The PowerShell team was in the process of supporting Nano Server. So, there
    was a full version of PowerShell supporting Windows servers and clients. Nano
    Server had a severely trimmed version of .NET (called .NET Core), so the team
    had to reduce functions and chop it down to make PowerShell work with .NET Core.
    So, technically PowerShell 5.1 for Nano Server was the first version of PowerShell
    Core.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 团队当时正在支持 Nano Server。因此，存在一个完整版本的 PowerShell 来支持 Windows 服务器和客户端。Nano
    Server 的 .NET 版本（称为 .NET Core）被大幅删减，因此团队不得不减少功能并削减内容，使 PowerShell 能够与 .NET Core
    一起工作。所以，从技术上讲，PowerShell 5.1 为 Nano Server 是第一个 PowerShell Core 版本。
- en: The first real and official version of PowerShell Core was 6.0, which also offered
    support for cross-platform such as macOS and Linux.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell Core 的第一个正式版本是 6.0，它也提供了对跨平台（如 macOS 和 Linux）的支持。
- en: Why is PowerShell useful for cybersecurity?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么 PowerShell 对网络安全有用？
- en: PowerShell runs on most modern Windows systems as a default. It helps administrators
    to automate their daily workflows. Since PowerShell is available on all systems,
    it also makes it easier for attackers to use the scripting language for their
    own purposes – if attackers get access to a system, for example, through a **credential**
    **theft** attack.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 默认在大多数现代 Windows 系统上运行。它帮助管理员自动化日常工作流程。由于 PowerShell 在所有系统上都可用，它也使得攻击者更容易利用这个脚本语言达到他们的目的——例如，如果攻击者通过
    **凭证** **盗窃** 攻击获取了系统的访问权限。
- en: 'For attackers, that sounds amazing: a preinstalled scripting framework that
    provides direct access to cmdlets and the underlying .NET Framework. Automation
    allows you to get a lot done – not just for a good purpose.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于攻击者来说，这听起来太棒了：一个预安装的脚本框架，提供对 cmdlet 和底层 .NET 框架的直接访问。自动化可以让你做很多事情——不仅仅是出于好目的。
- en: Is PowerShell dangerous, and should it be disabled?
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PowerShell 是否危险，应该禁用吗？
- en: No! I have often heard this question when talking to CISOs. As PowerShell is
    seen more and more in the hands of the red team, some people fear the capabilities
    of this mighty scripting framework.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不！在与 CISO 交谈时，我经常听到这个问题。随着 PowerShell 越来越多地出现在红队手中，一些人开始担心这个强大的脚本框架的能力。
- en: But as usual, it's not black and white, and organizations should rather think
    about how to harden their systems and protect their identities, how to implement
    better detection, and how to leverage PowerShell in a way that benefits their
    workloads and processes – instead of worrying about PowerShell.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但和往常一样，这不是黑与白的简单问题，组织应更多地考虑如何加固他们的系统、保护他们的身份，如何实现更好的检测，并且如何以有利于工作负载和流程的方式利用
    PowerShell——而不是担心 PowerShell 本身。
- en: 'In the end, when you set up a server, you don''t just install it and connect
    it to the internet. The same goes for PowerShell: you don''t just enable PowerShell
    remote usage in your organization allowing everybody to connect remotely to your
    servers, regardless of their role.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，当你设置服务器时，你不仅仅是安装它并将其连接到互联网。PowerShell 也一样：你不能仅仅启用 PowerShell 远程使用，让任何人都能远程连接到你的服务器，而不考虑他们的角色。
- en: PowerShell is just a scripting language, similar to the preinstalled **cscript**
    or **batch**. Technically, it provides the same potential impact as **Java** or
    **.NET**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 只是一个脚本语言，类似于预安装的 **cscript** 或 **batch**。从技术上讲，它提供的潜在影响与 **Java**
    或 **.NET** 相似。
- en: And if we compare it to Linux or macOS, saying that PowerShell is dangerous
    is like saying that **Bash or zsh** is dangerous.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将其与 Linux 或 macOS 相比较，说 PowerShell 危险就像说 **Bash 或 zsh** 危险一样。
- en: A friend who worked in incident response for many years once told me about adversaries
    dropping **C#** code files on the target boxes and calling **csc.exe** (which
    is part of the .NET Framework) to compile the dropped files directly on the box.
    Which is a very effective way to abuse a preinstalled software to install the
    adversary's code on the system without even leveraging PowerShell.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一位在事件响应领域工作多年的朋友曾告诉我，攻击者将 **C#** 代码文件放置到目标机器上，并调用 **csc.exe**（.NET 框架的一部分）直接在机器上编译这些文件。这是一个非常有效的方式，能够利用预装的软件在系统上安装攻击者的代码，而不需要借助
    PowerShell。
- en: So, in other words, it is not the language that is dangerous or malicious; adversaries
    still require identities or authorization for the execution, which can be constrained
    by the security expert or administrator who is responsible for the environment's
    security.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，危险或恶意的并不是语言本身；对手仍然需要身份或授权才能执行操作，而这些可以由负责环境安全的安全专家或管理员加以限制。
- en: And to be honest, all red teamers that I know or have talked to are starting
    to move more and more to other languages such as C# or C++ instead of PowerShell,
    if they want to stay undetected during their attacks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 坦白说，我认识或与许多红队人员交谈过，他们现在开始越来越多地转向其他语言，如 C# 或 C++，而不是 PowerShell，尤其是在攻击中想要保持不被察觉时。
- en: If the right security measures and detections are implemented, it is almost
    impossible to go unnoticed when using PowerShell for an attack in a well-configured
    and protected environment. Once you have followed the security best practices,
    PowerShell will support you to keep your environment safe and help you track any
    attackers in your environment.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实施了正确的安全措施和检测，在一个配置良好并且保护完善的环境中，使用 PowerShell 发起攻击几乎不可能不被察觉。一旦您遵循了安全最佳实践，PowerShell
    将帮助您保持环境的安全，并帮助您追踪任何入侵者。
- en: 'Additionally, a lot of your environmental security depends on your global credentials
    and access hygiene: before attackers can leverage PowerShell, first, they need
    access to a system. We''ll take a closer look at how to secure your environment
    credential-wise in [*Chapter 6*](B16679_06_Final_PD.xhtml#_idTextAnchor150), *Active
    Directory – Attacks* *and Mitigation*.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您的环境安全在很大程度上取决于您的全局凭证和访问管理：在攻击者能够利用 PowerShell 之前，他们首先需要访问系统。我们将在 [*第六章*](B16679_06_Final_PD.xhtml#_idTextAnchor150)
    中仔细探讨如何在凭证方面保护您的环境，*Active Directory – 攻击与缓解*。
- en: How can PowerShell support my blue team?
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PowerShell 如何支持我的蓝队？
- en: PowerShell not only enables your IT professionals to work more efficiently and
    to get things done quicker, but it also provides your security team with great
    options.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 不仅使您的 IT 专业人员能够更高效地工作并更快地完成任务，还为您的安全团队提供了极好的选择。
- en: 'PowerShell offers a lot of built-in safety guards that you will learn more
    about in this book:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 提供了许多内置的安全防护措施，您将在本书中进一步了解这些内容：
- en: '**Automation and compliance**: One of the main benefits is that you can automate
    repeatable, tedious tasks. Not only will your administrators benefit from automating
    tasks, but your **Security Operations Center** (**SOC**) can automate response
    actions taken, triggered by certain events.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化与合规性**：其中一个主要的好处是，您可以自动化重复且枯燥的任务。您的管理员不仅能从自动化任务中受益，而且您的 **安全运营中心** (**SOC**)
    还可以在特定事件触发时自动执行响应操作。'
- en: One of the main reasons organizations are getting breached is missing security
    updates. It is not easy to keep all systems up to date – even with updated management
    systems such as **Windows Server Update Services** (**WSUS**) in place. PowerShell
    can help to build a mechanism to regularly check whether updates are missing to
    keep your environment secure.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 组织遭到入侵的主要原因之一是缺少安全更新。保持所有系统更新并不容易——即使是像 **Windows Server Update Services** (**WSUS**)
    这样的更新管理系统也很难完全保证。PowerShell 可以帮助构建一个机制，定期检查是否缺少更新，从而保持您的环境安全。
- en: Auditing and enforcing compliance can easily be achieved using **Desired State**
    **Configuration** (**DSC**).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 审计和执行合规性可以通过使用 **所需状态配置** (**DSC**) 来轻松实现。
- en: Automate security checks to audit Active Directory or server security and enforce
    your security baselines. DSC allows you to control the configuration of your servers
    at any time. You can configure your machines to reset their configuration up to
    every 15 minutes to the configuration you specified.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化安全检查以审核 Active Directory 或服务器安全性，并强制执行您的安全基线。DSC 使您能够随时控制服务器的配置。您可以将您的机器配置为每
    15 分钟重置其配置到您指定的设置。
- en: Additionally, if you integrate DSC as part of your incident response plan, it
    is very easy to rebuild potentially compromised servers from the scratch.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你将 DSC 集成到你的事件响应计划中，重新构建可能被入侵的服务器将变得非常容易。
- en: '**Control who is allowed to do what and where**: By configuring **PowerShell
    remoting**/**WinRM**, you can specify *who* is allowed to log on to *which device
    or server*. Of course, it does not help against **credential theft** (as this
    is not a PowerShell topic), but it helps to granularly define which identity is
    allowed to do what. Additionally, it provides great auditing capabilities for
    remote connections.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制谁可以做什么以及在哪里做**：通过配置**PowerShell 远程管理**/**WinRM**，你可以指定*谁*被允许登录到*哪个设备或服务器*。当然，这对**凭证盗窃**无济于事（因为这不是
    PowerShell 的话题），但它有助于细化定义哪个身份可以做什么。此外，它还提供了远程连接的出色审计能力。'
- en: '**Constrained Language mode** lets you restrict which PowerShell elements are
    allowed in a session. This can already help to prevent certain attacks.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**受限语言模式**允许你限制会话中可以使用的 PowerShell 元素。这已经可以帮助防止某些攻击。'
- en: And using **Just Enough Administration** (**JEA**), you can even restrict which
    roles/identities are allowed to run which commands on which machine. You can even
    restrict the parameters of a command.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**足够的管理**（**JEA**），你甚至可以限制哪些角色/身份被允许在特定机器上运行哪些命令。你还可以限制命令的参数。
- en: '**Find out what is going on in your environment**: PowerShell provides an extensive
    logging framework with many additional logging options such as creating transcripts
    and script block logging.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**了解你的环境中发生了什么**：PowerShell 提供了一个广泛的日志框架，拥有许多额外的日志选项，例如创建记录和脚本块日志记录。'
- en: Every action in PowerShell can be tracked if the right infrastructure is put
    behind it. You can even automate your response actions using a **Security Orchestration,
    Automation, and Response** (**SOAR**) approach.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 PowerShell 中配置了适当的基础设施，几乎所有的操作都可以被追踪。你甚至可以使用**安全编排、自动化和响应**（**SOAR**）方法自动化你的响应行动。
- en: Using PowerShell, you can quickly pull and search event logs of multiple servers,
    connecting remotely to analyze them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PowerShell，你可以快速提取并搜索多个服务器的事件日志，远程连接以进行分析。
- en: In a case of a security breach, PowerShell can also help you to collect and
    investigate the forensic artifacts and to automate the investigation. There are
    great modules such as *PowerForensics* that you can reuse for your forensics operations
    and post-breach remediation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全漏洞发生的情况下，PowerShell 还可以帮助你收集和调查法医证据，并自动化调查过程。有许多优秀的模块，如*PowerForensics*，可以用于你的法医操作和事后补救。
- en: '**Restrict which scripts are allowed to run**: By default, PowerShell brings
    a feature called **Execution Policy**. Although it is *not* a security control,
    it prevents users from unintentionally running scripts.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制哪些脚本可以运行**：默认情况下，PowerShell 提供了一个名为**执行策略**的功能。虽然它*不是*一种安全控制，但它可以防止用户不小心运行脚本。'
- en: 'Signing your code helps you to verify whether a script that is run is considered
    legit: if you allow only signed scripts to run, this is a great way to prevent
    your users to run scripts directly downloaded from the internet.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对你的代码进行签名可以帮助你验证执行的脚本是否被认为是合法的：如果只允许签名的脚本运行，这是防止用户直接运行从互联网下载的脚本的绝佳方式。
- en: '**AppLocker**, in combination with **Code Signing**, can help you to control
    which scripts are allowed to run in your organization.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**AppLocker**与**代码签名**结合使用，可以帮助你控制在组织中哪些脚本可以运行。'
- en: The mentioned solutions do not restrict interactive code restriction though.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前述解决方案并未限制交互式代码的执行。
- en: '**Detect and stop malicious code from execution**: The **Antimalware Scan Interface**
    (**AMSI**) provides a possibility to have your code checked by the antimalware
    solution that is currently present on the machine. This can help to detect malicious
    code and is also a great safeguard against file-less malware attacks (**living
    off the land**) – attacks that don''t require files to be stored on the machine,
    but rather directly run the code in memory.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检测并阻止恶意代码执行**：**反恶意软件扫描接口**（**AMSI**）提供了一种可能性，允许你的代码通过当前机器上存在的反恶意软件解决方案进行检查。这有助于检测恶意代码，并且是防止无文件恶意软件攻击（**Living
    off the Land**）的绝佳保障——这种攻击不需要在机器上存储文件，而是直接在内存中运行代码。'
- en: It is integrated directly into PowerShell and can assess scripts, interactive
    use, and dynamic code evaluation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它直接集成在 PowerShell 中，可以评估脚本、交互式使用和动态代码评估。
- en: These are only some examples of how PowerShell can support the blue team, but
    it should already give you an overview of how blue teamers can benefit from using
    and auditing PowerShell.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是PowerShell如何支持蓝队的一些示例，但它应该已经为你提供了一个概述，展示了蓝队员如何从使用和审计PowerShell中受益。
- en: 'It is also worth reading the great blog article *PowerShell* *♥* *the Blue
    Team that* the Microsoft PowerShell team has published to provide advice on how
    PowerShell supports blue teamers: [https://devblogs.microsoft.com/powershell/powershell-the-blue-team/](https://devblogs.microsoft.com/powershell/powershell-the-blue-team/).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这篇由微软PowerShell团队发布的精彩博客文章*PowerShell* *♥* *蓝队*也是值得的，它提供了关于PowerShell如何支持蓝队员的建议：[https://devblogs.microsoft.com/powershell/powershell-the-blue-team/](https://devblogs.microsoft.com/powershell/powershell-the-blue-team/)。
- en: You will learn more about possible attacks, mitigations, and bypasses during
    your journey throughout this book.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在你翻阅本书的过程中，你将学习到更多关于可能的攻击、缓解措施和绕过方法的内容。
- en: But first, let's start refreshing your knowledge of PowerShell fundamentals.
    Enjoy!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们开始复习PowerShell基础知识。享受吧！
- en: Getting started with PowerShell
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用PowerShell
- en: Before we can jump directly into scripting for cybersecurity and crazy red or
    blue team tasks, it is important to know some of the basics of PowerShell. Here
    are some refreshers that will help you to get started.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们直接进入网络安全脚本编写以及疯狂的红蓝队任务之前，了解一些PowerShell的基础知识是非常重要的。以下是一些有助于你入门的复习内容。
- en: Introduction to OOP
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程简介
- en: PowerShell is an object-oriented language. OOP allows developers to think of
    software development as if they were working with real-life objects or entities.
    Some of the main advantages of OOP are that it's scalable, flexible, and overall,
    it lets you efficiently reuse your code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell是一种面向对象的语言。面向对象编程让开发人员能够将软件开发看作是与现实世界中的对象或实体进行工作。面向对象编程的主要优点之一是它可扩展、灵活，并且总体上能让你高效地复用代码。
- en: Some of the base terminologies in OOP are **classes**, **objects**, **properties**,
    and **methods**. And if we look at the four main principles of OOP – **encapsulation**,
    **abstraction**, **inheritance**, and **polymorphism** – you quickly feel overwhelmed
    if you have no experience with OOP yet.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中的一些基本术语包括**类**、**对象**、**属性**和**方法**。如果我们看看面向对象编程的四个主要原则——**封装**、**抽象**、**继承**和**多态**——如果你还没有面向对象编程经验，可能会感到有些不知所措。
- en: But don't worry, it is not as hard as it sounds, and OOP will make your life
    easier!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心，它并不像听起来那么难，面向对象编程会让你的生活变得更轻松！
- en: 'To better understand those concepts and principles, let''s look at Alice and
    Bob as an example. They are both human beings; therefore, they share the same
    *class*: **human**. Both are our working entities in our example and, therefore,
    are our *objects*.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些概念和原理，我们以Alice和Bob为例。他们都是人类，因此共享相同的*类*：**人类**。两者都是我们示例中的工作实体，因此也是我们的*对象*。
- en: A *class* is a collection of properties and methods, similar to a blueprint
    for objects. Alice and Bob are both humans and share many *properties* and *methods*.
    Both have a certain amount of energy they can spend per day, can feel more or
    less relaxed, and need to work to gain money.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*类*是属性和方法的集合，类似于对象的蓝图。Alice和Bob都是人类，分享许多*属性*和*方法*。两者都有一定的每日能量，可以感到不同程度的放松，并且都需要工作来赚取金钱。'
- en: 'Both need to work and like to drink coffee. During the night, both need to
    sleep to restore their energy:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都需要工作，并且喜欢喝咖啡。晚上，两者都需要休息以恢复精力：
- en: '![Figure 1.1 – Alice, the CISO](image/B16679_01_001.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – Alice，CISO](image/B16679_01_001.jpg)'
- en: Figure 1.1 – Alice, the CISO
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – Alice，CISO
- en: Alice works as a **Chief Information Security Officer** (**CISO**) and, often,
    plays between meetings and in the evening with her cat Mr. Meow, which helps her
    to relax.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Alice担任**首席信息安全官**（**CISO**），并且经常在会议之间和晚上与她的猫咪Mr. Meow一起玩耍，这帮助她放松。
- en: '![Figure 1.2 – Bob, the security consultant](image/B16679_01_002.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – Bob，安全顾问](image/B16679_01_002.jpg)'
- en: Figure 1.2 – Bob, the security consultant
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – Bob，安全顾问
- en: 'In comparison, Bob works as a security consultant. Although he is also a human,
    he has different *methods* than Alice: Bob does not have a cat, but he enjoys
    painting in his spare time, which makes him feel relaxed and restores his batteries.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Bob是一名安全顾问。尽管他也是人类，但他的*方法*与Alice不同：Bob没有猫，但他在闲暇时喜欢画画，这使他感到放松并恢复精力。
- en: Let's explore the four main principles of OOP, looking at Alice and Bob.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过Alice和Bob来探索面向对象编程的四个主要原则。
- en: Encapsulation
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 封装
- en: '**Encapsulation** is achieved if each object keeps its state **private** inside
    a class. Other objects cannot access it directly, they need to call a method to
    change its state.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: For example, Alice's state includes the private **EnergyLevel**, **RelaxationStatus**,
    and **Money** properties. She also has a private **SighHappily()** method. She
    can call this method whenever she wants; the other classes can't influence whenever
    Alice sighs happily. When Alice plays with her cat Mr. Meow, the **SighHappily()**
    method is called by default – Alice really enjoys this activity.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'What other classes can do is call the public **Work()**, **DrinkCoffee()**,
    **Sleep()**, and **PlayWithCat()** functions. Those functions can change the internal
    state and even call the private **SighHappily()** method when Alice plays with
    her cat Mr. Meow:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – A closer look at public and private methods](image/B16679_01_003.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – A closer look at public and private methods
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, if you want to change a private property's value, you always need
    to call a public method that is linked to the private state. Like in real life,
    there is no magic cure – besides coffee – to immediately remove your tiredness.
    And even with coffee, you still need to perform an action to drink it. The binding
    that exists between the private state and the public methods is called **encapsulation**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Abstraction** can be thought of as a natural extension of encapsulation.
    Often, a code base becomes super extensive, and you can lose the overview. Applying
    abstraction means that each object should expose its methods at only a high level
    and should hide details that are not necessary to other objects.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, we have the **Work()** method defined in the **human** class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how technical your parents are, they might understand what you
    do in your daily job. Mine, however, do not understand a word that I say. They
    just know that I work with computers. So, if I talk with my parents on the phone,
    instead of telling them every detail and boring them to death, I just tell them
    that I have finished work.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: A similar principle should also apply when writing object-oriented code. Although
    there are many different operations behind the **Work()**method, it is abstracted
    and only the relevant data is shown.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Another example could be an elevator in the office. When you push a button to
    get to a different floor, something happens below the surface. But only the buttons
    and the display, indicating the floor level, are shown to the user of the elevator.
    This principle is called abstraction and helps to keep an overview of the task
    that should be achieved.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you require very similar classes or objects, you won't want to duplicate
    existing code. This would make things more complicated, work-intensive, and there
    would be a higher chance of implementing bugs – for example, if you have to change
    the code for all different instances and forget one.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: So, our Alice and Bob objects are quite similar and share a *common logic*,
    but they are *not entirely the same*. They are both humans, but they have different
    professions that require different skillsets and tasks performed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的Alice和Bob对象非常相似，共享一个*共同的逻辑*，但它们*并不完全相同*。它们都是人类，但拥有不同的职业，要求具备不同的技能和任务。
- en: All CISOs and all security consultants are humans, so both roles **inherit**
    all properties and methods from the **human** class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所有CISO和所有安全顾问都是人类，因此这两个角色都**继承**了**human**类的所有属性和方法。
- en: Similar to the **SecurityConsultant** class, the **CISO** class inherits all
    properties and methods of the **human** class. However, while the **CISO** class
    also introduces the **StrategicPlanningSkillset** property and the **CalculateRisk()**
    method, they are not necessary for the **SecurityConsultant** class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于**SecurityConsultant**类，**CISO**类继承了**human**类的所有属性和方法。然而，虽然**CISO**类还引入了**StrategicPlanningSkillset**属性和**CalculateRisk()**方法，但它们对于**SecurityConsultant**类并不必要。
- en: The **SecurityConsultant** class defines their own **TechnicalAuditingSkillset**
    property and **AnalyzeSystem()** and **TalkToCustomer()** methods.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**SecurityConsultant**类定义了自己的**TechnicalAuditingSkillset**属性以及**AnalyzeSystem()**和**TalkToCustomer()**方法。'
- en: 'Alice inherits all the skills that were defined in the **human** class, and
    in the **CISO** class, which builds a *hierarchy*: **human** is now the parent
    class of the **CISO** class, while the **CISO** class is Alice''s **parent** class
    – in this case, Alice is the **child** object.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Alice继承了**human**类中定义的所有技能，而在**CISO**类中，这构建了一个*层次结构*：**human**现在是**CISO**类的父类，而**CISO**类是Alice的**父类**—在这个案例中，Alice是**子对象**。
- en: 'Additionally, Bob inherits all the properties and methods defined in the **human**
    class, but in comparison to Alice, he inherits everything from the **SecurityConsultant**
    class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Bob继承了**human**类中定义的所有属性和方法，但与Alice相比，他继承了**SecurityConsultant**类中的所有内容：
- en: '![Figure 1.4 – Inheritance: parent and child classes and objects](image/B16679_01_004.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 继承：父类和子类以及对象](image/B16679_01_004.jpg)'
- en: 'Figure 1.4 – Inheritance: parent and child classes and objects'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 继承：父类和子类以及对象
- en: And yes, dear security consultants and CISOs, I know that your profession requires
    far more skills and that your role is far more challenging than is shown in this
    example. I tried to make it abstract to keep it simple.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，亲爱的安全顾问和CISO们，我知道你们的职业要求远多于此示例所显示的技能，而且你们的角色比这个示例所展示的要挑战得多。我尽量将其抽象化，以保持简单。
- en: Looking at Alice and Bob, Alice enjoys spending time with her cat, Mr. Meow,
    so she brings her unique **PlayWithCat()** and **SighHappily()** methods. Bob
    does not have a cat, but he enjoys painting and, therefore, has the unique **Paint()**
    method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 看看Alice和Bob，Alice喜欢和她的猫Mr. Meow一起度过时光，所以她有自己独特的**PlayWithCat()**和**SighHappily()**方法。Bob没有猫，但他喜欢画画，因此他有独特的**Paint()**方法。
- en: Using **inheritance**, we only need to add what is necessary to implement the
    required changes while using the existing logic with the parent classes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**继承**，我们只需要添加必要的部分来实现所需的更改，同时使用父类中的现有逻辑。
- en: Polymorphism
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多态性
- en: Now that we have looked into the concept of inheritance, **polymorphism** is
    not far off. Polymorphism means that although you can create different objects
    out of different classes, all classes and objects can be used just like their
    parents.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了继承的概念，那么**多态性**也就不远了。多态性意味着，尽管你可以从不同的类创建不同的对象，但所有类和对象都可以像它们的父类一样使用。
- en: If we look at Alice and Bob, both are humans. That means we can rely on the
    fact that both support the **EnergyLevel**, **RelaxationStatus**, and **Money**
    properties along with the **Work()**, **DrinkCoffee()**, and **Sleep()** methods.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下Alice和Bob，两者都是人类。这意味着我们可以依赖于两者都支持**EnergyLevel**、**RelaxationStatus**和**Money**属性，以及**Work()**、**DrinkCoffee()**和**Sleep()**方法。
- en: Additionally, they can support other unique properties and methods, but they
    always support the same ones as their parents to avoid confusion.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，他们可以支持其他独特的属性和方法，但始终支持与父类相同的内容，以避免混淆。
- en: Please note that this overview should only serve as a high-level overview; if
    you want to dive deeper into the concepts of OOP, you might want to look into
    other literature solely on OOP, such as *Learning Object-Oriented Programming*,
    which is written by Gaston C. Hillar and also published by Packt.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个概述仅应作为一个高层次的介绍；如果你想深入了解面向对象编程（OOP）的概念，你可能需要查阅其他专门讲解OOP的文献，比如*《学习面向对象编程》*，该书由Gaston
    C. Hillar编写，并由Packt出版。
- en: Now that you understand the base concepts of OOP, let's get back to working
    with PowerShell.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了面向对象编程（OOP）的基本概念，让我们回到 PowerShell 的使用上。
- en: Windows PowerShell
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows PowerShell
- en: By default, Windows PowerShell 5.1 is installed on all newer systems, starting
    with Windows 10\. You can either open it by searching in your Start menu for **PowerShell**,
    or you can also start it via *Windows key* + *R* and typing in **powershell**
    or **powershell.exe**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Windows PowerShell 5.1 会安装在所有较新的系统上，从 Windows 10 开始。你可以通过在开始菜单中搜索**PowerShell**来打开它，也可以通过按
    *Windows 键* + *R*，然后输入 **powershell** 或 **powershell.exe** 来启动它。
- en: 'In this console, you can run commands, scripts, or cmdlets:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个控制台中，你可以运行命令、脚本或 cmdlet：
- en: "![Figure 1.5 – The Windows PowerShell version 5.1 \uFEFFCLI](image/B16679_01_005.jpg)"
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – Windows PowerShell 版本 5.1 命令行界面](image/B16679_01_005.jpg)'
- en: Figure 1.5 – The Windows PowerShell version 5.1 CLI
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – Windows PowerShell 版本 5.1 命令行界面
- en: 'On Windows 10 devices, the default location of Windows PowerShell v5.1 is under
    the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 10 设备上，Windows PowerShell v5.1 的默认位置如下：
- en: 'Windows PowerShell: **%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows PowerShell: **%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe**'
- en: 'Windows PowerShell (x86): **%SystemRoot%\syswow64\WindowsPowerShell\v1.0\powershell.exe**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows PowerShell (x86): **%SystemRoot%\syswow64\WindowsPowerShell\v1.0\powershell.exe**'
- en: Why Is There a v1.0 in the Path? Does That Mean I'm Running an Old Version?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么路径中会有 v1.0？这是否意味着我在运行旧版本？
- en: As we will also take a more detailed look at PowerShell versions in this book,
    you might think *Omg, I heard that old versions do not provide all necessary security
    features, such as logging and many more! Am I* *at risk?*
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中也会更详细地讲解 PowerShell 版本，你可能会想：*天啊，我听说旧版本没有提供所有必要的安全功能，比如日志记录等！我是不是* *处于风险之中？*
- en: No, you aren't. Although the path contains **v1**, newer versions are being
    installed in this exact path. Originally it was planned to create a new folder
    with the correct version name, but later Microsoft decided against it so that
    no breaking changes are caused.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不是的，实际上即便路径中包含 **v1**，新版本仍然会被安装到这个路径中。最初计划为每个版本创建一个新的文件夹，并使用正确的版本名称，但后来微软决定不这样做，以避免引发破坏性更改。
- en: 'You might have also noticed the **.ps1** script extension. We have the same
    reason here: originally it was also planned that each version will be differentiated
    by the script extension. But out of backward compatibility reasons, this idea
    was not implemented for PowerShell v2 logic.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了 **.ps1** 脚本扩展名。这里的原因是相同的：最初也计划通过脚本扩展名来区分每个版本，但出于向后兼容的原因，PowerShell
    v2 的逻辑并未实现这一点。
- en: But since Windows PowerShell will not be developed further, it makes sense to
    install and use the latest PowerShell Core binaries.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于 Windows PowerShell 将不再进一步开发，因此安装并使用最新的 PowerShell Core 二进制文件是合理的选择。
- en: PowerShell Core
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell Core
- en: On newer systems, Windows PowerShell version 5.1 is still installed by default.
    To use the latest PowerShell Core version, you need to manually download and install
    it. While this book was written, the latest stable PowerShell Core version was
    PowerShell 7.3.6.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新的系统上，Windows PowerShell 版本 5.1 仍然是默认安装的。如果要使用最新的 PowerShell Core 版本，你需要手动下载并安装它。在本书写作时，最新的稳定
    PowerShell Core 版本是 PowerShell 7.3.6。
- en: 'To learn more about how to download and install the latest PowerShell Core
    version, you can leverage the official documentation: [https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何下载并安装最新的 PowerShell Core 版本，你可以参考官方文档：[https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows)。
- en: 'You will find the latest stable PowerShell Core version here: [https://aka.ms/powershell-release?tag=stable](https://aka.ms/powershell-release?tag=stable).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到最新的稳定版 PowerShell Core：[https://aka.ms/powershell-release?tag=stable](https://aka.ms/powershell-release?tag=stable)。
- en: 'Download it and start the installation. The installation wizard opens and guides
    you through the installation. Depending on your requirements, you can specify
    what should be configured by default:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并开始安装。安装向导将打开，并引导你完成安装过程。根据你的需求，你可以指定默认配置项：
- en: '![Figure 1.6 – Installing PowerShell 7](image/B16679_01_006.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 安装 PowerShell 7](image/B16679_01_006.jpg)'
- en: Figure 1.6 – Installing PowerShell 7
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 安装 PowerShell 7
- en: Don't worry if you haven't enabled **PowerShell remoting** yet. You can configure
    this option later. The wizard runs through and installs PowerShell Core in the
    separate **$env:ProgramFiles\PowerShell\7** location. PowerShell 7 is designed
    to run parallel to PowerShell 5.1.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尚未启用 **PowerShell 远程管理**，不用担心。你可以稍后配置此选项。向导将会运行并将 PowerShell Core 安装到单独的**$env:ProgramFiles\PowerShell\7**目录。PowerShell
    7 设计为与 PowerShell 5.1 并行运行。
- en: 'After the setup is complete, you can launch the new PowerShell console and
    pin it to your taskbar or the Start menu:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，你可以启动新的 PowerShell 控制台并将其固定到任务栏或开始菜单：
- en: "![Figure 1.7 – The PowerShell version 7 \uFEFFCLI](image/B16679_01_007.jpg)"
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – PowerShell 7 CLI 版本](image/B16679_01_007.jpg)'
- en: Figure 1.7 – The PowerShell version 7 CLI
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – PowerShell 7 CLI
- en: Now you can use the latest PowerShell Core version instead of the old Windows
    PowerShell version 5.1.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用最新的 PowerShell Core 版本，替代旧版 Windows PowerShell 5.1。
- en: Installing PowerShell Core Group Policy definitions
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 PowerShell Core 组策略定义
- en: To define consistent options for your servers in your environment, Group Policy
    helps with the configuration.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的环境中的服务器定义一致的选项时，组策略能够帮助进行配置。
- en: When installing PowerShell 7, Group Policy templates, along with an installation
    script, will be populated under **$PSHOME**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 PowerShell 7 时，组策略模板以及安装脚本会被填充到**$PSHOME**目录下。
- en: Group Policy requires two kinds of templates (**.admx**, **.adml**) to allow
    the configuration of registry-based settings.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 组策略需要两种模板（**.admx**，**.adml**）来配置基于注册表的设置。
- en: 'You can find the templates as well as the installation script using the **Get-ChildItem
    -Path $PSHOME -Filter *****Core*Policy*** command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**Get-ChildItem -Path $PSHOME -Filter *****Core*Policy*** 命令查找模板和安装脚本：
- en: '![Figure 1.8 – Locating the PowerShell Core Group Policy templates and installation
    script](image/B16679_01_008.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 查找 PowerShell Core 组策略模板和安装脚本](image/B16679_01_008.jpg)'
- en: Figure 1.8 – Locating the PowerShell Core Group Policy templates and installation
    script
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 查找 PowerShell Core 组策略模板和安装脚本
- en: Type **$PSHOME\InstallPSCorePolicyDefinitions.ps1** into your domain controller,
    press *Tab*, and confirm with *Enter*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的域控制器中输入 **$PSHOME\InstallPSCorePolicyDefinitions.ps1**，按下*Tab*键并按*Enter*键确认。
- en: 'The Group Policy templates for PowerShell Core will be installed, and you can
    access them by navigating to the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell Core 的组策略模板将被安装，你可以通过以下路径访问它们：
- en: '**Computer Configuration** | **Administrative Templates** | **PowerShell Core**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算机配置** | **管理模板** | **PowerShell Core**'
- en: '**User Configuration** |**Administrative Templates** | **PowerShell Core**'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户配置** | **管理模板** | **PowerShell Core**'
- en: You can now use them to configure PowerShell Core in your environment, in parallel
    to Windows PowerShell.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用这些模板来配置 PowerShell Core 环境，和 Windows PowerShell 一起使用。
- en: You can configure both policies differently, but to avoid confusion and misconfiguration,
    I recommend configuring the setting in Windows PowerShell and checking the **Use
    Windows PowerShell Policy setting** box, which is available in all PowerShell
    Core Group Policy settings.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以分别配置这两种策略，但为了避免混淆和错误配置，建议你在 Windows PowerShell 中配置设置，并勾选所有 PowerShell Core
    组策略设置中提供的**使用 Windows PowerShell 策略设置**框。
- en: Autocompletion
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动完成
- en: 'Autocompleting commands can be very useful and can save a lot of time. You
    can either use *Tab* or *Ctrl* + spacebar for autocompletion:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 自动完成命令非常有用，能节省大量时间。你可以使用*Tab*键或*Ctrl* + 空格键进行自动完成：
- en: With *Tab*, the command that comes nearest to the command that you already typed
    in is shown. With every other *Tab* you can switch through the commands and have
    the next one – sorted alphabetically – entered.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*Tab*键时，系统会显示最接近你已输入命令的命令。每按一次*Tab*键，你可以浏览命令并输入下一个命令——按字母顺序排列。
- en: 'If there are multiple commands that fit the string you entered, you can type
    *Ctrl* + spacebar to see all possible commands. You can use the arrow keys to
    select a command. Confirm with *Enter*:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有多个命令符合你输入的字符串，你可以按*Ctrl* + 空格键查看所有可能的命令。你可以使用箭头键选择一个命令，按*Enter*键确认：
- en: '![Figure 1.9 – Using Ctrl + spacebar to choose the right command](image/B16679_01_009.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – 使用 Ctrl + 空格键选择正确的命令](image/B16679_01_009.jpg)'
- en: Figure 1.9 – Using Ctrl + spacebar to choose the right command
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 使用 Ctrl + 空格键选择正确的命令
- en: Working with the PowerShell history
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 PowerShell 历史记录
- en: 'Sometimes, it can be useful to find out which commands you have used recently
    in your PowerShell session:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，查看你最近在 PowerShell 会话中使用过哪些命令是非常有用的：
- en: '![Figure 1.10 – Using Get-History](image/B16679_01_010.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – Using Get-History
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: All recently used commands are shown. Use the arrow keys to browse the last-used
    commands, change them, and run them again.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In this example, one of the last commands that was run was the **Enter-PSSession**
    command, which initiates a PowerShell remoting session to the specified host –
    in this case, to **PSSEC-PC01**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to initiate another PowerShell remoting session to **PSSEC-PC02**
    instead of **PSSEC-PC01**, you don''t have to type in the whole command again:
    just use the *arrow up key* once, then change **-ComputerName** to **PSSEC-PC02**
    and hit *Enter* to execute it.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: If your configuration allows you to connect to **PSSEC-PC02** from this PC using
    the same credentials, the connection is established, and you can work remotely
    on **PSSEC-PC02**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: We will have a closer look at PowerShell remoting in [*Chapter 3*](B16679_03_Final_PD.xhtml#_idTextAnchor064),
    *Exploring PowerShell Remote Management Technologies and* *PowerShell Remoting*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Searching the PowerShell history
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To search the history, pipe the **Get-History** command to **Select-String**
    and define the string that you are searching for:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are a person who likes to keep your commands terse, **aliases** might
    speak to you. We will take a look at them later, but for now, here''s an example
    of how you''d search the history, using the same commands but abbreviated as an
    alias:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you want to see all the PowerShell remoting sessions that were established
    in this session, you can search for the **Enter-PSSession** string:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Searching the session history](image/B16679_01_011.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Searching the session history
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you only search for a substring such as **PSSession**, you can
    find **all** occurrences of the **PSSession** string, including the last execution
    of **Get-History**:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Searching the session history](image/B16679_01_012.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Figure 1.12 – Searching the session history
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: When you are looking for a command that was run recently, you don't have to
    query the entire history. To only get the last *X* history entries, you can specify
    the **-****Count** parameter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, to get the last five entries, specify **-****Count 5**:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – Getting the last five history entries](image/B16679_01_013.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: Figure 1.13 – Getting the last five history entries
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: When you close a PowerShell session, the *session history* is deleted. That
    means you will get no results if you use the session-bound **Get-History** command
    upon starting a new session.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: But there's also a *persistent history* that you can query, as provided by the
    **PSReadline** module.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'The history is stored in a file, which is stored under the path configured
    in **(Get-PSReadlineOption).HistorySavePath**:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14 – Displaying the location of the persistent history](image/B16679_01_014.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 1.14 – Displaying the location of the persistent history
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'You can either open the file or inspect the content using **Get-Content**:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过**Get-Content**来打开文件或查看其内容：
- en: '[PRE2]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you just want to search for a command to execute it once more, the **interactive
    search** might be helpful. Press *Ctrl* + *R* to search backward, and type in
    characters or words that were part of the command that you executed earlier.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想搜索某个命令并再次执行，**交互式搜索**可能会有所帮助。按下*Ctrl* + *R*进行反向搜索，输入你之前执行命令时用过的字符或词语。
- en: 'As you are searching backward, the most recent command that you executed will
    appear in your command line. To find the next match, press *Ctrl* + *R* again:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行反向搜索时，你之前执行的最新命令会出现在命令行中。要查找下一个匹配项，再次按下*Ctrl* + *R*：
- en: '![Figure 1.15 – Using the interactive search to search backward](image/B16679_01_015.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.15 – 使用交互式搜索进行反向搜索](image/B16679_01_015.jpg)'
- en: Figure 1.15 – Using the interactive search to search backward
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – 使用交互式搜索进行反向搜索
- en: '*Ctrl* + *S* works just like *Ctrl* + *R* but searches forward. You can use
    both shortcuts to move back and forth in the search results.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ctrl* + *S* 和 *Ctrl* + *R* 类似，后者用于反向搜索，前者用于正向搜索。你可以使用这两个快捷键在搜索结果中前后移动。'
- en: '*Ctrl* + *R* and *Ctrl* + *S* allow you to search the permanent history, so
    you are not restricted to search for the commands run during this session.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ctrl* + *R* 和 *Ctrl* + *S* 允许你搜索永久历史记录，因此你不局限于只搜索当前会话中执行的命令。'
- en: Clearing the screen
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清除屏幕
- en: 'Sometimes, after running multiple commands, you might want to start with an
    empty shell without reopening it – to keep your current session, history, and
    variables:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在运行多个命令之后，你可能想在不重新打开终端的情况下开始一个空白的 shell，以保留当前会话、历史记录和变量：
- en: '[PRE3]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After typing in the **Clear** command and confirming with *Enter*, your current
    PowerShell console will be cleared, and you can start with a fresh and clean console.
    All variables set in this session are still accessible, and your history is still
    available.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 输入**Clear**命令并按*Enter*确认后，当前的 PowerShell 控制台将被清空，你可以从一个全新的控制台开始。此会话中设置的所有变量仍然可访问，历史记录仍然可用。
- en: Instead of **Clear**, you can also use the **cls** alias or the *Ctrl* + *L*
    shortcut.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**Clear**，你还可以使用**cls**别名或*Ctrl* + *L*快捷键。
- en: Canceling a command
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 取消命令
- en: If you are running a command, sometimes, you might want to cancel it out for
    different reasons. It could be that you executed the command by accident, perhaps
    a command takes too long, or you want to try a different approach – it doesn't
    matter, *Ctrl* + *C* is your friend. Press *Ctrl* + *C* to cancel a running command.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行某个命令，有时可能会出于不同的原因取消它。可能是你不小心执行了命令，或者某个命令执行时间过长，亦或你想尝试不同的方法——没关系，*Ctrl*
    + *C* 是你的朋友。按下 *Ctrl* + *C* 来取消正在运行的命令。
- en: Execution Policy
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行策略
- en: 'Before we get started writing PowerShell scripts, let''s take a closer look
    at a mechanism called Execution Policy. If you have tried to run a script on a
    system that was not configured to run scripts, you might have already stumbled
    upon this feature:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写 PowerShell 脚本之前，让我们先详细了解一个名为执行策略（Execution Policy）的机制。如果你曾尝试在未配置为允许运行脚本的系统上运行脚本，可能已经遇到过这个功能：
- en: '![Figure 1.16 – Trying to execute a script on a system with Execution Policy
    configured as Restricted](image/B16679_01_016.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.16 – 尝试在执行策略配置为“Restricted”的系统上执行脚本](image/B16679_01_016.jpg)'
- en: Figure 1.16 – Trying to execute a script on a system with Execution Policy configured
    as Restricted
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 尝试在执行策略配置为“Restricted”的系统上执行脚本
- en: 'Execution Policy is a feature that restricts the execution of PowerShell scripts
    on the system. Use **Get-ExecutionPolicy** to find out how the Execution Policy
    setting is configured:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 执行策略是一个限制系统上 PowerShell 脚本执行的功能。使用**Get-ExecutionPolicy**来查看当前执行策略的配置：
- en: '![Figure 1.17 – Finding out the current Execution Policy setting](image/B16679_01_017.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.17 – 查找当前执行策略设置](image/B16679_01_017.jpg)'
- en: Figure 1.17 – Finding out the current Execution Policy setting
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 – 查找当前执行策略设置
- en: While the default setting on all Windows clients is *Restricted*, the default
    setting on Windows servers is *RemoteSigned*. Having the *Restricted* setting
    configured, the system does not run scripts at all, while *RemoteSigned* allows
    the execution of local scripts and remote scripts that were signed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有 Windows 客户端的默认设置是 *Restricted*，但 Windows 服务器的默认设置是 *RemoteSigned*。在配置为
    *Restricted* 设置的系统中，完全不允许运行脚本，而 *RemoteSigned* 则允许执行本地脚本和已签名的远程脚本。
- en: Configuring Execution Policy
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置执行策略
- en: To start working with PowerShell and create your own scripts, first, you need
    to configure the Execution Policy setting.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Execution Policy is a feature that allows you to avoid running PowerShell code
    by accident. It does not protect against attackers who are trying to run code
    on your system on purpose.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Rather, it is a feature that protects you from your own mistakes – for example,
    if you have downloaded a script from the internet that you want to inspect before
    running, and you double-click on it by mistake, Execution Policy helps you to
    prevent this.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Execution Policy options
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following are the Execution Policy options that determine whether it is
    allowed to run scripts on the current system or whether they need to be signed
    to run:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '**AllSigned**: Only scripts that are signed by a trusted publisher can be executed,
    including local scripts.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *1*, *AppLocker, Application Control, and Code Signing*, you can find out
    more about **script signing**, or you can refer to the online documentation at
    [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_signing](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_signing).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '**Bypass**: Nothing is blocked, and scripts run without generating a warning
    or a prompt.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RemoteSigned**: Only locally created scripts can run if they are unsigned.
    All scripts that were downloaded from the internet, or are stored on a remote
    network location, need to be signed by a trusted publisher.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restricted**: This is the default configuration. It is not possible to run
    PowerShell scripts or load configuration files. It is still possible to run interactive
    code.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unrestricted**: All scripts can be run, regardless of whether they were downloaded
    from the internet or were created locally. If scripts were downloaded from the
    internet, you will still get prompted if you want to run the file.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Execution Policy scope
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To specify who or what will be affected by the Execution Policy feature, you
    can define **scopes**. The **-scope** parameter allows you to set the scope that
    is affected by the Execution Policy feature:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '**CurrentUser**: This means that the current user on this computer is affected.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LocalMachine**: This is the default scope. All users on this computer are
    affected.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MachinePolicy**: This affects all users on this computer.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process**: This only affects the current PowerShell session.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One good way is to sign all scripts that are being run in your organization.
    Through this, you can not only identify which scripts are allowed, but it also
    allows you to use further mitigations such as AppLocker in a better way (you can
    read more about AppLocker in [*"11" on page* *435*](B16679_11_Final_PD.xhtml#_idTextAnchor306),
    *AppLocker, Application Control, and Code Signing*) – and you can configure Execution
    Policy to **AllSigned**.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you develop your own PowerShell scripts, they are not signed while
    you are still working on them.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: To maintain protection from running scripts unintentionally, but to have the
    ability to run locally developed scripts nevertheless, the **RemoteSigned** setting
    is a good approach. In this case, only local scripts (that is, scripts that weren't
    downloaded from the internet and signed) can be run; unsigned scripts from the
    internet will be blocked from running.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **Set-ExecutionPolicy** cmdlet as an administrator to configure the
    Execution Policy setting:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.18 – Configuring the Execution Policy setting](image/B16679_01_018.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: Figure 1.18 – Configuring the Execution Policy setting
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The Execution Policy setting is being configured. Now you can run your own scripts
    and imported modules on your system.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Windows PowerShell – configuring Execution Policy via Group Policy
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't want to set the Execution Policy setting for every machine in your
    organization manually, you can also configure it globally via Group Policy.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: To configure Group Policy for *Windows PowerShell*, create a new **Group Policy
    Object** (**GPO**) that is linked to the root folder in which all your devices
    are located and that you want to configure Execution Policy for.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, navigate to **Computer Configuration** | **Policies** | **Administrative
    Templates** | **Windows Components** | **Windows PowerShell**:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19 – Configuring the Execution Policy feature using GPO for Windows
    PowerShell](image/B16679_01_019.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: Figure 1.19 – Configuring the Execution Policy feature using GPO for Windows
    PowerShell
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Configure the **Turn on Script Execution** setting, and choose the **Allow local
    scripts and remote signed scripts** option, which configures Execution Policy
    to **RemoteSigned**.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell Core – configuring Execution Policy via Group Policy
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Windows PowerShell and PowerShell Core are designed to run in parallel,
    you also need to configure the Execution Policy settings for PowerShell Core.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'The Group Policy settings for PowerShell Core are located in the following
    paths:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '**Computer Configuration** | **Administrative Templates** | **PowerShell Core**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Configuration** | **Administrative Templates** | **PowerShell Core**:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.20 – Configuring the Execution Policy setting using GPO for PowerShell
    Core](image/B16679_01_020.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: Figure 1.20 – Configuring the Execution Policy setting using GPO for PowerShell
    Core
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Configure the settings of your choice, and apply the changes. In this case,
    the settings configured in the Windows PowerShell Group Policy will be applied.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Execution Policy is not a security control – avoiding Execution Policy
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, Execution Policy is a feature that keeps you from running
    scripts unintentionally. It is not a feature designed to protect you from malicious
    users or from code run directly on the machine.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Even if Execution Policy is configured as strictly as possible, you can still
    type in any code into a PowerShell prompt.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, when we speak of *bypassing Execution Policy*, we are simply **avoiding**
    Execution Policy, as you will see in this section. Although it's not a *real hack*,
    some people in the security community still like to call avoiding Execution Policy
    a *bypass*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Execution Policy is quite easy – the easiest way is by using its own
    **-****Bypass** parameter.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: This parameter was introduced when people started to think of Execution Policy
    as a security control. The PowerShell team wanted to avoid this misconception
    so that organizations were not lulled into a false sense of security.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: I created a simple script that just writes **Hello World!** into the console,
    which you can find on GitHub at https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter01/HelloWorld.ps1.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: With Execution Policy set to restricted, I get an error message when I try to
    run the script without any additional parameters.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if I run the script using **powershell.exe** as an administrator with
    the **-ExecutionPolicy** parameter set to **Bypass**, the script runs without
    any issues:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If Execution Policy is configured via *Group Policy*, it **can't be avoided**
    just by using the **-****Bypass** parameter.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'As Execution Policy only restricts the execution of scripts, another way is
    to simply pass the content of the script to **Invoke-Expression**. Again, the
    content of the script is run without any issues – even if Execution Policy was
    configured using Group Policy:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Piping the content of the script into **Invoke-Expression** causes the content
    of the script to be handled as if the commands were executed locally using the
    command line; this bypasses Execution Policy and Execution Policy only applies
    to executing scripts and not local commands.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Those are only some examples out of many ways to avoid **ExecutionPolicy**,
    there are some examples of avoiding **ExecutionPolicy** in [*"8" on page* *337*](B16679_08_Final_PD.xhtml#_idTextAnchor204),
    *Red Team Tasks and Cookbook*. Therefore, don't be under the false impression
    that **ExecutionPolicy** protects you from attackers.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in what mitigations can help you to improve the security
    of your environment, you can read more about it in *Section 3*, *Securing PowerShell
    – Effective Mitigations* *in Detail*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Help system
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be successful in PowerShell, understanding and using the help system is key.
    To get started, you will find some useful advice in this book. As I will cover
    only the basics and mostly concentrate on scripting for cybersecurity, I advise
    you to also review the documentation on the PowerShell help system. This can be
    found at https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/02-help-system.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three functions that make your life easier when you are working with
    PowerShell:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '**Get-Help**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-Command**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-Member**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a deeper look at how to use them and how they can help you.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Get-Help
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are familiar with working on Linux systems, **Get-Help** is similar to
    what the **man** pages in Linux are, that is, a collection of how-to pages and
    tutorials on how to use certain commands in the best way possible.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: If you don't know how to use a command, just use **Get-Help <command>** and
    you will know which options it provides and how to use it.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are running **Get-Help** for the first time on your computer, you
    might only see a very restricted version of the help pages, along with a remark
    that states that the help files are missing for this cmdlet on this computer:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As mentioned, the output only displays partial help:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1.21 – Output of Get-Help when the \uFEFFhelp files are missing for\
    \ a cmdlet](image/B16679_01_021.jpg)"
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: Figure 1.21 – Output of Get-Help when the help files are missing for a cmdlet
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, first, you need to update your help files. An internet connection
    is required. Open PowerShell as an administrator and run the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see an overlay that shows you the status of the update:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 1.22 – Updating \uFEFFhelp](image/B16679_01_022.jpg)"
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: Figure 1.22 – Updating help
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the update is finished, you can use all the help files as intended.
    As help files get quickly outdated, it makes sense to update them regularly or
    even create a scheduled task to update the help files on your system.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Did You Know?
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell help files are not deployed by default because the files get outdated
    so quickly. As it makes no sense to ship outdated help files, they are not installed
    by default.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following **Get-Help** parameters:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '**Detailed**: This displays the basic help page and adds parameter descriptions
    along with examples.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Examples**: This only displays the example section.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full**: This displays the complete help page.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Online**: This displays the online version of the specified help page. It
    does not work in a remote session.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameter**: This parameter only displays help for the specified parameter.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ShowWindow**: This displays the help page in a separate window. It not only
    provides better reading comfort but also allows you to search and configure the
    settings.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The easiest way to get all the information that the help file provides is by
    using the **-****Full** parameter:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running this command gets you the full help pages for the **Get-Content** function:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.23 – The full Help pages for the Get-Content function](image/B16679_01_023.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
- en: Figure 1.23 – The full Help pages for the Get-Content function
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Please also review the official PowerShell documentation for more advanced
    ways of **Get-Help**: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/get-help](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/get-help).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Get-Command
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Get-Command** gets you all commands that are currently installed on the computer,
    including aliases, applications, cmdlets, filters, functions, and scripts:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Additionally, it can show you which commands are available for a certain module.
    In this case, we investigate the **EventList** module that we have installed from
    the **PowerShell Gallery**, which is a central repository for the modules, scripts,
    and other PowerShell-related resources:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Get-Command** can be also very helpful if you are looking for a specific
    cmdlet, but you can''t remember its name. For example, if you want to find out
    all the cmdlets that are available on your computer that have **Alias** in their
    name, **Get-Command** can be very helpful:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you don''t remember a certain command exactly, use the **-UseFuzzyMatching**
    parameter. This shows you all of the related commands:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Additionally, please review the documentation to get more advanced examples
    on how **Get-Command** can help you: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/get-command](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/get-command).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Get-Member
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Get-Member** helps you to display the members within an object.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: In PowerShell, everything is an object, even a simple string. **Get-Member**
    is very useful for seeing which operations are possible.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you want to see what operations are possible when using your **"Hello
    World!"** string, just type in the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All available methods and properties will be displayed, and you can choose
    from the list the one that best fits your use case:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.24 – Displaying all the available members of a string](image/B16679_01_024.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: Figure 1.24 – Displaying all the available members of a string
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, I also inserted the **| Sort-Object Name** string.
    It sorts the output alphabetically and helps you to quickly find a method or property
    by name.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: If **Sort-Object** was not specified, **Get-Member** would have sorted the output
    alphabetically by **MemberType** (that is, **Method**, **ParameterizedProperty**,
    and **Property**).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have chosen the operation that you want to run, you can use it by
    adding**.**(a *dot*), followed by the *operation*. So, if you want to find out
    the length of your string, add the **Length** operation:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Of course, you can also work with variables, numbers, and all other objects.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the data type of a variable, you can use **GetType()**. In this
    example, we use **GetType()** to find out that the data type of the **$x** variable
    is integer:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To get more advanced examples regarding how to use **Get-Member**, please also
    make sure that you review the official documentation at [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/get-member](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/get-member).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell versions
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As PowerShell functionalities are often tied to a certain version, it might
    be useful to check the PowerShell version that is installed on your system.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the **$PSVersionTable.PSVersion** environment variable:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, PowerShell 5.1 has been installed.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Exploring security features added with each version
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PowerShell is backward compatible with earlier versions. Therefore, it makes
    sense to always upgrade to the latest version.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: But let's have a look at which security-related features were made available
    with which version. This overview should serve only as a reference, so I won't
    dive into every feature in detail.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell v1
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first PowerShell version, PowerShell v1, was released in 2006 as a standalone
    version. It introduced the following list of security-related features:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Signed scripts and PowerShell **Subject Interface** **Package** (**SIP**).
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-AuthenticodeSignature**, ***-Acl**, and **Get-PfxCertificate cmdlets.**'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution Policy.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requiring *intent* to run scripts from the current directory (**./foo.ps1**).
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts are not run if they are double-clicked.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell Engine logging: Some commands could be logged via **LogPipelineExecutionDetails**,
    although this is difficult to configure.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Built-in protection from scripts that are sent directly via email: This intentionally
    adds PowerShell extensions to Windows'' *Unsafe to* *email* list.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software Restriction Policies** (**SRPs**) and AppLocker support.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell v2
  id: totrans-364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In 2009, the second version of PowerShell (PowerShell v2) was released. This
    version was included in the Windows 7 OS by default. It offered the following
    list of features:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Eventing
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes within Execution Policy
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Scopes* to Execution Policy (the process, user, and machine)'
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The *ExecutionPolicy Bypass* implementation to make people stop treating it
    like a security control
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell remoting security
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules and module security
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IIS-hosted remoting endpoints
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This was very difficult to configure and required DIY constrained endpoints.
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add-Type**'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data language
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell v3
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'PowerShell v3, released in 2012, was included by default in the Windows 8 OS.
    It offered the following list of features:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Unblock-File and alternate data stream management in core cmdlets.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial implementation of constrained language (for Windows RT).
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registry settings for module logging (via **LogPipelineExecutionDetails**).
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Constrained endpoints: These were still hard to configure, but a *more* admin-friendly
    version of IIS-hosted remoting endpoints.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell v4
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Following PowerShell version v3, PowerShell v4 was just released in 2013 –
    1 year after the former version – and was included, by default, in the Windows
    8.1 OS. Its features are listed as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Workflows.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DSC security, especially for signed policy documents.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell web services security.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With KB3000850, many significant security features could be ported into PowerShell
    version 4, such as module logging, script block logging, transcription, and more.
    However, those features were included, by default, in PowerShell version 5.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell v5
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'PowerShell v5 was released in 2015 and was included, by default, in the Windows
    10 OS. A lot of security features that are available nowadays in PowerShell were
    provided with this release. They are listed as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Security transparency
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AMSI**'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transcription
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script block logging
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module logging
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protected event logging
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JEA
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local JEA (for interactive constrained/kiosk modes)
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure code generation APIs
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constrained language
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cryptographic Message Syntax** (**CMS**) cmdlets, ***-FileCatalog** cmdlets,
    **ConvertFrom-SddlString**, **Format-Hex**, and **Get-FileHash**'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell Gallery security
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Revoke-Obfuscation**'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Injection Hunter module
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell classes security
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell v6
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With PowerShell v6, which was released as a standalone in 2018, the PowerShell
    team was mostly focused on the effort to make PowerShell available cross-platform
    as open source software. PowerShell v6 introduced the first macOS and Unix shell
    to offer full security transparency. Its features include the following:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH on Windows
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cross-platform parity: full security transparency via Syslog'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell editors
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get started, you might want to choose an editor. Before you start
    typing your scripts into **notepad.exe** or want to use PowerShell ISE for PowerShell
    7, let's take a look at what PowerShell editors you can use for free and what
    the potential downsides are.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Windows PowerShell ISE
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Windows PowerShell** **Integrated Scripting Environment** (**ISE**) is
    a host application that is integrated within Microsoft Windows systems. As this
    application is pre-installed, this makes it very easy for beginners to simply
    open the Windows PowerShell ISE and type in their very first script.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: The downside of the Windows PowerShell ISE is that, currently, it **does not
    support PowerShell Core** – and currently, there's no intention by the PowerShell
    team to add support.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: To open it, you can either open the Windows Start menu and search for **PowerShell
    ISE**, or you can run it by opening the command line, using the *Windows key*
    + *R* shortcut, and typing in **powershell_ise** or **powershell_ise.exe**.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: When you start the Windows PowerShell ISE, you will only see a PowerShell command
    line, the menu, and the available commands. Before you can use the editor, you
    either need to open a file or create a new blank file.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also click on the little drop-down arrow on the right-hand side to
    expand the scripting pane or enable the scripting pane from the **View** menu:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.25 – Windows PowerShell ISE after opening a new file](image/B16679_01_025.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
- en: Figure 1.25 – Windows PowerShell ISE after opening a new file
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows 10 devices, the default location of the PowerShell ISE is under
    the following:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows PowerShell ISE:'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**%****windir%\system32\WindowsPowerShell\v1.0\PowerShell_ISE.exe**'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows PowerShell ISE (x86):'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**%****windir%\syswow64\WindowsPowerShell\v1.0\PowerShell_ISE.exe**'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Where Do Those Nasty Errors Come From?
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: When working with PowerShell or the PowerShell ISE, sometimes, errors can appear
    that are caused by the fact that you had insufficient permissions. To overcome
    that issue, start PowerShell (ISE) as an administrator if your use case requires
    it.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Windows PowerShell ISE commands
  id: totrans-427
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On the right-hand pane, you can browse through all commands and modules that
    are available in this session. Especially if you are not that familiar with existing
    cmdlets, this can help you a lot.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yes, you could just use Windows PowerShell or Windows PowerShell ISE to work
    with PowerShell 5.1\. But honestly, you should use PowerShell Core 7 instead.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: You want to write complex scripts, functions, and modules, and, therefore, you
    want to use a good editor that supports you while scripting.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code is not the only recommended editor to use to edit PowerShell,
    but it comes for free as an open source and cross-platform version.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: It was developed by Microsoft and can be downloaded from the official Visual
    Studio Code web page at [https://code.visualstudio.com/](https://code.visualstudio.com/).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio versus Visual Studio Code
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you search for Visual Studio Code, it often happens that you stumble onto
    Visual Studio, which is – despite the name – a completely different product.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio is a full-featured **integrated development environment** (**IDE**),
    which consists of multiple tools that help a developer to develop, debug, compile,
    and deploy their code. Visual Studio even contains a tool to easily design **GUI**
    components.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code is an editor that provides a lot of features, but in the
    end, it is very useful for code developers. Additionally, it provides Git integration,
    which makes it very easy to connect with your versioning system to track changes
    and eventually revert them.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, Visual Studio is a big suite that was designed to develop apps
    for Android, iOS, Mac, Windows, the web, and the cloud, as Microsoft states. In
    comparison, Visual Studio Code is a code editor that supports thousands of extensions
    and provides many features. Visual Studio does not run on Linux systems, while
    Visual Studio Code works on cross-platform systems.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: As Visual Studio is a full-featured IDE with many features, it might take longer
    to load when starting the program. So, for working with PowerShell, I recommend
    using Visual Studio Code, which is not only my preferred editor but also the recommended
    editor for PowerShell.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Working with Visual Studio Code
  id: totrans-440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Visual Studio Code offers some great benefits when working with PowerShell.
    The PowerShell team has even released a guide on how to leverage Visual Studio
    Code for your PowerShell development. You can find it at [https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode](https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have installed Visual Studio Code onto your OS, this is what the UI
    should look like when you open it:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.26 – The Visual Studio Code editor](image/B16679_01_026.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
- en: Figure 1.26 – The Visual Studio Code editor
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get the most out of Visual Studio Code, make sure that you follow
    the documentation. Nevertheless, here are my must-haves when working on my PowerShell
    projects in Virtual Studio Code.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Installing the PowerShell extension
  id: totrans-446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To properly work with PowerShell using Visual Studio Code, the PowerShell extension
    should be installed and activated.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: If you start a new project or file and use PowerShell code before installing
    the PowerShell extension, Visual Studio Code suggests installing the PowerShell
    extension. Confirm with **Yes** to the prompt on the installation of the PowerShell
    extension.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to download the extension manually, you can download the Visual
    Studio PowerShell extension via the following link: [https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell](https://marketplace.visualstudio.com/items?itemName=ms-vscode.PowerShell).'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Launch the quick opening option by pressing *Ctrl* + *P* and type in **ext install
    powershell**. Then, press *Enter*.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: The extensions pane opens. Search for **PowerShell** and click on the **Install**
    button. Follow the instructions.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation, the PowerShell extension is automatically displayed.
    If you want to access it later again, you can either open the **Extensions** pane
    directly from the menu or by using the *Ctrl* + *Shift* + *X* shortcut:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.27 – Visual Studio Code: Installing the PowerShell extension](image/B16679_01_027.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.27 – Visual Studio Code: Installing the PowerShell extension'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Automated Formatting in Visual Studio Code
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: By pressing *Alt* + *Shift* + *F*, Visual Studio Code automatically formats
    your current code. You can specify your formatting preferences by adjusting your
    workspace configuration.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to get started when working with PowerShell
    for cybersecurity. You obtained a high-level understanding of OOP and its four
    main principles. You learned what properties and methods are and how they apply
    to an object.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: You now understand how to install the latest version of PowerShell Core and
    understand how to perform some basic tasks such as working with the history, clearing
    the screen, and canceling commands.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: You have learned that Execution Policy is only a feature that keeps you from
    running scripts unintentionally, and it's important to understand that it is not
    a security control to prevent you from attackers.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to help yourself and obtain more information about cmdlets,
    functions, methods, and properties, using the help system.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have also found and installed your preferred PowerShell editor,
    you are ready to get started, learn about the PowerShell scripting fundamentals,
    and write your first scripts in the next chapter.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to explore some of the topics that were mentioned in this chapter,
    use these resources:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting Started with PowerShell: [https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/01-getting-started](https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/01-getting-started)'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing and upgrading to PowerShell version 5.1: [https://docs.microsoft.com/en-us/powershell/scripting/windows-powershell/install/installing-windows-powershell](https://docs.microsoft.com/en-us/powershell/scripting/windows-powershell/install/installing-windows-powershell)'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Migrating from Windows PowerShell 5.1 to PowerShell 7: [https://docs.microsoft.com/en-us/powershell/scripting/install/migrating-from-windows-powershell-51-to-powershell-7](https://docs.microsoft.com/en-us/powershell/scripting/install/migrating-from-windows-powershell-51-to-powershell-7).'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing the latest PowerShell release on Windows: [https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows)'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing PowerShell on Linux: [https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux)'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing PowerShell on macOS: [https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-macos](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-macos)'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing PowerShell on ARM: [https://docs.microsoft.com/en-us/powershell/scripting/install/powershell-core-on-arm](https://docs.microsoft.com/en-us/powershell/scripting/install/powershell-core-on-arm)'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using PowerShell in Docker: [https://docs.microsoft.com/en-us/powershell/scripting/install/powershell-in-docker](https://docs.microsoft.com/en-us/powershell/scripting/install/powershell-in-docker)'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell ♥ the Blue Team: [https://devblogs.microsoft.com/powershell/powershell-the-blue-team/](https://devblogs.microsoft.com/powershell/powershell-the-blue-team/)'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using Visual Studio Code for PowerShell Development: [https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode](https://docs.microsoft.com/en-us/powershell/scripting/dev-cross-plat/vscode/using-vscode)'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also find all the links mentioned in this chapter in the GitHub repository
    for [*Chapter 1*](B16679_01_Final_PD.xhtml#_idTextAnchor016). There is no need
    to manually type in every link: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter01/Links.md](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter01/Links.md).'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
