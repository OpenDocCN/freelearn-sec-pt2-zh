<html><head></head><body>
		<div id="_idContainer051">
			<h1 class="chapter-number" id="_idParaDest-32"><a id="_idTextAnchor034"/>2</h1>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor035"/>PowerShell Scripting Fundamentals</h1>
			<p>Now that you have learned how to get started with PowerShell, let’s have a closer look at PowerShell scripting fundamentals to refresh <span class="No-Break">our knowledge.</span></p>
			<p>We will start with the basics, such as working with variables, operators, and control structures. Then, we will dive deeper, putting the big picture together when it comes to cmdlets, functions, and <span class="No-Break">even modules.</span></p>
			<p>After working through this chapter, you should be able to create your very own scripts and even know how to create your <span class="No-Break">own modules.</span></p>
			<p>In this chapter, we are going to cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li><span class="No-Break">Variables</span></li>
				<li><span class="No-Break">Operators</span></li>
				<li><span class="No-Break">Control structures</span></li>
				<li><span class="No-Break">Naming conventions</span></li>
				<li><span class="No-Break">Cmdlets</span></li>
				<li><span class="No-Break">Functions</span></li>
				<li><span class="No-Break">Aliases</span></li>
				<li><span class="No-Break">Modules</span></li>
			</ul>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor036"/>Technical requirements</h1>
			<p>For this chapter, you will need <span class="No-Break">the following:</span></p>
			<ul>
				<li>PowerShell 7.3 <span class="No-Break">and above</span></li>
				<li>Visual <span class="No-Break">Studio Code</span></li>
				<li>Access to the GitHub repository for <span class="No-Break"><strong class="source-inline">Chapter02</strong></span><span class="No-Break">: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter02"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter02</span></a><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/tree/master/Chapter02&#13;"/></li>
			</ul>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor037"/>Variables</h1>
			<p>A <strong class="bold">variable</strong> is a storage<a id="_idIndexMarker170"/> location that developers can use to store information with a <a id="_idIndexMarker171"/>so-called <em class="italic">value</em>. Variables always have names that allow you to call them independently of the values that are stored within. In PowerShell, the <strong class="source-inline">$</strong> sign at the beginning indicates <span class="No-Break">a variable:</span></p>
			<pre class="source-code">
&gt; $i = 1
&gt; $string = "Hello World!"
&gt; $this_is_a_variable = "test"</pre>
			<p>Variables are great for storing simple values, strings, and also the output <span class="No-Break">of commands:</span></p>
			<pre class="source-code">
&gt; Get-Date
Monday, November 2, 2020 6:43:59 PM
&gt; $date = Get-Date
&gt; Write-Host "Today is" $date
Today is 11/2/2020 6:44:40 PM</pre>
			<p>As you can see in these examples, not only can we store strings and numbers within a variable, we can also store the output of a cmdlet such as <strong class="source-inline">Get-Date</strong> and reuse it within <span class="No-Break">our code.</span></p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor038"/>Data types</h2>
			<p>In contrast to other<a id="_idIndexMarker172"/> scripting or programming languages, you don’t necessarily <a id="_idIndexMarker173"/>need to define the data type for variables. When defining a variable, the data type that makes the most sense is <span class="No-Break">automatically set:</span></p>
			<pre class="source-code">
&gt; $x = 4
&gt; $string = "Hello World!"
&gt; $date = Get-Date</pre>
			<p>You can find out which data type was used with the <span class="No-Break"><strong class="source-inline">GetType()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
&gt; $x.GetType().Name
Int32
&gt; $string.GetType().Name
String
&gt; $date.GetType().Name
DateTime</pre>
			<p>In PowerShell, data types <a id="_idIndexMarker174"/>are automatically set. When defining variables in an<a id="_idIndexMarker175"/> automated way, sometimes it can happen that the wrong variable type is set. For example, it can happen that an integer was defined as a string. If you spot a conflict, the <strong class="source-inline">GetType()</strong> method helps you to find out which data type <span class="No-Break">was set.</span></p>
			<h3>Overview of data types</h3>
			<p>The following table <a id="_idIndexMarker176"/>shows a list of variable data types with <span class="No-Break">their description:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer041">
					<img alt="Table 2.1 – Variable data types" src="image/B16679_02_Table_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 2.1 – Variable data types</p>
			<p>These are the most common data types that you will come across when working with PowerShell. This is not a complete list, so there might also be other variables that you will encounter: using <strong class="source-inline">GetType()</strong> helps you identify the variable <span class="No-Break">data type.</span></p>
			<p>In PowerShell, all data types<a id="_idIndexMarker177"/> are based on .NET classes; to get more information <a id="_idIndexMarker178"/>on each class, you can refer to the official <span class="No-Break">Microsoft </span><span class="No-Break"><a id="_idIndexMarker179"/></span><span class="No-Break">documentation:</span></p>
			<ul>
				<li><a href="https://learn.microsoft.com/en-us/dotnet/api/system"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/api/system</span></a></li>
				<li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.management.automation"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/api/system.management.automation</span></a></li>
			</ul>
			<h3>Casting variables</h3>
			<p>Normally, there’s no need to<a id="_idIndexMarker180"/> declare data types, as PowerShell <a id="_idIndexMarker181"/>does it by itself. But sometimes there might be a need to change the data type – for example, if a list of imported number values is treated like a string instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; $number = "4"
&gt; $number.GetType().Name
String</pre>
			<p>If you are processing values that have the wrong data type declared, you will either see nasty error messages (because only another input is accepted) or your code will not work <span class="No-Break">as expected.</span></p>
			<p>If the <strong class="source-inline">$number</strong> variable was declared as a string and we perform an addition, a mathematical operation will not be performed. Instead, both are concatenated as <span class="No-Break">a string:</span></p>
			<pre class="source-code">
&gt; $number + 2
42</pre>
			<p>Although 42 might be the answer to the ultimate question of life, the universe, and everything, it is not the expected answer for our equation: when adding <em class="italic">4 + 2</em>, we expect the result <em class="italic">6</em>, but since <em class="italic">4</em> is treated as a string, <em class="italic">2</em> will be concatenated and the string <em class="italic">42</em> is shown as <span class="No-Break">a result:</span></p>
			<pre class="source-code">
&gt; ($number + 2).GetType().Name
String</pre>
			<p>Especially when parsing files or input, it can happen that variables are not set correctly. If that happens, error messages or wrong operations are the results. Of course, this behavior is not <a id="_idIndexMarker182"/>strictly limited to integers and strings: it <a id="_idIndexMarker183"/>can basically occur with every other data type <span class="No-Break">as well.</span></p>
			<p>If you discover that a wrong data type is set, you can convert the data type by <strong class="bold">casting</strong> it to <span class="No-Break">another type.</span></p>
			<p>If we want, for example, to process <strong class="source-inline">$number</strong> as a normal integer, we need to cast the variable type <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">[int]</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; $int_number = [int]$number
&gt; $int_number.GetType().Name
Int32</pre>
			<p>Now, <strong class="source-inline">$int_number</strong> can be processed as a normal integer, and performing mathematical operations works <span class="No-Break">as expected:</span></p>
			<pre class="source-code">
&gt; $int_number + 2
6</pre>
			<p>You can also cast a Unicode hex string into a character in PowerShell by using the hex value of the Unicode string and casting it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">[char]</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; 0x263a
9786
&gt; [char]0x263a
☺</pre>
			<p>Most of the time, the<a id="_idIndexMarker184"/> right variable data type is already set <a id="_idIndexMarker185"/>automatically by PowerShell. Casting data types helps you to control how to process the data, avoiding wrong results and <span class="No-Break">error messages.</span></p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor039"/>Automatic variables</h2>
			<p>Automatic variables are <a id="_idIndexMarker186"/>built-in variables that are created and maintained <span class="No-Break">by </span><span class="No-Break"><a id="_idIndexMarker187"/></span><span class="No-Break">PowerShell.</span></p>
			<p>Here is just a small collection of commonly used automatic variables that are important for beginners. You might find other automatic variables used in <span class="No-Break">later chapters:</span></p>
			<ul>
				<li><strong class="source-inline">$?</strong>: The execution status of the last command. If the last command succeeded, it is set to <strong class="source-inline">True</strong>, otherwise, it is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">False</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">$_</strong>: When processing a pipeline object, <strong class="source-inline">$_</strong> can be used to access the current object (<strong class="source-inline">$PSItem</strong>). It can also be used in commands that execute an action on every item, as in the <span class="No-Break">following example:</span><pre class="source-code">
<strong class="bold">Get-ChildItem -Path C:\ -Directory -Force -ErrorAction SilentlyContinue | ForEach-Object {</strong></pre><pre class="source-code">
<strong class="bold">    Write-Host $_.FullName</strong></pre><pre class="source-code">
<strong class="bold">}</strong></pre></li>
				<li><strong class="source-inline">$Error</strong>: Contains the most recent errors, collected in an array. The most recent error can be found <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">$Error[0]</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">$false</strong>: Represents the traditional Boolean value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">False</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">$LastExitCode</strong>: Contains the last exit code of the program that <span class="No-Break">was run.</span></li>
				<li><strong class="source-inline">$null</strong>: Contains <strong class="source-inline">null</strong> or an empty value. It can be used to check whether a variable contains a value or to set an undefined value when scripting, as <strong class="source-inline">$null</strong> is still treated like an object with <span class="No-Break">a value.</span></li>
				<li><strong class="source-inline">$PSScriptRoot</strong>: The location of the directory from which the script is being run. It can help you to address <span class="No-Break">relative paths.</span></li>
				<li><strong class="source-inline">$true</strong>: Contains <strong class="source-inline">True</strong>. You <a id="_idIndexMarker188"/>can use <strong class="source-inline">$true</strong> to represent <strong class="source-inline">True</strong> in commands<a id="_idIndexMarker189"/> <span class="No-Break">and scripts.</span></li>
			</ul>
			<p>For a complete list of<a id="_idIndexMarker190"/> automatic variables, please review the official <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor040"/>Environment variables</h2>
			<p>Environment variables store<a id="_idIndexMarker191"/> information about the operating system and<a id="_idIndexMarker192"/> paths that are frequently used by <span class="No-Break">the system.</span></p>
			<p>To show all environment variables within your session, you can leverage <strong class="source-inline">dir env:</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer042">
					<img alt="Figure 2.1 – Environment variables" src="image/B16679_02_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Environment variables</p>
			<p>You can directly <a id="_idIndexMarker193"/>access and reuse those variables by using the <a id="_idIndexMarker194"/><span class="No-Break">prefix </span><span class="No-Break"><strong class="source-inline">$env:</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; $env:PSModulePath
C:\Users\PSSec\Documents\WindowsPowerShell\Modules;C:\Program Files\WindowsPowerShell\Modules;C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules</pre>
			<p>To learn more about how to access and<a id="_idIndexMarker195"/> process environment variables, have a look at the official <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_environment_variables"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_environment_variables</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor041"/>Reserved words and language keywords</h2>
			<p>Some words are reserved by<a id="_idIndexMarker196"/> the system and should not be used as variables or function names, as this would lead to confusion and unexpected behavior of <span class="No-Break">your code.</span></p>
			<p>By using <strong class="source-inline">Get-Help</strong>, you can get a list and more information on <span class="No-Break">reserved words:</span></p>
			<pre class="source-code">
&gt; Get-Help about_reserved_words</pre>
			<p>Also see the <strong class="source-inline">about_Language_Keywords</strong> help <a id="_idIndexMarker197"/>pages to get a detailed overview and explanation of all <span class="No-Break">language keywords:</span></p>
			<pre class="source-code">
&gt; Get-Help about_Language_Keywords</pre>
			<p>Here’s an overview of all the language keywords that were available when this book <span class="No-Break">was written:</span></p>
			<pre class="source-code">
Begin               Enum               Param
Break               Exit               Process
Catch               Filter             Return
Class               Finally            Static
Continue            For                Switch
Data                ForEach            Throw
Define              From               Trap
Do                  Function           Try
DynamicParam        Hidden             Until
Else                If                 Using
Elseif              In                 Var
End                 InlineScript       While</pre>
			<p>To learn more about a certain <a id="_idIndexMarker198"/>language keyword, you can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">Get-Help</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-Help break</pre>
			<p>Some reserved words (such as <strong class="source-inline">if</strong>, <strong class="source-inline">for</strong>, <strong class="source-inline">foreach</strong>, and <strong class="source-inline">while</strong>) have their own help articles. To read them, add <strong class="source-inline">about_</strong> as <span class="No-Break">a prefix:</span></p>
			<pre class="source-code">
&gt; Get-Help about_If</pre>
			<p>If you don’t find a help page for a certain reserved word, as not every one has its own page, you can use <strong class="source-inline">Get-Help</strong> to find help pages that write about the word you are <span class="No-Break">looking for:</span></p>
			<pre class="source-code">
&gt; Get-Help filter -Category:HelpFile</pre>
			<p>Keep those<a id="_idIndexMarker199"/> reserved words in mind and avoid using them as function, variable, or parameter names. Using reserved words can and will lead to a malfunction of <span class="No-Break">your code.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor042"/>Variable scope</h2>
			<p>When working with PowerShell<a id="_idIndexMarker200"/> variables, you want to restrict access. If you use a variable in a function, you don’t want it to be available by default on the command line – especially if you are processing protected values. PowerShell variable scopes protect access to variables <span class="No-Break">as needed.</span></p>
			<p>In general, variables are only available in the context in which they were set, u<a id="_idTextAnchor043"/>nless the scope <span class="No-Break">is modified:</span></p>
			<pre class="source-code">
$script:ModuleRoot = $PSScriptRoot
# Sets the scope of the variable $ModuleRoot to script</pre>
			<h3>Scope modifier</h3>
			<p>Using the scope modifier, you can configure the scope in which your variables will be available. Here is an overview of the<a id="_idIndexMarker201"/> most commonly used <span class="No-Break">scope modifiers:</span></p>
			<ul>
				<li><strong class="source-inline">global</strong>: Sets<a id="_idIndexMarker202"/> the scope to <strong class="source-inline">global</strong>. This scope is effective when <a id="_idIndexMarker203"/>PowerShell starts or if you create a <span class="No-Break">new session.</span></li>
			</ul>
			<p>For example, if you set a variable to <strong class="source-inline">global</strong> within a module, once the module is loaded and the part is run in which the variable is set to <strong class="source-inline">global</strong>, this variable will be available in the session – even if you don’t run other functions of <span class="No-Break">this module.</span></p>
			<ul>
				<li><strong class="source-inline">local</strong>: This is the <a id="_idIndexMarker204"/>current <a id="_idIndexMarker205"/>scope. The <strong class="source-inline">local</strong> scope can be the <strong class="source-inline">global</strong> scope, the <strong class="source-inline">script</strong> scope, or any <span class="No-Break">other scope.</span></li>
				<li><strong class="source-inline">script</strong>: This<a id="_idIndexMarker206"/> scope is only effective within the script that sets this scope. It can be very <a id="_idIndexMarker207"/>useful if you want to set a variable only within a module that should not be available after the function <span class="No-Break">was called.</span></li>
			</ul>
			<p>To demonstrate how <a id="_idIndexMarker208"/>variable scopes work, I have prepared a little script, <strong class="source-inline">Get-VariableScope.ps1</strong>, which can be found in <strong class="source-inline">Chapter02</strong> of this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Get-VariableScope.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Get-VariableScope.ps1</span></a><span class="No-Break">.</span></p>
			<p>In the script, the <strong class="source-inline">Set-Variables</strong> function is declared first. If this function is called, it sets variables of three scopes – <strong class="source-inline">local</strong>, <strong class="source-inline">script</strong>, and <strong class="source-inline">global</strong> – and then outputs <span class="No-Break">each variable.</span></p>
			<p>Then, the <strong class="source-inline">Set-Variable</strong> function is called by the same script. After calling the function, the variables are written to <span class="No-Break">the output:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer043">
					<img alt="Figure 2.2 – Calling variables with a local, script, and global scope" src="image/B16679_02_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Calling variables with a local, script, and global scope</p>
			<p>While the variables were just set in the <strong class="source-inline">local</strong> scope, all configured variables are available when called in<a id="_idIndexMarker209"/> this context (<span class="No-Break"><strong class="bold">local scope</strong></span><span class="No-Break">).</span></p>
			<p>If the same script tries to access the defined variables outside of the function in which the variables were configured, it can still access the variables that were configured for the <strong class="source-inline">script</strong> and <strong class="source-inline">global</strong> scope. The variable with the <strong class="source-inline">local</strong> scope is inaccessible, as the variables were called<a id="_idIndexMarker210"/> in the <span class="No-Break"><strong class="bold">script scope</strong></span><span class="No-Break">.</span></p>
			<p>After <a id="_idIndexMarker211"/>running the <strong class="source-inline">Get-VariableScope.ps1</strong> script, try to access the variables on the command line yourself (<span class="No-Break"><strong class="bold">global scope</strong></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer044">
					<img alt="Figure 2.3 – Accessing the variables on the command line" src="image/B16679_02_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Accessing the variables on the command line</p>
			<p>You can imagine scopes as <em class="italic">containers for variables</em> therefore, in this case, we can only access variables within the <strong class="source-inline">global</strong> scope container. The variables with the <strong class="source-inline">local</strong> and <strong class="source-inline">script</strong> scopes are inaccessible from the command line when not called from the script they were <span class="No-Break">defined in.</span></p>
			<p>When working with scopes, it is advisable to <em class="italic">choose the scope that offers the minimum required privileges</em> for your use case. This can help prevent accidental script breakage when running scripts multiple times in the same session. While using the <strong class="source-inline">global</strong> scope is not necessarily problematic from a security standpoint, it is still best to avoid it when not <span class="No-Break">strictly</span><span class="No-Break"><a id="_idIndexMarker212"/></span><span class="No-Break"> necessary.</span></p>
			<p class="callout-heading">Working with Modified Scope Variables</p>
			<p class="callout">When you are working with <strong class="source-inline">script</strong> and <strong class="source-inline">global</strong> scope variables, it is a good practice to always use the variable with the modifier: <strong class="source-inline">$script:script_variable</strong> / <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">global:global_variable</strong></span><span class="No-Break">.</span></p>
			<p class="callout">Although it is possible to use the variable without the modifier (<strong class="source-inline">$script_variable</strong> / <strong class="source-inline">$global_variable</strong>), using it with the modifier helps you to see at one glance whether the scope of a variable was changed, helps you with your troubleshooting, and <span class="No-Break">avoids confusion.</span></p>
			<p>Scopes are not only restricted to variables; they can also be used to restrict functions, aliases, and PowerShell drives. Of course, there are also many more use cases for scopes than the ones I described in <span class="No-Break">this section.</span></p>
			<p>If you are interested to <a id="_idIndexMarker213"/>learn more about scopes (not only variable scopes) and advanced use cases, have a look at the official <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor044"/>Operators</h1>
			<p>Operators help you not only to<a id="_idIndexMarker214"/> perform mathematical or logical operations but they are also a good way to compare values or <span class="No-Break">redirect values.</span></p>
			<p><span class="No-Break">Arithmetic operators</span></p>
			<p>Arithmetic operators<a id="_idIndexMarker215"/> can be used to calculate values. They are<a id="_idIndexMarker216"/> <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Addition</strong></span><span class="No-Break"> </span><span class="No-Break"><a id="_idIndexMarker217"/></span><span class="No-Break">(</span><span class="No-Break"><strong class="source-inline">+</strong></span><span class="No-Break">):</span><pre class="source-code">
<strong class="bold">&gt; $a = 3; $b = 5; $result = $a + $b</strong></pre><pre class="source-code">
<strong class="bold">&gt; $result</strong></pre><pre class="source-code">
<strong class="bold">8</strong></pre></li>
				<li><span class="No-Break"><strong class="bold">Subtraction</strong></span><span class="No-Break"> </span><span class="No-Break"><a id="_idIndexMarker218"/></span><span class="No-Break">(</span><span class="No-Break"><strong class="source-inline">-</strong></span><span class="No-Break">):</span><pre class="source-code">
<strong class="bold">&gt; $a = 3; $b = 5; $result = $b - $a</strong></pre><pre class="source-code">
<strong class="bold">&gt; $result</strong></pre><pre class="source-code">
<strong class="bold">2</strong></pre></li>
				<li><span class="No-Break"><strong class="bold">Multiplication</strong></span><span class="No-Break"> </span><span class="No-Break"><a id="_idIndexMarker219"/></span><span class="No-Break">(</span><span class="No-Break"><strong class="source-inline">*</strong></span><span class="No-Break">):</span><pre class="source-code">
<strong class="bold">&gt; $a = 3; $b = 5; $result = $a * $b</strong></pre><pre class="source-code">
<strong class="bold">&gt; $result</strong></pre><pre class="source-code">
<strong class="bold">15</strong></pre></li>
				<li><span class="No-Break"><strong class="bold">Division</strong></span><span class="No-Break"> </span><span class="No-Break"><a id="_idIndexMarker220"/></span><span class="No-Break">(</span><span class="No-Break"><strong class="source-inline">/</strong></span><span class="No-Break">):</span><pre class="source-code">
<strong class="bold">&gt; $a = 12; $b = 4; $result = $a / $b</strong></pre><pre class="source-code">
<strong class="bold">&gt; $result</strong></pre><pre class="source-code">
<strong class="bold">3</strong></pre></li>
				<li><strong class="bold">Modulus</strong> (<strong class="source-inline">%</strong>): In case <a id="_idIndexMarker221"/>you have never worked with modulus<a id="_idIndexMarker222"/> in the past, <strong class="source-inline">%</strong> is a great way to check whether there is a remainder if a number is divided by a divisor. Modulus provides you <a id="_idIndexMarker223"/>with <span class="No-Break">the remainder:</span><pre class="source-code">
<strong class="bold">&gt; 7%2</strong></pre><pre class="source-code">
<strong class="bold">1</strong></pre><pre class="source-code">
<strong class="bold">&gt; 8%2</strong></pre><pre class="source-code">
<strong class="bold">0</strong></pre><pre class="source-code">
<strong class="bold">&gt; 7%4</strong></pre><pre class="source-code">
<strong class="bold">3</strong></pre></li>
			</ul>
			<p>Of course, you can also combine different arithmetic operators as you are <span class="No-Break">used to:</span></p>
			<pre class="source-code">
&gt; $a = 3; $b = 5; $c = 2
&gt; $result = ($a + $b) * $c
&gt; $result
16</pre>
			<p>When combining different arithmetic operators in PowerShell, the operator precedence is respected, as you are used to from regular <span class="No-Break">mathematic operations.</span></p>
			<p class="callout-heading">Semicolons, (Curly) Braces, and Ampersands</p>
			<p class="callout">In this example, we are using the semicolon to execute multiple commands on a single line: in PowerShell, a <strong class="bold">semicolon</strong> (<strong class="source-inline">;</strong>) is <a id="_idIndexMarker224"/>functionally equivalent to a <span class="No-Break">carriage return.</span></p>
			<p class="callout">It is also worth noting<a id="_idIndexMarker225"/> that the use of reserved<a id="_idIndexMarker226"/> characters <a id="_idIndexMarker227"/>such as <strong class="bold">curly braces</strong> <strong class="source-inline">{}</strong>, <strong class="bold">parentheses</strong> <strong class="source-inline">()</strong>, and <strong class="bold">ampersands</strong> <strong class="source-inline">&amp;</strong> can have a significant impact on script execution. Specifically, <strong class="bold">curly braces</strong> denote a code block, while <strong class="bold">parentheses</strong> are used to group expressions or function parameters. The <strong class="bold">ampersand</strong> is used to invoke an executable or command as if it were <span class="No-Break">a cmdlet.</span></p>
			<p class="callout">To avoid issues with script execution, it is essential to be aware of these reserved characters and their specific <span class="No-Break">use cases.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor045"/>Comparison operators</h2>
			<p>Often, it is<a id="_idIndexMarker228"/> necessary to compare values. In this section, you will find an overview of comparison operators <span class="No-Break">in PowerShell:</span></p>
			<ul>
				<li>Equal (<strong class="source-inline">-eq</strong>): Returns <strong class="source-inline">True</strong> if both<a id="_idIndexMarker229"/> values <span class="No-Break">are equal:</span><pre class="source-code">
<strong class="bold">&gt; $a = 1; $b = 1; $a -eq $b</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a = 1; $b = 2; $a -eq $b</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre></li>
			</ul>
			<p>In an <strong class="bold">array context</strong>, operators <a id="_idIndexMarker230"/>behave differently: when an array is used as the left-hand operand in a comparison, PowerShell performs the comparison operation against each element in <span class="No-Break">the array.</span></p>
			<p>When using comparison operators in an array context, the operation will return the elements selected by <span class="No-Break">the operator:</span></p>
			<pre class="source-code">
<strong class="bold">&gt; "A", "B", "C", "D" -lt "C"</strong>
<strong class="bold">A</strong>
<strong class="bold">B</strong></pre>
			<p>When used in an array context, the <strong class="source-inline">-eq</strong> operator behaves differently from its typical comparison behavior. Instead of checking whether the two operands are equal, it returns all elements in the left-hand operand array that are equal to the right-hand operand. If <a id="_idIndexMarker231"/>no matches are found, the operation will still <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">False</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
<strong class="bold">&gt; "A","B","C" -eq "A"</strong>
<strong class="bold">A</strong></pre>
			<ul>
				<li>Not equal (<strong class="source-inline">-ne</strong>): Returns <strong class="source-inline">True</strong> if <a id="_idIndexMarker232"/>both values are <span class="No-Break">not equal:</span><pre class="source-code">
<strong class="bold">&gt; $a = 1; $b = 2; $a -ne $b</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a = 1; $b = 1; $a -ne $b</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre><pre class="source-code">
<strong class="bold">&gt; "Hello World!" -ne $null</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre><pre class="source-code">
<strong class="bold">&gt; "A","B","C" -ne "A"</strong></pre><pre class="source-code">
<strong class="bold">B</strong></pre><pre class="source-code">
<strong class="bold">C</strong></pre></li>
				<li>Less equal (<strong class="source-inline">-le</strong>): Returns <strong class="source-inline">True</strong> if the first<a id="_idIndexMarker233"/> value is less than or <a id="_idIndexMarker234"/>equal to the <span class="No-Break">second value:</span><pre class="source-code">
<strong class="bold">&gt; $a = 1; $b = 2; $a -le $b</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a = 2; $b = 2; $a -le $b</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a = 3; $b = 2; $a -le $b</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre><pre class="source-code">
<strong class="bold">&gt; "A","B","C" -le "A"</strong></pre><pre class="source-code">
<strong class="bold">A</strong></pre></li>
				<li>Greater equal (<strong class="source-inline">-ge</strong>): Returns <strong class="source-inline">True</strong> if the<a id="_idIndexMarker235"/> first value is greater<a id="_idIndexMarker236"/> than or equal to the <span class="No-Break">second value:</span><pre class="source-code">
<strong class="bold">&gt; $a = 1; $b = 2; $a -ge $b</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a = 2; $b = 2; $a -ge $b</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a = 3; $b = 2; $a -ge $b</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre><pre class="source-code">
<strong class="bold">&gt; "A","B","C" -ge "A"</strong></pre><pre class="source-code">
<strong class="bold">A</strong></pre><pre class="source-code">
<strong class="bold">B</strong></pre><pre class="source-code">
<strong class="bold">C</strong></pre></li>
				<li>Less than (<strong class="source-inline">-lt</strong>): Returns <strong class="source-inline">True</strong> if the first <a id="_idIndexMarker237"/>value is less than the <span class="No-Break">second value:</span><pre class="source-code">
<strong class="bold">&gt; $a = 1; $b = 2; $a -lt $b</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a = 2; $b = 2; $a -lt $b</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a = 3; $b = 2; $a -lt $b</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre><pre class="source-code">
<strong class="bold">&gt; "A","B","C" -lt "A" # results in no output</strong></pre></li>
				<li>Greater than (<strong class="source-inline">-gt</strong>): Returns <strong class="source-inline">True</strong> if the first <a id="_idIndexMarker238"/>value is <a id="_idIndexMarker239"/>greater than the <span class="No-Break">second value:</span><pre class="source-code">
<strong class="bold">&gt; $a = 1; $b = 2; $a -gt $b</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a = 2; $b = 2; $a -gt $b</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a = 3; $b = 2; $a -gt $b</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre><pre class="source-code">
<strong class="bold">&gt; "A","B","C" -gt "A"</strong></pre><pre class="source-code">
<strong class="bold">B</strong></pre><pre class="source-code">
<strong class="bold">C</strong></pre></li>
				<li><strong class="source-inline">-like</strong>: Can be <a id="_idIndexMarker240"/>used to check whether a value matches a wildcard expression when used with a scalar. If used in an array context, the <strong class="source-inline">-like</strong> operator returns only the elements that match the specified <span class="No-Break">wildcard expression:</span><pre class="source-code">
<strong class="bold">&gt; "PowerShell" -like "*owers*"</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre><pre class="source-code">
<strong class="bold">&gt; "PowerShell", "Dog", "Cat", "Guinea Pig" -like "*owers*"</strong></pre><pre class="source-code">
<strong class="bold">PowerShell</strong></pre></li>
			</ul>
			<p>It is important to note that the array version of the operator does not return a Boolean value indicating whether any elements in the array match the expression, as the scalar <span class="No-Break">version does.</span></p>
			<ul>
				<li><strong class="source-inline">-notlike</strong>: Can be used to <a id="_idIndexMarker241"/>check whether a value does not <a id="_idIndexMarker242"/>match a wildcard expression when used with a scalar. If used in an array context, the <strong class="source-inline">-notlike</strong> operator returns only the elements that do not match the specified <span class="No-Break">wildcard </span><span class="No-Break"><a id="_idIndexMarker243"/></span><span class="No-Break">expression:</span><pre class="source-code">
<strong class="bold">&gt; "PowerShell" -notlike "*owers*"</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre><pre class="source-code">
<strong class="bold">&gt; "PowerShell", "Dog", "Cat", "Guinea Pig" -notlike "*owers*"</strong></pre><pre class="source-code">
<strong class="bold">Dog</strong></pre><pre class="source-code">
<strong class="bold">Cat</strong></pre><pre class="source-code">
<strong class="bold">Guinea Pig</strong></pre></li>
				<li><strong class="source-inline">-match</strong>: Can<a id="_idIndexMarker244"/> be used to check whether a value matches a <span class="No-Break">regular expression:</span><pre class="source-code">
<strong class="bold">&gt; "PowerShell scripting and automation for Cybersecurity" -match "shell\s*(\d)"</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre><pre class="source-code">
<strong class="bold">&gt; "Cybersecurity scripting in PowerShell 7.3" -match "shell\s*(\d)"</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre></li>
				<li><strong class="source-inline">-notmatch</strong>: Can be used to<a id="_idIndexMarker245"/> check whether a value<a id="_idIndexMarker246"/> does not match a <span class="No-Break">regular expression:</span><pre class="source-code">
<strong class="bold">&gt; "Cybersecurity scripting in PowerShell 7.3" -notmatch "^Cyb"</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre><pre class="source-code">
<strong class="bold">&gt; "PowerShell scripting and automation for Cybersecurity" -notmatch "^Cyb"</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre></li>
			</ul>
			<p>Also refer to the official<a id="_idIndexMarker247"/> PowerShell documentation to read more about comparison <span class="No-Break">operators: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor046"/>Assignment operators</h2>
			<p>When<a id="_idIndexMarker248"/> working with variables, it is vital to<a id="_idIndexMarker249"/> understand <span class="No-Break">assignment operators:</span></p>
			<ul>
				<li><strong class="source-inline">=</strong>: Assigns<a id="_idIndexMarker250"/> <span class="No-Break">a value:</span><pre class="source-code">
<strong class="bold">&gt; $a = 1; $a</strong></pre><pre class="source-code">
<strong class="bold">1</strong></pre></li>
				<li><strong class="source-inline">+=</strong>: Increases<a id="_idIndexMarker251"/> the value by the amount defined after the operator and stores the result in the <span class="No-Break">initial variable:</span><pre class="source-code">
<strong class="bold">&gt; $a = 1; $a += 2; $a</strong></pre><pre class="source-code">
<strong class="bold">3</strong></pre></li>
				<li><strong class="source-inline">-=</strong>: Decreases the <a id="_idIndexMarker252"/>value by the amount defined after the operator and stores the result in the <span class="No-Break">initial variable:</span><pre class="source-code">
<strong class="bold">&gt; $a</strong></pre><pre class="source-code">
<strong class="bold">3</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a -= 1; $a</strong></pre><pre class="source-code">
<strong class="bold">2</strong></pre></li>
				<li><strong class="source-inline">*=</strong>: Multiplies the <a id="_idIndexMarker253"/>value by the amount defined after the operator and stores the result in the <span class="No-Break">initial variable:</span><pre class="source-code">
<strong class="bold">&gt; $a</strong></pre><pre class="source-code">
<strong class="bold">2</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a *= 3; $a</strong></pre><pre class="source-code">
<strong class="bold">6</strong></pre></li>
				<li><strong class="source-inline">/=</strong>: Divides the value by the <a id="_idIndexMarker254"/>amount defined after the operator and stores the result in the <span class="No-Break">initial variable:</span><pre class="source-code">
<strong class="bold">&gt; $a</strong></pre><pre class="source-code">
<strong class="bold">6</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a /= 2; $a</strong></pre><pre class="source-code">
<strong class="bold">3</strong></pre></li>
				<li><strong class="source-inline">%=</strong>: Performs a modulo <a id="_idIndexMarker255"/>operation on the variable using the <a id="_idIndexMarker256"/>amount after the operator and stores the result in the <span class="No-Break">initial variable:</span><pre class="source-code">
<strong class="bold">&gt; $a</strong></pre><pre class="source-code">
<strong class="bold">3</strong></pre><pre class="source-code">
<strong class="bold">&gt; $a %= 2; $a</strong></pre><pre class="source-code">
<strong class="bold">1</strong></pre></li>
				<li><strong class="source-inline">++</strong>: Increases<a id="_idIndexMarker257"/> the variable <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">&gt; $a= 1; $a++; $a</strong></pre><pre class="source-code">
<strong class="bold">2</strong></pre></li>
				<li><strong class="source-inline">--</strong>: Decreases the <a id="_idIndexMarker258"/>variable <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">&gt; $a = 10; $a--; $a</strong></pre><pre class="source-code">
<strong class="bold">9</strong></pre></li>
			</ul>
			<p>Please refer to the official documentation to see more examples of how to use assignment <a id="_idIndexMarker259"/><span class="No-Break">operators: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_assignment_operators"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_assignment_operators</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor047"/>Logical operators</h2>
			<p>If you work with multiple <a id="_idIndexMarker260"/>statements, you will need logical operators to add, compare, or exclude. In this section, you will find an overview of common logical operators <span class="No-Break">in </span><span class="No-Break"><a id="_idIndexMarker261"/></span><span class="No-Break">PowerShell:</span></p>
			<ul>
				<li><strong class="source-inline">-and</strong>: Can be <a id="_idIndexMarker262"/>used to combine conditions. The defined action is triggered only if both conditions <span class="No-Break">are met:</span><pre class="source-code">
<strong class="bold">&gt; $a = 1; $b = 2</strong></pre><pre class="source-code">
<strong class="bold">&gt; if (($a -eq 1) -and ($b -eq 2)) {Write-Host "Condition is true!"}</strong></pre><pre class="source-code">
<strong class="bold">Condition is true!</strong></pre></li>
				<li><strong class="source-inline">-or</strong>: If one of the <a id="_idIndexMarker263"/>defined conditions is met, the action <span class="No-Break">is triggered:</span><pre class="source-code">
<strong class="bold">&gt; $a = 2; $b = 2</strong></pre><pre class="source-code">
<strong class="bold">&gt; if (($a -eq 1) -or ($b -eq 2)) {Write-Host "Condition is true!"}</strong></pre><pre class="source-code">
<strong class="bold">Condition is true!</strong></pre></li>
				<li><strong class="source-inline">-not</strong> or <strong class="source-inline">!</strong>: Can<a id="_idIndexMarker264"/> be used to negate a condition. The following example tests whether the folder specified using the <strong class="source-inline">$path</strong> variable is available. If it is missing, it will <span class="No-Break">be created:</span><pre class="source-code">
<strong class="bold">$path = $env:TEMP + "\TestDirectory"</strong></pre><pre class="source-code">
<strong class="bold">if( -not (Test-Path -Path $path )) {</strong></pre><pre class="source-code">
<strong class="bold">    New-Item -ItemType directory -Path $path</strong></pre><pre class="source-code">
<strong class="bold">}</strong></pre><pre class="source-code">
<strong class="bold">if (!(Test-Path -Path $path)) {</strong></pre><pre class="source-code">
<strong class="bold">    New-Item -ItemType directory -Path $path</strong></pre><pre class="source-code">
<strong class="bold">}</strong></pre></li>
				<li><strong class="source-inline">-xor</strong>: Logical<a id="_idIndexMarker265"/> exclusive <strong class="source-inline">-or</strong>. Is <strong class="source-inline">True</strong> if <em class="italic">only one</em> statement <a id="_idIndexMarker266"/>is <strong class="source-inline">True</strong> (but returns <strong class="source-inline">False</strong> if both <span class="No-Break">are </span><span class="No-Break"><strong class="source-inline">True</strong></span><span class="No-Break">):</span><pre class="source-code">
<strong class="bold">&gt; $a = 1; $b = 2; ($a -eq 1) -xor ($b -eq 1)</strong></pre><pre class="source-code">
<strong class="bold">True</strong></pre><pre class="source-code">
<strong class="bold">&gt; ($a -eq 1) -xor ($b -eq 2)</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre><pre class="source-code">
<strong class="bold">&gt; ($a -eq 2) -xor ($b -eq 1)</strong></pre><pre class="source-code">
<strong class="bold">False</strong></pre></li>
			</ul>
			<p>Now that you have learned how to work with operators in PowerShell, let’s have a look at control structures in our <span class="No-Break">next section.</span></p>
			<p>Please also refer to the <strong class="source-inline">about_operators</strong> documentation<a id="_idIndexMarker267"/> to learn more about PowerShell operators in <span class="No-Break">general: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_operators"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_operators</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor048"/>Control structures</h1>
			<p>A control structure<a id="_idIndexMarker268"/> is some kind of programmatic logic that assesses conditions and variables and decides which defined action will be taken if a certain condition <span class="No-Break">is met.</span></p>
			<p>Use the operators that we learned about in the last section to define the conditions, which will be assessed using the control structures introduced in <span class="No-Break">this section.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor049"/>Conditions</h2>
			<p>If you want to select <a id="_idIndexMarker269"/>which action <a id="_idIndexMarker270"/>is performed if a certain condition is met, you can use one of the following selection control structures: either an <strong class="source-inline">if/elseif/else</strong> construct or the <span class="No-Break"><strong class="source-inline">switch</strong></span><span class="No-Break"> statement.</span></p>
			<h3>If/elseif/else</h3>
			<p><strong class="source-inline">if</strong>, <strong class="source-inline">elseif</strong>, and <strong class="source-inline">else</strong> can be <a id="_idIndexMarker271"/>used to check whether a certain condition is <strong class="source-inline">True</strong> and <a id="_idIndexMarker272"/>run an action if the condition <span class="No-Break">is fulfilled:</span></p>
			<pre class="source-code">
if (&lt;condition&gt;)
{
    &lt;action&gt;
}
elseif (&lt;condition 2&gt;)
{
    &lt;action 2&gt;
}
...
else
{
    &lt;action 3&gt;
}</pre>
			<p>You can use the <strong class="source-inline">if</strong> statement to check whether a condition <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">True</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; if (1+2 -eq 3) { Write-Host "Good job!" }
 Good job!
&gt; if (1+2 -eq 5) { Write-Host "Something is terribly wrong!" }
# returns no Output</pre>
			<p>You can also check whether one of several conditions is <strong class="source-inline">True</strong> by using <strong class="source-inline">elseif</strong>. The action of the first condition that is met will <span class="No-Break">be executed:</span></p>
			<pre class="source-code">
$color = "green"
if ($color -eq "blue") {
     Write-Host "The color is blue!"
}
elseif ($color -eq "green"){
     Write-Host "The color is green!"
}
# returns: The color is green!</pre>
			<p>In this example, the control structure checks whether one of the specified conditions is met (either <strong class="source-inline">$color -eq "blue"</strong> or <strong class="source-inline">$color -eq "green"</strong>). If <strong class="source-inline">$color</strong> would be <strong class="source-inline">red</strong>, no action would <span class="No-Break">be performed.</span></p>
			<p>But since <strong class="source-inline">$color</strong> is <strong class="source-inline">green</strong>, the <strong class="source-inline">elseif</strong> condition is <strong class="source-inline">True</strong> and the <strong class="source-inline">The color is green!</strong> string will be written to <span class="No-Break">the console.</span></p>
			<p>If you want to <a id="_idIndexMarker273"/>specify an action that will be triggered if none of the specified conditions are met, you can use <strong class="source-inline">else</strong>. If no condition from <strong class="source-inline">if</strong> or <strong class="source-inline">elseif</strong> is met, the action specified in the <strong class="source-inline">else</strong> block will <span class="No-Break">be </span><span class="No-Break"><a id="_idIndexMarker274"/></span><span class="No-Break">executed:</span></p>
			<pre class="source-code">
$color = "red"
if ($color -eq "blue") {
     Write-Host "The color is blue!"
}
elseif ($color -eq "green"){
     Write-Host "The color is green!"
}
else {
     Write-Host "That is also a very beautiful color!"
}
# returns: That is also a very beautiful color!</pre>
			<p>In this example, we <a id="_idIndexMarker275"/>check whether <strong class="source-inline">$color</strong> is either <strong class="source-inline">blue</strong> or <strong class="source-inline">green</strong>. But since <strong class="source-inline">$color</strong> is <strong class="source-inline">"red"</strong>, none of the defined conditions are <strong class="source-inline">True</strong>, and therefore the code <a id="_idIndexMarker276"/>defined in the <strong class="source-inline">else</strong> block will be executed, which writes <strong class="source-inline">That is also a very beautiful color!</strong> to <span class="No-Break">the output.</span></p>
			<h3>Switch</h3>
			<p>Sometimes, it can<a id="_idIndexMarker277"/> happen that <a id="_idIndexMarker278"/>you want to check one variable against a long list <span class="No-Break">of values.</span></p>
			<p>To solve this problem, you could – of course – create a long and complicated list of <strong class="source-inline">if</strong>, <strong class="source-inline">elseif</strong>, …, <strong class="source-inline">elseif</strong>, and <span class="No-Break"><strong class="source-inline">else</strong></span><span class="No-Break"> statements.</span></p>
			<p>But instead, you can use the more elegant <strong class="source-inline">switch</strong> statement to test a value against a list of predefined values and <span class="No-Break">react accordingly:</span></p>
			<pre class="source-code">
switch (&lt;value to test&gt;) {
     &lt;condition 1&gt; {&lt;action 1&gt;}
     &lt;condition 2&gt; {&lt;action 2&gt;}
     &lt;condition 3&gt; {&lt;action 3&gt;}
     ...
     defaul<a id="_idTextAnchor050"/>t {}
}</pre>
			<p>Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
$color = Read-Host "What is your favorite color?"
switch ($color) {
     "blue"   { Write-Host "I'm BLUE, Da ba dee da ba di..." }
     "yellow" { Write-Host "YELLOW is the color of my true love's hair." }
     "red"    { Write-Host "Roxanne, you don't have to put on the RED light..." }
     "purple" { Write-Host "PURPLE rain, purple rain!" }
     "black" { Write-Host "Lady in BLACK... she came to me one morning, one lonely Sunday morning..." }
     default  { Write-Host "The color is not in this list." }
}</pre>
			<p>In this example, the user is prompted to enter a value: <strong class="source-inline">What is your </strong><span class="No-Break"><strong class="source-inline">favorite color?</strong></span><span class="No-Break">.</span></p>
			<p>Depending on what the user enters, a different output will be shown: if <strong class="source-inline">purple</strong> is entered, a line from a famous Prince song, <em class="italic">Purple Rain</em>, will be displayed. If <strong class="source-inline">red</strong> is entered, a line of the Police song <em class="italic">Roxanne</em> <span class="No-Break">is cited.</span></p>
			<p>But if <strong class="source-inline">green</strong> is entered, the <strong class="source-inline">default</strong> output will be shown, as there’s no option for the <strong class="source-inline">green</strong> value defined and the message <strong class="source-inline">The color is not in this list</strong> will <span class="No-Break">be displayed.</span></p>
			<p>In addition to using <a id="_idIndexMarker279"/>the <strong class="source-inline">switch</strong> statement to evaluate simple conditions based on the value of a <a id="_idIndexMarker280"/>variable or expression, PowerShell also supports <strong class="bold">more advanced modes</strong>. These modes allow you to use regular expressions, process the contents of files, <span class="No-Break">and more.</span></p>
			<p>For example, you can use the <strong class="source-inline">-Regex</strong> parameter to use a regular expression to match against the input, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
switch -Regex ($userInput) {
    "^[A-Z]" { "User input starts with a letter." }
    "^[0-9]" { "User input starts with a number." }
    default { "User input doesn't start with a letter or number." }
}</pre>
			<p>If <strong class="source-inline">$userInput</strong> was defined as <strong class="source-inline">"Hello World!"</strong>, then <strong class="source-inline">"User input starts with a letter."</strong> would be written to the output. If <strong class="source-inline">$userInput</strong> started with a number (for example, <strong class="source-inline">"1337"</strong>), the output would be <strong class="source-inline">"User input starts with a number."</strong>. And if <strong class="source-inline">$userInput</strong> started with a different character, (for example, <strong class="source-inline">"!"</strong>), then the <strong class="source-inline">default</strong> condition would be met and <strong class="source-inline">"User input doesn't start with a letter or number."</strong> would be written to <span class="No-Break">the output.</span></p>
			<p>You can also use the <strong class="source-inline">-File</strong> parameter to process the contents of a file with the <strong class="source-inline">switch</strong> statement. The <strong class="source-inline">-Wildcard</strong> parameter enables you to use the wildcard logic <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">switch</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$path = $env:TEMP + "\example.txt"
switch -Wildcard -File $path {
    "*Error*" { Write-Host "Error was found!: $_" }
}</pre>
			<p>In this example, we’re using the <strong class="source-inline">switch</strong> statement to process the contents of a file named <strong class="source-inline">"example.txt"</strong>. We’re looking for the <strong class="source-inline">"*Error*"</strong> pattern within the file, and then taking an action based on whether that pattern was found. If the specified file contains the pattern, <strong class="source-inline">"Error was found!:"</strong> will be written to the output, followed by the line that <a id="_idIndexMarker281"/>contained the error. It’s important to note that the wildcard pattern is processed line by line<a id="_idIndexMarker282"/> and not for the entire file, so there will be an <strong class="source-inline">"Error was found!: "</strong> line written to the output for every line in the file that contained the <strong class="source-inline">"*</strong><span class="No-Break"><strong class="source-inline">Error*"</strong></span><span class="No-Break"> pattern.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor051"/>Loops and iterations</h2>
			<p>If you want to run an <a id="_idIndexMarker283"/>action over and over again until a certain condition is met, you can do that using loops. A <a id="_idIndexMarker284"/>loop will continue to execute as long as the specified condition is <strong class="source-inline">True</strong> unless it is terminated with a loop-breaking statement such as <strong class="source-inline">break</strong>. Depending on the loop construct used, the loop may execute at least once, or may not execute at all if the condition is <span class="No-Break">initially </span><span class="No-Break"><strong class="source-inline">False</strong></span><span class="No-Break">.</span></p>
			<p>In this section, you will find an overview of how to work <span class="No-Break">with loops.</span></p>
			<h3>ForEach-Object</h3>
			<p><strong class="source-inline">ForEach-Object</strong> accepts a<a id="_idIndexMarker285"/> list or an array of items and allows you to <a id="_idIndexMarker286"/>perform an action against each of them. <strong class="source-inline">ForEach-Object</strong> is best used when you use the pipeline to pipe objects <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">ForEach-Object</strong></span><span class="No-Break">.</span></p>
			<p>As an <a id="_idIndexMarker287"/>example, if you want to process all files that are in a folder, you can<a id="_idIndexMarker288"/> use <strong class="source-inline">Foreach-Object</strong>. <strong class="source-inline">$_</strong> contains the value of every single item of <span class="No-Break">each iteration:</span></p>
			<pre class="source-code">
&gt; $path = $env:TEMP + "\baselines"
&gt; Get-ChildItem -Path $path | ForEach-Object {Write-Host $_}
Office365-ProPlus-Sept2019-FINAL.zip
Windows 10 Version 1507 Security Baseline.zip
Windows 10 Version 1607 and Windows Server 2016 Security Baseline.zip
Windows 10 Version 1803 Security Baseline.zip
Windows 10 Version 1809 and Windows Server 2019 Security Baseline.zip
Windows 10 Version 1903 and Windows Server Version 1903 Security Baseline - Sept2019Update.zip
Windows 10 Version 1909 and Windows Server Version 1909 Security Baseline.zip
Windows 10 Version 2004 and Windows Server Version 2004 Security Baseline.zip
Windows Server 2012 R2 Security Baseline.zip</pre>
			<p>If you want to<a id="_idIndexMarker289"/> perform specific actions before processing each item in the pipeline or after processing all the items, you can use the <strong class="source-inline">-Begin</strong> and <strong class="source-inline">-End</strong> advanced parameters with the <strong class="source-inline">ForEach-Object</strong> <span class="No-Break">cmdlet: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/foreach-object"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/foreach-object</span></a><span class="No-Break">.</span></p>
			<p>Additionally, you can use the <strong class="source-inline">-Process</strong> parameter to specify the script block that is run for each item in <span class="No-Break">the pipeline.</span></p>
			<h3>Foreach</h3>
			<p>To iterate<a id="_idIndexMarker290"/> through a<a id="_idIndexMarker291"/> collection of items in PowerShell, you can use the <strong class="source-inline">Foreach-Object</strong> <em class="italic">cmdlet</em>, the <strong class="source-inline">foreach</strong> <em class="italic">statement</em>, or the <strong class="source-inline">foreach</strong> <em class="italic">method</em>. The <strong class="source-inline">Foreach-Object</strong> <em class="italic">cmdlet</em> accepts pipeline objects, making it a useful tool for working with object-oriented data. The <strong class="source-inline">foreach</strong> <em class="italic">method</em> and the <strong class="source-inline">foreach</strong> <em class="italic">statement</em> are very similar to <strong class="source-inline">Foreach-Object</strong> but they do not accept pipeline objects. You will get error messages if you try to use it in the same way <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">Foreach-Object</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">foreach</strong> <em class="italic">statement</em> loads all items into a collection before they are processed, making it quicker but consuming more memory <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">ForEach-Object</strong></span><span class="No-Break">.</span></p>
			<p>The following example shows how to use the <span class="No-Break"><strong class="source-inline">foreach</strong></span><span class="No-Break"> </span><span class="No-Break"><em class="italic">statement</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$path = $env:TEMP + "\baselines"
$items = Get-ChildItem -Path $path
foreach ($file in $items) {
     Write-Host $file
}</pre>
			<p>In this example, the <strong class="source-inline">$path</strong> path is examined similarly as in our example before. But in this case, it uses a <strong class="source-inline">foreach</strong> <em class="italic">statement</em> to iterate through each item in the <strong class="source-inline">$items</strong> array, assigning the current item to the <strong class="source-inline">$file</strong> variable on each iteration. The <strong class="source-inline">$file</strong> variable is defined by the author of the script – every other variable name can be added here and, of course, processed. For each item, it outputs the value of <strong class="source-inline">$file</strong> to the console using the <span class="No-Break"><strong class="source-inline">Write-Host</strong></span><span class="No-Break"> cmdlet.</span></p>
			<p>You can use the <strong class="source-inline">.foreach({})</strong> <em class="italic">method</em> to iterate through a collection of items. Here’s an example of how to <span class="No-Break">use it:</span></p>
			<pre class="source-code">
$path = $env:TEMP + "\baselines"
$items = Get-ChildItem -Path $path
$items.foreach({
    Write-Host "Current item: $_"
})</pre>
			<p>In this example, <strong class="source-inline">$path</strong> is examined; for each file in that folder, the filename will be written to the command line. The <strong class="source-inline">.foreach</strong>(<strong class="source-inline">{}</strong>) <em class="italic">method</em> is used to iterate through each item in the <strong class="source-inline">$items</strong> collection and write a message to the console that includes the item’s <a id="_idIndexMarker292"/>name. The <strong class="source-inline">$_</strong> variable is used to reference the current item being<a id="_idIndexMarker293"/> iterated over. So, for each item in the <strong class="source-inline">$items</strong> collection, the script will output a message such as <strong class="source-inline">"Current </strong><span class="No-Break"><strong class="source-inline">item: filename"</strong></span><span class="No-Break">.</span></p>
			<h3>while</h3>
			<p><strong class="source-inline">while</strong> does<a id="_idIndexMarker294"/> something (<strong class="source-inline">&lt;actions&gt;</strong>) as long as the defined <em class="italic">condition</em> <span class="No-Break">is </span><span class="No-Break"><a id="_idIndexMarker295"/></span><span class="No-Break">fulfilled:</span></p>
			<pre class="source-code">
while ( &lt;<strong class="bold">condition</strong>&gt; ){ &lt;<strong class="bold">actions</strong>&gt; }</pre>
			<p>In this example, user input is read, and as long as the user doesn’t type in <strong class="source-inline">quit</strong>, the <strong class="source-inline">while</strong> loop <span class="No-Break">still runs:</span></p>
			<pre class="source-code">
while(($input = Read-Host -Prompt "Choose a command (type in 'help' for an overview)") -ne "quit"){
    switch ($input) {
        "hello" {Write-Host "Hello World!"}
        "color" {Write-Host "What's your favorite color?"}
        "help" {Write-Host "Options: 'hello', 'color', 'help' 'quit'"}
    }
}</pre>
			<p>In this example, if the user types in either <strong class="source-inline">hello</strong>, <strong class="source-inline">color</strong>, or <strong class="source-inline">help</strong>, different output options will be shown, but the program still continues, as the condition for the <strong class="source-inline">while</strong> statement is <span class="No-Break">not fulfilled.</span></p>
			<p>Once the user types in <strong class="source-inline">quit</strong>, the program will be terminated, as the condition <span class="No-Break">is fulfilled.</span></p>
			<h3>for</h3>
			<p>This defines the <a id="_idIndexMarker296"/>initializing statement, a condition, and loops through until the defined<a id="_idIndexMarker297"/> condition is not <span class="No-Break">fulfilled anymore:</span></p>
			<pre class="source-code">
for (&lt;initializing statement&gt;; &lt;condition&gt;; &lt;repeat&gt;)
{
    &lt;actions&gt;
}</pre>
			<p>If you<a id="_idIndexMarker298"/> need <a id="_idIndexMarker299"/>iterating values, <strong class="source-inline">for</strong> is a <span class="No-Break">great solution:</span></p>
			<pre class="source-code">
&gt; for ($i=1; $i -le 5; $i++) {Write-Host "i: $i"}
i: 1
i: 2
i: 3
i: 4
i: 5</pre>
			<p>In this example, <strong class="source-inline">$i=1</strong> is the starting condition, and in every iteration, <strong class="source-inline">$i</strong> is increased by <strong class="source-inline">1</strong>, using the <strong class="source-inline">$i++</strong> statement. As long as <strong class="source-inline">$i</strong> is smaller than or equal to <strong class="source-inline">5</strong> – that is, <strong class="source-inline">($i -le 5)</strong> – the loop continues and writes <strong class="source-inline">$i</strong> to <span class="No-Break">the output.</span></p>
			<h3>do-until/do-while</h3>
			<p>Compared to <a id="_idIndexMarker300"/>other loops, <strong class="source-inline">do-until</strong> or <strong class="source-inline">do-while</strong> already starts running the defined <a id="_idIndexMarker301"/>commands and then checks whether the <a id="_idIndexMarker302"/>condition is still met or <span class="No-Break">not met:</span></p>
			<pre class="source-code">
do{
     &lt;action&gt;
}
&lt;while/until&gt;&lt;condition&gt;</pre>
			<p>Although <strong class="source-inline">do-until</strong> and <strong class="source-inline">do-while</strong> have the same syntax, they differ in how the condition <span class="No-Break">is treated.</span></p>
			<p><strong class="source-inline">do-while</strong> runs as long as the condition is <strong class="source-inline">True</strong> and stops as soon as the condition is not met anymore. <strong class="source-inline">do-until</strong> runs only <a id="_idIndexMarker303"/>as long as the condition is <em class="italic">not</em> met: it<a id="_idIndexMarker304"/> ends when the <a id="_idIndexMarker305"/>condition <span class="No-Break">is met.</span></p>
			<h3>break</h3>
			<p><strong class="source-inline">break</strong> can <a id="_idIndexMarker306"/>be used to exit<a id="_idIndexMarker307"/> the loop (for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">for</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">foreach</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="source-inline">foreach-object</strong></span><span class="No-Break">/…):</span></p>
			<pre class="source-code">
&gt; for ($i=1; $i -le 10; $i++) {
    Write-Host "i: $i"
    if ($i -eq 3) {break}
}
i: 1
i: 2
i: 3</pre>
			<p>Consult the<a id="_idIndexMarker308"/> official documentation to learn more about the advanced usage of <span class="No-Break"><strong class="source-inline">break</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break</span></a><span class="No-Break">.</span></p>
			<h3>continue</h3>
			<p>The <strong class="source-inline">continue</strong> statement<a id="_idIndexMarker309"/> is used to skip the current iteration of a loop and move<a id="_idIndexMarker310"/> to the next one. It does not affect the loop’s condition, which will be re-evaluated at the beginning of the <span class="No-Break">next iteration:</span></p>
			<pre class="source-code">
&gt; for ($i=1; $i -le 10; $i++) {
    if (($i % 2) -ne 0) {continue}
    Write-Host "i: $i"
}
i: 2
i: 4
i: 6
i: 8
i: 10</pre>
			<p>In this example, we use the modulus (<strong class="source-inline">%</strong>) operator to calculate whether a division by <strong class="source-inline">2</strong> returns a remainder. If the remainder of <strong class="source-inline">$i % 2</strong> is non-zero, then the condition returns <strong class="source-inline">True</strong>, and <strong class="source-inline">continue</strong> <span class="No-Break">is triggered.</span></p>
			<p>This behavior causes <strong class="source-inline">$i</strong> to be only written to the console if no remainder <span class="No-Break">is returned.</span></p>
			<p class="callout-heading">Did You Know?</p>
			<p class="callout">The preceding example demonstrates that <em class="italic">every time</em> the remainder returned is <em class="italic">not 0</em>, the <em class="italic">current iteration is skipped</em>. This code could also be simplified by writing <span class="No-Break">the following:</span></p>
			<p class="callout"><strong class="bold">for ($i=1; $i -le 10; $</strong><span class="No-Break"><strong class="bold">i++) {</strong></span></p>
			<p class="callout"><strong class="bold">    if ($i % 2){ </strong><span class="No-Break"><strong class="bold">continue }</strong></span></p>
			<p class="callout"><strong class="bold">    Write-Host “</strong><span class="No-Break"><strong class="bold">i: $i”</strong></span></p>
			<p class="callout"><strong class="bold">}</strong></p>
			<p>You can use control structures not only to solve a single instance but also to solve problems by combining multiple control structures to build <span class="No-Break">complex logic.</span></p>
			<p>After reading this section, you should have a basic knowledge of what control structures exist and how to <span class="No-Break">use them.</span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor052"/>Naming conventions</h1>
			<p>Cmdlets and functions both follow <a id="_idIndexMarker311"/>the schema <em class="italic">verb-noun</em>, such as <strong class="source-inline">Get-Help</strong> or <strong class="source-inline">Stop-Process</strong>. So, if you write your own functions or cmdlets, make sure to follow the name guidelines <span class="No-Break">and recommendations.</span></p>
			<p>Microsoft has released a list of approved verbs. Although it is not technically enforced to use approved verbs, it is strongly recommended to do so in order to comply with PowerShell best practices and avoid conflicts with automatic variables and reserved words. Additionally, using approved verbs<a id="_idIndexMarker312"/> is required when publishing PowerShell modules to the PowerShell Gallery, as it will trigger a warning message if non-approved verbs are used. Here is the<a id="_idIndexMarker313"/> link for the <span class="No-Break">approved verbs:</span></p>
			<p><a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands</span></a></p>
			<p>Finding the <span class="No-Break">approved verbs</span></p>
			<p>If you are in the <a id="_idIndexMarker314"/>process of writing your code and quickly want to check <a id="_idIndexMarker315"/>which approved verbs exist, you can leverage the <span class="No-Break"><strong class="source-inline">Get-Verb</strong></span><span class="No-Break"> command.</span></p>
			<p>If you want to sort the list of available verbs, you can pipe the output to <strong class="source-inline">Sort-Object</strong>. By default, the verbs are sorted into traditional categories of use, such as <strong class="source-inline">Common</strong>, <strong class="source-inline">Data</strong>, and <strong class="source-inline">Lifecycle</strong>. However, you can also sort them alphabetically by name by specifying the <strong class="source-inline">Name</strong> property with the <strong class="source-inline">Sort-Object</strong> command. Use the following command to sort the output of <strong class="source-inline">Get-Verb</strong> by the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">Verb</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Get-Verb | Sort-Object Verb</pre>
			<p>You can also use wildcards to prefilter <span class="No-Break">the list:</span></p>
			<pre class="source-code">
&gt; Get-Verb re*
Verb     Group
----     -----
Redo     Common
Remove   Common
Rename   Common
Reset    Common
Resize   Common
Restore  Data
Register Lifecycle
Request  Lifecycle
Restart  Lifecycle
Resume   Lifecycle
Repair   Diagnostic
Resolve  Diagnostic
Read     Communications
Receive  Communications
Revoke   Security</pre>
			<p>If you just want to<a id="_idIndexMarker316"/> get all approved verbs from a certain group (in this case, <strong class="source-inline">Security</strong>), you <a id="_idIndexMarker317"/>can filter <strong class="source-inline">Group</strong> <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Where-Object</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-Verb | Where-Object Group -eq Security
Verb      Group
----      -----
Block     Security
Grant     Security
Protect   Security
Revoke    Security
Unblock   Security
Unprotect Security</pre>
			<p>Although naming conventions are not enforced in PowerShell, they should be respected nevertheless. Microsoft also strongly encourages following those guidelines when writing your cmdlets to ensure that users have a consistent <span class="No-Break">user experience.</span></p>
			<p>Please also have a look at the development guidelines when writing your own<a id="_idIndexMarker318"/> functions and <span class="No-Break">cmdlets: </span><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/strongly-encouraged-development-guidelines</span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor053"/>PowerShell profiles</h1>
			<p>PowerShell profiles<a id="_idIndexMarker319"/> are configuration files that allow you to personalize your PowerShell environment. These profiles can be used to customize the behavior and environment of PowerShell sessions. They are scripts that are executed when a PowerShell session is started, allowing users to set variables, define functions, create aliases, <span class="No-Break">and more.</span></p>
			<p>Any variables, functions, or aliases defined in the appropriate PowerShell profile will be loaded every time a PowerShell session is started. This means you can have a consistent and personalized PowerShell environment across all <span class="No-Break">your sessions.</span></p>
			<p>There are several different types of profiles and more than one can be processed by PowerShell. PowerShell profiles are stored as plain text files on your system, and there are several types of <span class="No-Break">profiles available:</span></p>
			<ul>
				<li><strong class="bold">All Users, All Hosts</strong> (<strong class="source-inline">$profile.AllUsersAllHosts</strong>): This profile applies to all users for all <a id="_idIndexMarker320"/><span class="No-Break">PowerShell hosts.</span></li>
				<li><strong class="bold">All Users, Current Host</strong> (<strong class="source-inline">$profile.AllUsersCurrentHost</strong>): This profile applies to all <a id="_idIndexMarker321"/>users for the current <span class="No-Break">PowerShell host.</span></li>
				<li><strong class="bold"><a id="_idTextAnchor054"/>Current User, All Hosts</strong> (<strong class="source-inline">$profile.CurrentUserAllHosts</strong>): This profile applies to the<a id="_idIndexMarker322"/> current user for all <span class="No-Break">PowerShell hosts.</span></li>
				<li><strong class="bold">Current User, Current Host</strong> (<strong class="source-inline">$profile.CurrentUserCurrentHost</strong>): This profile applies only to the <a id="_idIndexMarker323"/>current user and the current <span class="No-Break">PowerShell host.</span></li>
			</ul>
			<p>A <strong class="bold">PowerShell host</strong> is an <a id="_idIndexMarker324"/>application that hosts the PowerShell engine. Examples of PowerShell hosts include the Windows PowerShell console, the <a id="_idIndexMarker325"/>PowerShell <strong class="bold">Integrated Scripting Environment</strong> (<strong class="bold">ISE</strong>), and the PowerShell terminal in Visual <span class="No-Break">Studio Code.</span></p>
			<p>The location of your <a id="_idIndexMarker326"/>PowerShell profile(s) depends on your system and configuration, but you can easily find out where they are stored by running the following command <span class="No-Break">in PowerShell:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer045">
					<img alt="Figure 2.4 – Finding out the location of the local PowerShell profile(s)" src="image/B16679_02_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Finding out the location of the local PowerShell profile(s)</p>
			<p>It is important to note that there are also <a id="_idIndexMarker327"/>more profile paths available, including those used by the system and not just by individual users (which would be included in the <span class="No-Break"><strong class="source-inline">AllUsers</strong></span><span class="No-Break"> profile):</span></p>
			<ul>
				<li>Applies to local shells and all <span class="No-Break">users: </span><span class="No-Break"><strong class="source-inline">%windir%\system32\WindowsPowerShell\v1.0\profile.ps1</strong></span></li>
				<li>Applies to all shells and all <span class="No-Break">users: </span><span class="No-Break"><strong class="source-inline">%windir%\system32\WindowsPowerShell\v1.0\Microsoft.PowerShell_profile.ps1</strong></span></li>
				<li>Applies to all local ISE shells and all <span class="No-Break">users: </span><span class="No-Break"><strong class="source-inline">%windir%\system32\WindowsPowerShell\v1.0\Microsoft.PowerShellISE_profile.ps1</strong></span></li>
			</ul>
			<p>This profile is loaded when using the PowerShell ISE and can be viewed by running the <strong class="source-inline">$profile | fl * -force</strong> command within <span class="No-Break">the ISE</span></p>
			<ul>
				<li>Applies to current user ISE shells on the local <span class="No-Break">host: </span><span class="No-Break"><strong class="source-inline">%UserProfile%\Documents\WindowsPowerShell\Microsoft.PowerShellISE_profile.ps1</strong></span></li>
			</ul>
			<p>For example, in Windows PowerShell, there are profiles for <strong class="source-inline">AllUsers</strong> and <strong class="source-inline">AllHosts</strong>, which apply to all users and all PowerShell hosts on a system. In PowerShell Core, there are profiles for <strong class="source-inline">AllUsers</strong> and <strong class="source-inline">AllHosts</strong> as well, but they do not load the Windows PowerShell profiles from the <strong class="source-inline">system32</strong> directory by default. It’s also worth noting that while PowerShell Core supports loading Windows PowerShell profiles, the reverse is <span class="No-Break">not true.</span></p>
			<p>To access the file path of one particular profile, such as the one for <strong class="source-inline">CurrentUserCurrentHost</strong>, you can use the variable that is defined <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">$profile.CurrentUserCurrentHost</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; $profile.CurrentUserCurrentHost
C:\Users\pssecuser\Documents\PowerShell\Microsoft.PowerShell_profile.ps1</pre>
			<p>Use the following code snippet to check whether the file already exists; if it does not yet, the file <span class="No-Break">is created:</span></p>
			<pre class="source-code">
if ( !( Test-Path $profile.CurrentUserCurrentHost ) ) {
    New-Item -ItemType File -Path $profile.CurrentUserCurrentHost
}</pre>
			<p>Finally, add the <a id="_idIndexMarker328"/>commands, functions, or aliases to the <span class="No-Break">user profile:</span></p>
			<pre class="source-code">
&gt; Add-Content -Path $profile -Value “New-Alias -Name Get-Ip -Value ‘ipconfig.exe’”</pre>
			<p>In addition to customizing your PowerShell environment, profiles are also a crucial aspect of PowerShell security. By modifying your profiles, you can set policies and restrictions to enforce security best practices, such as preventing the execution of unsigned scripts or setting execution policies. But also, adversaries can use PowerShell profiles to their advantage – for example, to <span class="No-Break">establish persistence.</span></p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor055"/>Understanding PSDrives in PowerShell</h1>
			<p>PowerShell includes a <a id="_idIndexMarker329"/>feature called <strong class="bold">PowerShell drives</strong> (<strong class="bold">PSDrives</strong>). PSDrives in PowerShell are similar to filesystem drives in Windows, but instead of accessing files and folders, you use PSDrives to access a variety of data stores. These data stores can include directories, registry keys, and other data sources, which can be accessed through a consistent and <span class="No-Break">familiar interface.</span></p>
			<p>PSDrives are powered by <strong class="bold">PSProviders</strong>, which are the underlying components that provide access to data stores. PSProviders <a id="_idIndexMarker330"/>are similar to drivers in Windows, which allow access to different hardware devices. In the case of PowerShell, PSProviders allow you to access different data stores in a uniform way, using the same set of cmdlets <span class="No-Break">and syntax.</span></p>
			<p>For example, the <strong class="source-inline">Env:\</strong> PSDrive is a built-in PowerShell drive that provides access to environment variables. To retrieve all environment variables that have the <strong class="source-inline">path</strong> string in their name, you can use the <strong class="source-inline">Get-ChildItem</strong> cmdlet with the <span class="No-Break"><strong class="source-inline">Env:\</strong></span><span class="No-Break"> PSDrive:</span></p>
			<pre class="source-code">
&gt; Get-ChildItem Env:\*path*</pre>
			<p>To access a PSDrive, you use a special prefix in the path. For example, to access the filesystem drive, you use the prefix <strong class="source-inline">C:</strong>, and to access the registry drive, you use the prefix <strong class="source-inline">HKLM:</strong>. In the case of the <strong class="source-inline">Env:\</strong> PSDrive, the prefix is <strong class="source-inline">Env:</strong>, which allows you to access environment variables as if they were files <span class="No-Break">or folders.</span></p>
			<p>There are several built-in<a id="_idIndexMarker331"/> PSDrives in PowerShell, including <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">Alias</strong>: Provides access to <span class="No-Break">PowerShell aliases</span></li>
				<li><strong class="source-inline">Environment</strong>: Provides access to <span class="No-Break">environment variables</span></li>
				<li><strong class="source-inline">Function</strong>: Provides access to <span class="No-Break">PowerShell functions</span></li>
				<li><strong class="source-inline">Variable</strong>: Provides access to <span class="No-Break">PowerShell variables</span></li>
				<li><strong class="source-inline">Cert</strong>: Provides access to certificates in the Windows <span class="No-Break">certificate store</span></li>
				<li><strong class="source-inline">Cert:\CurrentUser</strong>: Provides access to certificates in the current user’s <span class="No-Break">certificate store</span></li>
				<li><strong class="source-inline">Cert:\LocalMachine</strong>: Provides access to certificates in the local machine’s <span class="No-Break">certificate store</span></li>
				<li><strong class="source-inline">WSMan</strong>: Provides <a id="_idIndexMarker332"/>access to <strong class="bold">Windows Remote Management</strong> (<strong class="bold">WinRM</strong>) <span class="No-Break">configuration data</span></li>
				<li><strong class="source-inline">C:</strong> and <strong class="source-inline">D:</strong> (<em class="italic">and other drive letters</em>): Used to access the filesystem, just like in <span class="No-Break">Windows Explorer</span></li>
				<li><strong class="source-inline">HKCU</strong>: Provides access to the <strong class="source-inline">HKEY_CURRENT_USER</strong> <span class="No-Break">registry hive</span></li>
				<li><strong class="source-inline">HKLM</strong>: Provides <a id="_idIndexMarker333"/>access to the <strong class="source-inline">HKEY_LOCAL_MACHINE</strong> <span class="No-Break">registry hive</span></li>
			</ul>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor056"/>Making your code reusable</h1>
			<p>In this section, we will explore the concept of <a id="_idIndexMarker334"/>making your code reusable in PowerShell. Reusability is an <a id="_idIndexMarker335"/>important aspect of coding that allows you to create a function, cmdlet, or module once and use it multiple times without having to rewrite the same code again and again. Through this, you can save time and effort in the <span class="No-Break">long run.</span></p>
			<p>We will start by discussing cmdlets, followed by functions and aliases, and finally, we will explore PowerShell modules, which are collections of PowerShell commands and functions that can be easily shared and installed on other systems, which is a great way to package and distribute your <span class="No-Break">reusable code.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor057"/>Cmdlets</h2>
			<p>A cmdlet (pronounced as <em class="italic">commandlet</em>) is a type of PowerShell command that performs a specific task and can be written in<a id="_idIndexMarker336"/> C# or in another .NET language. This includes advanced functions, which are also considered cmdlets but have more advanced features than <span class="No-Break">regular functions.</span></p>
			<p><strong class="source-inline">Get-Command</strong> can help you to differentiate cmdlets from functions. Additionally, you can also see the version and <span class="No-Break">the provider:</span></p>
			<pre class="source-code">
&gt; Get-Command new-item
CommandType   Name      Version    Source
-----------   ----      -------    ------
Cmdlet        New-Item  3.1.0.0    Microsoft.PowerShell.Management</pre>
			<p>To find out all cmdlets that are currently installed on the machine you are using, you can leverage <strong class="source-inline">Get-Command</strong> with the <span class="No-Break"><strong class="source-inline">CommandType</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
Get-Command -CommandType Cmdlet</pre>
			<p>If you want to dig deeper into cmdlets, I recommend reviewing the official PowerShell documentation. Microsoft has published a <a id="_idIndexMarker337"/>lot of advice, as well as recommendations <span class="No-Break">and guidelines:</span></p>
			<ul>
				<li><a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview</span></a></li>
				<li><a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/windows-powershell-cmdlet-concepts"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/windows-powershell-cmdlet-concepts</span></a></li>
			</ul>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor058"/>Functions</h2>
			<p>Functions are a collection of <a id="_idIndexMarker338"/>PowerShell commands that should be run following a <span class="No-Break">certain logic.</span></p>
			<p>As with other programming and scripting languages, if you are typing in the same commands over and over again, and if you find yourself modifying the same one-liners for different scenarios, it is definitely time to create <span class="No-Break">a function.</span></p>
			<p>When you choose a name, make sure it follows the verb-noun naming convention and only uses approved verbs. Read more about approved verbs and naming conventions in the <em class="italic">Naming conventions</em> section covered earlier in <span class="No-Break">this chapter.</span></p>
			<p>This skeleton function using pseudocode should demonstrate the basic structure of <span class="No-Break">a function:</span></p>
			<pre class="source-code">
function <strong class="bold">Verb-Noun</strong> {
&lt;#
        &lt;Optional help text&gt;
#&gt;
param (
    [<strong class="bold">data_type</strong>]$<strong class="bold">Parameter</strong>
)
&lt;...Code: Function Logic...&gt;
}</pre>
			<p>Once the function is loaded into the session, it needs to be called so that it will <span class="No-Break">be executed:</span></p>
			<pre class="source-code">
Verb-Noun -Parameter "test"</pre>
			<p>You can find a demo<a id="_idIndexMarker339"/> function with demo help that simply writes the output <strong class="bold">Hello World!</strong> and accepts a parameter to generate additional output, as well as the calling of it <span class="No-Break">on GitHub:</span></p>
			<p><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Write-HelloWorld.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Write-HelloWorld.ps1</span></a><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/blob/master/Chapter02/Write-HelloWorld.ps1&#13;"/></p>
			<h3>Parameters</h3>
			<p>A function does<a id="_idIndexMarker340"/> not necessarily need to support parameters, but if you want to<a id="_idIndexMarker341"/> process input within the function, parameters <span class="No-Break">are required:</span></p>
			<pre class="source-code">
function Invoke-Greeting {
    param (
        [string]$Name
    )
    Write-Output "Hello $Name!"
}</pre>
			<p>In this example, the <strong class="source-inline">Invoke-Greeting</strong> function provides the possibility to supply the <strong class="source-inline">$Name</strong> parameter, while specifying the data type as <strong class="source-inline">[string]</strong> will attempt to convert any input to a <em class="italic">string</em>, allowing for flexibility in the parameter input. You can also use other data types (for example, <strong class="source-inline">int</strong>, <strong class="source-inline">boolean</strong>, and so on) depending on your <span class="No-Break">use case.</span></p>
			<p>If the parameter is specified, the provided value is stored in the <strong class="source-inline">$Name</strong> variable and can be used within <span class="No-Break">the function:</span></p>
			<pre class="source-code">
&gt; Invoke-Greeting -Name "Miriam"
Hello Miriam!</pre>
			<p>If the parameter is not specified, it will be replaced by <strong class="source-inline">$null</strong> (which <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">""</strong></span><span class="No-Break">/</span><span class="No-Break"><em class="italic">nothing</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
&gt; Invoke-Greeting
Hello !</pre>
			<p>In this case, the <strong class="source-inline">$Name</strong> parameter is not mandatory, so it does not have to be specified to run <span class="No-Break">the function.</span></p>
			<p>Adding <a id="_idIndexMarker342"/>parameters enables you to cover many of your use case’s complex scenarios. You might have already seen functions that allow only some type of input or that require a certain parameter – functions that will not be run until the user confirms and <a id="_idIndexMarker343"/>functions that provide the possibility to run <span class="No-Break">them verbosely.</span></p>
			<p>Let’s explore how these behaviors can be configured in our next sections about <strong class="source-inline">cmdletbinding</strong>, <strong class="source-inline">SupportsShouldProcess</strong>, input validation, and <span class="No-Break">mandatory parameters.</span></p>
			<h4>cmdletbinding</h4>
			<p><strong class="source-inline">cmdletbinding</strong> is a feature <a id="_idIndexMarker344"/>in PowerShell that allows you to add common parameters (such as <strong class="source-inline">-Verbose</strong>, <strong class="source-inline">-Debug</strong>, or <strong class="source-inline">-ErrorAction</strong>) to your functions and cmdlets without defining them yourself. This can make your code more consistent with other PowerShell commands and easier to use <span class="No-Break">for users.</span></p>
			<p>One way to use <strong class="source-inline">cmdletbinding</strong> is to declare a parameter as mandatory, positional, or in a parameter set, which can automatically turn your function into a cmdlet with additional common parameters. For example, if you want to make the <strong class="source-inline">-Name</strong> parameter mandatory in your function, you can add <strong class="source-inline">[Parameter(Mandatory)]</strong> before the parameter definition, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
function Invoke-Greeting {
    [cmdletbinding()]
    param (
        [Parameter(Mandatory)]
        $Name
    )
    Write-Output "Hello $Name!"
}</pre>
			<p>This will automatically add the <strong class="source-inline">[&lt;CommonParameters &gt;]</strong> section to the output of <strong class="source-inline">Get-Command</strong>, and you will see all the common parameters that are also available in many other cmdlets, such as <strong class="source-inline">Verbose</strong>, <strong class="source-inline">Debug</strong>, <strong class="source-inline">ErrorAction</strong>, <span class="No-Break">and others.</span></p>
			<p>To learn more about <strong class="source-inline">cmdletbinding</strong> and its<a id="_idIndexMarker345"/> functionality, check out the following <span class="No-Break">link: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute</span></a><span class="No-Break">.</span></p>
			<h4>SupportsShouldProcess</h4>
			<p>If a function makes changes, you <a id="_idIndexMarker346"/>can use <strong class="source-inline">SupportsShouldProcess</strong> to add an additional layer of protection to your function. By adding <strong class="source-inline">[CmdletBinding(SupportsShouldProcess)]</strong>, you can enable the <strong class="source-inline">-WhatIf</strong> and <strong class="source-inline">-Confirm</strong> parameters in your function, which help users understand the effect of their actions before executing the function. To use <strong class="source-inline">SupportsShouldProcess</strong> effectively, you will also need to call <strong class="source-inline">ShouldProcess()</strong> for each item being processed. Here’s an example of what your code could <span class="No-Break">look like:</span></p>
			<pre class="source-code">
function Invoke-Greeting {
    [CmdletBinding(SupportsShouldProcess)]
    param (
        $Name
    )
    foreach ($item in $Name) {
        if ($PSCmdlet.ShouldProcess($item)) {
            Write-Output "Hello $item!"
        }
    }
}</pre>
			<p>With this code, the function can be executed with the <strong class="source-inline">-Confirm</strong> parameter to prompt the user for confirmation before processing each item, or with the <strong class="source-inline">-WhatIf</strong> parameter to display a list of changes that would be made without actually processing <span class="No-Break">the items.</span></p>
			<pre class="source-code">
&gt; Get-Command -Name Invoke-Greeting -Syntax
Invoke-Greeting [[-Name] &lt;Object&gt;] [-WhatIf] [-Confirm] [&lt;CommonParameters&gt;]</pre>
			<p>Once you have <a id="_idIndexMarker347"/>added <strong class="source-inline">SupportsShouldProcess</strong> to your function, you can also see that the syntax has changed, by using <strong class="source-inline">Get-Command</strong> as shown in the <span class="No-Break">preceding example.</span></p>
			<h4>Accepting input via the pipeline</h4>
			<p>It is also possible to <a id="_idIndexMarker348"/>configure parameters to accept user input to use it in our code. In addition to accepting input from the user, we can also accept input from the pipeline. This can be done in two ways: by value or by <span class="No-Break">property name.</span></p>
			<p>When accepting input by value, we receive the entire object passed through the pipeline. We can then use the parameter in our function to filter or manipulate <span class="No-Break">the object.</span></p>
			<p>When accepting input by property name, we receive only the specified property of the object passed through the pipeline. This can be useful when we only need to work with a specific property of <span class="No-Break">the object.</span></p>
			<p>To configure a function to accept input by value, we can use <strong class="source-inline">ValueFromPipeline</strong>; to accept input by property name use <strong class="source-inline">ValueFromPipelineByPropertyName</strong>. Of course, both can be combined with each other and with other parameter options as well, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">Mandatory</strong></span><span class="No-Break">.</span></p>
			<p>The following example shows the <strong class="source-inline">Invoke-Greeting</strong> function, which accepts input both by value and property name for its mandatory <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">Name</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
function Invoke-Greeting {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [string]$Name
    )
    process {
        Write-Output "Hello $Name!"
    }
}</pre>
			<p>You can now pass input by value to this function, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
&gt; "Alice","Bob" | Invoke-Greeting
Hello Alice!
Hello Bob!</pre>
			<p>But it also works to pass<a id="_idIndexMarker349"/> input by property name, as the following code <span class="No-Break">snippet demonstrates:</span></p>
			<pre class="source-code">
&gt; [pscustomobject]@{Name = "Miriam"} | Invoke-Greeting
Hello Miriam!</pre>
			<p>If you want to dive deeper into accepting input from the pipeline and how to troubleshoot issues, you may refer to the <span class="No-Break">following resources:</span></p>
			<ul>
				<li><em class="italic">PowerShell Basics for Security Professionals Part 6 – Pipeline</em> by Carlos <span class="No-Break">Perez: </span><a href="https://youtube.com/watch?v=P3ST3lat9bs&#13;"><span class="No-Break">https://youtube.com/watch?v=P3ST3lat9bs</span></a></li>
				<li><em class="italic">About </em><span class="No-Break"><em class="italic">Pipelines</em></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_pipelines"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_pipelines</span></a><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_pipelines&#13;"/></li>
			</ul>
			<p>As this book focuses on PowerShell security and not on expert function creation, it can barely scratch the surface of advanced functions. So, if you are interested in learning more about advanced functions and parameters, I have added some links in the <em class="italic">Further reading</em> section at the end of <span class="No-Break">this chapter.</span></p>
			<h3>Comment-based help</h3>
			<p>Writing comment-based<a id="_idIndexMarker350"/> help for your functions is crucial; others might <a id="_idIndexMarker351"/>reuse your function or if you want to adjust or reuse the function yourself some months after you wrote it, having good comment-based help will simplify <span class="No-Break">the usage:</span></p>
			<pre class="source-code">
&lt;#
.SYNOPSIS
&lt;Describe the function shortly.&gt;
.DESCRIPTION
&lt;More detailed description of the function.&gt;
.PARAMETER Name
&lt;Add a section to describe each parameter, if your function has one or more parameters.&gt;
.EXAMPLE
&lt;Example how to call the funtion&gt;
&lt;Describes what happens if the example call is run.&gt;
#&gt;</pre>
			<p>Please also have a look at the <strong class="source-inline">Write-HelloWorld.ps1</strong> demo script on GitHub to see an <span class="No-Break">example: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Write-HelloWorld.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Write-HelloWorld.ps1</span></a><span class="No-Break">.</span></p>
			<h3>Error handling</h3>
			<p>If you are not sure <a id="_idIndexMarker352"/>whether<a id="_idIndexMarker353"/> your command will succeed, use <strong class="source-inline">try</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">catch</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
try {
    New-PSSession -ComputerName $Computer -ErrorAction Stop
}
catch {
    Write-Warning -Message "Couldn't connect to Computer: $Computer"
}</pre>
			<p>Setting <strong class="source-inline">ErrorAction</strong> to <strong class="source-inline">Stop</strong> will treat the error as a terminating error. As only terminating errors are caught, the action defined in the <strong class="source-inline">catch</strong> block <span class="No-Break">is triggered.</span></p>
			<p>If <strong class="source-inline">ErrorAction</strong> is not<a id="_idIndexMarker354"/> defined and if no terminating error is<a id="_idIndexMarker355"/> triggered, the <strong class="source-inline">catch</strong> block will <span class="No-Break">be ignored.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor059"/>The difference between cmdlets and script cmdlets (advanced functions)</h2>
			<p>When I heard for the first time about cmdlets and advanced functions, I was like <em class="italic">Okay great, but what’s the difference? They both sound </em><span class="No-Break"><em class="italic">pretty alike</em></span><span class="No-Break">.</span></p>
			<p>One significant difference is that<a id="_idIndexMarker356"/> cmdlets can be written in a .NET language such as C# and reside within a compiled binary. Script cmdlets, also known as advanced functions, are <a id="_idIndexMarker357"/>similar to cmdlets, but they are written in PowerShell script rather than a .NET language. Script cmdlets are a way to create custom cmdlets using PowerShell script instead of compiling code in a .<span class="No-Break">NET language.</span></p>
			<p>One advantage of script cmdlets is that they can be easily modified and debugged without requiring compilation, making them more accessible to users who may not be comfortable with .NET languages. Additionally, script cmdlets can be distributed and shared just like <span class="No-Break">compiled cmdlets.</span></p>
			<p>For software vendors and developers, it is easier to package compiled cmdlets than to package libraries of functions and scripts, as well as to write and package <span class="No-Break">help files.</span></p>
			<p>However, it is just a matter of preference what you want to use – if you prefer writing your functions in C# or other .NET-based languages, cmdlets might be your preferred choice; if you prefer using PowerShell only, you might want to create <span class="No-Break">PowerShell functions.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor060"/>Aliases</h2>
			<p>An alias is some<a id="_idIndexMarker358"/> kind of a nickname for a PowerShell command, an alternate name. You can set aliases to make your daily work easier – for example, if you are repeatedly working with the same long and complicated command, setting an alias and using it instead will ease your <span class="No-Break">daily work.</span></p>
			<p>For example, one of the most used aliases is the famous <strong class="source-inline">cd</strong> command, which administrators use to change the directory on the command line. But <strong class="source-inline">cd</strong> is only an alias for the <span class="No-Break"><strong class="source-inline">Set-Location</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
PS C:\&gt; cd 'C:\tmp\PSSec\'
PS C:\tmp\PS Sec&gt;
PS C:\&gt; Set-Location 'C:\tmp\PSSec\'
PS C:\tmp\PS Sec&gt;</pre>
			<p>To see all available cmdlets that have the word <strong class="source-inline">Alias</strong> in their name, you can <span class="No-Break">leverage </span><span class="No-Break"><strong class="source-inline">Get-Command</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer046">
					<img alt="Figure 2.5 – Getting all available cmdlets that have the word Alias in their name" src="image/B16679_02_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Getting all available cmdlets that have the word Alias in their name</p>
			<p>Next, let’s have a closer look at how to work with aliases, using the <strong class="source-inline">Get-Alias</strong>, <strong class="source-inline">New-Alias</strong>, <strong class="source-inline">Set-Alias</strong>, <strong class="source-inline">Export-Alias</strong>, and <span class="No-Break"><strong class="source-inline">Import-Alias</strong></span><span class="No-Break"> cmdlets.</span></p>
			<h3>Get-Alias</h3>
			<p>To see all aliases <a id="_idIndexMarker359"/>that are<a id="_idIndexMarker360"/> currently configured on the computer you are working on, use the <span class="No-Break"><strong class="source-inline">Get-Alias</strong></span><span class="No-Break"> cmdlet:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer047">
					<img alt="Figure 2.6 – Output of the Get-Alias command" src="image/B16679_02_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Output of the Get-Alias command</p>
			<p>You can either <a id="_idIndexMarker361"/>use <strong class="source-inline">Get-Alias</strong> to <a id="_idIndexMarker362"/>inspect the entire list of aliases that are available, or you can check whether a specific alias exists using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Name</strong></span><span class="No-Break"> parameter.</span></p>
			<h3>New-Alias</h3>
			<p>You can <a id="_idIndexMarker363"/>use <strong class="source-inline">New-Alias</strong> to create a new alias within the current <span class="No-Break">PowerShell</span><span class="No-Break"><a id="_idIndexMarker364"/></span><span class="No-Break"> session:</span></p>
			<pre class="source-code">
&gt; New-Alias -Name Get-Ip -Value ipconfig
&gt; Get-Ip
Windows IP Configuration
Ethernet adapter Ethernet:
   Connection-specific DNS Suffix  . : mshome.net
   IPv4 Address. . . . . . . . . . . : 10.10.1.10
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 10.10.1.1</pre>
			<p>This alias is not set permanently, so once you exit the session, the alias will not be <span class="No-Break">available anymore.</span></p>
			<p>If you want to use aliases multiple times in multiple sessions, you can either export them and import them in every new session or you can configure them to be permanently set for every new PowerShell session by using the <span class="No-Break">PowerShell profile.</span></p>
			<p>If you want to <a id="_idIndexMarker365"/>add parameters to the command that your alias runs, you can create a function<a id="_idIndexMarker366"/> and use <strong class="source-inline">New-Alias</strong> to link the new function to your <span class="No-Break">existing command.</span></p>
			<h3>Set-Alias</h3>
			<p><strong class="source-inline">Set-Alias</strong> can<a id="_idIndexMarker367"/> be <a id="_idIndexMarker368"/>used to either create or change <span class="No-Break">an alias.</span></p>
			<p>So if you want to change, for example, the content of the formerly created <strong class="source-inline">Get-Ip</strong> alias to <strong class="source-inline">Get-NetIPAddress</strong>, you would run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; Set-Alias -Name Get-Ip -Value Get-NetIPAddress</pre>
			<h3>Export-Alias</h3>
			<p>Export one or more <a id="_idIndexMarker369"/>aliases with <strong class="source-inline">Export-Alias</strong> – either as a <strong class="source-inline">.csv</strong> file or as <span class="No-Break">a</span><span class="No-Break"><a id="_idIndexMarker370"/></span><span class="No-Break"> script:</span></p>
			<pre class="source-code">
Export-Alias -Path "alias.csv"</pre>
			<p>Using this command, we first export all aliases to a <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">csv</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
Export-Alias -Path "alias.ps1" -As Script</pre>
			<p>The <strong class="source-inline">-As Script</strong> parameter allows you to execute all currently available aliases as a script that can <span class="No-Break">be executed:</span></p>
			<pre class="source-code">
Export-Alias -Path "alias.ps1" -Name Get-Ip -As Script</pre>
			<p>If you plan to re-import the aliases later, it’s important to be aware that executing the script without re-importing the function may cause issues. Therefore, make sure to also import the script on the new system on which you plan to import <span class="No-Break">the alias.</span></p>
			<p>Of course, it is also possible to only export a single alias by specifying its <strong class="source-inline">-Name</strong> parameter, in the <span class="No-Break">last example.</span></p>
			<h4>alias.csv</h4>
			<p>The <strong class="source-inline">alias.csv</strong> file<a id="_idIndexMarker371"/> that we created using the <strong class="source-inline">Export-Alias</strong> command can now be reused to create or import all aliases of this session in <span class="No-Break">another session:</span></p>
			<pre class="source-code">
# Alias File
# Exported by : PSSec
# Date/Time : Sunday, July 9, 2023 1:39:50 PM
# Computer : PSSEC-PC
"foreach","ForEach-Object","","ReadOnly, AllScope"
"%","ForEach-Object","","ReadOnly, AllScope"
"where","Where-Object","","ReadOnly, AllScope"
"?","Where-Object","","ReadOnly, AllScope"
"ac","Add-Content","","ReadOnly, AllScope"
"clc","Clear-Content","","ReadOnly, AllScope"
...
"stz","Set-TimeZone","","None"
"Get-Ip","Get-NetIPAddress","","None"</pre>
			<h4>alias.ps1</h4>
			<p>If you export your aliases <a id="_idIndexMarker372"/>using the <strong class="source-inline">-As Script</strong> option (as in the example from earlier), an executable <strong class="source-inline">.ps1</strong> file (<strong class="source-inline">alias.ps1</strong>) <span class="No-Break">is created.</span></p>
			<p>You can now use the file to set your aliases automatically whenever you run the <strong class="source-inline">.ps1</strong> script, or you can use the code to edit your profile file (see <strong class="source-inline">New-Alias</strong>) to configure <span class="No-Break">permanent aliases:</span></p>
			<pre class="source-code">
# Alias File
# Exported by : PSSec
# Date/Time : Sunday, July 9, 2023 1:34:31 PM
# Computer : PSSEC-PC
set-alias -Name:"Get-Ip" -Value:"Get-NetIPAddress" -Description:"" -Option:"None"</pre>
			<p>If you use functions to <a id="_idIndexMarker373"/>define aliases, make sure to also save those functions and execute them in the session in which you want to import <span class="No-Break">your aliases.</span></p>
			<h3>Import-Alias</h3>
			<p>You can use <strong class="source-inline">Import-Alias</strong> to<a id="_idIndexMarker374"/> import aliases that were exported<a id="_idIndexMarker375"/> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">.csv</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Set-Alias -Name Get-Ip -Value Get-Iponfig
&gt; Export-Alias -Name Get-Ip -Path Get-Ip_alias.csv</pre>
			<p>Import the file to make the alias available in your <span class="No-Break">current session:</span></p>
			<pre class="source-code">
&gt; Import-Alias -Path .\Get-Ip_alias.csv
&gt; Get-Ip
Windows IP Configuration
Ethernet adapter Ethernet:
   Connection-specific DNS Suffix  . : mshome.net
   IPv4 Address. . . . . . . . . . . : 10.10.1.10
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 10.10.1.1</pre>
			<p>Further information on aliases<a id="_idIndexMarker376"/> can be found at the following <span class="No-Break">link: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_aliases"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_aliases</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor061"/>Modules</h2>
			<p>Modules are a <a id="_idIndexMarker377"/>collection of PowerShell commands and functions that can be easily shipped and installed on other systems. They are a great way to enrich your sessions with <span class="No-Break">other functionalities.</span></p>
			<p class="callout-heading">Find Module-Related Cmdlets</p>
			<p class="callout">To find module-related cmdlets, leverage <strong class="source-inline">Get-Command</strong> and have a look at their help pages and the official documentation to understand <span class="No-Break">their function:</span></p>
			<p class="callout"><strong class="source-inline">Get-Command -</strong><span class="No-Break"><strong class="source-inline">Name "*Module*"</strong></span></p>
			<p>All modules that are installed on the system can be found in one of the <strong class="source-inline">PSModulePath</strong> folders, which are part of the <span class="No-Break"><strong class="source-inline">Env:\</strong></span><span class="No-Break"> PSDrive:</span></p>
			<pre class="source-code">
&gt; Get-Item -Path Env:\PSModulePath
Name           Value
----           -----
PSModulePath   C:\Users\PSSec\Documents\WindowsPowerShell\Modules;
               C:\Program Files\WindowsPowerShell\Modules;
               C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules</pre>
			<p>Query the content with <strong class="source-inline">Env:\PSModulePath</strong> to find out which paths were set on <span class="No-Break">your system.</span></p>
			<h3>Working with modules</h3>
			<p>To use a module <a id="_idIndexMarker378"/>efficiently, the following sections will help you to make the module available, to find out how to work with it, and to finally remove or <span class="No-Break">unload it.</span></p>
			<h4>Finding and installing modules</h4>
			<p>To search for a certain module <a id="_idIndexMarker379"/>in a repository, you can leverage <strong class="source-inline">Find-Module -Name &lt;modulename&gt;</strong>. It queries the repositories that are configured on your <span class="No-Break">operating system:</span></p>
			<pre class="source-code">
&gt; Find-Module -Name EventList
Version    Name       Repository           Description
-------    ----       ----------           -----------
2.0.1      EventList  PSGallery            EventList - The Event Analyzer. This tool helps you to decide which events to monitor in your infrastructure and support...</pre>
			<p>Once you have found the<a id="_idIndexMarker380"/> desired module, you can download and install it to your local system <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Install-Module</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Install-Module &lt;modulename&gt;</pre>
			<p>If you have already installed a module for which a newer version exists, update it <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">Update-Module</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Update-Module &lt;modulename&gt; -Force</pre>
			<p>To see which repositories are available on your system, use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&gt; Get-PSRepository</pre>
			<p>One of the most commonly used repositories<a id="_idIndexMarker381"/> is the <strong class="bold">PowerShell Gallery</strong> (shown as <strong class="source-inline">PSGallery</strong> in the <span class="No-Break">previous example).</span></p>
			<h4>The PowerShell Gallery</h4>
			<p>The PowerShell Gallery is<a id="_idIndexMarker382"/> the central repository for<a id="_idIndexMarker383"/> PowerShell content: <a href="https://www.powershellgallery.com/">https://www.powershellgallery.com/</a>. In this repository, you'll find <a id="_idIndexMarker384"/>thousands of helpful modules, scripts, and <strong class="bold">Desired State Configuration</strong> (<span class="No-Break"><strong class="bold">DSC</strong></span><span class="No-Break">) resources.</span></p>
			<p>To leverage <a id="_idIndexMarker385"/>the PowerShell Gallery and to install modules directly from the repository, <strong class="source-inline">NuGet</strong> and <strong class="source-inline">PowerShellGet</strong> need to <span class="No-Break">be installed.</span></p>
			<p>If you haven’t installed the required packages, when you try to install a module for the first time from the PowerShell Gallery, you will be prompted to <span class="No-Break">install it:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer048">
					<img alt="Figure 2.7 – Installing a module from the PowerShell Gallery using Windows PowerShell" src="image/B16679_02_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Installing a module from the PowerShell Gallery using Windows PowerShell</p>
			<p>As you can see in the preceding screenshot, you will not only be prompted to install the module itself but also the NuGet provider if you are installing modules from the PowerShell Gallery for the <span class="No-Break">first time.</span></p>
			<p>If you are using PowerShell Core, both <strong class="source-inline">NuGet</strong> and <strong class="source-inline">PowerShellGet</strong> are usually <span class="No-Break">already preinstalled:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer049">
					<img alt="Figure 2.8 – Installing a module from the PowerShell Gallery using PowerShell Core" src="image/B16679_02_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Installing a module from the PowerShell Gallery using PowerShell Core</p>
			<p class="callout-heading">Configure PowerShell Gallery as a Trusted Repository</p>
			<p class="callout">When you <a id="_idIndexMarker386"/>install modules from the PowerShell Gallery, you may receive a warning that the repository is not trusted. This warning is displayed to ensure that you are aware that you are installing code from an external source that has not been verified by Microsoft. The warning is intended to protect you from potentially malicious code that could harm <span class="No-Break">your system.</span></p>
			<p class="callout">To avoid the warning, you can configure the repository as a trusted repository. By doing this, you are indicating that you trust the source and that you accept the potential risks associated with installing code from it. To configure a repository as a trusted repository, you can use the following code snippet: <strong class="source-inline">Set-PSRepository -Name 'PSGallery' -</strong><span class="No-Break"><strong class="source-inline">InstallationPolicy Trusted</strong></span><span class="No-Break">.</span></p>
			<p class="callout">By configuring the repository as a trusted repository, you are indicating that you trust the code provided by that repository and that you are willing to take responsibility for any risks associated with <span class="No-Break">using it.</span></p>
			<h4>Working with modules</h4>
			<p>To find out which <a id="_idIndexMarker387"/>modules are already available in the current session, you can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">Get-Module</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-Module</pre>
			<p>To see which modules are available to import, including those that come pre-installed with Windows, you can use the <strong class="source-inline">ListAvailable</strong> parameter with the <strong class="source-inline">Get-Module</strong> cmdlet. This will display a list of all available modules on the computer, including their version numbers, descriptions, and <span class="No-Break">other information:</span></p>
			<pre class="source-code">
&gt; Get-Module -ListAvailable</pre>
			<p>Find out which commands are available by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Get-Command</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-Command -Module &lt;modulename&gt;</pre>
			<p>And if you <a id="_idIndexMarker388"/>want to know more about the usage of a command that is available in a module, you can use <strong class="source-inline">Get-Help</strong>. You can see how important it is to write proper help pages for <span class="No-Break">your function:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer050">
					<img alt="Figure 2.9 – Getting the help pages of a command" src="image/B16679_02_009.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Getting the help pages of a command</p>
			<p>If you have, for example, an old version loaded in your current session and you want to unload it, <strong class="source-inline">Remove-Module</strong> unloads the <a id="_idIndexMarker389"/>current module from <span class="No-Break">your session:</span></p>
			<pre class="source-code">
&gt; Remove-Module &lt;modulename&gt;</pre>
			<p>When you are developing and testing your own modules, this command is <span class="No-Break">especially helpful.</span></p>
			<h3>Creating your own modules</h3>
			<p>To make your functions<a id="_idIndexMarker390"/> easier to ship to other systems, creating a module is a great way. As the description of full-blown modules would exceed the scope of this book, I will describe the basics of how to quickly <span class="No-Break">get started.</span></p>
			<p>Please also have a look at the official PowerShell module documentation to better understand how modules <a id="_idIndexMarker391"/>work and how they should be <span class="No-Break">created: </span><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/developer/module/writing-a-windows-powershell-module</span><span class="No-Break">.</span></p>
			<p>When working more intensively with PowerShell modules, you might also come across many different files, such as files that end with <strong class="source-inline">.psm1</strong>, <strong class="source-inline">.psd1</strong>, <strong class="source-inline">.ps1xml</strong>, or <strong class="source-inline">.dll</strong>, help files, localization files, and <span class="No-Break">many others.</span></p>
			<p>I will not describe all the files that can be used in a module, but I will describe the most necessary files – the <strong class="source-inline">.psm1</strong> file and the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">psd1</strong></span><span class="No-Break"> file.</span></p>
			<h4>.psm1</h4>
			<p>The <strong class="source-inline">.psm1</strong> file contains the <a id="_idIndexMarker392"/>scripting logic that your module should provide. Of course, you can also use it to import other functions within <span class="No-Break">your module.</span></p>
			<h4>.psd1 – the module manifest</h4>
			<p>The <strong class="source-inline">.psd1</strong> file is the<a id="_idIndexMarker393"/> manifest of your module. If you only create a PowerShell script module, this file is not mandatory, but it allows you to control your module functions and include information about <span class="No-Break">the module.</span></p>
			<h4>Developing a basic module</h4>
			<p>Creating a basic <a id="_idIndexMarker394"/>PowerShell module can be as simple as writing a script <a id="_idIndexMarker395"/>containing one or more functions, and saving it with a <strong class="source-inline">.psm1</strong> <span class="No-Break">file extension.</span></p>
			<p>First, we define the path where the module should be saved in the <strong class="source-inline">$path</strong> variable and create the <strong class="source-inline">MyModule</strong> folder if it does not exist yet. We then use the <strong class="source-inline">New-ModuleManifest</strong> cmdlet to create a new module manifest file named <strong class="source-inline">MyModule.psd1</strong> in the <strong class="source-inline">MyModule</strong> folder. The <strong class="source-inline">-RootModule</strong> parameter specifies the name of the PowerShell module file, which <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">MyModule.psm1</strong></span><span class="No-Break">.</span></p>
			<p>Using the <strong class="source-inline">Set-Content</strong> cmdlet, we create the <strong class="source-inline">MyModule.psm1</strong> file and define the <strong class="source-inline">Invoke-Greeting</strong> function, which we wrote earlier in <span class="No-Break">this chapter:</span></p>
			<pre class="source-code">
$path = $env:TEMP + "\MyModule\"
if (!(Test-Path -Path $path)) {
    New-Item -ItemType directory -Path $path
}
New-ModuleManifest -Path $path\MyModule.psd1 -RootModule MyModule.psm1
Set-Content -Path $path\MyModule.psm1 -Value {
    function Invoke-Greeting {
        [CmdletBinding()]
        param(
            [Parameter(Mandatory=$true)]
            [string]$Name
        )
        "Hello, $Name!"
    }
}</pre>
			<p>When you want to use a module in your PowerShell session, you can either import it directly into your session or copy it into one of the <strong class="source-inline">PSModule</strong> paths. To ensure that the module is easily accessible for future use, it’s recommended to copy it to one of the <strong class="source-inline">PSModule</strong> paths. The <strong class="source-inline">PSModule</strong> paths are directories that are searched for modules when you use the <strong class="source-inline">Import-Module</strong> cmdlet. To see the <strong class="source-inline">PSModule</strong> paths, you can run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; $env:PSModulePath</pre>
			<p>Once you have<a id="_idIndexMarker396"/> determined which <strong class="source-inline">PSModule</strong> path to use, you can <a id="_idIndexMarker397"/>copy the module directory to that location. After copying the module to the appropriate <strong class="source-inline">PSModule</strong> path, you can then import the module using the <span class="No-Break"><strong class="source-inline">Import-Module</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; Import-Module MyModule</pre>
			<p>Alternatively, when you are in the development phase, you can import the module directly into your session, without having it copied in one of the <strong class="source-inline">PSModule</strong> paths, <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Import-Module</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Import-Module $env:TEMP\MyModule\MyModule.psd1</pre>
			<p>By copying the module to a <strong class="source-inline">PSModule</strong> path, you can easily import it into any PowerShell session without having to specify the full path to <span class="No-Break">the module.</span></p>
			<p>Now, you can call the function that was defined in the <span class="No-Break"><strong class="source-inline">MyModule</strong></span><span class="No-Break"> module:</span></p>
			<pre class="source-code">
&gt; Invoke-Greeting -Name "Miriam"</pre>
			<p>Congratulations, you <a id="_idIndexMarker398"/>just created and executed your first very <span class="No-Break">own</span><span class="No-Break"><a id="_idIndexMarker399"/></span><span class="No-Break"> module!</span></p>
			<p>You can compare your own module with the demo module of this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter02/MyModule"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter02/MyModule</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Module Manifest Options</p>
			<p class="callout">Have a closer look at the options that are available within the module manifest. For example, you can also specify the author, the description, or modules that are required to install this module, using the <span class="No-Break"><strong class="source-inline">RequiredModules</strong></span><span class="No-Break"> hashtable.</span></p>
			<p>As you become more familiar with module development and want to take your code to the next level, you can explore tools such as <strong class="source-inline">PSModuleDevelopment</strong>, which can help you with your development tasks, and also with later CI/CD <span class="No-Break">tasks: </span><a href="https://psframework.org/documentation/documents/psmoduledevelopment.html"><span class="No-Break">https://psframework.org/documentation/documents/psmoduledevelopment.html</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor062"/>Summary</h1>
			<p>In this chapter, you have learned the fundamentals of PowerShell scripting. After refreshing the basics of variables, operators, and control structures, you are able to create your very own scripts, functions, <span class="No-Break">and modules.</span></p>
			<p>Now that you are familiar with the PowerShell basics and you are able to work with PowerShell on your local system, let’s dive deeper into PowerShell remoting and its security considerations in the <span class="No-Break">next chapter.</span></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor063"/>Further reading</h1>
			<p>If you want to explore some of the topics that were mentioned in this chapter, check out <span class="No-Break">these resources:</span></p>
			<ul>
				<li>Everything you want to know about <span class="No-Break">arrays: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-arrays&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-arrays</span></a></li>
				<li>Everything you want to know about <span class="No-Break">hashtables: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-hashtable&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-hashtable</span></a></li>
				<li>Everything you want to know about <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-null&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-null</span></a></li>
				<li>Everything you want to know about <span class="No-Break"><strong class="source-inline">PSCustomObject</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-pscustomobject&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-pscustomobject</span></a></li>
				<li>About <span class="No-Break">functions: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions</span></a></li>
				<li>Functions <span class="No-Break">101: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/09-functions&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/09-functions</span></a></li>
				<li>About functions’ advanced <span class="No-Break">parameters: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters</span></a></li>
				<li>Cmdlets versus <span class="No-Break">functions: </span><a href="https://www.leeholmes.com/blog/2007/07/24/cmdlets-vs-functions/&#13;"><span class="No-Break">https://www.leeholmes.com/blog/2007/07/24/cmdlets-vs-functions/</span></a></li>
				<li>Modules help <span class="No-Break">pages: </span><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_modules</span></li>
			</ul>
			<p>You can also find all links mentioned in this chapter in the GitHub repository for <a href="B16679_02_Final_PD.xhtml#_idTextAnchor034"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> – no need to manually type in every <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Links.md"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Links.md</span></a></p>
		</div>
	</body></html>