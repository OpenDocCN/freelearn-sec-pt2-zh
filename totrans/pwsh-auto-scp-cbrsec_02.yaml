- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell Scripting Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned how to get started with PowerShell, let’s have a closer
    look at PowerShell scripting fundamentals to refresh our knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the basics, such as working with variables, operators, and
    control structures. Then, we will dive deeper, putting the big picture together
    when it comes to cmdlets, functions, and even modules.
  prefs: []
  type: TYPE_NORMAL
- en: After working through this chapter, you should be able to create your very own
    scripts and even know how to create your own modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cmdlets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell 7.3 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access to the GitHub repository for **Chapter02**: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter02](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter02)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **variable** is a storage location that developers can use to store information
    with a so-called *value*. Variables always have names that allow you to call them
    independently of the values that are stored within. In PowerShell, the **$** sign
    at the beginning indicates a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables are great for storing simple values, strings, and also the output
    of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in these examples, not only can we store strings and numbers
    within a variable, we can also store the output of a cmdlet such as **Get-Date**
    and reuse it within our code.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In contrast to other scripting or programming languages, you don’t necessarily
    need to define the data type for variables. When defining a variable, the data
    type that makes the most sense is automatically set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find out which data type was used with the **GetType()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In PowerShell, data types are automatically set. When defining variables in
    an automated way, sometimes it can happen that the wrong variable type is set.
    For example, it can happen that an integer was defined as a string. If you spot
    a conflict, the **GetType()** method helps you to find out which data type was
    set.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table shows a list of variable data types with their description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – Variable data types](image/B16679_02_Table_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 2.1 – Variable data types
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the most common data types that you will come across when working
    with PowerShell. This is not a complete list, so there might also be other variables
    that you will encounter: using **GetType()** helps you identify the variable data
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In PowerShell, all data types are based on .NET classes; to get more information
    on each class, you can refer to the official Microsoft documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/api/system](https://learn.microsoft.com/en-us/dotnet/api/system)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/api/system.management.automation](https://learn.microsoft.com/en-us/dotnet/api/system.management.automation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally, there’s no need to declare data types, as PowerShell does it by itself.
    But sometimes there might be a need to change the data type – for example, if
    a list of imported number values is treated like a string instead of **int**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you are processing values that have the wrong data type declared, you will
    either see nasty error messages (because only another input is accepted) or your
    code will not work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the **$number** variable was declared as a string and we perform an addition,
    a mathematical operation will not be performed. Instead, both are concatenated
    as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Although 42 might be the answer to the ultimate question of life, the universe,
    and everything, it is not the expected answer for our equation: when adding *4
    + 2*, we expect the result *6*, but since *4* is treated as a string, *2* will
    be concatenated and the string *42* is shown as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Especially when parsing files or input, it can happen that variables are not
    set correctly. If that happens, error messages or wrong operations are the results.
    Of course, this behavior is not strictly limited to integers and strings: it can
    basically occur with every other data type as well.'
  prefs: []
  type: TYPE_NORMAL
- en: If you discover that a wrong data type is set, you can convert the data type
    by **casting** it to another type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want, for example, to process **$number** as a normal integer, we need
    to cast the variable type to **[int]**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, **$int_number** can be processed as a normal integer, and performing mathematical
    operations works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also cast a Unicode hex string into a character in PowerShell by using
    the hex value of the Unicode string and casting it to **[char]**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, the right variable data type is already set automatically
    by PowerShell. Casting data types helps you to control how to process the data,
    avoiding wrong results and error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automatic variables are built-in variables that are created and maintained by
    PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is just a small collection of commonly used automatic variables that are
    important for beginners. You might find other automatic variables used in later
    chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**$?**: The execution status of the last command. If the last command succeeded,
    it is set to **True**, otherwise, it is set to **False**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$_**: When processing a pipeline object, **$_** can be used to access the
    current object (**$PSItem**). It can also be used in commands that execute an
    action on every item, as in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**$Error**: Contains the most recent errors, collected in an array. The most
    recent error can be found in **$Error[0]**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$false**: Represents the traditional Boolean value of **False**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$LastExitCode**: Contains the last exit code of the program that was run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$null**: Contains **null** or an empty value. It can be used to check whether
    a variable contains a value or to set an undefined value when scripting, as **$null**
    is still treated like an object with a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$PSScriptRoot**: The location of the directory from which the script is being
    run. It can help you to address relative paths.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$true**: Contains **True**. You can use **$true** to represent **True** in
    commands and scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a complete list of automatic variables, please review the official documentation:
    [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables).'
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Environment variables store information about the operating system and paths
    that are frequently used by the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show all environment variables within your session, you can leverage **dir
    env:**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Environment variables](image/B16679_02_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Environment variables
  prefs: []
  type: TYPE_NORMAL
- en: 'You can directly access and reuse those variables by using the prefix **$env:**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To learn more about how to access and process environment variables, have a
    look at the official documentation: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_environment_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_environment_variables).'
  prefs: []
  type: TYPE_NORMAL
- en: Reserved words and language keywords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some words are reserved by the system and should not be used as variables or
    function names, as this would lead to confusion and unexpected behavior of your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using **Get-Help**, you can get a list and more information on reserved
    words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Also see the **about_Language_Keywords** help pages to get a detailed overview
    and explanation of all language keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an overview of all the language keywords that were available when this
    book was written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To learn more about a certain language keyword, you can use **Get-Help**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Some reserved words (such as **if**, **for**, **foreach**, and **while**) have
    their own help articles. To read them, add **about_** as a prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t find a help page for a certain reserved word, as not every one
    has its own page, you can use **Get-Help** to find help pages that write about
    the word you are looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Keep those reserved words in mind and avoid using them as function, variable,
    or parameter names. Using reserved words can and will lead to a malfunction of
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Variable scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with PowerShell variables, you want to restrict access. If you
    use a variable in a function, you don’t want it to be available by default on
    the command line – especially if you are processing protected values. PowerShell
    variable scopes protect access to variables as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, variables are only available in the context in which they were
    set, unless the scope is modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Scope modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the scope modifier, you can configure the scope in which your variables
    will be available. Here is an overview of the most commonly used scope modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**global**: Sets the scope to **global**. This scope is effective when PowerShell
    starts or if you create a new session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if you set a variable to **global** within a module, once the module
    is loaded and the part is run in which the variable is set to **global**, this
    variable will be available in the session – even if you don’t run other functions
    of this module.
  prefs: []
  type: TYPE_NORMAL
- en: '**local**: This is the current scope. The **local** scope can be the **global**
    scope, the **script** scope, or any other scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**script**: This scope is only effective within the script that sets this scope.
    It can be very useful if you want to set a variable only within a module that
    should not be available after the function was called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate how variable scopes work, I have prepared a little script, **Get-VariableScope.ps1**,
    which can be found in **Chapter02** of this book’s GitHub repository: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Get-VariableScope.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Get-VariableScope.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: In the script, the **Set-Variables** function is declared first. If this function
    is called, it sets variables of three scopes – **local**, **script**, and **global**
    – and then outputs each variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the **Set-Variable** function is called by the same script. After calling
    the function, the variables are written to the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Calling variables with a local, script, and global scope](image/B16679_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Calling variables with a local, script, and global scope
  prefs: []
  type: TYPE_NORMAL
- en: While the variables were just set in the **local** scope, all configured variables
    are available when called in this context (**local scope**).
  prefs: []
  type: TYPE_NORMAL
- en: If the same script tries to access the defined variables outside of the function
    in which the variables were configured, it can still access the variables that
    were configured for the **script** and **global** scope. The variable with the
    **local** scope is inaccessible, as the variables were called in the **script
    scope**.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the **Get-VariableScope.ps1** script, try to access the variables
    on the command line yourself (**global scope**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Accessing the variables on the command line](image/B16679_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Accessing the variables on the command line
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine scopes as *containers for variables* therefore, in this case,
    we can only access variables within the **global** scope container. The variables
    with the **local** and **script** scopes are inaccessible from the command line
    when not called from the script they were defined in.
  prefs: []
  type: TYPE_NORMAL
- en: When working with scopes, it is advisable to *choose the scope that offers the
    minimum required privileges* for your use case. This can help prevent accidental
    script breakage when running scripts multiple times in the same session. While
    using the **global** scope is not necessarily problematic from a security standpoint,
    it is still best to avoid it when not strictly necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Modified Scope Variables
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are working with **script** and **global** scope variables, it is
    a good practice to always use the variable with the modifier: **$script:script_variable**
    / **$****global:global_variable**.'
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to use the variable without the modifier (**$script_variable**
    / **$global_variable**), using it with the modifier helps you to see at one glance
    whether the scope of a variable was changed, helps you with your troubleshooting,
    and avoids confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Scopes are not only restricted to variables; they can also be used to restrict
    functions, aliases, and PowerShell drives. Of course, there are also many more
    use cases for scopes than the ones I described in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested to learn more about scopes (not only variable scopes)
    and advanced use cases, have a look at the official documentation: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes).'
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operators help you not only to perform mathematical or logical operations but
    they are also a good way to compare values or redirect values.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic operators can be used to calculate values. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Addition**  (**+**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Subtraction**  (**-**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Multiplication**  (*****):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Division**  (**/**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Modulus** (**%**): In case you have never worked with modulus in the past,
    **%** is a great way to check whether there is a remainder if a number is divided
    by a divisor. Modulus provides you with the remainder:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Of course, you can also combine different arithmetic operators as you are used
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: When combining different arithmetic operators in PowerShell, the operator precedence
    is respected, as you are used to from regular mathematic operations.
  prefs: []
  type: TYPE_NORMAL
- en: Semicolons, (Curly) Braces, and Ampersands
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are using the semicolon to execute multiple commands on
    a single line: in PowerShell, a **semicolon** (**;**) is functionally equivalent
    to a carriage return.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that the use of reserved characters such as **curly
    braces** **{}**, **parentheses** **()**, and **ampersands** **&** can have a significant
    impact on script execution. Specifically, **curly braces** denote a code block,
    while **parentheses** are used to group expressions or function parameters. The
    **ampersand** is used to invoke an executable or command as if it were a cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid issues with script execution, it is essential to be aware of these
    reserved characters and their specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, it is necessary to compare values. In this section, you will find an
    overview of comparison operators in PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Equal (**-eq**): Returns **True** if both values are equal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In an **array context**, operators behave differently: when an array is used
    as the left-hand operand in a comparison, PowerShell performs the comparison operation
    against each element in the array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using comparison operators in an array context, the operation will return
    the elements selected by the operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When used in an array context, the **-eq** operator behaves differently from
    its typical comparison behavior. Instead of checking whether the two operands
    are equal, it returns all elements in the left-hand operand array that are equal
    to the right-hand operand. If no matches are found, the operation will still return
    **False**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Not equal (**-ne**): Returns **True** if both values are not equal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Less equal (**-le**): Returns **True** if the first value is less than or equal
    to the second value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Greater equal (**-ge**): Returns **True** if the first value is greater than
    or equal to the second value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Less than (**-lt**): Returns **True** if the first value is less than the second
    value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Greater than (**-gt**): Returns **True** if the first value is greater than
    the second value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**-like**: Can be used to check whether a value matches a wildcard expression
    when used with a scalar. If used in an array context, the **-like** operator returns
    only the elements that match the specified wildcard expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is important to note that the array version of the operator does not return
    a Boolean value indicating whether any elements in the array match the expression,
    as the scalar version does.
  prefs: []
  type: TYPE_NORMAL
- en: '**-notlike**: Can be used to check whether a value does not match a wildcard
    expression when used with a scalar. If used in an array context, the **-notlike**
    operator returns only the elements that do not match the specified wildcard expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**-match**: Can be used to check whether a value matches a regular expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**-notmatch**: Can be used to check whether a value does not match a regular
    expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also refer to the official PowerShell documentation to read more about comparison
    operators: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators).'
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with variables, it is vital to understand assignment operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '**=**: Assigns a value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**+=**: Increases the value by the amount defined after the operator and stores
    the result in the initial variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**-=**: Decreases the value by the amount defined after the operator and stores
    the result in the initial variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '***=**: Multiplies the value by the amount defined after the operator and stores
    the result in the initial variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**/=**: Divides the value by the amount defined after the operator and stores
    the result in the initial variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**%=**: Performs a modulo operation on the variable using the amount after
    the operator and stores the result in the initial variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**++**: Increases the variable by **1**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**--**: Decreases the variable by **1**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Please refer to the official documentation to see more examples of how to use
    assignment operators: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_assignment_operators](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_assignment_operators).'
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you work with multiple statements, you will need logical operators to add,
    compare, or exclude. In this section, you will find an overview of common logical
    operators in PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-and**: Can be used to combine conditions. The defined action is triggered
    only if both conditions are met:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**-or**: If one of the defined conditions is met, the action is triggered:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**-not** or **!**: Can be used to negate a condition. The following example
    tests whether the folder specified using the **$path** variable is available.
    If it is missing, it will be created:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**-xor**: Logical exclusive **-or**. Is **True** if *only one* statement is
    **True** (but returns **False** if both are **True**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you have learned how to work with operators in PowerShell, let’s have
    a look at control structures in our next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please also refer to the **about_operators** documentation to learn more about
    PowerShell operators in general: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_operators](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_operators).'
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A control structure is some kind of programmatic logic that assesses conditions
    and variables and decides which defined action will be taken if a certain condition
    is met.
  prefs: []
  type: TYPE_NORMAL
- en: Use the operators that we learned about in the last section to define the conditions,
    which will be assessed using the control structures introduced in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to select which action is performed if a certain condition is met,
    you can use one of the following selection control structures: either an **if/elseif/else**
    construct or the **switch** statement.'
  prefs: []
  type: TYPE_NORMAL
- en: If/elseif/else
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**if**, **elseif**, and **else** can be used to check whether a certain condition
    is **True** and run an action if the condition is fulfilled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the **if** statement to check whether a condition is **True**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check whether one of several conditions is **True** by using **elseif**.
    The action of the first condition that is met will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the control structure checks whether one of the specified conditions
    is met (either **$color -eq "blue"** or **$color -eq "green"**). If **$color**
    would be **red**, no action would be performed.
  prefs: []
  type: TYPE_NORMAL
- en: But since **$color** is **green**, the **elseif** condition is **True** and
    the **The color is green!** string will be written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to specify an action that will be triggered if none of the specified
    conditions are met, you can use **else**. If no condition from **if** or **elseif**
    is met, the action specified in the **else** block will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we check whether **$color** is either **blue** or **green**.
    But since **$color** is **"red"**, none of the defined conditions are **True**,
    and therefore the code defined in the **else** block will be executed, which writes
    **That is also a very beautiful color!** to the output.
  prefs: []
  type: TYPE_NORMAL
- en: Switch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, it can happen that you want to check one variable against a long
    list of values.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, you could – of course – create a long and complicated
    list of **if**, **elseif**, …, **elseif**, and **else** statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'But instead, you can use the more elegant **switch** statement to test a value
    against a list of predefined values and react accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the user is prompted to enter a value: **What is your** **favorite
    color?**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on what the user enters, a different output will be shown: if **purple**
    is entered, a line from a famous Prince song, *Purple Rain*, will be displayed.
    If **red** is entered, a line of the Police song *Roxanne* is cited.'
  prefs: []
  type: TYPE_NORMAL
- en: But if **green** is entered, the **default** output will be shown, as there’s
    no option for the **green** value defined and the message **The color is not in
    this list** will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using the **switch** statement to evaluate simple conditions
    based on the value of a variable or expression, PowerShell also supports **more
    advanced modes**. These modes allow you to use regular expressions, process the
    contents of files, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use the **-Regex** parameter to use a regular expression
    to match against the input, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: If **$userInput** was defined as **"Hello World!"**, then **"User input starts
    with a letter."** would be written to the output. If **$userInput** started with
    a number (for example, **"1337"**), the output would be **"User input starts with
    a number."**. And if **$userInput** started with a different character, (for example,
    **"!"**), then the **default** condition would be met and **"User input doesn't
    start with a letter or number."** would be written to the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the **-File** parameter to process the contents of a file
    with the **switch** statement. The **-Wildcard** parameter enables you to use
    the wildcard logic with **switch**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we’re using the **switch** statement to process the contents
    of a file named **"example.txt"**. We’re looking for the **"*Error*"** pattern
    within the file, and then taking an action based on whether that pattern was found.
    If the specified file contains the pattern, **"Error was found!:"** will be written
    to the output, followed by the line that contained the error. It’s important to
    note that the wildcard pattern is processed line by line and not for the entire
    file, so there will be an **"Error was found!: "** line written to the output
    for every line in the file that contained the **"*****Error*"** pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: Loops and iterations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to run an action over and over again until a certain condition is
    met, you can do that using loops. A loop will continue to execute as long as the
    specified condition is **True** unless it is terminated with a loop-breaking statement
    such as **break**. Depending on the loop construct used, the loop may execute
    at least once, or may not execute at all if the condition is initially **False**.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will find an overview of how to work with loops.
  prefs: []
  type: TYPE_NORMAL
- en: ForEach-Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ForEach-Object** accepts a list or an array of items and allows you to perform
    an action against each of them. **ForEach-Object** is best used when you use the
    pipeline to pipe objects to **ForEach-Object**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if you want to process all files that are in a folder, you can
    use **Foreach-Object**. **$_** contains the value of every single item of each
    iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to perform specific actions before processing each item in the
    pipeline or after processing all the items, you can use the **-Begin** and **-End**
    advanced parameters with the **ForEach-Object** cmdlet: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/foreach-object](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/foreach-object).'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can use the **-Process** parameter to specify the script block
    that is run for each item in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Foreach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To iterate through a collection of items in PowerShell, you can use the **Foreach-Object**
    *cmdlet*, the **foreach** *statement*, or the **foreach** *method*. The **Foreach-Object**
    *cmdlet* accepts pipeline objects, making it a useful tool for working with object-oriented
    data. The **foreach** *method* and the **foreach** *statement* are very similar
    to **Foreach-Object** but they do not accept pipeline objects. You will get error
    messages if you try to use it in the same way as **Foreach-Object**.
  prefs: []
  type: TYPE_NORMAL
- en: The **foreach** *statement* loads all items into a collection before they are
    processed, making it quicker but consuming more memory than **ForEach-Object**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to use the **foreach**  *statement*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the **$path** path is examined similarly as in our example
    before. But in this case, it uses a **foreach** *statement* to iterate through
    each item in the **$items** array, assigning the current item to the **$file**
    variable on each iteration. The **$file** variable is defined by the author of
    the script – every other variable name can be added here and, of course, processed.
    For each item, it outputs the value of **$file** to the console using the **Write-Host**
    cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the **.foreach({})** *method* to iterate through a collection of
    items. Here’s an example of how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, **$path** is examined; for each file in that folder, the filename
    will be written to the command line. The **.foreach**(**{}**) *method* is used
    to iterate through each item in the **$items** collection and write a message
    to the console that includes the item’s name. The **$_** variable is used to reference
    the current item being iterated over. So, for each item in the **$items** collection,
    the script will output a message such as **"Current** **item: filename"**.'
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**while** does something (**<actions>**) as long as the defined *condition*
    is fulfilled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, user input is read, and as long as the user doesn’t type in
    **quit**, the **while** loop still runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: In this example, if the user types in either **hello**, **color**, or **help**,
    different output options will be shown, but the program still continues, as the
    condition for the **while** statement is not fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user types in **quit**, the program will be terminated, as the condition
    is fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: for
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This defines the initializing statement, a condition, and loops through until
    the defined condition is not fulfilled anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need iterating values, **for** is a great solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: In this example, **$i=1** is the starting condition, and in every iteration,
    **$i** is increased by **1**, using the **$i++** statement. As long as **$i**
    is smaller than or equal to **5** – that is, **($i -le 5)** – the loop continues
    and writes **$i** to the output.
  prefs: []
  type: TYPE_NORMAL
- en: do-until/do-while
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Compared to other loops, **do-until** or **do-while** already starts running
    the defined commands and then checks whether the condition is still met or not
    met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Although **do-until** and **do-while** have the same syntax, they differ in
    how the condition is treated.
  prefs: []
  type: TYPE_NORMAL
- en: '**do-while** runs as long as the condition is **True** and stops as soon as
    the condition is not met anymore. **do-until** runs only as long as the condition
    is *not* met: it ends when the condition is met.'
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**break** can be used to exit the loop (for example, **for**/**foreach**/**foreach-object**/…):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Consult the official documentation to learn more about the advanced usage of
    **break**: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break).'
  prefs: []
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **continue** statement is used to skip the current iteration of a loop
    and move to the next one. It does not affect the loop’s condition, which will
    be re-evaluated at the beginning of the next iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the modulus (**%**) operator to calculate whether a
    division by **2** returns a remainder. If the remainder of **$i % 2** is non-zero,
    then the condition returns **True**, and **continue** is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior causes **$i** to be only written to the console if no remainder
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Did You Know?
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example demonstrates that *every time* the remainder returned
    is *not 0*, the *current iteration is skipped*. This code could also be simplified
    by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**for ($i=1; $i -le 10; $****i++) {**'
  prefs: []
  type: TYPE_NORMAL
- en: '**if ($i % 2){** **continue }**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write-Host “****i: $i”**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: You can use control structures not only to solve a single instance but also
    to solve problems by combining multiple control structures to build complex logic.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this section, you should have a basic knowledge of what control
    structures exist and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cmdlets and functions both follow the schema *verb-noun*, such as **Get-Help**
    or **Stop-Process**. So, if you write your own functions or cmdlets, make sure
    to follow the name guidelines and recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft has released a list of approved verbs. Although it is not technically
    enforced to use approved verbs, it is strongly recommended to do so in order to
    comply with PowerShell best practices and avoid conflicts with automatic variables
    and reserved words. Additionally, using approved verbs is required when publishing
    PowerShell modules to the PowerShell Gallery, as it will trigger a warning message
    if non-approved verbs are used. Here is the link for the approved verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands)'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the approved verbs
  prefs: []
  type: TYPE_NORMAL
- en: If you are in the process of writing your code and quickly want to check which
    approved verbs exist, you can leverage the **Get-Verb** command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to sort the list of available verbs, you can pipe the output to
    **Sort-Object**. By default, the verbs are sorted into traditional categories
    of use, such as **Common**, **Data**, and **Lifecycle**. However, you can also
    sort them alphabetically by name by specifying the **Name** property with the
    **Sort-Object** command. Use the following command to sort the output of **Get-Verb**
    by the name **Verb**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use wildcards to prefilter the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'If you just want to get all approved verbs from a certain group (in this case,
    **Security**), you can filter **Group** using **Where-Object**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Although naming conventions are not enforced in PowerShell, they should be respected
    nevertheless. Microsoft also strongly encourages following those guidelines when
    writing your cmdlets to ensure that users have a consistent user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please also have a look at the development guidelines when writing your own
    functions and cmdlets: https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/strongly-encouraged-development-guidelines.'
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell profiles are configuration files that allow you to personalize your
    PowerShell environment. These profiles can be used to customize the behavior and
    environment of PowerShell sessions. They are scripts that are executed when a
    PowerShell session is started, allowing users to set variables, define functions,
    create aliases, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Any variables, functions, or aliases defined in the appropriate PowerShell profile
    will be loaded every time a PowerShell session is started. This means you can
    have a consistent and personalized PowerShell environment across all your sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several different types of profiles and more than one can be processed
    by PowerShell. PowerShell profiles are stored as plain text files on your system,
    and there are several types of profiles available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**All Users, All Hosts** (**$profile.AllUsersAllHosts**): This profile applies
    to all users for all PowerShell hosts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All Users, Current Host** (**$profile.AllUsersCurrentHost**): This profile
    applies to all users for the current PowerShell host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current User, All Hosts** (**$profile.CurrentUserAllHosts**): This profile
    applies to the current user for all PowerShell hosts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current User, Current Host** (**$profile.CurrentUserCurrentHost**): This
    profile applies only to the current user and the current PowerShell host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **PowerShell host** is an application that hosts the PowerShell engine. Examples
    of PowerShell hosts include the Windows PowerShell console, the PowerShell **Integrated
    Scripting Environment** (**ISE**), and the PowerShell terminal in Visual Studio
    Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The location of your PowerShell profile(s) depends on your system and configuration,
    but you can easily find out where they are stored by running the following command
    in PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Finding out the location of the local PowerShell profile(s)](image/B16679_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Finding out the location of the local PowerShell profile(s)
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that there are also more profile paths available, including
    those used by the system and not just by individual users (which would be included
    in the **AllUsers** profile):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Applies to local shells and all users: **%windir%\system32\WindowsPowerShell\v1.0\profile.ps1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applies to all shells and all users: **%windir%\system32\WindowsPowerShell\v1.0\Microsoft.PowerShell_profile.ps1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applies to all local ISE shells and all users: **%windir%\system32\WindowsPowerShell\v1.0\Microsoft.PowerShellISE_profile.ps1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This profile is loaded when using the PowerShell ISE and can be viewed by running
    the **$profile | fl * -force** command within the ISE
  prefs: []
  type: TYPE_NORMAL
- en: 'Applies to current user ISE shells on the local host: **%UserProfile%\Documents\WindowsPowerShell\Microsoft.PowerShellISE_profile.ps1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, in Windows PowerShell, there are profiles for **AllUsers** and
    **AllHosts**, which apply to all users and all PowerShell hosts on a system. In
    PowerShell Core, there are profiles for **AllUsers** and **AllHosts** as well,
    but they do not load the Windows PowerShell profiles from the **system32** directory
    by default. It’s also worth noting that while PowerShell Core supports loading
    Windows PowerShell profiles, the reverse is not true.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the file path of one particular profile, such as the one for **CurrentUserCurrentHost**,
    you can use the variable that is defined in **$profile.CurrentUserCurrentHost**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code snippet to check whether the file already exists; if
    it does not yet, the file is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the commands, functions, or aliases to the user profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: In addition to customizing your PowerShell environment, profiles are also a
    crucial aspect of PowerShell security. By modifying your profiles, you can set
    policies and restrictions to enforce security best practices, such as preventing
    the execution of unsigned scripts or setting execution policies. But also, adversaries
    can use PowerShell profiles to their advantage – for example, to establish persistence.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PSDrives in PowerShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell includes a feature called **PowerShell drives** (**PSDrives**). PSDrives
    in PowerShell are similar to filesystem drives in Windows, but instead of accessing
    files and folders, you use PSDrives to access a variety of data stores. These
    data stores can include directories, registry keys, and other data sources, which
    can be accessed through a consistent and familiar interface.
  prefs: []
  type: TYPE_NORMAL
- en: PSDrives are powered by **PSProviders**, which are the underlying components
    that provide access to data stores. PSProviders are similar to drivers in Windows,
    which allow access to different hardware devices. In the case of PowerShell, PSProviders
    allow you to access different data stores in a uniform way, using the same set
    of cmdlets and syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the **Env:\** PSDrive is a built-in PowerShell drive that provides
    access to environment variables. To retrieve all environment variables that have
    the **path** string in their name, you can use the **Get-ChildItem** cmdlet with
    the **Env:\** PSDrive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: To access a PSDrive, you use a special prefix in the path. For example, to access
    the filesystem drive, you use the prefix **C:**, and to access the registry drive,
    you use the prefix **HKLM:**. In the case of the **Env:\** PSDrive, the prefix
    is **Env:**, which allows you to access environment variables as if they were
    files or folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several built-in PSDrives in PowerShell, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Alias**: Provides access to PowerShell aliases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment**: Provides access to environment variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function**: Provides access to PowerShell functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variable**: Provides access to PowerShell variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cert**: Provides access to certificates in the Windows certificate store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cert:\CurrentUser**: Provides access to certificates in the current user’s
    certificate store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cert:\LocalMachine**: Provides access to certificates in the local machine’s
    certificate store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WSMan**: Provides access to **Windows Remote Management** (**WinRM**) configuration
    data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C:** and **D:** (*and other drive letters*): Used to access the filesystem,
    just like in Windows Explorer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HKCU**: Provides access to the **HKEY_CURRENT_USER** registry hive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HKLM**: Provides access to the **HKEY_LOCAL_MACHINE** registry hive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your code reusable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the concept of making your code reusable in
    PowerShell. Reusability is an important aspect of coding that allows you to create
    a function, cmdlet, or module once and use it multiple times without having to
    rewrite the same code again and again. Through this, you can save time and effort
    in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by discussing cmdlets, followed by functions and aliases, and
    finally, we will explore PowerShell modules, which are collections of PowerShell
    commands and functions that can be easily shared and installed on other systems,
    which is a great way to package and distribute your reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: Cmdlets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cmdlet (pronounced as *commandlet*) is a type of PowerShell command that performs
    a specific task and can be written in C# or in another .NET language. This includes
    advanced functions, which are also considered cmdlets but have more advanced features
    than regular functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Get-Command** can help you to differentiate cmdlets from functions. Additionally,
    you can also see the version and the provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'To find out all cmdlets that are currently installed on the machine you are
    using, you can leverage **Get-Command** with the **CommandType** parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to dig deeper into cmdlets, I recommend reviewing the official
    PowerShell documentation. Microsoft has published a lot of advice, as well as
    recommendations and guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/windows-powershell-cmdlet-concepts](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/windows-powershell-cmdlet-concepts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are a collection of PowerShell commands that should be run following
    a certain logic.
  prefs: []
  type: TYPE_NORMAL
- en: As with other programming and scripting languages, if you are typing in the
    same commands over and over again, and if you find yourself modifying the same
    one-liners for different scenarios, it is definitely time to create a function.
  prefs: []
  type: TYPE_NORMAL
- en: When you choose a name, make sure it follows the verb-noun naming convention
    and only uses approved verbs. Read more about approved verbs and naming conventions
    in the *Naming conventions* section covered earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This skeleton function using pseudocode should demonstrate the basic structure
    of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the function is loaded into the session, it needs to be called so that
    it will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find a demo function with demo help that simply writes the output **Hello
    World!** and accepts a parameter to generate additional output, as well as the
    calling of it on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Write-HelloWorld.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Write-HelloWorld.ps1)'
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function does not necessarily need to support parameters, but if you want
    to process input within the function, parameters are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the **Invoke-Greeting** function provides the possibility to
    supply the **$Name** parameter, while specifying the data type as **[string]**
    will attempt to convert any input to a *string*, allowing for flexibility in the
    parameter input. You can also use other data types (for example, **int**, **boolean**,
    and so on) depending on your use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the parameter is specified, the provided value is stored in the **$Name**
    variable and can be used within the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'If the parameter is not specified, it will be replaced by **$null** (which
    is **""**/*nothing*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the **$Name** parameter is not mandatory, so it does not have
    to be specified to run the function.
  prefs: []
  type: TYPE_NORMAL
- en: Adding parameters enables you to cover many of your use case’s complex scenarios.
    You might have already seen functions that allow only some type of input or that
    require a certain parameter – functions that will not be run until the user confirms
    and functions that provide the possibility to run them verbosely.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how these behaviors can be configured in our next sections about
    **cmdletbinding**, **SupportsShouldProcess**, input validation, and mandatory
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: cmdletbinding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**cmdletbinding** is a feature in PowerShell that allows you to add common
    parameters (such as **-Verbose**, **-Debug**, or **-ErrorAction**) to your functions
    and cmdlets without defining them yourself. This can make your code more consistent
    with other PowerShell commands and easier to use for users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to use **cmdletbinding** is to declare a parameter as mandatory, positional,
    or in a parameter set, which can automatically turn your function into a cmdlet
    with additional common parameters. For example, if you want to make the **-Name**
    parameter mandatory in your function, you can add **[Parameter(Mandatory)]** before
    the parameter definition, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically add the **[<CommonParameters >]** section to the output
    of **Get-Command**, and you will see all the common parameters that are also available
    in many other cmdlets, such as **Verbose**, **Debug**, **ErrorAction**, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about **cmdletbinding** and its functionality, check out the
    following link: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute).'
  prefs: []
  type: TYPE_NORMAL
- en: SupportsShouldProcess
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a function makes changes, you can use **SupportsShouldProcess** to add an
    additional layer of protection to your function. By adding **[CmdletBinding(SupportsShouldProcess)]**,
    you can enable the **-WhatIf** and **-Confirm** parameters in your function, which
    help users understand the effect of their actions before executing the function.
    To use **SupportsShouldProcess** effectively, you will also need to call **ShouldProcess()**
    for each item being processed. Here’s an example of what your code could look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: With this code, the function can be executed with the **-Confirm** parameter
    to prompt the user for confirmation before processing each item, or with the **-WhatIf**
    parameter to display a list of changes that would be made without actually processing
    the items.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Once you have added **SupportsShouldProcess** to your function, you can also
    see that the syntax has changed, by using **Get-Command** as shown in the preceding
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting input via the pipeline
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is also possible to configure parameters to accept user input to use it
    in our code. In addition to accepting input from the user, we can also accept
    input from the pipeline. This can be done in two ways: by value or by property
    name.'
  prefs: []
  type: TYPE_NORMAL
- en: When accepting input by value, we receive the entire object passed through the
    pipeline. We can then use the parameter in our function to filter or manipulate
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: When accepting input by property name, we receive only the specified property
    of the object passed through the pipeline. This can be useful when we only need
    to work with a specific property of the object.
  prefs: []
  type: TYPE_NORMAL
- en: To configure a function to accept input by value, we can use **ValueFromPipeline**;
    to accept input by property name use **ValueFromPipelineByPropertyName**. Of course,
    both can be combined with each other and with other parameter options as well,
    such as **Mandatory**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the **Invoke-Greeting** function, which accepts
    input both by value and property name for its mandatory **$****Name** parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now pass input by value to this function, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'But it also works to pass input by property name, as the following code snippet
    demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to dive deeper into accepting input from the pipeline and how to
    troubleshoot issues, you may refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*PowerShell Basics for Security Professionals Part 6 – Pipeline* by Carlos
    Perez: [https://youtube.com/watch?v=P3ST3lat9bs](https://youtube.com/watch?v=P3ST3lat9bs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*About* *Pipelines*: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_pipelines](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_pipelines)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As this book focuses on PowerShell security and not on expert function creation,
    it can barely scratch the surface of advanced functions. So, if you are interested
    in learning more about advanced functions and parameters, I have added some links
    in the *Further reading* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Comment-based help
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Writing comment-based help for your functions is crucial; others might reuse
    your function or if you want to adjust or reuse the function yourself some months
    after you wrote it, having good comment-based help will simplify the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Please also have a look at the **Write-HelloWorld.ps1** demo script on GitHub
    to see an example: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Write-HelloWorld.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Write-HelloWorld.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are not sure whether your command will succeed, use **try** and **catch**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Setting **ErrorAction** to **Stop** will treat the error as a terminating error.
    As only terminating errors are caught, the action defined in the **catch** block
    is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: If **ErrorAction** is not defined and if no terminating error is triggered,
    the **catch** block will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between cmdlets and script cmdlets (advanced functions)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When I heard for the first time about cmdlets and advanced functions, I was
    like *Okay great, but what’s the difference? They both sound* *pretty alike*.
  prefs: []
  type: TYPE_NORMAL
- en: One significant difference is that cmdlets can be written in a .NET language
    such as C# and reside within a compiled binary. Script cmdlets, also known as
    advanced functions, are similar to cmdlets, but they are written in PowerShell
    script rather than a .NET language. Script cmdlets are a way to create custom
    cmdlets using PowerShell script instead of compiling code in a .NET language.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of script cmdlets is that they can be easily modified and debugged
    without requiring compilation, making them more accessible to users who may not
    be comfortable with .NET languages. Additionally, script cmdlets can be distributed
    and shared just like compiled cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: For software vendors and developers, it is easier to package compiled cmdlets
    than to package libraries of functions and scripts, as well as to write and package
    help files.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is just a matter of preference what you want to use – if you prefer
    writing your functions in C# or other .NET-based languages, cmdlets might be your
    preferred choice; if you prefer using PowerShell only, you might want to create
    PowerShell functions.
  prefs: []
  type: TYPE_NORMAL
- en: Aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alias is some kind of a nickname for a PowerShell command, an alternate name.
    You can set aliases to make your daily work easier – for example, if you are repeatedly
    working with the same long and complicated command, setting an alias and using
    it instead will ease your daily work.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, one of the most used aliases is the famous **cd** command, which
    administrators use to change the directory on the command line. But **cd** is
    only an alias for the **Set-Location** cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'To see all available cmdlets that have the word **Alias** in their name, you
    can leverage **Get-Command**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Getting all available cmdlets that have the word Alias in their
    name](image/B16679_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Getting all available cmdlets that have the word Alias in their
    name
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s have a closer look at how to work with aliases, using the **Get-Alias**,
    **New-Alias**, **Set-Alias**, **Export-Alias**, and **Import-Alias** cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: Get-Alias
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see all aliases that are currently configured on the computer you are working
    on, use the **Get-Alias** cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Output of the Get-Alias command](image/B16679_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Output of the Get-Alias command
  prefs: []
  type: TYPE_NORMAL
- en: You can either use **Get-Alias** to inspect the entire list of aliases that
    are available, or you can check whether a specific alias exists using the **-****Name**
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: New-Alias
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use **New-Alias** to create a new alias within the current PowerShell
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: This alias is not set permanently, so once you exit the session, the alias will
    not be available anymore.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use aliases multiple times in multiple sessions, you can either
    export them and import them in every new session or you can configure them to
    be permanently set for every new PowerShell session by using the PowerShell profile.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to add parameters to the command that your alias runs, you can create
    a function and use **New-Alias** to link the new function to your existing command.
  prefs: []
  type: TYPE_NORMAL
- en: Set-Alias
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Set-Alias** can be used to either create or change an alias.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So if you want to change, for example, the content of the formerly created
    **Get-Ip** alias to **Get-NetIPAddress**, you would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Export-Alias
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Export one or more aliases with **Export-Alias** – either as a **.csv** file
    or as a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this command, we first export all aliases to a **.****csv** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'The **-As Script** parameter allows you to execute all currently available
    aliases as a script that can be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: If you plan to re-import the aliases later, it’s important to be aware that
    executing the script without re-importing the function may cause issues. Therefore,
    make sure to also import the script on the new system on which you plan to import
    the alias.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is also possible to only export a single alias by specifying its
    **-Name** parameter, in the last example.
  prefs: []
  type: TYPE_NORMAL
- en: alias.csv
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **alias.csv** file that we created using the **Export-Alias** command can
    now be reused to create or import all aliases of this session in another session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: alias.ps1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you export your aliases using the **-As Script** option (as in the example
    from earlier), an executable **.ps1** file (**alias.ps1**) is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now use the file to set your aliases automatically whenever you run
    the **.ps1** script, or you can use the code to edit your profile file (see **New-Alias**)
    to configure permanent aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: If you use functions to define aliases, make sure to also save those functions
    and execute them in the session in which you want to import your aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Import-Alias
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use **Import-Alias** to import aliases that were exported as **.csv**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the file to make the alias available in your current session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Further information on aliases can be found at the following link: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_aliases](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_aliases).'
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modules are a collection of PowerShell commands and functions that can be easily
    shipped and installed on other systems. They are a great way to enrich your sessions
    with other functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Find Module-Related Cmdlets
  prefs: []
  type: TYPE_NORMAL
- en: 'To find module-related cmdlets, leverage **Get-Command** and have a look at
    their help pages and the official documentation to understand their function:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get-Command -****Name "*Module*"**'
  prefs: []
  type: TYPE_NORMAL
- en: 'All modules that are installed on the system can be found in one of the **PSModulePath**
    folders, which are part of the **Env:\** PSDrive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Query the content with **Env:\PSModulePath** to find out which paths were set
    on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Working with modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use a module efficiently, the following sections will help you to make the
    module available, to find out how to work with it, and to finally remove or unload
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Finding and installing modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To search for a certain module in a repository, you can leverage **Find-Module
    -Name <modulename>**. It queries the repositories that are configured on your
    operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have found the desired module, you can download and install it to
    your local system using **Install-Module**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have already installed a module for which a newer version exists, update
    it with **Update-Module**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'To see which repositories are available on your system, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: One of the most commonly used repositories is the **PowerShell Gallery** (shown
    as **PSGallery** in the previous example).
  prefs: []
  type: TYPE_NORMAL
- en: The PowerShell Gallery
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The PowerShell Gallery is the central repository for PowerShell content: [https://www.powershellgallery.com/](https://www.powershellgallery.com/).
    In this repository, you''ll find thousands of helpful modules, scripts, and **Desired
    State Configuration** (**DSC**) resources.'
  prefs: []
  type: TYPE_NORMAL
- en: To leverage the PowerShell Gallery and to install modules directly from the
    repository, **NuGet** and **PowerShellGet** need to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven’t installed the required packages, when you try to install a module
    for the first time from the PowerShell Gallery, you will be prompted to install
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Installing a module from the PowerShell Gallery using Windows
    PowerShell](image/B16679_02_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Installing a module from the PowerShell Gallery using Windows PowerShell
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, you will not only be prompted to
    install the module itself but also the NuGet provider if you are installing modules
    from the PowerShell Gallery for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using PowerShell Core, both **NuGet** and **PowerShellGet** are
    usually already preinstalled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Installing a module from the PowerShell Gallery using PowerShell
    Core](image/B16679_02_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Installing a module from the PowerShell Gallery using PowerShell
    Core
  prefs: []
  type: TYPE_NORMAL
- en: Configure PowerShell Gallery as a Trusted Repository
  prefs: []
  type: TYPE_NORMAL
- en: When you install modules from the PowerShell Gallery, you may receive a warning
    that the repository is not trusted. This warning is displayed to ensure that you
    are aware that you are installing code from an external source that has not been
    verified by Microsoft. The warning is intended to protect you from potentially
    malicious code that could harm your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid the warning, you can configure the repository as a trusted repository.
    By doing this, you are indicating that you trust the source and that you accept
    the potential risks associated with installing code from it. To configure a repository
    as a trusted repository, you can use the following code snippet: **Set-PSRepository
    -Name ''PSGallery'' -****InstallationPolicy Trusted**.'
  prefs: []
  type: TYPE_NORMAL
- en: By configuring the repository as a trusted repository, you are indicating that
    you trust the code provided by that repository and that you are willing to take
    responsibility for any risks associated with using it.
  prefs: []
  type: TYPE_NORMAL
- en: Working with modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To find out which modules are already available in the current session, you
    can use **Get-Module**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'To see which modules are available to import, including those that come pre-installed
    with Windows, you can use the **ListAvailable** parameter with the **Get-Module**
    cmdlet. This will display a list of all available modules on the computer, including
    their version numbers, descriptions, and other information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'Find out which commands are available by using **Get-Command**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you want to know more about the usage of a command that is available
    in a module, you can use **Get-Help**. You can see how important it is to write
    proper help pages for your function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Getting the help pages of a command](image/B16679_02_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Getting the help pages of a command
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have, for example, an old version loaded in your current session and
    you want to unload it, **Remove-Module** unloads the current module from your
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: When you are developing and testing your own modules, this command is especially
    helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make your functions easier to ship to other systems, creating a module is
    a great way. As the description of full-blown modules would exceed the scope of
    this book, I will describe the basics of how to quickly get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please also have a look at the official PowerShell module documentation to
    better understand how modules work and how they should be created: https://docs.microsoft.com/en-us/powershell/scripting/developer/module/writing-a-windows-powershell-module.'
  prefs: []
  type: TYPE_NORMAL
- en: When working more intensively with PowerShell modules, you might also come across
    many different files, such as files that end with **.psm1**, **.psd1**, **.ps1xml**,
    or **.dll**, help files, localization files, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: I will not describe all the files that can be used in a module, but I will describe
    the most necessary files – the **.psm1** file and the **.****psd1** file.
  prefs: []
  type: TYPE_NORMAL
- en: .psm1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **.psm1** file contains the scripting logic that your module should provide.
    Of course, you can also use it to import other functions within your module.
  prefs: []
  type: TYPE_NORMAL
- en: .psd1 – the module manifest
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **.psd1** file is the manifest of your module. If you only create a PowerShell
    script module, this file is not mandatory, but it allows you to control your module
    functions and include information about the module.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a basic module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Creating a basic PowerShell module can be as simple as writing a script containing
    one or more functions, and saving it with a **.psm1** file extension.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the path where the module should be saved in the **$path**
    variable and create the **MyModule** folder if it does not exist yet. We then
    use the **New-ModuleManifest** cmdlet to create a new module manifest file named
    **MyModule.psd1** in the **MyModule** folder. The **-RootModule** parameter specifies
    the name of the PowerShell module file, which is **MyModule.psm1**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the **Set-Content** cmdlet, we create the **MyModule.psm1** file and
    define the **Invoke-Greeting** function, which we wrote earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'When you want to use a module in your PowerShell session, you can either import
    it directly into your session or copy it into one of the **PSModule** paths. To
    ensure that the module is easily accessible for future use, it’s recommended to
    copy it to one of the **PSModule** paths. The **PSModule** paths are directories
    that are searched for modules when you use the **Import-Module** cmdlet. To see
    the **PSModule** paths, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have determined which **PSModule** path to use, you can copy the module
    directory to that location. After copying the module to the appropriate **PSModule**
    path, you can then import the module using the **Import-Module** cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, when you are in the development phase, you can import the module
    directly into your session, without having it copied in one of the **PSModule**
    paths, using **Import-Module**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: By copying the module to a **PSModule** path, you can easily import it into
    any PowerShell session without having to specify the full path to the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can call the function that was defined in the **MyModule** module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, you just created and executed your first very own module!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can compare your own module with the demo module of this chapter: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter02/MyModule](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter02/MyModule).'
  prefs: []
  type: TYPE_NORMAL
- en: Module Manifest Options
  prefs: []
  type: TYPE_NORMAL
- en: Have a closer look at the options that are available within the module manifest.
    For example, you can also specify the author, the description, or modules that
    are required to install this module, using the **RequiredModules** hashtable.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you become more familiar with module development and want to take your code
    to the next level, you can explore tools such as **PSModuleDevelopment**, which
    can help you with your development tasks, and also with later CI/CD tasks: [https://psframework.org/documentation/documents/psmoduledevelopment.html](https://psframework.org/documentation/documents/psmoduledevelopment.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned the fundamentals of PowerShell scripting.
    After refreshing the basics of variables, operators, and control structures, you
    are able to create your very own scripts, functions, and modules.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with the PowerShell basics and you are able to work
    with PowerShell on your local system, let’s dive deeper into PowerShell remoting
    and its security considerations in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to explore some of the topics that were mentioned in this chapter,
    check out these resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything you want to know about arrays: [https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-arrays](https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything you want to know about hashtables: [https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-hashtable](https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-hashtable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything you want to know about **$****null**: [https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-null](https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything you want to know about **PSCustomObject**: [https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-pscustomobject](https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-pscustomobject'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'About functions: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions 101: [https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/09-functions](https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/09-functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'About functions’ advanced parameters: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Cmdlets versus functions: [https://www.leeholmes.com/blog/2007/07/24/cmdlets-vs-functions/](https://www.leeholmes.com/blog/2007/07/24/cmdlets-vs-functions/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules help pages: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also find all links mentioned in this chapter in the GitHub repository
    for [*Chapter 2*](B16679_02_Final_PD.xhtml#_idTextAnchor034) – no need to manually
    type in every link: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Links.md](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Links.md)'
  prefs: []
  type: TYPE_NORMAL
