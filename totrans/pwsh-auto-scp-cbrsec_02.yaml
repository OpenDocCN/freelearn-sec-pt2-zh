- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell Scripting Fundamentals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned how to get started with PowerShell, let’s have a closer
    look at PowerShell scripting fundamentals to refresh our knowledge.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the basics, such as working with variables, operators, and
    control structures. Then, we will dive deeper, putting the big picture together
    when it comes to cmdlets, functions, and even modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: After working through this chapter, you should be able to create your very own
    scripts and even know how to create your own modules.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming conventions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cmdlets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aliases
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell 7.3 and above
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access to the GitHub repository for **Chapter02**: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter02](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter02)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **variable** is a storage location that developers can use to store information
    with a so-called *value*. Variables always have names that allow you to call them
    independently of the values that are stored within. In PowerShell, the **$** sign
    at the beginning indicates a variable:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Variables are great for storing simple values, strings, and also the output
    of commands:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see in these examples, not only can we store strings and numbers
    within a variable, we can also store the output of a cmdlet such as **Get-Date**
    and reuse it within our code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In contrast to other scripting or programming languages, you don’t necessarily
    need to define the data type for variables. When defining a variable, the data
    type that makes the most sense is automatically set:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can find out which data type was used with the **GetType()** method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In PowerShell, data types are automatically set. When defining variables in
    an automated way, sometimes it can happen that the wrong variable type is set.
    For example, it can happen that an integer was defined as a string. If you spot
    a conflict, the **GetType()** method helps you to find out which data type was
    set.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Overview of data types
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table shows a list of variable data types with their description:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – Variable data types](image/B16679_02_Table_001.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Table 2.1 – Variable data types
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the most common data types that you will come across when working
    with PowerShell. This is not a complete list, so there might also be other variables
    that you will encounter: using **GetType()** helps you identify the variable data
    type.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'In PowerShell, all data types are based on .NET classes; to get more information
    on each class, you can refer to the official Microsoft documentation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/api/system](https://learn.microsoft.com/en-us/dotnet/api/system)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/api/system.management.automation](https://learn.microsoft.com/en-us/dotnet/api/system.management.automation)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.microsoft.com/en-us/dotnet/api/system.management.automation](https://learn.microsoft.com/en-us/dotnet/api/system.management.automation)'
- en: Casting variables
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换变量
- en: 'Normally, there’s no need to declare data types, as PowerShell does it by itself.
    But sometimes there might be a need to change the data type – for example, if
    a list of imported number values is treated like a string instead of **int**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不需要声明数据类型，因为PowerShell会自动处理。但有时可能需要更改数据类型——例如，如果导入的数字值列表被当作字符串处理而不是**int**：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you are processing values that have the wrong data type declared, you will
    either see nasty error messages (because only another input is accepted) or your
    code will not work as expected.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理声明了错误数据类型的值，你将看到令人头疼的错误信息（因为只接受其他输入），或者你的代码将无法按预期工作。
- en: 'If the **$number** variable was declared as a string and we perform an addition,
    a mathematical operation will not be performed. Instead, both are concatenated
    as a string:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**$number**变量被声明为字符串，并且我们执行加法操作，那么将不会进行数学运算。相反，两者会作为字符串连接在一起：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Although 42 might be the answer to the ultimate question of life, the universe,
    and everything, it is not the expected answer for our equation: when adding *4
    + 2*, we expect the result *6*, but since *4* is treated as a string, *2* will
    be concatenated and the string *42* is shown as a result:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然42可能是生命、宇宙和一切问题的终极答案，但它并不是我们方程的预期答案：当我们计算*4 + 2*时，期望的结果是*6*，但由于*4*被视为字符串，*2*将被连接成字符串*42*，并作为结果显示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Especially when parsing files or input, it can happen that variables are not
    set correctly. If that happens, error messages or wrong operations are the results.
    Of course, this behavior is not strictly limited to integers and strings: it can
    basically occur with every other data type as well.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在解析文件或输入时，变量可能没有正确设置。如果发生这种情况，结果会是错误信息或错误操作。当然，这种行为不仅限于整数和字符串：基本上每种数据类型都会发生类似问题。
- en: If you discover that a wrong data type is set, you can convert the data type
    by **casting** it to another type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现设置了错误的数据类型，可以通过**类型转换**将数据类型转换为其他类型。
- en: 'If we want, for example, to process **$number** as a normal integer, we need
    to cast the variable type to **[int]**:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将**$number**作为普通整数处理，我们需要将变量类型转换为**[int]**：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, **$int_number** can be processed as a normal integer, and performing mathematical
    operations works as expected:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**$int_number**可以作为普通整数处理，执行数学运算时也能按预期工作：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also cast a Unicode hex string into a character in PowerShell by using
    the hex value of the Unicode string and casting it to **[char]**:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用Unicode字符串的十六进制值，并将其转换为**[char]**，在PowerShell中将Unicode十六进制字符串转换为字符：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Most of the time, the right variable data type is already set automatically
    by PowerShell. Casting data types helps you to control how to process the data,
    avoiding wrong results and error messages.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，PowerShell会自动设置正确的变量数据类型。类型转换可以帮助你控制如何处理数据，避免错误结果和错误信息。
- en: Automatic variables
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动变量
- en: Automatic variables are built-in variables that are created and maintained by
    PowerShell.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 自动变量是由PowerShell创建并维护的内置变量。
- en: 'Here is just a small collection of commonly used automatic variables that are
    important for beginners. You might find other automatic variables used in later
    chapters:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只是一个初学者常用的自动变量小集合。你可能会在后续章节中找到其他自动变量：
- en: '**$?**: The execution status of the last command. If the last command succeeded,
    it is set to **True**, otherwise, it is set to **False**.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$?**：上一个命令的执行状态。如果上一个命令成功执行，则设置为**True**，否则设置为**False**。'
- en: '**$_**: When processing a pipeline object, **$_** can be used to access the
    current object (**$PSItem**). It can also be used in commands that execute an
    action on every item, as in the following example:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$_**：在处理管道对象时，**$_**可以用来访问当前对象（**$PSItem**）。它也可以用于在每个项目上执行操作的命令，如以下示例所示：'
- en: '[PRE10]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**$Error**: Contains the most recent errors, collected in an array. The most
    recent error can be found in **$Error[0]**.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$Error**：包含最近的错误，这些错误存储在一个数组中。最近的错误可以在**$Error[0]**中找到。'
- en: '**$false**: Represents the traditional Boolean value of **False**.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$false**：表示传统的布尔值**False**。'
- en: '**$LastExitCode**: Contains the last exit code of the program that was run.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$LastExitCode**：包含运行的程序的最后退出代码。'
- en: '**$null**: Contains **null** or an empty value. It can be used to check whether
    a variable contains a value or to set an undefined value when scripting, as **$null**
    is still treated like an object with a value.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$null**：包含**null**或空值。它可以用来检查变量是否包含值，或者在脚本编写时设置一个未定义的值，因为**$null**仍然被当作一个具有值的对象来处理。'
- en: '**$PSScriptRoot**: The location of the directory from which the script is being
    run. It can help you to address relative paths.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$PSScriptRoot**：当前脚本运行所在目录的位置。它可以帮助你处理相对路径。'
- en: '**$true**: Contains **True**. You can use **$true** to represent **True** in
    commands and scripts.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$true**：包含**True**。你可以在命令和脚本中使用**$true**来表示**True**。'
- en: 'For a complete list of automatic variables, please review the official documentation:
    [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有关自动变量的完整列表，请查看官方文档：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables)。
- en: Environment variables
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境变量
- en: Environment variables store information about the operating system and paths
    that are frequently used by the system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量存储有关操作系统和系统经常使用的路径的信息。
- en: 'To show all environment variables within your session, you can leverage **dir
    env:**, as shown in the following screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示当前会话中的所有环境变量，可以使用**dir env:**，如下面的截图所示：
- en: '![Figure 2.1 – Environment variables](image/B16679_02_001.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 环境变量](image/B16679_02_001.jpg)'
- en: Figure 2.1 – Environment variables
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 环境变量
- en: 'You can directly access and reuse those variables by using the prefix **$env:**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用前缀**$env:**直接访问和重用这些变量：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To learn more about how to access and process environment variables, have a
    look at the official documentation: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_environment_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_environment_variables).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于如何访问和处理环境变量的信息，请查看官方文档：[https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_environment_variables](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_environment_variables)。
- en: Reserved words and language keywords
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留字和语言关键字
- en: Some words are reserved by the system and should not be used as variables or
    function names, as this would lead to confusion and unexpected behavior of your
    code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有些词是系统保留的，不应作为变量或函数名称使用，因为这会导致代码出现混淆和意外行为。
- en: 'By using **Get-Help**, you can get a list and more information on reserved
    words:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**Get-Help**，你可以获得保留字的列表和更多信息：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Also see the **about_Language_Keywords** help pages to get a detailed overview
    and explanation of all language keywords:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另请查看**about_Language_Keywords**帮助页面，以获得所有语言关键字的详细概述和解释：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here’s an overview of all the language keywords that were available when this
    book was written:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本书编写时所有可用的语言关键字概览：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To learn more about a certain language keyword, you can use **Get-Help**:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于某个语言关键字的信息，你可以使用**Get-Help**：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Some reserved words (such as **if**, **for**, **foreach**, and **while**) have
    their own help articles. To read them, add **about_** as a prefix:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些保留字（如**if**、**for**、**foreach**和**while**）有自己的帮助文章。要阅读它们，请在前面加上**about_**作为前缀：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you don’t find a help page for a certain reserved word, as not every one
    has its own page, you can use **Get-Help** to find help pages that write about
    the word you are looking for:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有找到某个特定保留字的帮助页面（并非每个保留字都有自己的页面），你可以使用**Get-Help**查找包含你所寻找词语的帮助页面：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Keep those reserved words in mind and avoid using them as function, variable,
    or parameter names. Using reserved words can and will lead to a malfunction of
    your code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住这些保留字，避免将它们用作函数、变量或参数名称。使用保留字会导致代码出现故障。
- en: Variable scope
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量作用域
- en: When working with PowerShell variables, you want to restrict access. If you
    use a variable in a function, you don’t want it to be available by default on
    the command line – especially if you are processing protected values. PowerShell
    variable scopes protect access to variables as needed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 PowerShell 变量时，你需要限制访问。如果你在函数中使用一个变量，你不希望它在命令行上默认可用——尤其是当你处理受保护的值时。PowerShell
    变量作用域根据需要保护对变量的访问。
- en: 'In general, variables are only available in the context in which they were
    set, unless the scope is modified:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Scope modifier
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the scope modifier, you can configure the scope in which your variables
    will be available. Here is an overview of the most commonly used scope modifiers:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**global**: Sets the scope to **global**. This scope is effective when PowerShell
    starts or if you create a new session.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if you set a variable to **global** within a module, once the module
    is loaded and the part is run in which the variable is set to **global**, this
    variable will be available in the session – even if you don’t run other functions
    of this module.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '**local**: This is the current scope. The **local** scope can be the **global**
    scope, the **script** scope, or any other scope.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**script**: This scope is only effective within the script that sets this scope.
    It can be very useful if you want to set a variable only within a module that
    should not be available after the function was called.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To demonstrate how variable scopes work, I have prepared a little script, **Get-VariableScope.ps1**,
    which can be found in **Chapter02** of this book’s GitHub repository: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Get-VariableScope.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Get-VariableScope.ps1).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: In the script, the **Set-Variables** function is declared first. If this function
    is called, it sets variables of three scopes – **local**, **script**, and **global**
    – and then outputs each variable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the **Set-Variable** function is called by the same script. After calling
    the function, the variables are written to the output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Calling variables with a local, script, and global scope](image/B16679_02_002.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Calling variables with a local, script, and global scope
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: While the variables were just set in the **local** scope, all configured variables
    are available when called in this context (**local scope**).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: If the same script tries to access the defined variables outside of the function
    in which the variables were configured, it can still access the variables that
    were configured for the **script** and **global** scope. The variable with the
    **local** scope is inaccessible, as the variables were called in the **script
    scope**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the **Get-VariableScope.ps1** script, try to access the variables
    on the command line yourself (**global scope**):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Accessing the variables on the command line](image/B16679_02_003.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Accessing the variables on the command line
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine scopes as *containers for variables* therefore, in this case,
    we can only access variables within the **global** scope container. The variables
    with the **local** and **script** scopes are inaccessible from the command line
    when not called from the script they were defined in.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: When working with scopes, it is advisable to *choose the scope that offers the
    minimum required privileges* for your use case. This can help prevent accidental
    script breakage when running scripts multiple times in the same session. While
    using the **global** scope is not necessarily problematic from a security standpoint,
    it is still best to avoid it when not strictly necessary.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Working with Modified Scope Variables
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are working with **script** and **global** scope variables, it is
    a good practice to always use the variable with the modifier: **$script:script_variable**
    / **$****global:global_variable**.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Although it is possible to use the variable without the modifier (**$script_variable**
    / **$global_variable**), using it with the modifier helps you to see at one glance
    whether the scope of a variable was changed, helps you with your troubleshooting,
    and avoids confusion.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Scopes are not only restricted to variables; they can also be used to restrict
    functions, aliases, and PowerShell drives. Of course, there are also many more
    use cases for scopes than the ones I described in this section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are interested to learn more about scopes (not only variable scopes)
    and advanced use cases, have a look at the official documentation: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_scopes).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operators help you not only to perform mathematical or logical operations but
    they are also a good way to compare values or redirect values.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Arithmetic operators can be used to calculate values. They are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**Addition**  (**+**):'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Subtraction**  (**-**):'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Multiplication**  (*****):'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Division**  (**/**):'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Modulus** (**%**): In case you have never worked with modulus in the past,
    **%** is a great way to check whether there is a remainder if a number is divided
    by a divisor. Modulus provides you with the remainder:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Of course, you can also combine different arithmetic operators as you are used
    to:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When combining different arithmetic operators in PowerShell, the operator precedence
    is respected, as you are used to from regular mathematic operations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Semicolons, (Curly) Braces, and Ampersands
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we are using the semicolon to execute multiple commands on
    a single line: in PowerShell, a **semicolon** (**;**) is functionally equivalent
    to a carriage return.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth noting that the use of reserved characters such as **curly
    braces** **{}**, **parentheses** **()**, and **ampersands** **&** can have a significant
    impact on script execution. Specifically, **curly braces** denote a code block,
    while **parentheses** are used to group expressions or function parameters. The
    **ampersand** is used to invoke an executable or command as if it were a cmdlet.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: To avoid issues with script execution, it is essential to be aware of these
    reserved characters and their specific use cases.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, it is necessary to compare values. In this section, you will find an
    overview of comparison operators in PowerShell:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Equal (**-eq**): Returns **True** if both values are equal:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In an **array context**, operators behave differently: when an array is used
    as the left-hand operand in a comparison, PowerShell performs the comparison operation
    against each element in the array.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'When using comparison operators in an array context, the operation will return
    the elements selected by the operator:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When used in an array context, the **-eq** operator behaves differently from
    its typical comparison behavior. Instead of checking whether the two operands
    are equal, it returns all elements in the left-hand operand array that are equal
    to the right-hand operand. If no matches are found, the operation will still return
    **False**:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Not equal (**-ne**): Returns **True** if both values are not equal:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Less equal (**-le**): Returns **True** if the first value is less than or equal
    to the second value:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Greater equal (**-ge**): Returns **True** if the first value is greater than
    or equal to the second value:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Less than (**-lt**): Returns **True** if the first value is less than the second
    value:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Greater than (**-gt**): Returns **True** if the first value is greater than
    the second value:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '**-like**: Can be used to check whether a value matches a wildcard expression
    when used with a scalar. If used in an array context, the **-like** operator returns
    only the elements that match the specified wildcard expression:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: It is important to note that the array version of the operator does not return
    a Boolean value indicating whether any elements in the array match the expression,
    as the scalar version does.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '**-notlike**: Can be used to check whether a value does not match a wildcard
    expression when used with a scalar. If used in an array context, the **-notlike**
    operator returns only the elements that do not match the specified wildcard expression:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '**-match**: Can be used to check whether a value matches a regular expression:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '**-notmatch**: Can be used to check whether a value does not match a regular
    expression:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Also refer to the official PowerShell documentation to read more about comparison
    operators: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_comparison_operators).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Assignment operators
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with variables, it is vital to understand assignment operators:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '**=**: Assigns a value:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '**+=**: Increases the value by the amount defined after the operator and stores
    the result in the initial variable:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '**-=**: Decreases the value by the amount defined after the operator and stores
    the result in the initial variable:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '***=**: Multiplies the value by the amount defined after the operator and stores
    the result in the initial variable:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '**/=**: Divides the value by the amount defined after the operator and stores
    the result in the initial variable:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '**%=**: Performs a modulo operation on the variable using the amount after
    the operator and stores the result in the initial variable:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '**++**: Increases the variable by **1**:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '**--**: Decreases the variable by **1**:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Please refer to the official documentation to see more examples of how to use
    assignment operators: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_assignment_operators](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_assignment_operators).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you work with multiple statements, you will need logical operators to add,
    compare, or exclude. In this section, you will find an overview of common logical
    operators in PowerShell:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '**-and**: Can be used to combine conditions. The defined action is triggered
    only if both conditions are met:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '**-or**: If one of the defined conditions is met, the action is triggered:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '**-not** or **!**: Can be used to negate a condition. The following example
    tests whether the folder specified using the **$path** variable is available.
    If it is missing, it will be created:'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '**-xor**: Logical exclusive **-or**. Is **True** if *only one* statement is
    **True** (but returns **False** if both are **True**):'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Now that you have learned how to work with operators in PowerShell, let’s have
    a look at control structures in our next section.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Please also refer to the **about_operators** documentation to learn more about
    PowerShell operators in general: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_operators](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_operators).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Control structures
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A control structure is some kind of programmatic logic that assesses conditions
    and variables and decides which defined action will be taken if a certain condition
    is met.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Use the operators that we learned about in the last section to define the conditions,
    which will be assessed using the control structures introduced in this section.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Conditions
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to select which action is performed if a certain condition is met,
    you can use one of the following selection control structures: either an **if/elseif/else**
    construct or the **switch** statement.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: If/elseif/else
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**if**, **elseif**, and **else** can be used to check whether a certain condition
    is **True** and run an action if the condition is fulfilled:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'You can use the **if** statement to check whether a condition is **True**:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'You can also check whether one of several conditions is **True** by using **elseif**.
    The action of the first condition that is met will be executed:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: In this example, the control structure checks whether one of the specified conditions
    is met (either **$color -eq "blue"** or **$color -eq "green"**). If **$color**
    would be **red**, no action would be performed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: But since **$color** is **green**, the **elseif** condition is **True** and
    the **The color is green!** string will be written to the console.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to specify an action that will be triggered if none of the specified
    conditions are met, you can use **else**. If no condition from **if** or **elseif**
    is met, the action specified in the **else** block will be executed:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: In this example, we check whether **$color** is either **blue** or **green**.
    But since **$color** is **"red"**, none of the defined conditions are **True**,
    and therefore the code defined in the **else** block will be executed, which writes
    **That is also a very beautiful color!** to the output.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Switch
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, it can happen that you want to check one variable against a long
    list of values.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, you could – of course – create a long and complicated
    list of **if**, **elseif**, …, **elseif**, and **else** statements.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'But instead, you can use the more elegant **switch** statement to test a value
    against a list of predefined values and react accordingly:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Here is an example:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'In this example, the user is prompted to enter a value: **What is your** **favorite
    color?**.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on what the user enters, a different output will be shown: if **purple**
    is entered, a line from a famous Prince song, *Purple Rain*, will be displayed.
    If **red** is entered, a line of the Police song *Roxanne* is cited.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: But if **green** is entered, the **default** output will be shown, as there’s
    no option for the **green** value defined and the message **The color is not in
    this list** will be displayed.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using the **switch** statement to evaluate simple conditions
    based on the value of a variable or expression, PowerShell also supports **more
    advanced modes**. These modes allow you to use regular expressions, process the
    contents of files, and more.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use the **-Regex** parameter to use a regular expression
    to match against the input, like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: If **$userInput** was defined as **"Hello World!"**, then **"User input starts
    with a letter."** would be written to the output. If **$userInput** started with
    a number (for example, **"1337"**), the output would be **"User input starts with
    a number."**. And if **$userInput** started with a different character, (for example,
    **"!"**), then the **default** condition would be met and **"User input doesn't
    start with a letter or number."** would be written to the output.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the **-File** parameter to process the contents of a file
    with the **switch** statement. The **-Wildcard** parameter enables you to use
    the wildcard logic with **switch**:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'In this example, we’re using the **switch** statement to process the contents
    of a file named **"example.txt"**. We’re looking for the **"*Error*"** pattern
    within the file, and then taking an action based on whether that pattern was found.
    If the specified file contains the pattern, **"Error was found!:"** will be written
    to the output, followed by the line that contained the error. It’s important to
    note that the wildcard pattern is processed line by line and not for the entire
    file, so there will be an **"Error was found!: "** line written to the output
    for every line in the file that contained the **"*****Error*"** pattern.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Loops and iterations
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to run an action over and over again until a certain condition is
    met, you can do that using loops. A loop will continue to execute as long as the
    specified condition is **True** unless it is terminated with a loop-breaking statement
    such as **break**. Depending on the loop construct used, the loop may execute
    at least once, or may not execute at all if the condition is initially **False**.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will find an overview of how to work with loops.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: ForEach-Object
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ForEach-Object** accepts a list or an array of items and allows you to perform
    an action against each of them. **ForEach-Object** is best used when you use the
    pipeline to pipe objects to **ForEach-Object**.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if you want to process all files that are in a folder, you can
    use **Foreach-Object**. **$_** contains the value of every single item of each
    iteration:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'If you want to perform specific actions before processing each item in the
    pipeline or after processing all the items, you can use the **-Begin** and **-End**
    advanced parameters with the **ForEach-Object** cmdlet: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/foreach-object](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/foreach-object).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can use the **-Process** parameter to specify the script block
    that is run for each item in the pipeline.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Foreach
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To iterate through a collection of items in PowerShell, you can use the **Foreach-Object**
    *cmdlet*, the **foreach** *statement*, or the **foreach** *method*. The **Foreach-Object**
    *cmdlet* accepts pipeline objects, making it a useful tool for working with object-oriented
    data. The **foreach** *method* and the **foreach** *statement* are very similar
    to **Foreach-Object** but they do not accept pipeline objects. You will get error
    messages if you try to use it in the same way as **Foreach-Object**.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: The **foreach** *statement* loads all items into a collection before they are
    processed, making it quicker but consuming more memory than **ForEach-Object**.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to use the **foreach**  *statement*:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: In this example, the **$path** path is examined similarly as in our example
    before. But in this case, it uses a **foreach** *statement* to iterate through
    each item in the **$items** array, assigning the current item to the **$file**
    variable on each iteration. The **$file** variable is defined by the author of
    the script – every other variable name can be added here and, of course, processed.
    For each item, it outputs the value of **$file** to the console using the **Write-Host**
    cmdlet.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the **.foreach({})** *method* to iterate through a collection of
    items. Here’s an example of how to use it:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'In this example, **$path** is examined; for each file in that folder, the filename
    will be written to the command line. The **.foreach**(**{}**) *method* is used
    to iterate through each item in the **$items** collection and write a message
    to the console that includes the item’s name. The **$_** variable is used to reference
    the current item being iterated over. So, for each item in the **$items** collection,
    the script will output a message such as **"Current** **item: filename"**.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: while
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**while** does something (**<actions>**) as long as the defined *condition*
    is fulfilled:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'In this example, user input is read, and as long as the user doesn’t type in
    **quit**, the **while** loop still runs:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: In this example, if the user types in either **hello**, **color**, or **help**,
    different output options will be shown, but the program still continues, as the
    condition for the **while** statement is not fulfilled.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Once the user types in **quit**, the program will be terminated, as the condition
    is fulfilled.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: for
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This defines the initializing statement, a condition, and loops through until
    the defined condition is not fulfilled anymore:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'If you need iterating values, **for** is a great solution:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: In this example, **$i=1** is the starting condition, and in every iteration,
    **$i** is increased by **1**, using the **$i++** statement. As long as **$i**
    is smaller than or equal to **5** – that is, **($i -le 5)** – the loop continues
    and writes **$i** to the output.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: do-until/do-while
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Compared to other loops, **do-until** or **do-while** already starts running
    the defined commands and then checks whether the condition is still met or not
    met:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Although **do-until** and **do-while** have the same syntax, they differ in
    how the condition is treated.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '**do-while** runs as long as the condition is **True** and stops as soon as
    the condition is not met anymore. **do-until** runs only as long as the condition
    is *not* met: it ends when the condition is met.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: break
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**break** can be used to exit the loop (for example, **for**/**foreach**/**foreach-object**/…):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Consult the official documentation to learn more about the advanced usage of
    **break**: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_break).'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: continue
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **continue** statement is used to skip the current iteration of a loop
    and move to the next one. It does not affect the loop’s condition, which will
    be re-evaluated at the beginning of the next iteration:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: In this example, we use the modulus (**%**) operator to calculate whether a
    division by **2** returns a remainder. If the remainder of **$i % 2** is non-zero,
    then the condition returns **True**, and **continue** is triggered.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: This behavior causes **$i** to be only written to the console if no remainder
    is returned.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Did You Know?
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example demonstrates that *every time* the remainder returned
    is *not 0*, the *current iteration is skipped*. This code could also be simplified
    by writing the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '**for ($i=1; $i -le 10; $****i++) {**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '**if ($i % 2){** **continue }**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '**Write-Host “****i: $i”**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: You can use control structures not only to solve a single instance but also
    to solve problems by combining multiple control structures to build complex logic.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: After reading this section, you should have a basic knowledge of what control
    structures exist and how to use them.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cmdlets and functions both follow the schema *verb-noun*, such as **Get-Help**
    or **Stop-Process**. So, if you write your own functions or cmdlets, make sure
    to follow the name guidelines and recommendations.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft has released a list of approved verbs. Although it is not technically
    enforced to use approved verbs, it is strongly recommended to do so in order to
    comply with PowerShell best practices and avoid conflicts with automatic variables
    and reserved words. Additionally, using approved verbs is required when publishing
    PowerShell modules to the PowerShell Gallery, as it will trigger a warning message
    if non-approved verbs are used. Here is the link for the approved verbs:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/approved-verbs-for-windows-powershell-commands)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: Finding the approved verbs
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: If you are in the process of writing your code and quickly want to check which
    approved verbs exist, you can leverage the **Get-Verb** command.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to sort the list of available verbs, you can pipe the output to
    **Sort-Object**. By default, the verbs are sorted into traditional categories
    of use, such as **Common**, **Data**, and **Lifecycle**. However, you can also
    sort them alphabetically by name by specifying the **Name** property with the
    **Sort-Object** command. Use the following command to sort the output of **Get-Verb**
    by the name **Verb**:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'You can also use wildcards to prefilter the list:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'If you just want to get all approved verbs from a certain group (in this case,
    **Security**), you can filter **Group** using **Where-Object**:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Although naming conventions are not enforced in PowerShell, they should be respected
    nevertheless. Microsoft also strongly encourages following those guidelines when
    writing your cmdlets to ensure that users have a consistent user experience.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'Please also have a look at the development guidelines when writing your own
    functions and cmdlets: https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/strongly-encouraged-development-guidelines.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell profiles
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell profiles are configuration files that allow you to personalize your
    PowerShell environment. These profiles can be used to customize the behavior and
    environment of PowerShell sessions. They are scripts that are executed when a
    PowerShell session is started, allowing users to set variables, define functions,
    create aliases, and more.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Any variables, functions, or aliases defined in the appropriate PowerShell profile
    will be loaded every time a PowerShell session is started. This means you can
    have a consistent and personalized PowerShell environment across all your sessions.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several different types of profiles and more than one can be processed
    by PowerShell. PowerShell profiles are stored as plain text files on your system,
    and there are several types of profiles available:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '**All Users, All Hosts** (**$profile.AllUsersAllHosts**): This profile applies
    to all users for all PowerShell hosts.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All Users, Current Host** (**$profile.AllUsersCurrentHost**): This profile
    applies to all users for the current PowerShell host.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current User, All Hosts** (**$profile.CurrentUserAllHosts**): This profile
    applies to the current user for all PowerShell hosts.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current User, Current Host** (**$profile.CurrentUserCurrentHost**): This
    profile applies only to the current user and the current PowerShell host.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **PowerShell host** is an application that hosts the PowerShell engine. Examples
    of PowerShell hosts include the Windows PowerShell console, the PowerShell **Integrated
    Scripting Environment** (**ISE**), and the PowerShell terminal in Visual Studio
    Code.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'The location of your PowerShell profile(s) depends on your system and configuration,
    but you can easily find out where they are stored by running the following command
    in PowerShell:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Finding out the location of the local PowerShell profile(s)](image/B16679_02_004.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Finding out the location of the local PowerShell profile(s)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that there are also more profile paths available, including
    those used by the system and not just by individual users (which would be included
    in the **AllUsers** profile):'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'Applies to local shells and all users: **%windir%\system32\WindowsPowerShell\v1.0\profile.ps1**'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applies to all shells and all users: **%windir%\system32\WindowsPowerShell\v1.0\Microsoft.PowerShell_profile.ps1**'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Applies to all local ISE shells and all users: **%windir%\system32\WindowsPowerShell\v1.0\Microsoft.PowerShellISE_profile.ps1**'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This profile is loaded when using the PowerShell ISE and can be viewed by running
    the **$profile | fl * -force** command within the ISE
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Applies to current user ISE shells on the local host: **%UserProfile%\Documents\WindowsPowerShell\Microsoft.PowerShellISE_profile.ps1**'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, in Windows PowerShell, there are profiles for **AllUsers** and
    **AllHosts**, which apply to all users and all PowerShell hosts on a system. In
    PowerShell Core, there are profiles for **AllUsers** and **AllHosts** as well,
    but they do not load the Windows PowerShell profiles from the **system32** directory
    by default. It’s also worth noting that while PowerShell Core supports loading
    Windows PowerShell profiles, the reverse is not true.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the file path of one particular profile, such as the one for **CurrentUserCurrentHost**,
    you can use the variable that is defined in **$profile.CurrentUserCurrentHost**:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Use the following code snippet to check whether the file already exists; if
    it does not yet, the file is created:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Finally, add the commands, functions, or aliases to the user profile:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: In addition to customizing your PowerShell environment, profiles are also a
    crucial aspect of PowerShell security. By modifying your profiles, you can set
    policies and restrictions to enforce security best practices, such as preventing
    the execution of unsigned scripts or setting execution policies. But also, adversaries
    can use PowerShell profiles to their advantage – for example, to establish persistence.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PSDrives in PowerShell
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell includes a feature called **PowerShell drives** (**PSDrives**). PSDrives
    in PowerShell are similar to filesystem drives in Windows, but instead of accessing
    files and folders, you use PSDrives to access a variety of data stores. These
    data stores can include directories, registry keys, and other data sources, which
    can be accessed through a consistent and familiar interface.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: PSDrives are powered by **PSProviders**, which are the underlying components
    that provide access to data stores. PSProviders are similar to drivers in Windows,
    which allow access to different hardware devices. In the case of PowerShell, PSProviders
    allow you to access different data stores in a uniform way, using the same set
    of cmdlets and syntax.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the **Env:\** PSDrive is a built-in PowerShell drive that provides
    access to environment variables. To retrieve all environment variables that have
    the **path** string in their name, you can use the **Get-ChildItem** cmdlet with
    the **Env:\** PSDrive:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: To access a PSDrive, you use a special prefix in the path. For example, to access
    the filesystem drive, you use the prefix **C:**, and to access the registry drive,
    you use the prefix **HKLM:**. In the case of the **Env:\** PSDrive, the prefix
    is **Env:**, which allows you to access environment variables as if they were
    files or folders.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several built-in PSDrives in PowerShell, including the following:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '**Alias**: Provides access to PowerShell aliases'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment**: Provides access to environment variables'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function**: Provides access to PowerShell functions'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variable**: Provides access to PowerShell variables'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cert**: Provides access to certificates in the Windows certificate store'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cert:\CurrentUser**: Provides access to certificates in the current user’s
    certificate store'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cert:\LocalMachine**: Provides access to certificates in the local machine’s
    certificate store'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WSMan**: Provides access to **Windows Remote Management** (**WinRM**) configuration
    data'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C:** and **D:** (*and other drive letters*): Used to access the filesystem,
    just like in Windows Explorer'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HKCU**: Provides access to the **HKEY_CURRENT_USER** registry hive'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HKLM**: Provides access to the **HKEY_LOCAL_MACHINE** registry hive'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your code reusable
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the concept of making your code reusable in
    PowerShell. Reusability is an important aspect of coding that allows you to create
    a function, cmdlet, or module once and use it multiple times without having to
    rewrite the same code again and again. Through this, you can save time and effort
    in the long run.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: We will start by discussing cmdlets, followed by functions and aliases, and
    finally, we will explore PowerShell modules, which are collections of PowerShell
    commands and functions that can be easily shared and installed on other systems,
    which is a great way to package and distribute your reusable code.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Cmdlets
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cmdlet (pronounced as *commandlet*) is a type of PowerShell command that performs
    a specific task and can be written in C# or in another .NET language. This includes
    advanced functions, which are also considered cmdlets but have more advanced features
    than regular functions.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '**Get-Command** can help you to differentiate cmdlets from functions. Additionally,
    you can also see the version and the provider:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'To find out all cmdlets that are currently installed on the machine you are
    using, you can leverage **Get-Command** with the **CommandType** parameter:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'If you want to dig deeper into cmdlets, I recommend reviewing the official
    PowerShell documentation. Microsoft has published a lot of advice, as well as
    recommendations and guidelines:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview)'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/windows-powershell-cmdlet-concepts](https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/windows-powershell-cmdlet-concepts)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are a collection of PowerShell commands that should be run following
    a certain logic.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: As with other programming and scripting languages, if you are typing in the
    same commands over and over again, and if you find yourself modifying the same
    one-liners for different scenarios, it is definitely time to create a function.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: When you choose a name, make sure it follows the verb-noun naming convention
    and only uses approved verbs. Read more about approved verbs and naming conventions
    in the *Naming conventions* section covered earlier in this chapter.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'This skeleton function using pseudocode should demonstrate the basic structure
    of a function:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Once the function is loaded into the session, it needs to be called so that
    it will be executed:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'You can find a demo function with demo help that simply writes the output **Hello
    World!** and accepts a parameter to generate additional output, as well as the
    calling of it on GitHub:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Write-HelloWorld.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Write-HelloWorld.ps1)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function does not necessarily need to support parameters, but if you want
    to process input within the function, parameters are required:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: In this example, the **Invoke-Greeting** function provides the possibility to
    supply the **$Name** parameter, while specifying the data type as **[string]**
    will attempt to convert any input to a *string*, allowing for flexibility in the
    parameter input. You can also use other data types (for example, **int**, **boolean**,
    and so on) depending on your use case.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'If the parameter is specified, the provided value is stored in the **$Name**
    variable and can be used within the function:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'If the parameter is not specified, it will be replaced by **$null** (which
    is **""**/*nothing*):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: In this case, the **$Name** parameter is not mandatory, so it does not have
    to be specified to run the function.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Adding parameters enables you to cover many of your use case’s complex scenarios.
    You might have already seen functions that allow only some type of input or that
    require a certain parameter – functions that will not be run until the user confirms
    and functions that provide the possibility to run them verbosely.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how these behaviors can be configured in our next sections about
    **cmdletbinding**, **SupportsShouldProcess**, input validation, and mandatory
    parameters.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: cmdletbinding
  id: totrans-479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**cmdletbinding** is a feature in PowerShell that allows you to add common
    parameters (such as **-Verbose**, **-Debug**, or **-ErrorAction**) to your functions
    and cmdlets without defining them yourself. This can make your code more consistent
    with other PowerShell commands and easier to use for users.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to use **cmdletbinding** is to declare a parameter as mandatory, positional,
    or in a parameter set, which can automatically turn your function into a cmdlet
    with additional common parameters. For example, if you want to make the **-Name**
    parameter mandatory in your function, you can add **[Parameter(Mandatory)]** before
    the parameter definition, like this:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: This will automatically add the **[<CommonParameters >]** section to the output
    of **Get-Command**, and you will see all the common parameters that are also available
    in many other cmdlets, such as **Verbose**, **Debug**, **ErrorAction**, and others.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about **cmdletbinding** and its functionality, check out the
    following link: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_cmdletbindingattribute).'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: SupportsShouldProcess
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a function makes changes, you can use **SupportsShouldProcess** to add an
    additional layer of protection to your function. By adding **[CmdletBinding(SupportsShouldProcess)]**,
    you can enable the **-WhatIf** and **-Confirm** parameters in your function, which
    help users understand the effect of their actions before executing the function.
    To use **SupportsShouldProcess** effectively, you will also need to call **ShouldProcess()**
    for each item being processed. Here’s an example of what your code could look
    like:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: With this code, the function can be executed with the **-Confirm** parameter
    to prompt the user for confirmation before processing each item, or with the **-WhatIf**
    parameter to display a list of changes that would be made without actually processing
    the items.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Once you have added **SupportsShouldProcess** to your function, you can also
    see that the syntax has changed, by using **Get-Command** as shown in the preceding
    example.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Accepting input via the pipeline
  id: totrans-491
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is also possible to configure parameters to accept user input to use it
    in our code. In addition to accepting input from the user, we can also accept
    input from the pipeline. This can be done in two ways: by value or by property
    name.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: When accepting input by value, we receive the entire object passed through the
    pipeline. We can then use the parameter in our function to filter or manipulate
    the object.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: When accepting input by property name, we receive only the specified property
    of the object passed through the pipeline. This can be useful when we only need
    to work with a specific property of the object.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: To configure a function to accept input by value, we can use **ValueFromPipeline**;
    to accept input by property name use **ValueFromPipelineByPropertyName**. Of course,
    both can be combined with each other and with other parameter options as well,
    such as **Mandatory**.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the **Invoke-Greeting** function, which accepts
    input both by value and property name for its mandatory **$****Name** parameter:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'You can now pass input by value to this function, as shown in the following
    example:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'But it also works to pass input by property name, as the following code snippet
    demonstrates:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'If you want to dive deeper into accepting input from the pipeline and how to
    troubleshoot issues, you may refer to the following resources:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '*PowerShell Basics for Security Professionals Part 6 – Pipeline* by Carlos
    Perez: [https://youtube.com/watch?v=P3ST3lat9bs](https://youtube.com/watch?v=P3ST3lat9bs'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '*About* *Pipelines*: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_pipelines](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_pipelines)'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As this book focuses on PowerShell security and not on expert function creation,
    it can barely scratch the surface of advanced functions. So, if you are interested
    in learning more about advanced functions and parameters, I have added some links
    in the *Further reading* section at the end of this chapter.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Comment-based help
  id: totrans-507
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Writing comment-based help for your functions is crucial; others might reuse
    your function or if you want to adjust or reuse the function yourself some months
    after you wrote it, having good comment-based help will simplify the usage:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Please also have a look at the **Write-HelloWorld.ps1** demo script on GitHub
    to see an example: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Write-HelloWorld.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Write-HelloWorld.ps1).'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are not sure whether your command will succeed, use **try** and **catch**:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Setting **ErrorAction** to **Stop** will treat the error as a terminating error.
    As only terminating errors are caught, the action defined in the **catch** block
    is triggered.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: If **ErrorAction** is not defined and if no terminating error is triggered,
    the **catch** block will be ignored.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: The difference between cmdlets and script cmdlets (advanced functions)
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When I heard for the first time about cmdlets and advanced functions, I was
    like *Okay great, but what’s the difference? They both sound* *pretty alike*.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: One significant difference is that cmdlets can be written in a .NET language
    such as C# and reside within a compiled binary. Script cmdlets, also known as
    advanced functions, are similar to cmdlets, but they are written in PowerShell
    script rather than a .NET language. Script cmdlets are a way to create custom
    cmdlets using PowerShell script instead of compiling code in a .NET language.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of script cmdlets is that they can be easily modified and debugged
    without requiring compilation, making them more accessible to users who may not
    be comfortable with .NET languages. Additionally, script cmdlets can be distributed
    and shared just like compiled cmdlets.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: For software vendors and developers, it is easier to package compiled cmdlets
    than to package libraries of functions and scripts, as well as to write and package
    help files.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: However, it is just a matter of preference what you want to use – if you prefer
    writing your functions in C# or other .NET-based languages, cmdlets might be your
    preferred choice; if you prefer using PowerShell only, you might want to create
    PowerShell functions.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Aliases
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alias is some kind of a nickname for a PowerShell command, an alternate name.
    You can set aliases to make your daily work easier – for example, if you are repeatedly
    working with the same long and complicated command, setting an alias and using
    it instead will ease your daily work.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, one of the most used aliases is the famous **cd** command, which
    administrators use to change the directory on the command line. But **cd** is
    only an alias for the **Set-Location** cmdlet:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'To see all available cmdlets that have the word **Alias** in their name, you
    can leverage **Get-Command**:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Getting all available cmdlets that have the word Alias in their
    name](image/B16679_02_005.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Getting all available cmdlets that have the word Alias in their
    name
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s have a closer look at how to work with aliases, using the **Get-Alias**,
    **New-Alias**, **Set-Alias**, **Export-Alias**, and **Import-Alias** cmdlets.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Get-Alias
  id: totrans-530
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see all aliases that are currently configured on the computer you are working
    on, use the **Get-Alias** cmdlet:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Output of the Get-Alias command](image/B16679_02_006.jpg)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Output of the Get-Alias command
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: You can either use **Get-Alias** to inspect the entire list of aliases that
    are available, or you can check whether a specific alias exists using the **-****Name**
    parameter.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: New-Alias
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use **New-Alias** to create a new alias within the current PowerShell
    session:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: This alias is not set permanently, so once you exit the session, the alias will
    not be available anymore.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: If you want to use aliases multiple times in multiple sessions, you can either
    export them and import them in every new session or you can configure them to
    be permanently set for every new PowerShell session by using the PowerShell profile.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: If you want to add parameters to the command that your alias runs, you can create
    a function and use **New-Alias** to link the new function to your existing command.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Set-Alias
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Set-Alias** can be used to either create or change an alias.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'So if you want to change, for example, the content of the formerly created
    **Get-Ip** alias to **Get-NetIPAddress**, you would run the following command:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Export-Alias
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Export one or more aliases with **Export-Alias** – either as a **.csv** file
    or as a script:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Using this command, we first export all aliases to a **.****csv** file:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'The **-As Script** parameter allows you to execute all currently available
    aliases as a script that can be executed:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: If you plan to re-import the aliases later, it’s important to be aware that
    executing the script without re-importing the function may cause issues. Therefore,
    make sure to also import the script on the new system on which you plan to import
    the alias.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is also possible to only export a single alias by specifying its
    **-Name** parameter, in the last example.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: alias.csv
  id: totrans-554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **alias.csv** file that we created using the **Export-Alias** command can
    now be reused to create or import all aliases of this session in another session:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: alias.ps1
  id: totrans-557
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you export your aliases using the **-As Script** option (as in the example
    from earlier), an executable **.ps1** file (**alias.ps1**) is created.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now use the file to set your aliases automatically whenever you run
    the **.ps1** script, or you can use the code to edit your profile file (see **New-Alias**)
    to configure permanent aliases:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: If you use functions to define aliases, make sure to also save those functions
    and execute them in the session in which you want to import your aliases.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Import-Alias
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use **Import-Alias** to import aliases that were exported as **.csv**:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Import the file to make the alias available in your current session:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Further information on aliases can be found at the following link: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_aliases](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_aliases).'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modules are a collection of PowerShell commands and functions that can be easily
    shipped and installed on other systems. They are a great way to enrich your sessions
    with other functionalities.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Find Module-Related Cmdlets
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: 'To find module-related cmdlets, leverage **Get-Command** and have a look at
    their help pages and the official documentation to understand their function:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '**Get-Command -****Name "*Module*"**'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: 'All modules that are installed on the system can be found in one of the **PSModulePath**
    folders, which are part of the **Env:\** PSDrive:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Query the content with **Env:\PSModulePath** to find out which paths were set
    on your system.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Working with modules
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use a module efficiently, the following sections will help you to make the
    module available, to find out how to work with it, and to finally remove or unload
    it.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Finding and installing modules
  id: totrans-578
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To search for a certain module in a repository, you can leverage **Find-Module
    -Name <modulename>**. It queries the repositories that are configured on your
    operating system:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Once you have found the desired module, you can download and install it to
    your local system using **Install-Module**:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'If you have already installed a module for which a newer version exists, update
    it with **Update-Module**:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'To see which repositories are available on your system, use the following:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: One of the most commonly used repositories is the **PowerShell Gallery** (shown
    as **PSGallery** in the previous example).
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: The PowerShell Gallery
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The PowerShell Gallery is the central repository for PowerShell content: [https://www.powershellgallery.com/](https://www.powershellgallery.com/).
    In this repository, you''ll find thousands of helpful modules, scripts, and **Desired
    State Configuration** (**DSC**) resources.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: To leverage the PowerShell Gallery and to install modules directly from the
    repository, **NuGet** and **PowerShellGet** need to be installed.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven’t installed the required packages, when you try to install a module
    for the first time from the PowerShell Gallery, you will be prompted to install
    it:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Installing a module from the PowerShell Gallery using Windows
    PowerShell](image/B16679_02_007.jpg)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Installing a module from the PowerShell Gallery using Windows PowerShell
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, you will not only be prompted to
    install the module itself but also the NuGet provider if you are installing modules
    from the PowerShell Gallery for the first time.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using PowerShell Core, both **NuGet** and **PowerShellGet** are
    usually already preinstalled:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Installing a module from the PowerShell Gallery using PowerShell
    Core](image/B16679_02_008.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Installing a module from the PowerShell Gallery using PowerShell
    Core
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: Configure PowerShell Gallery as a Trusted Repository
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: When you install modules from the PowerShell Gallery, you may receive a warning
    that the repository is not trusted. This warning is displayed to ensure that you
    are aware that you are installing code from an external source that has not been
    verified by Microsoft. The warning is intended to protect you from potentially
    malicious code that could harm your system.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid the warning, you can configure the repository as a trusted repository.
    By doing this, you are indicating that you trust the source and that you accept
    the potential risks associated with installing code from it. To configure a repository
    as a trusted repository, you can use the following code snippet: **Set-PSRepository
    -Name ''PSGallery'' -****InstallationPolicy Trusted**.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: By configuring the repository as a trusted repository, you are indicating that
    you trust the code provided by that repository and that you are willing to take
    responsibility for any risks associated with using it.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: Working with modules
  id: totrans-602
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To find out which modules are already available in the current session, you
    can use **Get-Module**:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'To see which modules are available to import, including those that come pre-installed
    with Windows, you can use the **ListAvailable** parameter with the **Get-Module**
    cmdlet. This will display a list of all available modules on the computer, including
    their version numbers, descriptions, and other information:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'Find out which commands are available by using **Get-Command**:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'And if you want to know more about the usage of a command that is available
    in a module, you can use **Get-Help**. You can see how important it is to write
    proper help pages for your function:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Getting the help pages of a command](image/B16679_02_009.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Getting the help pages of a command
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have, for example, an old version loaded in your current session and
    you want to unload it, **Remove-Module** unloads the current module from your
    session:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: When you are developing and testing your own modules, this command is especially
    helpful.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own modules
  id: totrans-615
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make your functions easier to ship to other systems, creating a module is
    a great way. As the description of full-blown modules would exceed the scope of
    this book, I will describe the basics of how to quickly get started.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: 'Please also have a look at the official PowerShell module documentation to
    better understand how modules work and how they should be created: https://docs.microsoft.com/en-us/powershell/scripting/developer/module/writing-a-windows-powershell-module.'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: When working more intensively with PowerShell modules, you might also come across
    many different files, such as files that end with **.psm1**, **.psd1**, **.ps1xml**,
    or **.dll**, help files, localization files, and many others.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: I will not describe all the files that can be used in a module, but I will describe
    the most necessary files – the **.psm1** file and the **.****psd1** file.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: .psm1
  id: totrans-620
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **.psm1** file contains the scripting logic that your module should provide.
    Of course, you can also use it to import other functions within your module.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: .psd1 – the module manifest
  id: totrans-622
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **.psd1** file is the manifest of your module. If you only create a PowerShell
    script module, this file is not mandatory, but it allows you to control your module
    functions and include information about the module.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Developing a basic module
  id: totrans-624
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Creating a basic PowerShell module can be as simple as writing a script containing
    one or more functions, and saving it with a **.psm1** file extension.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the path where the module should be saved in the **$path**
    variable and create the **MyModule** folder if it does not exist yet. We then
    use the **New-ModuleManifest** cmdlet to create a new module manifest file named
    **MyModule.psd1** in the **MyModule** folder. The **-RootModule** parameter specifies
    the name of the PowerShell module file, which is **MyModule.psm1**.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the **Set-Content** cmdlet, we create the **MyModule.psm1** file and
    define the **Invoke-Greeting** function, which we wrote earlier in this chapter:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'When you want to use a module in your PowerShell session, you can either import
    it directly into your session or copy it into one of the **PSModule** paths. To
    ensure that the module is easily accessible for future use, it’s recommended to
    copy it to one of the **PSModule** paths. The **PSModule** paths are directories
    that are searched for modules when you use the **Import-Module** cmdlet. To see
    the **PSModule** paths, you can run the following command:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Once you have determined which **PSModule** path to use, you can copy the module
    directory to that location. After copying the module to the appropriate **PSModule**
    path, you can then import the module using the **Import-Module** cmdlet:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Alternatively, when you are in the development phase, you can import the module
    directly into your session, without having it copied in one of the **PSModule**
    paths, using **Import-Module**:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: By copying the module to a **PSModule** path, you can easily import it into
    any PowerShell session without having to specify the full path to the module.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can call the function that was defined in the **MyModule** module:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Congratulations, you just created and executed your first very own module!
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: 'You can compare your own module with the demo module of this chapter: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter02/MyModule](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter02/MyModule).'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Module Manifest Options
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Have a closer look at the options that are available within the module manifest.
    For example, you can also specify the author, the description, or modules that
    are required to install this module, using the **RequiredModules** hashtable.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'As you become more familiar with module development and want to take your code
    to the next level, you can explore tools such as **PSModuleDevelopment**, which
    can help you with your development tasks, and also with later CI/CD tasks: [https://psframework.org/documentation/documents/psmoduledevelopment.html](https://psframework.org/documentation/documents/psmoduledevelopment.html).'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned the fundamentals of PowerShell scripting.
    After refreshing the basics of variables, operators, and control structures, you
    are able to create your very own scripts, functions, and modules.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are familiar with the PowerShell basics and you are able to work
    with PowerShell on your local system, let’s dive deeper into PowerShell remoting
    and its security considerations in the next chapter.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to explore some of the topics that were mentioned in this chapter,
    check out these resources:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything you want to know about arrays: [https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-arrays](https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-arrays'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything you want to know about hashtables: [https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-hashtable](https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-hashtable'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything you want to know about **$****null**: [https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-null](https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-null'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything you want to know about **PSCustomObject**: [https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-pscustomobject](https://docs.microsoft.com/en-us/powershell/scripting/learn/deep-dives/everything-about-pscustomobject'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 'About functions: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions 101: [https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/09-functions](https://docs.microsoft.com/en-us/powershell/scripting/learn/ps101/09-functions'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: 'About functions’ advanced parameters: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced_parameters'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 'Cmdlets versus functions: [https://www.leeholmes.com/blog/2007/07/24/cmdlets-vs-functions/](https://www.leeholmes.com/blog/2007/07/24/cmdlets-vs-functions/'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules help pages: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_modules'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also find all links mentioned in this chapter in the GitHub repository
    for [*Chapter 2*](B16679_02_Final_PD.xhtml#_idTextAnchor034) – no need to manually
    type in every link: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Links.md](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter02/Links.md)'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
