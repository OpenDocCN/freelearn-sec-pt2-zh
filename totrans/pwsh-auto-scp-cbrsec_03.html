<html><head></head><body>
		<div id="_idContainer081">
			<h1 class="chapter-number" id="_idParaDest-59"><a id="_idTextAnchor064"/>3</h1>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor065"/>Exploring PowerShell Remote Management Technologies and PowerShell Remoting</h1>
			<p>As one of the main purposes of PowerShell is automating administration tasks, <strong class="bold">PowerShell remoting</strong> (<strong class="bold">PSRemoting</strong>) plays<a id="_idIndexMarker400"/> a big part in administrating multiple computers at the same time: using only a single command, you can run the same command line on hundreds <span class="No-Break">of computers.</span></p>
			<p>But similar to when you work with individual computers, PSRemoting is only as secure as your configuration: if you don’t lock the door of your house, burglars can break <span class="No-Break">into it.</span></p>
			<p>And that’s the same case for computers, as well as for PSRemoting: if you don’t harden your configuration and use insecure settings, attackers can leverage that and use your computers <span class="No-Break">against you.</span></p>
			<p>In this chapter, you will not only learn the basics of PSRemoting and how to enable and configure it – you will also discover the best practices for maintaining a secure PSRemoting configuration. While PSRemoting is inherently secure, there are still measures you can take to ensure that your configuration remains secure. We will explore these measures in detail to help you keep your PSRemoting <span class="No-Break">setup secure.</span></p>
			<p>We will also see what PSRemoting network traffic looks like, depending on what authentication protocol is used. Lastly, you will learn how to configure it, what configurations to avoid, and how to use PSRemoting to <span class="No-Break">execute commands.</span></p>
			<p>In this chapter, you will learn about the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Working remotely <span class="No-Break">with PowerShell</span></li>
				<li>Enabling <span class="No-Break">PowerShell remoting</span></li>
				<li>PowerShell endpoints (<span class="No-Break">session configurations)</span></li>
				<li>PowerShell remoting authentication and <span class="No-Break">security considerations</span></li>
				<li>Executing commands using <span class="No-Break">PowerShell remoting</span></li>
				<li>Working with <span class="No-Break">PowerShell remoting</span></li>
				<li>PowerShell remoting <span class="No-Break">best practices</span></li>
			</ul>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor066"/>Technical requirements</h1>
			<p>The following are the technical requirements for <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>PowerShell 7.3 <span class="No-Break">and above</span></li>
				<li>Visual <span class="No-Break">Studio Code</span></li>
				<li><span class="No-Break">Wireshark</span></li>
				<li>A test lab with a domain controller and one or more <span class="No-Break">test machines</span></li>
				<li>Access to the GitHub repository for <span class="No-Break"><strong class="source-inline">Chapter03</strong></span><span class="No-Break">: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter03</span></a><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/tree/master/Chapter03&#13;"/></li>
			</ul>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor067"/>Working remotely with PowerShell</h1>
			<p>PowerShell <a id="_idIndexMarker401"/>was designed to automate administration tasks and simplify the lives of system administrators. Remote management was a part of this plan from the very beginning, as outlined by Jeffrey Snover in the Monad Manifesto from 2002: <a href="https://www.jsnover.com/blog/2011/10/01/monad-manifesto/">https://www.jsnover.com/blog/2011/10/01/monad-manifesto/</a>. However, to ship version 1.0 promptly, some features, including PSRemoting, were not included until later versions. PSRemoting was officially introduced in version 2.0 and further improved in <span class="No-Break">version 3.0.</span></p>
			<p>It quickly became one of the most important core functionalities and nowadays supports many other functions within PowerShell, such <span class="No-Break">as workflows.</span></p>
			<p>While PSRemoting can work with a variety of authentication methods, the default protocol for domain authentication is Kerberos. This is the most secure and commonly used method of authentication in Active Directory environments, which is where most people using PSRemoting are likely to be operating. So, when Kerberos is not available, PSRemoting will fall back to NTLM to also support <span class="No-Break">workgroup authentication.</span></p>
			<p>Windows PowerShell <a id="_idIndexMarker402"/>supports remoting over different technologies. By default, PSRemoting <a id="_idIndexMarker403"/>uses <strong class="bold">Windows Remote Management (WinRM)</strong> as its transport protocol. However, it’s important to note that WinRM is just one of several protocols that can be used to support remote management in PowerShell. PSRemoting itself is a specific protocol (<strong class="bold">PSRP</strong>) that governs the way that PowerShell manages input, output, data streams, object serialization, and<a id="_idIndexMarker404"/> more. PSRP can be supported over a <a id="_idIndexMarker405"/>variety of transports, including <strong class="bold">WS-Management (WS-Man)</strong>, <strong class="bold">Secure Shell (SSH)</strong>, <strong class="bold">Hyper-V VMBus</strong>, and <a id="_idIndexMarker406"/>others. While <strong class="bold">Windows Management Instrumentation (WMI)</strong> and <strong class="bold">Remote Procedure Call (RPC)</strong> are<a id="_idIndexMarker407"/> remote management technologies that <a id="_idIndexMarker408"/>can be used with PowerShell, they are not considered part of the <span class="No-Break">PSRemoting protocol.</span></p>
			<p>This difference between those remote management technologies is also reflected in the protocol that’s <span class="No-Break">being used:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer052">
					<img alt="Table 3.1 – Overview of connection methods and protocols used" src="image/B16679_03_Table_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.1 – Overview of connection methods and protocols used</p>
			<p>PSRemoting is only enabled in Windows Server 2012 R2 and above and only connections from members of the Administrators group are allowed by default. However, PowerShell Core provides support for several remote management protocols, including WMI, Web-Services Management (WS-Management), and SSH remoting. It’s important to note that PowerShell Core doesn’t support <span class="No-Break">RPC connections.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor068"/>PowerShell remoting using WinRM</h2>
			<p><strong class="bold">DMTF</strong> (formerly known as the <strong class="bold">Distributed Management Task Force</strong>) is <a id="_idIndexMarker409"/>a non-profit <a id="_idIndexMarker410"/>organization that defines open manageability standards, such as the Common Information Model (CIM), and <span class="No-Break">also WS-Management.</span></p>
			<p>WS-Management<a id="_idIndexMarker411"/> defines a <strong class="bold">Simple Object Access Protocol</strong> (<strong class="bold">SOAP</strong>)-based protocol that can be used to manage servers and <span class="No-Break">web services.</span></p>
			<p>Microsoft’s implementation of <a id="_idIndexMarker412"/>WS-Management <span class="No-Break">is </span><span class="No-Break"><strong class="bold">WinRM</strong></span><span class="No-Break">.</span></p>
			<p>As soon as you attempt to establish a PSRemoting connection, the WinRM client sends SOAP messages within the WS-Management protocol over <strong class="bold">HTTP</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="bold">HTTPS</strong></span><span class="No-Break">.</span></p>
			<p>PSRemoting, when <a id="_idIndexMarker413"/>using <a id="_idIndexMarker414"/>WinRM, listens on the <span class="No-Break">following ports:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">HTTP</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">5985</strong></span></li>
				<li><span class="No-Break"><strong class="bold">HTTPS</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">5986</strong></span></li>
			</ul>
			<p>Regardless<a id="_idIndexMarker415"/> of whether HTTP or HTTPS is used, PSRemoting traffic is always encrypted after the authentication process – depending on which protocol is used for authentication. You can read more about the different authentication protocols in the <span class="No-Break"><em class="italic">Authentication</em></span><span class="No-Break"> section.</span></p>
			<p>On the remote host, the <a id="_idIndexMarker416"/>WinRM service runs and is configured to have one or more listeners (HTTP or HTTPS). Each listener waits for incoming HTTP/HTTPS traffic sent through the <span class="No-Break">WS-Management protocol.</span></p>
			<p>Once traffic is received, the WinRM service determines which PowerShell endpoint or application the traffic is meant for and <span class="No-Break">forwards it:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer053">
					<img alt="Figure 3.1 – How WinRM and WS-Management are used to connect via PSRemoting" src="image/B16679_03_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – How WinRM and WS-Management are used to connect via PSRemoting</p>
			<p>In general, this <a id="_idIndexMarker417"/>diagram has been abstracted to simplify your understanding of how WinRM works. <strong class="source-inline">PowerShell.exe</strong> is not called; instead, the <strong class="source-inline">Wsmprovhost.exe</strong> process is, which runs <span class="No-Break">PSRemoting connections.</span></p>
			<p>As WinRM and WS-Management are the default when establishing remote connections, this chapter will mostly focus on those technologies. But for completeness, I will shortly introduce all other possible remoting technologies in <span class="No-Break">this section.</span></p>
			<p>If you<a id="_idIndexMarker418"/> would like to learn about WinRM and WS-Management in more depth, I recommend visiting the <span class="No-Break">following sources:</span></p>
			<ul>
				<li><a href="https://docs.microsoft.com/en-us/windows/win32/winrm/windows-remote-management-architecture"><span class="No-Break">https://docs.microsoft.com/en-us/windows/win32/winrm/windows-remote-management-architecture</span></a></li>
				<li><a href="https://github.com/devops-collective-inc/secrets-of-powershell-remoting"><span class="No-Break">https://github.com/devops-collective-inc/secrets-of-powershell-remoting</span></a></li>
			</ul>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor069"/>Windows Management Instrumentation (WMI) and Common Information Model (CIM)</h2>
			<p><strong class="bold">WMI</strong> is <a id="_idIndexMarker419"/>Microsoft’s implementation of CIM, an<a id="_idIndexMarker420"/> open standard designed <span class="No-Break">by DMTF.</span></p>
			<p>WMI <a id="_idIndexMarker421"/>was<a id="_idIndexMarker422"/> introduced with Windows NT 4.0 and was included in the Windows operating system starting with Windows 2000. It is still present in all modern systems, including Windows 10 and Windows <span class="No-Break">Server 2019.</span></p>
			<p>CIM defines<a id="_idIndexMarker423"/> how IT <a id="_idIndexMarker424"/>system elements are represented as objects and how they relate to each other. This should offer a good way to manage IT systems, regardless of the manufacturer <span class="No-Break">or platform.</span></p>
			<p>WMI relies<a id="_idIndexMarker425"/> on the <strong class="bold">Distributed Component Object Model</strong> (<strong class="bold">DCOM</strong>) and<a id="_idIndexMarker426"/> RPC, which is the underlying mechanism behind DCOM, <span class="No-Break">to communicate.</span></p>
			<p>DCOM was created to let <a id="_idIndexMarker427"/>the <strong class="bold">Component Object Model</strong> (<strong class="bold">COM</strong>) communicate over the network and is the predecessor of .<span class="No-Break">NET Remoting.</span></p>
			<p>This section will give you only a basic overview of the WMI and CIM cmdlets to fulfill your understanding of the remote management technologies in this chapter. You will learn more about COM, WMI, and CIM in <a href="B16679_05_Final_PD.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">PowerShell Is Powerful – System and </em><span class="No-Break"><em class="italic">API Access</em></span><span class="No-Break">.</span></p>
			<h3>WMI cmdlets</h3>
			<p>WMI <a id="_idIndexMarker428"/>cmdlets<a id="_idIndexMarker429"/> were deprecated starting with PowerShell Core 6 and should not be used in newer versions of PowerShell. However, it’s important to note that they are still supported in certain older versions of PowerShell, such as PowerShell 5.1 on Windows 10, and will continue to be supported for the support life of those operating systems. If possible, use the newer CIM cmdlets instead, since they can be used on Windows and non-Windows <span class="No-Break">operating systems.</span></p>
			<p>First, let’s have a look at how to work with the deprecated, but still present, <span class="No-Break">WMI cmdlets.</span></p>
			<p>To find all the cmdlets and functions that have the <strong class="source-inline">wmi</strong> string included in their name, leverage the <strong class="source-inline">Get-Command</strong> cmdlet. With the <strong class="source-inline">-CommandType</strong> parameter, you can specify what kind of commands you want to look for. In this example, I am searching for cmdlets <span class="No-Break">and functions:</span></p>
			<pre class="source-code">
&gt; Get-Command -Name *wmi* -CommandType Cmdlet,Function
CommandType  Name               Version    Source
-----------  ----               -------    ------
Cmdlet       Get-WmiObject      3.1.0.0    Microsoft.PowerShell.Management
Cmdlet       Invoke-WmiMethod   3.1.0.0    Microsoft.PowerShell.Management
Cmdlet       Register-WmiEvent  3.1.0.0    Microsoft.PowerShell.Management
Cmdlet       Remove-WmiObject   3.1.0.0    Microsoft.PowerShell.Management
Cmdlet       Set-WmiInstance    3.1.0.0    Microsoft.PowerShell.Management</pre>
			<p>An example <a id="_idIndexMarker430"/>of how to work with WMI is via the <strong class="source-inline">Get-WmiObject</strong> cmdlet. Using this cmdlet, you can query local and <span class="No-Break">remote computers.</span></p>
			<p>You can use <a id="_idIndexMarker431"/>the <strong class="source-inline">-List</strong> parameter to retrieve all available WMI classes on <span class="No-Break">your computer:</span></p>
			<pre class="source-code">
&gt; Get-WmiObject -List
   NameSpace: ROOT\cimv2
Name                  Methods Properties
----                  ------- ----------
CIM_Indication        {}      {CorrelatedIndications, IndicationFilterName, IndicationIde...
CIM_ClassIndication   {}      {ClassDefinition, CorrelatedIndications, IndicationFilterNa...
CIM_ClassDeletion     {}      {ClassDefinition, CorrelatedIndications, IndicationFilterNa...
...</pre>
			<p>Here’s an<a id="_idIndexMarker432"/> example of how to use <strong class="source-inline">Get-WmiObject</strong> to retrieve information about Windows services on your <span class="No-Break">local computer:</span></p>
			<pre class="source-code">
&gt; Get-WmiObject -Class Win32_Service
ExitCode  : 0
Name      : AdobeARMservice
ProcessId : 3556
StartMode : Auto
State     : Running
Status    : OK
…</pre>
			<p>Not only<a id="_idIndexMarker433"/> can you query your local computer, but you can also query a remote computer by using the <strong class="source-inline">-ComputerName</strong> parameter, followed by the name of the remote computer. The following example shows how to retrieve the same information from the <strong class="source-inline">PSSec-PC02</strong> <span class="No-Break">remote computer:</span></p>
			<pre class="source-code">
&gt; Get-WmiObject -Class Win32_Service -ComputerName PSSec-PC02</pre>
			<p>The preceding code returns a list of all services that are available on the <span class="No-Break">remote computer.</span></p>
			<p>By using the <strong class="source-inline">-Query</strong> parameter, you can even specify the query that should be run against the CIM database of the specified computer. The following command only retrieves all services with the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">WinRM</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-WmiObject -ComputerName PSSec-PC02 -Query "select * from win32_service where name='WinRM'"
ExitCode  : 0
Name      : WinRM
ProcessId : 6408
StartMode : Auto
State     : Running
Status    : OK</pre>
			<p>In this example, we<a id="_idIndexMarker434"/> run the specified <strong class="source-inline">select * from win32_service where name='WinRM'</strong> query remotely <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">PSSec-PC02</strong></span><span class="No-Break">.</span></p>
			<p>Using <a id="_idIndexMarker435"/>PowerShell WMI cmdlets, you can also call WMI methods, delete objects, and <span class="No-Break">much more.</span></p>
			<p class="callout-heading">Did you know?</p>
			<p class="callout">RPC, on which WMI relies, is no longer supported in PowerShell Core 6. This is due in part to PowerShell’s goal of cross-platform compatibility: from PowerShell version 7 and above, RPC is only supported on machines running the Windows <span class="No-Break">operating system.</span></p>
			<h3>CIM cmdlets</h3>
			<p>With <a id="_idIndexMarker436"/>PowerShell 3.0, which came <a id="_idIndexMarker437"/>with Windows Server 2012 and Windows 8, a new set of cmdlets were introduced to manage objects that were compliant with the CIM and <span class="No-Break">WS-Man standards.</span></p>
			<p>At some point, the WMI cmdlets drifted away from the DMTF standards, which prevented cross-platform management. So, Microsoft moved back to being compliant with the DMTF CIM standards by publishing the new <span class="No-Break">CIM cmdlets.</span></p>
			<p>To find out all CIM-related cmdlets, you can leverage the <span class="No-Break"><strong class="source-inline">Get-Command</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; Get-Command -Name "*cim*" -CommandType Cmdlet,Function
CommandType     Name                        Version    Source
-----------     ----                        -------    ------
Cmdlet          Get-CimAssociatedInstance   1.0.0.0    CimCmdlets
Cmdlet          Get-CimClass                1.0.0.0    CimCmdlets
Cmdlet          Get-CimInstance             1.0.0.0    CimCmdlets
Cmdlet          Get-CimSession              1.0.0.0    CimCmdlets
Cmdlet          Invoke-CimMethod            1.0.0.0    CimCmdlets
Cmdlet          New-CimInstance             1.0.0.0    CimCmdlets
Cmdlet          New-CimSession              1.0.0.0    CimCmdlets
Cmdlet          New-CimSessionOption        1.0.0.0    CimCmdlets
Cmdlet          Register-CimIndicationEvent 1.0.0.0    CimCmdlets
Cmdlet          Remove-CimInstance          1.0.0.0    CimCmdlets
Cmdlet          Remove-CimSession           1.0.0.0    CimCmdlets
Cmdlet          Set-CimInstance             1.0.0.0    CimCmdlets</pre>
			<p>In this<a id="_idIndexMarker438"/> example, we are looking for all cmdlets<a id="_idIndexMarker439"/> and functions that have <strong class="source-inline">cim</strong> in <span class="No-Break">their name.</span></p>
			<p>You can find an overview of all the currently available CIM cmdlets to interact with the CIM servers <span class="No-Break">at </span><a href="https://docs.microsoft.com/de-de/powershell/module/cimcmdlets/"><span class="No-Break">https://docs.microsoft.com/de-de/powershell/module/cimcmdlets/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor070"/>Open Management Infrastructure (OMI)</h2>
			<p>To <a id="_idIndexMarker440"/>help <a id="_idIndexMarker441"/>with a cross-platform managing approach, Microsoft created the <strong class="bold">Open Management Infrastructure</strong> (<strong class="bold">OMI</strong>) in 2012 (https://github.com/Microsoft/omi), but it never really became that popular and isn’t used broadly anymore. Therefore, Microsoft decided to add support for <span class="No-Break">SSH remoting.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor071"/>PowerShell remoting using SSH</h2>
			<p>To <a id="_idIndexMarker442"/>enable PSRemoting between Windows and Linux hosts, Microsoft added support for PSRemoting <a id="_idIndexMarker443"/>over <strong class="bold">SSH</strong> with <span class="No-Break">PowerShell 6.</span></p>
			<p class="callout-heading">PSRemoting via SSH requirements</p>
			<p class="callout">To use PSRemoting via SSH, <em class="italic">PowerShell version 6 or above</em> and <em class="italic">SSH</em> need to be installed on all computers. Starting from Windows 10 version 1809 and Windows Server 2019, OpenSSH for Windows was integrated into the Windows <span class="No-Break">operating system.</span></p>
			<h3>PowerShell remoting on Linux</h3>
			<p>As a<a id="_idIndexMarker444"/> first step, to use PowerShell on Linux, install PowerShell Core by following the steps for your operating system, which you can find in the official PowerShell Core <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux</span></a><span class="No-Break">.</span></p>
			<p>In my demo lab, I have a Debian 10 server installed. So, the steps may vary, depending on the operating system that <span class="No-Break">is used.</span></p>
			<p>Configure <strong class="source-inline">/etc/ssh/sshd_config</strong> with the editor of your choice. In my example, I am <span class="No-Break">using </span><span class="No-Break"><strong class="bold">vi</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; vi /etc/ssh/sshd_config</pre>
			<p>First, add a PowerShell subsystem entry to <span class="No-Break">your configuration:</span></p>
			<pre class="source-code">
Subsystem powershell /usr/bin/pwsh -sshs -NoLogo</pre>
			<p>In Linux systems, the PowerShell executable is typically located at <strong class="source-inline">/usr/bin/pwsh</strong> by default. Please make sure you adjust this part if you installed PowerShell in a <span class="No-Break">different location.</span></p>
			<p>To allow users to log on remotely using SSH, configure <strong class="source-inline">PasswordAuthentication</strong> <span class="No-Break">and/or </span><span class="No-Break"><strong class="source-inline">PubkeyAuthentication</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>If you want to allow authentication using a username and a password, set <strong class="source-inline">PasswordAuthentication</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">yes</strong></span><span class="No-Break">:</span><pre class="source-code">
PasswordAuthentication yes</pre></li>
				<li>If you want to enable a more secure method, set <strong class="source-inline">PubkeyAuthentication</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">yes</strong></span><span class="No-Break">:</span><pre class="source-code">
PubkeyAuthentication yes</pre></li>
			</ul>
			<p><strong class="source-inline">PubkeyAuthentication</strong>, which <a id="_idIndexMarker445"/>stands for <strong class="bold">public key authentication</strong>, is a method of authentication that relies on a generated key pair: a private and a public key is generated. While the <strong class="bold">private key</strong> is<a id="_idIndexMarker446"/> kept safe on the user’s computer, the <strong class="bold">public key</strong> is <a id="_idIndexMarker447"/>entered on a <span class="No-Break">remote server.</span></p>
			<p>When the <a id="_idIndexMarker448"/>user authenticates using this private key, the server can verify the user’s identity using their public key. A public key can only be used to verify the authenticity of the private key or to encrypt data that only the private key <span class="No-Break">can encrypt.</span></p>
			<p>Using public key authentication for remote access not only protects against the risk of password attacks such as brute-force and dictionary attacks but also offers an additional layer of security in case the server gets compromised. In such cases, only the public key can be extracted while the private key remains safe. As the public key alone is not enough to authenticate, this method provides better security than using a username and password, as passwords can be extracted and reused if the server <span class="No-Break">is compromised.</span></p>
			<p>You can learn how to generate a <a id="_idIndexMarker449"/>key pair using the <strong class="bold">ssh-keygen</strong> tool <span class="No-Break">at </span><span class="No-Break">https://www.ssh.com/ssh/keygen/</span><span class="No-Break">.</span></p>
			<p>If you are interested in how public key authentication works, you can read more about it on the official SSH <span class="No-Break">website: </span><a href="https://www.ssh.com/ssh/public-key-authentication"><span class="No-Break">https://www.ssh.com/ssh/public-key-authentication</span></a><span class="No-Break">.</span></p>
			<p>Of course, both authentication mechanisms can be configured at the same time, but if you use <strong class="source-inline">PubkeyAuthentication</strong> and no other user connects using their username and password, you should use <span class="No-Break"><strong class="source-inline">PubkeyAuthentication</strong></span><span class="No-Break"> only:</span></p>
			<pre class="source-code">
PasswordAuthentication no
PubkeyAuthentication yes</pre>
			<p>If you want to learn more about the different options of the <strong class="source-inline">sshd</strong> configuration file, I highly recommend that you look at <a id="_idIndexMarker450"/>the <strong class="bold">man </strong><span class="No-Break"><strong class="bold">pages</strong></span><span class="No-Break">: </span><span class="No-Break">https://manpages.debian.org/jessie/openssh-server/sshd_config.5.en.html</span><span class="No-Break">.</span></p>
			<p class="callout-heading">Man pages</p>
			<p class="callout"><strong class="bold">Man</strong> stands for <strong class="bold">manual</strong>. Man pages <a id="_idIndexMarker451"/>are used to get more information about a Linux/UNIX command or configuration file and can be compared to the Help system <span class="No-Break">in PowerShell.</span></p>
			<p>Restart the <span class="No-Break"><strong class="source-inline">ssh</strong></span><span class="No-Break"> service:</span></p>
			<pre class="source-code">
&gt; /etc/init.d/ssh restart</pre>
			<p>The updated configuration is loaded into memory to activate <span class="No-Break">the changes.</span></p>
			<h3>PowerShell remoting on macOS</h3>
			<p>To enable <a id="_idIndexMarker452"/>PSRemoting over SSH to manage macOS systems, the steps are quite similar to those when enabling PSRemoting on a Linux system: the biggest difference is that the configuration files are in a <span class="No-Break">different location.</span></p>
			<p>First, you need to install PowerShell Core on the macOS systems that you want to manage <span class="No-Break">remotely: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-macos"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-macos</span></a><span class="No-Break">.</span></p>
			<p>Edit the <span class="No-Break"><strong class="source-inline">ssh</strong></span><span class="No-Break"> configuration:</span></p>
			<pre class="source-code">
&gt; vi /private/etc/ssh/sshd_config</pre>
			<p>Create a subsystem entry <span class="No-Break">for PowerShell:</span></p>
			<pre class="source-code">
Subsystem powershell /usr/local/bin/pwsh -sshs -NoLogo</pre>
			<p>Then, define what kind of authentication you want to configure for <span class="No-Break">this machine:</span></p>
			<ul>
				<li>Username <span class="No-Break">and password:</span><pre class="source-code">
PasswordAuthentication yes</pre></li>
				<li>Public <span class="No-Break">key authentication:</span><pre class="source-code">
PubkeyAuthentication yes</pre></li>
			</ul>
			<p>To learn more about the options that can be configured in the <strong class="source-inline">sshd</strong> configuration, have a look at the <em class="italic">PowerShell remoting on Linux</em> section that we <span class="No-Break">covered previously.</span></p>
			<p>Restart the <strong class="source-inline">ssh</strong> service to load the <span class="No-Break">new configuration:</span></p>
			<pre class="source-code">
&gt; sudo launchctl stop com.openssh.sshd
&gt; sudo launchctl start com.openssh.sshd</pre>
			<p>The service will restart and the new configuration will <span class="No-Break">be active.</span></p>
			<h3>PowerShell remoting via SSH on Windows</h3>
			<p>Of course, it is<a id="_idIndexMarker453"/> also possible to manage Windows systems via SSH, but in this book, I will use PSRemoting via WinRM in all of my examples as this is the default setting on <span class="No-Break">Windows systems.</span></p>
			<p>However, if you want to enable PSRemoting via SSH on your Windows systems, make sure you install OpenSSH and follow the instructions on how to set up PSRemoting over SSH <span class="No-Break">on Windows:</span></p>
			<ul>
				<li><a href="https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_overview"><span class="No-Break">https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_overview</span></a></li>
				<li><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core?view=powershell-7.1#set-up-on-a-windows-computer"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core?view=powershell-7.1#set-up-on-a-windows-computer</span></a></li>
			</ul>
			<p class="callout-heading">Did you know?</p>
			<p class="callout">PSRemoting via SSH does not support remote endpoint <a id="_idIndexMarker454"/>configuration, nor <strong class="bold">Just Enough </strong><span class="No-Break"><strong class="bold">Administration</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JEA</strong></span><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor072"/>Enabling PowerShell remoting</h1>
			<p>There<a id="_idIndexMarker455"/> are different ways to enable PSRemoting for your system(s). If you only work with a few machines in your lab, you might want to enable it manually. But as soon as you want to enable PSRemoting in a big environment, you might want to enable and configure PSRemoting centrally. In this section, we will have a look at both methods. The following table provides an overview of which method takes which <span class="No-Break">configuration actions:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer054">
					<img alt="Table 3.2 – Enabling PSRemoting – different methods" src="image/B16679_03_Table_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 3.2 – Enabling PSRemoting – different methods</p>
			<p>Please <a id="_idIndexMarker456"/>note that the <strong class="source-inline">Enable-PSRemoting</strong> method is a subpart of the manual configuration; to configure HTTP and HTTPS listeners, additional steps must be taken. Let’s explore what is needed to manually configure PSRemoting, which could be useful in a test scenario, <span class="No-Break">for example.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor073"/>Enabling PowerShell remoting manually</h2>
			<p>If <a id="_idIndexMarker457"/>you want to enable PSRemoting on a <a id="_idIndexMarker458"/>single machine, this can be done manually by using the <strong class="source-inline">Enable-PSRemoting</strong> command on an <span class="No-Break">elevated shell:</span></p>
			<pre class="source-code">
&gt; Enable-PSRemoting
WinRM has been updated to receive requests.
WinRM service type changed successfully.
WinRM service started.
WinRM has been updated for remote management.
WinRM firewall exception enabled.
Configured LocalAccountTokenFilterPolicy to grant administrative rights remotely to local users.</pre>
			<p>In this example, the command ran successfully, so PSRemoting was enabled on <span class="No-Break">this machine.</span></p>
			<p>If you’re wondering about the difference between <strong class="source-inline">Enable-PSRemoting</strong> and <strong class="source-inline">winrm quickconfig</strong>, the truth is that there is not much difference technically. <strong class="source-inline">Enable-PSRemoting</strong> already incorporates all the actions performed by <strong class="source-inline">winrm quickconfig</strong>, but with additional environment changes specific to Windows PowerShell. So, to <a id="_idIndexMarker459"/>put it simply, running <strong class="source-inline">Enable-PSRemoting</strong> is sufficient, and you can skip running <span class="No-Break"><strong class="source-inline">winrm quickconfig</strong></span><span class="No-Break">.</span></p>
			<h3>Set-WSManQuickConfig error message</h3>
			<p>Depending <a id="_idIndexMarker460"/>on your network configuration, an error message may be shown if you try to enable <span class="No-Break">PSRemoting manually:</span></p>
			<pre class="source-code">
WinRM firewall exception will not work since one of the network connection types on this machine is set to Public. Change the network connection type to either Domain or Private and try again.</pre>
			<p>This error message was generated by the <strong class="source-inline">Set-WSManQuickConfig</strong> command, which is called during the process of <span class="No-Break">enabling PSRemoting.</span></p>
			<p>This message is shown if one network connection is set to public because, by default, PSRemoting is not allowed on networks that were defined as <span class="No-Break">public networks:</span></p>
			<pre class="source-code">
&gt; Get-NetConnectionProfile
Name             : Network 1
InterfaceAlias   : Ethernet
InterfaceIndex   : 4
NetworkCategory  : <strong class="bold">Public</strong>
IPv4Connectivity : Internet
IPv6Connectivity : NoTraffic</pre>
			<p>To avoid this error, there are <span class="No-Break">two options:</span></p>
			<ul>
				<li>Configure the network profile as a <span class="No-Break">private network.</span></li>
				<li>Enforce <strong class="source-inline">Enable-PSRemoting</strong> so that the network profile check <span class="No-Break">is skipped.</span></li>
			</ul>
			<p>If you are certain that the network profile is not a public one and instead a network that you trust, you can configure it as a <span class="No-Break">private network:</span></p>
			<pre class="source-code">
&gt; Set-NetConnectionProfile -NetworkCategory Private</pre>
			<p>If you don’t want to <a id="_idIndexMarker461"/>configure the network as a trusted, private network, you can enforce skipping the network profile check by adding the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">SkipNetworkProfileCheck</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
&gt; Enable-PSRemoting -SkipNetworkProfileCheck</pre>
			<p>Having PSRemoting enabled on public network-connected computers puts your computer at significant risk, so <span class="No-Break">be careful.</span></p>
			<h3>Checking your WinRM configuration</h3>
			<p>After <a id="_idIndexMarker462"/>enabling PSRemoting and WinRM, you might want to check the current WinRM configuration. You can achieve this using <strong class="source-inline">winrm </strong><span class="No-Break"><strong class="source-inline">get winrm/config</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer055">
					<img alt="Figure 3.2 – Verifying your local WinRM configuration" src="image/B16679_03_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Verifying your local WinRM configuration</p>
			<p>You can find all the configured options in the displayed output. The <strong class="source-inline">winrm get winrm/config</strong> command provides a summary of the WinRM <span class="No-Break">configuration settings.</span></p>
			<p>To change your local WinRM configuration, you can use the <span class="No-Break"><strong class="source-inline">set</strong></span><span class="No-Break"> option:</span></p>
			<pre class="source-code">
&gt; winrm set winrm/config/service '@{AllowUnencrypted="false"}'</pre>
			<p>Alternatively, you can use the <strong class="source-inline">wsman:\</strong> PowerShell drive to access and modify specific items in the<a id="_idIndexMarker463"/> configuration. Using the <strong class="source-inline">wsman:\</strong> provider allows you to access and modify specific items of the WinRM configuration in a more intuitive and cmdlet-like way, with the added benefit of built-in help <span class="No-Break">and documentation.</span></p>
			<p>To change your local WinRM configuration, you can use the <strong class="source-inline">Set-Item</strong> cmdlet with the <strong class="source-inline">wsman:\</strong> provider to access and modify the WinRM configuration items. For example, to disable the use of unencrypted traffic, you can run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; Set-Item wsman:\localhost\Service\AllowUnencrypted -Value $false</pre>
			<p>In this example, we are configuring the WinRM service to <em class="italic">not</em> allow unencrypted connections. You can use a similar syntax to also configure other WinRM options – just make sure you provide the entire path to the setting in the tree, as well as the option and <span class="No-Break">the value.</span></p>
			<h3>Trusted hosts</h3>
			<p>If you are <a id="_idIndexMarker464"/>connecting to a machine that is not domain-joined, which might be the reason why you configure it manually, Kerberos authentication is not an option and the NTLM protocol should be used for <span class="No-Break">authentication instead.</span></p>
			<p>In this case, you need to configure the remote machine to be considered a trusted host in <strong class="bold">WS-Man</strong> on your local device; otherwise, the connection <span class="No-Break">will fail.</span></p>
			<p>To configure <strong class="source-inline">TrustedHosts</strong> for a remote host, you can use the <strong class="source-inline">Set-Item</strong> cmdlet, along with the <strong class="source-inline">wsman:\localhost\client\TrustedHosts</strong> path. By default, this value is empty, so you need to add the IP address or domain name of the remote host. To add a new value without replacing the existing ones, use the <strong class="source-inline">-Concatenate</strong> switch, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
&gt; Set-Item wsman:\localhost\client\TrustedHosts -Value 172.29.0.12 -Concatenate -Force</pre>
			<p>This will append the specified IP address to the existing list <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">TrustedHosts</strong></span><span class="No-Break">.</span></p>
			<p>To <a id="_idIndexMarker465"/>verify that your changes were applied, you can use the <strong class="source-inline">Get-Item</strong> cmdlet to display the current <span class="No-Break"><strong class="source-inline">TrustedHosts</strong></span><span class="No-Break"> configuration:</span></p>
			<pre class="source-code">
&gt; Get-Item wsman:\localhost\client\TrustedHosts
   WSManConfig: Microsoft.WSMan.Management\WSMan::localhost\Client
Type            Name             SourceOfValue   Value
----            ----             -------------   -----
System.String   TrustedHosts                     172.29.0.12</pre>
			<p>The preceding example shows that the host with an IP address of <strong class="source-inline">172.29.0.12</strong> has been configured as a trusted host on the <span class="No-Break">local machine.</span></p>
			<p>It is also a good practice to audit the <strong class="source-inline">TrustedHosts</strong> list to detect any unauthorized changes. This can help in detecting tampering attempts on <span class="No-Break">your system.</span></p>
			<h3>Connecting via HTTPS</h3>
			<p>Optionally, you <a id="_idIndexMarker466"/>can also configure a certificate to encrypt the traffic over <strong class="bold">HTTPS</strong>. To ensure secure PSRemoting, it is recommended that you configure a certificate to encrypt the traffic over HTTPS, especially in scenarios where Kerberos is not available for server identity verification. Although PSRemoting traffic is encrypted by default, encryption can be removed, and basic authentication can be enforced easily (see the <em class="italic">PowerShell remoting authentication and security considerations</em> section). Configuring a certificate adds another layer of security to <span class="No-Break">your environment.</span></p>
			<p>Therefore, to provide an extra layer of security, it can make sense to issue a certificate and enable <strong class="bold">WinRM </strong><span class="No-Break"><strong class="bold">via SSL</strong></span><span class="No-Break">.</span></p>
			<p>If you haven’t purchased a publicly signed SSL certificate from a valid <strong class="bold">certificate authority</strong> (<strong class="bold">CA</strong>), you can create a <strong class="bold">self-signed certificate</strong> to get started. However, if you’re using this for workgroup remoting, you can also use an <strong class="bold">internal CA</strong>. This can provide additional security and trust since you have a trusted source within the organization sign <span class="No-Break">the certificate.</span></p>
			<p>This section only covers how to issue and configure a self-signed certificate. So, make sure you adjust the steps if you are using a publicly signed certificate or an <span class="No-Break">internal CA.</span></p>
			<p>First, let’s get a self-signed certificate! This step is very easy if you are working on Windows Server 2012 and above – you can leverage the <span class="No-Break"><strong class="source-inline">New-SelfSignedCertificate</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; $Cert = New-SelfSignedCertificate -CertstoreLocation Cert:\LocalMachine\My -DnsName "PSSec-PC01"
&gt; Export-Certificate -Cert $Cert -FilePath C:\tmp\cert</pre>
			<p>Make sure <a id="_idIndexMarker467"/>that the value provided via the <strong class="source-inline">-DnsName</strong> parameter matches the hostname and that a matching DNS record exists in your <span class="No-Break">DNS server.</span></p>
			<p>Add an <span class="No-Break">HTTPS listener:</span></p>
			<pre class="source-code">
&gt; New-Item -Path WSMan:\LocalHost\Listener -Transport HTTPS -Address * -CertificateThumbPrint $Cert.Thumbprint –Force</pre>
			<p>Finally, make sure you add an exception for the firewall. The default port for WinRM over HTTPS <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">5986</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; New-NetFirewallRule -DisplayName "Windows Remote Management (HTTPS-In)" -Name "Windows Remote Management (HTTPS-In)" -Profile Any -LocalPort 5986 -Protocol TCP</pre>
			<p>To clarify, it’s important to note that using the <strong class="source-inline">-Profile Any</strong> option opens WinRM to public or unidentified networks. If you’re not in a test environment, make sure you use the appropriate profile options, such as <strong class="source-inline">Domain</strong>, <strong class="source-inline">Private</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">Public</strong></span><span class="No-Break">.</span></p>
			<p>If you want to ensure that only HTTPS is used, remove WinRM’s <span class="No-Break">HTTP listener:</span></p>
			<pre class="source-code">
&gt; Get-ChildItem WSMan:\Localhost\listener | Where -Property Keys -eq "Transport=HTTP" | Remove-Item -Recurse</pre>
			<p>Additionally, you may want to check and remove any existing firewall exceptions for HTTP traffic that were configured. This step is not necessary if you did not configure any <span class="No-Break">exceptions previously.</span></p>
			<p>In some cases, you may want to move the WinRM listener to a different port. This can be useful if your firewall setup does not allow port <strong class="source-inline">5986</strong> or if you want to use a non-standard port for security reasons. To move the WinRM listener to a different port, use the <span class="No-Break"><strong class="source-inline">Set-Item</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; Set-Item WSMan:\Localhost\listener\<strong class="bold">&lt;ListenerName&gt;</strong>\port -Value <strong class="bold">&lt;PortNumber&gt;</strong></pre>
			<p>Replace <strong class="source-inline">&lt;ListenerName&gt;</strong> with the name of the listener that you want to edit and replace <strong class="source-inline">&lt;PortNumber&gt;</strong> with the port number that you want <span class="No-Break">to configure.</span></p>
			<p>Next, we’ll import<a id="_idIndexMarker468"/> our certificate. However, before doing so, it’s important to understand that certificates generated through tools such as <strong class="source-inline">New-SelfSignedCertificate</strong> already have usage restrictions built into them to ensure they are only valid for client and server authentication. If you’re using a certificate generated through another tool (for example, an internal PKI), it’s important to make sure that it also has these usage restrictions. Additionally, ensure that the root certificate is protected properly since attackers can use it to forge SSL certificates for <span class="No-Break">trusted websites.</span></p>
			<p>Once you have the appropriate certificate, copy it to a secure location on the computer from where you want to connect to the remote machine (such as <strong class="source-inline">C:\tmp\cert</strong> in our example), and then import it into the local <span class="No-Break">certificate store:</span></p>
			<pre class="source-code">
&gt; Import-Certificate -Filepath "C:\tmp\cert" -CertStoreLocation "Cert:\LocalMachine\Root"</pre>
			<p>Specify the credentials that you want to use to log in and enter your session. The <strong class="source-inline">-UseSSL</strong> parameter indicates that your connection will be encrypted <span class="No-Break">using SSL:</span></p>
			<pre class="source-code">
&gt; $cred = Get-Credential
&gt; Enter-PSSession -ComputerName PSSec-PC01 -UseSSL -Credential $cred</pre>
			<p>Of course, you still have to enter credentials to sign in to the machine remotely. The certificate only guarantees the authenticity of the remote computer and helps establish the <span class="No-Break">encrypted connection.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor074"/>Configuring PowerShell Remoting via Group Policy</h2>
			<p>When <a id="_idIndexMarker469"/>working with multiple<a id="_idIndexMarker470"/> servers, you may not want to enable PSRemoting manually on each machine, so Group Policy is the tool of <span class="No-Break">your choice.</span></p>
			<p>Using <a id="_idIndexMarker471"/>Group Policy, you<a id="_idIndexMarker472"/> can configure multiple machines using a single <strong class="bold">Group Policy </strong><span class="No-Break"><strong class="bold">Object</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">GPO</strong></span><span class="No-Break">).</span></p>
			<p>To get started, create a new GPO: open <strong class="bold">Group Policy Management</strong>, right-click on the <strong class="bold">Organizational Unit</strong> (<strong class="bold">OU</strong>) in <a id="_idIndexMarker473"/>which you want to create the new GPO, and select <strong class="bold">Create a GPO in this domain, and Link </strong><span class="No-Break"><strong class="bold">it here…</strong></span><span class="No-Break">.</span></p>
			<p>GPO is only a<a id="_idIndexMarker474"/> tool to configure your machines – it doesn’t start services. Therefore, you still need to find a solution to reboot all configured servers or start the WinRM service on <span class="No-Break">all servers.</span></p>
			<p>If you want to enable PSRemoting remotely, Lee Holmes has written a great script that leverages WMI connections (which most systems <span class="No-Break">support): </span><a href="http://www.powershellcookbook.com/recipe/SQOK/program-remotely-enable-powershell-remoting"><span class="No-Break">http://www.powershellcookbook.com/recipe/SQOK/program-remotely-enable-powershell-remoting</span></a><span class="No-Break">.</span></p>
			<h3>Allowing WinRM</h3>
			<p>In the <a id="_idIndexMarker475"/>newly created GPO, navigate to <strong class="bold">Computer Configuration</strong> | <strong class="bold">Policies</strong> | <strong class="bold">Administrative Templates</strong> | <strong class="bold">Windows Components</strong> | <strong class="bold">Windows Remote Management</strong> | <strong class="bold">WinRM Service</strong> and set the <strong class="bold">Allow remote server management through WinRM</strong> policy <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Enabled</strong></span><span class="No-Break">.</span></p>
			<p>In this<a id="_idIndexMarker476"/> policy, you can define the IPv4 and IPv6 filters. If you don’t use a protocol (for example, IPv6), then leave it empty so that users can’t connect to WinRM using this <span class="No-Break">particular protocol.</span></p>
			<p>To allow connections, you can use the wildcard character, <strong class="source-inline">*</strong>, an IP, or an <span class="No-Break">IP range.</span></p>
			<p>When working with customers or in my demo labs, I learned that the most common reason for errors occurring regarding why WinRM did not work was using an IP or an IP range when configuring <span class="No-Break">this setting.</span></p>
			<p>Therefore, nowadays, I use<a id="_idIndexMarker477"/> the wildcard character, <strong class="source-inline">*</strong>, <em class="italic">but only</em> in combination with a <strong class="bold">firewall IP restriction</strong>, to secure my setup. We will configure the firewall IP restriction later in this section (see <em class="italic">Creating a </em><span class="No-Break"><em class="italic">firewall rule</em></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer056">
					<img alt="Figure 3.3 – Configuring Allow remote server management through WinRM" src="image/B16679_03_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Configuring Allow remote server management through WinRM</p>
			<p class="callout-heading">Caution!</p>
			<p class="callout">Only use the wildcard (<strong class="source-inline">*</strong>) configuration if you wish to restrict via a firewall rule that remote IPs are allowed to <span class="No-Break">connect to.</span></p>
			<h3>Configuring the WinRM service to start automatically</h3>
			<p>To configure the <a id="_idIndexMarker478"/>WinRM service so that it starts automatically, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Use the same GPO and navigate to <strong class="bold">Computer Configuration</strong> | <strong class="bold">Policies</strong> | <strong class="bold">Windows Settings</strong> | <strong class="bold">Security Settings</strong> | <span class="No-Break"><strong class="bold">System Services</strong></span><span class="No-Break">.</span></li>
				<li>Select and configure the <strong class="bold">Windows Remote Management (WS </strong><span class="No-Break"><strong class="bold">Management)</strong></span><span class="No-Break"> setting.</span></li>
				<li>A new <a id="_idIndexMarker479"/>window will open. Check the <strong class="bold">Define this policy setting</strong> option and set the service startup mode <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Automatic</strong></span><span class="No-Break">.</span></li>
				<li>Confirm your configuration by <span class="No-Break">clicking </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer057">
					<img alt="Figure 3.4 – Configuring the Windows Remote Management service so that it starts automatically" src="image/B16679_03_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Configuring the Windows Remote Management service so that it starts automatically</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This setting only configures the service to start automatically, which usually happens when your computer starts. It does not start the service for you, so make sure that you reboot your computer (or start the service manually) so that the WinRM service <span class="No-Break">starts automatically.</span></p>
			<h3>Creating a firewall rule</h3>
			<p>To configure <a id="_idIndexMarker480"/>the settings of the firewall, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Navigate to <strong class="bold">Computer Configuration</strong> | <strong class="bold">Policies</strong> | <strong class="bold">Windows Settings</strong> | <strong class="bold">Security Settings </strong>| <strong class="bold">Windows Defender Firewall with Advanced Security</strong> | <strong class="bold">Windows Defender Firewall with Advanced Security</strong> | <span class="No-Break"><strong class="bold">Inbound Rules</strong></span><span class="No-Break">.</span></li>
				<li>Create a new inbound rule using <span class="No-Break">the wizard.</span></li>
				<li>Check the <strong class="bold">Predefined</strong> option and select <strong class="bold">Windows </strong><span class="No-Break"><strong class="bold">Remote Management</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer058">
					<img alt="Figure 3.5 – Creating a predefined Windows Remote Management firewall rule" src="image/B16679_03_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Creating a predefined Windows Remote Management firewall rule</p>
			<ol>
				<li value="4">Click <strong class="bold">Next</strong> and remove the <strong class="bold">Public</strong> firewall profile by deselecting the option shown in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer059">
					<img alt="Figure 3.6 – Deselecting the public network profile" src="image/B16679_03_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Deselecting the public network profile</p>
			<ol>
				<li value="5">Finally, select <strong class="bold">Allow the connection</strong> before<a id="_idIndexMarker481"/> confirming your configuration by clicking the <span class="No-Break"><strong class="bold">Finish</strong></span><span class="No-Break"> button:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer060">
					<img alt="Figure 3.7 – Allow the connection" src="image/B16679_03_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Allow the connection</p>
			<p>The <a id="_idIndexMarker482"/>new rule will be created, and shown in <span class="No-Break">your GPO:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer061">
					<img alt="Figure 3.8 – Displaying the new inbound firewall rule" src="image/B16679_03_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Displaying the new inbound firewall rule</p>
			<ol>
				<li value="6">Before exiting the GPO configuration, make sure you open your newly created firewall rule once again by double-clicking it. The <strong class="bold">Windows Remote Management (HTTP-In) Properties</strong> window <span class="No-Break">will open.</span></li>
				<li>Optional: if your<a id="_idIndexMarker483"/> machines reside in the same domain, navigate to the <strong class="bold">Advanced</strong> tab and deselect the <strong class="bold">Private</strong> profile to make sure that a remote connection using WinRM is only allowed within the <strong class="bold">Domain</strong> <span class="No-Break">network profile:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer062">
					<img alt="Figure 3.9 – Only allowing WinRM within the Domain network profile" src="image/B16679_03_009.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Only allowing WinRM within the Domain network profile</p>
			<ol>
				<li value="8">Then, navigate to the <strong class="bold">Scope</strong> tab and add all remote IP addresses from which it should be allowed to access the computer remotely. For instance, if you have a management subnet on your network, you can add the IP addresses within that subnet to <span class="No-Break">the list:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer063">
					<img alt="Figure 3.10 – Configuring which remote IP addresses are allowed to connect" src="image/B16679_03_010.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Configuring which remote IP addresses are allowed to connect</p>
			<p>In the<a id="_idIndexMarker484"/> best case, allow only a hardened, secure management system to manage systems <span class="No-Break">via PSRemoting.</span></p>
			<p>Use the clean source principle to build the management system and use the recommended privileged access model to <span class="No-Break">access it:</span></p>
			<ul>
				<li><a href="https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-success-criteria#clean-source-principle"><span class="No-Break">https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-success-criteria#clean-source-principle</span></a></li>
				<li><a href="https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-access-model"><span class="No-Break">https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-access-model</span></a></li>
			</ul>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor075"/>PowerShell endpoints (session configurations)</h1>
			<p>In this<a id="_idIndexMarker485"/> chapter, you might have read the term <strong class="bold">endpoint</strong> <span class="No-Break">several times.</span></p>
			<p>If we are talking about endpoints, we are not talking about one computer: PSRemoting is designed to work with multiple endpoints on <span class="No-Break">a computer.</span></p>
			<p>But what exactly is<a id="_idIndexMarker486"/> <span class="No-Break">an endpoint?</span></p>
			<p>When we are talking about PowerShell endpoints, <em class="italic">each endpoint is a session configuration</em>, which you can configure to offer certain services or which you can <span class="No-Break">also restrict.</span></p>
			<p>So, every time we run <strong class="source-inline">Invoke-Command</strong> or enter a PowerShell session, we are connecting to an endpoint (also known as a remote <span class="No-Break">session configuration).</span></p>
			<p>Sessions that <a id="_idIndexMarker487"/>offer fewer cmdlets, functions, and features, as those that are usually available if no restrictions are in place, are called <span class="No-Break"><strong class="bold">constrained endpoints</strong></span><span class="No-Break">.</span></p>
			<p>Before we enable PSRemoting, no endpoint will have been configured on <span class="No-Break">the computer.</span></p>
			<p>You can see all the available session configurations by running the <span class="No-Break"><strong class="source-inline">Get-PSSessionConfiguration</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer064">
					<img alt="Figure 3.11 – No endpoint is shown when PSRemoting is not enabled" src="image/B16679_03_011.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – No endpoint is shown when PSRemoting is not enabled</p>
			<p>When PSRemoting is not enabled on a computer, no endpoint will be shown. This is because the WinRM service, which is responsible for PSRemoting, is not started by default. However, once the WinRM service is started, the endpoints are already configured and ready to use, but not exposed and cannot be connected to until PSRemoting <span class="No-Break">is enabled.</span></p>
			<p>Enabling PSRemoting using <strong class="source-inline">Enable-PSRemoting</strong>, as we did in the previous section, creates all <a id="_idIndexMarker488"/>default session configurations, which are necessary to connect to this endpoint <span class="No-Break">via PSRemoting:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer065">
					<img alt="Figure 3.12 – After enabling PSRemoting, we can see all the prepopulated endpoints" src="image/B16679_03_012.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – After enabling PSRemoting, we can see all the prepopulated endpoints</p>
			<p>Typically, in Windows PowerShell 3.0 and above, there are three default preconfigured endpoints on <span class="No-Break">client systems:</span></p>
			<ul>
				<li><strong class="source-inline">microsoft.powershell</strong>: This<a id="_idIndexMarker489"/> is the standard endpoint and is used for PSRemoting connections if not <span class="No-Break">specified otherwise</span></li>
				<li><strong class="source-inline">microsoft.powershell32</strong>: This <a id="_idIndexMarker490"/>is a 32-bit endpoint that’s optional if you’re running a 64-bit <span class="No-Break">operating system</span></li>
				<li><strong class="source-inline">microsoft.powershell.workflow</strong>: This <a id="_idIndexMarker491"/>endpoint is for PowerShell workflows – <span class="No-Break">h</span><a href="https://docs.microsoft.com/en-us/system-center/sma/overview-powershell-workflows?view=sc-sma-2019&#13;"><span class="No-Break">ttps://docs.microsoft.com/en-us/system-center/sma/overview-powershell-workflows?view=sc-sma-2019</span></a></li>
			</ul>
			<p>On <em class="italic">server systems</em>, there’s typically a fourth session configuration <span class="No-Break">that’s predefined:</span></p>
			<ul>
				<li><strong class="source-inline">microsoft.windows.servermanagerworkflows</strong>: This endpoint <a id="_idIndexMarker492"/>is for Server Manager workflows – <span class="No-Break">h</span><span class="No-Break">ttps://docs.microsoft.com/en-us/windows-server/administration/server-manager/server-manager</span></li>
			</ul>
			<p>Every computer will show different default endpoints. In the preceding example, I ran the command on a <a id="_idIndexMarker493"/>Windows 10 client, which will show fewer endpoints than, for example, Windows <span class="No-Break">Server 2019.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor076"/>Connecting to a specified endpoint</h2>
			<p>By <a id="_idIndexMarker494"/>default, the <strong class="source-inline">microsoft.powershell</strong> endpoint is used for all PSRemoting connections. But if you want to connect to another specified endpoint, you can do this by using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">ConfigurationName</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
&gt; Enter-PSSession -ComputerName PSSec-PC01 -ConfigurationName 'microsoft.powershell32'</pre>
			<p>The specified configuration can be either the name of another default or a <span class="No-Break">custom endpoint.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor077"/>Creating a custom endpoint – a peek into JEA</h2>
			<p>Creating a <a id="_idIndexMarker495"/>custom endpoint (also known as <strong class="bold">Just Enough Administration</strong> or <strong class="bold">JEA</strong>) allows you to define a restricted <a id="_idIndexMarker496"/>administrative environment for delegated administration. With JEA, you can define a set of approved commands and parameters that are allowed to be executed on specific machines by specific users. This enables you to give users just enough permissions to perform their job duties, without granting them full administrative access. It is a great way to secure your <span class="No-Break">remote connections:</span></p>
			<ul>
				<li>You can restrict the session so that only predefined commands will <span class="No-Break">be run.</span></li>
				<li>You can enable transcription so that every command that is executed in this session <span class="No-Break">is logged.</span></li>
				<li>You can specify a security descriptor (SDDL) to determine who is allowed to connect and <span class="No-Break">who isn’t.</span></li>
				<li>You can configure scripts and modules that will be automatically loaded as soon as the connection to this endpoint <span class="No-Break">is established.</span></li>
				<li>You can even specify that another account is used to run your commands in this session on <span class="No-Break">the endpoint.</span></li>
			</ul>
			<p>To create<a id="_idIndexMarker497"/> and activate an endpoint, two steps need to <span class="No-Break">be followed:</span></p>
			<ol>
				<li>Creating a session <span class="No-Break">configuration file</span></li>
				<li>Registering the session as a <span class="No-Break">new endpoint</span></li>
			</ol>
			<h3>Creating a session configuration file</h3>
			<p>Using <strong class="source-inline">New-PSSessionConfigurationFile</strong>, you can create an empty skeleton session <a id="_idIndexMarker498"/>configuration file. You need to specify the path where the configuration file will be saved, so the <strong class="source-inline">-Path</strong> parameter is mandatory. A session configuration file ends with the <strong class="source-inline">.pssc</strong> filename extension, so make sure you name the <span class="No-Break">file accordingly:</span></p>
			<pre class="source-code">
&gt; New-PSSessionConfigurationFile -Path <strong class="bold">&lt;Path:\To\Your\SessionConfigurationFile.pssc&gt;</strong></pre>
			<p>Have a look at the official documentation for more <span class="No-Break">information: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/new-pssessionconfigurationfile"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/new-pssessionconfigurationfile</span></a><span class="No-Break">.</span></p>
			<p>You can either generate an empty session configuration file and populate it later using an editor or you can use the <strong class="source-inline">New-PSSessionConfigurationFile</strong> parameters to directly generate the file with all its defined <span class="No-Break">configuration options:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer066">
					<img alt="Figure 3.13 – New-PSSessionConfigurationFile parameters" src="image/B16679_03_013.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – New-PSSessionConfigurationFile parameters</p>
			<p>For this <a id="_idIndexMarker499"/>example, we will create a session configuration file for a <span class="No-Break"><strong class="source-inline">RestrictedRemoteServer</strong></span><span class="No-Break"> session:</span></p>
			<pre class="source-code">
&gt; New-PSSessionConfigurationFile -SessionType RestrictedRemoteServer -Path .\PSSessionConfig.pssc</pre>
			<p>By using <strong class="source-inline">-SessionType RestrictedRemoteServer</strong>, only the most important commands are being imported into this session, such as <strong class="source-inline">Exit-PSSession</strong>, <strong class="source-inline">Get-Command</strong>, <strong class="source-inline">Get-FormatData</strong>, <strong class="source-inline">Get-Help</strong>, <strong class="source-inline">Measure-Object</strong>, <strong class="source-inline">Out-Default</strong>, and <strong class="source-inline">Select-Object</strong>. If you want to allow other commands in this session, they need to be configured in the role capability file, which we will discuss in detail in <a href="B16679_10_Final_PD.xhtml#_idTextAnchor278"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Language Modes and Just Enough </em><span class="No-Break"><em class="italic">Administration (JEA)</em></span><span class="No-Break">.</span></p>
			<h3>Registering the session as a new endpoint</h3>
			<p>After <a id="_idIndexMarker500"/>creating the session configuration file, you must register it as an endpoint by utilizing the <span class="No-Break"><strong class="source-inline">Register-PSSessionConfiguration</strong></span><span class="No-Break"> command.</span></p>
			<p>When utilizing the mandatory <strong class="source-inline">-Name</strong> parameter, make sure you only specify the name of the session<a id="_idIndexMarker501"/> configuration file, without including the <span class="No-Break">filename extension:</span></p>
			<pre class="source-code">
&gt; Register-PSSessionConfiguration -Name PSSessionConfig
WARNING: Register-PSSessionConfiguration may need to restart the WinRM service if a configuration using this name has recently been unregistered, certain system data structures may still be cached. In that case, a restart of WinRM may be required.
All WinRM sessions connected to Windows PowerShell session configurations, such as Microsoft.PowerShell and session configurations that are created with the Register-PSSessionConfiguration cmdlet, are disconnected.
   WSManConfig: Microsoft.WSMan.Management\WSMan::localhost\Plugin
Type            Keys                                Name
----            ----                                ----
Container       {Name=PSSessionConfig}              PSSessionConfig</pre>
			<p>The session configuration will be registered, and a new endpoint will be created. Sometimes, it might be necessary to restart the WinRM service after registering <span class="No-Break">an endpoint:</span></p>
			<pre class="source-code">
&gt; Get-PSSessionConfiguration -Name PSSessionConfig
Name          : PSSessionConfig
PSVersion     : 5.1
StartupScript :
RunAsUser     :
Permission    : NT AUTHORITY\INTERACTIVE AccessAllowed, BUILTIN\Administrators AccessAllowed, BUILTIN\Remote Management Users AccessAllowed</pre>
			<p>Using <strong class="source-inline">Get-PSSessionConfiguration</strong>, you can verify that the endpoint was created. If <a id="_idIndexMarker502"/>you specify the endpoint name using the <strong class="source-inline">-Name</strong> parameter, as in the preceding example, you will only get the information relevant to the <span class="No-Break">specified endpoint.</span></p>
			<p>We will have a deeper look into the possible session configuration and registering parameters in <a href="B16679_10_Final_PD.xhtml#_idTextAnchor278"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Language Modes and Just Enough </em><span class="No-Break"><em class="italic">Administration (JEA)</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor078"/>PowerShell remoting authentication and security considerations</h1>
			<p>PSRemoting traffic<a id="_idIndexMarker503"/> is encrypted by default – regardless of whether a connection was initiated via HTTP or HTTPS. The underlying protocol that’s used is WS-Man, which is decoupled to allow it to be used more broadly. PSRemoting uses an authentication protocol, such as Kerberos or NTLM, to authenticate the session traffic, and SSL/TLS is used to encrypt the session traffic, regardless of whether the connection was initiated via HTTP <span class="No-Break">or HTTPS.</span></p>
			<p>But similar to every other computer, PSRemoting is only as secure as the computer that’s been configured. And if you don’t secure your administrator’s credentials, an attacker can extract and use them <span class="No-Break">against you.</span></p>
			<p>Therefore, you should also put effort into hardening your infrastructure and securing your most valuable identities. You will learn more about Active Directory security and credential hygiene in <a href="B16679_06_Final_PD.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Active Directory – Attacks and Mitigations</em>, and learn more about what mitigations you can put in place in <em class="italic">Part 3</em>, <em class="italic">Securing PowerShell – Effective Mitigations </em><span class="No-Break"><em class="italic">in Detail</em></span><span class="No-Break">.</span></p>
			<p>It’s important to understand that enabling PSRemoting does not automatically ensure a secure environment. As with any remote management technology, it’s critical to harden your systems and take appropriate security measures to protect against potential threats. This applies not only to PSRemoting but also to other remote management technologies, such as RDP. By investing time and effort into securing your systems and environment, you can mitigate potential risks and better protect your <span class="No-Break">organization’s assets.</span></p>
			<p>First, let’s have a look at how authentication is used <span class="No-Break">within PSRemoting.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor079"/>Authentication</h2>
			<p>By default, WinRM <a id="_idIndexMarker504"/>uses <strong class="bold">Kerberos</strong> for authentication and falls back to <strong class="bold">NTLM</strong> in<a id="_idIndexMarker505"/> case Kerberos authentication is <span class="No-Break">not possible.</span></p>
			<p>When used <a id="_idIndexMarker506"/>within a domain, Kerberos is the <a id="_idIndexMarker507"/>standard to authenticate. To use Kerberos for authentication in PSRemoting, ensure that both the client and server computers are connected to the same domain and that the DNS names have been properly configured and are reachable. It’s also important to note that from a Kerberos perspective, the server must be registered in <span class="No-Break">Active Directory.</span></p>
			<p>In general, you can specify which protocol should be used when connecting to a <span class="No-Break">remote computer:</span></p>
			<pre class="source-code">
&gt; Enter-PSSession -ComputerName PSSEC-PC01 -Authentication Kerberos</pre>
			<p>When establishing a PSRemoting session, if the <strong class="source-inline">-Authentication</strong> parameter is not specified, the default value of <strong class="source-inline">Default</strong> is used, which is equal to the <strong class="source-inline">Negotiate</strong> value. This means that the client and server negotiate the best authentication protocol to use based on what is supported by <span class="No-Break">both systems.</span></p>
			<p>Typically, <em class="italic">Kerberos</em> is the preferred protocol, but if it’s not available or supported, the system will fall back to using <em class="italic">NTLM</em>. More information about <strong class="bold">Negotiate</strong> can be found in the Microsoft documentation for Negotiate in Win32 <span class="No-Break">applications: </span><a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/microsoft-negotiate"><span class="No-Break">https://learn.microsoft.com/en-us/windows/win32/secauthn/microsoft-negotiate</span></a><span class="No-Break">.</span></p>
			<h3>What are the circumstances for an NTLM fallback?</h3>
			<p>PSRemoting <a id="_idIndexMarker508"/>was designed to work with Active Directory, so Kerberos is the preferred authentication protocol. But in some cases, Kerberos authentication<a id="_idIndexMarker509"/> is not possible and NTLM <span class="No-Break">is used.</span></p>
			<p><span class="No-Break"><strong class="bold">Kerberos</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Computers are joined to the same domain or are both within domains that trust <span class="No-Break">each other.</span></li>
				<li>The client can resolve the server’s hostname or <span class="No-Break">IP address.</span></li>
				<li>The server has a <a id="_idIndexMarker510"/>valid <strong class="bold">Service Principal Name</strong> (<strong class="bold">SPN</strong>) registered in Active Directory. The SPN matches the target you are <span class="No-Break">connecting to.</span></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">NTLM</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Commonly<a id="_idIndexMarker511"/> used to connect to <span class="No-Break">non-domain-joined workstations</span></li>
				<li>If IP addresses are used instead of <span class="No-Break">DNS names</span></li>
			</ul>
			<p>To connect to the <strong class="source-inline">PSSec-PC01</strong> computer via Kerberos, we can use the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; Enter-PSSession -ComputerName PSSec-PC01</pre>
			<p>If no credentials<a id="_idIndexMarker512"/> were explicitly specified, if the current user has permission to access the remote computer, and if the remote computer is configured to accept Kerberos authentication, the connection will be established automatically without the need to provide any explicit credentials. This is one of the benefits of using Kerberos authentication, as the authentication process is implicit and seamless for <span class="No-Break">the user.</span></p>
			<p>If the current user does not have permission to access the remote computer, we can also specify explicitly which credentials should be used with the <strong class="source-inline">-Credential</strong> parameter. To simplify testing, we use <strong class="source-inline">Get-Credential</strong> to prompt for the credentials and store them in the <strong class="source-inline">$cred</strong> <span class="No-Break">secure string:</span></p>
			<pre class="source-code">
$cred = Get-Credential -Credential "PSSEC\Administrator"</pre>
			<p>Then, we connect <span class="No-Break">via Kerberos:</span></p>
			<pre class="source-code">
Enter-PSSession -ComputerName PSSEC-PC01 -Credential $cred</pre>
			<p>If you capture the traffic using Wireshark, you will see that WinRM includes Kerberos as its <strong class="source-inline">content-type</strong> as part of its protocol, indicating that Kerberos was used for authentication. While the actual Kerberos traffic itself may not be visible in the HTTP packet, the use of Kerberos for authentication can still be confirmed by examining the headers in the WinRM traffic. Additionally, you can see that the entire HTTP session is encrypted, providing an added layer <span class="No-Break">of security:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer067">
					<img alt="Figure 3.14 – WinRM HTTP traffic captured with Wireshark" src="image/B16679_03_014.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – WinRM HTTP traffic captured with Wireshark</p>
			<p>As you can see, a session to <strong class="source-inline">PSSec-PC01</strong> has been established over port <strong class="source-inline">5985</strong> (WinRM over HTTP), using PowerShell version 5.1.17763.1490. The request was sent <span class="No-Break">via WS-Man.</span></p>
			<p>Once the <a id="_idIndexMarker513"/>initial authentication process is complete, WinRM proceeds to encrypt all ongoing communication to maintain the security of the data being exchanged between the client and server. When establishing a connection over HTTPS, the TLS protocol is utilized to negotiate the encryption method used for data transportation. In the case of an HTTP connection, the encryption that’s utilized for message-level encryption is determined by the initial authentication <span class="No-Break">protocol used.</span></p>
			<p>The level of encryption provided by<a id="_idIndexMarker514"/> each authentication protocol is <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Basic authentication</strong>: <span class="No-Break">No</span><span class="No-Break"><a id="_idIndexMarker515"/></span><span class="No-Break"> encryption.</span></li>
				<li><strong class="bold">NTLM authentication</strong>: RC4 <a id="_idIndexMarker516"/>cipher with a <span class="No-Break">128-bit key.</span></li>
				<li><strong class="bold">Kerberos authentication</strong>: <strong class="source-inline">etype</strong> in<a id="_idIndexMarker517"/> the TGS ticket determines the encryption. On modern systems, this is <span class="No-Break">typically AES-256.</span></li>
				<li><strong class="bold">CredSSP authentication</strong>: The<a id="_idIndexMarker518"/> TLS cipher suite that was negotiated in the handshake will <span class="No-Break">be used.</span></li>
			</ul>
			<p>Note that while the HTTP protocol is used as the connection protocol, the content is encrypted using the appropriate encryption mechanism based on the initial authentication protocol used. A common misconception about PSRemoting is that a connection using WinRM over HTTP is not encrypted. However, as you can see in the following screenshot, this is not <span class="No-Break">the case:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer068">
					<img alt="Figure 3.15 – Kerberos TCP stream captured with Wireshark" src="image/B16679_03_015.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – Kerberos TCP stream captured with Wireshark</p>
			<p>If DNS <a id="_idIndexMarker519"/>names are not working and if both hosts are not joined to the same domain, NTLM will be used as a <span class="No-Break">fallback option.</span></p>
			<p>If you are connecting to a remote computer in the same domain, with working DNS names, NTLM is still used to connect if the host IP address is specified instead of <span class="No-Break">the hostname:</span></p>
			<pre class="source-code">
Enter-PSSession -ComputerName 172.29.0.12 -Credential $cred</pre>
			<p>Capturing the traffic with Wireshark once more reveals that NTLM was used to authenticate and that the traffic is encrypted <span class="No-Break">as well:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer069">
					<img alt="Figure 3.16 – NTLM traffic captured with Wireshark" src="image/B16679_03_016.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – NTLM traffic captured with Wireshark</p>
			<p>Similar to <a id="_idIndexMarker520"/>connecting with Kerberos, you can see that a connection is established to the host, <strong class="source-inline">172.29.0.12</strong>, using WinRM over HTTP (port <strong class="source-inline">5985</strong>). But this time, NTLM is used instead of Kerberos to negotiate the session. Using NTLM, you can even capture the hostname, the username, the domain name, and the challenge, which is used <span class="No-Break">for authentication.</span></p>
			<p>Going deeper into the TCP stream, it becomes evident that the communication is once again encrypted, even when NTLM is used, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer070">
					<img alt="Figure 3.17 – NTLM TCP stream captured with Wireshark" src="image/B16679_03_017.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – NTLM TCP stream captured with Wireshark</p>
			<p>When <a id="_idIndexMarker521"/>using NTLM authentication, please note that PSRemoting only works if the remote host was added to the <span class="No-Break"><strong class="source-inline">TrustedHosts</strong></span><span class="No-Break"> list.</span></p>
			<p>When using NTLM authentication, it’s important to understand the limitations of the <strong class="source-inline">TrustedHosts</strong> list. While adding a remote host to the <strong class="source-inline">TrustedHosts</strong> list can help you catch your mistakes, it’s not a reliable way to ensure secure communication. This is because NTLM can’t guarantee that you are connecting to the intended remote host, which makes using <strong class="source-inline">TrustedHosts</strong> misleading. It’s important to note that the main weakness of NTLM is its inability to verify the identity of the remote host. Therefore, even with <strong class="source-inline">TrustedHosts</strong>, NTLM connections shouldn’t be considered <span class="No-Break">more trustworthy.</span></p>
			<p>If the host is not specified as a trusted host and if the credentials are not explicitly provided (like we did when using <strong class="source-inline">-Credential $cred</strong>), establishing a remote session or running commands remotely will fail and show an <span class="No-Break">error message:</span></p>
			<pre class="source-code">
&gt; Enter-PSSession -ComputerName 172.29.0.10
Enter-PSSession : Connecting to remote server 172.29.0.10 failed with the following error message : The WinRM client
cannot process the request. If the authentication scheme is different from Kerberos, or if the client computer is not
joined to a domain, then HTTPS transport must be used or the destination machine must be added to the TrustedHosts
configuration setting. Use winrm.cmd to configure TrustedHosts. Note that computers in the TrustedHosts list might not
be authenticated. You can get more information about that by running the following command: winrm help config. For
more information, see the about_Remote_Troubleshooting Help topic.
At line:1 char:1
+ Enter-PSSession -ComputerName 172.29.0.10
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : InvalidArgument: (172.29.0.10:String) [Enter-PSSession], PSRemotingTransportException
    + FullyQualifiedErrorId : CreateRemoteRunspaceFailed</pre>
			<p>Kerberos <a id="_idIndexMarker522"/>and NTLM are not the only authentication protocols, but they are the most secure compared with others. Let’s have a look at what other methods exist and how you can <span class="No-Break">enforce them.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor080"/>Authentication protocols</h2>
			<p>Of course, it <a id="_idIndexMarker523"/>is also possible to configure which<a id="_idIndexMarker524"/> authentication method should be used by specifying the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Authentication</strong></span><span class="No-Break"> parameter.</span></p>
			<p class="callout-heading">Authentication protocols</p>
			<p class="callout">If it is possible to use Kerberos authentication, you should always use Kerberos, as this protocol provides most <span class="No-Break">security features.</span></p>
			<p class="callout">Proceed to <a href="B16679_06_Final_PD.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Active Directory – Attacks and Mitigation</em>, to learn more about authentication and how Kerberos and <span class="No-Break">NTLM work.</span></p>
			<p>The following are all accepted values for the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Authentication</strong></span><span class="No-Break"> parameter:</span></p>
			<ul>
				<li><strong class="source-inline">Default</strong>: This is the default value. Here, <strong class="source-inline">Negotiate</strong> will <span class="No-Break">be used.</span></li>
				<li><strong class="source-inline">Basic</strong>: Basic authentication is used to authenticate, using the HTTP protocol, but does not provide security by itself – neither for the data, which is transported in cleartext over the network, nor for the credentials. However, when paired with TLS, this can still be a reasonably secure mechanism and is commonly used by <span class="No-Break">many websites.</span></li>
			</ul>
			<p>As the credentials are only encoded using Base64 encoding, the encryption can easily be reversed and the credentials can be extracted <span class="No-Break">in cleartext.</span></p>
			<p>This authentication does not provide confidentially for the provided credentials if they’re not encrypted <a id="_idIndexMarker525"/><span class="No-Break">with </span><span class="No-Break"><strong class="bold">SSL</strong></span><span class="No-Break">/</span><span class="No-Break"><strong class="bold">TLS</strong></span><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="source-inline">Credssp</strong>: Using <a id="_idIndexMarker526"/>the <strong class="bold">CredSSP</strong> authentication, the user’s credentials will be provided by PowerShell from the client to the remote server to authenticate the user. This mode is particularly useful in situations where you need the remote session to be able to authenticate as you for further network hops. After this authentication, the credentials are passed between the client and server in an encrypted format to <span class="No-Break">maintain security.</span></li>
			</ul>
			<p>When using the CredSSP authentication mechanism, PowerShell passes the user’s full credentials to the remote server for authentication. This means that if you connect to a compromised machine, an adversary can extract your credentials directly from memory. It’s important to note that this is the default authentication mechanism of RDP, making PSRemoting a more <span class="No-Break">secure alternative.</span></p>
			<ul>
				<li><strong class="source-inline">Digest</strong>: Digest authentication is one of the methods a web server can use for authentication. The username and password are <a id="_idIndexMarker527"/>hashed using <strong class="bold">MD5</strong> cryptography algorithms before they’re sent over the network using <a id="_idIndexMarker528"/>the <strong class="bold">HTTP</strong> protocol. Before hashing, a nonce is added to avoid <span class="No-Break">replay attacks.</span></li>
			</ul>
			<p>It does not <a id="_idIndexMarker529"/>provide strong authentication compared to other authentication protocols (for example, key-based ones), but it is still stronger than weaker authentication mechanisms and should be considered as a replacement for weak <span class="No-Break">basic authentication.</span></p>
			<ul>
				<li><strong class="source-inline">Kerberos</strong>: This form of authentication uses the Kerberos protocol. Kerberos is the standard to authenticate in a domain and provides the <span class="No-Break">highest security.</span></li>
				<li><strong class="source-inline">Negotiate</strong>: This option allows the client to negotiate the authentication. When a domain account is used, the authentication will be via Kerberos; with a local account, it falls back <span class="No-Break">to NTLM.</span></li>
				<li><strong class="source-inline">NegotiateWithImplicitCredential</strong>: This option uses the current user’s credentials to authenticate (<span class="No-Break">run as).</span></li>
			</ul>
			<p>These <a id="_idIndexMarker530"/>authentication mechanisms can be used within all <span class="No-Break">PSRemoting cmdlets.</span></p>
			<p>They are also<a id="_idIndexMarker531"/> specified in the <strong class="source-inline">AuthenticationMechanism</strong><strong class="bold"> enum</strong>, which is defined in Microsoft <span class="No-Break">docs: </span><span class="No-Break">https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.runspaces.authenticationmechanism</span><span class="No-Break">.</span></p>
			<p>It’s important to note that PowerShell considers some authentication mechanisms as potentially dangerous and may show error messages if you try to use them. In such cases, you would need to explicitly override these errors to proceed with the dangerous <span class="No-Break">authentication mechanism.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor081"/>Basic authentication security considerations</h2>
			<p>If used <a id="_idIndexMarker532"/>without any additional encryption layers, basic authentication is not secure. In this section we are going to explore a very good example of why you should not use basic authentication or why you should always encrypt your communication using <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>) if <a id="_idIndexMarker533"/>you have to use <span class="No-Break">basic authentication.</span></p>
			<p class="callout-heading">Caution!</p>
			<p class="callout">Do not configure this in your production environment as this configuration is highly insecure and is only shown for testing purposes. You will compromise yourself if you use <span class="No-Break">this configuration!</span></p>
			<p>If you<a id="_idIndexMarker534"/> want to configure your <strong class="bold">test environment</strong> to use basic authentication and allow unencrypted traffic, you need to configure your WinRM configuration to allow basic authentication, as well as <span class="No-Break">unencrypted traffic.</span></p>
			<p>In this example, <strong class="source-inline">PSSec-PC01</strong> is the remote host to which we want to connect using unencrypted traffic and basic authentication. We will connect from a management machine, which will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">PSSec-PC02</strong></span><span class="No-Break">.</span></p>
			<p>When we try to authenticate from <strong class="source-inline">PSSec-PC02</strong> to <strong class="source-inline">PSSec-PC01</strong> (the IP address is <strong class="source-inline">172.29.0.12</strong>) using the <strong class="source-inline">-Authentication Basic</strong> parameter, we get a message stating that we need to provide a username and a password to authenticate using <span class="No-Break">basic authentication:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer071">
					<img alt="Figure 3.18 – Error messages are shown if an insecure authentication mechanism is used" src="image/B16679_03_018.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18 – Error messages are shown if an insecure authentication mechanism is used</p>
			<p>Once we provide these credentials, we are still not able to authenticate and get another error message stating that access has been denied. The reason for this is that <strong class="source-inline">basic</strong> authentication is an insecure authentication mechanism if it’s not protected by TLS. Therefore, PSRemoting does not allow you to connect using this insecure authentication mechanism if you don’t configure <span class="No-Break">it explicitly.</span></p>
			<p>So, let’s configure basic authentication explicitly in our demo setup, knowing that we will weaken our configuration on purpose. First, allow unencrypted traffic <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">PSSec-PC01</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; winrm set winrm/config/service '@{AllowUnencrypted="true"}'</pre>
			<p>Remember to differentiate between <strong class="source-inline">service</strong> and <strong class="source-inline">client</strong> configuration. As we want to connect to <strong class="source-inline">PSSec-PC01</strong>, we will connect to the WinRM service, so we are <span class="No-Break">configuring </span><span class="No-Break"><strong class="source-inline">service</strong></span><span class="No-Break">.</span></p>
			<p>Next, configure<a id="_idIndexMarker535"/> basic authentication to <span class="No-Break">be allowed:</span></p>
			<pre class="source-code">
&gt; winrm set winrm/config/service/auth '@{Basic="true"}'</pre>
			<p>After making changes to the WinRM configuration, it is important to restart the WinRM service for the new configuration to <span class="No-Break">take effect:</span></p>
			<pre class="source-code">
&gt; Restart-Service -Name WinRM</pre>
			<p>Now, let’s configure <strong class="source-inline">PSSec-PC02</strong> to establish unencrypted connections to other devices using <span class="No-Break">basic authentication.</span></p>
			<p>First, we must configure the client so that unencrypted connections can <span class="No-Break">be initialized:</span></p>
			<pre class="source-code">
&gt; winrm set winrm/config/client '@{AllowUnencrypted="true"}'</pre>
			<p>Then, we must make sure that the client is allowed to establish connections using <span class="No-Break">basic authentication:</span></p>
			<pre class="source-code">
&gt; winrm set winrm/config/client/auth '@{Basic="true"}'</pre>
			<p>Lastly, restart the WinRM service to load the <span class="No-Break">new configuration:</span></p>
			<pre class="source-code">
&gt; Restart-Service -Name WinRM</pre>
			<p>Again, this configuration exposes your devices and makes them vulnerable. Specifically, it exposes your credentials to potential attackers who could intercept network traffic while you connect to your machines. This could allow an attacker to gain unauthorized access to your systems and potentially compromise sensitive data or perform <span class="No-Break">malicious actions.</span></p>
			<p>Therefore, we apply this configuration only in a test environment. In productive environments, it’s important to take appropriate security measures, such as enabling encryption and using secure authentication protocols, to protect your devices <span class="No-Break">and data.</span></p>
			<p>As soon as we <a id="_idIndexMarker536"/>have our vulnerable configuration in place, it’s time to connect using basic authentication. I have added a local user called <strong class="source-inline">PSSec</strong> on <strong class="source-inline">PSSec-PC01</strong>, which I will use in <span class="No-Break">this example.</span></p>
			<p>Let’s connect from <strong class="source-inline">PSSec-PC02</strong> to <strong class="source-inline">PSSec-PC01</strong> (the IP address is <strong class="source-inline">172.29.0.12</strong>) by using the <strong class="source-inline">-Authentication</strong> parameter while specifying <strong class="source-inline">Basic</strong>, as well as the credentials for the <span class="No-Break"><strong class="source-inline">PSSec</strong></span><span class="No-Break"> user:</span></p>
			<pre class="source-code">
&gt; $cred = Get-Credential -Credential "PSSec"
&gt; New-PSSession -ComputerName 172.29.0.12 -Authentication Basic -Credential $cred</pre>
			<p>The session is being established. If I track the traffic using Wireshark, I will see the SOAP requests that are being made. Even worse, I can see the <strong class="source-inline">Authorization</strong> header, which exposes the Base64-encrypted username <span class="No-Break">and password:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer072">
					<img alt="Figure 3.19 – Wireshark capture of authenticating using unencrypted basic authentication" src="image/B16679_03_019.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.19 – Wireshark capture of authenticating using unencrypted basic authentication</p>
			<p>Base64 can <a id="_idIndexMarker537"/>be easily decrypted, for example, with <span class="No-Break">PowerShell itself:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer073">
					<img alt="Figure 3.20 – Decrypting Base6﻿4-encrypted credentials" src="image/B16679_03_020.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.20 – Decrypting Base64-encrypted credentials</p>
			<p>So, an attacker can easily find out that the password of the <strong class="source-inline">PSSec</strong> user is <strong class="source-inline">PS-SecRockz1234!</strong> and can either inject the session as a man in the middle or use the password to impersonate the <strong class="source-inline">PSSec</strong> user – a great start when they’re attacking the <span class="No-Break">entire environment.</span></p>
			<p>I hope I made the risks of basic authentication and unencrypted sessions more transparent so that you will try this configuration in test environments only – and avoid it <span class="No-Break">in production.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor082"/>PowerShell remoting and credential theft</h2>
			<p>Depending <a id="_idIndexMarker538"/>on the authentication <a id="_idIndexMarker539"/>method that is used, credentials can be entered into the remote system, which can be stolen by an adversary. If you are interested in learning more about <strong class="bold">credential theft</strong> and mitigations, the <em class="italic">Mitigating Pass-the-Hash (PtH) Attacks and Other Credential Theft</em> white papers are a valuable <span class="No-Break">resource: </span><a href="https://www.microsoft.com/en-us/download/details.aspx?id=36036"><span class="No-Break">https://www.microsoft.com/en-us/download/details.aspx?id=36036</span></a><span class="No-Break">.</span></p>
			<p>By default, PSRemoting does not leave credentials on the target system, which makes PowerShell an awesome <span class="No-Break">administration tool.</span></p>
			<p>But if, for example, PSRemoting with CredSSP is used, the credentials enter the remote system, where they can be extracted and used to <span class="No-Break">impersonate identities.</span></p>
			<p>Keep in mind that when using CredSSP as an authentication mechanism, the credentials used to authenticate to the remote system are cached on that system. While this is convenient for single sign-on purposes, it also makes those cached credentials vulnerable to theft. If you can avoid it, do not use CredSSP as an authentication mechanism. But if you choose to use CredSSP, it is recommended that you enable Credential Guard to help mitigate <span class="No-Break">this risk.</span></p>
			<p>We will have a closer look at authentication and how the infamous pass-the-hash attack works in <a href="B16679_06_Final_PD.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Active Directory – Attacks </em><span class="No-Break"><em class="italic">and Mitigation</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor083"/>Executing commands using PowerShell remoting</h1>
			<p>Sometimes, you <a id="_idIndexMarker540"/>may want to run a <a id="_idIndexMarker541"/>command remotely but have not configured PSRemoting. Some cmdlets provide built-in remoting technologies that can <span class="No-Break">be leveraged.</span></p>
			<p>All commands that offer a built-in remoting technology have one thing in common: typically, they all have a parameter called <strong class="source-inline">-ComputerName</strong> to specify the <span class="No-Break">remote endpoint.</span></p>
			<p>To get a list of locally available commands that have the option to run tasks remotely, use the <strong class="source-inline">Get-Command -CommandType Cmdlet -ParameterName </strong><span class="No-Break"><strong class="source-inline">ComputerName</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
&gt; Get-Command -ParameterName ComputerName
CommandType  Name               Version    Source
-----------  ----               -------    ------
Cmdlet       Connect-PSSession  3.0.0.0    Microsoft.PowerShell.Core
Cmdlet       Enter-PSSession    3.0.0.0    Microsoft.PowerShell.Core
Cmdlet       Get-PSSession      3.0.0.0    Microsoft.PowerShell.Core
Cmdlet       Invoke-Command     3.0.0.0    Microsoft.PowerShell.Core
Cmdlet       New-PSSession      3.0.0.0    Microsoft.PowerShell.Core
Cmdlet       Receive-Job        3.0.0.0    Microsoft.PowerShell.Core
Cmdlet       Receive-PSSession  3.0.0.0    Microsoft.PowerShell.Core
Cmdlet       Remove-PSSession   3.0.0.0    Microsoft.PowerShell.Core</pre>
			<p>Please note that<a id="_idIndexMarker542"/> this list is <span class="No-Break">not complete.</span></p>
			<p>Cmdlets<a id="_idIndexMarker543"/> with a <strong class="source-inline">-ComputerName</strong> parameter do not necessarily use WinRM. Some use WMI, many others use RPC – it depends on the underlying technology of <span class="No-Break">the cmdlet.</span></p>
			<p>As every cmdlet has an underlying protocol, its firewall configuration and services need to be configured accordingly. This could mean a big management overhead. So, when managing environments remotely, it makes sense to configure PSRemoting accordingly: using WinRM is firewall-friendly and easier to configure <span class="No-Break">and maintain.</span></p>
			<p class="callout-heading">Do not be confused!</p>
			<p class="callout">PSRemoting should not be confused with using the <strong class="source-inline">-ComputerName</strong> parameter of a cmdlet to execute it on a remote computer. They are distinct approaches with different capabilities and usage scenarios. Those cmdlets that utilize the <strong class="source-inline">-ComputerName</strong> parameter rely on their underlying protocols, which often need a separate firewall exception rule <span class="No-Break">to run.</span></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor084"/>Executing single commands and script blocks</h2>
			<p>You<a id="_idIndexMarker544"/> can <em class="italic">execute a single command</em> or <em class="italic">entire script blocks</em> on a remote or local computer using the <span class="No-Break"><strong class="source-inline">Invoke-Command</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
Invoke-Command -ComputerName &lt;Name&gt; -ScriptBlock {&lt;ScriptBlock&gt;}</pre>
			<p>The following<a id="_idIndexMarker545"/> example shows how to restart the printer spooler on the <strong class="source-inline">PSSec-PC01</strong> remote computer, which is displaying <span class="No-Break">verbose output:</span></p>
			<pre class="source-code">
&gt; Invoke-Command -ComputerName PSSec-PC01 -ScriptBlock { Restart-Service -Name Spooler -Verbose }
VERBOSE: Performing the operation "Restart-Service" on target "Print Spooler (Spooler)".</pre>
			<p><strong class="source-inline">Invoke-Command</strong> is a great option for running local scripts and commands on a <span class="No-Break">remote computer.</span></p>
			<p>If you don’t want to copy the same scripts to your remote machine(s), you can use <strong class="source-inline">Invoke-Command</strong> with the <strong class="source-inline">-FilePath</strong> parameter to <em class="italic">run the local script on the </em><span class="No-Break"><em class="italic">remote system</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Invoke-Command -ComputerName PSSec-PC01 -FilePath c:\tmp\test.ps1</pre>
			<p>When using the <strong class="source-inline">-FilePath</strong> parameter with <strong class="source-inline">Invoke-Command</strong>, it is important to keep in mind that any dependencies required by the script (such as other scripts or commands) must also be present on the remote system. Otherwise, the script will not run <span class="No-Break">as expected.</span></p>
			<p>You can also <em class="italic">execute commands on multiple systems</em> – just specify all the remote systems that you want to execute your command or script on in the <strong class="source-inline">-ComputerName</strong> parameter. The <a id="_idIndexMarker546"/>following command <a id="_idIndexMarker547"/>restarts the print spooler on <strong class="source-inline">PSSec-PC01</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">PSSec-PC02</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Invoke-Command -ComputerName PSSec-PC01,PSSec-PC02 {Restart-Service -Name Spooler}</pre>
			<p>Please have a look at the official PowerShell documentation to learn all options that <strong class="source-inline">Invoke-Command</strong> has to <span class="No-Break">offer: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/invoke-command"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/invoke-command</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor085"/>Working with PowerShell sessions</h2>
			<p>The <strong class="source-inline">-Session</strong> parameter<a id="_idIndexMarker548"/> indicates that a cmdlet or function supports sessions <span class="No-Break">within PSRemoting.</span></p>
			<p>To find all locally available commands that support the <strong class="source-inline">-Session</strong> parameter, you can use the <strong class="source-inline">Get-Command -ParameterName </strong><span class="No-Break"><strong class="source-inline">session</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer074">
					<img alt="Figure 3.21 – All commands that provide a session parameter" src="image/B16679_03_021.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.21 – All commands that provide a session parameter</p>
			<p>All local commands that provide a <strong class="source-inline">-Session</strong> parameter will <span class="No-Break">be shown.</span></p>
			<h3>Interactive sessions</h3>
			<p>By leveraging <a id="_idIndexMarker549"/>the <strong class="source-inline">Enter-PSSession</strong> command, you can initiate an interactive session. Once the session has been established, you can work on the remote <span class="No-Break">system’s shell:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer075">
					<img alt="Figure 3.22 – Entering a PowerShell session, executing a command, and exiting the session" src="image/B16679_03_022.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.22 – Entering a PowerShell session, executing a command, and exiting the session</p>
			<p>Once your<a id="_idIndexMarker550"/> work is finished, use <strong class="source-inline">Exit-PSSession</strong> to close the session and the <span class="No-Break">remote connection.</span></p>
			<h3>Persistent sessions</h3>
			<p>The <strong class="source-inline">New-PSSession</strong> cmdlet <a id="_idIndexMarker551"/>can be utilized to establish a <span class="No-Break">persistent session.</span></p>
			<p>As in a former example, we use <strong class="source-inline">Get-Credential</strong> once more to store our credentials as a secure string in the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">cred</strong></span><span class="No-Break"> variable.</span></p>
			<p>Using the following command, we create two sessions for the <strong class="source-inline">PSSec-PC01</strong> and <strong class="source-inline">PSSec-PC01</strong> remote computers to <span class="No-Break">execute commands:</span></p>
			<pre class="source-code">
$sessions = New-PSSession -ComputerName PSSec-PC01, PSSec-PC02 -Credential $cred</pre>
			<p>To display all active sessions, you can use the <span class="No-Break"><strong class="source-inline">Get-PSSession</strong></span><span class="No-Break"> command:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer076">
					<img alt="Figure 3.23 – Creating persistent sessions and displaying them" src="image/B16679_03_023.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.23 – Creating persistent sessions and displaying them</p>
			<p>Now, you can use the <strong class="source-inline">$sessions</strong> variable to run commands in all remote computer sessions that <span class="No-Break">you’ve specified.</span></p>
			<p>A common <a id="_idIndexMarker552"/>use case is to check whether all security updates were applied to your remote computers. In this case, we want to check whether the <strong class="source-inline">KB5023773</strong> hotfix is installed on all remote computers. We also don’t want any error messages to be displayed if the hotfix was not found, so we will use the <strong class="source-inline">-ErrorAction SilentlyContinue</strong> parameter in our <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
Invoke-Command –Session $sessions -ScriptBlock { Get-Hotfix -Id 'KB5023773' -ErrorAction SilentlyContinue }</pre>
			<p>The following is the output we get after running <span class="No-Break">this command:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer077">
					<img alt="Figure 3.24 – Running a command in all specified sessions" src="image/B16679_03_024.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.24 – Running a command in all specified sessions</p>
			<p>As it turns out, the hotfix is only installed on <strong class="source-inline">PSSec-PC01</strong> but is missing on the second <span class="No-Break">computer, </span><span class="No-Break"><strong class="source-inline">PSSec-02</strong></span><span class="No-Break">.</span></p>
			<p>To act on this and install the missing update, we can either send more commands directly into the session or we can enter the session interactively by specifying the session ID – that is, <strong class="source-inline">Enter-PSSession -</strong><span class="No-Break"><strong class="source-inline">Id 2</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer078">
					<img alt="Figure 3.25 – Entering a persistent session, running a command, and exiting it again" src="image/B16679_03_025.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.25 – Entering a persistent session, running a command, and exiting it again</p>
			<p>Now that we have entered the session, we can run the <strong class="source-inline">Get-WindowsUpdate</strong> command to install the missing update. Please note that this command is not available by default and requires you to install the <span class="No-Break"><strong class="source-inline">PSWindowsUpdate</strong></span><span class="No-Break"> module:</span></p>
			<pre class="source-code">
Get-WindowsUpdate -Install -KBArticleID 'KB5023773'</pre>
			<p>After our command has run, we can exit the session using <strong class="source-inline">Exit-PSSession</strong>, which only disconnects us from the session but leaves the <span class="No-Break">session open.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are using an interactive session, all executed modules, such as <strong class="source-inline">PSWindowsUpdate</strong>, need to be installed on the remote system. If you use <strong class="source-inline">Invoke-Command</strong> to run commands in a persistent session, the module only needs to be installed on the computer that you use to run <span class="No-Break">the commands:</span></p>
			<p class="callout"><strong class="bold">Invoke-Command – Session $sessions -ScriptBlock { Get-WindowsUpdate -Install -</strong><span class="No-Break"><strong class="bold">KBArticleID ‘KB5023773’}</strong></span></p>
			<p>If we check<a id="_idIndexMarker553"/> for <strong class="source-inline">KB5023773</strong> after some time, we will see that the update <span class="No-Break">was installed:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer079">
					<img alt="Figure 3.26 – The update was installed successfully" src="image/B16679_03_026.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.26 – The update was installed successfully</p>
			<p>As soon as we are finished with our work and if we don’t need our sessions anymore, we can remove them using the <span class="No-Break"><strong class="source-inline">Remove-PSSession</strong></span><span class="No-Break"> command:</span></p>
			<ul>
				<li>Here, we can use the <strong class="source-inline">$sessions</strong> variable, which we <span class="No-Break">specified earlier:</span><pre class="source-code">
<strong class="bold">Remove-PSSession -Session $sessions</strong></pre></li>
				<li>Alternatively, we can remove a single session by using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> parameter:</span><pre class="source-code">
<strong class="bold">Remove-PSSession -id 2</strong></pre></li>
			</ul>
			<p>After removing one or all session(s), you can use <strong class="source-inline">Get-PSSession</strong> to <span class="No-Break">verify this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer080">
					<img alt="Figure 3.27 – Removing all persistent sessions" src="image/B16679_03_027.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.27 – Removing all persistent sessions</p>
			<p>Executing commands using PSRemoting can simplify your daily administration workload immensely. Now that you have learned the basics, you can combine it with your PowerShell scripting knowledge. What problems will you solve and what tasks will <span class="No-Break">you automate?</span></p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor086"/>Best practices</h1>
			<p>To ensure optimal security and performance when using PSRemoting, it’s important to follow the best practices enforced by the product. These practices are designed to minimize the risk of <a id="_idIndexMarker554"/>security breaches and ensure that your remote management tasks <span class="No-Break">run smoothly.</span></p>
			<p><span class="No-Break"><strong class="bold">Authentication</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>If possible, use only Kerberos or <span class="No-Break">NTLM authentication.</span></li>
				<li>Avoid CredSSP and basic authentication <span class="No-Break">whenever possible.</span></li>
				<li>In the best case, restrict the usage of all other authentication mechanisms <span class="No-Break">besides Kerberos/NTLM.</span></li>
				<li>SSH remoting – configure public key authentication and keep the private <span class="No-Break">key protected.</span></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Limit connections</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Limit connections via firewall from a management subnet (hardware and software <span class="No-Break">if possible/available).</span></li>
			</ul>
			<p>PSRemoting’s default firewall policies differ based on the network profile. In a <strong class="bold">Domain</strong>, <strong class="bold">Workgroup</strong>, or <strong class="bold">Private</strong> network profile, PSRemoting is available to all by default (assuming they have valid credentials). In a <strong class="bold">Public</strong> profile, PSRemoting refuses to listen to that adapter by default. If you force it to, the network rule will limit access to only systems on the same <span class="No-Break">network subnet.</span></p>
			<ul>
				<li>Use a secure management system to manage systems via PSRemoting. Consider limiting connections from a management <strong class="bold">virtual network</strong> (<strong class="bold">VNet</strong>) if you have one, which also applies to other management protocols such as RDP, WMI, CIM, <span class="No-Break">and others.</span></li>
				<li>Use a secure management system to manage systems via PSRemoting. Use the clean source principle to build the management system and use the recommended <a id="_idIndexMarker555"/>privileged <span class="No-Break">access model:</span><ul><li><a href="https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-success-criteria#clean-source-principle"><span class="No-Break">https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-success-criteria#clean-source-principle</span></a></li><li><a href="https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-access-model"><span class="No-Break">https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-access-model</span></a></li></ul></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Restrict sessions</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Use constrained language <span class="No-Break">and JEA.</span></li>
				<li>You will learn more about JEA, constrained language, session security, and SDDLs in <a href="B16679_10_Final_PD.xhtml#_idTextAnchor278"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Language Modes and Just Enough </em><span class="No-Break"><em class="italic">Administration (JEA).</em></span></li>
			</ul>
			<p><strong class="bold">Audit </strong><span class="No-Break"><strong class="bold">insecure settings</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Use the WinRM group policy to enforce secure PSRemoting settings on all managed systems, including encryption and <span class="No-Break">authentication requirements.</span></li>
				<li><strong class="source-inline">Get-Item WSMan:\localhost\Client\AllowUnencrypted</strong>: This setting should <em class="italic">not</em> be set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">$true</strong></span><span class="No-Break">.</span></li>
				<li>Audit insecure WinRM settings regularly to ensure compliance with <span class="No-Break">security policies:</span><pre class="source-code">
Get-Item WSMan:\localhost\client\AllowUnencrypted</pre><pre class="source-code">
Get-Item wsman:\localhost\service\AllowUnencrypted</pre><pre class="source-code">
Get-Item wsman:\localhost\client\auth\Basic</pre><pre class="source-code">
Get-Item wsman:\localhost\service\auth\Basic</pre></li>
				<li>Eventually, use <strong class="bold">Desired State Configuration</strong> (<strong class="bold">DSC</strong>) to audit and apply <span class="No-Break">your settings.</span></li>
			</ul>
			<p><strong class="bold">And all other mitigation methods mentioned in the previous chapter, especially </strong><span class="No-Break"><strong class="bold">the following</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Enable logging and transcription and monitor event logs. You can read more about this in <a href="B16679_04_Final_PD.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Detection – Auditing </em><span class="No-Break"><em class="italic">and Monitoring</em></span><span class="No-Break">.</span></li>
				<li>Eliminate unnecessary local and <span class="No-Break">domain administrators</span></li>
				<li>Enable and enforce script signing. You will learn more about script signing in <a href="B16679_11_Final_PD.xhtml#_idTextAnchor306"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">AppLocker, Application Control, and </em><span class="No-Break"><em class="italic">Code Signing</em></span><span class="No-Break">.</span></li>
				<li>Configure <strong class="bold">DSC</strong> to harden your systems and control your <span class="No-Break">system configuration.</span></li>
			</ul>
			<p>PSRemoting is <a id="_idIndexMarker556"/>a great way to administrate your systems efficiently. Of course, it is only as secure as you configure it to be. If the right configuration is in place, administration via PSRemoting is even more secure than logging <span class="No-Break">in interactively.</span></p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor087"/>Summary</h1>
			<p>After reading this chapter, you should be familiar with how to use PowerShell remotely, using PSRemoting. You learned what options exist in PowerShell to establish remote connections, which enables you to not only manage Windows machines but also other operating systems, such as macOS <span class="No-Break">and Linux.</span></p>
			<p>You also learned what endpoints are and can create basic custom endpoints. You will strengthen this ability later in <a href="B16679_10_Final_PD.xhtml#_idTextAnchor278"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Language Modes and Just Enough Administration (JEA)</em>, but you already know <span class="No-Break">the basics.</span></p>
			<p>Then, you learned a lot about authentication protocols that can be used and even more about security considerations when working with those protocols. You should also be aware of how easily an adversary can obtain decrypted credentials if a weak authentication protocol <span class="No-Break">is used.</span></p>
			<p>You should now be able to configure PSRemoting manually and centrally, which helps you set up your initial PSRemoting configuration in your <span class="No-Break">production environment.</span></p>
			<p>Last but not least, you learned how to execute commands using PSRemoting, which enables you to not only run one command on one device – you can also automate your tedious <span class="No-Break">administration tasks.</span></p>
			<p>When working with PowerShell – either remotely or locally – auditing and monitoring are very important topics. Using transcriptions and event logging helps the Blue Team detect adversaries and protect <span class="No-Break">their environment.</span></p>
			<p>Therefore, now that you are familiar with PSRemoting, we’ll look at detection and logging within PowerShell in the <span class="No-Break">next chapter.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor088"/>Further reading</h1>
			<p>If you want to explore some of the topics that were mentioned in this chapter, take a look at <span class="No-Break">these resources.</span></p>
			<p><span class="No-Break"><strong class="bold">Authentication</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>RFC 2617 – HTTP authentication (basic and digest <span class="No-Break">authentication): </span><a href="https://tools.ietf.org/html/rfc2617"><span class="No-Break">https://tools.ietf.org/html/rfc2617</span></a></li>
				<li><strong class="bold">Credential Security Support Provider</strong> (<span class="No-Break"><strong class="bold">CredSSP</strong></span><span class="No-Break">) protocol:</span><ul><li><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/85f57821-40bb-46aa-bfcb-ba9590b8fc30"><span class="No-Break">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/85f57821-40bb-46aa-bfcb-ba9590b8fc30</span></a><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-cssp/85f57821-40bb-46aa-bfcb-ba9590b8fc30&#13;"/></li><li><a href="https://ldapwiki.com/wiki/Wiki.jsp?page=CredSSP"><span class="No-Break">https://ldapwiki.com/wiki/Wiki.jsp?page=CredSSP</span></a></li></ul></li>
				<li>Public <span class="No-Break">key authentication:</span><ul><li><a href="https://en.wikipedia.org/wiki/Public-key_cryptography"><span class="No-Break">https://en.wikipedia.org/wiki/Public-key_cryptography</span></a></li><li><a href="https://www.ssh.com/ssh/public-key-authentication"><span class="No-Break">https://www.ssh.com/ssh/public-key-authentication</span></a></li></ul></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">CIM</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>CIM <span class="No-Break">cmdlets: </span><a href="https://devblogs.microsoft.com/powershell/introduction-to-cim-cmdlets/"><span class="No-Break">https://devblogs.microsoft.com/powershell/introduction-to-cim-cmdlets/</span></a></li>
				<li>CIM standard by <span class="No-Break">DMTF: </span><a href="https://www.dmtf.org/standards/cim"><span class="No-Break">https://www.dmtf.org/standards/cim</span></a></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">DCOM</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">DCOM</strong> remote <span class="No-Break">protocol: </span><a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/4a893f3d-bd29-48cd-9f43-d9777a4415b0"><span class="No-Break">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/4a893f3d-bd29-48cd-9f43-d9777a4415b0</span></a></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">OMI</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Open Management Infrastructure (<span class="No-Break">OMI): </span><a href="https://cloudblogs.microsoft.com/windowsserver/2012/06/28/open-management-infrastructure/"><span class="No-Break">https://cloudblogs.microsoft.com/windowsserver/2012/06/28/open-management-infrastructure/</span></a></li>
			</ul>
			<p><strong class="bold">Other </strong><span class="No-Break"><strong class="bold">useful resources</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><span class="No-Break">New-NetFirewallRule: </span><a href="https://learn.microsoft.com/en-us/powershell/module/netsecurity/new-netfirewallrule"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/netsecurity/new-netfirewallrule</span></a></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">PowerShell remoting</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>[MS-PSRP]: PowerShell remoting <span class="No-Break">protocol: </span><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/602ee78e-9a19-45ad-90fa-bb132b7cecec"><span class="No-Break">https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/602ee78e-9a19-45ad-90fa-bb132b7cecec</span></a><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-psrp/602ee78e-9a19-45ad-90fa-bb132b7cecec&#13;"/></li>
				<li>Running Remote <span class="No-Break">Commands: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/running-remote-commands"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/running-remote-commands</span></a><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/running-remote-commands&#13;"/></li>
				<li>WS-Man Remoting in PowerShell <span class="No-Break">Core: </span><a href="https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/wsman-remoting-in-powershell-core?view=powershell-7.3"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/learn/remoting/wsman-remoting-in-powershell-core?view=powershell-7.3</span></a></li>
				<li>WS-Man specifications by <span class="No-Break">DMTF: </span><a href="https://www.dmtf.org/standards/ws-man"><span class="No-Break">https://www.dmtf.org/standards/ws-man</span></a></li>
				<li>WinRM <span class="No-Break">security: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/winrmsecurity"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/winrmsecurity</span></a><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/winrmsecurity&#13;"/></li>
				<li>PowerShell <span class="No-Break">endpoints: </span><a href="https://devblogs.microsoft.com/scripting/introduction-to-powershell-endpoints/"><span class="No-Break">https://devblogs.microsoft.com/scripting/introduction-to-powershell-endpoints/</span></a><a href="https://devblogs.microsoft.com/scripting/introduction-to-powershell-endpoints/&#13;"/></li>
				<li>PSRemoting over <span class="No-Break">SSH: </span><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core</span></li>
				<li>The second <span class="No-Break">hop: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop</span></a><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop&#13;"/></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">WMI</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><span class="No-Break">Get-WmiObject: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject</span></a><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-wmiobject&#13;"/></li>
				<li><span class="No-Break">Invoke-WmiMethod: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/invoke-wmimethod"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/invoke-wmimethod</span></a><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/invoke-wmimethod&#13;"/></li>
				<li><span class="No-Break">Register-WmiEvent: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/register-wmievent&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/register-wmievent</span></a></li>
				<li><span class="No-Break">Remove-WmiObject: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/remove-wmiobject&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/remove-wmiobject</span></a></li>
				<li><span class="No-Break">Set-WmiInstance: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-wmiinstance&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/set-wmiinstance</span></a></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">WS-Man</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>WS-Man standard by <span class="No-Break">DMTF: </span><a href="https://www.dmtf.org/standards/ws-man&#13;"><span class="No-Break">https://www.dmtf.org/standards/ws-man</span></a></li>
				<li>WS-Management Remoting in PowerShell <span class="No-Break">Core: </span><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/wsman-remoting-in-powershell-core</span></li>
			</ul>
			<p>You can also find all the links mentioned in this chapter in the GitHub repository for <a href="B16679_03_Final_PD.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> – there’s no need to manually type in every <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter03/Links.md"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter03/Links.md</span></a><span class="No-Break">.</span></p>
		</div>
	</body></html>