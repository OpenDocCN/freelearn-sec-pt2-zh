<html><head></head><body>
		<div id="_idContainer108">
			<h1 class="chapter-number" id="_idParaDest-84"><a id="_idTextAnchor089"/><a id="_idTextAnchor090"/>4</h1>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor091"/>Detection – Auditing and Monitoring</h1>
			<p>Although organizations already try to harden their environments, only a few take into account that auditing and monitoring are two of the most important things when it comes to securing <span class="No-Break">your environment.</span></p>
			<p>For many years while working at Microsoft, I have preached the <em class="italic">protect</em>, <em class="italic">detect</em>, and <em class="italic">respond</em> approach. Most companies try to just <em class="italic">protect</em> their devices, but that’s where they stop. To <em class="italic">detect</em> and <em class="italic">respond</em>, there <a id="_idIndexMarker557"/>needs to be not only a working <strong class="bold">Security Operations Center</strong> (<strong class="bold">SOC</strong>) in place but also infrastructure <span class="No-Break">and resources.</span></p>
			<p>Those people and resources require money – a budget that many companies don’t want to spend in the first place, unless they have <span class="No-Break">been breached.</span></p>
			<p>When working with customers, I saw only a few environments with a working SOC in place, as well <a id="_idIndexMarker558"/>as the infrastructure to host a <strong class="bold">Security Information and Event Management</strong> (<strong class="bold">SIEM</strong>) system. I was really happy that when I left those customers, most of them started rethinking their approach and improved their security practices, as well as their monitoring <span class="No-Break">and detection.</span></p>
			<p>However, I also had customers that were already breached when I was introduced to them for the first time. Customers that never had the budget nor employees for detections suddenly had the budget to improve immediately, as soon as they <span class="No-Break">were breached.</span></p>
			<p>And over the years, I learned that it’s not a question of <em class="italic">whether</em> an organization will be hacked – it is rather <em class="italic">when</em> they will be hacked, and <em class="italic">how long</em> the attacker stays in the environment unnoticed. That’s if they are detected <span class="No-Break">at all.</span></p>
			<p>Therefore, I recommend to every IT decision-maker that I meet to <em class="italic">assume a breach</em> and protect what <span class="No-Break">is important.</span></p>
			<p>Over the years, I saw more and more organizations that actually had operating SOCs in place, which made me really happy. But unfortunately – especially when looking at small and medium-sized enterprises – most organizations have either no monitoring in place or are just starting <span class="No-Break">their journey.</span></p>
			<p>PowerShell has been covered in the media several times when it comes to attacks. Ransomware malware was distributed, sending malicious emails that launched PowerShell in the background to execute a payload, a fileless attack in which the malware does not need to be downloaded on the client but runs in the memory instead, and even <a id="_idIndexMarker559"/>legitimate system tools that have been abused by adversaries to execute their attacks (also known as <strong class="bold">Living Off the Land</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="bold">LOLbins</strong></span><span class="No-Break">).</span></p>
			<p>And yes, attackers like to leverage what they already find on a system. However, if organizations had not only the appropriate mitigations in place but also the right detection, it would make it way harder for adversaries to launch a successful attack and <span class="No-Break">stay unnoticed.</span></p>
			<p>Many tools that adversaries use in their attacks provide little to no transparency, so it can be really hard for defenders (a.k.a. the <strong class="bold">blue team</strong>) to detect and analyze such <span class="No-Break">an attack.</span></p>
			<p>PowerShell, in contrast, provides such amazing logging opportunities that it is quite easy to analyze and detect an attack that was launched using it. Therefore, if you are a blue teamer and you notice that you were targeted with a PowerShell-based attack, you are in luck (as much as you can be in luck if your infrastructure was attacked)! This makes it much easier for you to find out <span class="No-Break">what happened.</span></p>
			<p>Having an extensive (not exclusively restricted to) PowerShell logging infrastructure in place helps your SOC team to identify attackers and get insights into what commands and code adversaries executed. It also helps to improve your detection and <span class="No-Break">security controls.</span></p>
			<p>In this chapter, you will learn the basics of security monitoring with PowerShell, which will help you to get started with your detections or improve them. In this chapter, you will get a deeper understanding of the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Configuring PowerShell <span class="No-Break">Event Logging</span></li>
				<li>PowerShell <span class="No-Break">Module Logging</span></li>
				<li>PowerShell Script <span class="No-Break">Block Logging</span></li>
				<li>Protected <span class="No-Break">Event Logging</span></li>
				<li><span class="No-Break">PowerShell transcripts</span></li>
				<li>Analyzing <span class="No-Break">event logs</span></li>
				<li>Getting started <span class="No-Break">with logging</span></li>
				<li>The most important PowerShell related event logs <span class="No-Break">and IDs</span></li>
			</ul>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor092"/>Technical requirements</h1>
			<p>To get the most out of this chapter, ensure that you have <span class="No-Break">the following:</span></p>
			<ul>
				<li>PowerShell 7.3 <span class="No-Break">and above.</span></li>
				<li>Access to the GitHub repository <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Chapter04</strong></span><span class="No-Break">:</span></li>
			</ul>
			<p><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter04</span></a></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor093"/>Configuring PowerShell Event Logging</h1>
			<p>Implementing <a id="_idIndexMarker560"/>robust auditing mechanisms for PowerShell to help you monitor, detect and prevent potential threats is an essential step to ensure effective security practices for PowerShell. By leveraging PowerShell logging, you can capture detailed information about PowerShell activities on your systems, which is essential for detecting and investigating security incidents. PowerShell logging can help you identify suspicious activities, such as the execution of malicious commands or the modification of critical <span class="No-Break">system settings.</span></p>
			<p>In this section, we will discuss the different types of PowerShell logging that you can enable, including PowerShell Module Logging, PowerShell Script Block Logging, Protected Event <a id="_idIndexMarker561"/>Logging, and PowerShell transcripts. We will also look into how to configure these logging features to meet your organization’s specific <span class="No-Break">security requirements.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor094"/>PowerShell Module Logging</h2>
			<p>PowerShell Module Logging <a id="_idIndexMarker562"/>was added with <strong class="bold">PowerShell 3.0</strong>. This feature <a id="_idIndexMarker563"/>provides extensive logging of all PowerShell commands that are executed on the system. If Module Logging is enabled, pipeline execution events are generated and written to the <strong class="source-inline">Microsoft-Windows-Powershell/Operational</strong> event log in the context of event <span class="No-Break">ID</span><span class="No-Break"><strong class="source-inline"> 4103</strong></span><span class="No-Break">.</span></p>
			<h3>How to configure Module Logging</h3>
			<p>You can either <a id="_idIndexMarker564"/>enable Module Logging for the execution of a module in the current session, or you can configure it to be turned <span class="No-Break">on permanently.</span></p>
			<p>Enabling it only within a single session only makes sense if you want to troubleshoot the behavior of a certain module. If you want to detect the commands that adversaries run in your infrastructure, it makes sense to turn on Module <span class="No-Break">Logging permanently.</span></p>
			<p>To enable Module Logging within the current session, only for a certain module, you need to import the module first. In this example, we will use the <span class="No-Break"><strong class="source-inline">EventList</strong></span><span class="No-Break"> module:</span></p>
			<pre class="source-code">
&gt; Import-Module EventList
&gt; (Get-Module EventList).LogPipelineExecutionDetails = $true
&gt; (Get-Module EventList).LogPipelineExecutionDetails
True</pre>
			<p>Of course, you can replace the module name, <strong class="source-inline">EventList</strong>, with any other module name that you want to log pipeline execution <span class="No-Break">details for:</span></p>
			<pre class="source-code">
Import-Module &lt;Module-Name&gt;
(Get-Module &lt;Module-Name&gt;).LogPipelineExecutionDetails = $true</pre>
			<p>If you want to monitor a managed environment, you don’t want to enable PowerShell Module Logging <a id="_idIndexMarker565"/>manually on every host. In this case, you can use Group Policy to enable <span class="No-Break">Module Logging.</span></p>
			<p>Create a new <strong class="bold">Group Policy Object</strong> (<strong class="bold">GPO</strong>). As Windows PowerShell and PowerShell Core were <a id="_idIndexMarker566"/>designed to co-exist and can be configured individually, it depends on what PowerShell version you want <span class="No-Break">to configure:</span></p>
			<ul>
				<li>To configure Windows PowerShell, navigate to <strong class="bold">Computer Configuration</strong> | <strong class="bold">Policies</strong> | <strong class="bold">Administrative Templates</strong> | <strong class="bold">Windows Components</strong> | <span class="No-Break"><strong class="bold">Windows PowerShell</strong></span></li>
				<li>To configure PowerShell Core, navigate to <strong class="bold">Computer Configuration</strong> | <strong class="bold">Administrative Templates</strong> | <span class="No-Break"><strong class="bold">PowerShell Core</strong></span></li>
			</ul>
			<p class="callout-heading">Where are my PowerShell Core .admx templates?</p>
			<p class="callout">If you haven’t imported the <strong class="source-inline">.admx</strong> templates into your Group Policies yet to configure PowerShell Core, please refer to <a href="B16679_01_Final_PD.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Getting Started </em><span class="No-Break"><em class="italic">with PowerShell</em></span><span class="No-Break">.</span></p>
			<p>Select and edit the <strong class="bold">Turn on Module Logging</strong> policy. A window opens to configure <span class="No-Break">Module Logging:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer082">
					<img alt="Figure 4.1 – Configur﻿ing Module Logging for Windows PowerShell via Group Policy" src="image/B16679_04_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Configuring Module Logging for Windows PowerShell via Group Policy</p>
			<p>For PowerShell <a id="_idIndexMarker567"/>Core, the configuration Window looks almost the same, except for the <strong class="bold">Use Windows PowerShell Policy setting.</strong> option. If this option is selected, PowerShell Core relies on the existing Windows <span class="No-Break">PowerShell configuration.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer083">
					<img alt="Figure 4.2 – Configure Module Logging for PowerShell Core via Group Policy" src="image/B16679_04_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Configure Module Logging for PowerShell Core via Group Policy</p>
			<p>Enable <strong class="bold">Use Windows PowerShell Policy setting</strong> if you want to only use one GPO for your Module Logging configuration. Next, depending on your configuration, either in the Windows PowerShell or PowerShell Core Module Logging GPO, go to <strong class="bold">Module Names</strong>, and click on the <strong class="bold">Show…</strong> button to configure the <a id="_idIndexMarker568"/>modules for which Module Logging should be turned on. A new <span class="No-Break">window opens.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer084">
					<img alt="Figure 4.3 – Configuring a wildcard (*) to log all modules" src="image/B16679_04_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Configuring a wildcard (*) to log all modules</p>
			<p>Now, you can configure single modules for which Module Logging should be turned on, but for security monitoring, it makes sense to monitor all Module Logging events – no matter which module <span class="No-Break">was executed.</span></p>
			<p>You can achieve this by configuring a wildcard (<strong class="source-inline">*</strong>) as a module name. Confirm twice with <strong class="bold">OK</strong> and exit the GPO editor to make your <span class="No-Break">changes active.</span></p>
			<p>Of course, you can also add Module Logging for a single instance instead of monitoring all of them by specifying the <a id="_idIndexMarker569"/>module name as a value. However, I recommend logging all PowerShell activity (<strong class="source-inline">*</strong>), which is especially useful if adversaries import custom <span class="No-Break">PowerShell modules.</span></p>
			<p>All events generated by this configuration can be found in the Microsoft Windows PowerShell Operational event <span class="No-Break">log (</span><span class="No-Break"><strong class="source-inline">Microsoft-Windows-Powershell/Operational</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor095"/>PowerShell Script Block Logging</h2>
			<p>A <strong class="bold">script block</strong> is a collection <a id="_idIndexMarker570"/>of expressions and commands that is grouped together and executed as one unit. Of course, a single command can be also executed as a <span class="No-Break">script block.</span></p>
			<p>Many <a id="_idIndexMarker571"/>commands support the <strong class="source-inline">-ScriptBlock</strong> parameter, such as the <strong class="source-inline">Invoke-Command</strong> command. which you can use to run entire script blocks, locally <span class="No-Break">or remotely:</span></p>
			<pre class="source-code">
&gt; Invoke-Command -ComputerName PSSec-PC01 -ScriptBlock {Restart-Service -Name Spooler -Verbose}
VERBOSE: Performing the operation "Restart-Service" on target "Print Spooler (Spooler)".</pre>
			<p>It is important to note that all actions performed in PowerShell are considered script blocks and will be logged if <em class="italic">Script Block Logging</em> is enabled – regardless of whether or not they use the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">ScriptBlock</strong></span><span class="No-Break"> parameter.</span></p>
			<p>Most of the time, companies and organizations do not care about logging and event log analysis unless a security incident occurs. However, by that point, it is already too late to enable logging retroactively. Therefore, the PowerShell team made the decision that security-relevant script blocks should be logged <span class="No-Break">by default.</span></p>
			<p>Starting with PowerShell 5, a <em class="italic">basic version of Script Block Logging</em> is enabled by default – only scripting techniques that are commonly used in malicious attacks are written to the <strong class="source-inline">Microsoft-Windows-Powershell/Operational</strong> <span class="No-Break">event log.</span></p>
			<p>This basic version of Script Block Logging does not replace full Script Block Logging; it should only be considered as a last resort, if logging was not in place when an <span class="No-Break">attack happened.</span></p>
			<p>If you want <a id="_idIndexMarker572"/>to protect your environment and detect malicious activities, you still should consider turning on <em class="italic">full Script </em><span class="No-Break"><em class="italic">Block Logging</em></span><span class="No-Break">.</span></p>
			<p>Additionally, there’s an even more verbose option when configuring Script Block Logging – <em class="italic">Script Block </em><span class="No-Break"><em class="italic">Invocation Logging</em></span><span class="No-Break">.</span></p>
			<p>By default, only script blocks are logged the first time they are used. Configuring Script Block Invocation Logging also generates events every time script blocks are invoked and when scripts start <span class="No-Break">or stop.</span></p>
			<p>Enabling Script Block Invocation Logging can generate a high volume of events, which may flood the log and roll out useful security data from other events. Be careful with enabling Script Block Invocation Logging, as a high volume of events will be generated – usually, you don’t need it for <span class="No-Break">incident analysis.</span></p>
			<h3>How to configure Script Block Logging</h3>
			<p>There are several ways to configure Script Block Logging – manually as well as centrally <a id="_idIndexMarker573"/>managed. Let’s have a look at what needs to be configured to log all the code executed in <span class="No-Break">your environment.</span></p>
			<p>To manually enable Script Block Logging, you can edit the registry. The settings that you want to change are within the following <span class="No-Break">registry path:</span></p>
			<pre class="source-code">
HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging</pre>
			<p>Using the <strong class="source-inline">EnableScriptBlockLogging</strong> (<strong class="source-inline">REG_DWORD</strong>) registry key, you can configure to enable Script <span class="No-Break">Block Logging:</span></p>
			<ul>
				<li><strong class="bold">Enabled</strong>: Set the value to <strong class="source-inline">1</strong> to <span class="No-Break">enable it</span></li>
				<li><strong class="bold">Disabled</strong>: Set the value to <strong class="source-inline">0</strong> to <span class="No-Break">disable it</span></li>
			</ul>
			<p>If Script Block Logging is enabled, you will find all the executed code under event <span class="No-Break">ID </span><span class="No-Break"><strong class="source-inline">4104</strong></span><span class="No-Break">.</span></p>
			<p>Using the <strong class="source-inline">EnableScriptBlockInvocationLogging</strong> (<strong class="source-inline">REG_DWORD</strong>) registry key, you can configure it to enable Script Block Invocation Logging (event IDs <strong class="source-inline">4105</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">4106</strong></span><span class="No-Break">):</span></p>
			<ul>
				<li><strong class="bold">Enabled</strong>: Set the value to <strong class="source-inline">1</strong> to <span class="No-Break">enable it</span></li>
				<li><strong class="bold">Disabled</strong>: Set the value to <strong class="source-inline">0</strong> to <span class="No-Break">disable it</span></li>
			</ul>
			<p>If Script Block Logging, as well as Script Block Invocation Logging, is enabled, event IDs <strong class="source-inline">4105</strong> and <strong class="source-inline">4106</strong> will <span class="No-Break">be generated.</span></p>
			<p>If Script Block <a id="_idIndexMarker574"/>Invocation Logging is enabled, a lot of noise is generated and the log file size increases. Therefore, the maximum size should be reconfigured (see the <em class="italic">Increasing log size</em> section). For general security monitoring, you won’t need to configure verbose Script <span class="No-Break">Block Logging.</span></p>
			<p>You can configure Script Block Logging manually by running the following commands in an elevated <span class="No-Break">PowerShell console:</span></p>
			<pre class="source-code">
New-Item -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" -Force
Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" -Name "EnableScriptBlockLogging" -Value 1 -Force</pre>
			<p>The first command creates all the registry keys if they don’t exist yet, and the second one enables Script <span class="No-Break">Block Logging.</span></p>
			<p>When enabling <strong class="source-inline">ScriptBlockLogging</strong> using the described commands, <strong class="source-inline">ScriptBlockLogging</strong> will be enabled for both 32-bit and 64-bit applications. You can verify that both settings were configured under <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">HKLM:\HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">HKLM:\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging</strong></span></li>
			</ul>
			<p>In managed environments, it makes sense to manage your machines centrally. Of course, this <a id="_idIndexMarker575"/>can be done via PowerShell and/or <strong class="bold">Desired State Configuration</strong> (<strong class="bold">DSC</strong>), but it can be also done using <span class="No-Break">Group Policy.</span></p>
			<p>Create a new GPO. Depending on which PowerShell version you want to configure, navigate to either of <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Computer Configuration</strong> | <strong class="bold">Policies</strong> | <strong class="bold">Administrative Templates</strong> | <strong class="bold">Windows Components</strong> | <strong class="bold">Windows PowerShell</strong> for <span class="No-Break">Windows PowerShell</span></li>
				<li><strong class="bold">Computer Configuration</strong> | <strong class="bold">Administrative Templates</strong> | <strong class="bold">PowerShell Core</strong> for <span class="No-Break">PowerShell Core</span></li>
			</ul>
			<p>Select and edit the <strong class="bold">Turn on PowerShell Script Block Logging</strong> policy. A window will open to configure <span class="No-Break">Module Logging.</span></p>
			<p>If you <a id="_idIndexMarker576"/>decide to configure the <strong class="bold">Log script block invocation start / stop events</strong> option, a lot more events will be generated, and a lot of noise will be generated. Depending on your use case, this option might be interesting nevertheless, but if you have just started doing security monitoring, I advise to not turn on <span class="No-Break">this option.</span></p>
			<p class="callout-heading">Increasing the log size for Script Block Invocation Logging</p>
			<p class="callout">If Script Block Invocation Logging is enabled, using the <strong class="bold">Log script block invocation start / stop events</strong> option, the log file size increases, and the maximum size should <span class="No-Break">be reconfigured.</span></p>
			<p>Event ID<strong class="source-inline"> 4105</strong> and <strong class="source-inline">4106</strong> will only be generated if the <strong class="bold">Log script block invocation start / stop events</strong> option <span class="No-Break">is enabled.</span></p>
			<p>In our example, we will <em class="italic">not</em> configure <strong class="bold">Log script block invocation start / stop events</strong> to avoid noise; therefore, we’ll leave the <span class="No-Break">checkbox unchecked:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer085">
					<img alt="Figure 4.4 – Turning on PowerShell Script Block Logging for Windows PowerShell" src="image/B16679_04_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Turning on PowerShell Script Block Logging for Windows PowerShell</p>
			<p>In the PowerShell Core policy, you will – as with the PowerShell Module Logging policy and some <a id="_idIndexMarker577"/>other policies – find the option to use the current Windows PowerShell Policy setting as well for <span class="No-Break">PowerShell Core.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer086">
					<img alt="Figure 4.5 – Turning on PowerShell Script Block Logging for PowerShell Core" src="image/B16679_04_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Turning on PowerShell Script Block Logging for PowerShell Core</p>
			<p>All events generated by this configuration can be found in the Microsoft Windows PowerShell Operational event log (<strong class="source-inline">Microsoft-Windows-Powershell/Operational</strong>), or for PowerShell Core, in the PowerShell Core event <span class="No-Break">log (</span><span class="No-Break"><strong class="source-inline">PowerShellCore/Operational</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor096"/>Protected Event Logging</h2>
			<p>Event logging is a sensitive topic. Often, sensitive information such as passwords is exposed and written to the <span class="No-Break">event log.</span></p>
			<p>Sensitive <a id="_idIndexMarker578"/>information is pure gold in the hand of an adversary who has access to such a system, so to counter this, beginning with Windows 10 and PowerShell version 5, Microsoft introduced Protected <span class="No-Break">Event Logging.</span></p>
			<p><strong class="bold">Protected Event Logging</strong> encrypts <a id="_idIndexMarker579"/>data using the <strong class="bold">Internet Engineering Task Force (IETF)</strong> <strong class="bold">Cryptographic Message Syntax</strong> (<strong class="bold">CMS</strong>) standard, which relies on public key cryptography. This means <a id="_idIndexMarker580"/>that a public key is deployed on all systems that should support Protected Event Logging. Then, the public key is used to encrypt event log data before it is forwarded to a central log <span class="No-Break">collection server.</span></p>
			<p>On this machine, the highly sensitive private key is used to decrypt the data, before the data is inserted into the SIEM. This machine is sensitive and, therefore, needs <span class="No-Break">special protection.</span></p>
			<p>Protected Event Logging is not enabled by default and can currently only be used with PowerShell <span class="No-Break">event logs.</span></p>
			<h3>Enabling Protected Event Logging</h3>
			<p>To enable <a id="_idIndexMarker581"/>Protected Event Logging, you can deploy a <em class="italic">base64-encoded X.509</em> certificate or another option (for example, deploying a certificate <a id="_idIndexMarker582"/>through <strong class="bold">Public Key Infrastructure (PKI)</strong> and providing a thumbprint, or providing a path to a local or file share-hosted certificate). In our example, we’ll use a <em class="italic">base64-encoded </em><span class="No-Break"><em class="italic">X.509</em></span><span class="No-Break"> certificate.</span></p>
			<p>Here are the <span class="No-Break">certificate requirements:</span></p>
			<ul>
				<li>The certificate <a id="_idIndexMarker583"/>must also have the <em class="italic">“Document Encryption”</em> <strong class="bold">Enhanced Key Usage</strong> (<strong class="bold">EKU</strong>) with the OID number (<span class="No-Break"><strong class="source-inline">1.3.6.1.4.1.311.80.1</strong></span><span class="No-Break">) included</span></li>
				<li>The certificate properties must include either the “<em class="italic">Data Encipherment</em>” or “<em class="italic">Key Encipherment</em>” <span class="No-Break">key usage</span></li>
			</ul>
			<p>There’s a great SANS blog post where you can see how to check your certificate’s <span class="No-Break">properties: </span><a href="https://www.sans.org/blog/powershell-protect-cmsmessage-example-code/"><span class="No-Break">https://www.sans.org/blog/powershell-protect-cmsmessage-example-code/</span></a><span class="No-Break">.</span></p>
			<p>Protected <a id="_idIndexMarker584"/>Event Logging leverages <strong class="bold">IETF CMS</strong> to secure the event log content. Therefore, you can also refer to the documentation pages for the <strong class="source-inline">Protect-CMSMessage</strong> and <strong class="source-inline">Unprotect-CMSMessage</strong> cmdlets for more information on encrypting and decrypting <span class="No-Break">using CMS:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Protect-CMSMessage</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/protect-cmsmessage"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/protect-cmsmessage</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Unprotect-CMSMessage</strong></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/unprotect-cmsmessage"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/unprotect-cmsmessage</span></a></li>
			</ul>
			<p>Be careful that the certificate file that you plan to deploy <strong class="bold">does not</strong> contain the private key. Once you have obtained the certificate, you can either enable it manually or by using <span class="No-Break">Group Policy.</span></p>
			<p>In the blog post <em class="italic">PowerShell </em><em class="italic">♥</em><em class="italic"> the blue team</em>, the PowerShell team provides you with the <strong class="source-inline">Enable-ProtectedEventLogging</strong> function, which you can use to enable Protected Event Logging using <span class="No-Break">PowerShell: </span><a href="https://devblogs.microsoft.com/powershell/powershell-the-blue-team/#protected-event-logging"><span class="No-Break">https://devblogs.microsoft.com/powershell/powershell-the-blue-team/#protected-event-logging</span></a><span class="No-Break">.</span></p>
			<p>To leverage this script, save your certificate in the <strong class="source-inline">$cert</strong> variable, which you will use in the second command to pass the public key certificate to the <strong class="source-inline">Enable-ProtectedEventLogging</strong> function, enabling Protected Event Logging on the <span class="No-Break">local system:</span></p>
			<pre class="source-code">
&gt; $cert = Get-Content C:\tmp\PEL_certificate.cer –Raw
&gt; Enable-ProtectedEventLogging –Certificate $cert</pre>
			<p>You can also enable Protected Event Logging using Group Policy. Create a new GPO or reuse an <a id="_idIndexMarker585"/>existing GPO, and then navigate to <strong class="bold">Computer Configuration</strong> | <strong class="bold">Policies</strong> | <strong class="bold">Administrative Templates</strong> | <strong class="bold">Windows Components</strong> | <span class="No-Break"><strong class="bold">Event Logging</strong></span><span class="No-Break">.</span></p>
			<p>Open the <strong class="bold">Enable Protected Event </strong><span class="No-Break"><strong class="bold">Logging</strong></span><span class="No-Break"> policy.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer087">
					<img alt="Figure 4.6 – Enabling Protected Event Logging" src="image/B16679_04_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Enabling Protected Event Logging</p>
			<p>Set <strong class="bold">Enable Protected Event Logging</strong> to <strong class="bold">Enabled</strong>, provide your certificate, and confirm <span class="No-Break">with </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></p>
			<p>Use the <strong class="source-inline">Unprotect-CmsMessage</strong> cmdlet on a secure and protected system to decrypt the data before storing it in your SIEM, provided that an appropriate decryption certificate (that is, the one that has the private key) is installed on <span class="No-Break">the machine.</span></p>
			<p>To decrypt the data before storing it in your SIEM, make use of the <strong class="source-inline">Unprotect-CmsMessage</strong> cmdlet on a secure and protected system, where an appropriate decryption certificate containing the private key <span class="No-Break">is installed:</span></p>
			<pre class="source-code">
&gt; Get-WinEvent Microsoft-Windows-PowerShell/Operational | Where-Object Id -eq 4104 | Unprotect-CmsMessage</pre>
			<p>In this <a id="_idIndexMarker586"/>example, all events from the Operational PowerShell log with the event ID <strong class="source-inline">4104</strong> will be decrypted, assuming the private key <span class="No-Break">is present.</span></p>
			<p>There is also an option to document what exactly was run in a session and what output was shown. This option is called a transcript – let’s have a closer look in our <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor097"/>PowerShell transcripts</h2>
			<p>PowerShell transcripts <a id="_idIndexMarker587"/>have been available in PowerShell since PowerShell version 1.0 as part of the <strong class="source-inline">Microsoft.PowerShell.Host</strong> module. Transcripts are a great way to monitor what happens in a <span class="No-Break">PowerShell session.</span></p>
			<p>If a PowerShell transcript is started, all executed PowerShell commands and their output are recorded and saved into the folder that was specified. If not specified otherwise, the default output folder is the <strong class="source-inline">My Documents</strong> folder (<strong class="source-inline">%userprofile%\Documents</strong>) of the <span class="No-Break">current user.</span></p>
			<p>The following screenshot is an example of how such a transcript <span class="No-Break">could look.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer088">
					<img alt="Figure 4.7 – A screenshot of a PowerShell transcript" src="image/B16679_04_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – A screenshot of a PowerShell transcript</p>
			<p>The name <a id="_idIndexMarker588"/>of the <strong class="source-inline">.txt</strong> file starts with <strong class="source-inline">PowerShell_transcript</strong>, followed by <strong class="source-inline">computername</strong>, a random string, and a <span class="No-Break">time stamp.</span></p>
			<p>This is a typical example of a PowerShell transcript filename that was started on <em class="italic">PSSec-PC01</em> – <span class="No-Break"><strong class="source-inline">PowerShell_transcript.PSSEC-PC01.MUxdLMnA.20210320152800.txt</strong></span><span class="No-Break">.</span></p>
			<h3>How to start transcripts</h3>
			<p>There are several options for enabling transcripts. However, the simplest method to record PowerShell <a id="_idIndexMarker589"/>transcripts is by simply typing the <strong class="source-inline">Start-Transcript</strong> command in the current session and hitting <em class="italic">Enter</em>. In this case, only commands that are run in this local session will <span class="No-Break">be captured.</span></p>
			<p>When running the <strong class="source-inline">Start-Transcript</strong> cmdlet directly, the most interesting parameters are <strong class="source-inline">-OutputDirectory</strong>, <strong class="source-inline">-Append</strong>, <strong class="source-inline">-NoClobber</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">-IncludeInvocationHeader</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">-Append</strong>: The new transcript will be added to an <span class="No-Break">existing file.</span></li>
				<li><strong class="source-inline">-IncludeInvocationHeader</strong>: Time stamps when commands are run are added to the transcript, along with a delimiter between commands to make the transcripts easier to parse <span class="No-Break">through automation.</span></li>
				<li><strong class="source-inline">-NoClobber</strong>: This transcript will not overwrite an existing file. Normally, if a transcript <a id="_idIndexMarker590"/>already exists in the defined location (for example, if the defined file has the same name as an already existing file, or the filename was configured using the <strong class="source-inline">-Path</strong> or <strong class="source-inline">-LiteralPath</strong> parameter), <strong class="source-inline">Start-Transcript</strong> overwrites this file <span class="No-Break">without warning.</span></li>
				<li><strong class="source-inline">-OutputDirectory</strong>: Using this parameter, you can configure the path where your transcripts can <span class="No-Break">be stored.</span></li>
				<li><strong class="source-inline">-UseMinimalHeader</strong>: This parameter <a id="_idIndexMarker591"/>was added in <strong class="bold">PowerShell version 6.2</strong> and ensures that only a short header is prepended instead of the <span class="No-Break">detailed header.</span></li>
			</ul>
			<p>Read more <a id="_idIndexMarker592"/>about the full list of parameters in the <strong class="source-inline">Start-Transcript</strong> help files or in the official PowerShell <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.host/start-transcript?view=powershell-7#parameters"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.host/start-transcript?view=powershell-7#parameters</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Securing your transcripts</p>
			<p class="callout">As with any security logging you collect, it’s important to ensure that your transcripts are securely stored to prevent attackers from tampering with them. Make sure to configure a secure path that is difficult for attackers to access, taking into consideration the possibility of stolen corporate identities. Once an attacker gains access to transcripts, they can modify them and render your detection <span class="No-Break">efforts useless.</span></p>
			<p>Transcripts that were initialized with <strong class="source-inline">Start-Transcript</strong> are only recorded as long as the session is active or until <strong class="source-inline">Stop-Transcript</strong> is executed, which stops the recording of executed <span class="No-Break">PowerShell commands.</span></p>
			<h3>Enabling transcripts by default</h3>
			<p>To enable <a id="_idIndexMarker593"/>transcripts <em class="italic">by default</em> on a system, you can either configure transcripts via a <strong class="bold">registry</strong> or by using <strong class="bold">Group Policy</strong> to configure transcripts for <span class="No-Break">multiple systems.</span></p>
			<h4>Enabling transcripts by registry or script</h4>
			<p>When <a id="_idIndexMarker594"/>PowerShell transcripts are configured, the following registry hive <span class="No-Break">is used:</span></p>
			<pre class="source-code">
<strong class="source-inline">HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription</strong></pre>
			<p>For example, to enable transcription, using invocation headers and the <strong class="source-inline">C:\tmp</strong> output folder, you need to configure the following values to the <span class="No-Break">registry keys:</span></p>
			<ul>
				<li><strong class="source-inline">[REG_DWORD]EnableTranscripting = 1</strong></li>
				<li><strong class="source-inline">[REG_DWORD]EnableInvocationHeader = 1</strong></li>
				<li><strong class="source-inline">[REG_SZ]OutputDirectory = </strong><span class="No-Break"><strong class="source-inline">C:\tmp</strong></span></li>
			</ul>
			<p>To manage multiple machines, it’s more comfortable to use GPO, but in some cases, some machines are not part of the Active Directory domain; hence, they cannot be managed. For this example, I have added the <strong class="source-inline">Enable-PSTranscription</strong> function to the GitHub repository for this <span class="No-Break">book: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Enable-PSTranscription.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Enable-PSTranscription.ps1</span></a><span class="No-Break">.</span></p>
			<p>Load the <strong class="source-inline">Enable-PSTranscription</strong> function into the current session and specify the folder where your transcripts should be saved, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&gt; Enable-PSTranscription -OutputDirectory "C:\PSLogs"</pre>
			<p>If no <strong class="source-inline">-OutputDirectory</strong> is specified, the script will write transcripts into <strong class="source-inline">C:\ProgramData\WindowsPowerShell\Transcripts</strong> as the <span class="No-Break">default option.</span></p>
			<p>This function just configures all defined values and overwrites your existing registry keys. Feel free to adjust the function to your needs and to <span class="No-Break">reuse it.</span></p>
			<p>As soon as a new session is started, transcripts will be written to the <span class="No-Break">configured folder.</span></p>
			<h4>Enabling transcripts using Group Policy</h4>
			<p>In Active <a id="_idIndexMarker595"/>Directory-managed environments, the easiest way to configure transcripts is by using <span class="No-Break">Group Policy.</span></p>
			<p>Create a new GPO or reuse an existing one. Then, navigate to <strong class="bold">Computer Configuration</strong> | <strong class="bold">Policies</strong> | <strong class="bold">Administrative Templates</strong> | <strong class="bold">Windows Components</strong> | <span class="No-Break"><strong class="bold">Windows PowerShell</strong></span><span class="No-Break">.</span></p>
			<p>Double-click and open the <strong class="bold">Turn on PowerShell Transcription</strong> policy to configure <span class="No-Break">PowerShell transcription:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer089">
					<img alt="Figure 4.8 – Turning on PowerShell transcription" src="image/B16679_04_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Turning on PowerShell transcription</p>
			<p>Set the policy to <strong class="bold">Enabled</strong>, and select whether a transcript output directory and invocation <a id="_idIndexMarker596"/>headers should be included. If the output directory is not specified, transcriptions are saved to the <strong class="source-inline">My Documents</strong> folder of the current <span class="No-Break">user (</span><span class="No-Break"><strong class="source-inline">%userprofile%\Documents</strong></span><span class="No-Break">).</span></p>
			<h4>Enabling transcripts for PowerShell Remoting sessions</h4>
			<p><strong class="bold">Custom endpoints</strong> are an <a id="_idIndexMarker597"/>excellent way to apply default settings <a id="_idIndexMarker598"/>to PowerShell Remoting sessions. If transcriptions were configured, they will be enabled by default for local sessions, but configuring them additionally in <strong class="bold">Just Enough Administration</strong> allows you to group and collect logs specific to that endpoint when used for remote sessions. By configuring transcription and other settings on a custom endpoint, you can enforce these settings for all remote sessions connected to that endpoint, making it easier to ensure consistency and compliance across <span class="No-Break">your environment.</span></p>
			<p>To get started, create a session configuration file, using the <strong class="source-inline">New-PSSessionConfigurationFile</strong> cmdlet with the <strong class="source-inline">-TranscriptDirectory</strong> parameter to specify where transcripts should be <span class="No-Break">written to:</span></p>
			<pre class="source-code">
&gt; New-PSSessionConfigurationFile -Path "$env:userprofile\Documents\PSSession.pssc" -TranscriptDirectory "C:\tmp"</pre>
			<p>This command creates a new session configuration file, enforcing transcription, and stores it in <strong class="source-inline">%userprofile%\Documents\PSSession.pssc</strong>, the path that was defined within the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Path</strong></span><span class="No-Break"> parameter.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer090">
					<img alt="Figure 4.9 – The newly created session configuration" src="image/B16679_04_009.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – The newly created session configuration</p>
			<p>We <a id="_idIndexMarker599"/>introduced custom endpoints in <a href="B16679_03_Final_PD.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Exploring PowerShell Remote Management Technologies and PowerShell Remoting,</em> and we will dive deeper into Just Enough Administration in <a href="B16679_10_Final_PD.xhtml#_idTextAnchor278"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Language Modes and Just Enough Administration (JEA)</em>. To learn more about the concept of custom endpoints and Just Enough Administration, please make sure to review <span class="No-Break">both chapters.</span></p>
			<h3>Best practices for PowerShell transcripts</h3>
			<p>As a security <a id="_idIndexMarker600"/>best practice, <em class="italic">use session transcripts for every user</em>. This does not mean that your administrators are doing nasty stuff on your machines and they need to be monitored. In no way do I encourage mistrust in your own staff. However, credential theft is a real threat, and if your administrator’s identity is stolen and misused, you will be happy to understand what was done by <span class="No-Break">the adversary.</span></p>
			<p>If you use transcripts, make sure that they cannot be modified. If they can be altered by an attacker, they are of almost no use <span class="No-Break">at all.</span></p>
			<p>So, make sure to provide a path to a preconfigured folder, and specify it either via a GPO, manual configuration, or in the session configuration file. Prevent all users from modifying or deleting any data in this folder. The local system account requires read and write access, so make sure to configure the access <span class="No-Break">permissions accordingly.</span></p>
			<p>And last but not least, it makes sense to forward all the transcript files to a central logging server or your SIEM to analyze <span class="No-Break">them regularly.</span></p>
			<p>One effective <a id="_idIndexMarker601"/>approach to centralizing the transcript files is to configure their destination as a <strong class="bold">Uniform Naming Convention (UNC)</strong> path with a dynamic filename. For example, you can set the transcript directory to a network share with write-only permission, using the PowerShell profile to log all activity to a file with a unique name, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
\\server\share$\env:computername-$($env:userdomain)-$($env:username)-$(Get-Date Format YYYYMMddhhmmss).txt</pre>
			<p>Also, ensure that <a id="_idIndexMarker602"/>this share is not readable by normal users. By using this approach, you can easily collect and analyze the logs from all machines in a centralized location, allowing you to better detect and respond to security incidents without the need to set up an entire <span class="No-Break">logging infrastructure.</span></p>
			<p>In addition to collecting logs, analyzing them is equally important. In the next section, we will explore the techniques and tools used for <span class="No-Break">log analysis.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor098"/>Analyzing event logs</h1>
			<p>There are several ways to work with Windows event logs using PowerShell. Of course, you can always <a id="_idIndexMarker603"/>forward your event logs to the SIEM of your choice, but sometimes, it happens that you want to directly analyze the event logs on a certain machine. For this use case, it makes sense to look at the available options that come <span class="No-Break">with PowerShell.</span></p>
			<p>The easiest option if you just want to analyze events or create new events is the <strong class="source-inline">*-WinEvent</strong> cmdlets, which are still available in PowerShell Core 7. You can use <strong class="source-inline">Get-Command</strong> to find all <span class="No-Break">available cmdlets:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer091">
					<img alt="Figure 4.10 – The available *-WinEvent cmdlets" src="image/B16679_04_010.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – The available *-WinEvent cmdlets</p>
			<p>In PowerShell 5.1, there was also the possibility of using the <strong class="source-inline">*-EventLog</strong> cmdlets, but they were removed <a id="_idIndexMarker604"/>in PowerShell Core 6 and above. Since PowerShell 5.1 is installed by default on all Windows 10 operating systems, I refer to <strong class="source-inline">*-EventLog</strong> here. Again, use <strong class="source-inline">Get-Command</strong> to find all <span class="No-Break">available cmdlets:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer092">
					<img alt="Figure 4.11 – The available *-EventLog cmdlets" src="image/B16679_04_011.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – The available *-EventLog cmdlets</p>
			<p>The third option is to use <strong class="source-inline">wevtutil</strong>. This command-line executable is not very intuitive to understand, but it can be used to operate and analyze event logs. Using the <strong class="source-inline">/?</strong> parameter, you can get more details on <span class="No-Break">the usage.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer093">
					<img alt="Figure 4.12 – wevtutil.exe usage" src="image/B16679_04_012.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – wevtutil.exe usage</p>
			<p>For example, clearing the <strong class="source-inline">Security</strong> event log can be achieved with the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; wevtutil.exe cl Security</pre>
			<p>Refer to the <a id="_idIndexMarker605"/>official documentation to get more details on <span class="No-Break"><strong class="source-inline">wevtutil</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/de-de/windows-server/administration/windows-commands/wevtutil"><span class="No-Break">https://docs.microsoft.com/de-de/windows-server/administration/windows-commands/wevtutil</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor099"/>Finding out which logs exist on a system</h2>
			<p>If you want <a id="_idIndexMarker606"/>to find out which event logs exist on a system, you can leverage the <strong class="source-inline">-ListLog</strong> parameter followed by a wildcard (<strong class="source-inline">*</strong>) – <strong class="source-inline">Get-WinEvent -</strong><span class="No-Break"><strong class="source-inline">ListLog *</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer094">
					<img alt="Figure 4.13 – Listing all event logs" src="image/B16679_04_013.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – Listing all event logs</p>
			<p>You might <a id="_idIndexMarker607"/>want to pipe the output to <strong class="source-inline">Sort-Object</strong> to sort by record count, maximum log size, log mode, or <span class="No-Break">log name.</span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor100"/>Querying events in general</h2>
			<p>To get started, let’s have a look how we can analyze some of the most common scenarios <a id="_idIndexMarker608"/>for <span class="No-Break">PowerShell auditing.</span></p>
			<p>Using the <strong class="source-inline">Get-WinEvent</strong> command, you can get all the event IDs from the event log that you specified – <span class="No-Break"><strong class="source-inline">Get-WinEvent Microsoft-Windows-PowerShell/Operational</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer095">
					<img alt="Figure 4.14 – Querying the Microsoft Windows PowerShell Operational log" src="image/B16679_04_014.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – Querying the Microsoft Windows PowerShell Operational log</p>
			<p>In this example, you would see all event IDs that were generated in the PowerShell <span class="No-Break">Operational log.</span></p>
			<p>If you only <a id="_idIndexMarker609"/>want to query the last <em class="italic">x</em> events, the <strong class="source-inline">-MaxEvents</strong> parameter will help you to achieve this task. For example to query the last 15 events of the <em class="italic">security</em> event log use <strong class="source-inline">Get-WinEvent Security -</strong><span class="No-Break"><strong class="source-inline">MaxEvents 15</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer096">
					<img alt="Figure 4.15 – Querying the last 15 events from the Security event log" src="image/B16679_04_015.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – Querying the last 15 events from the Security event log</p>
			<p>This is especially helpful if you want to analyze recent events without querying the entire <span class="No-Break">event log.</span></p>
			<p>Using the <strong class="source-inline">-Oldest</strong> parameter reverts the order so that you see the oldest events in this log – <strong class="source-inline">Get-WinEvent Security -MaxEvents </strong><span class="No-Break"><strong class="source-inline">15 -Oldest</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer097">
					<img alt="Figure 4.16 – The 15 oldest events from the Security event log" src="image/B16679_04_016.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16 – The 15 oldest events from the Security event log</p>
			<p>To find all <a id="_idIndexMarker610"/>events in the Microsoft Windows PowerShell Operational log that contain code that was executed and logged by <strong class="source-inline">ScriptBlockLogging</strong>, filter for event id<strong class="source-inline"> 4104</strong>: <strong class="source-inline">Get-WinEvent Microsoft-Windows-PowerShell/Operational | Where-Object { $_.Id -eq 4104 } | </strong><span class="No-Break"><strong class="source-inline">fl</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer098">
					<img alt="Figure 4.17 – Finding all executed and logged code" src="image/B16679_04_017.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17 – Finding all executed and logged code</p>
			<p>You can also <a id="_idIndexMarker611"/>filter for certain keywords in the message part. For example, to find all events that contain the <strong class="source-inline">"logon"</strong> string in the message, use the <strong class="source-inline">-match</strong> comparison operator – <strong class="source-inline">Get-WinEvent Security | Where-Object { $_.Message -match "</strong><span class="No-Break"><strong class="source-inline">logon" }</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer099">
					<img alt="Figure 4.18 – Finding all events that contain “logon” in their message" src="image/B16679_04_018.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18 – Finding all events that contain “logon” in their message</p>
			<p>You can also <a id="_idIndexMarker612"/>filter using XPath-based queries, using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">FilterXPath</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterXPath "*[System[(EventID=4100 or EventID=4101 or EventID=4102 or EventID=4103 or EventID=4104)]]"</pre>
			<p>The output is shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer100">
					<img alt="Figure 4.19 – Filtering using an XPath query" src="image/B16679_04_019.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19 – Filtering using an XPath query</p>
			<p>It is also possible to filter by a specified <strong class="bold">hash table</strong>, using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">FilterHashtable</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
&gt; $eventLog = @{ ProviderName="Microsoft-Windows-PowerShell"; Id = 4104 }
&gt; Get-WinEvent -FilterHashtable $eventLog</pre>
			<p>Using hash tables can reduce your usage of <strong class="source-inline">Where-Object</strong> filter <span class="No-Break">clauses significantly.</span></p>
			<p>If you want <a id="_idIndexMarker613"/>to query complex event structures, you can use the <strong class="source-inline">-FilterXml</strong> parameter and provide an <strong class="bold">XML</strong> string. I have prepared such an example and uploaded it to this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Get-AllPowerShellEvents.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Get-AllPowerShellEvents.ps1</span></a><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer101">
					<img alt="Figure 4.20 – Using the Get-AllPowerShellEvents.ps1 script" src="image/B16679_04_020.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20 – Using the Get-AllPowerShellEvents.ps1 script</p>
			<p>This example queries the <strong class="source-inline">Microsoft-Windows-PowerShell/Operational</strong>, <strong class="source-inline">PowerShellCore/Operational</strong>, and <strong class="source-inline">Windows PowerShell</strong> event logs and retrieves all the events that I will describe in the <em class="italic">Basic PowerShell event logs</em> section in <span class="No-Break">this chapter.</span></p>
			<p>Now that you know how to work with event logs and query events, let’s look at how to detect and analyze which code was run on <span class="No-Break">a system.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor101"/>Which code was run on a system?</h2>
			<p>Filtering and scrolling through all events that contain executed code can be a tedious task, if you decide <a id="_idIndexMarker614"/>to perform this task manually. But, thankfully, PowerShell allows you to automate this task and quickly find what you are <span class="No-Break">searching for.</span></p>
			<p>In general, all events that contain logged code can be found either in the Microsoft Windows PowerShell or the PowerShell Core Operational log, indicated by event <span class="No-Break">ID </span><span class="No-Break"><strong class="source-inline">4104</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-WinEvent Microsoft-Windows-PowerShell/Operational | Where-Object Id -eq 4104
&gt; Get-WinEvent PowerShellCore/Operational | Where-Object Id -eq 4104</pre>
			<p>To better find and filter what code was executed, I have written the <strong class="source-inline">Get-ExecutedCode</strong> function, which you can find in the GitHub repository for this <span class="No-Break">book: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Get-ExecutedCode.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Get-ExecutedCode.ps1</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor102"/>Downgrade attack</h2>
			<p>As newer <a id="_idIndexMarker615"/>versions such as 5.1 and upward introduced a lot of new security features, older PowerShell versions such as version 2.0 became more attractive to attackers. Therefore, a common way to leverage older versions is a <a id="_idIndexMarker616"/>so-called <span class="No-Break"><strong class="bold">downgrade attack</strong></span><span class="No-Break">.</span></p>
			<p>A downgrade attack can be executed by specifying the version number when <span class="No-Break">running </span><span class="No-Break"><strong class="source-inline">powershell.exe</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; powershell.exe -version 2 –command &lt;command&gt;</pre>
			<p>If the specified version is installed, the command runs, using the deprecated binary, which implies that only security features that existed when that version was written <span class="No-Break">are applied.</span></p>
			<p>All machines that run Windows 7 and above have at least PowerShell version 2.0 installed. Although Windows 7 is not supported and does not receive any security updates anymore, it is <span class="No-Break">still widespread.</span></p>
			<p>Additionally, PowerShell <a id="_idIndexMarker617"/>version 2.0 still relies on <strong class="bold">.NET Framework 2.0</strong>, which does not include advanced security features and provides no advanced logging. Therefore, that’s perfect for attackers that do not want anybody to know what they did on <span class="No-Break">your system.</span></p>
			<p>.NET Framework 2.0 is not included by default on Windows 10, but it can be installed manually – for example, by an attacker or an administrator. On operating systems prior to Windows 10, .NET Framework 2.0 is installed <span class="No-Break">by default.</span></p>
			<p>On Windows 8, PowerShell version 2.0 can be disabled by running the following command in an <span class="No-Break">elevated console:</span></p>
			<pre class="source-code">
Disable-WindowsOptionalFeature -Online -FeatureName MicrosoftWindowsPowerShellV2Root</pre>
			<p>.NET Framework 2.0, which is required to run PowerShell version 2.0, is by default not installed on newer systems such as <span class="No-Break">Windows 10.</span></p>
			<p>So, if you <a id="_idIndexMarker618"/>try to run <strong class="source-inline">powershell.exe -version 2</strong>, you get an error message, stating that version 2 of .NET Framework <span class="No-Break">is missing:</span></p>
			<pre class="source-code">
&gt; powershell.exe -version 2
Version v2.0.50727 of the .NET Framework is not installed and it is required to run version 2 of Windows PowerShell.</pre>
			<p>As .NET Framework 2.0 can be installed manually – either by system administrators or attackers – make sure to check for PowerShell version 2.0 and <span class="No-Break">disable it.</span></p>
			<p>Run the following command to check whether PowerShell version 2.0 is enabled <span class="No-Break">or disabled:</span></p>
			<pre class="source-code">
&gt; Get-WindowsOptionalFeature -Online | Where-Object {$_.FeatureName -match "PowerShellv2"}
FeatureName : MicrosoftWindowsPowerShellV2Root
State       : Enabled
FeatureName : MicrosoftWindowsPowerShellV2
State       : Enabled</pre>
			<p>So, it seems like PowerShell version 2.0 is still enabled on this machine. Therefore, if the missing .NET Framework 2.0 is installed, this system will be vulnerable to a <span class="No-Break">downgrade attack.</span></p>
			<p>Therefore, let’s disable PowerShell version 2.0 to harden your system by running the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
Get-WindowsOptionalFeature -Online | Where-Object {$_.FeatureName -match "PowerShellv2"} | ForEach-Object {Disable-WindowsOptionalFeature -Online -FeatureName $_.FeatureName -Remove}</pre>
			<p>You will <a id="_idIndexMarker619"/>see in the output that a restart is needed, so after you restart your PC, the changes are applied and PowerShell version 2.0 <span class="No-Break">is disabled:</span></p>
			<pre class="source-code">
&gt; Get-WindowsOptionalFeature -Online | Where-Object {$_.FeatureName -match "PowerShellv2"} | ForEach-Object {Disable-WindowsOptionalFeature -Online -FeatureName $_.FeatureName -Remove}
Path          :
Online        : True
RestartNeeded : False
Path          :
Online        : True
RestartNeeded : False</pre>
			<p>So, if you verify once again, you will see that the state is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Disabled</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-WindowsOptionalFeature -Online | Where-Object {$_.FeatureName -match "PowerShellv2"}
FeatureName : MicrosoftWindowsPowerShellV2Root
State       : Disabled
FeatureName : MicrosoftWindowsPowerShellV2
State       : Disabled</pre>
			<p>However, on Windows 7, PowerShell version 2.0 cannot be disabled. The only way to disallow PowerShell version 2.0 usage <a id="_idIndexMarker620"/>is to leverage <strong class="bold">Application Control</strong> or <strong class="bold">AppLocker</strong>, which <a id="_idIndexMarker621"/>we will discuss in <a href="B16679_11_Final_PD.xhtml#_idTextAnchor306"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">AppLocker, Application Control, and </em><span class="No-Break"><em class="italic">Code Signing</em></span><span class="No-Break">.</span></p>
			<p>For adversaries, there is also another way to run a downgrade attack – if, for example, a compiled <a id="_idIndexMarker622"/>application leverages an older PowerShell version, and links against the compiled PowerShell v2 binaries, a downgrade attack can be launched by exploiting the application. So, whenever this application runs, PowerShell v2 is also active, and it can be used by the attacker if they manage to exploit <span class="No-Break">the application.</span></p>
			<p>In this case, disabling PowerShell version 2.0 can help to protect against this type of attack by blocking the <a id="_idIndexMarker623"/>deprecated binaries in the <strong class="bold">Global Assembly Cache</strong> (<strong class="bold">GAC</strong>) or removing the PowerShell component altogether. Nevertheless, it’s important to note that other applications that rely on these binaries will be blocked as well, as they usually don’t ship with all of the <span class="No-Break">PowerShell binaries.</span></p>
			<p>In general, a downgrade attack is a highly critical issue, and therefore, you should monitor for it. You can do so by monitoring the event with the event id<strong class="source-inline"> 400</strong> in the Windows PowerShell event log – if the specified version is lower than <strong class="source-inline">[Version] "5"</strong>, you should definitely <span class="No-Break">investigate further.</span></p>
			<p>Lee Holmes, who was part of the Windows PowerShell team at Microsoft, provides a great example of how to monitor for potential downgrade attacks by looking for event ID <strong class="source-inline">400</strong> in the PowerShell event log in his blog article <em class="italic">Detecting and Preventing PowerShell Downgrade </em><span class="No-Break"><em class="italic">Attacks</em></span><span class="No-Break">: </span><a href="https://www.leeholmes.com/detecting-and-preventing-powershell-downgrade-attacks/"><span class="No-Break">https://www.leeholmes.com/detecting-and-preventing-powershell-downgrade-attacks/</span></a><span class="No-Break">.</span></p>
			<p>Use this <a id="_idIndexMarker624"/>example to find lower versions of the PowerShell engine <span class="No-Break">being loaded:</span></p>
			<pre class="source-code">
Get-WinEvent -LogName "Windows PowerShell" | Where-Object Id -eq 400 | Foreach-Object {
        $version = [Version] ($_.Message -replace '(?s).*EngineVersion=([\d\.]+)*.*','$1')
        if($version -lt ([Version] "5.0")) { $_ }
}</pre>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor103"/>EventList</h2>
			<p>During my time as a Premier Field Engineer at Microsoft, I worked with a lot of customers that <a id="_idIndexMarker625"/>were just building their SOCs from scratch. Most of those customers not only wanted to set up log event forwarding but also asked me for best practices to harden <a id="_idIndexMarker626"/>their <span class="No-Break">Windows environment.</span></p>
			<p>When talking <a id="_idIndexMarker627"/>about hardening Windows environments, you can’t ignore the Microsoft <strong class="bold">Security and Compliance Toolkit</strong> (<span class="No-Break"><strong class="bold">SCT</strong></span><span class="No-Break">): </span><a href="https://www.microsoft.com/en-us/download/details.aspx?id=55319"><span class="No-Break">https://www.microsoft.com/en-us/download/details.aspx?id=55319</span></a><span class="No-Break">.</span></p>
			<p>I will talk more about some parts of this toolkit later in <a href="B16679_06_Final_PD.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Active Directory – Attacks and Mitigation</em> as well as in <a href="B16679_13_Final_PD.xhtml#_idTextAnchor341"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">What Else? – Further Mitigations and Resources</em>. In general, this toolkit contains several tools for comparing and verifying your <a id="_idIndexMarker628"/>configuration, as well as the <span class="No-Break">so-called </span><span class="No-Break"><strong class="bold">baselines</strong></span><span class="No-Break">.</span></p>
			<p>These baselines are meant to provide hardening guidance – a lot of settings that are important for your security posture, as well as <span class="No-Break"><em class="italic">monitoring configuration</em></span><span class="No-Break">.</span></p>
			<p>Needless to say, you should not just enforce those baselines without having a structured plan and knowing the impact of the settings that you <span class="No-Break">are configuring.</span></p>
			<p>If a baseline is configured for a certain computer, thanks to the monitoring configuration piece, new events are generated in the <strong class="source-inline">Security</strong> <span class="No-Break">event log.</span></p>
			<p>When I worked with customers, I always recommended applying the Microsoft Security baselines after a <span class="No-Break">well-structured plan.</span></p>
			<p>On one occasion, I was at a customer’s site and just recommended that they should apply Microsoft Security baselines to see more event IDs. After recommending applying those baselines, my customer asked me whether there was an overview to see what additional event IDs were being generated if they enabled a particular baseline, like the <em class="italic">Windows 2016 Domain </em><span class="No-Break"><em class="italic">Controller baseline</em></span><span class="No-Break">.</span></p>
			<p>I only knew of a documentation document that they could use to find it out themselves, the <em class="italic">Windows 10 and Windows Server 2016 security auditing and monitoring </em><span class="No-Break"><em class="italic">reference</em></span><span class="No-Break">: </span><a href="https://www.microsoft.com/en-us/download/details.aspx?id=52630"><span class="No-Break">https://www.microsoft.com/en-us/download/details.aspx?id=52630</span></a><span class="No-Break">.</span></p>
			<p>Although this document provided amazingly detailed information on all <strong class="bold">Advanced Audit Policy Configuration</strong> items, with its 754 pages, it was <span class="No-Break">quite extensive.</span></p>
			<p>So, the customer was not happy studying this big document and asked me to write down what events <a id="_idIndexMarker629"/>would be generated if they applied this baseline. I was not <a id="_idIndexMarker630"/>happy about such stupefying work, but I started to write down all events for this <span class="No-Break">one baseline.</span></p>
			<p>While I was doing this, the customer approached me and realized that they had not one but multiple kinds of baselines that they wanted to apply in their environment. Also, these were not only Domain Controller baselines but also baselines for member servers and client computers of all kinds of operating systems. So, they asked me to write down the event IDs for <em class="italic">ALL</em> <span class="No-Break">existing baselines.</span></p>
			<p>As you can imagine, I was not super-excited about this new task. This seemed like a very dull and exhausting task that would take years <span class="No-Break">to complete.</span></p>
			<p>Therefore, I considered the need to automate matching baselines to event IDs, and that’s how my open source tool <strong class="bold">EventList</strong> <span class="No-Break">was born.</span></p>
			<p>Although it all started as an Excel document with Visual Basic macros, it became a huge project in the meantime, with a huge database behind <span class="No-Break">the code.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer102">
					<img alt="Figure 4.21 – The EventList logo" src="image/B16679_04_021.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.21 – The EventList logo</p>
			<p>And whenever I need <a id="_idIndexMarker631"/>to work with event IDs, my EventList database became <a id="_idIndexMarker632"/>my source of truth, and it is still <span class="No-Break">growing constantly.</span></p>
			<h3>Working with EventList</h3>
			<p>To get started, EventList can be easily installed from the <span class="No-Break">PowerShell Gallery:</span></p>
			<pre class="source-code">
&gt; Install-Module EventList</pre>
			<p>EventList is <a id="_idIndexMarker633"/>built in PowerShell; therefore, even if you want to work solely with the user interface, you need to run at least one PowerShell command. Open the PowerShell console as an administrator and type in <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&gt; Open-EventListGUI</pre>
			<p>Confirm by hitting <em class="italic">Enter</em>. After a few seconds, the EventList <span class="No-Break">UI appears.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer103">
					<img alt="Figure 4.22 – The EventList UI" src="image/B16679_04_022.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.22 – The EventList UI</p>
			<p>At the top left, you can <a id="_idIndexMarker634"/>select an existing baseline and see the <strong class="bold">MITRE ATT&amp;CK</strong> techniques <a id="_idIndexMarker635"/>and areas that are being populated in the UI. So, you can see directly what MITRE ATT&amp;CK techniques are covered if a certain baseline <span class="No-Break">is applied.</span></p>
			<p>You have also the possibility to import your own baselines or exported GPOs and delete <span class="No-Break">existing ones.</span></p>
			<p>Once you have selected a baseline and the MITRE ATT&amp;CK checkboxes are filled, choose <strong class="bold">Generate </strong><span class="No-Break"><strong class="bold">Event List</strong></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer104">
					<img alt="Figure 4.23 – EventList – showing the baseline events" src="image/B16679_04_023.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.23 – EventList – showing the baseline events</p>
			<p>A pop-up <a id="_idIndexMarker636"/>window opens, and you can choose whether you want to generate an EventList for baseline events only or all MITRE <span class="No-Break">ATT&amp;CK events.</span></p>
			<p>To see which event IDs would be generated if you applied a certain baseline, select <strong class="bold">Baseline Events only</strong>. Confirm with <strong class="bold">OK</strong> to see the EventList for the baseline/GPO that <span class="No-Break">you selected.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer105">
					<img alt="Figure 4.24 – A generated EventList" src="image/B16679_04_024.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.24 – A generated EventList</p>
			<p>An EventList is <a id="_idIndexMarker637"/>generated, in which you see each event ID that will be generated if this baseline is applied, as well as (if available) a link to the documentation and a recommendation on whether this event should be monitored <span class="No-Break">or not.</span></p>
			<p>If <strong class="bold">Export as CSV</strong> is checked, you can select where the output should be saved, and a <strong class="source-inline">.csv</strong> file <span class="No-Break">is generated.</span></p>
			<p>As Microsoft Security <a id="_idIndexMarker638"/>baselines mostly rely on the <strong class="bold">Advanced Audit Logs</strong>, by using the <strong class="bold">Baseline only</strong> function, EventList helps a lot to understand and demystify the Advanced <span class="No-Break">Audit Logs.</span></p>
			<p>You can achieve the same thing by using the following commands on <span class="No-Break">the CLI:</span></p>
			<pre class="source-code">
&gt; Get-BaselineEventList -BaselineName "MSFT Windows Server 2019 - Domain Controller"</pre>
			<p>The baseline needs to be imported into the EventList database, so make sure that the baseline name is shown when verifying with the <span class="No-Break"><strong class="source-inline">Get-BaselineNameFromDB</strong></span><span class="No-Break"> function.</span></p>
			<p>Of course, you can also select different MITRE ATT&amp;CK techniques and areas and generate an EventList to see which event IDs cover a certain MITRE ATT&amp;CK area. Generate an EventList, select <strong class="bold">All MITRE ATT&amp;CK Events</strong>, and confirm <span class="No-Break">with </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></p>
			<p>A popup will open, and you <a id="_idIndexMarker639"/>can see all event IDs that were correlated to the selected MITRE <span class="No-Break">ATT&amp;CK techniques.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer106">
					<img alt="Figure 4.25 – A MITRE ATT&amp;CK EventList" src="image/B16679_04_025.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.25 – A MITRE ATT&amp;CK EventList</p>
			<p>Again, this can be achieved by passing either a baseline or MITRE ATT&amp;CK technique numbers to the <strong class="source-inline">Get-MitreEventList</strong> function, using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Identity</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
&gt; Get-MitreEventList -Identity "T1039"</pre>
			<p>The following screenshot shows the output of <span class="No-Break">the command.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer107">
					<img alt="Figure 4.26 – The Get-MitreEventList function can also be run via the command line" src="image/B16679_04_026.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.26 – The Get-MitreEventList function can also be run via the command line</p>
			<p>Of course, EventList provides many more functions. It also provides possibilities to generate forwarder <a id="_idIndexMarker640"/>agent snippets of all event IDs that should be forwarded for your use case. You can also generate your own GPOs and hunting queries that support your very own <span class="No-Break">use case.</span></p>
			<p>However, there are too many functions to describe everything in detail in this book. If you are interested in learning more about EventList, make sure to read the EventList documentation in its GitHub repository, that is mentioned at the end of this section. Some experts also find it useful to query the database behind <span class="No-Break">EventList manually.</span></p>
			<p>I wrote EventList to help SOCs worldwide understand what to monitor and simplify their event <span class="No-Break">ID forwarding.</span></p>
			<p>I am constantly improving EventList, so if you want to learn more, you are more than welcome to download and test it. It can be either downloaded and installed from my GitHub repository (<a href="https://github.com/miriamxyra/EventList">https://github.com/miriamxyra/EventList</a>) or installed from the <span class="No-Break">PowerShell Gallery:</span></p>
			<pre class="source-code">
&gt; Install-Module EventList -Force</pre>
			<p>To understand the functionalities of EventList more comprehensively, I recommend reading the documentation and help files and watching some of the recordings of the talks <a id="_idIndexMarker641"/>that I have given <span class="No-Break">on it:</span></p>
			<ul>
				<li><strong class="bold">Hack.lu 2019: (version </strong><span class="No-Break"><strong class="bold">1.1.0)</strong></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=nkMDsw4MA48"><span class="No-Break">https://www.youtube.com/watch?v=nkMDsw4MA48</span></a></li>
				<li><strong class="bold">Black Hat 2020 (version </strong><span class="No-Break"><strong class="bold">2.0.0)</strong></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=3x5-nZ2bfbo"><span class="No-Break">https://www.youtube.com/watch?v=3x5-nZ2bfbo</span></a></li>
			</ul>
			<p>If you have <a id="_idIndexMarker642"/>any ideas on what is missing in EventList, I would love to hear more, and I’m looking forward to your pull request on GitHub or your message on Twitter or <span class="No-Break">via email.</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor104"/>Getting started with logging</h1>
			<p>To improve your detection, it makes sense to set up a SIEM system for event collection so that you have <a id="_idIndexMarker643"/>all event logs in one place, allowing you to hunt and even build <span class="No-Break">automated alerting.</span></p>
			<p>There are many options if you want to choose a SIEM system – for every budget and scenario. Over the years, I have seen many different SIEM systems – and each one just fitted perfectly for <span class="No-Break">each organization.</span></p>
			<p>The most <a id="_idIndexMarker644"/>popular <a id="_idIndexMarker645"/>SIEM systems <a id="_idIndexMarker646"/>that I have <a id="_idIndexMarker647"/>seen out <a id="_idIndexMarker648"/>in the wild were <strong class="bold">Splunk</strong>, <strong class="bold">Azure Sentinel</strong>, <strong class="bold">ArcSight</strong>, <strong class="bold">qRadar</strong>, and the <strong class="bold">“ELK stack” (Elastic, LogStash, and Kibana)</strong>, just <a id="_idIndexMarker649"/>to mention a few. I also saw and used <strong class="bold">Windows Event Forwarding</strong> (<strong class="bold">WEF</strong>) to realize event <span class="No-Break">log monitoring.</span></p>
			<p>Of course, it is also possible to analyze events on a local machine, but it is not practical – depending on the configuration, if the maximum log size is reached, old events are deleted, and you cannot easily correlate them with logs from <span class="No-Break">another system.</span></p>
			<p>In this chapter, we will also analyze events directly on the machine (or remotely if you like), but for an actual production environment, I recommend having an SIEM system in place – just make sure that it fits your use case before <span class="No-Break">you start.</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor105"/>An overview of important PowerShell-related log files</h2>
			<p>Before we get <a id="_idIndexMarker650"/>started, you might want to configure all the logs that you want to forward to your SIEM or a central <span class="No-Break">log server.</span></p>
			<p>In this section, you will find an overview of all the logs that I consider important when it comes to <span class="No-Break">PowerShell logging.</span></p>
			<h3>Basic PowerShell event logs</h3>
			<p>When working <a id="_idIndexMarker651"/>with PowerShell, there are three event logs that are of interest – the <strong class="bold">Windows PowerShell log</strong>, the <strong class="bold">Microsoft Windows PowerShell Operational log</strong>, and the <strong class="bold">PowerShellCore Operational log</strong>. Let’s discuss each of them in the <span class="No-Break">following subsections.</span></p>
			<h4>The Windows PowerShell Log</h4>
			<p>Windows <a id="_idIndexMarker652"/>PowerShell has always had a strong focus on security and logging, even in its earliest versions. In fact, compared to other shell or scripting <a id="_idIndexMarker653"/>languages, PowerShell’s early versions already had significantly better security logging capabilities. However, over the years, the language evolved, and its logging capabilities expanded enormously, providing us with even better <span class="No-Break">logging nowadays.</span></p>
			<p>Although early versions did not provide us with the security logging that you know from today’s PowerShell <a id="_idIndexMarker654"/>versions, Windows PowerShell has written events to the <strong class="bold">Windows PowerShell event log</strong> since version 1 when important engine events occurred. Back then, PowerShell provided only basic logging functionalities, which are still available in current operating systems, as <span class="No-Break">shown here:</span></p>
			<ul>
				<li><strong class="bold">Full name</strong>: <span class="No-Break">Windows PowerShell</span></li>
				<li><strong class="bold">Log path</strong>: <strong class="source-inline">%</strong><span class="No-Break"><strong class="source-inline">SystemRoot%\System32\Winevt\Logs\Windows PowerShell.evtx</strong></span></li>
				<li><strong class="bold">Path in the UI</strong>: <strong class="bold">Applications and Services</strong> | <span class="No-Break"><strong class="bold">Windows PowerShell</strong></span></li>
			</ul>
			<p>The <em class="italic">most interesting event IDs</em> in these event logs are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Event ID 200</strong> (a warning): <span class="No-Break"><strong class="bold">Command health.</strong></span></li>
			</ul>
			<p>Look for <strong class="source-inline">Host Application</strong> to get more details on the <span class="No-Break">executed command.</span></p>
			<ul>
				<li><strong class="bold">Event ID 400</strong>: <strong class="bold">The engine state is changed from none </strong><span class="No-Break"><strong class="bold">to available.</strong></span></li>
			</ul>
			<p>This event might be <em class="italic">the most interesting event</em> in this event log, as it indicates when the engine was started and which version was used. This event is optimal for identifying and terminating outdated PowerShell versions (monitoring for <strong class="source-inline">HostVersion</strong> less than 5.0) – and is used for downgrade attacks (see the <em class="italic">Detecting a downgrade attack</em> section for <span class="No-Break">more information).</span></p>
			<ul>
				<li><strong class="bold">Event ID 800</strong>: <strong class="bold">The pipeline execution details for the command line –</strong> <em class="italic">&lt;</em><span class="No-Break"><em class="italic">command-line command&gt;</em></span><span class="No-Break"><strong class="bold">.</strong></span></li>
			</ul>
			<p>Although <a id="_idIndexMarker655"/>event ID <strong class="source-inline">800</strong> provides details on the <a id="_idIndexMarker656"/>execution of command lines that contain cmdlets, it doesn’t include information about other executables such as <strong class="source-inline">wmic</strong>. It may be more useful to monitor the event IDs <strong class="source-inline">4103</strong> and <strong class="source-inline">4104</strong> from the <em class="italic">Microsoft Windows PowerShell Operational log</em> for <span class="No-Break">additional details.</span></p>
			<p>The Microsoft Windows PowerShell Operational log contains all relevant information when it comes to the usage <a id="_idIndexMarker657"/>of PowerShell – for example, <strong class="bold">Module Logging</strong> and <a id="_idIndexMarker658"/>also <strong class="bold">Script Block Logging</strong> events are written to <span class="No-Break">this log.</span></p>
			<h4>The Microsoft Windows PowerShell Operational log</h4>
			<p>Starting <a id="_idIndexMarker659"/>with Windows Vista, Microsoft <a id="_idIndexMarker660"/>introduced a new type of logging system called <strong class="bold">ETW</strong>. As part <a id="_idIndexMarker661"/>of this change, the <em class="italic">Microsoft Windows PowerShell Operational log</em> was introduced, which included a range of event IDs such as <strong class="source-inline">4100</strong>, <strong class="source-inline">4103</strong> (although configuring them could be challenging), as well as <strong class="source-inline">40961</strong>, <strong class="source-inline">40862</strong>, and others related to PowerShell <span class="No-Break">Remoting logs.</span></p>
			<p>With <em class="italic">KB3000850</em>, Advanced Audit <a id="_idIndexMarker662"/>capabilities such as <strong class="bold">Module Logging</strong>, <strong class="bold">Script Block Logging</strong>, and <strong class="bold">transcription</strong> could <a id="_idIndexMarker663"/>be ported into PowerShell version <a id="_idIndexMarker664"/>4 (Windows Server 2012 R2 and Windows 8.1). Later on, with PowerShell version 5 (Windows Server 2016 and Windows 10), these features were included <span class="No-Break">by default.</span></p>
			<p>With these new auditing capabilities, there were also new event types introduced, such as the event IDs <strong class="source-inline">4104</strong>, <strong class="source-inline">4105</strong>, and <strong class="source-inline">4106</strong>, which provide you with advanced <span class="No-Break">logging capabilities:</span></p>
			<ul>
				<li><strong class="bold">Full </strong><span class="No-Break"><strong class="bold">name:</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">Microsoft-Windows-Powershell/Operational</strong></span></li>
				<li><strong class="bold">Log </strong><span class="No-Break"><strong class="bold">path</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-PowerShell%4Operational.evtx</strong></span></li>
				<li><strong class="bold">Path in the UI</strong>: <strong class="bold">Applications and Services</strong> | <strong class="bold">Microsoft</strong> | <strong class="bold">Windows</strong> | <strong class="bold">PowerShell</strong> | <span class="No-Break"><strong class="bold">Operational</strong></span></li>
			</ul>
			<p>The <em class="italic">most interesting event IDs</em> in this event logs are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Event ID 4103</strong>: <strong class="bold">Executing pipeline/command invocation. An event is generated if PowerShell Module Logging </strong><span class="No-Break"><strong class="bold">is enabled.</strong></span></li>
				<li><strong class="bold">Event ID 4104</strong>: <strong class="bold">Creating </strong><span class="No-Break"><strong class="bold">Scriptblock text.</strong></span></li>
			</ul>
			<p>An event <a id="_idIndexMarker665"/>is generated if <strong class="source-inline">ScriptBlockLogging</strong> is enabled. Common malicious activities such as loading a malicious <a id="_idIndexMarker666"/>module or executing a suspicious command are logged, regardless of whether <strong class="source-inline">ScriptBlockLogging</strong> is enabled <span class="No-Break">or not.</span></p>
			<ul>
				<li><strong class="bold">Event ID 4105</strong>:<strong class="bold"> ScriptBlock_Invoke_Start_Detail (message: started/completed an invocation </strong><span class="No-Break"><strong class="bold">of ScriptBlock).</strong></span></li>
			</ul>
			<p>An event is generated if <strong class="source-inline">ScriptBlockLogging</strong> is enabled. This records start/stop events. It is very noisy and not necessarily needed for <span class="No-Break">security monitoring.</span></p>
			<ul>
				<li><strong class="bold">Event ID 4106</strong>: <strong class="bold">ScriptBlock_Invoke_Complete_Detail (message: started/completed an invocation </strong><span class="No-Break"><strong class="bold">of ScriptBlock).</strong></span></li>
			</ul>
			<p>An event is generated if <strong class="source-inline">ScriptBlockLogging</strong> is enabled. This records start/stop events. It is very noisy and not necessarily needed for <span class="No-Break">security monitoring.</span></p>
			<ul>
				<li><strong class="bold">Event ID 40961</strong>: <strong class="bold">The PowerShell console is </strong><span class="No-Break"><strong class="bold">starting up.</strong></span></li>
			</ul>
			<p>This event indicates that the PowerShell console was opened. Especially monitor for unusual user behavior using this event (for example, if the PowerShell console was executed by a user that should not log on to this system, or if it’s a <span class="No-Break">system account).</span></p>
			<ul>
				<li><strong class="bold">Event ID 40962</strong>: <strong class="bold">The PowerShell console is ready for </strong><span class="No-Break"><strong class="bold">user input.</strong></span></li>
			</ul>
			<p>This event indicates that the PowerShell console was started and is now ready for user <a id="_idIndexMarker667"/>input. Especially monitor <a id="_idIndexMarker668"/>for unusual user behavior using this event (for example, if the PowerShell console was executed by a user that should not log on to this system or if it’s a <span class="No-Break">system account).</span></p>
			<p>To filter for certain event IDs, you can pipe the output of <strong class="source-inline">Get-WinEvent</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Where-Object</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-WinEvent Microsoft-Windows-PowerShell/Operational | Where-Object Id -eq 4104</pre>
			<p>In this example, you will get all events with the event ID <strong class="source-inline">4104</strong>, which indicates that a script block <span class="No-Break">was created.</span></p>
			<h4>The PowerShellCore Operational log</h4>
			<p>When <a id="_idIndexMarker669"/>PowerShell Core was introduced, so was the <a id="_idIndexMarker670"/>PowerShellCore Operational log. It provides Advanced Audit capabilities for PowerShell Core <span class="No-Break">Event Logging:</span></p>
			<ul>
				<li><strong class="bold">Full </strong><span class="No-Break"><strong class="bold">name:</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">PowerShellCore/Operational</strong></span></li>
				<li><strong class="bold">Log </strong><span class="No-Break"><strong class="bold">path</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">%SystemRoot%\System32\Winevt\Logs\PowerShellCore%4Operational.evtx</strong></span></li>
				<li><strong class="bold">Path in the UI</strong>: <strong class="bold">Applications and Services</strong> | <strong class="bold">PowerShellCore</strong> | <span class="No-Break"><strong class="bold">Operational</strong></span></li>
			</ul>
			<p>The event IDs that are logged within this log file are the same as the ones that are logged in the Microsoft Windows PowerShell Operational log. Please refer to the event IDs in the <span class="No-Break">previous section.</span></p>
			<h3>The Windows Remote Management (WinRM) log</h3>
			<p>The <strong class="bold">Microsoft Windows WinRM Operational log</strong> records both inbound and outbound <a id="_idIndexMarker671"/>WinRM connections. Since <a id="_idIndexMarker672"/>PowerShell relies on WinRM for PowerShell remoting, you can also find PowerShell remote connections in this event log. Therefore, it is essential to also monitor and analyze event IDs from <span class="No-Break">this log.</span></p>
			<ul>
				<li><strong class="bold">Full </strong><span class="No-Break"><strong class="bold">name</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">Microsoft-Windows-WinRM/Operational</strong></span></li>
				<li><strong class="bold">Log </strong><span class="No-Break"><strong class="bold">path</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-WinRM%4Operational.evtx</strong></span></li>
				<li><strong class="bold">Path in the UI</strong>: <strong class="bold">Applications and Services</strong> | <strong class="bold">Microsoft</strong> | <strong class="bold">Windows</strong> | <strong class="bold">Windows Remote Management</strong> | <span class="No-Break"><strong class="bold">Operational</strong></span></li>
			</ul>
			<p>When working with PowerShell and WinRM, the following are <em class="italic">the most interesting events</em> to look for in the WinRM <span class="No-Break">event log.</span></p>
			<ul>
				<li><strong class="bold">Event ID 6</strong>: <strong class="bold">Creating a </strong><span class="No-Break"><strong class="bold">WSMan session.</strong></span></li>
			</ul>
			<p>This is recorded whenever a remote connection is established. It also contains the username, the destination address, and the PowerShell version that <span class="No-Break">was used.</span></p>
			<ul>
				<li><strong class="bold">Event ID 81</strong>: <strong class="bold">Processing a client request for a CreateShell operation or processing a client request for a </strong><span class="No-Break"><strong class="bold">DeleteShell operation.</strong></span></li>
				<li><strong class="bold">Event ID 82</strong>: <strong class="bold">Entering the plugin for a CreateShell operation with a ResourceUri </strong><span class="No-Break"><strong class="bold">of</strong></span><span class="No-Break"><strong class="bold"> &lt;http://schemas.microsoft.com/powershell/Microsoft.PowerShell&gt;</strong></span></li>
				<li><strong class="bold">Event ID 134</strong>: <strong class="bold">Sending a response for a </strong><span class="No-Break"><strong class="bold">CreateShell operation.</strong></span></li>
				<li><strong class="bold">Event ID 169</strong>: <strong class="bold">The </strong><em class="italic">&lt;domain&gt;\&lt;user&gt;</em><strong class="bold"> user has authenticated successfully using </strong><span class="No-Break"><strong class="bold">NTLM authentication.</strong></span></li>
			</ul>
			<p>You can query all events within the WinRM log using <span class="No-Break"><strong class="source-inline">Get-WinEvent Microsoft-Windows-WinRM/Operational</strong></span><span class="No-Break">.</span></p>
			<h3>Security</h3>
			<p>The Security <a id="_idIndexMarker673"/>event log is not only PowerShell <a id="_idIndexMarker674"/>related but also helps to correlate events such as logon/logoff <span class="No-Break">and authentication.</span></p>
			<ul>
				<li><strong class="bold">Full </strong><span class="No-Break"><strong class="bold">name</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">Security</strong></span></li>
				<li><strong class="bold">Log </strong><span class="No-Break"><strong class="bold">path</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">%SystemRoot%\System32\Winevt\Logs\Security.evtx</strong></span></li>
				<li><strong class="bold">Path in the UI</strong>: <strong class="bold">Windows Logs</strong> | <span class="No-Break"><strong class="bold">Security</strong></span></li>
			</ul>
			<p>While not all event IDs in the Security log are generated by default, the most important ones are there to help identify security issues. If you want to implement extensive security logging, I recommend applying the Microsoft Security baselines from the Microsoft Security toolkit to your systems. However, it is important to note that the settings in the Security baseline should be commensurate with your organization’s resources and capabilities. Therefore, it’s advisable to evaluate which logging settings are appropriate for your organization’s needs and capabilities before applying <span class="No-Break">a baseline.</span></p>
			<p>You can <a id="_idIndexMarker675"/>download the <strong class="bold">Microsoft Security toolkit</strong> <span class="No-Break">here: </span><a href="https://www.microsoft.com/en-us/download/details.aspx?id=55319"><span class="No-Break">https://www.microsoft.com/en-us/download/details.aspx?id=55319</span></a><span class="No-Break">.</span></p>
			<p>The event IDs in this event log are some of the most important to monitor for security purposes. While not all of them are specific to PowerShell, they are still critical to maintaining a secure environment. The following are the <em class="italic">most interesting event IDs</em> in this <span class="No-Break">event log:</span></p>
			<ul>
				<li><strong class="bold">Event ID 4657</strong>: <strong class="bold">A registry value </strong><span class="No-Break"><strong class="bold">was modified</strong></span></li>
				<li><strong class="bold">Event ID 4688</strong>: <strong class="bold">A new process has been created. Look for processes with powershell.exe as the “New Process Name”. You can use the Creator Process ID to link what process launched which </strong><span class="No-Break"><strong class="bold">other processes.</strong></span></li>
				<li><strong class="bold">Event ID 1100</strong>: <strong class="bold">The Event Logging service has </strong><span class="No-Break"><strong class="bold">shut down.</strong></span></li>
				<li><strong class="bold">Event ID 1102</strong>: <strong class="bold">The audit log </strong><span class="No-Break"><strong class="bold">was cleared.</strong></span></li>
				<li><strong class="bold">Event ID 1104</strong>: <strong class="bold">The security log is </strong><span class="No-Break"><strong class="bold">now full.</strong></span></li>
				<li><strong class="bold">Event ID 4624</strong>: <strong class="bold">An account was successfully </strong><span class="No-Break"><strong class="bold">logged on.</strong></span></li>
				<li><strong class="bold">Event ID 4625</strong>: <strong class="bold">An account failed to </strong><span class="No-Break"><strong class="bold">log on.</strong></span></li>
			</ul>
			<p>The Security <a id="_idIndexMarker676"/>log is quite extensive and contains <a id="_idIndexMarker677"/>a lot of important event IDs. Covering just the Security log could fill an entire book; therefore, this list is not complete, and I only listed some of the most important ones when it comes <span class="No-Break">to PowerShell.</span></p>
			<p>Nevertheless, the question of <em class="italic">which security event IDs matter</em> has kept me awake many nights, and so I came <a id="_idIndexMarker678"/>up with an open source tool called <strong class="bold">EventList</strong>. If you want to find out which event IDs matter, have a look at the <em class="italic">Forwarding and analyzing event logs – EventList</em> section in <span class="No-Break">this chapter.</span></p>
			<h3>System</h3>
			<p>In the <a id="_idIndexMarker679"/>system log, many system-relevant log IDs <span class="No-Break">are </span><span class="No-Break"><a id="_idIndexMarker680"/></span><span class="No-Break">generated:</span></p>
			<ul>
				<li><strong class="bold">Full </strong><span class="No-Break"><strong class="bold">name</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">System</strong></span></li>
				<li><strong class="bold">Log </strong><span class="No-Break"><strong class="bold">path</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">%SystemRoot%\System32\Winevt\Logs\System.evtx</strong></span></li>
				<li><strong class="bold">Path in the UI</strong>: <strong class="bold">Windows Logs</strong> | <span class="No-Break"><strong class="bold">System</strong></span></li>
			</ul>
			<p>The <em class="italic">most interesting event ID</em> in this event log for PowerShell security logging is <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Event ID 104</strong> – <strong class="bold">the </strong><em class="italic">&lt;name&gt;</em><strong class="bold"> log was cleared.</strong> This event indicates that the event log with the name <em class="italic">&lt;name&gt;</em> was cleared, which could indicate an adversary trying to hide traces. Especially use this event ID to monitor for the log names <em class="italic">“Windows PowerShell,"</em> <em class="italic">“PowerShell Operational,"</em> or <em class="italic">“PowerShellCore”</em> to detect PowerShell-related event <span class="No-Break">log clearing.</span></li>
			</ul>
			<p>Depending on what you are monitoring for, there are many interesting events in this log – for example, details on <span class="No-Break">every installation.</span></p>
			<h3>Windows Defender</h3>
			<p>The Windows <a id="_idIndexMarker681"/>Defender log has been enabled by default since <a id="_idIndexMarker682"/>Windows 10 and Windows Server 2016, and it provides a lot of helpful events. For example, it also contains <a id="_idIndexMarker683"/>events related to the <strong class="bold">Antimalware Scan Interface</strong> (<strong class="bold">AMSI</strong>), which is a part of <span class="No-Break">Windows Defender:</span></p>
			<ul>
				<li><strong class="bold">Full name</strong>: <span class="No-Break"><strong class="source-inline">Microsoft-Windows-Windows Defender/Operational</strong></span></li>
				<li><strong class="bold">Log path</strong>: <strong class="source-inline">%</strong><span class="No-Break"><strong class="source-inline">SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-Windows Defender%4Operational.evtx</strong></span></li>
				<li><strong class="bold">Path in the UI</strong>: <strong class="bold">Applications and Services</strong> | <strong class="bold">Microsoft</strong> | <strong class="bold">Windows</strong> | <strong class="bold">Windows Defender</strong> | <span class="No-Break"><strong class="bold">Operational</strong></span></li>
			</ul>
			<p>The <em class="italic">most interesting event IDs</em> in this event log for PowerShell security logging are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Event ID 1116</strong>: <strong class="bold">Microsoft Defender Antivirus has detected malware or other potentially </strong><span class="No-Break"><strong class="bold">unwanted software.</strong></span></li>
				<li><strong class="bold">Event ID 1117</strong>: <strong class="bold">Microsoft Defender Antivirus has taken action to protect this machine from malware or other potentially </strong><span class="No-Break"><strong class="bold">unwanted software.</strong></span></li>
			</ul>
			<p>If Microsoft Defender is used on your machine, you will find many more interesting Defender-related log events in this event log. Use this reference to learn more about each Microsoft Defender-related event <span class="No-Break">ID: </span><a href="https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/troubleshoot-microsoft-defender-antivirus"><span class="No-Break">https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/troubleshoot-microsoft-defender-antivirus</span></a><span class="No-Break">.</span></p>
			<p>We will take a closer look at AMSI in <a href="B16679_12_Final_PD.xhtml#_idTextAnchor324"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Exploring the Antimalware Scan </em><span class="No-Break"><em class="italic">Interface (AMSI)</em></span><span class="No-Break">.</span></p>
			<h3>Windows Defender Application Control and AppLocker</h3>
			<p><strong class="bold">Windows Defender Application Control</strong> (<strong class="bold">WDAC</strong>) and <strong class="bold">AppLocker</strong> can <a id="_idIndexMarker684"/>be used <a id="_idIndexMarker685"/>to allowlist <a id="_idIndexMarker686"/>applications <a id="_idIndexMarker687"/>to restrict which software is allowed to be used within an organization. Both solutions help you to protect against the unauthorized use <span class="No-Break">of software.</span></p>
			<p>We <a id="_idIndexMarker688"/>will take <a id="_idIndexMarker689"/>a closer look at WDAC and AppLocker in <a href="B16679_11_Final_PD.xhtml#_idTextAnchor306"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">AppLocker, Application Control, and </em><span class="No-Break"><em class="italic">Code Signing</em></span><span class="No-Break">.</span></p>
			<p>When <a id="_idIndexMarker690"/>enabling allowlist solutions, auditing is the first major step; hence, analyzing WDAC and AppLocker-related event IDs is necessary for <span class="No-Break">this process.</span></p>
			<h4>Windows Defender Application Control (WDAC)</h4>
			<p>WDAC is Microsoft’s latest allowlisting solution, which was introduced with Windows 10 and was earlier known as <em class="italic">Device Guard</em>. In addition to allowlisting applications, WDAC can also be used to enforce code integrity policies on <span class="No-Break">Windows machines.</span></p>
			<p>WDAC has two main event logs – one event log named <strong class="bold">MSI and Scripts</strong> is shared with AppLocker, and <a id="_idIndexMarker691"/>another event log is used to log <strong class="bold">Code </strong><span class="No-Break"><strong class="bold">Integrity</strong></span><span class="No-Break">-related events.</span></p>
			<p><span class="No-Break"><strong class="bold">Code Integrity</strong></span></p>
			<ul>
				<li><strong class="bold">Full </strong><span class="No-Break"><strong class="bold">name</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">Microsoft-Windows-CodeIntegrity/Operational</strong></span></li>
				<li><strong class="bold">Log </strong><span class="No-Break"><strong class="bold">path</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-CodeIntegrity%4Operational.evtx</strong></span></li>
				<li><strong class="bold">Path in the UI</strong>: <strong class="bold">Applications and Services Logs</strong> | <strong class="bold">Microsoft</strong> | <strong class="bold">Windows</strong> | <strong class="bold">CodeIntegrity</strong> | <span class="No-Break"><strong class="bold">Operational</strong></span></li>
			</ul>
			<p>The <em class="italic">most interesting event IDs</em> in this event logs for PowerShell security logging are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Event ID 3001</strong>: <strong class="bold">An unsigned driver attempted to load on </strong><span class="No-Break"><strong class="bold">the system.</strong></span></li>
				<li><strong class="bold">Event ID 3023</strong>: <strong class="bold">The driver file under validation didn’t meet the requirements to pass the Application </strong><span class="No-Break"><strong class="bold">Control policy.</strong></span></li>
				<li><strong class="bold">Event ID 3033</strong>: <strong class="bold">The file under validation didn’t meet the requirements to pass the Application </strong><span class="No-Break"><strong class="bold">Control policy.</strong></span></li>
				<li><strong class="bold">Event ID 3034</strong>: <strong class="bold">The file under validation didn’t meet the requirements to pass the Application Control policy if it was enforced. The file was allowed, since the policy is in </strong><span class="No-Break"><strong class="bold">audit mode.</strong></span></li>
				<li><strong class="bold">Event ID 3064</strong>: <strong class="bold">If the Application Control policy was enforced, a user mode DLL under validation didn’t meet the requirements to pass the Application Control policy. The DLL was allowed, since the policy is in </strong><span class="No-Break"><strong class="bold">audit mode.</strong></span></li>
				<li><strong class="bold">Event ID 3065</strong>: <strong class="bold">If the Application Control policy was enforced, a user mode DLL under validation didn’t meet the requirements to pass the Application </strong><span class="No-Break"><strong class="bold">Control policy.</strong></span></li>
				<li><strong class="bold">Event ID 3076</strong>: <strong class="bold">This event is the main Application Control block event for audit mode policies. It indicates that the file would have been blocked if the policy </strong><span class="No-Break"><strong class="bold">was enforced.</strong></span></li>
				<li><strong class="bold">Event ID 3077</strong>: <strong class="bold">This event is the main Application Control block event for enforced policies. It indicates that the file didn’t pass your policy and </strong><span class="No-Break"><strong class="bold">was blocked.</strong></span></li>
			</ul>
			<p>You can <a id="_idIndexMarker692"/>query all events within the WDAC log using <strong class="source-inline">Get-WinEvent Microsoft-Windows-CodeIntegrity/Operational</strong>. Monitoring and analyzing these events can help identify potential security breaches and improve the overall security posture of <span class="No-Break">a system.</span></p>
			<p><strong class="bold">MSI </strong><span class="No-Break"><strong class="bold">and Script</strong></span></p>
			<p>All Microsoft <a id="_idIndexMarker693"/>Installer and script-related event IDs can be found in this <span class="No-Break">event log:</span></p>
			<ul>
				<li><strong class="bold">Full name</strong>: <strong class="source-inline">Microsoft-Windows-AppLocker/MSI </strong><span class="No-Break"><strong class="source-inline">and Script</strong></span></li>
				<li><strong class="bold">Log path</strong>: <strong class="source-inline">%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-AppLocker%4MSI </strong><span class="No-Break"><strong class="source-inline">and Script.evtx</strong></span></li>
				<li><strong class="bold">Path in the UI</strong>: <strong class="bold">Applications and Services Logs</strong> | <strong class="bold">Microsoft</strong> | <strong class="bold">Windows</strong> | <strong class="bold">Applocker</strong> | <strong class="bold">MSI </strong><span class="No-Break"><strong class="bold">and Script</strong></span></li>
			</ul>
			<p>The <em class="italic">most interesting event IDs</em> in the event <a id="_idIndexMarker694"/>logs for PowerShell security logging are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Event ID 8028</strong>: <em class="italic">*</em><strong class="bold"> was allowed to run but would have been prevented if the Config CI policy </strong><span class="No-Break"><strong class="bold">was enforced.</strong></span></li>
				<li><strong class="bold">Event ID 8029</strong>: <em class="italic">*</em><strong class="bold"> was prevented from running due to the Config </strong><span class="No-Break"><strong class="bold">CI policy.</strong></span></li>
				<li><strong class="bold">Event ID 8036</strong>: <em class="italic">*</em><strong class="bold"> was prevented from running due to the Config </strong><span class="No-Break"><strong class="bold">CI policy.</strong></span></li>
				<li><strong class="bold">Event ID 8037</strong>: <em class="italic">*</em><strong class="bold"> passed the Config CI policy and was allowed </strong><span class="No-Break"><strong class="bold">to run.</strong></span></li>
			</ul>
			<p>If you <a id="_idIndexMarker695"/>want to learn about more Application Control event IDs, have a look at the <em class="italic">AppLocker</em> section and the following <span class="No-Break">documentation: </span><a href="https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/event-id-explanations"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/event-id-explanations</span></a><span class="No-Break">.</span></p>
			<h4>AppLocker</h4>
			<p>When it comes <a id="_idIndexMarker696"/>to AppLocker, there are four event log files that you might want to examine, depending on your use case – <em class="italic">EXE and DLL</em>, <em class="italic">MSI and Script</em>, <em class="italic">Packaged app-Deployment</em>, and <span class="No-Break"><em class="italic">Packaged app-Execution</em></span><span class="No-Break">.</span></p>
			<p>In the UI, you can find all four logs under the same path – simply replace <strong class="bold">&lt;Name of the log&gt;</strong> with the name of each event log, as <span class="No-Break">shown here:</span></p>
			<p><strong class="bold">Path in the UI</strong>: <strong class="bold">Applications and Services</strong> | <strong class="bold">Microsoft</strong> | <strong class="bold">Windows</strong> | <strong class="bold">AppLocker</strong> | <strong class="bold">&lt;Name of </strong><span class="No-Break"><strong class="bold">the log&gt;</strong></span></p>
			<p>The following is the full name and the path of each AppLocker-related event log (please note that auditing must be enabled in order for any of these event logs <span class="No-Break">to appear):</span></p>
			<ul>
				<li><strong class="bold">EXE </strong><span class="No-Break"><strong class="bold">and DLL</strong></span></li>
			</ul>
			<p>All event IDs that are related to executing binaries (EXE) and DLLs can be found in this <span class="No-Break">event log:</span></p>
			<ul>
				<li><strong class="bold">Full name</strong>: <strong class="source-inline">Microsoft-Windows-AppLocker/EXE </strong><span class="No-Break"><strong class="source-inline">and DLL</strong></span></li>
				<li><strong class="bold">Log path</strong>: <strong class="source-inline">%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-AppLocker%4EXE </strong><span class="No-Break"><strong class="source-inline">and DLL.evtx</strong></span></li>
			</ul>
			<ul>
				<li><strong class="bold">MSI </strong><span class="No-Break"><strong class="bold">and Script</strong></span></li>
			</ul>
			<p>All Microsoft Installer and script-related event IDs can be found in this <span class="No-Break">event log:</span></p>
			<ul>
				<li><strong class="bold">Full name</strong>: <strong class="source-inline">Microsoft-Windows-AppLocker/MSI </strong><span class="No-Break"><strong class="source-inline">and Script</strong></span></li>
				<li><strong class="bold">Log path</strong>: <strong class="source-inline">%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-AppLocker%4MSI </strong><span class="No-Break"><strong class="source-inline">and Script.evtx</strong></span></li>
			</ul>
			<ul>
				<li><span class="No-Break"><strong class="bold">Packaged app-Deployment</strong></span></li>
			</ul>
			<p>If a packaged <a id="_idIndexMarker697"/>app is deployed, you can find all related event IDs in this <span class="No-Break">event log:</span></p>
			<ul>
				<li><strong class="bold">Full name</strong>: <span class="No-Break"><strong class="source-inline">Microsoft-Windows-AppLocker/Packaged app-Deployment</strong></span></li>
				<li><strong class="bold">Log path</strong>: <strong class="source-inline">%</strong><span class="No-Break"><strong class="source-inline">SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-AppLocker%4Packaged app-Deployment.evtx</strong></span></li>
			</ul>
			<ul>
				<li><span class="No-Break"><strong class="bold">Packaged app-Execution</strong></span></li>
			</ul>
			<p>All packaged app execution-related event IDs can be found in this <span class="No-Break">event log.</span></p>
			<ul>
				<li><strong class="bold">Full name</strong>: <span class="No-Break"><strong class="source-inline">Microsoft-Windows-AppLocker/Packaged app-Execution</strong></span></li>
				<li><strong class="bold">Log path</strong>: <strong class="source-inline">%</strong><span class="No-Break"><strong class="source-inline">SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-AppLocker%4Packaged app-Execution.evtx</strong></span></li>
			</ul>
			<p>The <em class="italic">most interesting event IDs</em> in these <a id="_idIndexMarker698"/>event logs for PowerShell security logging are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Event ID 8000 (error)</strong>: <strong class="bold">The Application Identity Policy conversion failed. Status *&lt;%1&gt; This indicates that the policy was not applied correctly to the computer. The status message is provided for </strong><span class="No-Break"><strong class="bold">troubleshooting purposes.</strong></span></li>
				<li><strong class="bold">Event ID 8001 (information)</strong>: <strong class="bold">The AppLocker policy was applied successfully to this computer. This indicates that the AppLocker policy was successfully applied to </strong><span class="No-Break"><strong class="bold">the computer.</strong></span></li>
				<li><strong class="bold">Event ID 8002 (information)</strong>: <em class="italic">&lt;Filename&gt;</em><strong class="bold"> was allowed to run. This specifies that the .exe or .dll file is allowed by an </strong><span class="No-Break"><strong class="bold">AppLocker rule.</strong></span></li>
				<li><strong class="bold">Event ID 8003 (warning)</strong>: <em class="italic">&lt;Filename&gt;</em><strong class="bold"> was allowed to run but would have been prevented from running if the AppLocker policy were enforced. This is applied only when the Audit only enforcement mode is enabled. It specifies that the .exe or .dll file would be blocked if the Enforce rules enforcement mode </strong><span class="No-Break"><strong class="bold">were enabled.</strong></span></li>
				<li><strong class="bold">Event ID 8004 (error)</strong>: <em class="italic">&lt;Filename&gt;</em><strong class="bold"> was not allowed to run. Access to &lt;filename&gt; is restricted by the administrator. This is applied only when the Enforce rules enforcement mode is set either directly or indirectly through Group Policy inheritance. The .exe or .dll file </strong><span class="No-Break"><strong class="bold">cannot run.</strong></span></li>
				<li><strong class="bold">Event ID 8005 (information)</strong>: <em class="italic">&lt;Filename&gt;</em><strong class="bold"> was allowed to run. This specifies that the script or .msi file is allowed by an </strong><span class="No-Break"><strong class="bold">AppLocker rule.</strong></span></li>
				<li><strong class="bold">Event ID 8006 (warning)</strong>: <em class="italic">&lt;Filename&gt;</em><strong class="bold"> was allowed to run but would have been prevented from running if the AppLocker policy were enforced. This is applied only when the Audit only enforcement mode is enabled. It specifies that the script or .msi file would be blocked if the Enforce rules enforcement mode </strong><span class="No-Break"><strong class="bold">were enabled.</strong></span></li>
				<li><strong class="bold">Event ID 8007 (error)</strong>: <em class="italic">&lt;Filename&gt;</em><strong class="bold"> was not allowed to run. Access to &lt;Filename&gt; is restricted by the administrator. This is applied only when the Enforce rules enforcement mode is set either directly or indirectly through Group Policy inheritance. The script or .msi file </strong><span class="No-Break"><strong class="bold">cannot run.</strong></span></li>
				<li><strong class="bold">Event ID 8008 (error)</strong>: <strong class="bold">AppLocker is disabled on the SKU. This was added in Windows Server 2012 and </strong><span class="No-Break"><strong class="bold">Windows 8.</strong></span></li>
			</ul>
			<p>If you are <a id="_idIndexMarker699"/>interested in learning about more AppLocker event IDs, please refer to the following <span class="No-Break">link: </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/using-event-viewer-with-applocker"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/using-event-viewer-with-applocker</span></a><span class="No-Break">.</span></p>
			<p>There are, of course, many other <a id="_idIndexMarker700"/>interesting log files, such as <strong class="bold">Firewall</strong> and <strong class="bold">DSC</strong>. Mentioning <a id="_idIndexMarker701"/>and describing all of them would exceed the content of this book; therefore, I have only mentioned some of the most interesting log files when it comes to <span class="No-Break">PowerShell Security.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor106"/>Increasing log size</h2>
			<p>Every event that is generated lets a log file grow. As thousands of events can be written in a very short time, it is useful to increase the maximum log file size – especially if you also want to <a id="_idIndexMarker702"/>analyze <span class="No-Break">events locally.</span></p>
			<p>Of course, it is always recommended to forward your logs to a central log repository to make sure the logs will not be lost. However, if you want to analyze events locally, it is also helpful to increase the log <span class="No-Break">file size.</span></p>
			<p>The <strong class="source-inline">Limit-EventLog</strong> cmdlet can help you with this task in <span class="No-Break">Windows PowerShell:</span></p>
			<pre class="source-code">
&gt; Limit-EventLog -LogName "Windows PowerShell" -MaximumSize 4194240KB</pre>
			<p>This command sets the maximum size of the PowerShell log to <em class="italic">4 GB</em>. Please note that the “MB” and “GB” prefixes are also available in <span class="No-Break">this cmdlet.</span></p>
			<p>When setting the maximum size of the event log, it’s important to keep in mind that the size of an event log entry can vary, depending on the specific event log and the number of enabled events. Look how much space one event usually takes up in your environment on average per log. First, you need to get the log size of an event log. The following command returns the maximum size of the Windows PowerShell event log in <em class="italic">KB:</em> </p>
			<pre class="source-code">
<strong class="bold">&gt; – Get-ItemProperty -Path  'HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\Windows PowerShell\' -Name 'MaxSize' | Select-Object -ExpandProperty MaxSize</strong></pre>
			<p>Then, divide it by the number of entries. Just like that you can calculate the estimated size of your <a id="_idIndexMarker703"/>event log and how many events it should hold before events will <span class="No-Break">be rotated.</span></p>
			<p>If you use PowerShell 7, the <strong class="source-inline">Limit-EventLog</strong> cmdlet is not available. Instead, you will need to alter the registry, <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">New-ItemProperty</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; New-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\Windows PowerShell\' -Name 'MaxSize' -Value 4000MB -PropertyType DWORD -Force</pre>
			<p>Using the <strong class="source-inline">Limit-EventLog</strong> command, you can also specify the behavior when an event log is <span class="No-Break">full: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/limit-eventlog"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/limit-eventlog</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor107"/>Summary</h1>
			<p>In this chapter, you learned how to get started with security logging for PowerShell. You now know which event logs are of interest and which event IDs you should look for. As security monitoring is a huge topic, you have learned just the basics on how to get started <span class="No-Break">and continue.</span></p>
			<p>You learned how to configure PowerShell Module Logging, Script Block Logging, and PowerShell transcripts – manually and centralized for Windows PowerShell, as well as for <span class="No-Break">PowerShell Core.</span></p>
			<p>Another important learning point is that log events can be tampered with, and you can implement some level of protection using Protected <span class="No-Break">Event Logging.</span></p>
			<p>Eventually, it is best to forward your log events to a centralized SIEM system, but if that’s not possible, you also learned how to analyze events <span class="No-Break">using PowerShell.</span></p>
			<p>Now that you have been provided with some example scripts and code snippets, you are ready to investigate all PowerShell activity on your clients <span class="No-Break">and servers.</span></p>
			<p>Last but not least, if you want to dive deeper into security monitoring, EventList can help you to find out which events are important <span class="No-Break">to monitor.</span></p>
			<p>When we talk about auditing, detection, and monitoring; local systems are not far away. Let’s dive deeper into the system and have a look at the Windows registry, the Windows API, COM, CIM/WMI, and how it is possible to run PowerShell without running <strong class="source-inline">powershell.exe</strong> in our <span class="No-Break">next chapter.</span></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor108"/>Further reading</h1>
			<p>If you want to explore some of the topics that were mentioned in this chapter, follow <span class="No-Break">these resources:</span></p>
			<ul>
				<li><strong class="bold">Auditing – </strong><span class="No-Break"><strong class="bold">further resources</strong></span><span class="No-Break">:</span><ul><li>Detecting Offensive PowerShell Attack <span class="No-Break">Tools: </span><a href="https://adsecurity.org/?p=2604"><span class="No-Break">https://adsecurity.org/?p=2604</span></a></li><li>Lee Holmes on downgrade <span class="No-Break">attacks: </span><a href="https://www.leeholmes.com/blog/2017/03/17/detecting-and-preventing-powershell-downgrade-attacks/"><span class="No-Break">https://www.leeholmes.com/blog/2017/03/17/detecting-and-preventing-powershell-downgrade-attacks/</span></a></li><li>Microsoft <span class="No-Break">SCT: </span><a href="https://www.microsoft.com/en-us/download/details.aspx?id=55319"><span class="No-Break">https://www.microsoft.com/en-us/download/details.aspx?id=55319</span></a></li><li>PowerShell ♥ the Blue <span class="No-Break">Team: </span><a href="https://devblogs.microsoft.com/powershell/powershell-the-blue-team/"><span class="No-Break">https://devblogs.microsoft.com/powershell/powershell-the-blue-team/</span></a></li><li>Windows 10 and Windows Server 2016 security auditing and monitoring <span class="No-Break">reference: </span><a href="https://www.microsoft.com/en-us/download/details.aspx?id=52630"><span class="No-Break">https://www.microsoft.com/en-us/download/details.aspx?id=52630</span></a></li><li><em class="italic">PowerShell post-exploitation, the Empire has fallen, You CAN detect PowerShell exploitation</em> by Michael <span class="No-Break">Gough: </span><a href="https://de.slideshare.net/Hackerhurricane/you-can-detect-powershell-attacks"><span class="No-Break">https://de.slideshare.net/Hackerhurricane/you-can-detect-powershell-attacks</span></a></li></ul></li>
				<li><span class="No-Break"><strong class="bold">EventList</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break">GitHub: </span><a href="https://github.com/miriamxyra/EventList"><span class="No-Break">https://github.com/miriamxyra/EventList</span></a></li><li>Black Hat presentation 2020 (version <span class="No-Break">2.0.0): </span><a href="https://www.youtube.com/watch?v=3x5-nZ2bfbo"><span class="No-Break">https://www.youtube.com/watch?v=3x5-nZ2bfbo</span></a></li></ul></li>
				<li><strong class="bold">Helpful cmdlets </strong><span class="No-Break"><strong class="bold">and commands</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">Limit-EventLog</strong> <span class="No-Break">documentation: </span><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/limit-eventlog?view=powershell-5.1</span></li><li><strong class="source-inline">Start-Transcript</strong> <span class="No-Break">documentation: </span><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.host/start-transcript?view=powershell-7#parameters</span></li><li><strong class="source-inline">wevtutil</strong> <span class="No-Break">documentation: </span><span class="No-Break">https://docs.microsoft.com/de-de/windows-server/administration/windows-commands/wevtutil</span></li><li><span class="No-Break"><strong class="source-inline">Unprotect-CmsMessage</strong></span><span class="No-Break">: </span><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/unprotect-cmsmessage</span></li></ul></li>
				<li><strong class="bold">PowerShell Logging and </strong><span class="No-Break"><strong class="bold">event logs</strong></span><span class="No-Break">:</span><ul><li>RFC – <span class="No-Break">CMS: </span><span class="No-Break">https://www.rfc-editor.org/rfc/rfc5652</span></li><li>PowerShell Core Group Policy <span class="No-Break">settings: </span><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_group_policy_settings?view=powershell-7.1</span></li><li>PowerShell logging on a non-Windows <span class="No-Break">OS: </span><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_non-windows?view=powershell-7</span></li><li>About logging on a Windows <span class="No-Break">OS: </span><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_windows?view=powershell-7.1</span></li><li>About event logs (v <span class="No-Break">5.1): </span><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_eventlogs</span></li></ul></li>
			</ul>
			<p>You can also find all links mentioned in this chapter in the GitHub repository for <span class="No-Break"><em class="italic">Chapter 4</em></span> – there’s no need to manually type in every <span class="No-Break">link: </span><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Links.md.</span></p>
		</div>
	

		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer109">
			</div>
		</div>
		<div class="Content" id="_idContainer110">
			<h1 id="_idParaDest-103"><a id="_idTextAnchor109"/>Part 2: Digging Deeper – Identities, System Access, and Day-to-Day Security Tasks</h1>
			<p>Let’s dive deeper and combine PowerShell with other technologies. The technology section of this part mostly explores the ways that attackers can enumerate, bypass, hijack, and compromise key components such as the operating system itself, Active Directory, and Azure AD/Entra ID. On July 11, 2023 Microsoft renamed Azure AD to Entra ID. As this was just shortly announced before this book was released, we will refer to Entra ID just as Azure Active Directory, Azure AD, or AAD in this part. This part is not only of interest to red teamers but also to blue teamers who want to learn how adversaries are trying to abuse well-established solutions in order to protect themselves from such attacks. Additionally, you will get a lot of useful extra information about concepts, protocols, and mitigation, and many more <span class="No-Break">interesting insights.</span></p>
			<p>We’ll first explore PowerShell’s capabilities to access the system: we will not only look into working with the registry and WMI but we will also find out how you can leverage .NET, as well as native Windows APIs, and how you can compile and run custom DLLs and unmanaged code from PowerShell. Ever wondered how it is possible to run PowerShell without calling powershell.exe? Don’t worry – after working through this part, you <span class="No-Break">will know.</span></p>
			<p>In the Active Directory chapter, we will dive into enumeration – with or without the Active Directory PowerShell module – as well as into access rights, authentication protocols, credential theft, and mitigation tactics. We will also look into the recommended Microsoft security baselines and the Security <span class="No-Break">Compliance Toolkit.</span></p>
			<p>When talking about Active Directory, Azure AD is not far away; therefore, we will also investigate this technology from a PowerShell security perspective. Azure AD security is not a broadly well-known topic, and in this chapter, you will learn how to differentiate between Active Directory and Azure AD and about fundamental Azure AD concepts. You will learn which accounts and roles make useful targets for attackers and how Azure AD can be enumerated. Last but not least, we will explore several credential theft techniques and also look into <span class="No-Break">mitigating them.</span></p>
			<p>In <a href="B16679_08_Final_PD.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> and <a href="B16679_09_Final_PD.xhtml#_idTextAnchor228"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, this book also provides you with red and blue team cookbooks. Both parts first explore the common PowerShell tools for both intents and then provide many useful PowerShell code snippets that you can use for your own purposes – no matter whether you are a blue or <span class="No-Break">red teamer.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B16679_05_Final_PD.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>, <em class="italic">PowerShell Is Powerful – System and API Access</em></li>
				<li><a href="B16679_06_Final_PD.xhtml#_idTextAnchor150"><em class="italic">Chapter 6</em></a>, <em class="italic">Active Directory – Attacks and Mitigation</em></li>
				<li><a href="B16679_07_Final_PD.xhtml#_idTextAnchor179"><em class="italic">Chapter 7</em></a>,<em class="italic"> Hacking the Cloud – Exploiting Azure Active Directory/Entra ID</em></li>
				<li><a href="B16679_08_Final_PD.xhtml#_idTextAnchor204"><em class="italic">Chapter 8</em></a>,<em class="italic"> Red Team Tasks and Cookbook</em></li>
				<li><a href="B16679_09_Final_PD.xhtml#_idTextAnchor228"><em class="italic">Chapter 9</em></a>,<em class="italic"> Blue Team Tasks and Cookbook</em></li>
			</ul>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer111">
			</div>
		</div>
		<div>
			<div id="_idContainer112">
			</div>
		</div>
	</body></html>