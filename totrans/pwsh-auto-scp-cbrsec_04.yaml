- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Detection – Auditing and Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although organizations already try to harden their environments, only a few
    take into account that auditing and monitoring are two of the most important things
    when it comes to securing your environment.
  prefs: []
  type: TYPE_NORMAL
- en: For many years while working at Microsoft, I have preached the *protect*, *detect*,
    and *respond* approach. Most companies try to just *protect* their devices, but
    that’s where they stop. To *detect* and *respond*, there needs to be not only
    a working **Security Operations Center** (**SOC**) in place but also infrastructure
    and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Those people and resources require money – a budget that many companies don’t
    want to spend in the first place, unless they have been breached.
  prefs: []
  type: TYPE_NORMAL
- en: When working with customers, I saw only a few environments with a working SOC
    in place, as well as the infrastructure to host a **Security Information and Event
    Management** (**SIEM**) system. I was really happy that when I left those customers,
    most of them started rethinking their approach and improved their security practices,
    as well as their monitoring and detection.
  prefs: []
  type: TYPE_NORMAL
- en: However, I also had customers that were already breached when I was introduced
    to them for the first time. Customers that never had the budget nor employees
    for detections suddenly had the budget to improve immediately, as soon as they
    were breached.
  prefs: []
  type: TYPE_NORMAL
- en: And over the years, I learned that it’s not a question of *whether* an organization
    will be hacked – it is rather *when* they will be hacked, and *how long* the attacker
    stays in the environment unnoticed. That’s if they are detected at all.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, I recommend to every IT decision-maker that I meet to *assume a breach*
    and protect what is important.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, I saw more and more organizations that actually had operating
    SOCs in place, which made me really happy. But unfortunately – especially when
    looking at small and medium-sized enterprises – most organizations have either
    no monitoring in place or are just starting their journey.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell has been covered in the media several times when it comes to attacks.
    Ransomware malware was distributed, sending malicious emails that launched PowerShell
    in the background to execute a payload, a fileless attack in which the malware
    does not need to be downloaded on the client but runs in the memory instead, and
    even legitimate system tools that have been abused by adversaries to execute their
    attacks (also known as **Living Off the Land** or **LOLbins**).
  prefs: []
  type: TYPE_NORMAL
- en: And yes, attackers like to leverage what they already find on a system. However,
    if organizations had not only the appropriate mitigations in place but also the
    right detection, it would make it way harder for adversaries to launch a successful
    attack and stay unnoticed.
  prefs: []
  type: TYPE_NORMAL
- en: Many tools that adversaries use in their attacks provide little to no transparency,
    so it can be really hard for defenders (a.k.a. the **blue team**) to detect and
    analyze such an attack.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell, in contrast, provides such amazing logging opportunities that it
    is quite easy to analyze and detect an attack that was launched using it. Therefore,
    if you are a blue teamer and you notice that you were targeted with a PowerShell-based
    attack, you are in luck (as much as you can be in luck if your infrastructure
    was attacked)! This makes it much easier for you to find out what happened.
  prefs: []
  type: TYPE_NORMAL
- en: Having an extensive (not exclusively restricted to) PowerShell logging infrastructure
    in place helps your SOC team to identify attackers and get insights into what
    commands and code adversaries executed. It also helps to improve your detection
    and security controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the basics of security monitoring with PowerShell,
    which will help you to get started with your detections or improve them. In this
    chapter, you will get a deeper understanding of the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring PowerShell Event Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell Module Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell Script Block Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protected Event Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell transcripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing event logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most important PowerShell related event logs and IDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the most out of this chapter, ensure that you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell 7.3 and above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access to the GitHub repository for **Chapter04**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter04](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter04)'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring PowerShell Event Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing robust auditing mechanisms for PowerShell to help you monitor,
    detect and prevent potential threats is an essential step to ensure effective
    security practices for PowerShell. By leveraging PowerShell logging, you can capture
    detailed information about PowerShell activities on your systems, which is essential
    for detecting and investigating security incidents. PowerShell logging can help
    you identify suspicious activities, such as the execution of malicious commands
    or the modification of critical system settings.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss the different types of PowerShell logging that
    you can enable, including PowerShell Module Logging, PowerShell Script Block Logging,
    Protected Event Logging, and PowerShell transcripts. We will also look into how
    to configure these logging features to meet your organization’s specific security
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell Module Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PowerShell Module Logging was added with **PowerShell 3.0**. This feature provides
    extensive logging of all PowerShell commands that are executed on the system.
    If Module Logging is enabled, pipeline execution events are generated and written
    to the **Microsoft-Windows-Powershell/Operational** event log in the context of
    event ID **4103**.
  prefs: []
  type: TYPE_NORMAL
- en: How to configure Module Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can either enable Module Logging for the execution of a module in the current
    session, or you can configure it to be turned on permanently.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling it only within a single session only makes sense if you want to troubleshoot
    the behavior of a certain module. If you want to detect the commands that adversaries
    run in your infrastructure, it makes sense to turn on Module Logging permanently.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable Module Logging within the current session, only for a certain module,
    you need to import the module first. In this example, we will use the **EventList**
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can replace the module name, **EventList**, with any other module
    name that you want to log pipeline execution details for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you want to monitor a managed environment, you don’t want to enable PowerShell
    Module Logging manually on every host. In this case, you can use Group Policy
    to enable Module Logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new **Group Policy Object** (**GPO**). As Windows PowerShell and PowerShell
    Core were designed to co-exist and can be configured individually, it depends
    on what PowerShell version you want to configure:'
  prefs: []
  type: TYPE_NORMAL
- en: To configure Windows PowerShell, navigate to **Computer Configuration** | **Policies**
    | **Administrative Templates** | **Windows Components** | **Windows PowerShell**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To configure PowerShell Core, navigate to **Computer Configuration** | **Administrative
    Templates** | **PowerShell Core**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where are my PowerShell Core .admx templates?
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t imported the **.admx** templates into your Group Policies yet
    to configure PowerShell Core, please refer to [*Chapter 1*](B16679_01_Final_PD.xhtml#_idTextAnchor016),
    *Getting Started* *with PowerShell*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select and edit the **Turn on Module Logging** policy. A window opens to configure
    Module Logging:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.1 – Configur\uFEFFing Module Logging for Windows PowerShell via\
    \ Group Policy](image/B16679_04_001.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Configuring Module Logging for Windows PowerShell via Group Policy
  prefs: []
  type: TYPE_NORMAL
- en: For PowerShell Core, the configuration Window looks almost the same, except
    for the **Use Windows PowerShell Policy setting.** option. If this option is selected,
    PowerShell Core relies on the existing Windows PowerShell configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Configure Module Logging for PowerShell Core via Group Policy](image/B16679_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Configure Module Logging for PowerShell Core via Group Policy
  prefs: []
  type: TYPE_NORMAL
- en: Enable **Use Windows PowerShell Policy setting** if you want to only use one
    GPO for your Module Logging configuration. Next, depending on your configuration,
    either in the Windows PowerShell or PowerShell Core Module Logging GPO, go to
    **Module Names**, and click on the **Show…** button to configure the modules for
    which Module Logging should be turned on. A new window opens.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Configuring a wildcard (*) to log all modules](image/B16679_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Configuring a wildcard (*) to log all modules
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can configure single modules for which Module Logging should be turned
    on, but for security monitoring, it makes sense to monitor all Module Logging
    events – no matter which module was executed.
  prefs: []
  type: TYPE_NORMAL
- en: You can achieve this by configuring a wildcard (*****) as a module name. Confirm
    twice with **OK** and exit the GPO editor to make your changes active.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can also add Module Logging for a single instance instead of
    monitoring all of them by specifying the module name as a value. However, I recommend
    logging all PowerShell activity (*****), which is especially useful if adversaries
    import custom PowerShell modules.
  prefs: []
  type: TYPE_NORMAL
- en: All events generated by this configuration can be found in the Microsoft Windows
    PowerShell Operational event log (**Microsoft-Windows-Powershell/Operational**).
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell Script Block Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **script block** is a collection of expressions and commands that is grouped
    together and executed as one unit. Of course, a single command can be also executed
    as a script block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many commands support the **-ScriptBlock** parameter, such as the **Invoke-Command**
    command. which you can use to run entire script blocks, locally or remotely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that all actions performed in PowerShell are considered
    script blocks and will be logged if *Script Block Logging* is enabled – regardless
    of whether or not they use the **-****ScriptBlock** parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, companies and organizations do not care about logging and
    event log analysis unless a security incident occurs. However, by that point,
    it is already too late to enable logging retroactively. Therefore, the PowerShell
    team made the decision that security-relevant script blocks should be logged by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with PowerShell 5, a *basic version of Script Block Logging* is enabled
    by default – only scripting techniques that are commonly used in malicious attacks
    are written to the **Microsoft-Windows-Powershell/Operational** event log.
  prefs: []
  type: TYPE_NORMAL
- en: This basic version of Script Block Logging does not replace full Script Block
    Logging; it should only be considered as a last resort, if logging was not in
    place when an attack happened.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to protect your environment and detect malicious activities, you
    still should consider turning on *full Script* *Block Logging*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there’s an even more verbose option when configuring Script Block
    Logging – *Script Block* *Invocation Logging*.
  prefs: []
  type: TYPE_NORMAL
- en: By default, only script blocks are logged the first time they are used. Configuring
    Script Block Invocation Logging also generates events every time script blocks
    are invoked and when scripts start or stop.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Script Block Invocation Logging can generate a high volume of events,
    which may flood the log and roll out useful security data from other events. Be
    careful with enabling Script Block Invocation Logging, as a high volume of events
    will be generated – usually, you don’t need it for incident analysis.
  prefs: []
  type: TYPE_NORMAL
- en: How to configure Script Block Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several ways to configure Script Block Logging – manually as well
    as centrally managed. Let’s have a look at what needs to be configured to log
    all the code executed in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually enable Script Block Logging, you can edit the registry. The settings
    that you want to change are within the following registry path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the **EnableScriptBlockLogging** (**REG_DWORD**) registry key, you can
    configure to enable Script Block Logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enabled**: Set the value to **1** to enable it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disabled**: Set the value to **0** to disable it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Script Block Logging is enabled, you will find all the executed code under
    event ID **4104**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the **EnableScriptBlockInvocationLogging** (**REG_DWORD**) registry key,
    you can configure it to enable Script Block Invocation Logging (event IDs **4105**
    and **4106**):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enabled**: Set the value to **1** to enable it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disabled**: Set the value to **0** to disable it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Script Block Logging, as well as Script Block Invocation Logging, is enabled,
    event IDs **4105** and **4106** will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: If Script Block Invocation Logging is enabled, a lot of noise is generated and
    the log file size increases. Therefore, the maximum size should be reconfigured
    (see the *Increasing log size* section). For general security monitoring, you
    won’t need to configure verbose Script Block Logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can configure Script Block Logging manually by running the following commands
    in an elevated PowerShell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first command creates all the registry keys if they don’t exist yet, and
    the second one enables Script Block Logging.
  prefs: []
  type: TYPE_NORMAL
- en: 'When enabling **ScriptBlockLogging** using the described commands, **ScriptBlockLogging**
    will be enabled for both 32-bit and 64-bit applications. You can verify that both
    settings were configured under the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HKLM:\HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HKLM:\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In managed environments, it makes sense to manage your machines centrally. Of
    course, this can be done via PowerShell and/or **Desired State Configuration**
    (**DSC**), but it can be also done using Group Policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new GPO. Depending on which PowerShell version you want to configure,
    navigate to either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Computer Configuration** | **Policies** | **Administrative Templates** |
    **Windows Components** | **Windows PowerShell** for Windows PowerShell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Computer Configuration** | **Administrative Templates** | **PowerShell Core**
    for PowerShell Core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select and edit the **Turn on PowerShell Script Block Logging** policy. A window
    will open to configure Module Logging.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to configure the **Log script block invocation start / stop events**
    option, a lot more events will be generated, and a lot of noise will be generated.
    Depending on your use case, this option might be interesting nevertheless, but
    if you have just started doing security monitoring, I advise to not turn on this
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the log size for Script Block Invocation Logging
  prefs: []
  type: TYPE_NORMAL
- en: If Script Block Invocation Logging is enabled, using the **Log script block
    invocation start / stop events** option, the log file size increases, and the
    maximum size should be reconfigured.
  prefs: []
  type: TYPE_NORMAL
- en: Event ID **4105** and **4106** will only be generated if the **Log script block
    invocation start / stop events** option is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we will *not* configure **Log script block invocation start
    / stop events** to avoid noise; therefore, we’ll leave the checkbox unchecked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Turning on PowerShell Script Block Logging for Windows PowerShell](image/B16679_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Turning on PowerShell Script Block Logging for Windows PowerShell
  prefs: []
  type: TYPE_NORMAL
- en: In the PowerShell Core policy, you will – as with the PowerShell Module Logging
    policy and some other policies – find the option to use the current Windows PowerShell
    Policy setting as well for PowerShell Core.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Turning on PowerShell Script Block Logging for PowerShell Core](image/B16679_04_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Turning on PowerShell Script Block Logging for PowerShell Core
  prefs: []
  type: TYPE_NORMAL
- en: All events generated by this configuration can be found in the Microsoft Windows
    PowerShell Operational event log (**Microsoft-Windows-Powershell/Operational**),
    or for PowerShell Core, in the PowerShell Core event log (**PowerShellCore/Operational**).
  prefs: []
  type: TYPE_NORMAL
- en: Protected Event Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Event logging is a sensitive topic. Often, sensitive information such as passwords
    is exposed and written to the event log.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive information is pure gold in the hand of an adversary who has access
    to such a system, so to counter this, beginning with Windows 10 and PowerShell
    version 5, Microsoft introduced Protected Event Logging.
  prefs: []
  type: TYPE_NORMAL
- en: '**Protected Event Logging** encrypts data using the **Internet Engineering
    Task Force (IETF)** **Cryptographic Message Syntax** (**CMS**) standard, which
    relies on public key cryptography. This means that a public key is deployed on
    all systems that should support Protected Event Logging. Then, the public key
    is used to encrypt event log data before it is forwarded to a central log collection
    server.'
  prefs: []
  type: TYPE_NORMAL
- en: On this machine, the highly sensitive private key is used to decrypt the data,
    before the data is inserted into the SIEM. This machine is sensitive and, therefore,
    needs special protection.
  prefs: []
  type: TYPE_NORMAL
- en: Protected Event Logging is not enabled by default and can currently only be
    used with PowerShell event logs.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Protected Event Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To enable Protected Event Logging, you can deploy a *base64-encoded X.509* certificate
    or another option (for example, deploying a certificate through **Public Key Infrastructure
    (PKI)** and providing a thumbprint, or providing a path to a local or file share-hosted
    certificate). In our example, we’ll use a *base64-encoded* *X.509* certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the certificate requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The certificate must also have the *“Document Encryption”* **Enhanced Key Usage**
    (**EKU**) with the OID number (**1.3.6.1.4.1.311.80.1**) included
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The certificate properties must include either the “*Data Encipherment*” or
    “*Key Encipherment*” key usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There’s a great SANS blog post where you can see how to check your certificate’s
    properties: [https://www.sans.org/blog/powershell-protect-cmsmessage-example-code/](https://www.sans.org/blog/powershell-protect-cmsmessage-example-code/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Protected Event Logging leverages **IETF CMS** to secure the event log content.
    Therefore, you can also refer to the documentation pages for the **Protect-CMSMessage**
    and **Unprotect-CMSMessage** cmdlets for more information on encrypting and decrypting
    using CMS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protect-CMSMessage**: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/protect-cmsmessage](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/protect-cmsmessage)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unprotect-CMSMessage**: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/unprotect-cmsmessage](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/unprotect-cmsmessage)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful that the certificate file that you plan to deploy **does not** contain
    the private key. Once you have obtained the certificate, you can either enable
    it manually or by using Group Policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the blog post *PowerShell* *♥* *the blue team*, the PowerShell team provides
    you with the **Enable-ProtectedEventLogging** function, which you can use to enable
    Protected Event Logging using PowerShell: [https://devblogs.microsoft.com/powershell/powershell-the-blue-team/#protected-event-logging](https://devblogs.microsoft.com/powershell/powershell-the-blue-team/#protected-event-logging).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To leverage this script, save your certificate in the **$cert** variable, which
    you will use in the second command to pass the public key certificate to the **Enable-ProtectedEventLogging**
    function, enabling Protected Event Logging on the local system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can also enable Protected Event Logging using Group Policy. Create a new
    GPO or reuse an existing GPO, and then navigate to **Computer Configuration**
    | **Policies** | **Administrative Templates** | **Windows Components** | **Event
    Logging**.
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Enable Protected Event** **Logging** policy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Enabling Protected Event Logging](image/B16679_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Enabling Protected Event Logging
  prefs: []
  type: TYPE_NORMAL
- en: Set **Enable Protected Event Logging** to **Enabled**, provide your certificate,
    and confirm with **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: Use the **Unprotect-CmsMessage** cmdlet on a secure and protected system to
    decrypt the data before storing it in your SIEM, provided that an appropriate
    decryption certificate (that is, the one that has the private key) is installed
    on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To decrypt the data before storing it in your SIEM, make use of the **Unprotect-CmsMessage**
    cmdlet on a secure and protected system, where an appropriate decryption certificate
    containing the private key is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, all events from the Operational PowerShell log with the event
    ID **4104** will be decrypted, assuming the private key is present.
  prefs: []
  type: TYPE_NORMAL
- en: There is also an option to document what exactly was run in a session and what
    output was shown. This option is called a transcript – let’s have a closer look
    in our next section.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell transcripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PowerShell transcripts have been available in PowerShell since PowerShell version
    1.0 as part of the **Microsoft.PowerShell.Host** module. Transcripts are a great
    way to monitor what happens in a PowerShell session.
  prefs: []
  type: TYPE_NORMAL
- en: If a PowerShell transcript is started, all executed PowerShell commands and
    their output are recorded and saved into the folder that was specified. If not
    specified otherwise, the default output folder is the **My Documents** folder
    (**%userprofile%\Documents**) of the current user.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot is an example of how such a transcript could look.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – A screenshot of a PowerShell transcript](image/B16679_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – A screenshot of a PowerShell transcript
  prefs: []
  type: TYPE_NORMAL
- en: The name of the **.txt** file starts with **PowerShell_transcript**, followed
    by **computername**, a random string, and a time stamp.
  prefs: []
  type: TYPE_NORMAL
- en: This is a typical example of a PowerShell transcript filename that was started
    on *PSSec-PC01* – **PowerShell_transcript.PSSEC-PC01.MUxdLMnA.20210320152800.txt**.
  prefs: []
  type: TYPE_NORMAL
- en: How to start transcripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several options for enabling transcripts. However, the simplest method
    to record PowerShell transcripts is by simply typing the **Start-Transcript**
    command in the current session and hitting *Enter*. In this case, only commands
    that are run in this local session will be captured.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the **Start-Transcript** cmdlet directly, the most interesting
    parameters are **-OutputDirectory**, **-Append**, **-NoClobber**, and **-IncludeInvocationHeader**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-Append**: The new transcript will be added to an existing file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-IncludeInvocationHeader**: Time stamps when commands are run are added to
    the transcript, along with a delimiter between commands to make the transcripts
    easier to parse through automation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-NoClobber**: This transcript will not overwrite an existing file. Normally,
    if a transcript already exists in the defined location (for example, if the defined
    file has the same name as an already existing file, or the filename was configured
    using the **-Path** or **-LiteralPath** parameter), **Start-Transcript** overwrites
    this file without warning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-OutputDirectory**: Using this parameter, you can configure the path where
    your transcripts can be stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-UseMinimalHeader**: This parameter was added in **PowerShell version 6.2**
    and ensures that only a short header is prepended instead of the detailed header.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read more about the full list of parameters in the **Start-Transcript** help
    files or in the official PowerShell documentation: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.host/start-transcript?view=powershell-7#parameters](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.host/start-transcript?view=powershell-7#parameters).'
  prefs: []
  type: TYPE_NORMAL
- en: Securing your transcripts
  prefs: []
  type: TYPE_NORMAL
- en: As with any security logging you collect, it’s important to ensure that your
    transcripts are securely stored to prevent attackers from tampering with them.
    Make sure to configure a secure path that is difficult for attackers to access,
    taking into consideration the possibility of stolen corporate identities. Once
    an attacker gains access to transcripts, they can modify them and render your
    detection efforts useless.
  prefs: []
  type: TYPE_NORMAL
- en: Transcripts that were initialized with **Start-Transcript** are only recorded
    as long as the session is active or until **Stop-Transcript** is executed, which
    stops the recording of executed PowerShell commands.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling transcripts by default
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To enable transcripts *by default* on a system, you can either configure transcripts
    via a **registry** or by using **Group Policy** to configure transcripts for multiple
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling transcripts by registry or script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When PowerShell transcripts are configured, the following registry hive is
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to enable transcription, using invocation headers and the **C:\tmp**
    output folder, you need to configure the following values to the registry keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[REG_DWORD]EnableTranscripting = 1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[REG_DWORD]EnableInvocationHeader = 1**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[REG_SZ]OutputDirectory =** **C:\tmp**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To manage multiple machines, it’s more comfortable to use GPO, but in some
    cases, some machines are not part of the Active Directory domain; hence, they
    cannot be managed. For this example, I have added the **Enable-PSTranscription**
    function to the GitHub repository for this book: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Enable-PSTranscription.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Enable-PSTranscription.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the **Enable-PSTranscription** function into the current session and specify
    the folder where your transcripts should be saved, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If no **-OutputDirectory** is specified, the script will write transcripts into
    **C:\ProgramData\WindowsPowerShell\Transcripts** as the default option.
  prefs: []
  type: TYPE_NORMAL
- en: This function just configures all defined values and overwrites your existing
    registry keys. Feel free to adjust the function to your needs and to reuse it.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as a new session is started, transcripts will be written to the configured
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling transcripts using Group Policy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Active Directory-managed environments, the easiest way to configure transcripts
    is by using Group Policy.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new GPO or reuse an existing one. Then, navigate to **Computer Configuration**
    | **Policies** | **Administrative Templates** | **Windows Components** | **Windows
    PowerShell**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click and open the **Turn on PowerShell Transcription** policy to configure
    PowerShell transcription:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Turning on PowerShell transcription](image/B16679_04_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Turning on PowerShell transcription
  prefs: []
  type: TYPE_NORMAL
- en: Set the policy to **Enabled**, and select whether a transcript output directory
    and invocation headers should be included. If the output directory is not specified,
    transcriptions are saved to the **My Documents** folder of the current user (**%userprofile%\Documents**).
  prefs: []
  type: TYPE_NORMAL
- en: Enabling transcripts for PowerShell Remoting sessions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Custom endpoints** are an excellent way to apply default settings to PowerShell
    Remoting sessions. If transcriptions were configured, they will be enabled by
    default for local sessions, but configuring them additionally in **Just Enough
    Administration** allows you to group and collect logs specific to that endpoint
    when used for remote sessions. By configuring transcription and other settings
    on a custom endpoint, you can enforce these settings for all remote sessions connected
    to that endpoint, making it easier to ensure consistency and compliance across
    your environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, create a session configuration file, using the **New-PSSessionConfigurationFile**
    cmdlet with the **-TranscriptDirectory** parameter to specify where transcripts
    should be written to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a new session configuration file, enforcing transcription,
    and stores it in **%userprofile%\Documents\PSSession.pssc**, the path that was
    defined within the **-****Path** parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – The newly created session configuration](image/B16679_04_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – The newly created session configuration
  prefs: []
  type: TYPE_NORMAL
- en: We introduced custom endpoints in [*Chapter 3*](B16679_03_Final_PD.xhtml#_idTextAnchor064),
    *Exploring PowerShell Remote Management Technologies and PowerShell Remoting,*
    and we will dive deeper into Just Enough Administration in [*Chapter 10*](B16679_10_Final_PD.xhtml#_idTextAnchor278),
    *Language Modes and Just Enough Administration (JEA)*. To learn more about the
    concept of custom endpoints and Just Enough Administration, please make sure to
    review both chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for PowerShell transcripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a security best practice, *use session transcripts for every user*. This
    does not mean that your administrators are doing nasty stuff on your machines
    and they need to be monitored. In no way do I encourage mistrust in your own staff.
    However, credential theft is a real threat, and if your administrator’s identity
    is stolen and misused, you will be happy to understand what was done by the adversary.
  prefs: []
  type: TYPE_NORMAL
- en: If you use transcripts, make sure that they cannot be modified. If they can
    be altered by an attacker, they are of almost no use at all.
  prefs: []
  type: TYPE_NORMAL
- en: So, make sure to provide a path to a preconfigured folder, and specify it either
    via a GPO, manual configuration, or in the session configuration file. Prevent
    all users from modifying or deleting any data in this folder. The local system
    account requires read and write access, so make sure to configure the access permissions
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: And last but not least, it makes sense to forward all the transcript files to
    a central logging server or your SIEM to analyze them regularly.
  prefs: []
  type: TYPE_NORMAL
- en: 'One effective approach to centralizing the transcript files is to configure
    their destination as a **Uniform Naming Convention (UNC)** path with a dynamic
    filename. For example, you can set the transcript directory to a network share
    with write-only permission, using the PowerShell profile to log all activity to
    a file with a unique name, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Also, ensure that this share is not readable by normal users. By using this
    approach, you can easily collect and analyze the logs from all machines in a centralized
    location, allowing you to better detect and respond to security incidents without
    the need to set up an entire logging infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to collecting logs, analyzing them is equally important. In the
    next section, we will explore the techniques and tools used for log analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing event logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to work with Windows event logs using PowerShell. Of
    course, you can always forward your event logs to the SIEM of your choice, but
    sometimes, it happens that you want to directly analyze the event logs on a certain
    machine. For this use case, it makes sense to look at the available options that
    come with PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest option if you just want to analyze events or create new events
    is the ***-WinEvent** cmdlets, which are still available in PowerShell Core 7\.
    You can use **Get-Command** to find all available cmdlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – The available *-WinEvent cmdlets](image/B16679_04_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – The available *-WinEvent cmdlets
  prefs: []
  type: TYPE_NORMAL
- en: 'In PowerShell 5.1, there was also the possibility of using the ***-EventLog**
    cmdlets, but they were removed in PowerShell Core 6 and above. Since PowerShell
    5.1 is installed by default on all Windows 10 operating systems, I refer to ***-EventLog**
    here. Again, use **Get-Command** to find all available cmdlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – The available *-EventLog cmdlets](image/B16679_04_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – The available *-EventLog cmdlets
  prefs: []
  type: TYPE_NORMAL
- en: The third option is to use **wevtutil**. This command-line executable is not
    very intuitive to understand, but it can be used to operate and analyze event
    logs. Using the **/?** parameter, you can get more details on the usage.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – wevtutil.exe usage](image/B16679_04_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – wevtutil.exe usage
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, clearing the **Security** event log can be achieved with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the official documentation to get more details on **wevtutil**: [https://docs.microsoft.com/de-de/windows-server/administration/windows-commands/wevtutil](https://docs.microsoft.com/de-de/windows-server/administration/windows-commands/wevtutil).'
  prefs: []
  type: TYPE_NORMAL
- en: Finding out which logs exist on a system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to find out which event logs exist on a system, you can leverage
    the **-ListLog** parameter followed by a wildcard (*****) – **Get-WinEvent -****ListLog
    ***:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Listing all event logs](image/B16679_04_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Listing all event logs
  prefs: []
  type: TYPE_NORMAL
- en: You might want to pipe the output to **Sort-Object** to sort by record count,
    maximum log size, log mode, or log name.
  prefs: []
  type: TYPE_NORMAL
- en: Querying events in general
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, let’s have a look how we can analyze some of the most common
    scenarios for PowerShell auditing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the **Get-WinEvent** command, you can get all the event IDs from the
    event log that you specified – **Get-WinEvent Microsoft-Windows-PowerShell/Operational**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Querying the Microsoft Windows PowerShell Operational log](image/B16679_04_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Querying the Microsoft Windows PowerShell Operational log
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you would see all event IDs that were generated in the PowerShell
    Operational log.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you only want to query the last *x* events, the **-MaxEvents** parameter
    will help you to achieve this task. For example to query the last 15 events of
    the *security* event log use **Get-WinEvent Security -****MaxEvents 15**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Querying the last 15 events from the Security event log](image/B16679_04_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Querying the last 15 events from the Security event log
  prefs: []
  type: TYPE_NORMAL
- en: This is especially helpful if you want to analyze recent events without querying
    the entire event log.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the **-Oldest** parameter reverts the order so that you see the oldest
    events in this log – **Get-WinEvent Security -MaxEvents** **15 -Oldest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – The 15 oldest events from the Security event log](image/B16679_04_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – The 15 oldest events from the Security event log
  prefs: []
  type: TYPE_NORMAL
- en: 'To find all events in the Microsoft Windows PowerShell Operational log that
    contain code that was executed and logged by **ScriptBlockLogging**, filter for
    event id **4104**: **Get-WinEvent Microsoft-Windows-PowerShell/Operational | Where-Object
    { $_.Id -eq 4104 } |** **fl**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Finding all executed and logged code](image/B16679_04_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Finding all executed and logged code
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also filter for certain keywords in the message part. For example,
    to find all events that contain the **"logon"** string in the message, use the
    **-match** comparison operator – **Get-WinEvent Security | Where-Object { $_.Message
    -match "****logon" }**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Finding all events that contain “logon” in their message](image/B16679_04_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – Finding all events that contain “logon” in their message
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also filter using XPath-based queries, using the **-****FilterXPath**
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Filtering using an XPath query](image/B16679_04_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – Filtering using an XPath query
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to filter by a specified **hash table**, using the **-****FilterHashtable**
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using hash tables can reduce your usage of **Where-Object** filter clauses significantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to query complex event structures, you can use the **-FilterXml**
    parameter and provide an **XML** string. I have prepared such an example and uploaded
    it to this book’s GitHub repository: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Get-AllPowerShellEvents.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Get-AllPowerShellEvents.ps1):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Using the Get-AllPowerShellEvents.ps1 script](image/B16679_04_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – Using the Get-AllPowerShellEvents.ps1 script
  prefs: []
  type: TYPE_NORMAL
- en: This example queries the **Microsoft-Windows-PowerShell/Operational**, **PowerShellCore/Operational**,
    and **Windows PowerShell** event logs and retrieves all the events that I will
    describe in the *Basic PowerShell event logs* section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to work with event logs and query events, let’s look at
    how to detect and analyze which code was run on a system.
  prefs: []
  type: TYPE_NORMAL
- en: Which code was run on a system?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filtering and scrolling through all events that contain executed code can be
    a tedious task, if you decide to perform this task manually. But, thankfully,
    PowerShell allows you to automate this task and quickly find what you are searching
    for.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, all events that contain logged code can be found either in the
    Microsoft Windows PowerShell or the PowerShell Core Operational log, indicated
    by event ID **4104**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To better find and filter what code was executed, I have written the **Get-ExecutedCode**
    function, which you can find in the GitHub repository for this book: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Get-ExecutedCode.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Get-ExecutedCode.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: Downgrade attack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As newer versions such as 5.1 and upward introduced a lot of new security features,
    older PowerShell versions such as version 2.0 became more attractive to attackers.
    Therefore, a common way to leverage older versions is a so-called **downgrade
    attack**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A downgrade attack can be executed by specifying the version number when running
    **powershell.exe**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If the specified version is installed, the command runs, using the deprecated
    binary, which implies that only security features that existed when that version
    was written are applied.
  prefs: []
  type: TYPE_NORMAL
- en: All machines that run Windows 7 and above have at least PowerShell version 2.0
    installed. Although Windows 7 is not supported and does not receive any security
    updates anymore, it is still widespread.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, PowerShell version 2.0 still relies on **.NET Framework 2.0**,
    which does not include advanced security features and provides no advanced logging.
    Therefore, that’s perfect for attackers that do not want anybody to know what
    they did on your system.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework 2.0 is not included by default on Windows 10, but it can be installed
    manually – for example, by an attacker or an administrator. On operating systems
    prior to Windows 10, .NET Framework 2.0 is installed by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows 8, PowerShell version 2.0 can be disabled by running the following
    command in an elevated console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: .NET Framework 2.0, which is required to run PowerShell version 2.0, is by default
    not installed on newer systems such as Windows 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you try to run **powershell.exe -version 2**, you get an error message,
    stating that version 2 of .NET Framework is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As .NET Framework 2.0 can be installed manually – either by system administrators
    or attackers – make sure to check for PowerShell version 2.0 and disable it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to check whether PowerShell version 2.0 is enabled
    or disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So, it seems like PowerShell version 2.0 is still enabled on this machine. Therefore,
    if the missing .NET Framework 2.0 is installed, this system will be vulnerable
    to a downgrade attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, let’s disable PowerShell version 2.0 to harden your system by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see in the output that a restart is needed, so after you restart your
    PC, the changes are applied and PowerShell version 2.0 is disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if you verify once again, you will see that the state is set to **Disabled**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: However, on Windows 7, PowerShell version 2.0 cannot be disabled. The only way
    to disallow PowerShell version 2.0 usage is to leverage **Application Control**
    or **AppLocker**, which we will discuss in [*Chapter 11*](B16679_11_Final_PD.xhtml#_idTextAnchor306),
    *AppLocker, Application Control, and* *Code Signing*.
  prefs: []
  type: TYPE_NORMAL
- en: For adversaries, there is also another way to run a downgrade attack – if, for
    example, a compiled application leverages an older PowerShell version, and links
    against the compiled PowerShell v2 binaries, a downgrade attack can be launched
    by exploiting the application. So, whenever this application runs, PowerShell
    v2 is also active, and it can be used by the attacker if they manage to exploit
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, disabling PowerShell version 2.0 can help to protect against this
    type of attack by blocking the deprecated binaries in the **Global Assembly Cache**
    (**GAC**) or removing the PowerShell component altogether. Nevertheless, it’s
    important to note that other applications that rely on these binaries will be
    blocked as well, as they usually don’t ship with all of the PowerShell binaries.
  prefs: []
  type: TYPE_NORMAL
- en: In general, a downgrade attack is a highly critical issue, and therefore, you
    should monitor for it. You can do so by monitoring the event with the event id
    **400** in the Windows PowerShell event log – if the specified version is lower
    than **[Version] "5"**, you should definitely investigate further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lee Holmes, who was part of the Windows PowerShell team at Microsoft, provides
    a great example of how to monitor for potential downgrade attacks by looking for
    event ID **400** in the PowerShell event log in his blog article *Detecting and
    Preventing PowerShell Downgrade* *Attacks*: [https://www.leeholmes.com/detecting-and-preventing-powershell-downgrade-attacks/](https://www.leeholmes.com/detecting-and-preventing-powershell-downgrade-attacks/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this example to find lower versions of the PowerShell engine being loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: EventList
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During my time as a Premier Field Engineer at Microsoft, I worked with a lot
    of customers that were just building their SOCs from scratch. Most of those customers
    not only wanted to set up log event forwarding but also asked me for best practices
    to harden their Windows environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'When talking about hardening Windows environments, you can’t ignore the Microsoft
    **Security and Compliance Toolkit** (**SCT**): [https://www.microsoft.com/en-us/download/details.aspx?id=55319](https://www.microsoft.com/en-us/download/details.aspx?id=55319).'
  prefs: []
  type: TYPE_NORMAL
- en: I will talk more about some parts of this toolkit later in [*Chapter 6*](B16679_06_Final_PD.xhtml#_idTextAnchor150),
    *Active Directory – Attacks and Mitigation* as well as in [*Chapter 13*](B16679_13_Final_PD.xhtml#_idTextAnchor341),
    *What Else? – Further Mitigations and Resources*. In general, this toolkit contains
    several tools for comparing and verifying your configuration, as well as the so-called
    **baselines**.
  prefs: []
  type: TYPE_NORMAL
- en: These baselines are meant to provide hardening guidance – a lot of settings
    that are important for your security posture, as well as *monitoring configuration*.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, you should not just enforce those baselines without having
    a structured plan and knowing the impact of the settings that you are configuring.
  prefs: []
  type: TYPE_NORMAL
- en: If a baseline is configured for a certain computer, thanks to the monitoring
    configuration piece, new events are generated in the **Security** event log.
  prefs: []
  type: TYPE_NORMAL
- en: When I worked with customers, I always recommended applying the Microsoft Security
    baselines after a well-structured plan.
  prefs: []
  type: TYPE_NORMAL
- en: On one occasion, I was at a customer’s site and just recommended that they should
    apply Microsoft Security baselines to see more event IDs. After recommending applying
    those baselines, my customer asked me whether there was an overview to see what
    additional event IDs were being generated if they enabled a particular baseline,
    like the *Windows 2016 Domain* *Controller baseline*.
  prefs: []
  type: TYPE_NORMAL
- en: 'I only knew of a documentation document that they could use to find it out
    themselves, the *Windows 10 and Windows Server 2016 security auditing and monitoring*
    *reference*: [https://www.microsoft.com/en-us/download/details.aspx?id=52630](https://www.microsoft.com/en-us/download/details.aspx?id=52630).'
  prefs: []
  type: TYPE_NORMAL
- en: Although this document provided amazingly detailed information on all **Advanced
    Audit Policy Configuration** items, with its 754 pages, it was quite extensive.
  prefs: []
  type: TYPE_NORMAL
- en: So, the customer was not happy studying this big document and asked me to write
    down what events would be generated if they applied this baseline. I was not happy
    about such stupefying work, but I started to write down all events for this one
    baseline.
  prefs: []
  type: TYPE_NORMAL
- en: While I was doing this, the customer approached me and realized that they had
    not one but multiple kinds of baselines that they wanted to apply in their environment.
    Also, these were not only Domain Controller baselines but also baselines for member
    servers and client computers of all kinds of operating systems. So, they asked
    me to write down the event IDs for *ALL* existing baselines.
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, I was not super-excited about this new task. This seemed
    like a very dull and exhausting task that would take years to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, I considered the need to automate matching baselines to event IDs,
    and that’s how my open source tool **EventList** was born.
  prefs: []
  type: TYPE_NORMAL
- en: Although it all started as an Excel document with Visual Basic macros, it became
    a huge project in the meantime, with a huge database behind the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – The EventList logo](image/B16679_04_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – The EventList logo
  prefs: []
  type: TYPE_NORMAL
- en: And whenever I need to work with event IDs, my EventList database became my
    source of truth, and it is still growing constantly.
  prefs: []
  type: TYPE_NORMAL
- en: Working with EventList
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started, EventList can be easily installed from the PowerShell Gallery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'EventList is built in PowerShell; therefore, even if you want to work solely
    with the user interface, you need to run at least one PowerShell command. Open
    the PowerShell console as an administrator and type in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Confirm by hitting *Enter*. After a few seconds, the EventList UI appears.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – The EventList UI](image/B16679_04_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – The EventList UI
  prefs: []
  type: TYPE_NORMAL
- en: At the top left, you can select an existing baseline and see the **MITRE ATT&CK**
    techniques and areas that are being populated in the UI. So, you can see directly
    what MITRE ATT&CK techniques are covered if a certain baseline is applied.
  prefs: []
  type: TYPE_NORMAL
- en: You have also the possibility to import your own baselines or exported GPOs
    and delete existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have selected a baseline and the MITRE ATT&CK checkboxes are filled,
    choose **Generate** **Event List**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23 – EventList – showing the baseline events](image/B16679_04_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 – EventList – showing the baseline events
  prefs: []
  type: TYPE_NORMAL
- en: A pop-up window opens, and you can choose whether you want to generate an EventList
    for baseline events only or all MITRE ATT&CK events.
  prefs: []
  type: TYPE_NORMAL
- en: To see which event IDs would be generated if you applied a certain baseline,
    select **Baseline Events only**. Confirm with **OK** to see the EventList for
    the baseline/GPO that you selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – A generated EventList](image/B16679_04_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 – A generated EventList
  prefs: []
  type: TYPE_NORMAL
- en: An EventList is generated, in which you see each event ID that will be generated
    if this baseline is applied, as well as (if available) a link to the documentation
    and a recommendation on whether this event should be monitored or not.
  prefs: []
  type: TYPE_NORMAL
- en: If **Export as CSV** is checked, you can select where the output should be saved,
    and a **.csv** file is generated.
  prefs: []
  type: TYPE_NORMAL
- en: As Microsoft Security baselines mostly rely on the **Advanced Audit Logs**,
    by using the **Baseline only** function, EventList helps a lot to understand and
    demystify the Advanced Audit Logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can achieve the same thing by using the following commands on the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The baseline needs to be imported into the EventList database, so make sure
    that the baseline name is shown when verifying with the **Get-BaselineNameFromDB**
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can also select different MITRE ATT&CK techniques and areas and
    generate an EventList to see which event IDs cover a certain MITRE ATT&CK area.
    Generate an EventList, select **All MITRE ATT&CK Events**, and confirm with **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: A popup will open, and you can see all event IDs that were correlated to the
    selected MITRE ATT&CK techniques.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25 – A MITRE ATT&CK EventList](image/B16679_04_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.25 – A MITRE ATT&CK EventList
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, this can be achieved by passing either a baseline or MITRE ATT&CK technique
    numbers to the **Get-MitreEventList** function, using the **-****Identity** parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows the output of the command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26 – The Get-MitreEventList function can also be run via the command
    line](image/B16679_04_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.26 – The Get-MitreEventList function can also be run via the command
    line
  prefs: []
  type: TYPE_NORMAL
- en: Of course, EventList provides many more functions. It also provides possibilities
    to generate forwarder agent snippets of all event IDs that should be forwarded
    for your use case. You can also generate your own GPOs and hunting queries that
    support your very own use case.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are too many functions to describe everything in detail in this
    book. If you are interested in learning more about EventList, make sure to read
    the EventList documentation in its GitHub repository, that is mentioned at the
    end of this section. Some experts also find it useful to query the database behind
    EventList manually.
  prefs: []
  type: TYPE_NORMAL
- en: I wrote EventList to help SOCs worldwide understand what to monitor and simplify
    their event ID forwarding.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am constantly improving EventList, so if you want to learn more, you are
    more than welcome to download and test it. It can be either downloaded and installed
    from my GitHub repository ([https://github.com/miriamxyra/EventList](https://github.com/miriamxyra/EventList))
    or installed from the PowerShell Gallery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand the functionalities of EventList more comprehensively, I recommend
    reading the documentation and help files and watching some of the recordings of
    the talks that I have given on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hack.lu 2019: (version** **1.1.0)**: [https://www.youtube.com/watch?v=nkMDsw4MA48](https://www.youtube.com/watch?v=nkMDsw4MA48)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Black Hat 2020 (version** **2.0.0)**: [https://www.youtube.com/watch?v=3x5-nZ2bfbo](https://www.youtube.com/watch?v=3x5-nZ2bfbo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have any ideas on what is missing in EventList, I would love to hear
    more, and I’m looking forward to your pull request on GitHub or your message on
    Twitter or via email.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To improve your detection, it makes sense to set up a SIEM system for event
    collection so that you have all event logs in one place, allowing you to hunt
    and even build automated alerting.
  prefs: []
  type: TYPE_NORMAL
- en: There are many options if you want to choose a SIEM system – for every budget
    and scenario. Over the years, I have seen many different SIEM systems – and each
    one just fitted perfectly for each organization.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular SIEM systems that I have seen out in the wild were **Splunk**,
    **Azure Sentinel**, **ArcSight**, **qRadar**, and the **“ELK stack” (Elastic,
    LogStash, and Kibana)**, just to mention a few. I also saw and used **Windows
    Event Forwarding** (**WEF**) to realize event log monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is also possible to analyze events on a local machine, but it
    is not practical – depending on the configuration, if the maximum log size is
    reached, old events are deleted, and you cannot easily correlate them with logs
    from another system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will also analyze events directly on the machine (or remotely
    if you like), but for an actual production environment, I recommend having an
    SIEM system in place – just make sure that it fits your use case before you start.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of important PowerShell-related log files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get started, you might want to configure all the logs that you want
    to forward to your SIEM or a central log server.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will find an overview of all the logs that I consider important
    when it comes to PowerShell logging.
  prefs: []
  type: TYPE_NORMAL
- en: Basic PowerShell event logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with PowerShell, there are three event logs that are of interest
    – the **Windows PowerShell log**, the **Microsoft Windows PowerShell Operational
    log**, and the **PowerShellCore Operational log**. Let’s discuss each of them
    in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows PowerShell Log
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Windows PowerShell has always had a strong focus on security and logging, even
    in its earliest versions. In fact, compared to other shell or scripting languages,
    PowerShell’s early versions already had significantly better security logging
    capabilities. However, over the years, the language evolved, and its logging capabilities
    expanded enormously, providing us with even better logging nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although early versions did not provide us with the security logging that you
    know from today’s PowerShell versions, Windows PowerShell has written events to
    the **Windows PowerShell event log** since version 1 when important engine events
    occurred. Back then, PowerShell provided only basic logging functionalities, which
    are still available in current operating systems, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full name**: Windows PowerShell'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log path**: **%****SystemRoot%\System32\Winevt\Logs\Windows PowerShell.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path in the UI**: **Applications and Services** | **Windows PowerShell**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *most interesting event IDs* in these event logs are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 200** (a warning): **Command health.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look for **Host Application** to get more details on the executed command.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 400**: **The engine state is changed from none** **to available.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This event might be *the most interesting event* in this event log, as it indicates
    when the engine was started and which version was used. This event is optimal
    for identifying and terminating outdated PowerShell versions (monitoring for **HostVersion**
    less than 5.0) – and is used for downgrade attacks (see the *Detecting a downgrade
    attack* section for more information).
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 800**: **The pipeline execution details for the command line –**
    *<**command-line command>***.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although event ID **800** provides details on the execution of command lines
    that contain cmdlets, it doesn’t include information about other executables such
    as **wmic**. It may be more useful to monitor the event IDs **4103** and **4104**
    from the *Microsoft Windows PowerShell Operational log* for additional details.
  prefs: []
  type: TYPE_NORMAL
- en: The Microsoft Windows PowerShell Operational log contains all relevant information
    when it comes to the usage of PowerShell – for example, **Module Logging** and
    also **Script Block Logging** events are written to this log.
  prefs: []
  type: TYPE_NORMAL
- en: The Microsoft Windows PowerShell Operational log
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Starting with Windows Vista, Microsoft introduced a new type of logging system
    called **ETW**. As part of this change, the *Microsoft Windows PowerShell Operational
    log* was introduced, which included a range of event IDs such as **4100**, **4103**
    (although configuring them could be challenging), as well as **40961**, **40862**,
    and others related to PowerShell Remoting logs.
  prefs: []
  type: TYPE_NORMAL
- en: With *KB3000850*, Advanced Audit capabilities such as **Module Logging**, **Script
    Block Logging**, and **transcription** could be ported into PowerShell version
    4 (Windows Server 2012 R2 and Windows 8.1). Later on, with PowerShell version
    5 (Windows Server 2016 and Windows 10), these features were included by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these new auditing capabilities, there were also new event types introduced,
    such as the event IDs **4104**, **4105**, and **4106**, which provide you with
    advanced logging capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full** **name:**  **Microsoft-Windows-Powershell/Operational**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log** **path**: **%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-PowerShell%4Operational.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path in the UI**: **Applications and Services** | **Microsoft** | **Windows**
    | **PowerShell** | **Operational**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *most interesting event IDs* in this event logs are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 4103**: **Executing pipeline/command invocation. An event is generated
    if PowerShell Module Logging** **is enabled.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 4104**: **Creating** **Scriptblock text.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event is generated if **ScriptBlockLogging** is enabled. Common malicious
    activities such as loading a malicious module or executing a suspicious command
    are logged, regardless of whether **ScriptBlockLogging** is enabled or not.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 4105**: **ScriptBlock_Invoke_Start_Detail (message: started/completed
    an invocation** **of ScriptBlock).**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event is generated if **ScriptBlockLogging** is enabled. This records start/stop
    events. It is very noisy and not necessarily needed for security monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 4106**: **ScriptBlock_Invoke_Complete_Detail (message: started/completed
    an invocation** **of ScriptBlock).**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event is generated if **ScriptBlockLogging** is enabled. This records start/stop
    events. It is very noisy and not necessarily needed for security monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 40961**: **The PowerShell console is** **starting up.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This event indicates that the PowerShell console was opened. Especially monitor
    for unusual user behavior using this event (for example, if the PowerShell console
    was executed by a user that should not log on to this system, or if it’s a system
    account).
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 40962**: **The PowerShell console is ready for** **user input.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This event indicates that the PowerShell console was started and is now ready
    for user input. Especially monitor for unusual user behavior using this event
    (for example, if the PowerShell console was executed by a user that should not
    log on to this system or if it’s a system account).
  prefs: []
  type: TYPE_NORMAL
- en: 'To filter for certain event IDs, you can pipe the output of **Get-WinEvent**
    to **Where-Object**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you will get all events with the event ID **4104**, which indicates
    that a script block was created.
  prefs: []
  type: TYPE_NORMAL
- en: The PowerShellCore Operational log
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When PowerShell Core was introduced, so was the PowerShellCore Operational
    log. It provides Advanced Audit capabilities for PowerShell Core Event Logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full** **name:**  **PowerShellCore/Operational**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log** **path**: **%SystemRoot%\System32\Winevt\Logs\PowerShellCore%4Operational.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path in the UI**: **Applications and Services** | **PowerShellCore** | **Operational**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event IDs that are logged within this log file are the same as the ones
    that are logged in the Microsoft Windows PowerShell Operational log. Please refer
    to the event IDs in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Remote Management (WinRM) log
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Microsoft Windows WinRM Operational log** records both inbound and outbound
    WinRM connections. Since PowerShell relies on WinRM for PowerShell remoting, you
    can also find PowerShell remote connections in this event log. Therefore, it is
    essential to also monitor and analyze event IDs from this log.
  prefs: []
  type: TYPE_NORMAL
- en: '**Full** **name**: **Microsoft-Windows-WinRM/Operational**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log** **path**: **%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-WinRM%4Operational.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path in the UI**: **Applications and Services** | **Microsoft** | **Windows**
    | **Windows Remote Management** | **Operational**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with PowerShell and WinRM, the following are *the most interesting
    events* to look for in the WinRM event log.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 6**: **Creating a** **WSMan session.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is recorded whenever a remote connection is established. It also contains
    the username, the destination address, and the PowerShell version that was used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 81**: **Processing a client request for a CreateShell operation
    or processing a client request for a** **DeleteShell operation.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 82**: **Entering the plugin for a CreateShell operation with a ResourceUri**
    **of** **<http://schemas.microsoft.com/powershell/Microsoft.PowerShell>**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 134**: **Sending a response for a** **CreateShell operation.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 169**: **The** *<domain>\<user>* **user has authenticated successfully
    using** **NTLM authentication.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can query all events within the WinRM log using **Get-WinEvent Microsoft-Windows-WinRM/Operational**.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Security event log is not only PowerShell related but also helps to correlate
    events such as logon/logoff and authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '**Full** **name**: **Security**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log** **path**: **%SystemRoot%\System32\Winevt\Logs\Security.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path in the UI**: **Windows Logs** | **Security**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While not all event IDs in the Security log are generated by default, the most
    important ones are there to help identify security issues. If you want to implement
    extensive security logging, I recommend applying the Microsoft Security baselines
    from the Microsoft Security toolkit to your systems. However, it is important
    to note that the settings in the Security baseline should be commensurate with
    your organization’s resources and capabilities. Therefore, it’s advisable to evaluate
    which logging settings are appropriate for your organization’s needs and capabilities
    before applying a baseline.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the **Microsoft Security toolkit** here: [https://www.microsoft.com/en-us/download/details.aspx?id=55319](https://www.microsoft.com/en-us/download/details.aspx?id=55319).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The event IDs in this event log are some of the most important to monitor for
    security purposes. While not all of them are specific to PowerShell, they are
    still critical to maintaining a secure environment. The following are the *most
    interesting event IDs* in this event log:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 4657**: **A registry value** **was modified**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 4688**: **A new process has been created. Look for processes with
    powershell.exe as the “New Process Name”. You can use the Creator Process ID to
    link what process launched which** **other processes.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 1100**: **The Event Logging service has** **shut down.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 1102**: **The audit log** **was cleared.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 1104**: **The security log is** **now full.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 4624**: **An account was successfully** **logged on.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 4625**: **An account failed to** **log on.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Security log is quite extensive and contains a lot of important event IDs.
    Covering just the Security log could fill an entire book; therefore, this list
    is not complete, and I only listed some of the most important ones when it comes
    to PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, the question of *which security event IDs matter* has kept me
    awake many nights, and so I came up with an open source tool called **EventList**.
    If you want to find out which event IDs matter, have a look at the *Forwarding
    and analyzing event logs – EventList* section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the system log, many system-relevant log IDs are generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full** **name**: **System**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log** **path**: **%SystemRoot%\System32\Winevt\Logs\System.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path in the UI**: **Windows Logs** | **System**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *most interesting event ID* in this event log for PowerShell security logging
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 104** – **the** *<name>* **log was cleared.** This event indicates
    that the event log with the name *<name>* was cleared, which could indicate an
    adversary trying to hide traces. Especially use this event ID to monitor for the
    log names *“Windows PowerShell,"* *“PowerShell Operational,"* or *“PowerShellCore”*
    to detect PowerShell-related event log clearing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on what you are monitoring for, there are many interesting events
    in this log – for example, details on every installation.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Defender
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Windows Defender log has been enabled by default since Windows 10 and Windows
    Server 2016, and it provides a lot of helpful events. For example, it also contains
    events related to the **Antimalware Scan Interface** (**AMSI**), which is a part
    of Windows Defender:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full name**: **Microsoft-Windows-Windows Defender/Operational**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log path**: **%****SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-Windows
    Defender%4Operational.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path in the UI**: **Applications and Services** | **Microsoft** | **Windows**
    | **Windows Defender** | **Operational**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *most interesting event IDs* in this event log for PowerShell security
    logging are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 1116**: **Microsoft Defender Antivirus has detected malware or other
    potentially** **unwanted software.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 1117**: **Microsoft Defender Antivirus has taken action to protect
    this machine from malware or other potentially** **unwanted software.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If Microsoft Defender is used on your machine, you will find many more interesting
    Defender-related log events in this event log. Use this reference to learn more
    about each Microsoft Defender-related event ID: [https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/troubleshoot-microsoft-defender-antivirus](https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/troubleshoot-microsoft-defender-antivirus).'
  prefs: []
  type: TYPE_NORMAL
- en: We will take a closer look at AMSI in [*Chapter 12*](B16679_12_Final_PD.xhtml#_idTextAnchor324),
    *Exploring the Antimalware Scan* *Interface (AMSI)*.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Defender Application Control and AppLocker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Windows Defender Application Control** (**WDAC**) and **AppLocker** can be
    used to allowlist applications to restrict which software is allowed to be used
    within an organization. Both solutions help you to protect against the unauthorized
    use of software.'
  prefs: []
  type: TYPE_NORMAL
- en: We will take a closer look at WDAC and AppLocker in [*Chapter 11*](B16679_11_Final_PD.xhtml#_idTextAnchor306),
    *AppLocker, Application Control, and* *Code Signing*.
  prefs: []
  type: TYPE_NORMAL
- en: When enabling allowlist solutions, auditing is the first major step; hence,
    analyzing WDAC and AppLocker-related event IDs is necessary for this process.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Defender Application Control (WDAC)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: WDAC is Microsoft’s latest allowlisting solution, which was introduced with
    Windows 10 and was earlier known as *Device Guard*. In addition to allowlisting
    applications, WDAC can also be used to enforce code integrity policies on Windows
    machines.
  prefs: []
  type: TYPE_NORMAL
- en: WDAC has two main event logs – one event log named **MSI and Scripts** is shared
    with AppLocker, and another event log is used to log **Code** **Integrity**-related
    events.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code Integrity**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full** **name**: **Microsoft-Windows-CodeIntegrity/Operational**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log** **path**: **%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-CodeIntegrity%4Operational.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path in the UI**: **Applications and Services Logs** | **Microsoft** | **Windows**
    | **CodeIntegrity** | **Operational**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *most interesting event IDs* in this event logs for PowerShell security
    logging are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 3001**: **An unsigned driver attempted to load on** **the system.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 3023**: **The driver file under validation didn’t meet the requirements
    to pass the Application** **Control policy.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 3033**: **The file under validation didn’t meet the requirements
    to pass the Application** **Control policy.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 3034**: **The file under validation didn’t meet the requirements
    to pass the Application Control policy if it was enforced. The file was allowed,
    since the policy is in** **audit mode.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 3064**: **If the Application Control policy was enforced, a user
    mode DLL under validation didn’t meet the requirements to pass the Application
    Control policy. The DLL was allowed, since the policy is in** **audit mode.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 3065**: **If the Application Control policy was enforced, a user
    mode DLL under validation didn’t meet the requirements to pass the Application**
    **Control policy.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 3076**: **This event is the main Application Control block event
    for audit mode policies. It indicates that the file would have been blocked if
    the policy** **was enforced.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 3077**: **This event is the main Application Control block event
    for enforced policies. It indicates that the file didn’t pass your policy and**
    **was blocked.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can query all events within the WDAC log using **Get-WinEvent Microsoft-Windows-CodeIntegrity/Operational**.
    Monitoring and analyzing these events can help identify potential security breaches
    and improve the overall security posture of a system.
  prefs: []
  type: TYPE_NORMAL
- en: '**MSI** **and Script**'
  prefs: []
  type: TYPE_NORMAL
- en: 'All Microsoft Installer and script-related event IDs can be found in this event
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full name**: **Microsoft-Windows-AppLocker/MSI** **and Script**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log path**: **%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-AppLocker%4MSI**
    **and Script.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path in the UI**: **Applications and Services Logs** | **Microsoft** | **Windows**
    | **Applocker** | **MSI** **and Script**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *most interesting event IDs* in the event logs for PowerShell security
    logging are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 8028**: *** **was allowed to run but would have been prevented if
    the Config CI policy** **was enforced.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 8029**: *** **was prevented from running due to the Config** **CI
    policy.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 8036**: *** **was prevented from running due to the Config** **CI
    policy.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 8037**: *** **passed the Config CI policy and was allowed** **to
    run.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to learn about more Application Control event IDs, have a look
    at the *AppLocker* section and the following documentation: [https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/event-id-explanations](https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/event-id-explanations).'
  prefs: []
  type: TYPE_NORMAL
- en: AppLocker
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When it comes to AppLocker, there are four event log files that you might want
    to examine, depending on your use case – *EXE and DLL*, *MSI and Script*, *Packaged
    app-Deployment*, and *Packaged app-Execution*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the UI, you can find all four logs under the same path – simply replace
    **<Name of the log>** with the name of each event log, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Path in the UI**: **Applications and Services** | **Microsoft** | **Windows**
    | **AppLocker** | **<Name of** **the log>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the full name and the path of each AppLocker-related event
    log (please note that auditing must be enabled in order for any of these event
    logs to appear):'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXE** **and DLL**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All event IDs that are related to executing binaries (EXE) and DLLs can be
    found in this event log:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full name**: **Microsoft-Windows-AppLocker/EXE** **and DLL**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log path**: **%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-AppLocker%4EXE**
    **and DLL.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MSI** **and Script**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All Microsoft Installer and script-related event IDs can be found in this event
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full name**: **Microsoft-Windows-AppLocker/MSI** **and Script**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log path**: **%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-AppLocker%4MSI**
    **and Script.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packaged app-Deployment**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a packaged app is deployed, you can find all related event IDs in this event
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full name**: **Microsoft-Windows-AppLocker/Packaged app-Deployment**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log path**: **%****SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-AppLocker%4Packaged
    app-Deployment.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packaged app-Execution**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All packaged app execution-related event IDs can be found in this event log.
  prefs: []
  type: TYPE_NORMAL
- en: '**Full name**: **Microsoft-Windows-AppLocker/Packaged app-Execution**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log path**: **%****SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-AppLocker%4Packaged
    app-Execution.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *most interesting event IDs* in these event logs for PowerShell security
    logging are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 8000 (error)**: **The Application Identity Policy conversion failed.
    Status *<%1> This indicates that the policy was not applied correctly to the computer.
    The status message is provided for** **troubleshooting purposes.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 8001 (information)**: **The AppLocker policy was applied successfully
    to this computer. This indicates that the AppLocker policy was successfully applied
    to** **the computer.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 8002 (information)**: *<Filename>* **was allowed to run. This specifies
    that the .exe or .dll file is allowed by an** **AppLocker rule.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 8003 (warning)**: *<Filename>* **was allowed to run but would have
    been prevented from running if the AppLocker policy were enforced. This is applied
    only when the Audit only enforcement mode is enabled. It specifies that the .exe
    or .dll file would be blocked if the Enforce rules enforcement mode** **were enabled.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 8004 (error)**: *<Filename>* **was not allowed to run. Access to
    <filename> is restricted by the administrator. This is applied only when the Enforce
    rules enforcement mode is set either directly or indirectly through Group Policy
    inheritance. The .exe or .dll file** **cannot run.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 8005 (information)**: *<Filename>* **was allowed to run. This specifies
    that the script or .msi file is allowed by an** **AppLocker rule.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 8006 (warning)**: *<Filename>* **was allowed to run but would have
    been prevented from running if the AppLocker policy were enforced. This is applied
    only when the Audit only enforcement mode is enabled. It specifies that the script
    or .msi file would be blocked if the Enforce rules enforcement mode** **were enabled.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 8007 (error)**: *<Filename>* **was not allowed to run. Access to
    <Filename> is restricted by the administrator. This is applied only when the Enforce
    rules enforcement mode is set either directly or indirectly through Group Policy
    inheritance. The script or .msi file** **cannot run.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 8008 (error)**: **AppLocker is disabled on the SKU. This was added
    in Windows Server 2012 and** **Windows 8.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are interested in learning about more AppLocker event IDs, please refer
    to the following link: [https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/using-event-viewer-with-applocker](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/using-event-viewer-with-applocker).'
  prefs: []
  type: TYPE_NORMAL
- en: There are, of course, many other interesting log files, such as **Firewall**
    and **DSC**. Mentioning and describing all of them would exceed the content of
    this book; therefore, I have only mentioned some of the most interesting log files
    when it comes to PowerShell Security.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing log size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every event that is generated lets a log file grow. As thousands of events can
    be written in a very short time, it is useful to increase the maximum log file
    size – especially if you also want to analyze events locally.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is always recommended to forward your logs to a central log repository
    to make sure the logs will not be lost. However, if you want to analyze events
    locally, it is also helpful to increase the log file size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Limit-EventLog** cmdlet can help you with this task in Windows PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This command sets the maximum size of the PowerShell log to *4 GB*. Please note
    that the “MB” and “GB” prefixes are also available in this cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: When setting the maximum size of the event log, it’s important to keep in mind
    that the size of an event log entry can vary, depending on the specific event
    log and the number of enabled events. Look how much space one event usually takes
    up in your environment on average per log. First, you need to get the log size
    of an event log. The following command returns the maximum size of the Windows
    PowerShell event log in *KB:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then, divide it by the number of entries. Just like that you can calculate the
    estimated size of your event log and how many events it should hold before events
    will be rotated.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use PowerShell 7, the **Limit-EventLog** cmdlet is not available. Instead,
    you will need to alter the registry, using **New-ItemProperty**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the **Limit-EventLog** command, you can also specify the behavior when
    an event log is full: [https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/limit-eventlog](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/limit-eventlog).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to get started with security logging for PowerShell.
    You now know which event logs are of interest and which event IDs you should look
    for. As security monitoring is a huge topic, you have learned just the basics
    on how to get started and continue.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to configure PowerShell Module Logging, Script Block Logging,
    and PowerShell transcripts – manually and centralized for Windows PowerShell,
    as well as for PowerShell Core.
  prefs: []
  type: TYPE_NORMAL
- en: Another important learning point is that log events can be tampered with, and
    you can implement some level of protection using Protected Event Logging.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, it is best to forward your log events to a centralized SIEM system,
    but if that’s not possible, you also learned how to analyze events using PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have been provided with some example scripts and code snippets,
    you are ready to investigate all PowerShell activity on your clients and servers.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, if you want to dive deeper into security monitoring, EventList
    can help you to find out which events are important to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about auditing, detection, and monitoring; local systems are not
    far away. Let’s dive deeper into the system and have a look at the Windows registry,
    the Windows API, COM, CIM/WMI, and how it is possible to run PowerShell without
    running **powershell.exe** in our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to explore some of the topics that were mentioned in this chapter,
    follow these resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Auditing –** **further resources**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detecting Offensive PowerShell Attack Tools: [https://adsecurity.org/?p=2604](https://adsecurity.org/?p=2604)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lee Holmes on downgrade attacks: [https://www.leeholmes.com/blog/2017/03/17/detecting-and-preventing-powershell-downgrade-attacks/](https://www.leeholmes.com/blog/2017/03/17/detecting-and-preventing-powershell-downgrade-attacks/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft SCT: [https://www.microsoft.com/en-us/download/details.aspx?id=55319](https://www.microsoft.com/en-us/download/details.aspx?id=55319)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell ♥ the Blue Team: [https://devblogs.microsoft.com/powershell/powershell-the-blue-team/](https://devblogs.microsoft.com/powershell/powershell-the-blue-team/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows 10 and Windows Server 2016 security auditing and monitoring reference:
    [https://www.microsoft.com/en-us/download/details.aspx?id=52630](https://www.microsoft.com/en-us/download/details.aspx?id=52630)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PowerShell post-exploitation, the Empire has fallen, You CAN detect PowerShell
    exploitation* by Michael Gough: [https://de.slideshare.net/Hackerhurricane/you-can-detect-powershell-attacks](https://de.slideshare.net/Hackerhurricane/you-can-detect-powershell-attacks)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EventList**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub: [https://github.com/miriamxyra/EventList](https://github.com/miriamxyra/EventList)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Black Hat presentation 2020 (version 2.0.0): [https://www.youtube.com/watch?v=3x5-nZ2bfbo](https://www.youtube.com/watch?v=3x5-nZ2bfbo)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helpful cmdlets** **and commands**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limit-EventLog** documentation: https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/limit-eventlog?view=powershell-5.1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start-Transcript** documentation: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.host/start-transcript?view=powershell-7#parameters'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**wevtutil** documentation: https://docs.microsoft.com/de-de/windows-server/administration/windows-commands/wevtutil'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unprotect-CmsMessage**: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/unprotect-cmsmessage'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PowerShell Logging and** **event logs**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC – CMS: https://www.rfc-editor.org/rfc/rfc5652'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell Core Group Policy settings: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_group_policy_settings?view=powershell-7.1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell logging on a non-Windows OS: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_non-windows?view=powershell-7'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About logging on a Windows OS: https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_logging_windows?view=powershell-7.1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'About event logs (v 5.1): https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_eventlogs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also find all links mentioned in this chapter in the GitHub repository
    for *Chapter 4* – there’s no need to manually type in every link: https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter04/Links.md.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Digging Deeper – Identities, System Access, and Day-to-Day Security
    Tasks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s dive deeper and combine PowerShell with other technologies. The technology
    section of this part mostly explores the ways that attackers can enumerate, bypass,
    hijack, and compromise key components such as the operating system itself, Active
    Directory, and Azure AD/Entra ID. On July 11, 2023 Microsoft renamed Azure AD
    to Entra ID. As this was just shortly announced before this book was released,
    we will refer to Entra ID just as Azure Active Directory, Azure AD, or AAD in
    this part. This part is not only of interest to red teamers but also to blue teamers
    who want to learn how adversaries are trying to abuse well-established solutions
    in order to protect themselves from such attacks. Additionally, you will get a
    lot of useful extra information about concepts, protocols, and mitigation, and
    many more interesting insights.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll first explore PowerShell’s capabilities to access the system: we will
    not only look into working with the registry and WMI but we will also find out
    how you can leverage .NET, as well as native Windows APIs, and how you can compile
    and run custom DLLs and unmanaged code from PowerShell. Ever wondered how it is
    possible to run PowerShell without calling powershell.exe? Don’t worry – after
    working through this part, you will know.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Active Directory chapter, we will dive into enumeration – with or without
    the Active Directory PowerShell module – as well as into access rights, authentication
    protocols, credential theft, and mitigation tactics. We will also look into the
    recommended Microsoft security baselines and the Security Compliance Toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about Active Directory, Azure AD is not far away; therefore, we
    will also investigate this technology from a PowerShell security perspective.
    Azure AD security is not a broadly well-known topic, and in this chapter, you
    will learn how to differentiate between Active Directory and Azure AD and about
    fundamental Azure AD concepts. You will learn which accounts and roles make useful
    targets for attackers and how Azure AD can be enumerated. Last but not least,
    we will explore several credential theft techniques and also look into mitigating
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 8*](B16679_08_Final_PD.xhtml#_idTextAnchor204) and [*Chapter 9*](B16679_09_Final_PD.xhtml#_idTextAnchor228),
    this book also provides you with red and blue team cookbooks. Both parts first
    explore the common PowerShell tools for both intents and then provide many useful
    PowerShell code snippets that you can use for your own purposes – no matter whether
    you are a blue or red teamer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B16679_05_Final_PD.xhtml#_idTextAnchor110), *PowerShell Is Powerful
    – System and API Access*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B16679_06_Final_PD.xhtml#_idTextAnchor150), *Active Directory
    – Attacks and Mitigation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B16679_07_Final_PD.xhtml#_idTextAnchor179), *Hacking the Cloud
    – Exploiting Azure Active Directory/Entra ID*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B16679_08_Final_PD.xhtml#_idTextAnchor204), *Red Team Tasks and
    Cookbook*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B16679_09_Final_PD.xhtml#_idTextAnchor228), *Blue Team Tasks
    and Cookbook*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
