<html><head></head><body>
		<div id="_idContainer152">
			<h1 class="chapter-number" id="_idParaDest-104"><a id="_idTextAnchor110"/><a id="_idTextAnchor111"/>5</h1>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor112"/>PowerShell Is Powerful – System and API Access</h1>
			<p>Just when you thought PowerShell was already a mighty tool, get ready to be surprised by its ability to delve deep into the system. In this chapter, we’ll explore accessing the system and API by <span class="No-Break">using PowerShell.</span></p>
			<p>We’ll start by looking into the Windows Registry and how you can leverage PowerShell to easily access its keys and values. We’ll then move on to .NET Framework and the Windows API, and you’ll learn how to execute C# code directly <span class="No-Break">from PowerShell.</span></p>
			<p>Next, we’ll <a id="_idIndexMarker704"/>explore<a id="_idTextAnchor113"/> <strong class="bold">Windows Management Instrumentation</strong> (<strong class="bold">WMI</strong>), which can be used to access and manage a wide range of system resources, including hardware, software, network components, and other objects, through a standard interface. PowerShell makes it easy to interact with WMI and automate tasks and <span class="No-Break">manipulate data.</span></p>
			<p>In this chapter, you will also learn how it is possible to run PowerShell commands without executing <strong class="source-inline">powershell.exe</strong>. You’ll learn how to run PowerShell code directly from within other applications or even <span class="No-Break">in memory.</span></p>
			<p>You’ll learn how to identify potential threats and secure your environment against these types of attacks. So, get ready to discover just how powerful PowerShell can be when it comes to system and API access. Let’s dive in! We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Getting familiar with the <span class="No-Break">Windows Registry</span></li>
				<li>Basics of the <span class="No-Break">Windows API</span></li>
				<li>Exploring .<span class="No-Break">NET Framework</span></li>
				<li>Understanding the <strong class="bold">Component Object Model</strong> (<strong class="bold">COM</strong>) and <span class="No-Break">COM hijacking</span></li>
				<li>The <strong class="bold">Common Information </strong><span class="No-Break"><strong class="bold">Model</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CIM</strong></span><span class="No-Break">)/WMI</span></li>
				<li>Running PowerShell <span class="No-Break">without </span><span class="No-Break"><strong class="source-inline">powershell.exe</strong></span></li>
			</ul>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor114"/>Technical requirements</h1>
			<p>To make the most out of this chapter, ensure that you have <span class="No-Break">the following:</span></p>
			<ul>
				<li>PowerShell 7.3 <span class="No-Break">and above</span></li>
				<li>Installed Visual <span class="No-Break">Studio Code</span></li>
				<li>Installed Visual Studio for your <span class="No-Break">C# code</span></li>
				<li>C, C++, or C# knowledge and/or the ability to read <span class="No-Break">C code</span></li>
				<li>Knowledge of how to use compilers, <span class="No-Break">especially C/C++/C#</span></li>
				<li>Visual Basic knowledge and/or the ability to read Visual <span class="No-Break">Basic code</span></li>
				<li>Access to Microsoft Excel, or another tool from the Office suite that allows <span class="No-Break">running macros</span></li>
				<li>Access to the GitHub repository for <span class="No-Break"><strong class="source-inline">Chapter05:</strong></span><span class="No-Break"> </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05</span></a></li>
			</ul>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor115"/>Getting familiar with the Windows Registry</h1>
			<p>The <a id="_idIndexMarker705"/>Windows Registry was introduced<a id="_idIndexMarker706"/> with <strong class="bold">Windows 3.1</strong>. Although back then, it primarily stored information for the COM-based components, it was developed over the years. Nowadays, it serves as the hierarchical database as we all know it – storing low-level configuration settings for the Windows operating system, as well as for applications running <span class="No-Break">on it.</span></p>
			<p>Although you can access the registry using multiple ways, we will concentrate in this section on how to access and operate the registry <span class="No-Break">using PowerShell.</span></p>
			<p>The Windows Registry of modern systems usually consists of five root keys. Each of them has their own purpose and contains <span class="No-Break">different settings:</span></p>
			<ul>
				<li><strong class="bold">HKEY_CLASSES_ROOT</strong> (<strong class="bold">HKCR</strong>): Hives <a id="_idIndexMarker707"/>underneath<a id="_idIndexMarker708"/> this root key contain information about COM class registration information and <span class="No-Break">file associations.</span></li>
				<li><strong class="bold">HKEY_CURRENT_USER</strong> (<strong class="bold">HKCU</strong>): Contains <a id="_idIndexMarker709"/>settings that are specific to the user <a id="_idIndexMarker710"/>that is currently logged on. Technically, this root key is just a symbolic link that leads <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">HKU\&lt;CurrentUserSid&gt;\</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">HKEY_LOCAL_MACHINE</strong> (<strong class="bold">HKLM</strong>): Settings<a id="_idIndexMarker711"/> that <a id="_idIndexMarker712"/>are specific to the <span class="No-Break">local computer.</span></li>
				<li><strong class="bold">HKEY_USERS</strong> (<strong class="bold">HKU</strong>): Subkeys <a id="_idIndexMarker713"/>for each user profile <a id="_idIndexMarker714"/>actively loaded on the machine (like <strong class="bold">HKEY_CURRENT_USER</strong>, but <a id="_idIndexMarker715"/>not exclusively limited to the currently <span class="No-Break">logged-on user).</span></li>
				<li><strong class="bold">HKEY_CURRENT_CONFIG</strong> (<strong class="bold">HKCC</strong>): Hives<a id="_idIndexMarker716"/> under this root key don’t store any information<a id="_idIndexMarker717"/> themselves, but rather act as a pointer to registry keys that keep information about the current <span class="No-Break">hardware profile.</span></li>
			</ul>
			<p>PowerShell treats the<a id="_idIndexMarker718"/> registry like a virtual drive; you can access and modify it using the same commands as you would while navigating and editing files <span class="No-Break">and folders.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor116"/>Working with the registry</h2>
			<p>Using<a id="_idIndexMarker719"/> the <strong class="source-inline">Get-PSDrive</strong> cmdlet, you can get all drives of the current session. If you inspect the output a little bit further, you’ll see that not only system drives are listed here. The <strong class="source-inline">HKCU</strong> and <strong class="source-inline">HKLM</strong> registry root keys can also be found here <span class="No-Break">as well:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer113">
					<img alt="Figure 5.1 – Finding the HKCU and HKLM registry root keys using Get-PSDrive" src="image/B16679_05_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Finding the HKCU and HKLM registry root keys using Get-PSDrive</p>
			<p>And since PSDrives such as <strong class="source-inline">HKCU</strong> and <strong class="source-inline">HKLM</strong> are treated like regular file drives, it is not surprising that you can navigate through them using <strong class="source-inline">Set-Location</strong> (or the equivalent alias, <strong class="source-inline">cd</strong>), as well as <strong class="source-inline">Get-ChildItem</strong> (or the alias, <strong class="source-inline">ls</strong>) to list the contents of <span class="No-Break">a folder.</span></p>
			<p>In the<a id="_idIndexMarker720"/> following example, I query the current Windows PowerShell version from <span class="No-Break">the registry:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer114">
					<img alt="Figure 5.2 – Navigating through the registry" src="image/B16679_05_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Navigating through the registry</p>
			<p>In the preceding screenshot, you can see all the sub-registry keys (<strong class="source-inline">Name</strong>), and also all the registry entries (also called <strong class="source-inline">Property</strong> in this context) that belong to each <span class="No-Break">registry key.</span></p>
			<p>It is also possible to browse other locations of the registry than only the listed drives by using <strong class="source-inline">Registry::</strong> followed by the root key you want to query. In the following screenshot, I use <strong class="source-inline">Foreach-Object</strong> to show the key names of all <span class="No-Break">sub-registry keys:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer115">
					<img alt="Figure 5.3 – Browsing the registry using the Registry:: prefix" src="image/B16679_05_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Browsing the registry using the Registry:: prefix</p>
			<p>Working with registry keys is quite similar to working with files and folders, but nevertheless, there’s a difference when it comes to registry entries. They not only consist of keys but also of properties and values, as you can see in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer116">
					<img alt="Figure 5.4 – Displaying properties and values of a registry key by using Get-Item" src="image/B16679_05_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Displaying properties and values of a registry key by using Get-Item</p>
			<p>When <a id="_idIndexMarker721"/>working with registry keys that have numerous subkeys and properties, you may want to obtain a list of all subkeys quickly. You can achieve this by using <span class="No-Break"><strong class="source-inline">ForEach-Object Name</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer117">
					<img alt="Figure 5.5 – Displaying all sub-registry keys" src="image/B16679_05_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Displaying all sub-registry keys</p>
			<p>In this screenshot, we first changed the working directory to <strong class="source-inline">HKLM:\SOFTWARE\Microsoft\Windows\</strong> using the <strong class="source-inline">Set-Location</strong> cmdlet before querying the registry using <strong class="source-inline">Get-ChildItem</strong>. This way, you won’t need to type the entire path over and over again if you want to perform execute further commands in <span class="No-Break">this location.</span></p>
			<p>If you are <a id="_idIndexMarker722"/>not certain where a specific registry key is located, query the registry recursive as you would <em class="italic">search</em> for a specific file on a drive using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; Get-ChildItem -Path "HKLM:\SOFTWARE\Microsoft\PowerShell" -Recurse -ErrorAction SilentlyContinue | Where-Object {$_.Name -like "*PowerShellEngine*"}</pre>
			<p>Using the <strong class="source-inline">New-Item</strong> cmdlet, you can create a new registry key, and using <strong class="source-inline">Remove-Item</strong>, you can delete one or more registry keys, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer118">
					<img alt="Figure 5.6 – Creating and deleting a registry key" src="image/B16679_05_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Creating and deleting a registry key</p>
			<p>Using <strong class="source-inline">Remove-Item</strong> with <a id="_idIndexMarker723"/>the <strong class="source-inline">-Recurse</strong> parameter lets you delete a registry key as well as subkeys recursively without being prompted <span class="No-Break">for confirmation.</span></p>
			<h3>Registry entry properties</h3>
			<p>You <a id="_idIndexMarker724"/>now know how to operate registry keys and how to display their properties, but when it comes to the registry, you want to understand how to work with the properties <span class="No-Break">as well.</span></p>
			<p>As mentioned earlier, although operating the registry is similar to working with files and folders, there are some differences when it comes to the properties of registry entries: while files have properties such as <strong class="source-inline">LastWriteTime</strong>, registry entries have their own set <span class="No-Break">of properties.</span></p>
			<p>One way to get a quick overview of the properties might be <strong class="source-inline">Get-Item</strong>, but there’s another cmdlet that helps you to get more details – <span class="No-Break"><strong class="source-inline">Get-ItemProperty</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer119">
					<img alt="Figure 5.7 – Using Get-ItemProperty to display registry entries" src="image/B16679_05_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Using Get-ItemProperty to display registry entries</p>
			<p>By using the <strong class="source-inline">*-ItemProperty</strong> cmdlets, you can also manage registry entries. For example, to <a id="_idIndexMarker725"/>create a new registry entry, the <strong class="source-inline">New-ItemProperty</strong> cmdlet can help you. In the following screenshot, I have created a new entry in the startup folder for all users and deleted it <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Remove-ItemProperty</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer120">
					<img alt="Figure 5.8 – Creating and deleting a new registry entry" src="image/B16679_05_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Creating and deleting a new registry entry</p>
			<p>It is also possible to change a registry entry by using the <strong class="source-inline">Set-ItemProperty</strong> cmdlet. The following example demonstrates how to use <strong class="source-inline">Set-ItemProperty</strong> to alter an existing startup entry to change the path of <span class="No-Break">a script:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer121">
					<img alt="Figure 5.9 – Altering a registry entry" src="image/B16679_05_009.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Altering a registry entry</p>
			<p>By the way, attackers <a id="_idIndexMarker726"/>like to create startup entries, too! This is, for example, one of many ways to establish persistence. So if you come across code similar to the preceding code in PowerShell logs and you did not create it yourself, it could be a sign of an attacker attempting to modify a startup entry to run their malware instead of its original <span class="No-Break">intended purpose.</span></p>
			<p>You can get more information on how to operate the registry using PowerShell via the following help <span class="No-Break">system commands:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Get-Help Registry</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Get-Help about_Providers</strong></span></li>
			</ul>
			<p>Additionally, understanding the security use cases for working with the registry is essential for defenders. Let’s explore some of the most common <span class="No-Break">ones next.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor117"/>Security use cases</h2>
			<p>There<a id="_idIndexMarker727"/> are multiple use cases for attackers where they query or attempt to modify the registry – use cases that defenders should also be familiar with. Let’s start exploring some of the most <span class="No-Break">common ones.</span></p>
			<h3>Reconnaissance</h3>
			<p>Often, attackers <a id="_idIndexMarker728"/>access the registry to find out more about the current target system: is an antimalware solution in use, and does the attacker's code need additional steps to avoid being detected? Is there a backup solution that would prevent a successful <span class="No-Break">ransomware attack?</span></p>
			<p>The registry is also<a id="_idIndexMarker729"/> often queried to find out more about the system and configured (security) options. And some adversaries also try<a id="_idIndexMarker730"/> to find out whether the system that is currently executing the<a id="_idIndexMarker731"/> code is a <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) or <span class="No-Break">a </span><span class="No-Break"><strong class="bold">sandbox</strong></span><span class="No-Break">.</span></p>
			<p>A VM is an emulated computer, which is hosted on another computer, the hypervisor. It does not require its own hardware, as it shares the hardware of the hypervisor with many other VMs. A sandbox is a system that is often used by security researchers or even antimalware solutions to detonate a potential malware and test how it behaves and whether it’s truly malicious. Attackers usually want to avoid their software being run on a VM or a sandbox as this could imply that someone is analyzing their malware to build protections <span class="No-Break">against it.</span></p>
			<p>If that is the case, and if the malware is executed in a VM or in a sandbox, often it is implemented so that the software behaves in a different way than it would on a physical work device that is used by a real user – to complicate reverse engineering of their code to stay undetected for a <span class="No-Break">longer period.</span></p>
			<p>Coming back to the registry – storing credentials in the registry is a very bad practice and should be avoided. However, there are still administrators and software vendors that use the registry to store credentials in a very unsecure way. Therefore, attackers have been observed to query the registry to <span class="No-Break">retrieve credentials.</span></p>
			<p>Some malware even uses the registry for their own purposes, and set and query their own registry hives <span class="No-Break">or keys.</span></p>
			<p>Remember that when you are searching for reconnaissance evidence, attackers also have other (programmatic) options to query the registry – such as the <strong class="source-inline">reg.exe</strong> command-line tool <span class="No-Break">or WMI.</span></p>
			<h3>Execution policy</h3>
			<p>In <a href="B16679_01_Final_PD.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Getting Started with PowerShell</em>, we learned that <strong class="source-inline">ExecutionPolicy</strong> restricts <a id="_idIndexMarker732"/>the execution of scripts on the local machine – although it’s not a security control. Nevertheless, the <strong class="source-inline">ExecutionPolicy</strong> status can also be queried or modified using <span class="No-Break">the registry:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer122">
					<img alt="Figure 5.10 – Changing the Windows PowerShell ExecutionPolicy using the registry" src="image/B16679_05_010.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Changing the Windows PowerShell ExecutionPolicy using the registry</p>
			<p>Changing <strong class="source-inline">ExecutionPolicy</strong> using the registry only works for Windows PowerShell. Therefore, you <a id="_idIndexMarker733"/>can see in the preceding screenshot that, first, the Windows PowerShell <strong class="source-inline">ExecutionPolicy</strong> shows that it is set to <strong class="source-inline">Restricted</strong>, but after configuring the registry entry, it is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Unrestricted</strong></span><span class="No-Break">.</span></p>
			<p>PowerShell Core’s <strong class="source-inline">ExecutionPolicy</strong> is defined in the following file: <span class="No-Break"><strong class="source-inline">C:\Program Files\PowerShell\7\powershell.config.json</strong></span><span class="No-Break">.</span></p>
			<h3>Persistence</h3>
			<p>Another <a id="_idIndexMarker734"/>reason attackers attempt to edit the registry is to establish persistence: a very common way to establish persistence is to add a Startup entry. This can be done by adding a link to either the Startup folder of the current user or <span class="No-Break">all users.</span></p>
			<p>Another option to establish persistence via Startup is by adding either a <strong class="source-inline">Run</strong> or <strong class="source-inline">RunOnce</strong> registry key under one of the following Startup <span class="No-Break">registry locations:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">HCU\.DEFAULT\Software\Microsoft\CurrentVersion\</strong></span></li>
			</ul>
			<p>Note that <strong class="source-inline">.DEFAULT</strong> can also be replaced with the <a id="_idIndexMarker735"/>user <strong class="bold">Security identifiers</strong> (<strong class="bold">SIDs</strong>) of the respective folder <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">HKEY_USERS</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">Run</strong> key <a id="_idIndexMarker736"/>executes the program each time a user logs on, while the <strong class="source-inline">RunOnce</strong> key runs the program once and then deletes the key. These keys can be set for the user or <span class="No-Break">the machine.</span></p>
			<p>To set, for example, a <strong class="source-inline">RunOnce</strong> key for the current user to execute a script <em class="italic">once</em> after the user logged on, you would use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
&gt; New-ItemProperty -Path HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce\ -Name "HelloWorld" -Value "C:\Users\ADMINI~1\AppData\Local\Temp\HelloWorld.ps1"</pre>
			<p>To set a <strong class="source-inline">Run</strong> key for the local machine to execute a script <em class="italic">every time</em> the machine is booted, use the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; New-ItemProperty -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\ -Name "HelloWorld" -Value "C:\Users\ADMINI~1\AppData\Local\Temp\HelloWorld.ps1"</pre>
			<p>Additionally, attackers can also establish persistence under other user's Startup keys by directly writing to their respective <strong class="source-inline">Run</strong>/<strong class="source-inline">RunOnce</strong> keys under the <strong class="source-inline">HKU\&lt;TargetSID&gt;\Software\Microsoft\CurrentVersion\</strong> key, provided they have the <span class="No-Break">necessary permissions.</span></p>
			<p>Now that we explored the Windows Registry, let’s dive into another important part when it comes to security: local <span class="No-Break">user rights.</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor118"/>User rights</h1>
			<p>User rights play a huge role in corporate environments: you can, for example, configure who is allowed to log on to which system and who is allowed to do what. A misconfiguration can cause a serious risk of identity theft and <span class="No-Break">lateral movement.</span></p>
			<p>Adversaries <a id="_idIndexMarker737"/>can use it to find out which accounts are worthwhile to compromise to escalate <span class="No-Break">their privileges.</span></p>
			<p>You can find a detailed overview of all user rights in the official <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment"><span class="No-Break">https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment</span></a><span class="No-Break">.</span></p>
			<p>I know the documentation is quite extensive and if you have no experience on user rights yet, you might quickly get lost. Therefore, let me explain some of the most important security-related user rights that I have often <span class="No-Break">seen misconfigured.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor119"/>Configuring access user rights</h2>
			<p>In general, log-on rights<a id="_idIndexMarker738"/> are always critical if too many users and or groups are allowed to access a sensitive system. Many default rights are set by default and may need to be changed to harden <span class="No-Break">the system.</span></p>
			<p>Depending on what machine type you’re configuring this policy for, you may want to limit the ability to log on locally or through a remote desktop to a machine to its users and/or specific <span class="No-Break">administrator accounts:</span></p>
			<ul>
				<li><strong class="bold">Access this computer from the network</strong> (<strong class="source-inline">SeNetworkLogonRight</strong>): For <strong class="bold">domain controllers</strong> (<strong class="bold">DCs</strong>), all authenticated users <a id="_idIndexMarker739"/>needs to have access to apply Group Policies, so configure <strong class="bold">Administrators</strong> and <strong class="bold">Authenticated Users</strong> to access DCs. Remove the <span class="No-Break">built-in groups.</span></li>
			</ul>
			<p>Remove <strong class="bold">Everyone</strong>, <strong class="bold">Users</strong>, as well as the built-in groups for member servers. For client PCs, only allow users and administrators to <span class="No-Break">log on.</span></p>
			<ul>
				<li><strong class="bold">Allow log on locally</strong> (<strong class="source-inline">SeInteractiveLogonRight</strong>): Remove <strong class="bold">Guest</strong> and built-in groups. If it’s a DC or a member server, also <span class="No-Break">remove </span><span class="No-Break"><strong class="bold">Users</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Allow log on through Remote Desktop </strong><span class="No-Break"><strong class="bold">Services</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">SeRemoteInteractiveLogonRight</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Log on as a batch </strong><span class="No-Break"><strong class="bold">job</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">SeBatchLogonRight</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Log on as a </strong><span class="No-Break"><strong class="bold">service</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">SeServiceLogonRight</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>The <em class="italic">deny</em> rules overwrite the <em class="italic">allow</em> privileges: no matter what you configured as an <em class="italic">allow</em> rule, if access is forbidden by a <em class="italic">deny</em> rule, the affected user cannot log on or access <span class="No-Break">the machine:</span></p>
			<ul>
				<li><strong class="bold">Deny access to this computer from the </strong><span class="No-Break"><strong class="bold">network</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">SeDenyNetworkLogonRight</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Deny log on as a batch </strong><span class="No-Break"><strong class="bold">job</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">SeDenyBatchLogonRight</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Deny log on as a </strong><span class="No-Break"><strong class="bold">service</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">SeDenyServiceLogonRight</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Deny log on </strong><span class="No-Break"><strong class="bold">locally</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">SeDenyInteractiveLogonRight</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Deny log on through Remote Desktop </strong><span class="No-Break"><strong class="bold">Services</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">SeDenyRemoteInteractiveLogonRight</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>These rules <a id="_idIndexMarker740"/>can help you to set up a solid tiering concept in <span class="No-Break">your environment.</span></p>
			<p>Do not remove <strong class="bold">Guest</strong> from the <strong class="bold">Deny log on</strong>/<strong class="bold">access</strong> permissions unless your specific configuration <span class="No-Break">requires it.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor120"/>Mitigating risks through backup and restore privileges</h2>
			<p>Backup and restore privileges <a id="_idIndexMarker741"/>can be incredibly powerful, as they allow users to access and modify files and directories that they normally have no access to. It makes sense to evaluate very carefully who has these rights configured, especially on critical systems such as DCs. These rights could allow adversaries to extract sensitive information such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Back up files and </strong><span class="No-Break"><strong class="bold">directories</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">SeBackupPrivilege</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Restore files and </strong><span class="No-Break"><strong class="bold">directories</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">SeRestorePrivilege</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>It’s crucial to note that backup privileges allow a user to read any file, regardless of their normal permissions. This means that users with backup privileges can also potentially access sensitive information such as, for example, password hashes that are available in the <strong class="source-inline">ntds.dit</strong> database file on DCs. Restore privileges, on the other hand, allow a user to write any file, which could potentially be used to plant malicious code or modify critical <span class="No-Break">system files.</span></p>
			<p>By default, the built-in <strong class="bold">Backup Operators</strong> group is assigned both of these rights. Be careful if you plan to remove this group because some backup software packages rely on this group to <a id="_idIndexMarker742"/>enable the software to function. Where possible, assign the backup and restore privileges only to specific users or groups instead of relying on the built-in <strong class="bold">Backup </strong><span class="No-Break"><strong class="bold">Operators</strong></span><span class="No-Break"> group.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor121"/>Delegation and impersonation</h2>
			<p>Having the right for <a id="_idIndexMarker743"/>delegation allows someone to delegate rights to <a id="_idIndexMarker744"/>another account. Impersonation allows impersonating another account, which is usually used by web servers to access resources in the context of a user. If misconfigured, both can have <span class="No-Break">dramatic consequences:</span></p>
			<ul>
				<li><strong class="bold">Enable computer and user accounts to be trusted for delegation</strong> (<strong class="source-inline">SeEnableDelegationPrivilege</strong>): If an account is trusted for delegation, that means that this account can set the <em class="italic">trusted for delegation</em> setting. Once set, this setting enables the ability to connect to multiple servers or services while retaining the credentials of the originating account. Web servers, which need to connect using the originating credentials to a database or data share, are a good example of a legitimate use case to be <em class="italic">trusted </em><span class="No-Break"><em class="italic">for delegation</em></span><span class="No-Break">.</span></li>
			</ul>
			<p>Nevertheless, you want to avoid configuring this right unless it is really needed by a <span class="No-Break">certain software.</span></p>
			<ul>
				<li><strong class="bold">Impersonate a client after authentication</strong> (<strong class="source-inline">SeImpersonatePrivilege</strong>): Impersonation allows services or threads to run under a different security context. If misconfigured, this ability could allow attackers to trick clients into connecting to a service created by the attacker to then impersonate the connecting client to elevate the <span class="No-Break">attacker’s privileges.</span></li>
				<li><strong class="bold">Act as part of the operating system</strong> (<strong class="source-inline">SeTcbPrivilege</strong>): This right allows an account to control the system and act as any user. This setting decides whether a process can take on the identity of any user, which gives access to the resources that the user <span class="No-Break">can use.</span></li>
			</ul>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor122"/>Preventing event log tampering</h2>
			<p>If you have <a id="_idIndexMarker745"/>access to the auditing and security log, you can tamper with it and hide your traces. The following settings affect access to the auditing and security log and should be configured <span class="No-Break">with care:</span></p>
			<ul>
				<li><strong class="bold">Generate security audits</strong> (<strong class="source-inline">SeAuditPrivilege</strong>): Although this privilege only allows generating new events, an attacker can create so much noise that their attacking attempts might go unnoticed, especially if the company does not forward event logs and deletes them after a certain volume <span class="No-Break">is reached.</span></li>
				<li><strong class="bold">Manage auditing and security log</strong> (<strong class="source-inline">SeSecurityPrivilege</strong>): If you can manage event logs, then you can surely delete them as well. Look for event ID <strong class="source-inline">104</strong> in the system event log. Please refer to <a href="B16679_04_Final_PD.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Detection – Auditing and Monitoring</em>, for more information on monitoring <span class="No-Break">and detection.</span></li>
			</ul>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor123"/>Preventing Mimikatz and credential theft</h2>
			<p>Mimikatz and <a id="_idIndexMarker746"/>other tools that are used for credential theft usually require the right to debug programs or load kernel mode drivers. The following settings<a id="_idIndexMarker747"/> are usually required by tools such as Mimikatz and others to <span class="No-Break">extract credentials:</span></p>
			<ul>
				<li><strong class="bold">Debug programs</strong> (<strong class="source-inline">SeDebugPrivilege</strong>): A common misconception with the <strong class="bold">Debug programs</strong> privilege is that this would be needed by developers to debug their software. This is not true. The Debug programs privileges privilege allows access to otherwise protected operating system memory, effectively providing control over program execution and the ability to read and write memory. Tools such as Mimikatz that access<a id="_idIndexMarker748"/> the <strong class="bold">Local Security Authority</strong> (<strong class="bold">LSA</strong>) to extract credentials require this permission to <span class="No-Break">properly function.</span></li>
			</ul>
			<p>Normally, your administrators will not require this user right, so it’s safe to revoke this right for everybody, even for <span class="No-Break">your administrators.</span></p>
			<p>Note that administrators can assign this right to themselves; therefore, remove this privilege and monitor for changes. In this way, you can spot indicators for the beginning of a credential <span class="No-Break">theft attack.</span></p>
			<ul>
				<li><strong class="bold">Load and unload device drivers</strong> (<strong class="source-inline">SeLoadDriverPrivilege</strong>): This right enables a user <a id="_idIndexMarker749"/>account to load kernel mode drivers. Since these drivers are located in <a id="_idIndexMarker750"/>kernel mode memory, they can be used to read or tamper with other kernel mode memory, much like the <strong class="bold">Debug programs</strong> right. Be cautious when granting this <span class="No-Break">user right.</span></li>
			</ul>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor124"/>System and domain access</h2>
			<p>Getting <a id="_idIndexMarker751"/>access to the system or adding machines to a domain can be very valuable for attackers. The following setting is related to <span class="No-Break">these scenarios:</span></p>
			<ul>
				<li><strong class="bold">Add workstations to domain</strong> (<strong class="source-inline">SeMachineAccountPrivilege</strong>): This privilege allows the user to add workstations to <span class="No-Break">the domain.</span></li>
			</ul>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor125"/>Time tampering</h2>
			<p>Tampering <a id="_idIndexMarker752"/>with the time of an operating system is not considered a security flaw by default and should not be confused with <strong class="bold">timestomping</strong>, which<a id="_idIndexMarker753"/> involves modifying timestamps of file creation, access, modification, and so on. Nevertheless, it is important to be aware that certain programs may encounter issues when the system time is tampered with, and incorrect timestamps can lead to inaccurate conclusions during event log analysis. The following settings should be configured very carefully to avoid <span class="No-Break">these scenarios:</span></p>
			<ul>
				<li><strong class="bold">Change the system </strong><span class="No-Break"><strong class="bold">time</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">SeSystemtimePrivilege</strong></span><span class="No-Break">)</span></li>
				<li><strong class="bold">Change the time </strong><span class="No-Break"><strong class="bold">zone</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">SeTimeZonePrivilege</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Of course, this is only a summary of the user rights that I have seen mostly misconfigured and not a complete list. Please refer to the official documentation and follow the links to read more about each user <span class="No-Break">privilege: </span><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment"><span class="No-Break">https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment</span></a><span class="No-Break">.</span></p>
			<p>And if you want to find out which built-in groups have which user rights assigned by default, the following documentation can be very <span class="No-Break">helpful: </span><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn487460(v=ws.11)"><span class="No-Break">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn487460(v=ws.11)</span></a><span class="No-Break">.</span></p>
			<p>You can use the <strong class="bold">Policy Analyzer</strong> as <a id="_idIndexMarker754"/>well to analyze and compare your settings with the official<a id="_idIndexMarker755"/> Microsoft recommendation. We will explore Policy Analyzer later in <a href="B16679_06_Final_PD.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><em class="italic">, Active Directory – Attacks </em><span class="No-Break"><em class="italic">and Mitigation</em></span><span class="No-Break">.</span></p>
			<p>But Policy Analyzer is not the only way to analyze and compare user right assignments – let’s look at how to assert which rights are set and how to configure them in our <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor126"/>Examining and configuring user rights</h2>
			<p>If you want to<a id="_idIndexMarker756"/> examine which user rights are configured on the localhost, you can<a id="_idIndexMarker757"/> run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; SecEdit.exe /export /areas USER_RIGHTS /cfg $Env:Temp\secedit.txt</pre>
			<p>If you want to export the local and domain-managed policy merged, you can use the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">mergedpolicy</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
&gt; SecEdit.exe /export <strong class="source-inline">/mergedpolicy</strong> /areas USER_RIGHTS /cfg $Env:Temp\secedit.txt</pre>
			<p>All current user rights will be written to <strong class="source-inline">$Env:Temp\secedit.txt</strong>. Under the <strong class="bold">[Privilege Rights]</strong> section, you can find all configured assignments. By using <strong class="source-inline">secedit</strong>, only the SIDs will be shown, so you will need to translate them into real user <span class="No-Break">account names.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer123">
					<img alt="Figure 5.11 – Privilege rights in the secedit file" src="image/B16679_05_011.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – Privilege rights in the secedit file</p>
			<p>You can find more information on further parameters and the usage of <strong class="source-inline">secedit</strong> in the official <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490997(v=technet.10)"><span class="No-Break">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490997(v=technet.10)</span></a><span class="No-Break">.</span></p>
			<p>I have <a id="_idIndexMarker758"/>written <a id="_idIndexMarker759"/>a script, <strong class="source-inline">Get-UserRightsAssignment</strong>, that will help you to translate the SIDs into account names and makes it easier to process user rights. You can use the <strong class="source-inline">-Path</strong> parameter to specify a custom location where the file generated by <strong class="source-inline">secedit</strong> should be <span class="No-Break">saved to:</span></p>
			<pre class="source-code">
&gt; Get-UserRightsAssignment.ps1 -Path C:\tmp\secedit.txt</pre>
			<p>The <strong class="source-inline">secedit</strong> file will be deleted after the script completes. If <strong class="source-inline">-Path</strong> is not specified, the default path will be <strong class="source-inline">$env:TEMP\secedit.txt</strong>. As the script leverages the <strong class="source-inline">secedit</strong> tool, you will need administrative rights to <span class="No-Break">execute it.</span></p>
			<p>You can find and download the <strong class="source-inline">Get-UserRightsAssignment</strong> script in the GitHub repository of this <span class="No-Break">book: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-UserRightsAssignment.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-UserRightsAssignment.ps1</span></a><span class="No-Break">.</span></p>
			<p>You can also use Group Policy to configure the user rights assignment of multiple computers and/or servers in <span class="No-Break">your environment.</span></p>
			<p>Create a new <strong class="bold">Group Policy Object</strong> (<strong class="bold">GPO</strong>) and <a id="_idIndexMarker760"/>navigate to <strong class="bold">Computer Configuration</strong> | <strong class="bold">Windows Settings</strong> | <strong class="bold">Security Settings</strong> | <strong class="bold">Local Policies</strong> | <strong class="bold">User </strong><span class="No-Break"><strong class="bold">Rights Assignment</strong></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer124">
					<img alt="Figure 5.12 – Configuring user rights assignment via Group Policy" src="image/B16679_05_012.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – Configuring user rights assignment via Group Policy</p>
			<p>Double-click <a id="_idIndexMarker761"/>each policy setting that you want to configure. A window <a id="_idIndexMarker762"/>will open. To configure the setting, check the <strong class="bold">Define these policy settings</strong> box and use <strong class="bold">Add User or Group</strong> to add additional users or groups, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer125">
					<img alt="Figure 5.13 – Configuring the Allow log on locally setting" src="image/B16679_05_013.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13 – Configuring the Allow log on locally setting</p>
			<p>Under the <strong class="bold">Explain</strong> tab, you will<a id="_idIndexMarker763"/> find more information on what this setting does and, often, also useful links on where to find more details on <span class="No-Break">this setting.</span></p>
			<p>If you configure <a id="_idIndexMarker764"/>user rights assignments and assess the GPO on the system, you will see that a similar file is created as if you would create it manually. You can use it to compare your settings or just place a manually preconfigured <strong class="source-inline">secedit</strong> file here to avoid configuring all settings manually via the <span class="No-Break">GPO interface.</span></p>
			<p>For example in my domain, <strong class="source-inline">PSSec.local</strong>, I created the GPO with the unique ID <strong class="source-inline">{B04231D1-A45A-4390-BB56-897DA6B1A910}</strong>. If I want to access the newly created <strong class="source-inline">secedit</strong> configuration, I simply have to navigate to the following path and assess the <span class="No-Break"><strong class="source-inline">GptTmpl.inf</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
<strong class="source-inline">\\pssec.local\SYSVOL\PSSec.local\Policies\{B04231D1-A45A-4390-BB56-897DA6B1A910}\Machine\Microsoft\Windows NT\SecEdit</strong></pre>
			<p>Of course, you can also just copy the <strong class="source-inline">GptTmpl.inf</strong> file from an existing Microsoft Security baseline into a newly created <a id="_idIndexMarker765"/>GPO to just configure the Microsoft recommendations. A Microsoft Security baseline is a configuration recommendation by Microsoft to provide security best practices. We will further look into baselines in <a href="B16679_06_Final_PD.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><em class="italic">, Active Directory – Attacks </em><span class="No-Break"><em class="italic">and Mitigation</em></span><span class="No-Break">.</span></p>
			<p>After exploring Windows user rights in the preceding section, we will now focus on another vital component of the Windows operating system – the <span class="No-Break">Windows API.</span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor127"/>Basics of the Windows API</h1>
			<p>The <a id="_idIndexMarker766"/>Windows <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>), also known as Win32 or WinAPI, is a collection of libraries, functions, and interfaces that provide low-level access to various features and components of the Windows operating system. It allows developers direct access to system features and hardware, simplifying access to deeper layers of the operating system. The Windows API functions are written in C/C++ and are exposed by DLL files (such as <strong class="source-inline">kernel32.dll</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">user32.dll</strong></span><span class="No-Break">).</span></p>
			<p>The Windows API is implemented as a <a id="_idIndexMarker767"/>collection of <strong class="bold">dynamic-link libraries</strong> (<strong class="bold">DLLs</strong>) that are loaded into memory when an application needs to use them. These DLLs contain the functions and procedures that make up the API. When an application calls a function from the API, it is essentially sending a message to the operating system to perform a certain task. The operating system then executes the appropriate function from the appropriate DLL and returns the result to <span class="No-Break">the application.</span></p>
			<p>Nowadays, the names <em class="italic">Windows API</em> or <em class="italic">WinAPI</em> refers to several versions, although the versions implemented for different platforms can be still referred to by their own names (such as <span class="No-Break"><em class="italic">Win32 API</em></span><span class="No-Break">):</span></p>
			<ul>
				<li><strong class="bold">Win16 API</strong>: The<a id="_idIndexMarker768"/> first API version was the Win16 API, which was developed for 16-bit platforms, but is no <span class="No-Break">longer supported.</span></li>
				<li><strong class="bold">Win32 API</strong>: The <a id="_idIndexMarker769"/>Windows 32 API is still in use on all current modern Windows systems and was introduced with Windows NT and <span class="No-Break">Windows 95.</span></li>
				<li><strong class="bold">Win32s API</strong>: This<a id="_idIndexMarker770"/> is the Windows 32 API for the Windows 3.1 family, and therefore, an extension to 32-bit, as systems in this family originally only supported 16-bit. The <strong class="bold">s</strong> stands <span class="No-Break">for </span><span class="No-Break"><strong class="bold">subset</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Win64 API</strong>: This <a id="_idIndexMarker771"/>API is the variant for modern 64-bit operating systems and was introduced with Windows XP and Windows <span class="No-Break">Server 2003.</span></li>
				<li><strong class="bold">Windows Native API</strong>: The <a id="_idIndexMarker772"/>Native API is used when other APIs such as the Win32 API are not yet accessible – for example, when a system is booted. Unlike the well-documented Win32 API functions in<a id="_idIndexMarker773"/> the <strong class="bold">Microsoft Developer Network</strong> (<strong class="bold">MSDN</strong>) (such as <strong class="source-inline">kernel32.dll</strong>), it is important to note that the Native API, exported via <strong class="source-inline">NTDLL.DLL</strong>, is not considered a “contractual” interface. This means that the behavior and definitions of functions exposed by <strong class="source-inline">NTDLL.DLL</strong> may change <span class="No-Break">over time.</span></li>
			</ul>
			<p>The <a id="_idIndexMarker774"/>Windows API functions are written exclusively in C, C++, and assembly and can therefore be used by developers in their own functions. The Win32 API itself is quite large, so there are multiple DLL files needed to export the <span class="No-Break">entire functionality.</span></p>
			<p>Nowadays, there are several layered APIs, which simplify access so that the developer does not need to directly work with the Win32 or <span class="No-Break">Win64 API.</span></p>
			<p>Some APIs that build on the Windows API are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">WinRT</strong>: The <a id="_idIndexMarker775"/>Windows Runtime API was first introduced with Windows 8/Windows Server 2012. WinRT is based on the COM and was implemented in C++. It enables developers to write their code now also in other languages, such as C++, C#, Visual Basic .NET, Rust/WinRT, Python/WinRT, <span class="No-Break">and JavaScript/TypeScript.</span></li>
				<li><strong class="bold">COM</strong>: COM<a id="_idIndexMarker776"/> is a part of the APIs and is a technique for inter-process communication. We will have a deeper look at it later in <span class="No-Break">this chapter.</span></li>
				<li><strong class="bold">.NET</strong>/<strong class="bold">.NET Framework</strong>: .NET Framework is a software framework developed <a id="_idIndexMarker777"/>by Microsoft that provides a large library of pre-built functions and APIs that can be used by developers to build applications <span class="No-Break">on Windows.</span></li>
			</ul>
			<p>One way to access the Windows API from PowerShell is through the use of .NET Framework. This allows you to access the same functionality provided by the Windows API, but from within PowerShell. It allows you to interact with the operating system at a lower level and perform tasks that may not be possible with standard PowerShell cmdlets. We will learn more about .NET Framework later in <span class="No-Break">this chapter.</span></p>
			<p>The following list is a collection of different API categories that can <span class="No-Break">be utilized:</span></p>
			<ul>
				<li><strong class="bold">User interface</strong>: Provides<a id="_idIndexMarker778"/> functions for creating and managing user interface elements such as windows, buttons, <span class="No-Break">and menus.</span></li>
				<li><strong class="bold">Windows environment (Shell)</strong>: Includes <a id="_idIndexMarker779"/>functions for interacting with the Windows Shell, which is the graphical user interface that provides access to the filesystem and other <span class="No-Break">system resources.</span></li>
				<li><strong class="bold">User input and messaging</strong>: Handling user input and messaging, such as keyboard <a id="_idIndexMarker780"/>and mouse events, window messages, and system notifications functionality will be provided through <span class="No-Break">this interface.</span></li>
				<li><strong class="bold">Data access and storage</strong>: The<a id="_idIndexMarker781"/> Windows API provides functions for working with data and storage, including file and registry access, database connectivity, and <span class="No-Break">data encryption.</span></li>
				<li><strong class="bold">Diagnostics</strong>: This<a id="_idIndexMarker782"/> interface provides access to monitoring system performance, logging events, and troubleshooting <span class="No-Break">error functions.</span></li>
				<li><strong class="bold">Graphics and multimedia</strong>: Provides<a id="_idIndexMarker783"/> functions for working with graphics, multimedia, and game development, including DirectX and <span class="No-Break">Windows Media.</span></li>
				<li><strong class="bold">Devices</strong>: The <a id="_idIndexMarker784"/>Windows API includes functions for interacting with hardware devices, such as printers, scanners, <span class="No-Break">and cameras.</span></li>
				<li><strong class="bold">System services</strong>: Contains<a id="_idIndexMarker785"/> functions for managing system services, such as starting and stopping processes and managing <span class="No-Break">system resources.</span></li>
				<li><strong class="bold">Security and identity</strong>: The<a id="_idIndexMarker786"/> security and identity interface includes functions for managing user authentication, access control, <span class="No-Break">and cryptography.</span></li>
				<li><strong class="bold">Application installation and servicing</strong>: Includes functions for installing and uninstalling<a id="_idIndexMarker787"/> applications, managing updates, and handling <span class="No-Break">application errors.</span></li>
				<li><strong class="bold">System admin and management</strong>: Contains <a id="_idIndexMarker788"/>functions for managing system settings, performance, and security, and for automating <span class="No-Break">administrative tasks.</span></li>
				<li><strong class="bold">Networking and internet</strong>: The Windows API includes functions for networking <a id="_idIndexMarker789"/>and internet connectivity, including TCP/IP, sockets, and <span class="No-Break">web services.</span></li>
				<li><strong class="bold">Deprecated or legacy APIs</strong>: For backward compatibility with older applications<a id="_idIndexMarker790"/> and systems, the Windows API also includes some older functions <span class="No-Break">and interfaces.</span></li>
				<li><strong class="bold">Windows and application SDKs</strong>: In <a id="_idIndexMarker791"/>addition to the categories of APIs listed previously, there are <a id="_idIndexMarker792"/>also <strong class="bold">software development kits</strong> (<strong class="bold">SDKs</strong>) available for Windows and application development. PowerShell is one example of an SDK that uses the Windows API and .NET Framework. The <strong class="source-inline">System.Management.Automation</strong> assembly includes classes and cmdlets for working with PowerShell from within .<span class="No-Break">NET applications.</span></li>
			</ul>
			<p>Some of the most commonly used Windows API functions include those related to process and thread management, memory management, file and directory management, and registry manipulation. These functions can be used to perform a variety of tasks, such as enumerating processes and threads, reading and writing to memory, creating and deleting files and directories, and manipulating the <span class="No-Break">Windows Registry.</span></p>
			<p>There are of course many other APIs, but I will not concentrate on them in this book. A complete overview<a id="_idIndexMarker793"/> of the functions and structures within the Windows API that can be accessed can be found <span class="No-Break">here: </span><a href="https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list"><span class="No-Break">https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor128"/>Exploring .NET Framework</h1>
			<p><strong class="bold">.NET Framework</strong> is a<a id="_idIndexMarker794"/> software framework developed by Microsoft that provides a wide range of functionalities for building and running applications. It is a default part of every Windows installation since Windows Vista. One of the framework’s key features is the ability to access <a id="_idIndexMarker795"/>system and API resources, making it a <span class="No-Break">powerful tool.</span></p>
			<p>.NET Framework <a id="_idIndexMarker796"/>consists of two <span class="No-Break">main components:</span></p>
			<ul>
				<li><strong class="bold">Common Language </strong><span class="No-Break"><strong class="bold">Runtime</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CLR</strong></span><span class="No-Break">):</span></li>
			</ul>
			<p>This is<a id="_idIndexMarker797"/> the <a id="_idIndexMarker798"/>runtime engine for .NET; it also contains<a id="_idIndexMarker799"/> a <strong class="bold">Just in Time</strong> (<strong class="bold">JIT</strong>) compiler, which translates bytecode in <strong class="bold">Common Intermediate Language</strong> (<strong class="bold">CIL</strong>) to the <a id="_idIndexMarker800"/>underlying compiler to turn it into machine code that can execute on the specific architecture of the computer it is <span class="No-Break">running on.</span></p>
			<p>The CLR also includes thread management, a garbage collector, type safety, code access security, exception handling, <span class="No-Break">and more.</span></p>
			<p>Every .NET Framework version comes with its <span class="No-Break">own CLR.</span></p>
			<ul>
				<li><strong class="bold">.NET Framework Class </strong><span class="No-Break"><strong class="bold">Library</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">FCL</strong></span><span class="No-Break">):</span></li>
			</ul>
			<p>The FCL is <a id="_idIndexMarker801"/>a large collection of types and APIs that implement common functionality – for example, user interface services, connecting to databases, networking, <span class="No-Break">and more.</span></p>
			<p>.NET applications can be written in C#, F#, Visual Basic, and many more, which are also supported on non-Windows systems such as Linux or macOS. On Windows-only systems, C++ can be used <span class="No-Break">as well.</span></p>
			<p>Once the code is written in a .NET Framework-compatible language, the code is compiled into a CIL and is usually stored in assemblies (<strong class="source-inline">.dll</strong> or <strong class="source-inline">.exe</strong> ending). To compile C# source code files, for example, .NET Framework ships its own compiler – <strong class="source-inline">csc.exe</strong> – which can be found on Windows 10 computers under <span class="No-Break">CLR: </span><span class="No-Break"><strong class="source-inline">C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe</strong></span><span class="No-Break">.</span></p>
			<p>The compiler then writes the compiled CIL code as well as a manifest into a read-only part of the output file, which has a standard PE header (Win32-portable executable) and saves it as an assembly file (usually a file with an <strong class="source-inline">.exe</strong> ending – depends on which output format <span class="No-Break">you choose):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer126">
					<img alt="Figure 5.14 – How .NET Framework compiles applications" src="image/B16679_05_014.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14 – How .NET Framework compiles applications</p>
			<p>CIL code <a id="_idIndexMarker802"/>cannot be executed directly; it needs to be JIT compiled by the CLR into machine code first. Therefore, the CLR is needed on the system where the application <span class="No-Break">should run.</span></p>
			<p>When the freshly compiled assembly is executed, the CLR takes the assembly and compiles it on the fly by using a JIT compiler. The assembly is then turned into machine code that can run on the architecture of the machine on which the application <span class="No-Break">was started.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor129"/>.NET Framework versus .NET Core</h2>
			<p>With the<a id="_idIndexMarker803"/> rise of cross-platform and cloud-based applications, in 2016, Microsoft released .NET Core, a lightweight and modular version of the framework. Designed to run on multiple platforms including Windows, macOS, and Linux, .NET Core can be used to develop applications for web, desktop, mobile, gaming, <span class="No-Break">and IoT.</span></p>
			<p>Later, <strong class="bold">.NET Core</strong> was <a id="_idIndexMarker804"/>renamed to <strong class="bold">.NET</strong>, while the Windows-specific branch is nowadays referred to as <strong class="bold">.</strong><span class="No-Break"><strong class="bold">NET Framework</strong></span><span class="No-Break">.</span></p>
			<p>In the following screenshot, we will take a closer look at the similarities and differences between .NET Framework <span class="No-Break">and .NET:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer127">
					<img alt="Figure 5.15 – Comparing .NET and .NET Core" src="image/B16679_05_015.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15 – Comparing .NET and .NET Core</p>
			<p>Overall, .NET is a <a id="_idIndexMarker805"/>more lightweight and modular framework that is optimized for building modern, cloud-based, and containerized applications, whereas .NET Framework is a comprehensive framework that is designed for a wide range of programming scenarios, including large-scale enterprise applications and <span class="No-Break">legacy systems.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor130"/>Compile C# code using .NET Framework</h2>
			<p>It is possible <a id="_idIndexMarker806"/>to compile C# code with .NET Framework and PowerShell by using the command-line compiler, <strong class="source-inline">csc.exe</strong>. This compiler is included with every installation of .NET Framework. Please note that the <strong class="source-inline">csc.exe</strong> compiler can run on any <strong class="source-inline">.cs</strong> file and does not need PowerShell for its execution. Nevertheless, we will be looking at how to use <strong class="source-inline">csc.exe</strong> from PowerShell in this section <span class="No-Break">for completeness.</span></p>
			<p>To compile a C# file using <strong class="source-inline">csc.exe</strong>, navigate to the directory containing the file and run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /out:&lt;output_file_name&gt; &lt;input_file_name&gt;</pre>
			<p>The <strong class="source-inline">/out</strong> option specifies the name of the output file, and <strong class="source-inline">&lt;input_file_name&gt;</strong> specifies the name of the C# file you want to compile. For example, to compile a file named <strong class="source-inline">MyProgram.cs</strong> and to generate an executable file named <strong class="source-inline">MyProgram.exe</strong>, run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /out:MyProgram.exe MyProgram.cs</pre>
			<p>To run <a id="_idIndexMarker807"/>the compiled executable file, simply type the name of the file into the <span class="No-Break">PowerShell console:</span></p>
			<pre class="source-code">
&gt; .\MyProgram.exe</pre>
			<p>Here is an example of how to compile and run a simple <strong class="source-inline">"Hello, World!"</strong> program in C# <span class="No-Break">using PowerShell:</span></p>
			<pre class="source-code">
$code = @"
using System;
class Program {
    static void Main(string[] args) {
        Console.WriteLine("Hello World!");
    }
}
"@
$code | Out-File -FilePath MyProgram.cs
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /out:MyProgram.exe MyProgram.cs
.\MyProgram.exe</pre>
			<p>Once compiled, running <strong class="source-inline">MyProgram.exe</strong> will output <strong class="source-inline">"Hello World!"</strong> to the console, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer128">
					<img alt="Figure 5.16 – Compiling C code using the csc.exe and executing it" src="image/B16679_05_016.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.16 – Compiling C code using the csc.exe and executing it</p>
			<p>The <strong class="source-inline">Out-File</strong> cmdlet <a id="_idIndexMarker808"/>is used to write the C# code to a file named <strong class="source-inline">MyProgram.cs</strong> before it is compiled. This file can then be compiled using the <strong class="source-inline">csc.exe</strong> compiler, and the resulting executable can be run <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">.\MyProgram.exe</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor131"/>Using Add-Type to interact with .NET directly</h2>
			<p>The easiest <a id="_idIndexMarker809"/>way to access the Windows API from PowerShell using .NET methods is by using the <strong class="source-inline">Add-Type</strong> cmdlet. By using <strong class="source-inline">Add-Type</strong>, it is possible to compile and run .NET code from the PowerShell command line. The <strong class="source-inline">Add-Type</strong> cmdlet allows you to define and create .NET Core classes within your PowerShell session. With this cmdlet, you can easily integrate custom objects into your PowerShell code and gain access to .NET Core libraries. By passing your C# code to the <strong class="source-inline">-TypeDefinition</strong> parameter of the <strong class="source-inline">Add-Type</strong> cmdlet, your code compiles in real time whenever calling your newly defined <span class="No-Break">C# function.</span></p>
			<p>For the following example, I have written a little C# class named <strong class="source-inline">DirectoryTest</strong>, which contains the <strong class="source-inline">GetDirectories</strong> function. <strong class="source-inline">GetDirectories</strong> checks whether the path that was passed to the function can be accessed and outputs all files and folders that path contains to the command line. If the path does not exist or is not a legitimate path, the returned output will <span class="No-Break">be empty.</span></p>
			<p>You can find the code in the GitHub repository of this <span class="No-Break">book: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-GetDirectoriesUsingAddType.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-GetDirectoriesUsingAddType.ps1</span></a><span class="No-Break">.</span></p>
			<p>First, you <a id="_idIndexMarker810"/>need to create a class using C# that compiles and runs without errors. In my example, I first load my C# code into the <strong class="source-inline">$Source</strong> variable, which allows me to access <span class="No-Break">it later:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer129">
					<img alt="Figure 5.17 – Storing the C# class in the source variable" src="image/B16679_05_017.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.17 – Storing the C# class in the source variable</p>
			<p><strong class="source-inline">Add-Type</strong> allows you to define and use a .NET Core class in a PowerShell session. The .NET Core class can be either specified within a variable, as we are doing for this example, but it can also be specified inline or provided using a binary or source code file. The following screenshot shows the use <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Add-Type</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer130">
					<img alt="Figure 5.18 – Loading the source code into the current PowerShell session" src="image/B16679_05_018.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.18 – Loading the source code into the current PowerShell session</p>
			<p>Now we can directly interact with the class and call the <strong class="source-inline">GetDirectories</strong> function using the <strong class="source-inline">C:\</strong> parameter to specify which directories of which path should <span class="No-Break">be queried:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer131">
					<img alt="Figure 5.19 – Executing the GetDirectories function from the DirectoryTest class" src="image/B16679_05_019.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.19 – Executing the GetDirectories function from the DirectoryTest class</p>
			<p>Et voilà – all subfolders of the <strong class="source-inline">C</strong> partition are <span class="No-Break">being returned.</span></p>
			<p>Maybe you're now asking yourself, “<em class="italic">But why would I want to query the Windows API if I already have PowerShell?</em>” Well, there are a few reasons why you might prefer to use the API over PowerShell. One reason is that the API can offer low-level functionality that native PowerShell may not provide. Accessing raw Windows APIs directly through <strong class="source-inline">P/Invoke</strong> and executing unmanaged code might be <span class="No-Break">another reason.</span></p>
			<p>By using the API, you can create hooks (which is a technique to make code behave differently as originally designed by injecting custom code), intercept system events, manipulate system settings, monitor system resources, track user activity, and even manipulate the behavior of system processes, which can be useful for various purposes such as red teamers disabling antivirus or <span class="No-Break">elevating privileges.</span></p>
			<p>For further<a id="_idIndexMarker811"/> information on <strong class="source-inline">Add-Type</strong>, please refer to the official <strong class="source-inline">Add-Type</strong> <span class="No-Break">documentation: </span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor132"/>Loading a custom DLL from PowerShell</h2>
			<p>There’s also a <a id="_idIndexMarker812"/>way to load a custom DLL from PowerShell when it is already compiled. Of course, you can also use <strong class="source-inline">csc.exe</strong> to compile your own <span class="No-Break">program first.</span></p>
			<p>You can find the <strong class="source-inline">DirectoryTest.cs</strong> file that we are using in this example in this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/DirectoryTest.cs"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/DirectoryTest.cs</span></a><span class="No-Break">.</span></p>
			<p>We first compile the program into a DLL <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">csc.exe</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /out:"C:\Users\Administrator\Documents\Chapter05\DirectoryTest.dll" "C:\Users\Administrator\Documents\Chapter05\DirectoryTest.cs"</pre>
			<p>Now, you can load the compiled DLL and load it using the <strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">System.Reflection.Assembly]::Load()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
&gt; $DllPath = "C:\Users\Administrator\Documents\Chapter05\DirectoryTest.dll"
&gt; $DllBytes = [System.IO.File]::ReadAllBytes($DllPath)
&gt; [System.Reflection.Assembly]::Load($DllBytes)</pre>
			<p>In .NET, an assembly is basically the smallest, fundamental unit of deployment of an application. It is either a <strong class="source-inline">.dll</strong> or an <strong class="source-inline">.exe</strong> file. If the assembly is shared between applications, it is usually stored<a id="_idIndexMarker813"/> in the <strong class="bold">Global Assembly </strong><span class="No-Break"><strong class="bold">Cache</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">GAC</strong></span><span class="No-Break">).</span></p>
			<p>Once the DLL is successfully loaded, you can now access its methods from PowerShell, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer132">
					<img alt="Figure 5.20 – Loading a custom DLL and accessing its methods from PowerShell" src="image/B16679_05_020.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.20 – Loading a custom DLL and accessing its methods from PowerShell</p>
			<p>As shown <a id="_idIndexMarker814"/>in the preceding screenshot, by using <strong class="source-inline">[DirectoryTest]::GetDirectories("C:\tmp")</strong>, it is possible to execute the <strong class="source-inline">GetDirectories</strong> function that was defined in <strong class="source-inline">DirectoryTest.dll</strong>: all folders and files that are in the specified directory will be written to <span class="No-Break">the output.</span></p>
			<p>Similar to the <strong class="source-inline">[System.Reflection.Assembly]::Load()</strong> function, you can also use <strong class="source-inline">Add-Type</strong> with the <strong class="source-inline">-Path</strong> parameter to load a DLL <span class="No-Break">in PowerShell:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer133">
					<img alt="Figure 5.21 – Loading a DLL by using Add-Type" src="image/B16679_05_021.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.21 – Loading a DLL by using Add-Type</p>
			<p>You can find the example code used in <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.21</em> in the GitHub repository of this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-LoadDllWithAddType.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-LoadDllWithAddType.ps1</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor133"/>Calling the Windows API using P/Invoke</h2>
			<p>Using the <a id="_idIndexMarker815"/>Windows API can be useful for PowerShell scripting when you want to call functions that are not exposed by PowerShell cmdlets or .NET classes (<span class="No-Break"><strong class="bold">unmanaged code</strong></span><span class="No-Break">).</span></p>
			<p>To call a <a id="_idIndexMarker816"/>Windows API function from PowerShell, you need to do <span class="No-Break">three things:</span></p>
			<ol>
				<li>Declare the DLL file that contains the function using <strong class="source-inline">DllImport</strong>, specifying the location of <span class="No-Break">the DLL.</span></li>
				<li>Declare the function signature (the name, parameters, return type, and <span class="No-Break">calling convention).</span></li>
				<li>Invoke the function with the <span class="No-Break">appropriate arguments.</span></li>
			</ol>
			<p>Let’s look at how this can be done with an easy example using the <strong class="source-inline">MessageBoxA</strong> function <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">user32.dll</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$signature = @"
[DllImport("user32.dll")]
public static extern int MessageBoxA(IntPtr hWnd, string text, string caption, uint type);
"@
Add-Type -MemberDefinition $signature -Name "User32" -Namespace "Win32" -PassThru
$null = [Win32.User32]::MessageBoxA([IntPtr]::Zero, 'I just called to say "Hello World!" :-) ', 'Hello world', 0)</pre>
			<p>In this example, we first declare the function signature for the <strong class="source-inline">MessageBoxA</strong> function from the <strong class="source-inline">user32.dll</strong> library using the <strong class="source-inline">DllImport</strong> attribute and save it in the <strong class="source-inline">$signature</strong> variable. We then add the function signature to the PowerShell session using the <strong class="source-inline">Add-Type</strong> cmdlet, which allows us to use the function in our <span class="No-Break">PowerShell script.</span></p>
			<p>Finally, we call the <strong class="source-inline">[Win32.User32]::MessageBoxA()</strong> function, passing the appropriate arguments as specified by the function signature. In our example, we pass in a <strong class="source-inline">null IntPtr</strong> handle to specify that the message box should not have a parent window. We then <a id="_idIndexMarker817"/>specify the message string, as well as the title, and a <strong class="source-inline">uint</strong> value to specify the buttons and icons to display in the message box. In this example, <strong class="source-inline">0</strong> indicates that the message box should only have an <span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break"> button.</span></p>
			<p>After <a id="_idIndexMarker818"/>executing, the defined message box opens and shows the message and title <span class="No-Break">as specified:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer134">
					<img alt="Figure 5.22 – Executing unmanaged code from PowerShell" src="image/B16679_05_022.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.22 – Executing unmanaged code from PowerShell</p>
			<p>Note that when using <strong class="source-inline">P/Invoke</strong>, it’s important to ensure that the function signature matches the actual function in the unmanaged DLL, including the correct parameter types, return type, and <span class="No-Break">calling convention.</span></p>
			<p>In this example, we called unmanaged code from <strong class="source-inline">user32.dll</strong>, which resulted in opening a message box. You might ask yourself how this differentiates from calling the <strong class="source-inline">MessageBox</strong> function in the <strong class="source-inline">System.Windows.Forms</strong> .<span class="No-Break">NET class.</span></p>
			<p>Some Win32 APIs have corresponding .NET APIs that almost literally do what we demonstrated here (such as <strong class="source-inline">System.Windows.Forms.MessageBox.Show()</strong>), but many do not. By using the <strong class="source-inline">P/Invoke</strong> method demonstrated in the example, you can call any function defined in an unmanaged DLL from PowerShell, while the .NET class is limited to a specific set of functions, <span class="No-Break">including </span><span class="No-Break"><strong class="source-inline">MessageBox</strong></span><span class="No-Break">.</span></p>
			<p>If you want to explore loading<a id="_idIndexMarker819"/> and executing unmanaged code<a id="_idIndexMarker820"/> further, a great resource is https://pinvoke.net/. It’s an invaluable resource to find and operate <strong class="source-inline">P/Invoke</strong> signatures, user-defined types, and other information related to working with <span class="No-Break">unmanaged code.</span></p>
			<p>For more <a id="_idIndexMarker821"/>examples of how you can use PowerShell to interact with the Windows API, also refer to the blog series <em class="italic">Use PowerShell to Interact with the Windows API</em>, <span class="No-Break"><em class="italic">Parts 1-3</em></span><span class="No-Break">:</span></p>
			<ul>
				<li><a href="https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-1/"><span class="No-Break">https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-1/</span></a></li>
				<li><a href="https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-2/"><span class="No-Break">https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-2/</span></a></li>
				<li><a href="https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-3/"><span class="No-Break">https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-3/</span></a></li>
			</ul>
			<p>After exploring .NET Framework and <strong class="source-inline">P/Invoke</strong>, it’s time to focus on another crucial technology in the Windows operating system: <span class="No-Break">the COM.</span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor134"/>Understanding the Component Object Model (COM) and COM hijacking</h1>
			<p>COM is a <a id="_idIndexMarker822"/>binary standard for software componentry introduced by Microsoft in 1993, which defines a set of rules for how software components interact with each other and allows inter-process communication. It was developed by Microsoft to address the need for interoperability <span class="No-Break">between applications.</span></p>
			<p>COM is the basis <a id="_idIndexMarker823"/>of <a id="_idIndexMarker824"/>many other technologies, such<a id="_idIndexMarker825"/> as <strong class="bold">OLE</strong>, <strong class="bold">COM+</strong>, <strong class="bold">DCOM</strong>, <strong class="bold">ActiveX</strong>, <strong class="bold">Windows User Interface</strong>, <strong class="bold">Windows Runtime</strong>, and <a id="_idIndexMarker826"/>many <a id="_idIndexMarker827"/>others. Basically, COM is just <a id="_idIndexMarker828"/>middleware that sits between two components and allows them to communicate with <span class="No-Break">each other.</span></p>
			<p>One example of how COM is used can be demonstrated with how <strong class="bold">Object Linking and Embedding</strong> (<strong class="bold">OLE</strong>) works: if <a id="_idIndexMarker829"/>you want to include, for example, an Excel table in your PowerPoint presentation. Usually, to allow this, without COM, PowerPoint would need to have the actual code <a id="_idIndexMarker830"/>implemented that makes Excel work how it works. But since this would be a waste of resources and redundant code, it does not make sense to duplicate the same code in two applications. Rather, it makes sense to point to the other application to include the functionality. And this is basically what OLE does: it just embeds an Excel object into PowerPoint and links to the <span class="No-Break">Excel functionality.</span></p>
			<p>COM is a technology based on <a id="_idIndexMarker831"/>the <strong class="bold">client-server model</strong>, where a client creates and uses a COM component within a server to access its functionality through interfaces. A <strong class="bold">COM server</strong> provides<a id="_idIndexMarker832"/> services to other components, known as <strong class="bold">COM clients</strong>, by exposing its functionality<a id="_idIndexMarker833"/> through related <em class="italic">methods</em> and <em class="italic">properties</em> in <strong class="bold">COM interfaces</strong>. These <a id="_idIndexMarker834"/>interfaces define a standardized way for clients to access the functionality of objects, regardless of the implementation language. COM servers can be <em class="italic">in-process</em> DLLs or <span class="No-Break"><em class="italic">out-of-process</em></span><span class="No-Break"> EXEs.</span></p>
			<p>A COM server is implemented as <a id="_idIndexMarker835"/>a <strong class="bold">COM class</strong>, which is a blueprint defining the behavior and functionality of a COM object. A COM class usually implements one or more interfaces and provides a set of <em class="italic">methods</em> and <em class="italic">properties</em> that clients can use. Each <a id="_idIndexMarker836"/>COM class is identified by a unique 128-bit <strong class="bold">globally unique identifier</strong> (<strong class="bold">GUID</strong>) called a <strong class="bold">CLSID</strong>, which<a id="_idIndexMarker837"/> the server must register. When a client requests an object from the server, COM uses this CLSID to locate the <em class="italic">DLL</em> or <em class="italic">EXE</em> containing the code that implements the class and creates an instance of <span class="No-Break">the object.</span></p>
			<p>These components can be used in PowerShell using the <strong class="source-inline">New-Object</strong> cmdlet, which allows you to instantiate COM objects and interact with them using their methods <span class="No-Break">and properties.</span></p>
			<p>In the following example, we use the <strong class="source-inline">New-Object</strong> cmdlet to create an instance of the <strong class="source-inline">Excel.Application</strong> COM object, which provides access to the Excel application and its functionality. We then use the instantiated object to create a new workbook, add a new worksheet, and write the string <strong class="source-inline">"Hello world!"</strong> to cell A1. Finally, we save the workbook and quit the <span class="No-Break">Excel application:</span></p>
			<pre class="source-code">
$excel = New-Object -ComObject Excel.Application
$workbook = $excel.Workbooks.Add()
$worksheet = $workbook.Worksheets.Item(1)
$worksheet.Cells.Item(1,1) = "Hello world!"
$workbook.SaveAs($env:TEMP + "\example.xlsx")
$excel.Quit()</pre>
			<p>Note that in order<a id="_idIndexMarker838"/> to use the Excel COM object, you need to have Excel installed on your computer. The Excel COM object provides a large number of methods and properties, so there’s a lot you can do with it beyond the preceding <span class="No-Break">simple example.</span></p>
			<p>It is also possible to use PowerShell to interact with COM components on remote machines <a id="_idIndexMarker839"/>using <strong class="bold">Distributed COM</strong> (<strong class="bold">DCOM</strong>). DCOM enables a client to connect to a COM component running on a remote machine and use its functionality as if it were on the <span class="No-Break">local machine.</span></p>
			<p>While COM provides a powerful framework for software components to communicate and interoperate, it also provides clear advantages to adversaries, including the fact that they don’t need to worry about network or security settings such as proxy or firewall rules. In most cases, everything is already <a id="_idIndexMarker840"/>set up for <strong class="bold">Internet Explorer</strong> (<strong class="bold">IE</strong>). Additionally, IE can be fully automated and instrumented to perform various actions such as navigating to a specific URL, downloading a file, or interacting with the form fields of an HTML document. Everything can also be easily hidden from the user, as a newly created IE window is invisible by default, and if the browser was already executed and has already been loaded into memory, one additional instance is relatively unsuspicious. For adversaries, COM opens up the potential for abuse and exploitation, as in the case of <span class="No-Break"><strong class="bold">COM hijacking</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor135"/>COM hijacking</h2>
			<p>Shared libraries<a id="_idIndexMarker841"/> such as DLLs allow multiple applications to share common code without duplicating it in memory, which reduces memory usage and prevents code duplication. Without shared libraries, each application would need to bring its own libraries, making programs larger and more memory-intensive. But this can also cause problems such<a id="_idIndexMarker842"/> as <strong class="bold">DLL hell</strong>, where different versions of the DLL are installed or used by different applications, leading to problems such as crashes or <span class="No-Break">security issues.</span></p>
			<p>COM solves DLL hell by using versioning. Each component has a unique identifier (CLSID) and a version identifier (<strong class="source-inline">ProgID</strong>), and each version is installed in a separate directory and registered in the Windows Registry. This allows multiple versions to coexist <span class="No-Break">without conflicts.</span></p>
			<p>But this versioning mechanism can also be exploited for COM hijacking. In this attack, an adversary first locates a CLSID that is used by another process but is not registered yet. They create a malicious DLL and place it on the victim system. Then, they create a registry key that links the CLSID to the malicious DLL. As the registry key is created in HKCU, there are not even administrator rights needed for <span class="No-Break">this operation.</span></p>
			<p>In the COM <a id="_idIndexMarker843"/>programming model, every interface implementation is required to include three fundamental methods: <strong class="source-inline">QueryInterface</strong>, <strong class="source-inline">AddRef</strong>, and <strong class="source-inline">Release</strong>. These methods are provided through the <strong class="source-inline">IUnknown</strong> interface, which is the base interface that all COM interfaces inherit from. The implementation of the <strong class="source-inline">IUnknown</strong> interface is mandatory for all <span class="No-Break">COM objects.</span></p>
			<p><strong class="source-inline">AddRef</strong> is used to increment the reference count of an object when a client is using it, and <strong class="source-inline">Release</strong> is used to decrement the reference count when the client is done with <span class="No-Break">the object.</span></p>
			<p><strong class="source-inline">QueryInterface</strong> obtains a pointer to a different interface that is supported by the COM object. In a COM hijacking attack, the attacker’s malicious DLL must implement the same interfaces as the legitimate COM component it is impersonating, including the <strong class="source-inline">IUnknown</strong> interface and any other <span class="No-Break">supported interfaces.</span></p>
			<p>When a legitimate application tries to instantiate the COM object (that pointed formerly to an abandoned key) and queries the <strong class="source-inline">IUnknown</strong> interface of the malicious DLL file, the <strong class="source-inline">QueryInterface</strong> method returns the pointers to the other interfaces that were implemented by the malicious DLL file, enabling the attacker to take control of the victim application. By knowing which exports a DLL provides, an attacker can better plan their attack and identify the specific COM object they want <span class="No-Break">to target.</span></p>
			<p>First, we need to identify which COM servers are missing CLSIDs and don’t require elevated privileges (HKCU). <strong class="bold">Process Monitor</strong> (<strong class="bold">procmon</strong>), which <a id="_idIndexMarker844"/>is part of the <strong class="source-inline">SysInternals</strong> suite, can help us achieve this goal. You can download it<a id="_idIndexMarker845"/> from <span class="No-Break">here: </span><a href="https://learn.microsoft.com/en-us/sysinternals/downloads/procmon"><span class="No-Break">https://learn.microsoft.com/en-us/sysinternals/downloads/procmon</span></a><span class="No-Break">.</span></p>
			<p>There are several registry keys that we can use to audit for <span class="No-Break">stale CLSIDs:</span></p>
			<ul>
				<li><strong class="source-inline">InprocServer</strong>/<strong class="source-inline">InprocServer32</strong>: This key specifies the path to the DLL that implements the in-process server. This is what we are using in <span class="No-Break">this example.</span></li>
				<li><strong class="source-inline">LocalServer</strong>/<strong class="source-inline">LocalServer32</strong>: This key defines the complete path to a local COM server application, regardless of its bitness <span class="No-Break">or architecture.</span></li>
				<li><strong class="source-inline">TreatAs</strong>: This registry key specifies the CLSID of a class capable of emulating the <span class="No-Break">current class.</span></li>
				<li><strong class="source-inline">ProgID</strong>: This key represents a human-readable string for a COM object to represent an underlying CLSID, making it easier for applications to reference a <span class="No-Break">COM object.</span></li>
			</ul>
			<p>As we are <a id="_idIndexMarker846"/>looking for a stale <strong class="source-inline">InprocServer32</strong> CLSID that can be accessed and changed by the current user, we are looking for unused but registered CLSIDs within the HKCU using the following <span class="No-Break">filter parameters:</span></p>
			<ul>
				<li><strong class="bold">Include</strong>: <strong class="bold">Operation</strong> | <strong class="bold">is</strong> | <span class="No-Break"><strong class="bold">RegOpenKey</strong></span></li>
				<li><strong class="bold">Include</strong>: <strong class="bold">Result</strong> | <strong class="bold">is</strong> | <strong class="bold">NAME </strong><span class="No-Break"><strong class="bold">NOT FOUND</strong></span></li>
				<li><strong class="bold">Include</strong>: <strong class="bold">Path</strong> | <strong class="bold">ends with</strong> | <span class="No-Break"><strong class="bold">InprocServer32</strong></span></li>
				<li><strong class="bold">Exclude</strong>: <strong class="bold">Path</strong> | <strong class="bold">begins with</strong> | <span class="No-Break"><strong class="bold">HKLM</strong></span></li>
			</ul>
			<p>Note that in this example, we are using a stale <strong class="source-inline">InprocServer32</strong> CLSID, but COM hijacking would also be possible by abusing <strong class="source-inline">InprocServer</strong>, <strong class="source-inline">LocalServer</strong>, <strong class="source-inline">LocalServer32</strong>, <strong class="source-inline">TreatAs</strong>, or <strong class="source-inline">ProgId</strong>, or by replacing an existing <span class="No-Break">COM object.</span></p>
			<p>The following screenshot shows how this Process Monitor filter <span class="No-Break">is configured:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer135">
					<img alt="Figure 5.23 – Filtering for stale CLSIDs in the HKCU hive" src="image/B16679_05_023.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.23 – Filtering for stale CLSIDs in the HKCU hive</p>
			<p>Capture the events<a id="_idIndexMarker847"/> for some time (for example, 5 minutes) to make sure that common activities <span class="No-Break">are captured.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer136">
					<img alt="Figure 5.24 – Capturing stale CLSIDs" src="image/B16679_05_024.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.24 – Capturing stale CLSIDs</p>
			<p>Now, you can examine the captured CLSIDs and find the one(s) that you want to use in your COM hijacking demo. In this example, we are using <strong class="source-inline">{CDC82860-468D-4d4e-B7E7-C298FF23AB2C}</strong>, which was queried <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">Explorer.exe</strong></span><span class="No-Break">.</span></p>
			<p>We then create a <strong class="source-inline">.dll</strong> file, <strong class="source-inline">COMHijack.dll</strong>. You can find the code to compile the file in the GitHub repository <span class="No-Break">under </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/COMHijack/COMHijack/dllmain.cpp"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/COMHijack/COMHijack/dllmain.cpp</span></a><span class="No-Break">.</span></p>
			<p>This code defines a <a id="_idIndexMarker848"/>Windows DLL that runs a new process to launch the Windows calculator, <strong class="source-inline">calc.exe</strong>, when it is loaded into memory. The DLL main function sets up a <strong class="source-inline">switch</strong> statement to handle different reasons for the DLL being loaded, and in the <strong class="source-inline">DLL_PROCESS_ATTACH</strong> case, it calls the <strong class="source-inline">CallCalculator</strong> function, which creates a new process to run the <span class="No-Break">Windows calculator.</span></p>
			<p>We compile <strong class="source-inline">COMHijack.dll</strong> and place it under <strong class="source-inline">${Env:\TEMP}</strong>. Then, we create a new registry key for <strong class="source-inline">{CDC82860-468D-4d4e-B7E7-C298FF23AB2C}\InprocSServer32</strong> and set the value of the default property to the location where <strong class="source-inline">COMHijack.dll</strong> was <span class="No-Break">placed earlier:</span></p>
			<pre class="source-code">
$COMPath = ${Env:\TEMP} + "\COMHijack.dll"
$CLSIDString = "{CDC82860-468D-4d4e-B7E7-C298FF23AB2C}"
$RegPath = "HKCU:\Software\Classes\CLSID\" + $CLSIDString + "\InprocServer32"
New-Item -Path $RegPath -Force
New-ItemProperty -Path $RegPath -Name "(Default)" -Value $COMPath -Force
New-ItemProperty -Path $RegPath -Name "ThreadingModel" -Value "Apartment" -Force</pre>
			<p>And now, whenever <strong class="source-inline">Explorer.exe</strong> is opened, <strong class="source-inline">calc.exe</strong> will start <span class="No-Break">as well.</span></p>
			<p>This is, of course, not the only way for COM hijacking; there are many more options to explore. If you want to learn more about COM hijacking, I highly recommend looking into the links on COM hijacking in the <em class="italic">Further reading</em> section of <span class="No-Break">this chapter.</span></p>
			<p>Another important component in the Windows operating system is the WMI. This component can be leveraged by both attackers and defenders – let’s explore it in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor136"/>Common Information Model (CIM)/WMI</h1>
			<p>We already learned in <a href="B16679_03_Final_PD.xhtml#_idTextAnchor064"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Exploring PowerShell Remote Management Technologies and PowerShell Remoting</em>, that WMI is Microsoft’s implementation of the <strong class="bold">CIM</strong>, and <a id="_idIndexMarker849"/>how to use WMI- or CIM-related <span class="No-Break">PowerShell cmdlets.</span></p>
			<p>In this chapter, we are exploring WMI a little bit further in the <span class="No-Break">system context.</span></p>
			<p>WMI is not a<a id="_idIndexMarker850"/> new technology, and WMI attacks are not a new attack vector. WMI only produces a small forensic footprint, runs in memory only, and is a great way to evade whitelisting as well as host-based security tools. Therefore, WMI has been weaponized in attacks in recent years like <span class="No-Break">never before.</span></p>
			<p>In general, applications such as PowerShell, .NET, C/C++, VBScript, and many more can access WMI through the WMI API. The <strong class="bold">CIM Object Manager</strong> (<strong class="bold">CIMOM</strong>) then manages the access <a id="_idIndexMarker851"/>between each WMI component. The communication relies <span class="No-Break">on COM/DCOM.</span></p>
			<p>The following figure demonstrates the <a id="_idIndexMarker852"/>architecture <span class="No-Break">of WMI:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer137">
					<img alt="Figure 5.25 – WMI architecture" src="image/B16679_05_025.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.25 – WMI architecture</p>
			<p>The <strong class="bold">WMI consumer</strong> (or the managing application) connects using the WMI API to the WMI <a id="_idIndexMarker853"/>infrastructure and the WMI service (<strong class="source-inline">Winmgmt</strong>). In this case, we are looking at PowerShell as the only management application, but of course, there are also other possibilities, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">wmic.exe</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="bold">WMI infrastructure</strong> acts <a id="_idIndexMarker854"/>as a mediator between the consumer, the providers, and managed objects. It consists of the CIM Core and the CIM repository. The WMI infrastructure is what keeps and connects everything within <span class="No-Break">WMI together.</span></p>
			<p>It supports various APIs, such as <a id="_idIndexMarker855"/>the <strong class="bold">WMI COM API</strong>, through which consumers can access WMI providers through the <span class="No-Break">WMI infrastructure.</span></p>
			<p>The CIM repository is a database that stores static information and is organized <span class="No-Break">within </span><span class="No-Break"><strong class="bold">namespaces</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor137"/>Namespaces</h2>
			<p>A namespace is a <a id="_idIndexMarker856"/>logical database whose purpose is to basically group sets of classes and instances that are related to a certain managed environment. A good example is the Registry provider, which groups all WMI classes and providers to operate the <span class="No-Break">Windows Registry.</span></p>
			<p>The namespace root directory is called <strong class="source-inline">ROOT</strong>. Within all WMI installations, there are always the four <em class="italic">default</em> WMI namespaces underneath <strong class="source-inline">ROOT</strong>: <strong class="source-inline">CIMV2</strong>, <strong class="source-inline">Default</strong>, <strong class="source-inline">Security</strong>, and <strong class="source-inline">WMI</strong>. Some of them have their <span class="No-Break">own sub-namespaces.</span></p>
			<p>The <strong class="source-inline">ROOT/cimv2</strong> namespace is the most interesting namespace, as almost all interesting CIM classes are stored in this namespace. If you query all classes using <strong class="source-inline">Get-CimClass</strong> without specifying a namespace, <strong class="source-inline">ROOT/cimv2</strong> is queried <span class="No-Break">by default.</span></p>
			<p>Some providers also define their own namespaces. This has the benefit for the developers that they don’t need to seek the permission of the owner of the namespace and can get rid of other restricting constraints <span class="No-Break">as well:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer138">
					<img alt="Figure 5.26 – Overview of some common namespaces" src="image/B16679_05_026.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.26 – Overview of some common namespaces</p>
			<p>Using the old WMI cmdlets, it was possible to enumerate all namespaces using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Recurse</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
&gt; Get-WmiObject __namespace -Namespace 'root' -List -Recurse | Format-Table __namespace</pre>
			<p>But let’s look at how you can perform operations using the new CIM cmdlets, which are also supported within PowerShell Core – the WMI cmdlets are not <span class="No-Break">supported anymore.</span></p>
			<p>To search one namespace, you can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">Get-CimInstance</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Get-CimInstance -ClassName __Namespace -Namespace 'root'</pre>
			<p>However, searching recursively is not possible using <strong class="source-inline">Get-CimInstance</strong>; this cmdlet does not offer a <strong class="source-inline">-recurse</strong> parameter. To search recursively using <strong class="source-inline">Get-CimInstance</strong>, I have written a little function, which you can find in the GitHub repository of this <span class="No-Break">book: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-CimNamespace.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-CimNamespace.ps1</span></a><span class="No-Break">.</span></p>
			<p>After loading the<a id="_idIndexMarker857"/> function, you can use it by calling it by its name, <strong class="source-inline">Get-CimNamespace</strong>. Using the <strong class="source-inline">-recurse</strong> parameter lets you query recursively, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer139">
					<img alt="Figure 5.27 – Querying all present namespaces recursively" src="image/B16679_05_027.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.27 – Querying all present namespaces recursively</p>
			<p>A namespace cannot work on its own; there’s always a managed object, managed by its <strong class="bold">provider</strong>, that’s registered to <span class="No-Break">a namespace.</span></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor138"/>Providers</h2>
			<p>A provider is<a id="_idIndexMarker858"/> the interface between WMI and a managed object. It acts <a id="_idIndexMarker859"/>on behalf of the managing application, supplies the CIMOM with data from the managed object, and generates <span class="No-Break">event notifications.</span></p>
			<p>A provider usually consists of the following classifications: classes, events, event consumers, instances, methods, <span class="No-Break">and properties.</span></p>
			<h3>Classes</h3>
			<p>Classes<a id="_idIndexMarker860"/> define and represent the general parameters <a id="_idIndexMarker861"/>of <strong class="bold">managed objects</strong>, which are provided by a provider. Usually, they are defined in<a id="_idIndexMarker862"/> a <strong class="bold">Managed Object </strong><span class="No-Break"><strong class="bold">Format</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">MOF</strong></span><span class="No-Break">).</span></p>
			<p>If you remember <a href="B16679_01_Final_PD.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chap</em></span><span class="No-Break"><em class="italic">ter 1</em></span></a><em class="italic">, Getting Started with PowerShell</em>, we also talked about classes in this chapter. But in this context, a class is specific <span class="No-Break">to WMI/CIM.</span></p>
			<p>Using the <strong class="source-inline">Get-CimClass</strong> cmdlet helps you to list all available classes in a specific namespace or to get more information about a certain class using the <strong class="source-inline">-ClassName</strong> parameter, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer140">
					<img alt="Figure 5.28 – Retrieving a CIM class in PowerShell Core" src="image/B16679_05_028.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.28 – Retrieving a CIM class in PowerShell Core</p>
			<p>By using the old <strong class="source-inline">Get-WMIObject</strong> cmdlet, you can query the <strong class="source-inline">meta_class</strong> table to get the same information as you did with <strong class="source-inline">Get-CimClass</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer141">
					<img alt="Figure 5.29 – Retrieving a WMI class in Windows PowerShell" src="image/B16679_05_029.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.29 – Retrieving a WMI class in Windows PowerShell</p>
			<p>Every class also defines methods and properties, which are similar to our example of object-oriented programming from <a href="B16679_01_Final_PD.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><em class="italic">, Getting Started with PowerShell</em>, but specific <span class="No-Break">to CIM/WMI:</span></p>
			<ul>
				<li><strong class="bold">Methods</strong>: They <a id="_idIndexMarker863"/>define how we can interact with <span class="No-Break">an object:</span><pre class="source-code">
(Get-CimClass -ClassName Win32_OperatingSystem).CimClassMethods</pre></li>
				<li><strong class="bold">Properties</strong>: They <a id="_idIndexMarker864"/>allow us to define an object in more detail, such as the build number or <span class="No-Break">version number:</span><pre class="source-code">
(Get-CimClass -ClassName Win32_OperatingSystem).CimClassProperties</pre></li>
			</ul>
			<p>In every<a id="_idIndexMarker865"/> namespace, you can find predefined classes, the <strong class="bold">WMI system classes</strong>. System classes <a id="_idIndexMarker866"/>are used to support WMI with activities such as event notification, event and provider registration, and various <span class="No-Break">security tasks.</span></p>
			<p>Compared to classes that are defined by a provider, system classes are not defined in MOF. You can find an overview of all predefined system classes in the official <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-system-classes"><span class="No-Break">https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-system-classes</span></a><span class="No-Break">.</span></p>
			<h3>Instance</h3>
			<p>We<a id="_idIndexMarker867"/> discussed in <a href="B16679_01_Final_PD.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Getting Started with PowerShell</em>, that an <strong class="bold">object</strong> is an <strong class="bold">instance</strong> of a <strong class="bold">class</strong> that contains <strong class="bold">properties</strong> and <strong class="bold">methods</strong>. Similarly, a <strong class="bold">CIM instance</strong> is a unique, individual <strong class="bold">object</strong> that contains <strong class="bold">properties</strong> and <strong class="bold">methods</strong> defined by a <span class="No-Break"><strong class="bold">CIM class</strong></span><span class="No-Break">.</span></p>
			<p>By using the <strong class="source-inline">Get-CimInstance</strong> cmdlet, you can query a specified CIM instance by specifying the <strong class="source-inline">-Class</strong> parameter. The following screenshot demonstrates how to query the <span class="No-Break"><strong class="source-inline">Win32_OperatingSystem</strong></span><span class="No-Break"> class:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer142">
					<img alt="Figure 5.30 – Retrieving a CIM instance in PowerShell Core" src="image/B16679_05_030.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.30 – Retrieving a CIM instance in PowerShell Core</p>
			<p>Alternatively, you can also query WMI using the <strong class="source-inline">-Query</strong> parameter, as shown in the <span class="No-Break">following example:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer143">
					<img alt="Figure 5.31 – Retrieving a CIM instance using a query" src="image/B16679_05_031.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.31 – Retrieving a CIM instance using a query</p>
			<p>If you <a id="_idIndexMarker868"/>compare the output with the output of the CIM classes, you can quickly spot the difference between a class and an instance: the class defines the instance, and the instance contains the values that are specific to the <span class="No-Break">current system.</span></p>
			<h3>Event</h3>
			<p>Events <a id="_idIndexMarker869"/>are generated by specific actions that occur on a system. While not all actions generate events, many important system activities do result in an event being raised and recorded in the event log. CIM contains its own event infrastructure: whenever changes happen in data or services, notifications <span class="No-Break">are generated.</span></p>
			<h4>Intrinsic events</h4>
			<p>Intrinsic events <a id="_idIndexMarker870"/>are related to WMI/CIM itself, such as a new CIM instance being created or when changes in the WMI/CIM infrastructure occur. These changes can trigger an <span class="No-Break">intrinsic event.</span></p>
			<p>You can find examples of intrinsic event classes using <strong class="source-inline">(Get-CimClass -ClassName "*Event").CimSystemProperties | Where-Object {$_.ClassName -like "__*"}</strong>, as depicted in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer144">
					<img alt="Figure 5.32 – Querying intrinsic event classes" src="image/B16679_05_032.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.32 – Querying intrinsic event classes</p>
			<p>Everything <a id="_idIndexMarker871"/>within WMI/CIM is represented as an object, therefore every event is also represented as an object and has its own class. This behavior is similar to extrinsic <span class="No-Break">WMI events.</span></p>
			<h4>Extrinsic events</h4>
			<p>Extrinsic events<a id="_idIndexMarker872"/> are generated by WMI providers in response to a change in the system state, such as the installation of new software or the modification of a system setting. For example, if the operating system is rebooted or if a registry key is changed, these events can be used by a provider to generate a <span class="No-Break">WMI/CIM event.</span></p>
			<p>Examples of extrinsic event classes can be found using <strong class="source-inline">(Get-CimClass).CimSystemProperties | Where-Object {($_.ClassName -notlike "__*") -and (($_.ClassName -like "*Event") -or ($_.ClassName -like "*Trace"))}</strong>, as depicted in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer145">
					<img alt="Figure 5.33 – Querying extrinsic event classes" src="image/B16679_05_033.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.33 – Querying extrinsic event classes</p>
			<p>A query like <a id="_idIndexMarker873"/>this helps in discovering event classes that can be used to monitor system changes. For instance, you can use these classes to create a script that creates a new event log entry when an event of interest <span class="No-Break">is triggered.</span></p>
			<h3>Event consumer</h3>
			<p>To support event<a id="_idIndexMarker874"/> notifications, event consumers can be used within a provider to map a physical consumer to a logical consumer. Consumers define what actions should be triggered if a certain <span class="No-Break">change occurred.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor139"/>Events subscriptions</h2>
			<p>Monitoring <a id="_idIndexMarker875"/>WMI/CIM events can help you, as a blue teamer, to<a id="_idIndexMarker876"/> detect changes that occurred on an operating system, but can also help red teamers who base their attacks on <span class="No-Break">certain actions.</span></p>
			<p>When working with WMI/CIM events for the first time, it might quickly feel overwhelming. To <a id="_idIndexMarker877"/>help you to better understand, let’s look first at the basic steps in a <span class="No-Break">simplified way</span></p>
			<ol>
				<li><strong class="bold">Create a WMI Query Language (WQL) query</strong>: Similar to querying data from WMI/CIM, you also need to create a query for the <span class="No-Break">event subscription.</span></li>
				<li><strong class="bold">Create an event filter</strong>: Once you have created a WQL query, you will need to create a filter, which then registers the query <span class="No-Break">in CIM.</span></li>
				<li><strong class="bold">Create a consumer</strong>: The consumer defines what action should be taken if an event filter returns that a change in a <span class="No-Break">class occurred.</span></li>
				<li><strong class="bold">Bind the event filter to the consumer</strong>: With this last step, we make the WMI/CIM event subscription work. By performing this step, the consumer will be notified every time the event filter received <span class="No-Break">a match.</span></li>
			</ol>
			<h3>Creating a WQL query</h3>
			<p>In the <a id="_idIndexMarker878"/>earlier <em class="italic">Classes</em> section, you learned that predefined system classes exist for different purposes. When it comes to WMI/CIM events, the following four system classes might be the most interesting <span class="No-Break">for you:</span></p>
			<ul>
				<li><strong class="source-inline">InstanceCreationEvent</strong>: Checks<a id="_idIndexMarker879"/> whether a new instance was created. For example, you can check whether a new process <span class="No-Break">was created.</span></li>
				<li><strong class="source-inline">InstanceDeletionEvent</strong>: Checks <a id="_idIndexMarker880"/>whether an instance was deleted. For example, you can check whether a process <span class="No-Break">was terminated.</span></li>
				<li><strong class="source-inline">InstanceModificationEvent</strong>: Checks <a id="_idIndexMarker881"/>whether an instance was modified. For example, you can check whether a registry key <span class="No-Break">was modified.</span></li>
				<li><strong class="source-inline">InstanceOperationEvent</strong>: Checks <a id="_idIndexMarker882"/>for all three types of events – whether an instance was created, deleted, <span class="No-Break">or modified.</span></li>
			</ul>
			<p>The following is an example of a WQL event subscription query. It will trigger if a Windows service <span class="No-Break">was terminated:</span></p>
			<pre class="source-code">
Select * from __InstanceDeletionEvent within 15 where TargetInstance ISA 'Win32_Service'</pre>
			<p>Using this example, you can get a brief understanding of what such a query would <span class="No-Break">look like:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer146">
					<img alt="Figure 5.34 – The structure of a WQL event subscription query" src="image/B16679_05_034.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.34 – The structure of a WQL event subscription query</p>
			<p>The first <a id="_idIndexMarker883"/>part specifies where to look – in this case, <strong class="source-inline">InstanceDeletionEvents</strong>. The checking cycle specifies the polling interval in seconds of this query, indicated by the keyword <strong class="source-inline">within</strong>. In this example, the query runs every <span class="No-Break">15 seconds.</span></p>
			<p>In an event subscription query, conditions are not mandatory, but they can be useful in specifying and narrowing down the results. Conditions are indicated by <strong class="source-inline">where</strong>, similar to regular WQL or <span class="No-Break">SQL queries.</span></p>
			<p>It is also possible to specify multiple conditions, which are attached to the query by using <strong class="source-inline">AND</strong> or <strong class="source-inline">OR</strong>. If we, for example, want to check and act on the event that Microsoft Defender was terminated, the query would look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Select * from __InstanceDeletionEvent within 15 where TargetInstance ISA 'Win32_Service' AND Targetinstance.name='windefend'</pre>
			<p>In summary, using conditions in event subscription queries can help narrow down the results and enable targeted actions to be taken in response to <span class="No-Break">specific events.</span></p>
			<h3>Creating an event filter</h3>
			<p>Now it’s time <a id="_idIndexMarker884"/>to create our event filter. This can be done by using the <strong class="source-inline">New-CimInstance</strong> cmdlet, which creates a new instance of the <strong class="source-inline">__EventFilter</strong> <span class="No-Break">CIM class.</span></p>
			<p>Let’s use the WQL query that we just created and use it to create an event filter, as in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
$query = "Select * from __InstanceDeletionEvent within 15 where TargetInstance ISA 'Win32_Service' AND Targetinstance.name='windefend'"
$CimEventDefenderFilter = @{
    Name = "MicrosoftDefenderFilter";
    Query = $query;
    QueryLanguage = "WQL";
    EventNamespace = "\root\cimv2";
};
$CimEventDefenderInstance=New-CimInstance -ClassName __EventFilter -Namespace "Root/SubScription" -Property $CimEventDefenderFilter</pre>
			<p>To create an <a id="_idIndexMarker885"/>event filter, we need to define the properties, which is done in the <strong class="source-inline">$CimEventDefenderFilter</strong> hashtable. The instance is given the name <strong class="source-inline">MicrosoftDefenderFilter</strong> via the <strong class="source-inline">Name</strong> parameter. The query created earlier is assigned to the <strong class="source-inline">$query</strong> variable and then passed to the <strong class="source-inline">$CimEventDefenderFilter</strong> property’s <strong class="source-inline">Query</strong> parameter. The <strong class="source-inline">QueryLanguage</strong> parameter is set to <strong class="source-inline">WQL</strong> to indicate that the query is written in the WMI Query Language. Finally, the <strong class="source-inline">EventNamespace</strong> parameter specifies the namespace where the event filter will be registered, which, in this case, <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">\root\cimv2</strong></span><span class="No-Break">.</span></p>
			<p>Finally, a new CIM instance is created in the <strong class="source-inline">Root/SubScription</strong> namespace, using the <strong class="source-inline">__EventFilter</strong> class, to indicate that we are creating an event filter. The properties of this instance are set to the values in the hashtable of the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">CimEventDefenderFilter</strong></span><span class="No-Break"> variable.</span></p>
			<p>You can verify that the filter was created using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -Namespace root/subscription -ClassName __EventFilter</pre>
			<p>The following screenshot displays what it looks like when the event filter is <span class="No-Break">successfully created:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer147">
					<img alt="Figure 5.35 – Verifying that the filter was created" src="image/B16679_05_035.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.35 – Verifying that the filter was created</p>
			<p>As a next step, we <a id="_idIndexMarker886"/>will need to create <span class="No-Break">a consumer.</span></p>
			<h3>Creating a consumer</h3>
			<p>In WMI/CIM event<a id="_idIndexMarker887"/> subscriptions, a consumer is used to define what action should be taken when an event filter receives a match. There are several types of consumers available, each with its <span class="No-Break">own properties:</span></p>
			<ul>
				<li><strong class="source-inline">ActiveScriptEventConsumer</strong>: This<a id="_idIndexMarker888"/> consumer executes a script when an <span class="No-Break">event occurs.</span></li>
				<li><strong class="source-inline">CommandLineEventConsumer</strong>: This <a id="_idIndexMarker889"/>consumer starts a process when an event occurs. Please verify <a id="_idIndexMarker890"/>the <strong class="bold">access control list</strong> (<strong class="bold">ACL</strong>) of the <strong class="source-inline">.exe</strong> file, so that adversaries are prevented from replacing the <strong class="source-inline">.exe</strong> file with a <span class="No-Break">malicious file.</span></li>
				<li><strong class="source-inline">LogFileEventConsumer</strong>: This<a id="_idIndexMarker891"/> consumer creates a text log when an <span class="No-Break">event occurs.</span></li>
				<li><strong class="source-inline">NTEventLogEventConsumer</strong>: This<a id="_idIndexMarker892"/> consumer logs an event to the Windows event log when an <span class="No-Break">event occurs.</span></li>
				<li><strong class="source-inline">SMTPEventConsumer</strong>: This <a id="_idIndexMarker893"/>consumer sends an email when an <span class="No-Break">event occurs.</span></li>
			</ul>
			<p>Every consumer has its own properties, so make sure to check its properties before you <span class="No-Break">define them.</span></p>
			<p>The following<a id="_idIndexMarker894"/> example demonstrates how to configure a consumer that logs an event every time the Microsoft Defender service <span class="No-Break">is terminated:</span></p>
			<pre class="source-code">
$Message = @("%Targetinstance.Name% has been terminated on $env:computername. Current Status: %TargetInstance.Status%")
$CimDefenderConsumerProperties = @{
    Name = 'Windows Defender Service (windefend) was terminated';
    MachineName = $env:computername;
    EventID = [uint32]12345;
    EventType = [uint32]2;
    SourceName = 'Application';
    NumberOfInsertionStrings = [uint32]1;
    InsertionStringTemplates = $Message
    Category= [uint16]123;
}
$CimDefenderEventConsumer = New-CimInstance -ClassName NTEventLogEventConsumer -Namespace 'ROOT/subscription' -Property $CimDefenderConsumerProperties</pre>
			<p>The <strong class="source-inline">$Message</strong> variable defines the body of the event log message, which includes the name and status of the terminated service. The <strong class="source-inline">$CimDefenderConsumerProperties</strong> variable defines the properties of <strong class="source-inline">NTEventLogEventConsumer</strong>, such as the machine name (<strong class="source-inline">MachineName</strong>), event ID (<strong class="source-inline">EventID</strong>), event type (<strong class="source-inline">EventType</strong>), the name of the event log in which the event should be logged (<strong class="source-inline">SourceName = 'Application'</strong>), and the message of the event itself (<strong class="source-inline">InsertionStringTemplates</strong>). <strong class="source-inline">NumberOfInsertionStrings</strong> specifies the number of insertion strings that will be used in the <span class="No-Break">event message.</span></p>
			<p>In this case, <strong class="source-inline">EventType</strong> specifies that a warning (<strong class="source-inline">2</strong>) should be logged. Here’s an overview of all possible <span class="No-Break">event types:</span></p>
			<ul>
				<li><strong class="source-inline">0</strong>: <span class="No-Break">Successful event</span></li>
				<li><strong class="source-inline">1</strong>: <span class="No-Break">Error event</span></li>
				<li><strong class="source-inline">2</strong>: <span class="No-Break">Warning event</span></li>
				<li><strong class="source-inline">4</strong>: <span class="No-Break">Information event</span></li>
				<li><strong class="source-inline">8</strong>: Success <span class="No-Break">audit type</span></li>
				<li><strong class="source-inline">16</strong>: Failure <span class="No-Break">audit type</span></li>
			</ul>
			<p>Finally, the <strong class="source-inline">New-CimInstance</strong> cmdlet creates <span class="No-Break">the consumer.</span></p>
			<p>Use the <strong class="source-inline">Get-CimInstance</strong> cmdlet <a id="_idIndexMarker895"/>to verify that it was <span class="No-Break">created successfully:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -Namespace Root/Subscription -ClassName SMTPEventConsumer</pre>
			<h3>Binding the event filter to the consumer</h3>
			<p>Finally, we <a id="_idIndexMarker896"/>will bind the event filter to the consumer in order to make the WMI/CIM event subscription work. Binding an event filter to a consumer ensures that the consumer will be notified every time the event filter receives <span class="No-Break">a match.</span></p>
			<p>After creating an event filter and a consumer, the final step is to bind them together. This can be done by creating an instance of the <strong class="source-inline">__FilterToConsumerBinding</strong> class. This class defines a relationship between the event filter and <span class="No-Break">the consumer.</span></p>
			<p>The following example demonstrates how to create a binding instance between the event filter and the SMTP event consumer created in the <span class="No-Break">previous example:</span></p>
			<pre class="source-code">
$CimDefenderBindingProperties=@{
    Filter = [Ref]$CimEventDefenderInstance
    Consumer = [Ref]$CimDefenderEventConsumer
}
$CimDefenderBinding = New-CimInstance -ClassName __FilterToConsumerBinding -Namespace "root/subscription" -Property $CimDefenderBindingProperties</pre>
			<p>In this example, we are using the <strong class="source-inline">New-CimInstance</strong> cmdlet to create a new instance of the <strong class="source-inline">__FilterToConsumerBinding</strong> class. We pass the event filter and consumer instances as references to the <strong class="source-inline">Filter</strong> and <strong class="source-inline">Consumer</strong> properties of the <span class="No-Break">binding instance.</span></p>
			<p>Finally, we <a id="_idIndexMarker897"/>can verify that the binding was created by using the <strong class="source-inline">Get-CimInstance</strong> cmdlet, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -Namespace root/Subscription -ClassName __FilterToConsumerBinding</pre>
			<p>This will return all instances of the <strong class="source-inline">__FilterToConsumerBinding</strong> class in the <strong class="source-inline">root/subscription</strong> namespace, including the instance that we <span class="No-Break">just created.</span></p>
			<h3>Removing a CIM instance</h3>
			<p>If you want to remove <a id="_idIndexMarker898"/>any CIM instance that you created, you can use the <span class="No-Break"><strong class="source-inline">Remove-CimInstance</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -Namespace 'ROOT/subscription' -ClassName __EventFilter -Filter "name='MicrosoftDefenderFilter'" | Remove-CimInstance</pre>
			<p>The preceding code snippet removes the event filter CIM instance, <strong class="source-inline">'MicrosoftDefenderFilter'</strong>, which we <span class="No-Break">created earlier.</span></p>
			<p>The following <a id="_idIndexMarker899"/>command removes the event log consumer CIM instance with the name <strong class="source-inline">'Windows Defender Service (windefend) </strong><span class="No-Break"><strong class="source-inline">was terminated'</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -Namespace 'ROOT/subscription' -ClassName NTEventLogEventConsumer -Filter "name='Windows Defender Service (windefend) was terminated'" | Remove-CimInstance</pre>
			<p>And last but not least, to remove the CIM instance that is responsible for binding the event filter to the consumer, run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -Namespace 'ROOT/subscription' -ClassName __FilterToConsumerBinding -Filter "Filter = ""__eventfilter.name='MicrosoftDefenderFilter'""" | Remove-CimInstance</pre>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor140"/>Monitor WMI/CIM event subscriptions</h2>
			<p>You can detect and<a id="_idIndexMarker900"/> monitor WMI/CIM event-related activity by using both the Windows event log <span class="No-Break">and Sysmon.</span></p>
			<p>When using the Windows <a id="_idIndexMarker901"/>event log, you can use the operational WMI activity log to track <span class="No-Break">WMI/CIM-related events:</span></p>
			<ul>
				<li><strong class="bold">Full </strong><span class="No-Break"><strong class="bold">Name</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">Microsoft-Windows-WMI-Activity/Operational</strong></span></li>
				<li><strong class="bold">Log </strong><span class="No-Break"><strong class="bold">path</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-WMI-Activity%4Operational.evtx</strong></span></li>
				<li><strong class="bold">Path in the UI</strong>: <strong class="bold">Applications and Services</strong> | <strong class="bold">Microsoft</strong> | <strong class="bold">Windows</strong> | <strong class="bold">WMI Activity</strong> | <span class="No-Break"><strong class="bold">Operational</strong></span></li>
			</ul>
			<p>The <em class="italic">most interesting event IDs</em> in this <a id="_idIndexMarker902"/>event log for PowerShell security logging are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Event ID 5857</strong>: Provider started with result code. This event shows <span class="No-Break">provider loading.</span></li>
				<li><strong class="bold">Event ID 5858</strong>: Error message. This event typically triggers for <span class="No-Break">query errors.</span></li>
				<li><strong class="bold">Event ID 5859</strong>: This event indicates that a permanent event filter <span class="No-Break">was started.</span></li>
				<li><strong class="bold">Event ID 5860</strong>: A temporary event consumer was registered <span class="No-Break">or started.</span></li>
				<li><strong class="bold">Event ID 5861</strong>: A permanent event consumer binding <span class="No-Break">was registered.</span></li>
			</ul>
			<p>Some <a id="_idIndexMarker903"/>of the <a id="_idIndexMarker904"/>WMI activity events can be extremely noisy, so ensure to filter accordingly to your environment and your needs. Event IDs <em class="italic">5859</em>, <em class="italic">5860</em>, and <em class="italic">5861</em> can especially help you to find <span class="No-Break">malicious activity.</span></p>
			<p>Another great resource if you want to learn more about tracking WMI activity using the Windows event log is the following blog article written by Carlos <span class="No-Break">Perez: </span><a href="https://www.darkoperator.com/blog/2017/10/14/basics-of-tracking-wmi-activity"><span class="No-Break">https://www.darkoperator.com/blog/2017/10/14/basics-of-tracking-wmi-activity</span></a><span class="No-Break">.</span></p>
			<p><strong class="bold">Sysmon</strong> provides <a id="_idIndexMarker905"/>capabilities to monitor whenever an event filter or consumer is registered or when a consumer binds to <span class="No-Break">a filter:</span></p>
			<ul>
				<li><strong class="bold">Event ID 19</strong>: Logs the WMI namespace, filter name, and filter expression when a WMI event filter is registered. Malware can use this method to <span class="No-Break">execute code.</span></li>
				<li><strong class="bold">Event ID 20</strong>: Logs the registration of WMI consumers, including the consumer name, log, <span class="No-Break">and destination.</span></li>
				<li><strong class="bold">Event ID 21</strong>: Logs the consumer name and filter path when a consumer binds to a filter. This can help identify which consumer is receiving events from a <span class="No-Break">specific filter.</span></li>
			</ul>
			<p>Sysmon is a little less noisy than the Windows WMI activity event log, but you will need to install it first on the systems that you want to monitor, so it has its up- as well as <span class="No-Break">its downsides.</span></p>
			<p>For monitoring WMI activities <em class="italic">in general</em> – regardless of whether you use Windows event logs or Sysmon – look for new event filters and bindings being registered and filter out known good filters <span class="No-Break">and bindings.</span></p>
			<p>Monitor the use of <strong class="source-inline">wmic.exe</strong> – look especially for the <strong class="source-inline">'process call create'</strong> argument. Observe the use of <strong class="source-inline">winrm.exe</strong> for lateral movement, and investigate whether <strong class="source-inline">mofcomp.exe</strong> was used to compile a new provider. Look for the creation of <strong class="bold">MOF</strong> files in <a id="_idIndexMarker906"/>unusual directories. And<a id="_idIndexMarker907"/> monitor the child processes of <strong class="source-inline">WmiPrvse.exe</strong>, as they could indicate an instantiation of processes <span class="No-Break">through WMI.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor141"/>Manipulating CIM instances</h2>
			<p>CIM instances <a id="_idIndexMarker908"/>provide a standardized way of representing managed resources in a system, allowing users to interact with these resources in a unified way. But CIM instances can also be manipulated. In such cases, the <strong class="source-inline">Set-CimInstance</strong> cmdlet can be used to modify one or more properties of a <span class="No-Break">CIM instance.</span></p>
			<p>It is not possible to manipulate all CIM instances; they need to be writable. To find out which properties are writable, you can use the following script, which was inspired by <span class="No-Break">Trevor Sullivan:</span></p>
			<pre class="source-code">
$WritableCimProperties = foreach ($Class in Get-CimClass) {
    foreach ($Property in $Class.CimClassProperties) {
        if ($Property.Qualifiers.Name -contains 'Write') {
            [PSCustomObject]@{
                CimClassName = $Class.CimClassName
                PropertyName = $Property.Name
                Write = $true
            }
        }
    }
}
$WritableCimProperties</pre>
			<p>Once you find a property that can be written to that you want to manipulate, you can alter it <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Set-CimInstance</strong></span><span class="No-Break">.</span></p>
			<p>The following example demonstrates how you could use CIM to enable a disabled user account <span class="No-Break">with PowerShell:</span></p>
			<pre class="source-code">
$UserAccount = Get-CimInstance -ClassName Win32_UserAccount -Filter "Name LIKE 'vicvega%'"
$UserAccount.Disabled = $false
Set-CimInstance -InputObject $UserAccount</pre>
			<p>First, you can use the <strong class="source-inline">Get-CimInstance</strong> cmdlet to retrieve the instance of the <strong class="source-inline">Win32_UserAccount</strong> class that matches the specified filter criteria. In this case, we are searching for a user account whose name starts <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">vicvega</strong></span><span class="No-Break">.</span></p>
			<p>Then, you <a id="_idIndexMarker909"/>can modify the <strong class="source-inline">Disabled</strong> property of the retrieved user account instance to set it to <strong class="source-inline">$false</strong>. Finally, you can use the <strong class="source-inline">Set-CimInstance</strong> cmdlet to save the updated user account instance to the <span class="No-Break">CIM repository.</span></p>
			<p>Use the following command to verify that the updated user account instance was <span class="No-Break">saved successfully:</span></p>
			<pre class="source-code">
&gt; (Get-CimInstance -ClassName Win32_UserAccount -Filter "Name LIKE 'vicvega%'").Disabled</pre>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor142"/>Enumeration</h2>
			<p>WMI<a id="_idIndexMarker910"/> uses a subset of SQL, called <strong class="bold">WMI Query Language</strong> (<strong class="bold">WQL</strong>). WQL <a id="_idIndexMarker911"/>only supports a subset of commands, which are <a id="_idIndexMarker912"/>documented <span class="No-Break">here: </span><a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi"><span class="No-Break">https://docs.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi</span></a><span class="No-Break">.</span></p>
			<p>There are different types of queries – data, event, and schema queries. In this book, we will mostly concentrate on the most commonly used ones: <span class="No-Break">data queries.</span></p>
			<p>If you want to learn more about the other query types, I recommend referring to the official <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/querying-with-wql"><span class="No-Break">https://docs.microsoft.com/en-us/windows/win32/wmisdk/querying-with-wql</span></a><span class="No-Break">.</span></p>
			<p>A data query simply serves the purpose to retrieve data – for example, about class instances or <span class="No-Break">data associations.</span></p>
			<p>To query a class, you can either use WQL or query the class by its class name. So, for example, to query a group with the name <strong class="source-inline">Administrators</strong>, you can either query the class and then filter using PowerShell or use WQL and filter using <span class="No-Break">the query.</span></p>
			<p>Here is an example of querying the class and using PowerShell <span class="No-Break">to filter:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -ClassName win32_group -filter "name='Administrators'"</pre>
			<p>And this shows you how to query and filter <span class="No-Break">using WQL:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -Query "select * from win32_group where name = 'Administrators'"</pre>
			<p>Both methods <a id="_idIndexMarker913"/>will result in the <span class="No-Break">same output:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer148">
					<img alt="Figure 5.36 – Querying using different methods" src="image/B16679_05_036.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.36 – Querying using different methods</p>
			<p class="callout-heading">Did You Know?</p>
			<p class="callout">If you have the chance, you should always prefilter using WQL as that increases the performance of your queries. If you first query and then filter using PowerShell, it takes longer to calculate <span class="No-Break">the results.</span></p>
			<p>In this section, I will provide you with some examples of enumeration using CIM/WMI. You can adjust them to your needs or improve your <span class="No-Break">existing detections.</span></p>
			<p>Enumerate processes using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -ClassName win32_process</pre>
			<p>Using <strong class="source-inline">Get-CimInstance</strong> does not only retrieve information about processes but you can also use WMI to display the <strong class="source-inline">CommandLine</strong> property that is not available in the default .NET <span class="No-Break">output objects:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -ClassName win32_process | Select-Object ProcessId, Name, CommandLine</pre>
			<p>Use the following command to enumerate existing <span class="No-Break">user accounts:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -Query "select * from win32_useraccount" | Select-Object -Property *</pre>
			<p>By using WMI to<a id="_idIndexMarker914"/> enumerate users, you can not only enumerate local users but also domain users will be enumerated while executing one <span class="No-Break">single command.</span></p>
			<p>WMI also provides a huge advantage for red teamers: if you would be using PowerShell only, you would need to install the <strong class="source-inline">ActiveDirectory</strong> module to query domain users. By using WMI, you can simply enumerate all domain users if the computer on which you are executing commands <span class="No-Break">is domain-joined.</span></p>
			<p>Additionally to other properties, <strong class="source-inline">Get-CimInstance</strong> also returns the <strong class="source-inline">AccountType</strong> property, which indicates whether the account is a <em class="italic">normal account</em> (<strong class="source-inline">512</strong>), a <em class="italic">workstation account</em> (<strong class="source-inline">4096</strong>), or, for example, even the account of a backup domain controller (<em class="italic">server trust account</em>, <strong class="source-inline">8192</strong>). The number <strong class="source-inline">256</strong> would indicate that it’s a <em class="italic">temporary duplicate account</em>, while the number <strong class="source-inline">2048</strong> indicates an <em class="italic">interdomain </em><span class="No-Break"><em class="italic">trust account</em></span><span class="No-Break">.</span></p>
			<p>You can enumerate local groups and group members <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -Query "select * from win32_group"
&gt; Get-CimInstance -Query "select * from win32_groupuser"</pre>
			<p>Again, similar to the <strong class="source-inline">win32_useraccount</strong> table, <strong class="source-inline">win32_group</strong> and <strong class="source-inline">win32_groupuser</strong> are referring to both local and <span class="No-Break">domain groups.</span></p>
			<p>WMI and CIM understand relationships between different instances, so you can even combine tables to find out which accounts are members of the local administrators. The <strong class="source-inline">Get-CimAssociatedInstance</strong> cmdlet allows you to get related objects that are linked <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">-InputObject</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; $group = Get-CimInstance -ClassName win32_group -filter "name='Administrators'"
&gt; Get-CimAssociatedInstance -InputObject $group -ResultClassName Win32_UserAccount</pre>
			<p>To get more information about currently installed hotfixes and updates, you can query the <span class="No-Break"><strong class="source-inline">win32_quickfixengineering</strong></span><span class="No-Break"> table:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -Query "select * from win32_quickfixengineering"</pre>
			<p>Find out which processes, programs, or scripts are configured to run when the operating system starts by <a id="_idIndexMarker915"/>querying the <span class="No-Break"><strong class="source-inline">Win32_StartupCommand</strong></span><span class="No-Break"> instance:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -Query "select * from Win32_StartupCommand"</pre>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor143"/>Where is the WMI/CIM database located?</h2>
			<p>And by the <a id="_idIndexMarker916"/>way, if you have always wondered where WMI is actually located on a Windows system, the WMI database itself can be found <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">$Env:windir\System32\wbem\Repository</strong></span><span class="No-Break">.</span></p>
			<p>The following screenshot displays the context of <span class="No-Break">this folder.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer149">
					<img alt="Figure 5.37 – WMI database" src="image/B16679_05_037.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.37 – WMI database</p>
			<p>Here, you can usually find the <span class="No-Break">following files:</span></p>
			<ul>
				<li><strong class="source-inline">INDEX.BTR</strong> (“binary <span class="No-Break">tree index”):</span></li>
			</ul>
			<p>The index of all managed objects that were imported <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">OBJECTS.DATA</strong></span><span class="No-Break">.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">OBJECTS.DATA</strong></span><span class="No-Break">:</span></li>
			</ul>
			<p>All objects that are managed <span class="No-Break">by WMI.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">MAPPING[1-3].MAP</strong></span><span class="No-Break">:</span></li>
			</ul>
			<p>Correlates data between <strong class="source-inline">INDEX.BTW</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">OBJECTS.DATA</strong></span><span class="No-Break">.</span></p>
			<p>Now that we have covered the importance of monitoring and manipulating WMI for security purposes, it’s time to move on to another topic: while some individuals may believe that PowerShell is a security threat and advocate for blocking <strong class="source-inline">powershell.exe</strong>, attackers can still find ways to run PowerShell even if <strong class="source-inline">powershell.exe</strong> is <a id="_idIndexMarker917"/>prevented from being executed. In the following section, we will explore how this can <span class="No-Break">be achieved.</span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor144"/>Running PowerShell without powershell.exe</h1>
			<p>To execute<a id="_idIndexMarker918"/> PowerShell commands, you usually first start <strong class="source-inline">powershell.exe</strong>. But there may be situations where running PowerShell in a traditional manner is not possible <span class="No-Break">or allowed.</span></p>
			<p>In those cases, PowerShell can still be run by using other <a id="_idIndexMarker919"/>means, such as through <strong class="bold">Windows Script Host</strong> (<strong class="bold">WSH</strong>), WMI, .NET Framework, <span class="No-Break">or more.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor145"/>Using “living off the land” binaries to call assembly functions</h2>
			<p>The<a id="_idIndexMarker920"/> term <strong class="bold">LOLbin</strong> is short for <strong class="bold">living off the land binaries</strong> and was coined by malware <a id="_idIndexMarker921"/>researchers Christopher Campbell and Matt Graeber at DerbyCon 3 in 2013. In a Twitter discussion on what to call those binaries that can be abused to run malicious code, the term <em class="italic">LOLBins</em> came up for the first time and a (highly scientific) Twitter poll made the terms <em class="italic">LOLBins</em> and <em class="italic">LOLScripts</em> official within <span class="No-Break">the community.</span></p>
			<p>A LOLbin refers to legitimate, pre-installed system binaries or applications that can be abused by attackers to carry out malicious activities on a compromised system. Attackers use these LOLbins as part of their <strong class="bold">tactics, techniques, and procedures</strong> (<strong class="bold">TTPs</strong>) to evade <a id="_idIndexMarker922"/>detection by security solutions since these binaries are typically considered safe and allowed to execute on <span class="No-Break">the system.</span></p>
			<p>Basically, PowerShell is also considered a LOLbin, as PowerShell was added as a legitimate admin tool. But thankfully for blue teamers, PowerShell provides many possibilities to not only monitor but to also restrict the usage to preconfigured use cases, as well as users. Other examples of legitimate admin tools that could also serve as a LOLbin are <strong class="source-inline">cmd</strong>, <strong class="bold">WMI</strong>, <strong class="source-inline">regsvr32.exe</strong>, <strong class="source-inline">rundll32.exe</strong>, <strong class="source-inline">mshta.exe</strong>, <strong class="source-inline">certutil.exe</strong>, <strong class="source-inline">wmic.exe</strong>, <strong class="source-inline">msbuild.exe</strong>, <strong class="source-inline">installutil.exe</strong>, <strong class="source-inline">regsvcs.exe</strong>, <strong class="source-inline">regasm.exe</strong>, <strong class="source-inline">PSExec.exe</strong>, <span class="No-Break">and others.</span></p>
			<p><strong class="source-inline">PSExec.exe</strong> is a <a id="_idIndexMarker923"/>great example of a LOLbin: while many administrators are still using it for administrative tasks, adversaries also happen to find this tool very useful. Especially when it comes to passing the hash and lateral movement, attackers love <span class="No-Break">this tool.</span></p>
			<p>Sometimes, LOLbins are also simply used for obfuscation to invoke actions in a way that defenders might overlook when monitoring their systems – such as, for example, <strong class="source-inline">rundll.exe</strong>; this <a id="_idIndexMarker924"/>executable can load and run 32-bit DLLs and execute functions. Note that it can only execute functions that were explicitly written to run <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">rundll32.exe</strong></span><span class="No-Break">.</span></p>
			<p>If you know how to <a id="_idIndexMarker925"/>write DLLs using C/C++/C#, <strong class="source-inline">rundll32.exe</strong> can run self-created DLLs – an ability that attackers can also profit from to run their own DLLs and bypass <span class="No-Break">software restrictions.</span></p>
			<p>Since writing <a id="_idIndexMarker926"/>your own DLLs in C/C++/C# could fill an entire book itself, we won’t concentrate in detail on how to create a DLL in this book. In our next example, we will use an already existing <span class="No-Break">DLL, </span><span class="No-Break"><strong class="source-inline">PowerShdll.dll</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">PowerShdll.dll</strong> was<a id="_idIndexMarker927"/> written and released by the GitHub user <span class="No-Break"><em class="italic">p3nt4</em></span><span class="No-Break">: </span><a href="https://github.com/p3nt4/PowerShdll"><span class="No-Break">https://github.com/p3nt4/PowerShdll</span></a><span class="No-Break">.</span></p>
			<p>Once downloaded, you can simply use <strong class="source-inline">rundll32</strong> or another LOLbin that is supported by <strong class="source-inline">PowerShdll</strong> and execute the following command <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">cmd</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; rundll32 PowerShdll,main Get-Process</pre>
			<p>Et voilà – the <strong class="source-inline">Get-Process</strong> cmdlet is executed from <strong class="source-inline">cmd</strong> without ever touching <strong class="source-inline">powershell.exe</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer150">
					<img alt="Figure 5.38 – Executing PowerShell commands through PowerShdll and rundll32 from cmd" src="image/B16679_05_038.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.38 – Executing PowerShell commands through PowerShdll and rundll32 from cmd</p>
			<p>There are also other <a id="_idIndexMarker928"/>projects similar to <strong class="source-inline">PowerShdll</strong> that can be used by red teamers or adversaries, such as <strong class="source-inline">NoPowerShell</strong>, <strong class="source-inline">PowerLessShell</strong>, <strong class="source-inline">p0wnedShell</strong>, and <span class="No-Break">many others.</span></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor146"/>Binary executables</h2>
			<p>There <a id="_idIndexMarker929"/>are also projects such as <strong class="source-inline">NotPowerShell</strong> (<strong class="source-inline">nps.exe</strong>) that let you run PowerShell from its own <span class="No-Break">compiled binaries:</span></p>
			<pre class="source-code">
&gt; nps.exe <strong class="bold">&lt;powershell single command&gt;</strong></pre>
			<p>You can find the <strong class="source-inline">NoPowerShell</strong> project on <span class="No-Break">GitHub: </span><a href="https://github.com/Ben0xA/nps"><span class="No-Break">https://github.com/Ben0xA/nps</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor147"/>Executing PowerShell from .NET Framework using C#</h2>
			<p>One way <a id="_idIndexMarker930"/>to run PowerShell without <strong class="source-inline">powershell.exe</strong> is by using .NET Framework. This can be done by creating a C# console application in Visual Studio with the code that is available in this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05/RunPoSh"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05/RunPoSh</span></a><span class="No-Break">.</span></p>
			<p>For this example, we leverage the PowerShell class from the <strong class="source-inline">System.Management.Automation</strong> namespace, the definition of which you can find <span class="No-Break">here: </span><a href="https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.powershell"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.powershell</span></a><span class="No-Break">.</span></p>
			<p>To compile this program without errors, you will need to add <strong class="source-inline">System.Management.Automation.dll</strong> as a reference in <span class="No-Break">Visual Studio:</span></p>
			<ol>
				<li>Right-click on the <strong class="bold">Dependencies</strong> project in <strong class="bold">Solution Explorer</strong> and select <strong class="bold">Add </strong><span class="No-Break"><strong class="bold">Project Reference</strong></span><span class="No-Break">.</span></li>
				<li>In <strong class="bold">Reference Manager</strong>, select <strong class="bold">Browse</strong> and navigate to the folder where the <strong class="source-inline">System.Management.Automation.dll</strong> assembly is located. The default location is <strong class="source-inline">C:\Program Files (</strong><span class="No-Break"><strong class="source-inline">x86)\Reference Assemblies\Microsoft\WindowsPowerShell\3.0</strong></span><span class="No-Break">.</span></li>
				<li>Select the assembly and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break">.</span></li>
				<li>Save and build <span class="No-Break">your project.</span></li>
			</ol>
			<p>The newly compiled code allows you to execute PowerShell commands or scripts without executing <strong class="source-inline">powershell.exe</strong>, and only relying on the PowerShell class to execute PowerShell commands. The C# code in this example takes all command-line arguments, concatenates them into a single string, and adds that string as a PowerShell script to execute. The<a id="_idIndexMarker931"/> program then invokes the PowerShell script and captures the output, which is then printed to <span class="No-Break">the console.</span></p>
			<p class="callout-heading">RunPosh.exe - Possible Command Injection Risk!</p>
			<p class="callout">Please <a id="_idIndexMarker932"/>note that <strong class="source-inline">RunPosh.exe</strong> is vulnerable to trivial command injection. It should not be used in any productive environment and is only meant to demonstrate how PowerShell can be executed without <span class="No-Break">running </span><span class="No-Break"><strong class="source-inline">powershell.exe</strong></span><span class="No-Break">.</span></p>
			<p>After compiling <strong class="source-inline">RunPosh.exe</strong>, you can for example open a <strong class="source-inline">cmd</strong> command line and execute <strong class="source-inline">RunPoSh.exe Get-NetAdapter</strong> to get all network adapters <span class="No-Break">using PowerShell.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer151">
					<img alt="Figure 5.39 – Executing PowerShell commands without powershell.exe" src="image/B16679_05_039.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.39 – Executing PowerShell commands without powershell.exe</p>
			<p>There are numerous other examples of how PowerShell can be executed without relying on <strong class="source-inline">powershell.exe</strong>. The <a id="_idIndexMarker933"/>ones discussed in this chapter were merely a few, intended to provide you with an understanding of the different methods available to achieve <span class="No-Break">this goal.</span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor148"/>Summary</h1>
			<p>In this chapter, we explored how PowerShell provides access to various system and API resources such as the Windows Registry, Windows API (including COM and .NET Framework), and WMI. We also learned how to run PowerShell without the use of the <span class="No-Break"><strong class="source-inline">powershell.exe</strong></span><span class="No-Break"> executable.</span></p>
			<p>The chapter provided many examples that demonstrated how red teamers or adversaries can exploit these APIs and resources. It was also intended to help blue teamers to gain insights into adversary behavior and learn how to leverage PowerShell to monitor and detect suspicious behavior by leveraging <span class="No-Break">CIM events.</span></p>
			<p>By the end of the chapter, you should have gained a better understanding of how PowerShell can be used to interact with system resources and APIs, as well as how to leverage it for both offensive and <span class="No-Break">defensive purposes.</span></p>
			<p>When we are talking about PowerShell security, authentication and identities play an important role. Let’s have a look at Active Directory security from a PowerShell perspective in our <span class="No-Break">next chapter.</span></p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor149"/>Further reading</h1>
			<p>If you want to explore some of the topics that were mentioned in this chapter, follow <span class="No-Break">these resources:</span></p>
			<p><span class="No-Break"><strong class="bold">API</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Low-Level Windows API Access From <span class="No-Break">PowerShell: </span><a href="https://www.fuzzysecurity.com/tutorials/24.html"><span class="No-Break">https://www.fuzzysecurity.com/tutorials/24.html</span></a></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">CIM/WMI</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Use PowerShell to Manipulate Information with <span class="No-Break">CIM: </span><a href="https://devblogs.microsoft.com/scripting/use-powershell-to-manipulate-information-with-cim/"><span class="No-Break">https://devblogs.microsoft.com/scripting/use-powershell-to-manipulate-information-with-cim/</span></a><a href="https://devblogs.microsoft.com/scripting/use-powershell-to-manipulate-information-with-cim/&#13;"/></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">COM hijacking</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Demystifying Windows Component Object Model (<span class="No-Break">COM): </span><a href="https://www.221bluestreet.com/offensive-security/windows-components-object-model/demystifying-windows-component-object-model-com"><span class="No-Break">https://www.221bluestreet.com/offensive-security/windows-components-object-model/demystifying-windows-component-object-model-com</span></a><a href="https://www.221bluestreet.com/offensive-security/windows-components-object-model/demystifying-windows-component-object-model-com&#13;"/></li>
				<li><span class="No-Break">acCOMplice: </span><a href="https://github.com/nccgroup/acCOMplice"><span class="No-Break">https://github.com/nccgroup/acCOMplice</span></a></li>
				<li>COM Hijacking Techniques, David Tulis (<span class="No-Break">DerbyCon): </span><a href="https://www.youtube.com/watch?v=pH14BvUiTLY"><span class="No-Break">https://www.youtube.com/watch?v=pH14BvUiTLY</span></a></li>
				<li>OleViewDotNet by James <span class="No-Break">Forshaw: </span><a href="https://github.com/tyranid/oleviewdotnet"><span class="No-Break">https://github.com/tyranid/oleviewdotnet</span></a><a href="https://github.com/tyranid/oleviewdotnet"/></li>
				<li>COM Class Objects and <span class="No-Break">CLSIDs: </span><a href="https://learn.microsoft.com/en-us/windows/win32/com/com-class-objects-and-clsids"><span class="No-Break">https://learn.microsoft.com/en-us/windows/win32/com/com-class-objects-and-clsids</span></a></li>
				<li>Hijacking .NET to Defend <span class="No-Break">PowerShell: </span><a href="https://arxiv.org/ftp/arxiv/papers/1709/1709.07508.pdf"><span class="No-Break">https://arxiv.org/ftp/arxiv/papers/1709/1709.07508.pdf</span></a></li>
				<li>Playing around COM objects - PART <span class="No-Break">1: </span><a href="https://mohamed-fakroud.gitbook.io/red-teamings-dojo/windows-internals/playing-around-com-objects-part-1"><span class="No-Break">https://mohamed-fakroud.gitbook.io/red-teamings-dojo/windows-internals/playing-around-com-objects-part-1</span></a><a href="https://mohamed-fakroud.gitbook.io/red-teamings-dojo/windows-internals/playing-around-com-objects-part-1&#13;"/></li>
				<li>IUnknown::QueryInterface(REFIID,void**) method (<span class="No-Break">unknwn.h): </span><a href="https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)"><span class="No-Break">https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)</span></a><a href="https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)&#13;"/></li>
				<li>IUnknown interface (<span class="No-Break">unknwn.h): </span><a href="https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown"><span class="No-Break">https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown</span></a></li>
				<li>IUnknown::QueryInterface(Q**) method (<span class="No-Break">unknwn.h): </span><a href="https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)"><span class="No-Break">https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)</span></a><a href="https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)&#13;"/></li>
			</ul>
			<p><strong class="bold">.</strong><span class="No-Break"><strong class="bold">NET Framework</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Assemblies in .<span class="No-Break">NET: </span><a href="https://learn.microsoft.com/en-us/dotnet/standard/assembly/"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/standard/assembly/</span></a><a href="http://microsoft.com/en-us/dotnet/standard/assembly/"/></li>
				<li>Global Assembly <span class="No-Break">Cache: </span><a href="https://learn.microsoft.com/en-us/dotnet/framework/app-domains/gac"><span class="No-Break">https://learn.microsoft.com/en-us/dotnet/framework/app-domains/gac</span></a></li>
				<li>.NET Framework versions and <span class="No-Break">dependencies: </span><a href="https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/versions-and-dependencies"><span class="No-Break">https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/versions-and-dependencies</span></a></li>
			</ul>
			<p><strong class="bold">Running PowerShell </strong><span class="No-Break"><strong class="bold">without powershell.exe</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><span class="No-Break">NoPowerShell: </span><a href="https://github.com/bitsadmin/nopowershell"><span class="No-Break">https://github.com/bitsadmin/nopowershell</span></a></li>
				<li><span class="No-Break">PowerLessShell: </span><a href="https://github.com/Mr-Un1k0d3r/PowerLessShell"><span class="No-Break">https://github.com/Mr-Un1k0d3r/PowerLessShell</span></a></li>
				<li><span class="No-Break">p0wnedShell: </span><a href="https://github.com/Cn33liz/p0wnedShell"><span class="No-Break">https://github.com/Cn33liz/p0wnedShell</span></a></li>
			</ul>
			<p>You can also find all links mentioned in this chapter in the GitHub repository for <a href="B16679_05_Final_PD.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> – no need to manually type in every <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Links.md"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Links.md</span></a><span class="No-Break">.</span></p>
		</div>
	</body></html>