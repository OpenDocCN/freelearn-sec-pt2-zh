- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell Is Powerful – System and API Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just when you thought PowerShell was already a mighty tool, get ready to be
    surprised by its ability to delve deep into the system. In this chapter, we’ll
    explore accessing the system and API by using PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by looking into the Windows Registry and how you can leverage PowerShell
    to easily access its keys and values. We’ll then move on to .NET Framework and
    the Windows API, and you’ll learn how to execute C# code directly from PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll explore **Windows Management Instrumentation** (**WMI**), which
    can be used to access and manage a wide range of system resources, including hardware,
    software, network components, and other objects, through a standard interface.
    PowerShell makes it easy to interact with WMI and automate tasks and manipulate
    data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will also learn how it is possible to run PowerShell commands
    without executing **powershell.exe**. You’ll learn how to run PowerShell code
    directly from within other applications or even in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll learn how to identify potential threats and secure your environment
    against these types of attacks. So, get ready to discover just how powerful PowerShell
    can be when it comes to system and API access. Let’s dive in! We will cover the
    following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with the Windows Registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of the Windows API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring .NET Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the **Component Object Model** (**COM**) and COM hijacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Common Information** **Model** (**CIM**)/WMI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running PowerShell without **powershell.exe**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make the most out of this chapter, ensure that you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell 7.3 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed Visual Studio for your C# code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C, C++, or C# knowledge and/or the ability to read C code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowledge of how to use compilers, especially C/C++/C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Basic knowledge and/or the ability to read Visual Basic code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to Microsoft Excel, or another tool from the Office suite that allows
    running macros
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to the GitHub repository for **Chapter05:**  [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting familiar with the Windows Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Windows Registry was introduced with **Windows 3.1**. Although back then,
    it primarily stored information for the COM-based components, it was developed
    over the years. Nowadays, it serves as the hierarchical database as we all know
    it – storing low-level configuration settings for the Windows operating system,
    as well as for applications running on it.
  prefs: []
  type: TYPE_NORMAL
- en: Although you can access the registry using multiple ways, we will concentrate
    in this section on how to access and operate the registry using PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Windows Registry of modern systems usually consists of five root keys.
    Each of them has their own purpose and contains different settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HKEY_CLASSES_ROOT** (**HKCR**): Hives underneath this root key contain information
    about COM class registration information and file associations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HKEY_CURRENT_USER** (**HKCU**): Contains settings that are specific to the
    user that is currently logged on. Technically, this root key is just a symbolic
    link that leads to **HKU\<CurrentUserSid>\**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HKEY_LOCAL_MACHINE** (**HKLM**): Settings that are specific to the local
    computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HKEY_USERS** (**HKU**): Subkeys for each user profile actively loaded on
    the machine (like **HKEY_CURRENT_USER**, but not exclusively limited to the currently
    logged-on user).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HKEY_CURRENT_CONFIG** (**HKCC**): Hives under this root key don’t store any
    information themselves, but rather act as a pointer to registry keys that keep
    information about the current hardware profile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell treats the registry like a virtual drive; you can access and modify
    it using the same commands as you would while navigating and editing files and
    folders.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the **Get-PSDrive** cmdlet, you can get all drives of the current session.
    If you inspect the output a little bit further, you’ll see that not only system
    drives are listed here. The **HKCU** and **HKLM** registry root keys can also
    be found here as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Finding the HKCU and HKLM registry root keys using Get-PSDrive](image/B16679_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Finding the HKCU and HKLM registry root keys using Get-PSDrive
  prefs: []
  type: TYPE_NORMAL
- en: And since PSDrives such as **HKCU** and **HKLM** are treated like regular file
    drives, it is not surprising that you can navigate through them using **Set-Location**
    (or the equivalent alias, **cd**), as well as **Get-ChildItem** (or the alias,
    **ls**) to list the contents of a folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, I query the current Windows PowerShell version from
    the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Navigating through the registry](image/B16679_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Navigating through the registry
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see all the sub-registry keys (**Name**),
    and also all the registry entries (also called **Property** in this context) that
    belong to each registry key.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to browse other locations of the registry than only the
    listed drives by using **Registry::** followed by the root key you want to query.
    In the following screenshot, I use **Foreach-Object** to show the key names of
    all sub-registry keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Browsing the registry using the Registry:: prefix](image/B16679_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3 – Browsing the registry using the Registry:: prefix'
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with registry keys is quite similar to working with files and folders,
    but nevertheless, there’s a difference when it comes to registry entries. They
    not only consist of keys but also of properties and values, as you can see in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Displaying properties and values of a registry key by using
    Get-Item](image/B16679_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Displaying properties and values of a registry key by using Get-Item
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with registry keys that have numerous subkeys and properties,
    you may want to obtain a list of all subkeys quickly. You can achieve this by
    using **ForEach-Object Name**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Displaying all sub-registry keys](image/B16679_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Displaying all sub-registry keys
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, we first changed the working directory to **HKLM:\SOFTWARE\Microsoft\Windows\**
    using the **Set-Location** cmdlet before querying the registry using **Get-ChildItem**.
    This way, you won’t need to type the entire path over and over again if you want
    to perform execute further commands in this location.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not certain where a specific registry key is located, query the
    registry recursive as you would *search* for a specific file on a drive using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the **New-Item** cmdlet, you can create a new registry key, and using
    **Remove-Item**, you can delete one or more registry keys, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Creating and deleting a registry key](image/B16679_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Creating and deleting a registry key
  prefs: []
  type: TYPE_NORMAL
- en: Using **Remove-Item** with the **-Recurse** parameter lets you delete a registry
    key as well as subkeys recursively without being prompted for confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: Registry entry properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You now know how to operate registry keys and how to display their properties,
    but when it comes to the registry, you want to understand how to work with the
    properties as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, although operating the registry is similar to working
    with files and folders, there are some differences when it comes to the properties
    of registry entries: while files have properties such as **LastWriteTime**, registry
    entries have their own set of properties.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to get a quick overview of the properties might be **Get-Item**, but
    there’s another cmdlet that helps you to get more details – **Get-ItemProperty**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Using Get-ItemProperty to display registry entries](image/B16679_05_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Using Get-ItemProperty to display registry entries
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the ***-ItemProperty** cmdlets, you can also manage registry entries.
    For example, to create a new registry entry, the **New-ItemProperty** cmdlet can
    help you. In the following screenshot, I have created a new entry in the startup
    folder for all users and deleted it using **Remove-ItemProperty**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Creating and deleting a new registry entry](image/B16679_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Creating and deleting a new registry entry
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to change a registry entry by using the **Set-ItemProperty**
    cmdlet. The following example demonstrates how to use **Set-ItemProperty** to
    alter an existing startup entry to change the path of a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Altering a registry entry](image/B16679_05_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Altering a registry entry
  prefs: []
  type: TYPE_NORMAL
- en: By the way, attackers like to create startup entries, too! This is, for example,
    one of many ways to establish persistence. So if you come across code similar
    to the preceding code in PowerShell logs and you did not create it yourself, it
    could be a sign of an attacker attempting to modify a startup entry to run their
    malware instead of its original intended purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get more information on how to operate the registry using PowerShell
    via the following help system commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Get-Help Registry**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Get-Help about_Providers**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, understanding the security use cases for working with the registry
    is essential for defenders. Let’s explore some of the most common ones next.
  prefs: []
  type: TYPE_NORMAL
- en: Security use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple use cases for attackers where they query or attempt to modify
    the registry – use cases that defenders should also be familiar with. Let’s start
    exploring some of the most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: Reconnaissance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often, attackers access the registry to find out more about the current target
    system: is an antimalware solution in use, and does the attacker''s code need
    additional steps to avoid being detected? Is there a backup solution that would
    prevent a successful ransomware attack?'
  prefs: []
  type: TYPE_NORMAL
- en: The registry is also often queried to find out more about the system and configured
    (security) options. And some adversaries also try to find out whether the system
    that is currently executing the code is a **virtual machine** (**VM**) or a **sandbox**.
  prefs: []
  type: TYPE_NORMAL
- en: A VM is an emulated computer, which is hosted on another computer, the hypervisor.
    It does not require its own hardware, as it shares the hardware of the hypervisor
    with many other VMs. A sandbox is a system that is often used by security researchers
    or even antimalware solutions to detonate a potential malware and test how it
    behaves and whether it’s truly malicious. Attackers usually want to avoid their
    software being run on a VM or a sandbox as this could imply that someone is analyzing
    their malware to build protections against it.
  prefs: []
  type: TYPE_NORMAL
- en: If that is the case, and if the malware is executed in a VM or in a sandbox,
    often it is implemented so that the software behaves in a different way than it
    would on a physical work device that is used by a real user – to complicate reverse
    engineering of their code to stay undetected for a longer period.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the registry – storing credentials in the registry is a very
    bad practice and should be avoided. However, there are still administrators and
    software vendors that use the registry to store credentials in a very unsecure
    way. Therefore, attackers have been observed to query the registry to retrieve
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Some malware even uses the registry for their own purposes, and set and query
    their own registry hives or keys.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when you are searching for reconnaissance evidence, attackers
    also have other (programmatic) options to query the registry – such as the **reg.exe**
    command-line tool or WMI.
  prefs: []
  type: TYPE_NORMAL
- en: Execution policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B16679_01_Final_PD.xhtml#_idTextAnchor016), *Getting Started
    with PowerShell*, we learned that **ExecutionPolicy** restricts the execution
    of scripts on the local machine – although it’s not a security control. Nevertheless,
    the **ExecutionPolicy** status can also be queried or modified using the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Changing the Windows PowerShell ExecutionPolicy using the registry](image/B16679_05_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Changing the Windows PowerShell ExecutionPolicy using the registry
  prefs: []
  type: TYPE_NORMAL
- en: Changing **ExecutionPolicy** using the registry only works for Windows PowerShell.
    Therefore, you can see in the preceding screenshot that, first, the Windows PowerShell
    **ExecutionPolicy** shows that it is set to **Restricted**, but after configuring
    the registry entry, it is set to **Unrestricted**.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell Core’s **ExecutionPolicy** is defined in the following file: **C:\Program
    Files\PowerShell\7\powershell.config.json**.'
  prefs: []
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another reason attackers attempt to edit the registry is to establish persistence:
    a very common way to establish persistence is to add a Startup entry. This can
    be done by adding a link to either the Startup folder of the current user or all
    users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option to establish persistence via Startup is by adding either a **Run**
    or **RunOnce** registry key under one of the following Startup registry locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HCU\.DEFAULT\Software\Microsoft\CurrentVersion\**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that **.DEFAULT** can also be replaced with the user **Security identifiers**
    (**SIDs**) of the respective folder under **HKEY_USERS**.
  prefs: []
  type: TYPE_NORMAL
- en: The **Run** key executes the program each time a user logs on, while the **RunOnce**
    key runs the program once and then deletes the key. These keys can be set for
    the user or the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set, for example, a **RunOnce** key for the current user to execute a script
    *once* after the user logged on, you would use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To set a **Run** key for the local machine to execute a script *every time*
    the machine is booted, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, attackers can also establish persistence under other user's Startup
    keys by directly writing to their respective **Run**/**RunOnce** keys under the
    **HKU\<TargetSID>\Software\Microsoft\CurrentVersion\** key, provided they have
    the necessary permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we explored the Windows Registry, let’s dive into another important
    part when it comes to security: local user rights.'
  prefs: []
  type: TYPE_NORMAL
- en: User rights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'User rights play a huge role in corporate environments: you can, for example,
    configure who is allowed to log on to which system and who is allowed to do what.
    A misconfiguration can cause a serious risk of identity theft and lateral movement.'
  prefs: []
  type: TYPE_NORMAL
- en: Adversaries can use it to find out which accounts are worthwhile to compromise
    to escalate their privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a detailed overview of all user rights in the official documentation:
    [https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment).'
  prefs: []
  type: TYPE_NORMAL
- en: I know the documentation is quite extensive and if you have no experience on
    user rights yet, you might quickly get lost. Therefore, let me explain some of
    the most important security-related user rights that I have often seen misconfigured.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring access user rights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, log-on rights are always critical if too many users and or groups
    are allowed to access a sensitive system. Many default rights are set by default
    and may need to be changed to harden the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on what machine type you’re configuring this policy for, you may
    want to limit the ability to log on locally or through a remote desktop to a machine
    to its users and/or specific administrator accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Access this computer from the network** (**SeNetworkLogonRight**): For **domain
    controllers** (**DCs**), all authenticated users needs to have access to apply
    Group Policies, so configure **Administrators** and **Authenticated Users** to
    access DCs. Remove the built-in groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove **Everyone**, **Users**, as well as the built-in groups for member servers.
    For client PCs, only allow users and administrators to log on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Allow log on locally** (**SeInteractiveLogonRight**): Remove **Guest** and
    built-in groups. If it’s a DC or a member server, also remove **Users**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Allow log on through Remote Desktop** **Services** (**SeRemoteInteractiveLogonRight**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log on as a batch** **job** (**SeBatchLogonRight**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log on as a** **service** (**SeServiceLogonRight**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *deny* rules overwrite the *allow* privileges: no matter what you configured
    as an *allow* rule, if access is forbidden by a *deny* rule, the affected user
    cannot log on or access the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deny access to this computer from the** **network** (**SeDenyNetworkLogonRight**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deny log on as a batch** **job** (**SeDenyBatchLogonRight**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deny log on as a** **service** (**SeDenyServiceLogonRight**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deny log on** **locally** (**SeDenyInteractiveLogonRight**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deny log on through Remote Desktop** **Services** (**SeDenyRemoteInteractiveLogonRight**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These rules can help you to set up a solid tiering concept in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Do not remove **Guest** from the **Deny log on**/**access** permissions unless
    your specific configuration requires it.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigating risks through backup and restore privileges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Backup and restore privileges can be incredibly powerful, as they allow users
    to access and modify files and directories that they normally have no access to.
    It makes sense to evaluate very carefully who has these rights configured, especially
    on critical systems such as DCs. These rights could allow adversaries to extract
    sensitive information such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Back up files and** **directories** (**SeBackupPrivilege**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Restore files and** **directories** (**SeRestorePrivilege**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s crucial to note that backup privileges allow a user to read any file, regardless
    of their normal permissions. This means that users with backup privileges can
    also potentially access sensitive information such as, for example, password hashes
    that are available in the **ntds.dit** database file on DCs. Restore privileges,
    on the other hand, allow a user to write any file, which could potentially be
    used to plant malicious code or modify critical system files.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the built-in **Backup Operators** group is assigned both of these
    rights. Be careful if you plan to remove this group because some backup software
    packages rely on this group to enable the software to function. Where possible,
    assign the backup and restore privileges only to specific users or groups instead
    of relying on the built-in **Backup** **Operators** group.
  prefs: []
  type: TYPE_NORMAL
- en: Delegation and impersonation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having the right for delegation allows someone to delegate rights to another
    account. Impersonation allows impersonating another account, which is usually
    used by web servers to access resources in the context of a user. If misconfigured,
    both can have dramatic consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enable computer and user accounts to be trusted for delegation** (**SeEnableDelegationPrivilege**):
    If an account is trusted for delegation, that means that this account can set
    the *trusted for delegation* setting. Once set, this setting enables the ability
    to connect to multiple servers or services while retaining the credentials of
    the originating account. Web servers, which need to connect using the originating
    credentials to a database or data share, are a good example of a legitimate use
    case to be *trusted* *for delegation*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nevertheless, you want to avoid configuring this right unless it is really needed
    by a certain software.
  prefs: []
  type: TYPE_NORMAL
- en: '**Impersonate a client after authentication** (**SeImpersonatePrivilege**):
    Impersonation allows services or threads to run under a different security context.
    If misconfigured, this ability could allow attackers to trick clients into connecting
    to a service created by the attacker to then impersonate the connecting client
    to elevate the attacker’s privileges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Act as part of the operating system** (**SeTcbPrivilege**): This right allows
    an account to control the system and act as any user. This setting decides whether
    a process can take on the identity of any user, which gives access to the resources
    that the user can use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing event log tampering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have access to the auditing and security log, you can tamper with it
    and hide your traces. The following settings affect access to the auditing and
    security log and should be configured with care:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generate security audits** (**SeAuditPrivilege**): Although this privilege
    only allows generating new events, an attacker can create so much noise that their
    attacking attempts might go unnoticed, especially if the company does not forward
    event logs and deletes them after a certain volume is reached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manage auditing and security log** (**SeSecurityPrivilege**): If you can
    manage event logs, then you can surely delete them as well. Look for event ID
    **104** in the system event log. Please refer to [*Chapter 4*](B16679_04_Final_PD.xhtml#_idTextAnchor090),
    *Detection – Auditing and Monitoring*, for more information on monitoring and
    detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing Mimikatz and credential theft
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mimikatz and other tools that are used for credential theft usually require
    the right to debug programs or load kernel mode drivers. The following settings
    are usually required by tools such as Mimikatz and others to extract credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debug programs** (**SeDebugPrivilege**): A common misconception with the
    **Debug programs** privilege is that this would be needed by developers to debug
    their software. This is not true. The Debug programs privileges privilege allows
    access to otherwise protected operating system memory, effectively providing control
    over program execution and the ability to read and write memory. Tools such as
    Mimikatz that access the **Local Security Authority** (**LSA**) to extract credentials
    require this permission to properly function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally, your administrators will not require this user right, so it’s safe
    to revoke this right for everybody, even for your administrators.
  prefs: []
  type: TYPE_NORMAL
- en: Note that administrators can assign this right to themselves; therefore, remove
    this privilege and monitor for changes. In this way, you can spot indicators for
    the beginning of a credential theft attack.
  prefs: []
  type: TYPE_NORMAL
- en: '**Load and unload device drivers** (**SeLoadDriverPrivilege**): This right
    enables a user account to load kernel mode drivers. Since these drivers are located
    in kernel mode memory, they can be used to read or tamper with other kernel mode
    memory, much like the **Debug programs** right. Be cautious when granting this
    user right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System and domain access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Getting access to the system or adding machines to a domain can be very valuable
    for attackers. The following setting is related to these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add workstations to domain** (**SeMachineAccountPrivilege**): This privilege
    allows the user to add workstations to the domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time tampering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tampering with the time of an operating system is not considered a security
    flaw by default and should not be confused with **timestomping**, which involves
    modifying timestamps of file creation, access, modification, and so on. Nevertheless,
    it is important to be aware that certain programs may encounter issues when the
    system time is tampered with, and incorrect timestamps can lead to inaccurate
    conclusions during event log analysis. The following settings should be configured
    very carefully to avoid these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Change the system** **time** (**SeSystemtimePrivilege**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change the time** **zone** (**SeTimeZonePrivilege**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course, this is only a summary of the user rights that I have seen mostly
    misconfigured and not a complete list. Please refer to the official documentation
    and follow the links to read more about each user privilege: [https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment](https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment).'
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you want to find out which built-in groups have which user rights assigned
    by default, the following documentation can be very helpful: [https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn487460(v=ws.11)](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn487460(v=ws.11)).'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the **Policy Analyzer** as well to analyze and compare your settings
    with the official Microsoft recommendation. We will explore Policy Analyzer later
    in [*Chapter 6*](B16679_06_Final_PD.xhtml#_idTextAnchor150)*, Active Directory
    – Attacks* *and Mitigation*.
  prefs: []
  type: TYPE_NORMAL
- en: But Policy Analyzer is not the only way to analyze and compare user right assignments
    – let’s look at how to assert which rights are set and how to configure them in
    our next section.
  prefs: []
  type: TYPE_NORMAL
- en: Examining and configuring user rights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to examine which user rights are configured on the localhost, you
    can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to export the local and domain-managed policy merged, you can use
    the **/****mergedpolicy** parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All current user rights will be written to **$Env:Temp\secedit.txt**. Under
    the **[Privilege Rights]** section, you can find all configured assignments. By
    using **secedit**, only the SIDs will be shown, so you will need to translate
    them into real user account names.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Privilege rights in the secedit file](image/B16679_05_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Privilege rights in the secedit file
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information on further parameters and the usage of **secedit**
    in the official documentation: [https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490997(v=technet.10)](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490997(v=technet.10)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I have written a script, **Get-UserRightsAssignment**, that will help you to
    translate the SIDs into account names and makes it easier to process user rights.
    You can use the **-Path** parameter to specify a custom location where the file
    generated by **secedit** should be saved to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The **secedit** file will be deleted after the script completes. If **-Path**
    is not specified, the default path will be **$env:TEMP\secedit.txt**. As the script
    leverages the **secedit** tool, you will need administrative rights to execute
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find and download the **Get-UserRightsAssignment** script in the GitHub
    repository of this book: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-UserRightsAssignment.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-UserRightsAssignment.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use Group Policy to configure the user rights assignment of multiple
    computers and/or servers in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Group Policy Object** (**GPO**) and navigate to **Computer Configuration**
    | **Windows Settings** | **Security Settings** | **Local Policies** | **User**
    **Rights Assignment**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Configuring user rights assignment via Group Policy](image/B16679_05_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Configuring user rights assignment via Group Policy
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click each policy setting that you want to configure. A window will
    open. To configure the setting, check the **Define these policy settings** box
    and use **Add User or Group** to add additional users or groups, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Configuring the Allow log on locally setting](image/B16679_05_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Configuring the Allow log on locally setting
  prefs: []
  type: TYPE_NORMAL
- en: Under the **Explain** tab, you will find more information on what this setting
    does and, often, also useful links on where to find more details on this setting.
  prefs: []
  type: TYPE_NORMAL
- en: If you configure user rights assignments and assess the GPO on the system, you
    will see that a similar file is created as if you would create it manually. You
    can use it to compare your settings or just place a manually preconfigured **secedit**
    file here to avoid configuring all settings manually via the GPO interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example in my domain, **PSSec.local**, I created the GPO with the unique
    ID **{B04231D1-A45A-4390-BB56-897DA6B1A910}**. If I want to access the newly created
    **secedit** configuration, I simply have to navigate to the following path and
    assess the **GptTmpl.inf** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you can also just copy the **GptTmpl.inf** file from an existing
    Microsoft Security baseline into a newly created GPO to just configure the Microsoft
    recommendations. A Microsoft Security baseline is a configuration recommendation
    by Microsoft to provide security best practices. We will further look into baselines
    in [*Chapter 6*](B16679_06_Final_PD.xhtml#_idTextAnchor150)*, Active Directory
    – Attacks* *and Mitigation*.
  prefs: []
  type: TYPE_NORMAL
- en: After exploring Windows user rights in the preceding section, we will now focus
    on another vital component of the Windows operating system – the Windows API.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of the Windows API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Windows **Application Programming Interface** (**API**), also known as Win32
    or WinAPI, is a collection of libraries, functions, and interfaces that provide
    low-level access to various features and components of the Windows operating system.
    It allows developers direct access to system features and hardware, simplifying
    access to deeper layers of the operating system. The Windows API functions are
    written in C/C++ and are exposed by DLL files (such as **kernel32.dll** or **user32.dll**).
  prefs: []
  type: TYPE_NORMAL
- en: The Windows API is implemented as a collection of **dynamic-link libraries**
    (**DLLs**) that are loaded into memory when an application needs to use them.
    These DLLs contain the functions and procedures that make up the API. When an
    application calls a function from the API, it is essentially sending a message
    to the operating system to perform a certain task. The operating system then executes
    the appropriate function from the appropriate DLL and returns the result to the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, the names *Windows API* or *WinAPI* refers to several versions, although
    the versions implemented for different platforms can be still referred to by their
    own names (such as *Win32 API*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Win16 API**: The first API version was the Win16 API, which was developed
    for 16-bit platforms, but is no longer supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Win32 API**: The Windows 32 API is still in use on all current modern Windows
    systems and was introduced with Windows NT and Windows 95.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Win32s API**: This is the Windows 32 API for the Windows 3.1 family, and
    therefore, an extension to 32-bit, as systems in this family originally only supported
    16-bit. The **s** stands for **subset**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Win64 API**: This API is the variant for modern 64-bit operating systems
    and was introduced with Windows XP and Windows Server 2003.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows Native API**: The Native API is used when other APIs such as the
    Win32 API are not yet accessible – for example, when a system is booted. Unlike
    the well-documented Win32 API functions in the **Microsoft Developer Network**
    (**MSDN**) (such as **kernel32.dll**), it is important to note that the Native
    API, exported via **NTDLL.DLL**, is not considered a “contractual” interface.
    This means that the behavior and definitions of functions exposed by **NTDLL.DLL**
    may change over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Windows API functions are written exclusively in C, C++, and assembly and
    can therefore be used by developers in their own functions. The Win32 API itself
    is quite large, so there are multiple DLL files needed to export the entire functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, there are several layered APIs, which simplify access so that the
    developer does not need to directly work with the Win32 or Win64 API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some APIs that build on the Windows API are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**WinRT**: The Windows Runtime API was first introduced with Windows 8/Windows
    Server 2012\. WinRT is based on the COM and was implemented in C++. It enables
    developers to write their code now also in other languages, such as C++, C#, Visual
    Basic .NET, Rust/WinRT, Python/WinRT, and JavaScript/TypeScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COM**: COM is a part of the APIs and is a technique for inter-process communication.
    We will have a deeper look at it later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET**/**.NET Framework**: .NET Framework is a software framework developed
    by Microsoft that provides a large library of pre-built functions and APIs that
    can be used by developers to build applications on Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One way to access the Windows API from PowerShell is through the use of .NET
    Framework. This allows you to access the same functionality provided by the Windows
    API, but from within PowerShell. It allows you to interact with the operating
    system at a lower level and perform tasks that may not be possible with standard
    PowerShell cmdlets. We will learn more about .NET Framework later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list is a collection of different API categories that can be
    utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User interface**: Provides functions for creating and managing user interface
    elements such as windows, buttons, and menus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows environment (Shell)**: Includes functions for interacting with the
    Windows Shell, which is the graphical user interface that provides access to the
    filesystem and other system resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User input and messaging**: Handling user input and messaging, such as keyboard
    and mouse events, window messages, and system notifications functionality will
    be provided through this interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data access and storage**: The Windows API provides functions for working
    with data and storage, including file and registry access, database connectivity,
    and data encryption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Diagnostics**: This interface provides access to monitoring system performance,
    logging events, and troubleshooting error functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphics and multimedia**: Provides functions for working with graphics,
    multimedia, and game development, including DirectX and Windows Media.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices**: The Windows API includes functions for interacting with hardware
    devices, such as printers, scanners, and cameras.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System services**: Contains functions for managing system services, such
    as starting and stopping processes and managing system resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and identity**: The security and identity interface includes functions
    for managing user authentication, access control, and cryptography.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application installation and servicing**: Includes functions for installing
    and uninstalling applications, managing updates, and handling application errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System admin and management**: Contains functions for managing system settings,
    performance, and security, and for automating administrative tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking and internet**: The Windows API includes functions for networking
    and internet connectivity, including TCP/IP, sockets, and web services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deprecated or legacy APIs**: For backward compatibility with older applications
    and systems, the Windows API also includes some older functions and interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows and application SDKs**: In addition to the categories of APIs listed
    previously, there are also **software development kits** (**SDKs**) available
    for Windows and application development. PowerShell is one example of an SDK that
    uses the Windows API and .NET Framework. The **System.Management.Automation**
    assembly includes classes and cmdlets for working with PowerShell from within
    .NET applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the most commonly used Windows API functions include those related to
    process and thread management, memory management, file and directory management,
    and registry manipulation. These functions can be used to perform a variety of
    tasks, such as enumerating processes and threads, reading and writing to memory,
    creating and deleting files and directories, and manipulating the Windows Registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are of course many other APIs, but I will not concentrate on them in
    this book. A complete overview of the functions and structures within the Windows
    API that can be accessed can be found here: [https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring .NET Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**.NET Framework** is a software framework developed by Microsoft that provides
    a wide range of functionalities for building and running applications. It is a
    default part of every Windows installation since Windows Vista. One of the framework’s
    key features is the ability to access system and API resources, making it a powerful
    tool.'
  prefs: []
  type: TYPE_NORMAL
- en: '.NET Framework consists of two main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Language** **Runtime** (**CLR**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the runtime engine for .NET; it also contains a **Just in Time** (**JIT**)
    compiler, which translates bytecode in **Common Intermediate Language** (**CIL**)
    to the underlying compiler to turn it into machine code that can execute on the
    specific architecture of the computer it is running on.
  prefs: []
  type: TYPE_NORMAL
- en: The CLR also includes thread management, a garbage collector, type safety, code
    access security, exception handling, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Every .NET Framework version comes with its own CLR.
  prefs: []
  type: TYPE_NORMAL
- en: '**.NET Framework Class** **Library** (**FCL**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FCL is a large collection of types and APIs that implement common functionality
    – for example, user interface services, connecting to databases, networking, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: .NET applications can be written in C#, F#, Visual Basic, and many more, which
    are also supported on non-Windows systems such as Linux or macOS. On Windows-only
    systems, C++ can be used as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the code is written in a .NET Framework-compatible language, the code
    is compiled into a CIL and is usually stored in assemblies (**.dll** or **.exe**
    ending). To compile C# source code files, for example, .NET Framework ships its
    own compiler – **csc.exe** – which can be found on Windows 10 computers under
    CLR: **C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler then writes the compiled CIL code as well as a manifest into a
    read-only part of the output file, which has a standard PE header (Win32-portable
    executable) and saves it as an assembly file (usually a file with an **.exe**
    ending – depends on which output format you choose):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – How .NET Framework compiles applications](image/B16679_05_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – How .NET Framework compiles applications
  prefs: []
  type: TYPE_NORMAL
- en: CIL code cannot be executed directly; it needs to be JIT compiled by the CLR
    into machine code first. Therefore, the CLR is needed on the system where the
    application should run.
  prefs: []
  type: TYPE_NORMAL
- en: When the freshly compiled assembly is executed, the CLR takes the assembly and
    compiles it on the fly by using a JIT compiler. The assembly is then turned into
    machine code that can run on the architecture of the machine on which the application
    was started.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework versus .NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the rise of cross-platform and cloud-based applications, in 2016, Microsoft
    released .NET Core, a lightweight and modular version of the framework. Designed
    to run on multiple platforms including Windows, macOS, and Linux, .NET Core can
    be used to develop applications for web, desktop, mobile, gaming, and IoT.
  prefs: []
  type: TYPE_NORMAL
- en: Later, **.NET Core** was renamed to **.NET**, while the Windows-specific branch
    is nowadays referred to as **.****NET Framework**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we will take a closer look at the similarities
    and differences between .NET Framework and .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Comparing .NET and .NET Core](image/B16679_05_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Comparing .NET and .NET Core
  prefs: []
  type: TYPE_NORMAL
- en: Overall, .NET is a more lightweight and modular framework that is optimized
    for building modern, cloud-based, and containerized applications, whereas .NET
    Framework is a comprehensive framework that is designed for a wide range of programming
    scenarios, including large-scale enterprise applications and legacy systems.
  prefs: []
  type: TYPE_NORMAL
- en: Compile C# code using .NET Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to compile C# code with .NET Framework and PowerShell by using
    the command-line compiler, **csc.exe**. This compiler is included with every installation
    of .NET Framework. Please note that the **csc.exe** compiler can run on any **.cs**
    file and does not need PowerShell for its execution. Nevertheless, we will be
    looking at how to use **csc.exe** from PowerShell in this section for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile a C# file using **csc.exe**, navigate to the directory containing
    the file and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The **/out** option specifies the name of the output file, and **<input_file_name>**
    specifies the name of the C# file you want to compile. For example, to compile
    a file named **MyProgram.cs** and to generate an executable file named **MyProgram.exe**,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the compiled executable file, simply type the name of the file into
    the PowerShell console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of how to compile and run a simple **"Hello, World!"** program
    in C# using PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once compiled, running **MyProgram.exe** will output **"Hello World!"** to
    the console, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Compiling C code using the csc.exe and executing it](image/B16679_05_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Compiling C code using the csc.exe and executing it
  prefs: []
  type: TYPE_NORMAL
- en: The **Out-File** cmdlet is used to write the C# code to a file named **MyProgram.cs**
    before it is compiled. This file can then be compiled using the **csc.exe** compiler,
    and the resulting executable can be run using **.\MyProgram.exe**.
  prefs: []
  type: TYPE_NORMAL
- en: Using Add-Type to interact with .NET directly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to access the Windows API from PowerShell using .NET methods
    is by using the **Add-Type** cmdlet. By using **Add-Type**, it is possible to
    compile and run .NET code from the PowerShell command line. The **Add-Type** cmdlet
    allows you to define and create .NET Core classes within your PowerShell session.
    With this cmdlet, you can easily integrate custom objects into your PowerShell
    code and gain access to .NET Core libraries. By passing your C# code to the **-TypeDefinition**
    parameter of the **Add-Type** cmdlet, your code compiles in real time whenever
    calling your newly defined C# function.
  prefs: []
  type: TYPE_NORMAL
- en: For the following example, I have written a little C# class named **DirectoryTest**,
    which contains the **GetDirectories** function. **GetDirectories** checks whether
    the path that was passed to the function can be accessed and outputs all files
    and folders that path contains to the command line. If the path does not exist
    or is not a legitimate path, the returned output will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the code in the GitHub repository of this book: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-GetDirectoriesUsingAddType.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-GetDirectoriesUsingAddType.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to create a class using C# that compiles and runs without errors.
    In my example, I first load my C# code into the **$Source** variable, which allows
    me to access it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Storing the C# class in the source variable](image/B16679_05_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Storing the C# class in the source variable
  prefs: []
  type: TYPE_NORMAL
- en: '**Add-Type** allows you to define and use a .NET Core class in a PowerShell
    session. The .NET Core class can be either specified within a variable, as we
    are doing for this example, but it can also be specified inline or provided using
    a binary or source code file. The following screenshot shows the use of **Add-Type**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Loading the source code into the current PowerShell session](image/B16679_05_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Loading the source code into the current PowerShell session
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can directly interact with the class and call the **GetDirectories**
    function using the **C:\** parameter to specify which directories of which path
    should be queried:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Executing the GetDirectories function from the DirectoryTest
    class](image/B16679_05_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Executing the GetDirectories function from the DirectoryTest class
  prefs: []
  type: TYPE_NORMAL
- en: Et voilà – all subfolders of the **C** partition are being returned.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you're now asking yourself, “*But why would I want to query the Windows
    API if I already have PowerShell?*” Well, there are a few reasons why you might
    prefer to use the API over PowerShell. One reason is that the API can offer low-level
    functionality that native PowerShell may not provide. Accessing raw Windows APIs
    directly through **P/Invoke** and executing unmanaged code might be another reason.
  prefs: []
  type: TYPE_NORMAL
- en: By using the API, you can create hooks (which is a technique to make code behave
    differently as originally designed by injecting custom code), intercept system
    events, manipulate system settings, monitor system resources, track user activity,
    and even manipulate the behavior of system processes, which can be useful for
    various purposes such as red teamers disabling antivirus or elevating privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'For further information on **Add-Type**, please refer to the official **Add-Type**
    documentation: [https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type).'
  prefs: []
  type: TYPE_NORMAL
- en: Loading a custom DLL from PowerShell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s also a way to load a custom DLL from PowerShell when it is already compiled.
    Of course, you can also use **csc.exe** to compile your own program first.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the **DirectoryTest.cs** file that we are using in this example
    in this book’s GitHub repository: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/DirectoryTest.cs](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/DirectoryTest.cs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first compile the program into a DLL using **csc.exe**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can load the compiled DLL and load it using the **[****System.Reflection.Assembly]::Load()**
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In .NET, an assembly is basically the smallest, fundamental unit of deployment
    of an application. It is either a **.dll** or an **.exe** file. If the assembly
    is shared between applications, it is usually stored in the **Global Assembly**
    **Cache** (**GAC**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the DLL is successfully loaded, you can now access its methods from PowerShell,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Loading a custom DLL and accessing its methods from PowerShell](image/B16679_05_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Loading a custom DLL and accessing its methods from PowerShell
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding screenshot, by using **[DirectoryTest]::GetDirectories("C:\tmp")**,
    it is possible to execute the **GetDirectories** function that was defined in
    **DirectoryTest.dll**: all folders and files that are in the specified directory
    will be written to the output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the **[System.Reflection.Assembly]::Load()** function, you can also
    use **Add-Type** with the **-Path** parameter to load a DLL in PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Loading a DLL by using Add-Type](image/B16679_05_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – Loading a DLL by using Add-Type
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the example code used in *Figure 5**.21* in the GitHub repository
    of this chapter: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-LoadDllWithAddType.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Invoke-LoadDllWithAddType.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the Windows API using P/Invoke
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the Windows API can be useful for PowerShell scripting when you want to
    call functions that are not exposed by PowerShell cmdlets or .NET classes (**unmanaged
    code**).
  prefs: []
  type: TYPE_NORMAL
- en: 'To call a Windows API function from PowerShell, you need to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare the DLL file that contains the function using **DllImport**, specifying
    the location of the DLL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the function signature (the name, parameters, return type, and calling
    convention).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the function with the appropriate arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s look at how this can be done with an easy example using the **MessageBoxA**
    function from **user32.dll**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first declare the function signature for the **MessageBoxA**
    function from the **user32.dll** library using the **DllImport** attribute and
    save it in the **$signature** variable. We then add the function signature to
    the PowerShell session using the **Add-Type** cmdlet, which allows us to use the
    function in our PowerShell script.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the **[Win32.User32]::MessageBoxA()** function, passing the
    appropriate arguments as specified by the function signature. In our example,
    we pass in a **null IntPtr** handle to specify that the message box should not
    have a parent window. We then specify the message string, as well as the title,
    and a **uint** value to specify the buttons and icons to display in the message
    box. In this example, **0** indicates that the message box should only have an
    **OK** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing, the defined message box opens and shows the message and title
    as specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Executing unmanaged code from PowerShell](image/B16679_05_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Executing unmanaged code from PowerShell
  prefs: []
  type: TYPE_NORMAL
- en: Note that when using **P/Invoke**, it’s important to ensure that the function
    signature matches the actual function in the unmanaged DLL, including the correct
    parameter types, return type, and calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we called unmanaged code from **user32.dll**, which resulted
    in opening a message box. You might ask yourself how this differentiates from
    calling the **MessageBox** function in the **System.Windows.Forms** .NET class.
  prefs: []
  type: TYPE_NORMAL
- en: Some Win32 APIs have corresponding .NET APIs that almost literally do what we
    demonstrated here (such as **System.Windows.Forms.MessageBox.Show()**), but many
    do not. By using the **P/Invoke** method demonstrated in the example, you can
    call any function defined in an unmanaged DLL from PowerShell, while the .NET
    class is limited to a specific set of functions, including **MessageBox**.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to explore loading and executing unmanaged code further, a great
    resource is https://pinvoke.net/. It’s an invaluable resource to find and operate
    **P/Invoke** signatures, user-defined types, and other information related to
    working with unmanaged code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more examples of how you can use PowerShell to interact with the Windows
    API, also refer to the blog series *Use PowerShell to Interact with the Windows
    API*, *Parts 1-3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-1/](https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-1/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-2/](https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-2/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-3/](https://devblogs.microsoft.com/scripting/use-powershell-to-interact-with-the-windows-api-part-3/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After exploring .NET Framework and **P/Invoke**, it’s time to focus on another
    crucial technology in the Windows operating system: the COM.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Component Object Model (COM) and COM hijacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: COM is a binary standard for software componentry introduced by Microsoft in
    1993, which defines a set of rules for how software components interact with each
    other and allows inter-process communication. It was developed by Microsoft to
    address the need for interoperability between applications.
  prefs: []
  type: TYPE_NORMAL
- en: COM is the basis of many other technologies, such as **OLE**, **COM+**, **DCOM**,
    **ActiveX**, **Windows User Interface**, **Windows Runtime**, and many others.
    Basically, COM is just middleware that sits between two components and allows
    them to communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of how COM is used can be demonstrated with how **Object Linking
    and Embedding** (**OLE**) works: if you want to include, for example, an Excel
    table in your PowerPoint presentation. Usually, to allow this, without COM, PowerPoint
    would need to have the actual code implemented that makes Excel work how it works.
    But since this would be a waste of resources and redundant code, it does not make
    sense to duplicate the same code in two applications. Rather, it makes sense to
    point to the other application to include the functionality. And this is basically
    what OLE does: it just embeds an Excel object into PowerPoint and links to the
    Excel functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: COM is a technology based on the **client-server model**, where a client creates
    and uses a COM component within a server to access its functionality through interfaces.
    A **COM server** provides services to other components, known as **COM clients**,
    by exposing its functionality through related *methods* and *properties* in **COM
    interfaces**. These interfaces define a standardized way for clients to access
    the functionality of objects, regardless of the implementation language. COM servers
    can be *in-process* DLLs or *out-of-process* EXEs.
  prefs: []
  type: TYPE_NORMAL
- en: A COM server is implemented as a **COM class**, which is a blueprint defining
    the behavior and functionality of a COM object. A COM class usually implements
    one or more interfaces and provides a set of *methods* and *properties* that clients
    can use. Each COM class is identified by a unique 128-bit **globally unique identifier**
    (**GUID**) called a **CLSID**, which the server must register. When a client requests
    an object from the server, COM uses this CLSID to locate the *DLL* or *EXE* containing
    the code that implements the class and creates an instance of the object.
  prefs: []
  type: TYPE_NORMAL
- en: These components can be used in PowerShell using the **New-Object** cmdlet,
    which allows you to instantiate COM objects and interact with them using their
    methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we use the **New-Object** cmdlet to create an instance
    of the **Excel.Application** COM object, which provides access to the Excel application
    and its functionality. We then use the instantiated object to create a new workbook,
    add a new worksheet, and write the string **"Hello world!"** to cell A1\. Finally,
    we save the workbook and quit the Excel application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that in order to use the Excel COM object, you need to have Excel installed
    on your computer. The Excel COM object provides a large number of methods and
    properties, so there’s a lot you can do with it beyond the preceding simple example.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to use PowerShell to interact with COM components on remote
    machines using **Distributed COM** (**DCOM**). DCOM enables a client to connect
    to a COM component running on a remote machine and use its functionality as if
    it were on the local machine.
  prefs: []
  type: TYPE_NORMAL
- en: While COM provides a powerful framework for software components to communicate
    and interoperate, it also provides clear advantages to adversaries, including
    the fact that they don’t need to worry about network or security settings such
    as proxy or firewall rules. In most cases, everything is already set up for **Internet
    Explorer** (**IE**). Additionally, IE can be fully automated and instrumented
    to perform various actions such as navigating to a specific URL, downloading a
    file, or interacting with the form fields of an HTML document. Everything can
    also be easily hidden from the user, as a newly created IE window is invisible
    by default, and if the browser was already executed and has already been loaded
    into memory, one additional instance is relatively unsuspicious. For adversaries,
    COM opens up the potential for abuse and exploitation, as in the case of **COM
    hijacking**.
  prefs: []
  type: TYPE_NORMAL
- en: COM hijacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shared libraries such as DLLs allow multiple applications to share common code
    without duplicating it in memory, which reduces memory usage and prevents code
    duplication. Without shared libraries, each application would need to bring its
    own libraries, making programs larger and more memory-intensive. But this can
    also cause problems such as **DLL hell**, where different versions of the DLL
    are installed or used by different applications, leading to problems such as crashes
    or security issues.
  prefs: []
  type: TYPE_NORMAL
- en: COM solves DLL hell by using versioning. Each component has a unique identifier
    (CLSID) and a version identifier (**ProgID**), and each version is installed in
    a separate directory and registered in the Windows Registry. This allows multiple
    versions to coexist without conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: But this versioning mechanism can also be exploited for COM hijacking. In this
    attack, an adversary first locates a CLSID that is used by another process but
    is not registered yet. They create a malicious DLL and place it on the victim
    system. Then, they create a registry key that links the CLSID to the malicious
    DLL. As the registry key is created in HKCU, there are not even administrator
    rights needed for this operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the COM programming model, every interface implementation is required to
    include three fundamental methods: **QueryInterface**, **AddRef**, and **Release**.
    These methods are provided through the **IUnknown** interface, which is the base
    interface that all COM interfaces inherit from. The implementation of the **IUnknown**
    interface is mandatory for all COM objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '**AddRef** is used to increment the reference count of an object when a client
    is using it, and **Release** is used to decrement the reference count when the
    client is done with the object.'
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryInterface** obtains a pointer to a different interface that is supported
    by the COM object. In a COM hijacking attack, the attacker’s malicious DLL must
    implement the same interfaces as the legitimate COM component it is impersonating,
    including the **IUnknown** interface and any other supported interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: When a legitimate application tries to instantiate the COM object (that pointed
    formerly to an abandoned key) and queries the **IUnknown** interface of the malicious
    DLL file, the **QueryInterface** method returns the pointers to the other interfaces
    that were implemented by the malicious DLL file, enabling the attacker to take
    control of the victim application. By knowing which exports a DLL provides, an
    attacker can better plan their attack and identify the specific COM object they
    want to target.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to identify which COM servers are missing CLSIDs and don’t require
    elevated privileges (HKCU). **Process Monitor** (**procmon**), which is part of
    the **SysInternals** suite, can help us achieve this goal. You can download it
    from here: [https://learn.microsoft.com/en-us/sysinternals/downloads/procmon](https://learn.microsoft.com/en-us/sysinternals/downloads/procmon).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several registry keys that we can use to audit for stale CLSIDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**InprocServer**/**InprocServer32**: This key specifies the path to the DLL
    that implements the in-process server. This is what we are using in this example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LocalServer**/**LocalServer32**: This key defines the complete path to a
    local COM server application, regardless of its bitness or architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TreatAs**: This registry key specifies the CLSID of a class capable of emulating
    the current class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ProgID**: This key represents a human-readable string for a COM object to
    represent an underlying CLSID, making it easier for applications to reference
    a COM object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we are looking for a stale **InprocServer32** CLSID that can be accessed
    and changed by the current user, we are looking for unused but registered CLSIDs
    within the HKCU using the following filter parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Include**: **Operation** | **is** | **RegOpenKey**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Include**: **Result** | **is** | **NAME** **NOT FOUND**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Include**: **Path** | **ends with** | **InprocServer32**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exclude**: **Path** | **begins with** | **HKLM**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that in this example, we are using a stale **InprocServer32** CLSID, but
    COM hijacking would also be possible by abusing **InprocServer**, **LocalServer**,
    **LocalServer32**, **TreatAs**, or **ProgId**, or by replacing an existing COM
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how this Process Monitor filter is configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Filtering for stale CLSIDs in the HKCU hive](image/B16679_05_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – Filtering for stale CLSIDs in the HKCU hive
  prefs: []
  type: TYPE_NORMAL
- en: Capture the events for some time (for example, 5 minutes) to make sure that
    common activities are captured.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – Capturing stale CLSIDs](image/B16679_05_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24 – Capturing stale CLSIDs
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can examine the captured CLSIDs and find the one(s) that you want to
    use in your COM hijacking demo. In this example, we are using **{CDC82860-468D-4d4e-B7E7-C298FF23AB2C}**,
    which was queried by **Explorer.exe**.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a **.dll** file, **COMHijack.dll**. You can find the code to
    compile the file in the GitHub repository under [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/COMHijack/COMHijack/dllmain.cpp](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/COMHijack/COMHijack/dllmain.cpp).
  prefs: []
  type: TYPE_NORMAL
- en: This code defines a Windows DLL that runs a new process to launch the Windows
    calculator, **calc.exe**, when it is loaded into memory. The DLL main function
    sets up a **switch** statement to handle different reasons for the DLL being loaded,
    and in the **DLL_PROCESS_ATTACH** case, it calls the **CallCalculator** function,
    which creates a new process to run the Windows calculator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We compile **COMHijack.dll** and place it under **${Env:\TEMP}**. Then, we
    create a new registry key for **{CDC82860-468D-4d4e-B7E7-C298FF23AB2C}\InprocSServer32**
    and set the value of the default property to the location where **COMHijack.dll**
    was placed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And now, whenever **Explorer.exe** is opened, **calc.exe** will start as well.
  prefs: []
  type: TYPE_NORMAL
- en: This is, of course, not the only way for COM hijacking; there are many more
    options to explore. If you want to learn more about COM hijacking, I highly recommend
    looking into the links on COM hijacking in the *Further reading* section of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Another important component in the Windows operating system is the WMI. This
    component can be leveraged by both attackers and defenders – let’s explore it
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Common Information Model (CIM)/WMI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already learned in [*Chapter 3*](B16679_03_Final_PD.xhtml#_idTextAnchor064),
    *Exploring PowerShell Remote Management Technologies and PowerShell Remoting*,
    that WMI is Microsoft’s implementation of the **CIM**, and how to use WMI- or
    CIM-related PowerShell cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are exploring WMI a little bit further in the system context.
  prefs: []
  type: TYPE_NORMAL
- en: WMI is not a new technology, and WMI attacks are not a new attack vector. WMI
    only produces a small forensic footprint, runs in memory only, and is a great
    way to evade whitelisting as well as host-based security tools. Therefore, WMI
    has been weaponized in attacks in recent years like never before.
  prefs: []
  type: TYPE_NORMAL
- en: In general, applications such as PowerShell, .NET, C/C++, VBScript, and many
    more can access WMI through the WMI API. The **CIM Object Manager** (**CIMOM**)
    then manages the access between each WMI component. The communication relies on
    COM/DCOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure demonstrates the architecture of WMI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25 – WMI architecture](image/B16679_05_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25 – WMI architecture
  prefs: []
  type: TYPE_NORMAL
- en: The **WMI consumer** (or the managing application) connects using the WMI API
    to the WMI infrastructure and the WMI service (**Winmgmt**). In this case, we
    are looking at PowerShell as the only management application, but of course, there
    are also other possibilities, such as **wmic.exe**.
  prefs: []
  type: TYPE_NORMAL
- en: The **WMI infrastructure** acts as a mediator between the consumer, the providers,
    and managed objects. It consists of the CIM Core and the CIM repository. The WMI
    infrastructure is what keeps and connects everything within WMI together.
  prefs: []
  type: TYPE_NORMAL
- en: It supports various APIs, such as the **WMI COM API**, through which consumers
    can access WMI providers through the WMI infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The CIM repository is a database that stores static information and is organized
    within **namespaces**.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A namespace is a logical database whose purpose is to basically group sets of
    classes and instances that are related to a certain managed environment. A good
    example is the Registry provider, which groups all WMI classes and providers to
    operate the Windows Registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The namespace root directory is called **ROOT**. Within all WMI installations,
    there are always the four *default* WMI namespaces underneath **ROOT**: **CIMV2**,
    **Default**, **Security**, and **WMI**. Some of them have their own sub-namespaces.'
  prefs: []
  type: TYPE_NORMAL
- en: The **ROOT/cimv2** namespace is the most interesting namespace, as almost all
    interesting CIM classes are stored in this namespace. If you query all classes
    using **Get-CimClass** without specifying a namespace, **ROOT/cimv2** is queried
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some providers also define their own namespaces. This has the benefit for the
    developers that they don’t need to seek the permission of the owner of the namespace
    and can get rid of other restricting constraints as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26 – Overview of some common namespaces](image/B16679_05_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.26 – Overview of some common namespaces
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the old WMI cmdlets, it was possible to enumerate all namespaces using
    the **-****Recurse** parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: But let’s look at how you can perform operations using the new CIM cmdlets,
    which are also supported within PowerShell Core – the WMI cmdlets are not supported
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'To search one namespace, you can use **Get-CimInstance**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, searching recursively is not possible using **Get-CimInstance**; this
    cmdlet does not offer a **-recurse** parameter. To search recursively using **Get-CimInstance**,
    I have written a little function, which you can find in the GitHub repository
    of this book: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-CimNamespace.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Get-CimNamespace.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'After loading the function, you can use it by calling it by its name, **Get-CimNamespace**.
    Using the **-recurse** parameter lets you query recursively, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27 – Querying all present namespaces recursively](image/B16679_05_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.27 – Querying all present namespaces recursively
  prefs: []
  type: TYPE_NORMAL
- en: A namespace cannot work on its own; there’s always a managed object, managed
    by its **provider**, that’s registered to a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A provider is the interface between WMI and a managed object. It acts on behalf
    of the managing application, supplies the CIMOM with data from the managed object,
    and generates event notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'A provider usually consists of the following classifications: classes, events,
    event consumers, instances, methods, and properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes define and represent the general parameters of **managed objects**,
    which are provided by a provider. Usually, they are defined in a **Managed Object**
    **Format** (**MOF**).
  prefs: []
  type: TYPE_NORMAL
- en: If you remember [*Chap**ter 1*](B16679_01_Final_PD.xhtml#_idTextAnchor016)*,
    Getting Started with PowerShell*, we also talked about classes in this chapter.
    But in this context, a class is specific to WMI/CIM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the **Get-CimClass** cmdlet helps you to list all available classes in
    a specific namespace or to get more information about a certain class using the
    **-ClassName** parameter, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28 – Retrieving a CIM class in PowerShell Core](image/B16679_05_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.28 – Retrieving a CIM class in PowerShell Core
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the old **Get-WMIObject** cmdlet, you can query the **meta_class**
    table to get the same information as you did with **Get-CimClass**, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29 – Retrieving a WMI class in Windows PowerShell](image/B16679_05_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.29 – Retrieving a WMI class in Windows PowerShell
  prefs: []
  type: TYPE_NORMAL
- en: 'Every class also defines methods and properties, which are similar to our example
    of object-oriented programming from [*Chapter 1*](B16679_01_Final_PD.xhtml#_idTextAnchor016)*,
    Getting Started with PowerShell*, but specific to CIM/WMI:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Methods**: They define how we can interact with an object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Properties**: They allow us to define an object in more detail, such as the
    build number or version number:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In every namespace, you can find predefined classes, the **WMI system classes**.
    System classes are used to support WMI with activities such as event notification,
    event and provider registration, and various security tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to classes that are defined by a provider, system classes are not
    defined in MOF. You can find an overview of all predefined system classes in the
    official documentation: [https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-system-classes](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmi-system-classes).'
  prefs: []
  type: TYPE_NORMAL
- en: Instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We discussed in [*Chapter 1*](B16679_01_Final_PD.xhtml#_idTextAnchor016), *Getting
    Started with PowerShell*, that an **object** is an **instance** of a **class**
    that contains **properties** and **methods**. Similarly, a **CIM instance** is
    a unique, individual **object** that contains **properties** and **methods** defined
    by a **CIM class**.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the **Get-CimInstance** cmdlet, you can query a specified CIM instance
    by specifying the **-Class** parameter. The following screenshot demonstrates
    how to query the **Win32_OperatingSystem** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30 – Retrieving a CIM instance in PowerShell Core](image/B16679_05_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.30 – Retrieving a CIM instance in PowerShell Core
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can also query WMI using the **-Query** parameter, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.31 – Retrieving a CIM instance using a query](image/B16679_05_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.31 – Retrieving a CIM instance using a query
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compare the output with the output of the CIM classes, you can quickly
    spot the difference between a class and an instance: the class defines the instance,
    and the instance contains the values that are specific to the current system.'
  prefs: []
  type: TYPE_NORMAL
- en: Event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Events are generated by specific actions that occur on a system. While not
    all actions generate events, many important system activities do result in an
    event being raised and recorded in the event log. CIM contains its own event infrastructure:
    whenever changes happen in data or services, notifications are generated.'
  prefs: []
  type: TYPE_NORMAL
- en: Intrinsic events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Intrinsic events are related to WMI/CIM itself, such as a new CIM instance being
    created or when changes in the WMI/CIM infrastructure occur. These changes can
    trigger an intrinsic event.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find examples of intrinsic event classes using **(Get-CimClass -ClassName
    "*Event").CimSystemProperties | Where-Object {$_.ClassName -like "__*"}**, as
    depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.32 – Querying intrinsic event classes](image/B16679_05_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.32 – Querying intrinsic event classes
  prefs: []
  type: TYPE_NORMAL
- en: Everything within WMI/CIM is represented as an object, therefore every event
    is also represented as an object and has its own class. This behavior is similar
    to extrinsic WMI events.
  prefs: []
  type: TYPE_NORMAL
- en: Extrinsic events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Extrinsic events are generated by WMI providers in response to a change in the
    system state, such as the installation of new software or the modification of
    a system setting. For example, if the operating system is rebooted or if a registry
    key is changed, these events can be used by a provider to generate a WMI/CIM event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of extrinsic event classes can be found using **(Get-CimClass).CimSystemProperties
    | Where-Object {($_.ClassName -notlike "__*") -and (($_.ClassName -like "*Event")
    -or ($_.ClassName -like "*Trace"))}**, as depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.33 – Querying extrinsic event classes](image/B16679_05_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.33 – Querying extrinsic event classes
  prefs: []
  type: TYPE_NORMAL
- en: A query like this helps in discovering event classes that can be used to monitor
    system changes. For instance, you can use these classes to create a script that
    creates a new event log entry when an event of interest is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Event consumer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To support event notifications, event consumers can be used within a provider
    to map a physical consumer to a logical consumer. Consumers define what actions
    should be triggered if a certain change occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Events subscriptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Monitoring WMI/CIM events can help you, as a blue teamer, to detect changes
    that occurred on an operating system, but can also help red teamers who base their
    attacks on certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: When working with WMI/CIM events for the first time, it might quickly feel overwhelming.
    To help you to better understand, let’s look first at the basic steps in a simplified
    way
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a WMI Query Language (WQL) query**: Similar to querying data from
    WMI/CIM, you also need to create a query for the event subscription.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create an event filter**: Once you have created a WQL query, you will need
    to create a filter, which then registers the query in CIM.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a consumer**: The consumer defines what action should be taken if
    an event filter returns that a change in a class occurred.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bind the event filter to the consumer**: With this last step, we make the
    WMI/CIM event subscription work. By performing this step, the consumer will be
    notified every time the event filter received a match.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a WQL query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the earlier *Classes* section, you learned that predefined system classes
    exist for different purposes. When it comes to WMI/CIM events, the following four
    system classes might be the most interesting for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '**InstanceCreationEvent**: Checks whether a new instance was created. For example,
    you can check whether a new process was created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**InstanceDeletionEvent**: Checks whether an instance was deleted. For example,
    you can check whether a process was terminated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**InstanceModificationEvent**: Checks whether an instance was modified. For
    example, you can check whether a registry key was modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**InstanceOperationEvent**: Checks for all three types of events – whether
    an instance was created, deleted, or modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of a WQL event subscription query. It will trigger
    if a Windows service was terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this example, you can get a brief understanding of what such a query
    would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.34 – The structure of a WQL event subscription query](image/B16679_05_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.34 – The structure of a WQL event subscription query
  prefs: []
  type: TYPE_NORMAL
- en: The first part specifies where to look – in this case, **InstanceDeletionEvents**.
    The checking cycle specifies the polling interval in seconds of this query, indicated
    by the keyword **within**. In this example, the query runs every 15 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: In an event subscription query, conditions are not mandatory, but they can be
    useful in specifying and narrowing down the results. Conditions are indicated
    by **where**, similar to regular WQL or SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to specify multiple conditions, which are attached to the
    query by using **AND** or **OR**. If we, for example, want to check and act on
    the event that Microsoft Defender was terminated, the query would look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In summary, using conditions in event subscription queries can help narrow down
    the results and enable targeted actions to be taken in response to specific events.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an event filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it’s time to create our event filter. This can be done by using the **New-CimInstance**
    cmdlet, which creates a new instance of the **__EventFilter** CIM class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the WQL query that we just created and use it to create an event
    filter, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To create an event filter, we need to define the properties, which is done in
    the **$CimEventDefenderFilter** hashtable. The instance is given the name **MicrosoftDefenderFilter**
    via the **Name** parameter. The query created earlier is assigned to the **$query**
    variable and then passed to the **$CimEventDefenderFilter** property’s **Query**
    parameter. The **QueryLanguage** parameter is set to **WQL** to indicate that
    the query is written in the WMI Query Language. Finally, the **EventNamespace**
    parameter specifies the namespace where the event filter will be registered, which,
    in this case, is **\root\cimv2**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a new CIM instance is created in the **Root/SubScription** namespace,
    using the **__EventFilter** class, to indicate that we are creating an event filter.
    The properties of this instance are set to the values in the hashtable of the
    **$****CimEventDefenderFilter** variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify that the filter was created using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays what it looks like when the event filter
    is successfully created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.35 – Verifying that the filter was created](image/B16679_05_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.35 – Verifying that the filter was created
  prefs: []
  type: TYPE_NORMAL
- en: As a next step, we will need to create a consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a consumer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In WMI/CIM event subscriptions, a consumer is used to define what action should
    be taken when an event filter receives a match. There are several types of consumers
    available, each with its own properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ActiveScriptEventConsumer**: This consumer executes a script when an event
    occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CommandLineEventConsumer**: This consumer starts a process when an event
    occurs. Please verify the **access control list** (**ACL**) of the **.exe** file,
    so that adversaries are prevented from replacing the **.exe** file with a malicious
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LogFileEventConsumer**: This consumer creates a text log when an event occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NTEventLogEventConsumer**: This consumer logs an event to the Windows event
    log when an event occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SMTPEventConsumer**: This consumer sends an email when an event occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every consumer has its own properties, so make sure to check its properties
    before you define them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to configure a consumer that logs an
    event every time the Microsoft Defender service is terminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The **$Message** variable defines the body of the event log message, which includes
    the name and status of the terminated service. The **$CimDefenderConsumerProperties**
    variable defines the properties of **NTEventLogEventConsumer**, such as the machine
    name (**MachineName**), event ID (**EventID**), event type (**EventType**), the
    name of the event log in which the event should be logged (**SourceName = 'Application'**),
    and the message of the event itself (**InsertionStringTemplates**). **NumberOfInsertionStrings**
    specifies the number of insertion strings that will be used in the event message.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, **EventType** specifies that a warning (**2**) should be logged.
    Here’s an overview of all possible event types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**0**: Successful event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1**: Error event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2**: Warning event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**4**: Information event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**8**: Success audit type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**16**: Failure audit type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the **New-CimInstance** cmdlet creates the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **Get-CimInstance** cmdlet to verify that it was created successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Binding the event filter to the consumer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we will bind the event filter to the consumer in order to make the
    WMI/CIM event subscription work. Binding an event filter to a consumer ensures
    that the consumer will be notified every time the event filter receives a match.
  prefs: []
  type: TYPE_NORMAL
- en: After creating an event filter and a consumer, the final step is to bind them
    together. This can be done by creating an instance of the **__FilterToConsumerBinding**
    class. This class defines a relationship between the event filter and the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to create a binding instance between
    the event filter and the SMTP event consumer created in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using the **New-CimInstance** cmdlet to create a new
    instance of the **__FilterToConsumerBinding** class. We pass the event filter
    and consumer instances as references to the **Filter** and **Consumer** properties
    of the binding instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can verify that the binding was created by using the **Get-CimInstance**
    cmdlet, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will return all instances of the **__FilterToConsumerBinding** class in
    the **root/subscription** namespace, including the instance that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a CIM instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to remove any CIM instance that you created, you can use the **Remove-CimInstance**
    cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet removes the event filter CIM instance, **'MicrosoftDefenderFilter'**,
    which we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command removes the event log consumer CIM instance with the
    name **''Windows Defender Service (windefend)** **was terminated''**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And last but not least, to remove the CIM instance that is responsible for
    binding the event filter to the consumer, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Monitor WMI/CIM event subscriptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can detect and monitor WMI/CIM event-related activity by using both the
    Windows event log and Sysmon.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the Windows event log, you can use the operational WMI activity
    log to track WMI/CIM-related events:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full** **Name**: **Microsoft-Windows-WMI-Activity/Operational**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log** **path**: **%SystemRoot%\System32\Winevt\Logs\Microsoft-Windows-WMI-Activity%4Operational.evtx**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path in the UI**: **Applications and Services** | **Microsoft** | **Windows**
    | **WMI Activity** | **Operational**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *most interesting event IDs* in this event log for PowerShell security
    logging are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 5857**: Provider started with result code. This event shows provider
    loading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 5858**: Error message. This event typically triggers for query errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 5859**: This event indicates that a permanent event filter was started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 5860**: A temporary event consumer was registered or started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 5861**: A permanent event consumer binding was registered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the WMI activity events can be extremely noisy, so ensure to filter
    accordingly to your environment and your needs. Event IDs *5859*, *5860*, and
    *5861* can especially help you to find malicious activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another great resource if you want to learn more about tracking WMI activity
    using the Windows event log is the following blog article written by Carlos Perez:
    [https://www.darkoperator.com/blog/2017/10/14/basics-of-tracking-wmi-activity](https://www.darkoperator.com/blog/2017/10/14/basics-of-tracking-wmi-activity).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sysmon** provides capabilities to monitor whenever an event filter or consumer
    is registered or when a consumer binds to a filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event ID 19**: Logs the WMI namespace, filter name, and filter expression
    when a WMI event filter is registered. Malware can use this method to execute
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 20**: Logs the registration of WMI consumers, including the consumer
    name, log, and destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event ID 21**: Logs the consumer name and filter path when a consumer binds
    to a filter. This can help identify which consumer is receiving events from a
    specific filter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sysmon is a little less noisy than the Windows WMI activity event log, but you
    will need to install it first on the systems that you want to monitor, so it has
    its up- as well as its downsides.
  prefs: []
  type: TYPE_NORMAL
- en: For monitoring WMI activities *in general* – regardless of whether you use Windows
    event logs or Sysmon – look for new event filters and bindings being registered
    and filter out known good filters and bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Monitor the use of **wmic.exe** – look especially for the **'process call create'**
    argument. Observe the use of **winrm.exe** for lateral movement, and investigate
    whether **mofcomp.exe** was used to compile a new provider. Look for the creation
    of **MOF** files in unusual directories. And monitor the child processes of **WmiPrvse.exe**,
    as they could indicate an instantiation of processes through WMI.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating CIM instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CIM instances provide a standardized way of representing managed resources in
    a system, allowing users to interact with these resources in a unified way. But
    CIM instances can also be manipulated. In such cases, the **Set-CimInstance**
    cmdlet can be used to modify one or more properties of a CIM instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not possible to manipulate all CIM instances; they need to be writable.
    To find out which properties are writable, you can use the following script, which
    was inspired by Trevor Sullivan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once you find a property that can be written to that you want to manipulate,
    you can alter it using **Set-CimInstance**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how you could use CIM to enable a disabled
    user account with PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: First, you can use the **Get-CimInstance** cmdlet to retrieve the instance of
    the **Win32_UserAccount** class that matches the specified filter criteria. In
    this case, we are searching for a user account whose name starts with **vicvega**.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can modify the **Disabled** property of the retrieved user account
    instance to set it to **$false**. Finally, you can use the **Set-CimInstance**
    cmdlet to save the updated user account instance to the CIM repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to verify that the updated user account instance
    was saved successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Enumeration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'WMI uses a subset of SQL, called **WMI Query Language** (**WQL**). WQL only
    supports a subset of commands, which are documented here: [https://docs.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi](https://docs.microsoft.com/en-us/windows/win32/wmisdk/wql-sql-for-wmi).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of queries – data, event, and schema queries. In
    this book, we will mostly concentrate on the most commonly used ones: data queries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about the other query types, I recommend referring
    to the official documentation: [https://docs.microsoft.com/en-us/windows/win32/wmisdk/querying-with-wql](https://docs.microsoft.com/en-us/windows/win32/wmisdk/querying-with-wql).'
  prefs: []
  type: TYPE_NORMAL
- en: A data query simply serves the purpose to retrieve data – for example, about
    class instances or data associations.
  prefs: []
  type: TYPE_NORMAL
- en: To query a class, you can either use WQL or query the class by its class name.
    So, for example, to query a group with the name **Administrators**, you can either
    query the class and then filter using PowerShell or use WQL and filter using the
    query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of querying the class and using PowerShell to filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And this shows you how to query and filter using WQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Both methods will result in the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.36 – Querying using different methods](image/B16679_05_036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.36 – Querying using different methods
  prefs: []
  type: TYPE_NORMAL
- en: Did You Know?
  prefs: []
  type: TYPE_NORMAL
- en: If you have the chance, you should always prefilter using WQL as that increases
    the performance of your queries. If you first query and then filter using PowerShell,
    it takes longer to calculate the results.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I will provide you with some examples of enumeration using
    CIM/WMI. You can adjust them to your needs or improve your existing detections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enumerate processes using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Using **Get-CimInstance** does not only retrieve information about processes
    but you can also use WMI to display the **CommandLine** property that is not available
    in the default .NET output objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to enumerate existing user accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: By using WMI to enumerate users, you can not only enumerate local users but
    also domain users will be enumerated while executing one single command.
  prefs: []
  type: TYPE_NORMAL
- en: 'WMI also provides a huge advantage for red teamers: if you would be using PowerShell
    only, you would need to install the **ActiveDirectory** module to query domain
    users. By using WMI, you can simply enumerate all domain users if the computer
    on which you are executing commands is domain-joined.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally to other properties, **Get-CimInstance** also returns the **AccountType**
    property, which indicates whether the account is a *normal account* (**512**),
    a *workstation account* (**4096**), or, for example, even the account of a backup
    domain controller (*server trust account*, **8192**). The number **256** would
    indicate that it’s a *temporary duplicate account*, while the number **2048**
    indicates an *interdomain* *trust account*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enumerate local groups and group members as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Again, similar to the **win32_useraccount** table, **win32_group** and **win32_groupuser**
    are referring to both local and domain groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'WMI and CIM understand relationships between different instances, so you can
    even combine tables to find out which accounts are members of the local administrators.
    The **Get-CimAssociatedInstance** cmdlet allows you to get related objects that
    are linked to **-InputObject**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To get more information about currently installed hotfixes and updates, you
    can query the **win32_quickfixengineering** table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Find out which processes, programs, or scripts are configured to run when the
    operating system starts by querying the **Win32_StartupCommand** instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Where is the WMI/CIM database located?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And by the way, if you have always wondered where WMI is actually located on
    a Windows system, the WMI database itself can be found under **$Env:windir\System32\wbem\Repository**.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot displays the context of this folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.37 – WMI database](image/B16679_05_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.37 – WMI database
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can usually find the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '**INDEX.BTR** (“binary tree index”):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index of all managed objects that were imported into **OBJECTS.DATA**.
  prefs: []
  type: TYPE_NORMAL
- en: '**OBJECTS.DATA**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All objects that are managed by WMI.
  prefs: []
  type: TYPE_NORMAL
- en: '**MAPPING[1-3].MAP**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correlates data between **INDEX.BTW** and **OBJECTS.DATA**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have covered the importance of monitoring and manipulating WMI
    for security purposes, it’s time to move on to another topic: while some individuals
    may believe that PowerShell is a security threat and advocate for blocking **powershell.exe**,
    attackers can still find ways to run PowerShell even if **powershell.exe** is
    prevented from being executed. In the following section, we will explore how this
    can be achieved.'
  prefs: []
  type: TYPE_NORMAL
- en: Running PowerShell without powershell.exe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To execute PowerShell commands, you usually first start **powershell.exe**.
    But there may be situations where running PowerShell in a traditional manner is
    not possible or allowed.
  prefs: []
  type: TYPE_NORMAL
- en: In those cases, PowerShell can still be run by using other means, such as through
    **Windows Script Host** (**WSH**), WMI, .NET Framework, or more.
  prefs: []
  type: TYPE_NORMAL
- en: Using “living off the land” binaries to call assembly functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term **LOLbin** is short for **living off the land binaries** and was coined
    by malware researchers Christopher Campbell and Matt Graeber at DerbyCon 3 in
    2013\. In a Twitter discussion on what to call those binaries that can be abused
    to run malicious code, the term *LOLBins* came up for the first time and a (highly
    scientific) Twitter poll made the terms *LOLBins* and *LOLScripts* official within
    the community.
  prefs: []
  type: TYPE_NORMAL
- en: A LOLbin refers to legitimate, pre-installed system binaries or applications
    that can be abused by attackers to carry out malicious activities on a compromised
    system. Attackers use these LOLbins as part of their **tactics, techniques, and
    procedures** (**TTPs**) to evade detection by security solutions since these binaries
    are typically considered safe and allowed to execute on the system.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, PowerShell is also considered a LOLbin, as PowerShell was added as
    a legitimate admin tool. But thankfully for blue teamers, PowerShell provides
    many possibilities to not only monitor but to also restrict the usage to preconfigured
    use cases, as well as users. Other examples of legitimate admin tools that could
    also serve as a LOLbin are **cmd**, **WMI**, **regsvr32.exe**, **rundll32.exe**,
    **mshta.exe**, **certutil.exe**, **wmic.exe**, **msbuild.exe**, **installutil.exe**,
    **regsvcs.exe**, **regasm.exe**, **PSExec.exe**, and others.
  prefs: []
  type: TYPE_NORMAL
- en: '**PSExec.exe** is a great example of a LOLbin: while many administrators are
    still using it for administrative tasks, adversaries also happen to find this
    tool very useful. Especially when it comes to passing the hash and lateral movement,
    attackers love this tool.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, LOLbins are also simply used for obfuscation to invoke actions in
    a way that defenders might overlook when monitoring their systems – such as, for
    example, **rundll.exe**; this executable can load and run 32-bit DLLs and execute
    functions. Note that it can only execute functions that were explicitly written
    to run with **rundll32.exe**.
  prefs: []
  type: TYPE_NORMAL
- en: If you know how to write DLLs using C/C++/C#, **rundll32.exe** can run self-created
    DLLs – an ability that attackers can also profit from to run their own DLLs and
    bypass software restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Since writing your own DLLs in C/C++/C# could fill an entire book itself, we
    won’t concentrate in detail on how to create a DLL in this book. In our next example,
    we will use an already existing DLL, **PowerShdll.dll**.
  prefs: []
  type: TYPE_NORMAL
- en: '**PowerShdll.dll** was written and released by the GitHub user *p3nt4*: [https://github.com/p3nt4/PowerShdll](https://github.com/p3nt4/PowerShdll).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once downloaded, you can simply use **rundll32** or another LOLbin that is
    supported by **PowerShdll** and execute the following command from **cmd**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Et voilà – the **Get-Process** cmdlet is executed from **cmd** without ever
    touching **powershell.exe**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.38 – Executing PowerShell commands through PowerShdll and rundll32
    from cmd](image/B16679_05_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.38 – Executing PowerShell commands through PowerShdll and rundll32
    from cmd
  prefs: []
  type: TYPE_NORMAL
- en: There are also other projects similar to **PowerShdll** that can be used by
    red teamers or adversaries, such as **NoPowerShell**, **PowerLessShell**, **p0wnedShell**,
    and many others.
  prefs: []
  type: TYPE_NORMAL
- en: Binary executables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are also projects such as **NotPowerShell** (**nps.exe**) that let you
    run PowerShell from its own compiled binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the **NoPowerShell** project on GitHub: [https://github.com/Ben0xA/nps](https://github.com/Ben0xA/nps).'
  prefs: []
  type: TYPE_NORMAL
- en: Executing PowerShell from .NET Framework using C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way to run PowerShell without **powershell.exe** is by using .NET Framework.
    This can be done by creating a C# console application in Visual Studio with the
    code that is available in this book’s GitHub repository: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05/RunPoSh](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter05/RunPoSh).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we leverage the PowerShell class from the **System.Management.Automation**
    namespace, the definition of which you can find here: [https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.powershell](https://learn.microsoft.com/en-us/dotnet/api/system.management.automation.powershell).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile this program without errors, you will need to add **System.Management.Automation.dll**
    as a reference in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the **Dependencies** project in **Solution Explorer** and select
    **Add** **Project Reference**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Reference Manager**, select **Browse** and navigate to the folder where
    the **System.Management.Automation.dll** assembly is located. The default location
    is **C:\Program Files (****x86)\Reference Assemblies\Microsoft\WindowsPowerShell\3.0**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the assembly and click **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and build your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The newly compiled code allows you to execute PowerShell commands or scripts
    without executing **powershell.exe**, and only relying on the PowerShell class
    to execute PowerShell commands. The C# code in this example takes all command-line
    arguments, concatenates them into a single string, and adds that string as a PowerShell
    script to execute. The program then invokes the PowerShell script and captures
    the output, which is then printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: RunPosh.exe - Possible Command Injection Risk!
  prefs: []
  type: TYPE_NORMAL
- en: Please note that **RunPosh.exe** is vulnerable to trivial command injection.
    It should not be used in any productive environment and is only meant to demonstrate
    how PowerShell can be executed without running **powershell.exe**.
  prefs: []
  type: TYPE_NORMAL
- en: After compiling **RunPosh.exe**, you can for example open a **cmd** command
    line and execute **RunPoSh.exe Get-NetAdapter** to get all network adapters using
    PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.39 – Executing PowerShell commands without powershell.exe](image/B16679_05_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.39 – Executing PowerShell commands without powershell.exe
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous other examples of how PowerShell can be executed without
    relying on **powershell.exe**. The ones discussed in this chapter were merely
    a few, intended to provide you with an understanding of the different methods
    available to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how PowerShell provides access to various system
    and API resources such as the Windows Registry, Windows API (including COM and
    .NET Framework), and WMI. We also learned how to run PowerShell without the use
    of the **powershell.exe** executable.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter provided many examples that demonstrated how red teamers or adversaries
    can exploit these APIs and resources. It was also intended to help blue teamers
    to gain insights into adversary behavior and learn how to leverage PowerShell
    to monitor and detect suspicious behavior by leveraging CIM events.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you should have gained a better understanding of
    how PowerShell can be used to interact with system resources and APIs, as well
    as how to leverage it for both offensive and defensive purposes.
  prefs: []
  type: TYPE_NORMAL
- en: When we are talking about PowerShell security, authentication and identities
    play an important role. Let’s have a look at Active Directory security from a
    PowerShell perspective in our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to explore some of the topics that were mentioned in this chapter,
    follow these resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Low-Level Windows API Access From PowerShell: [https://www.fuzzysecurity.com/tutorials/24.html](https://www.fuzzysecurity.com/tutorials/24.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CIM/WMI**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use PowerShell to Manipulate Information with CIM: [https://devblogs.microsoft.com/scripting/use-powershell-to-manipulate-information-with-cim/](https://devblogs.microsoft.com/scripting/use-powershell-to-manipulate-information-with-cim/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**COM hijacking**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Demystifying Windows Component Object Model (COM): [https://www.221bluestreet.com/offensive-security/windows-components-object-model/demystifying-windows-component-object-model-com](https://www.221bluestreet.com/offensive-security/windows-components-object-model/demystifying-windows-component-object-model-com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'acCOMplice: [https://github.com/nccgroup/acCOMplice](https://github.com/nccgroup/acCOMplice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'COM Hijacking Techniques, David Tulis (DerbyCon): [https://www.youtube.com/watch?v=pH14BvUiTLY](https://www.youtube.com/watch?v=pH14BvUiTLY)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OleViewDotNet by James Forshaw: [https://github.com/tyranid/oleviewdotnet](https://github.com/tyranid/oleviewdotnet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'COM Class Objects and CLSIDs: [https://learn.microsoft.com/en-us/windows/win32/com/com-class-objects-and-clsids](https://learn.microsoft.com/en-us/windows/win32/com/com-class-objects-and-clsids)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hijacking .NET to Defend PowerShell: [https://arxiv.org/ftp/arxiv/papers/1709/1709.07508.pdf](https://arxiv.org/ftp/arxiv/papers/1709/1709.07508.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Playing around COM objects - PART 1: [https://mohamed-fakroud.gitbook.io/red-teamings-dojo/windows-internals/playing-around-com-objects-part-1](https://mohamed-fakroud.gitbook.io/red-teamings-dojo/windows-internals/playing-around-com-objects-part-1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IUnknown::QueryInterface(REFIID,void**) method (unknwn.h): [https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void)](https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IUnknown interface (unknwn.h): [https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown](https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nn-unknwn-iunknown)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IUnknown::QueryInterface(Q**) method (unknwn.h): [https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)](https://learn.microsoft.com/en-us/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.****NET Framework**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assemblies in .NET: [https://learn.microsoft.com/en-us/dotnet/standard/assembly/](https://learn.microsoft.com/en-us/dotnet/standard/assembly/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Global Assembly Cache: [https://learn.microsoft.com/en-us/dotnet/framework/app-domains/gac](https://learn.microsoft.com/en-us/dotnet/framework/app-domains/gac)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET Framework versions and dependencies: [https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/versions-and-dependencies](https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/versions-and-dependencies)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running PowerShell** **without powershell.exe**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'NoPowerShell: [https://github.com/bitsadmin/nopowershell](https://github.com/bitsadmin/nopowershell)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerLessShell: [https://github.com/Mr-Un1k0d3r/PowerLessShell](https://github.com/Mr-Un1k0d3r/PowerLessShell)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'p0wnedShell: [https://github.com/Cn33liz/p0wnedShell](https://github.com/Cn33liz/p0wnedShell)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also find all links mentioned in this chapter in the GitHub repository
    for [*Chapter 5*](B16679_05_Final_PD.xhtml#_idTextAnchor110) – no need to manually
    type in every link: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Links.md](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter05/Links.md).'
  prefs: []
  type: TYPE_NORMAL
