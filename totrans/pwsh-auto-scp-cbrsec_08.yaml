- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Red Team Tasks and Cookbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is meant to be a quick and dirty reference for red teamers that
    want to use PowerShell for their engagements. It is by no means complete but should
    help you get started.
  prefs: []
  type: TYPE_NORMAL
- en: After a short introduction to the phases of attack, we are going to look at
    what tools are usually used by red teamers for PowerShell-based engagements. After
    that, we will provide a PowerShell cookbook that covers most typical red team
    scenarios when it comes to PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Phases of an attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common PowerShell red team tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red team cookbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the most out of this chapter, ensure that you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows PowerShell 5.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell 7.3 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access to the GitHub repository for this chapter: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter08](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter08)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phases of an attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to an attack, the same pattern is usually repeated over and over
    again. These phases are also reflected when it comes to a professional penetration
    test, which is performed by red teamers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the phases of an attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Phases of an attack](image/B16679_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Phases of an attack
  prefs: []
  type: TYPE_NORMAL
- en: In the first phase, known as **reconnaissance**, the red teamer tries to get
    as much information as possible about the target. Once this phase has been completed,
    vulnerabilities are identified (**vulnerability identification**) that can be
    used for **exploitation** and getting access to the target.
  prefs: []
  type: TYPE_NORMAL
- en: Once a target has been successfully exploited, usually, credentials are collected,
    which can be used for **lateral movement** and to collect even more identities.
    Part of **post-exploitation** is to gain **persistence**, which means that the
    red teamer can reconnect without the need to exploit vulnerabilities once more.
  prefs: []
  type: TYPE_NORMAL
- en: Lateral movement can also occur by finding more vulnerabilities that can be
    exploited, for example by finding and exploiting a vulnerability in other connected
    systems that wasn’t accessible through the primary point of entry and cannot simply
    be reached by just gathering and abusing identities.
  prefs: []
  type: TYPE_NORMAL
- en: 'While moving laterally, the goal is usually to find a very valuable identity
    that has high privileges, such as a domain administrator account, which can then
    be used to gain control of the entire environment to achieve the actual **goal**
    of the engagement: in real-world adversary scenarios, this could be either to
    encrypt all possible systems to demand a ransom (as is done by **ransomware**)
    or to stay in the environment undetected as long as possible to **extract information**.'
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, adversaries try to **cover their tracks** in a real-world
    scenario. This step is – of course – not necessary if we are talking about a penetration
    test engagement; in this case, the pentester usually writes a **report** as a
    last step to present their findings.
  prefs: []
  type: TYPE_NORMAL
- en: All these steps might sound quite time-consuming, but in reality, most of the
    steps are already scripted, and it is only a matter of a few hours or even minutes
    until the entire environment is compromised. So long as the attack hasn’t started,
    the adversary has as much time as they like to do their reconnaissance to find
    out as much as possible about the target and prepare.
  prefs: []
  type: TYPE_NORMAL
- en: Once the first host has been compromised, it usually does not take longer than
    24 to 48 hours until a domain administrator account is compromised. But usually,
    depending on the organization and the industry, it takes some time until it is
    discovered that an actual attack has happened… if it is detected at all…
  prefs: []
  type: TYPE_NORMAL
- en: If adversaries are launching a ransomware campaign, they will not remain unnoticed
    once they start encrypting systems and demanding ransom. But usually, they still
    go unnoticed for a significant time to prepare for their attack.
  prefs: []
  type: TYPE_NORMAL
- en: For red teamers, PowerShell is a great tool as it is built into every modern
    Windows operating system and offers a mechanism for remote command execution.
    It also offers full access to system APIs via WMI and .NET Framework and can be
    used for fileless code execution, meaning that malicious code can be executed
    in memory without the need to write it to disk if intended. Additionally, it can
    be used to evade **antivirus** (**AV**), as well as **intrusion prevention** **systems**
    (**IPSs**).
  prefs: []
  type: TYPE_NORMAL
- en: Although there are many commands that red teamers can leverage for their purposes,
    there is also a plethora of open source tools that provide several capabilities
    that are very helpful in red team engagements, as well as in real-world scenario
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Common PowerShell red team tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many tools have been released that are written in PowerShell that can help you
    with your red team engagements – too many for you to make use of every single
    one. In this section, we will look at some of the most well-known and helpful
    tools to get you started and provide you with an overview of what is out there
    to help.
  prefs: []
  type: TYPE_NORMAL
- en: PowerSploit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PowerSploit** is a collection of PowerShell modules and scripts that can
    help red teamers during a penetration testing engagement. It was originally developed
    by Matt Graeber. It is no longer supported, but there are still many useful tools
    and scripts that are helpful. PowerSploit can be downloaded from GitHub: https://github.com/PowerShellMafia/PowerSploit.'
  prefs: []
  type: TYPE_NORMAL
- en: While most functions work fine in Windows PowerShell, they don’t in PowerShell
    7 and above. Some functionalities that PowerSploit made use of from .NET Framework
    were not ported into .NET Core, on which PowerShell 7 relies. So, when running
    PowerSploit from PowerShell 7 and above, you will likely experience errors. Therefore,
    we will be using Windows PowerShell for demonstration purposes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerSploit is a very extensive collection, so we will not deep-dive into it.
    It comes with several subfolders, which group its PowerShell modules into the
    following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CodeExecution**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ScriptModification**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistence**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AntivirusBypass**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exfiltration**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mayhem**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Privesc** (privilege escalation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recon** (reconnaissance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can either load the entire collection as a module or just load parts of
    it; it is possible to just copy and paste one of the subfolders into your module
    folder and load it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, you can find all the related functions and aliases of PowerSploit
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the most out of it, you can refer to the official documentation: [https://powersploit.readthedocs.io/en/latest/](https://powersploit.readthedocs.io/en/latest/).'
  prefs: []
  type: TYPE_NORMAL
- en: One tool within PowerSploit that might be worth taking a second look at is PowerView.
  prefs: []
  type: TYPE_NORMAL
- en: PowerView
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find the **PowerView** script within the **Recon** folder on GitHub:
    https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1.'
  prefs: []
  type: TYPE_NORMAL
- en: You can either import and load the entire **Recon** folder or you can just download
    and run the **PowerView.ps1** script, which might be easier in engagements when
    you need to execute your payloads from memory and not from disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerView has many built-in features, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration and gathering information about domains, **domain controllers**
    (**DCs**), users, groups, computers, global catalogs, directory service sites,
    and trusts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumeration of permission and access control of domain resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying where in the domain specific users are logged on and which machines
    the current user has access to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find a full overview of PowerView in the official documentation: [https://powersploit.readthedocs.io/en/latest/Recon/](https://powersploit.readthedocs.io/en/latest/Recon/).'
  prefs: []
  type: TYPE_NORMAL
- en: Invoke-Mimikatz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Mimikatz** is a well-known tool in the cybersecurity world. It helps you
    extract and reuse credentials, such as hashes or tickets from the **local security
    authority** (**LSA**), which enables red teamers to conduct a **Pass-the-Hash**
    (**PtH**) or **Pass-the-Ticket** (**PtT**) attack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mimikatz itself was written in C by Benjamin Delpy. However, Joseph Bialek
    managed to wrap it into a PowerShell script, which was included in PowerSploit,
    Nishang, and many other toolkits. I believe that the script that was hosted in
    Nishang was the latest version that I could find when writing this book: [https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1](https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: After loading the **Invoke-Mimikatz.ps1** script into the current session, you
    can just call Mimikatz’s function by executing **Invoke-Mimikatz** on the PowerShell
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the official Mimikatz documentation, please refer to the C Mimikatz version’s
    GitHub repository: https://github.com/gentilkiwi/mimikatz.'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Mimikatz is very well known by defenders and anti-malware
    solutions, so you should not just assume that **Invoke-Mimikatz** will just work
    without being detected or alerted. To make it work successfully, you will want
    to obfuscate it – and even then it will often be detected.
  prefs: []
  type: TYPE_NORMAL
- en: Empire
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PowerShell Empire** is a post-exploitation framework and was developed by
    Will Schroeder, Justin Warner, Matt Nelson, Steve Borosh, Alexander Rymdeko-Harvey,
    and Chris Ross. It is not supported any longer but still contains a lot of good
    stuff, nevertheless.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It was built to provide red teamers a platform to perform post-exploitation
    tasks, similar to Metasploit, and contains features such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to generate payloads to compromise systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility to import and use third-party tools such as Mimikatz
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Command and Control** (**C2**) server, which can be used for communication
    with compromised hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A library of post-exploitation modules that can be used for many tasks, such
    as information gathering, privilege escalation, and establishing persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Empire can be downloaded from GitHub: https://github.com/EmpireProject/Empire.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To quickly get started, there is even a QuickStart guide: https://github.com/EmpireProject/Empire/wiki/Quickstart.'
  prefs: []
  type: TYPE_NORMAL
- en: Inveigh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Inveigh** is a .NET IPv4/IPv6 machine-in-the-middle tool that was developed
    by Kevin Robertson. It was originally developed in PowerShell but later ported
    to C#, which made it available cross-platform. The latest PowerShell version of
    Inveigh is 1.506 and is no longer developed at the time of writing, but it is
    still available on GitHub. The latest C# version is 2.0.9.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main features of the PowerShell version:'
  prefs: []
  type: TYPE_NORMAL
- en: Domain Name System (DNS)/Active Directory Integrated DNS (ADIDNS)/Link-Local
    Multicast Name Resolution (LLMNR)/Multicast DNS (mDNS)/NetBIOS Name Service (NBNS)
    spoofing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inveigh can listen for and respond to LLMNR/mDNS/NBNS requests via .NET packet
    sniffing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inveigh can capture NTLMv1/NTLMv2 authentication attempts over SMB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inveigh provides HTTP/HTTPS/proxy listeners to capture incoming authentication
    requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can be downloaded from GitHub: https://github.com/Kevin-Robertson/Inveigh.'
  prefs: []
  type: TYPE_NORMAL
- en: PowerUpSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PowerUpSQL** was developed by Scott Sutherland and is a PowerShell module
    for attacking SQL servers. Although it offers a variety of possibilities, it does
    not support SQL injection yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an overview of PowerUpSQL’s capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerate SQL Server instances and databases, as well as users, roles, and permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weak configuration auditing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privilege escalation and obtaining system-level access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find this project and its documentation on GitHub: https://github.com/NetSPI/PowerUpSQL.'
  prefs: []
  type: TYPE_NORMAL
- en: AADInternals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**AADInternals**, developed by Nestori Syynimaa, is an extensive PowerShell
    module that offers a huge range of capabilities for administrating, enumerating,
    and exploiting Azure AD and Office 365 environments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of its features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerate Azure AD and Office 365 environments; review and modify permissions
    and access rights.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create backdoor users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exfiltrate credentials, such as PRTs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract or change the Azure AD connector account password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tamper with authentication options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract encryption keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create users in Azure AD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And many more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can simply install it from the PowerShell command line using **Install-Module
    AADInternals**. You can download it from PowerShell Gallery: https://www.powershellgallery.com/packages/AADInternals/.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also find this project on GitHub: https://github.com/Gerenios/AADInternals.'
  prefs: []
  type: TYPE_NORMAL
- en: Red team cookbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will find some handy code snippets for your red team engagement.
    Please also refer to [*Chapter 9*](B16679_09_Final_PD.xhtml#_idTextAnchor228),
    *Blue Team Tasks and Cookbook*, as you will find many blue teamer code snippets
    and scripts there. These can sometimes also be useful for a red teamer.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this cookbook is not a complete red team reference as this
    would fill an entire book. Rather, it intends to be a helpful source to help you
    get started with PowerShell-related red teaming.
  prefs: []
  type: TYPE_NORMAL
- en: To make it easier to understand for people starting in cybersecurity, this cookbook
    has been categorized into **MITRE ATT&CK** areas. Please note that you will not
    find *all* the MITRE ATT&CK areas in this cookbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the full MITRE ATT&CK enterprise matrix on the official MITRE
    web page: https://attack.mitre.org/matrices/enterprise/.'
  prefs: []
  type: TYPE_NORMAL
- en: Reconnaissance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, every attack starts with reconnaissance, the initial phase in which
    an adversary gathers information about a target system, network, or organization.
    Every little bit of information helps with planning the next phases of the attack
    and gaining insights and knowledge, identifying valuable targets, and executing
    a more targeted and successful attack or assessment.
  prefs: []
  type: TYPE_NORMAL
- en: Finding out whether an AAD/Entra ID user exists and viewing their cloud-specific
    details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to find out whether an Azure/Entra ID user exists and you wish to view
    their cloud-specific details. You also want to find out whether Federated Active
    Directory is in use or whether the company uses O365.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To do this, you can query one of Azure AD’s/Entra IDs APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can find more information about this API and the XML values it returns in
    [*Chapter 7*](B16679_07_Final_PD.xhtml#_idTextAnchor179), *Hacking the Cloud –
    Exploiting Azure Active* *Directory/Entra ID*.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the execution phase of an attack, the malicious activities are carried out
    by the attacker. The execution phase can be combined with other phases, such as
    executing an obfuscated PowerShell command, which is used to gather more information
    on another host.
  prefs: []
  type: TYPE_NORMAL
- en: Evading execution policies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You come across a system on which execution policies are enforced; they keep
    you from running a script, so you want to evade them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to configure an execution policy: it can be configured
    locally or via management solutions such as Group Policy. Depending on how it
    is configured, the solution differs.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As discussed in detail in [*Chapter 1*](B16679_01_Final_PD.xhtml#_idTextAnchor016),
    *Getting Started with PowerShell*, an execution policy is not a security control
    and does not keep adversaries from running malicious code. Rather, it is a feature
    to prevent users from unintentionally executing scripts. However, there are several
    ways to avoid an execution policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the execution policy was *not* enforced using Group Policy, you can easily
    set it to **Unrestricted** if you are a local administrator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are *not* a local administrator, and the execution policy was *not*
    enforced using GPO (only set locally), you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Regardless of whether you are a local administrator or not, as well as regardless
    of how the execution policy was configured, these commands will always work and
    run your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are many solutions to this problem and they are not all listed here. If
    you want to bypass an execution policy, this should not be an issue and can be
    done easily in several ways.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a PowerShell command line to execute a command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to pass a command directly to a new PowerShell session without opening
    a new shell and typing the command.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can achieve this by using **powershell.exe** with the **-c**/**-Command**
    parameter, followed by your command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The **-c** option will execute the supplied command wrapped in double quotes
    as if it were typed at the PowerShell prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding loading settings from the PowerShell user profile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PowerShell user profile contains non-desirable settings that you will want
    to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Use the **-NoProfile** or **-nop** parameter, which results in PowerShell not
    loading the PowerShell user profile. The **-nop** argument is short for **-NoProfile**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Downloading a file using PowerShell cmdlets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to download a file to a specified folder on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are multiple ways to download a file using PowerShell cmdlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Invoke-WebRequest**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all of the following examples, download the following script, which can
    be found at [https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1](https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/master/Chapter01/HelloWorld.ps1),
    and save it to the C:\Users\Administrator\Downloads\HelloWorld**.ps1** path.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download a file using **Invoke-WebRequest**, you can use the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you replace **<source>** and **<destination>** appropriately with
    the source of the file and where it should be downloaded, respectively, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to use its alias, **iwr**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Invoke-RestMethod**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also use **Invoke-RestMethod** to return the content of scripts from
    the internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Invoke-RestMethod** intends to retrieve data from **Representational State
    Transfer** (**REST**) web services. Depending on the data type, PowerShell formats
    the answer accordingly: if it’s a **JSON** or **XML** file, the content is returned
    as **[PSCustomObject]**, but it can also retrieve and return single items, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the file will not be downloaded; instead, it will be displayed
    as output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Start-BitsTransfer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To download a file using **Start-BitsTransfer**, you can use the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you replace **<source>** and **<destination>** appropriately with
    the source of the file and where it should be downloaded, respectively, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Downloading a file and executing it in memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to download a file but rather than saving it to disk, you want to execute
    it in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please be aware of the security implications: if you are downloading and executing
    a script that you don’t control, an adversary can replace the content, which can
    cause arbitrary code to be run.'
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that even though an in-memory approach may seem
    more stealthy, it does not guarantee complete stealthiness due to PowerShell’s
    security transparency and excellent event logging.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can achieve this using the following code snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Please note that in this example, we are using **Invoke-WebRequest** to download
    the script, but you can use any other option that lets you download a script as
    well. Using **Invoke-Expression** or its alias, **iex**, you can directly execute
    the script.
  prefs: []
  type: TYPE_NORMAL
- en: It is even possible to execute a command from the script that was exported when
    running the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will use the **HelloWorld.ps1** script from **Chapter01**:
    [https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1](https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how you can simply download and execute a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this example, you can download and execute **PowerView** to run the **Get-NetDomain**
    command directly, which comes with **PowerView**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Downloading and executing a file using COM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to download and execute a file from the internet using a COM object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For this example, we will use the **HelloWorld.ps1** script from **Chapter01**:
    [https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1](https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/master/Chapter01/HelloWorld.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following code snippet to achieve your goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also change the user agent of your request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Simply execute the preceding line before sending your request – of course, modify
    it first to reflect the user agent of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and executing a file using .NET classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to download and execute a file from the internet using .NET classes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are multiple ways to download a file using PowerShell cmdlets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System.Net.WebClient**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To download a file using the **System.Net.WebClient** class, you can use the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you replace **<source>** and **<destination>** appropriately with
    the source of the file and where it should be downloaded, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will use the **HelloWorld.ps1** script from **Chapter01**:
    [https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1](https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/master/Chapter01/HelloWorld.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how the **HelloWorld.ps1** script is downloaded
    in the administrator’s **Downloads** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to execute a file from the internet without actually saving it
    to a file, you can also leverage **DownloadString()**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following code to execute our script from the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this method, it is also possible to change the user agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the user agent needs to be set before *every* request.
  prefs: []
  type: TYPE_NORMAL
- en: '**System.Xml.XmlDocument**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also load an XML document and execute specific nodes. This is particularly
    useful if the commands in the nodes are encoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will use an XML file, which you can find in this book’s
    GitHub repository: [https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter08/XmlDocument-Demo.xml](https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/master/Chapter08/XmlDocument-Demo.xml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must load the URL of the XML file in the **$****Xml** variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the XML object is available, you can easily access the nodes and execute
    commands that were saved in the XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**System.NET.WebRequest**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best method for downloading and executing a script in memory only is by
    using the **System.NET.WebRequest** class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we will use the **HelloWorld.ps1** script from **Chapter01**:
    [https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter01/HelloWorld.ps1](https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/master/Chapter01/HelloWorld.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates how to create a web request to get
    the content of the **HelloWorld.ps1** script and execute it in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'By creating and sending a web request, it is also possible to set a custom
    user agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Executing C# code from PowerShell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to execute your custom C# code from PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are various ways to execute C# code from PowerShell. One of them is by
    using the **Add-Type** cmdlet to load and run your own .NET Framework classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, first, I have defined a little C# code snippet in the **$Source**
    variable. By using **Add-Type**, the C# class is loaded into memory. Now, we can
    directly access the C# function using PowerShell without the need to ever compile
    the C# code. By executing **[SayHello]::Main()**, the **Hello World!** string
    will be written to the output.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other ways to execute C# code from PowerShell. Please refer to
    [*Chapter 6*](B16679_06_Final_PD.xhtml#_idTextAnchor150), *Active Directory –
    Attacks and Mitigation*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once a system has been successfully compromised, adversaries want to establish
    persistence so that their malicious code will be automatically executed so that
    they don’t lose control over the system. Various methods can be used to establish
    persistence. We will look at some of them in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing persistence using the registry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to ensure that your PowerShell code is automatically executed on startup
    and want to use the registry for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can achieve this by creating a registry key in the **HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run**
    registry path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows how a registry key can be created to run the **C:\windows\system32\HelloWorld.ps1**
    script while using PowerShell as an autorun script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The command is stored under **NotSuspiciousAtAll**; whenever autostart is triggered,
    the script is executed using PowerShell in a noninteractive and hidden command
    line that is configured to bypass the execution policy.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing persistence using the startup folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to establish persistence by using the startup folder. Using this method,
    it is simple to establish persistence but also simple to detect it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can add your script to one of the following startup folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '**$****env:PROGRAMDATA\Microsoft\Windows\Start Menu\Programs\Startup**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$****env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**$****env:ALLUSERSPROFILE\Microsoft\Windows\Start Menu\Programs\StartUp**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can download it directly into the startup folder, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can create a new file and fill it with content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Establishing persistence using scheduled tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to establish persistence using scheduled tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use **schtasks** to create a scheduled task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The **/create** parameter indicates that you want to create a new scheduled
    task. Using **/tn**, you can specify the task name. Red teamers and adversaries
    usually try to pick a name that does not raise suspicion and that would easily
    be overlooked by a blue teamer if they were to investigate it. Using **/tr**,
    you can specify which command should be executed when this scheduled task is being
    run; **/sc** defines when the task is being executed. In this case, the task is
    scheduled every time the system starts up.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing persistence using the PowerShell profile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to establish persistence using the PowerShell profile. This method
    is harder to detect but your script will not run if **-noprofile** is specified
    whenever PowerShell starts, but using this method also means that it doesn’t trigger
    until the user runs PowerShell – which might never happen in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: PowerShell supports per-user profiles, which means each user has their own profile
    that will be loaded once they initiate a PowerShell session. These profiles are
    usually stored under C:\Users\<USERNAME>\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to add content to the current user profile, you could use **-Path
    $Profile** and add either your script or your command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a script to the current profile:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a command to execute the current profile:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To add your payload to every user profile on the current host, you could also
    iterate through all user profiles and add your script or command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, first, we’ll look for all PowerShell user profiles in the **C:\User**
    folder to iterate through them and add the **HelloWorld.ps1** script, which is
    located under **C:\windows\system32\**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, there is also a global profile that applies to all users on the
    system, which is located under **$PSHOME\Profile.ps1**. **$PSHOME** is an automatic
    variable that contains the path to the directory where PowerShell is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This command will edit the global profile and add your script to it to be executed
    whenever a PowerShell session on this host is initiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several other profiles, depending on the system or scenario. You
    can find more information on profiles in the official documentation: https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles.'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing persistence using WMI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to establish persistence by using WMI. This is one of the most covert
    methods and is also provided as a feature in PowerSploit.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To establish persistence using WMI, you could register a permanent event filter
    and consumer that will run on a system periodically unless they are unregistered.
    This section will show you how this can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a WMI event filter that specifies the events that need to occur
    to trigger the script to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the **WMIPersistenceFilter** event filter has been created.
    To create persistence, it is useful to use an event that is guaranteed to occur
    regularly. Therefore, in this example, the event will be triggered whenever the
    system time is *07:00*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a WMI command-line event consumer. This command is meant to be
    executed whenever the event filter returns data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In our example, the consumer is called **WMIPersistenceConsumer** and it is
    configured to bypass the execution policy and run the **C:\windows\system32\HelloWorld.ps1**
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, but not least, we need to *bind* them both together – that is, the filter
    and the consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now that the binding has been created, the PowerShell script will be executed
    every day at 7:00 A.M.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing persistence using Group Policy Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You compromised the DC and want to establish persistence using **Group Policy
    Objects** (**GPOs**). This has the advantage that GPOs are applied over and over
    again on all configured systems. If the GPO is not removed or altered, your payload
    will always be run on thousands of systems.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You need to create a new GPO that runs your PowerShell script or command on
    startup. This can be done using the **Group Policy Management Console** (**GPMC**)
    or PowerShell. In this example, we are using PowerShell to create the GPO:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a GPO named **PersistentScript**. Next, we add a
    Group Policy registry value in the startup folder and configure it to run our
    script via PowerShell (using the **ExecutionPolicy Bypass** parameter) every time
    the system starts. By doing so, the script will run on every system the Group
    Policy applies to at startup, regardless of how the execution policy is configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the newly created GPO only needs to be applied to one or more target
    systems. This can be done using the **New-GPLink** cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Modifying an existing GPO is also an option that attackers are likely to use
    if the permissions are not restrictive enough. While a newly created GPO might
    raise suspicion, modifying an existing GPO might fall under the radar of the blue
    team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that using GPOs as a method to establish persistence only works if you
    have the appropriate privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new user account and adding it to a group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to create a new user account and add it to a group.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are multiple ways to achieve your goal. You can, for example, use **New-LocalUser**
    in combination with **Add-LocalGroupMember** to create a new user and add it to
    an existing group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use **net.exe** to succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Defense evasion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usually, red teamers want to avoid being detected and try to hide and obfuscate
    their tracks as much as possible. This phase is known as **defense evasion**.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding creating a window on the desktop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to avoid creating PowerShell windows on the user’s desktop when executing
    PowerShell commands and scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can achieve this by using **-w hidden** to determine **WindowStyle**, which
    is short for **-WindowStyle**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Executing a Base64-encoded command using powershell.exe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to supply a Base64-encoded command as a command-line argument.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A Base64-encoded string can be executed in PowerShell using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The **-e** parameter (short for **-EncodedCommand**) allows you to supply a
    Base64-encoded command directly as a command-line argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just replace **<Base64 string>** with your Base64-encoded command, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the Base64-encoded string would be executed in PowerShell,
    and **“Hello World!”** would be written to the command line. This is because this
    Base64 string translates to **"Write-Host '****Hello World!'"**.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a string into a Base64 string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to convert a string into a Base64 string to obfuscate your commands.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can convert a string into a Base64 string by using the following code snippet;
    just replace **<text>** with the string that you want to convert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example would convert the **"Write-Host ''Hello World!''"** string
    into a Base64 string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we converted a Unicode string into a Base64 string.
    It is also possible to convert an ASCII string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Converting a Base64 string into a human-readable string
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to convert a Base64 string back into a human-readable format.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use the following code snippet to convert a Base64 string back into
    a human-readable string. Replace **"<Base64 string>"** with the actual Base64
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates how the **"VwByAGkAdABlAC0ASABvAHMAdAAgACc**
    **ASABlAGwAbABvACAAVwBvAHIAbABkACEAJwA="** string would be translated back into
    a human-readable format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This would result in the **"Write-Host 'Hello** **World!'"** string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, an ASCII string is encoded into a Base64 string. If you were to use
    Unicode to decode the string, you would not receive the desired output, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – If you are not using the correct format, you will get a corrupted
    output](image/B16679_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – If you are not using the correct format, you will get a corrupted
    output
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to convert a Base64 string back into an ASCII string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This would also result in the **"Write-Host 'Hello** **World!'"** string.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a downgrade attack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to bypass security mechanisms such as event logging that were introduced
    with newer PowerShell versions and therefore want to run a downgrade attack.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A downgrade attack can be executed by specifying PowerShell’s version number
    when running **powershell.exe**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If the specified version is installed, the command will run while using the
    deprecated binary, which implies that only security features that were already
    introduced to this version are applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to run **powershell.exe -version 2** and you get an error message
    similar to the one shown in the following code snippet, stating that version 2
    of .NET Framework is missing, that means that .NET Framework 2.0 hasn’t been installed
    on the system yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '.NET Framework 2.0 can be installed manually. To evaluate whether PowerShell
    version 2 is enabled or disabled, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this example, it seems like PowerShell version 2 is still enabled on this
    machine. So, if the missing .NET Framework 2.0 were to be installed, this system
    would be vulnerable to a downgrade attack.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling Microsoft Defender
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to disable Microsoft Defender and most of its security features.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use **Set-MpPreference** to achieve your goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This command disables real-time monitoring, intrusion prevention systems, **Internet
    Outbound AntiVirus** (**IOAV**) protection, and script scanning. It sets network
    protection to Audit Mode only (so that it’s not enforced any longer), disables
    **Microsoft Active Protection Service** (**MAPS**) reporting, sets the consent
    to never send samples, and disables controlled folder access. The **-Force** parameter
    ensures that the changes are applied without additional prompts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to the **Set-MpPreference** documentation if you want to tamper
    with features other than the ones shown in this example: https://learn.microsoft.com/en-us/powershell/module/defender/set-mppreference.'
  prefs: []
  type: TYPE_NORMAL
- en: Clearing logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to clear all event logs, regardless of which PowerShell version is
    deployed on the target system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can clear all event logs by using the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Credential access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The credential access phase is all about stealing credentials (for example,
    usernames and passwords). Those credentials can be used later to move laterally
    and authenticate against other targets.
  prefs: []
  type: TYPE_NORMAL
- en: Exfiltrating the ntds.dit file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to exfiltrate the **ntds.dit** file, which contains all identities
    and hashes within Active Directory.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As the **ntds.dit** file is constantly used by Active Directory and therefore
    locked, you need to find a way to access **ntds.dit**. One way is to create a
    shadow copy, create a symbolic link, and extract the file from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now access the **ntds.dit** file without errors and either extract
    it or proceed with extracting identities. In this example, we will simply copy
    it to **C:\tmp** for further use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve done this, you can delete the symbolic link and proceed with your
    penetration test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The discovery phase is similar to the reconnaissance phase: its goal is to
    gather as much information as possible about potential targets. The discovery
    phase usually occurs after a red teamer has gained access to a system and plans
    their next steps.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding out which user is currently logged on
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to find out which user is currently logged on and want to display their
    username and domain (or computer name if it’s a local account).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To achieve your goal, you can use the **whoami** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Enumerating users (local and domain)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to find out which user accounts exist on the current system or in the
    current domain.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Depending on your goal, there are multiple ways to enumerate users.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use WMI/CIM to enumerate all users, regardless of whether they are
    local or domain users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To enumerate local users only, you can use **Get-LocalUser** or **net users**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'There are multiple ways to enumerate domain users only. If the **ActiveDirectory**
    module is present, you can use **Get-ADUser**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'But in most cases, the **ActiveDirectory** module will not be present, so you
    can leverage **adsisearcher** to enumerate all domain users instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to use **net** to enumerate all domain users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Enumerating groups (local and domain)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to find out which local or domain groups exist.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Depending on whether you want to enumerate local or domain groups, there are
    multiple ways to achieve your goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use WMI/CIM to enumerate all groups, regardless of whether they are
    local or domain groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'To enumerate local groups only, you can use **Get-LocalGroup** or **net localgroups**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'There are multiple ways to enumerate domain users only. If the **ActiveDirectory**
    module is present, you can use **Get-ADGroup**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is not the case most of the time, you can also leverage **net**
    to find out which domain groups exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use **adsisearcher** to enumerate all domain groups, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving information about the current system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to retrieve information about the current system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using the **hostname** command, you can find out the hostname of the current
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the **systeminfo** command, you can retrieve detailed system configuration
    information about the current machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '**Systeminfo** lets you collect various pieces of information about the current
    system, such as hardware properties, the current operating system version, hostname,
    BIOS version, boot time, and much more valuable information.'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating network-related information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to learn more about the network-related information of the current
    system. What is its IP address and which other devices are connected to the current
    machine?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use the following commands to enumerate network-related information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '**ipconfig /all** displays detailed information about all network interfaces
    (including IP addresses, subnet masks, default gateways, DNS servers, and more)
    configured on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Using **Get-NetAdapter**, you can retrieve information about network adapters
    and their properties, such as their interface index, name, MAC address, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '**route print** displays the routing table on the system and shows the network
    destinations, associated gateway addresses, and interface information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '**arp -a** displays the **Address Resolution Protocol** (**ARP**) cache, which
    contains mappings of IP addresses to MAC addresses for devices on the local network.
    By doing this, you can easily find out potential targets for lateral movement.'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating domain information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to enumerate the current domain and want to find out more about the
    forest and the domain and forest trusts.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can leverage the **System.DirectoryServices.ActiveDirectory** namespace
    to enumerate the current domain and forest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The **GetCurrentDomain()** command retrieves the current domain object in Active
    Directory and returns information such as the domain name, domain controllers,
    and other properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The **GetCurrentDomain()).GetAllTrustRelationships()** command retrieves all
    trust relationships established by the current domain in Active Directory, providing
    information about trusted domains and their properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The **GetCurrentForest()** command retrieves the current forest object in Active
    Directory and returns information such as the forest name, domain trees, and other
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command retrieves all trust relationships for a specific forest
    in Active Directory and provides information about trusted domains within that
    forest, as well as their properties.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating domain controllers (DCs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to enumerate the DCs of a domain and find out which DC was used for
    the current authenticated session.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use **nltest** to query and list all DCs available in the specified
    domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve and display a list of all DCs in the current domain, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine which DC was used to authenticate the current session, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Listing installed antivirus (AV) products
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to list all AV products that were installed on the current system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can enumerate all installed AV products by using WMI/CIM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Lateral movement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once an initial foothold has been achieved, a red teamer usually tries to move
    laterally from one host to another, exploring and exploiting additional targets
    within the network. Lateral movement allows the attacker to explore the network,
    escalate privileges, access valuable resources, and ultimately gain control over
    critical systems or data.
  prefs: []
  type: TYPE_NORMAL
- en: Executing a single command or binary on a remote machine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to execute a single command or binary on a remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To execute a single command or binary on a remote (or local) machine, you can
    leverage **Invoke-Command**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how you can execute the **Get-Process** cmdlet,
    as well as the **mimikatz.exe** binary, on the remote host, **PSSec-PC01**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: If you want to use **Invoke-Command** against an IP address, ensure that the
    remote host’s IP is present in **TrustedHosts** and is configured for remote access.
  prefs: []
  type: TYPE_NORMAL
- en: Initiating a remote interactive PowerShell session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to initiate a remote PowerShell session in which you can interactively
    run PowerShell commands.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use **Enter-PSSession** to initiate an interactive remote PowerShell
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we would establish a PowerShell session to the remote host, **PSSec-PC01**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Command and Control (C2)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this phase, the red teamer is trying to communicate with its victim hosts
    to control them.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a reverse shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to open a reverse shell on a remote system.
  prefs: []
  type: TYPE_NORMAL
- en: A reverse shell is a shell that a red teamer can use to establish a connection
    to a remote system without the need to initiate a remote session. In the case
    of a reverse shell, usually, a payload is somehow stored on the victim system.
    Once the payload is executed, the victim establishes the connection back to the
    server that was specified by the red teamer, on which usually a listener is listening
    for incoming connections.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To reproduce this using PowerShell, first, create and start a listener on your
    C2 server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Once the listener has been started, it waits for a connection, which it accepts
    immediately, and stores the session in the **$****client** variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have the **victim machine** execute your payload. This could look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a new TCP socket, connects to the server on the **172.29.0.20**
    IP address on port **4444**, and waits for input once connected. The client can
    now either read incoming commands or write to the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, on the C2 server, you can now send commands over the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the connection needs to be terminated, just send the following command
    from the C2 server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find this code in this chapter’s GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Client: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter08/RevShell_Client.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter08/RevShell_Client.ps1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Server: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter08/RevShell_Server.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter08/RevShell_Server.ps1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, there are also tools such as PowerShell Empire and Metasploit that
    already have modules to generate payloads automatically and open a reverse shell.
  prefs: []
  type: TYPE_NORMAL
- en: Exfiltration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the exfiltration phase, the red teamer tries to steal and exfiltrate data
    from the victim’s network.
  prefs: []
  type: TYPE_NORMAL
- en: Exfiltrating a file and uploading it to a web server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to exfiltrate the content of a file and upload it to a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can achieve your goal by reading the bytes of the desired file, converting
    them into a **Base64** string, and uploading them to a web server using **Invoke-WebRequest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are uploading the Base64-encoded **ntds.dit** file that
    we extracted earlier as a shadow copy to **http://PSSec-example.com/upload** (which
    does not exist; we just made up for this example).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use the **System.NET.WebClient** class to extract and
    upload a file. The following code snippet demonstrates how this could be achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Impact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recipes in the impact phase are determined to cause mayhem; the red teamer is
    trying to interrupt, destroy, or manipulate systems or data.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to stop a service.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To do this, you can use the **Stop-Service** cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: If executed, the preceding command would stop the **Spooler** service. By using
    the **-Force** parameter, the service will be stopped abruptly without prompting
    for confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: Shutting down a system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You want to shut down a system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can achieve your goal using several methods. One of them is by using the
    **Stop-Computer** cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Using the **-ComputerName** parameter, you can specify whether the local or
    a remote host should be shut down.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the **shutdown** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The **/s** parameter indicates that the system will be shut down. The **/t**
    parameter indicates how many seconds will pass until the command is executed.
    In this case, the system is shut down immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the different phases of an attack. You were
    provided with an overview of common PowerShell red team tools and were presented
    with a red team cookbook, which can help you during your next red team engagements.
  prefs: []
  type: TYPE_NORMAL
- en: This red team cookbook contained many helpful code snippets that helped you
    learn about a bunch of important options when using **powershell.exe**, how to
    create obfuscation using Base64, how to download files, and how to execute scripts
    in memory only. You were reminded of how to execute commands on remote machines,
    as well as how to open a session.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at several options regarding how persistence can be established using
    PowerShell and how a downgrade attack can be performed. You also got a refresher
    on how in-memory injection works and how to open a reverse shell without any of
    the common red teaming tools. Last but not least, you learned how to clear logs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored various red teamer tasks and recipes, in the next chapter,
    we’ll explore blue team and infosec practitioner tasks and recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to explore some of the topics that were mentioned in this chapter,
    take a look at these resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abusing WMI to build a persistent asynchronous and** **fileless backdoor**:'
  prefs: []
  type: TYPE_NORMAL
- en: https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor-wp.pdf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://www.blackhat.com/docs/us-15/materials/us-15-Graeber-Abusing-Windows-Management-Instrumentation-WMI-To-Build-A-Persistent%20Asynchronous-And-Fileless-Backdoor.pdf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**New-GPLink**:'
  prefs: []
  type: TYPE_NORMAL
- en: https://learn.microsoft.com/en-us/powershell/module/grouppolicy/new-gplink
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PowerUpSQL**:'
  prefs: []
  type: TYPE_NORMAL
- en: https://github.com/NetSPI/PowerUpSQL/wiki/PowerUpSQL-Cheat-Sheet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://github.com/NetSPI/PowerUpSQL/wiki
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find all the links mentioned in this chapter in the GitHub repository
    for [*Chapter 8*](B16679_08_Final_PD.xhtml#_idTextAnchor204) – there’s no need
    to manually type in every link: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter08/Links.md](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter08/Links.md).'
  prefs: []
  type: TYPE_NORMAL
