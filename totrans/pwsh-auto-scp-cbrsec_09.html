<html><head></head><body>
		<div id="_idContainer198">
			<h1 class="chapter-number" id="_idParaDest-218"><a id="_idTextAnchor228"/>9</h1>
			<h1 id="_idParaDest-219"><a id="_idTextAnchor229"/>Blue Team Tasks and Cookbook</h1>
			<p>As a member of the blue team, your primary goal is to protect your organization’s systems and networks from cyber threats. However, this is no easy task. The threat landscape is constantly evolving, and you may be faced with challenges such as managing and analyzing large amounts of data, coordinating with other teams, and ensuring compliance <span class="No-Break">with regulations.</span></p>
			<p>In this chapter, we’ll first take a closer look at the <em class="italic">protect, detect, and respond</em> approach and some of the challenges that blue teamers face. Next, we will explore an overview of some useful open source tools written in PowerShell that can help you in your daily practice as a blue teamer. Finally, we will look at the blue team cookbook, a collection of PowerShell snippets that can come in handy in your daily work as a blue <span class="No-Break">team practitioner.</span></p>
			<p>In this chapter, we will discuss the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding the protect, detect, and <span class="No-Break">respond approach</span></li>
				<li>Common PowerShell blue <span class="No-Break">team tools</span></li>
				<li>The blue <span class="No-Break">team cookbook</span></li>
			</ul>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor230"/>Technical requirements</h1>
			<p>To get the most out of this chapter, ensure that you have <span class="No-Break">the following:</span></p>
			<ul>
				<li>Windows <span class="No-Break">PowerShell 5.1</span></li>
				<li>PowerShell 7.3 <span class="No-Break">and above</span></li>
				<li>Visual <span class="No-Break">Studio Code</span></li>
				<li>Access to the GitHub repository for <span class="No-Break">this chapter:</span></li>
			</ul>
			<p><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter09"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter09</span></a><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/tree/master"/></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor231"/>Protect, detect, and respond</h1>
			<p>Being a<a id="_idIndexMarker1652"/> blue<a id="_idIndexMarker1653"/> teamer is not an easy thing to do. You need to constantly keep up with the evolving threat landscape and stay up to date. While a red teamer needs to find just one single vulnerability to be successful, a blue teamer needs to watch for everything, as one little error already means that your network could <span class="No-Break">be compromised.</span></p>
			<p>Blue teamers not only need to configure and manage their systems but also analyze large amounts of data and coordinate with other teams. They need to ensure compliance with regulations and standards. And while they do all that, they need to keep the right balance between security and usability, ensuring that their users don’t get overwhelmed with all the security measures and try to bypass them <span class="No-Break">by themselves.</span></p>
			<p>To help keep track of <a id="_idIndexMarker1654"/>everything that <a id="_idIndexMarker1655"/>needs to be taken into account, categorizing tasks into <strong class="bold">protect</strong>, <strong class="bold">detect</strong>, and <strong class="bold">respond</strong> types <a id="_idIndexMarker1656"/>can help. This is an approach <a id="_idIndexMarker1657"/>to secure your organization’s systems, as well as its network. It is structured into three different areas – protection, detection, and response. Every pillar is of equal importance to keep your <span class="No-Break">infrastructure safe.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer195">
					<img alt="Figure 9.1 – The protect, detect, and respond approach" src="image/B16679_09_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The protect, detect, and respond approach</p>
			<p>Many companies just focus on the protection part, although detection and response are also very important to keep adversaries out of <span class="No-Break">your network.</span></p>
			<p>Let’s explore what each area covers in the <span class="No-Break">following subsections.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor232"/>Protection</h2>
			<p>The goal of <strong class="bold">protection</strong> measures<a id="_idIndexMarker1658"/> is to mitigate security risks and implement controls to reduce and block threats <em class="italic">before they happen</em>. Protection measures could include <span class="No-Break">the following:</span></p>
			<ul>
				<li>Regularly updating systems and monitoring them to fix vulnerabilities that could be exploited <span class="No-Break">by attackers.</span></li>
				<li>Implementing user authentication and authorization to ensure that only authorized users have access to data and systems. The least privilege approach also needs to <span class="No-Break">be followed.</span></li>
				<li>Encrypting sensitive data to minimize the risk of it being accessed by unauthorized users. Encrypt hard drives to avoid credential theft from a person that has physical access or even data theft if a device <span class="No-Break">was stolen.</span></li>
				<li>Implementing security policies, baselines, and access control to ensure that systems are configured as safely as possible. A strong password policy also needs to <span class="No-Break">be introduced.</span></li>
				<li>Deploying firewalls <a id="_idIndexMarker1659"/>and <strong class="bold">intrusion detection systems</strong> (<strong class="bold">IDSs</strong>)/intrusion <strong class="bold">prevention systems</strong> (<strong class="bold">IPSs</strong>) to block unauthorized <a id="_idIndexMarker1660"/>activities and detect <span class="No-Break">suspicious activities.</span></li>
			</ul>
			<p>Of course, protection mechanisms could also have a second purpose, such as an IDS or IPS, which not only blocks suspicious activities but also detects and alerts you to them. Therefore, this solution could also be a part of the <span class="No-Break"><strong class="bold">detection</strong></span><span class="No-Break"> area.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor233"/>Detection</h2>
			<p>In the <a id="_idIndexMarker1661"/>detection phase, the<a id="_idIndexMarker1662"/> goal is to identify and report potential security threats as quickly as possible. There are various things that you can do to improve your detection stance, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>Collecting and analyzing event logs about potential security breaches, such as failed login attempts or <span class="No-Break">configuration changes.</span></li>
				<li>Monitoring network activity for anomalies and suspicious behavior, such as users that are logging in to machines that they usually never log in to or attempts to access restricted resources. Another example would be if PowerShell (or other) code was executed from a workstation of a person that usually never runs code, such as employees from accounting <span class="No-Break">or marketing.</span></li>
				<li>Evaluating <a id="_idIndexMarker1663"/>security alerts from antivirus software <span class="No-Break">and IDSs/IPSs.</span></li>
				<li>Regularly<a id="_idIndexMarker1664"/> scanning your network for vulnerabilities to identify potential weaknesses that could be abused by adversaries. Also, periodically hire external penetration testers to check <span class="No-Break">your security.</span></li>
			</ul>
			<p>Implementing good detection measures will help you raise your awareness of what happens in your network. This allows you to act on potential security threats in the <span class="No-Break">response phase.</span></p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor234"/>Response</h2>
			<p>If a <a id="_idIndexMarker1665"/>security threat<a id="_idIndexMarker1666"/> was detected, it means that you need to act on it quickly to reduce the risk and restore systems to a secure state. This can involve a variety of activities, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>Isolating compromised systems to prevent further damage and the threat spreading within <span class="No-Break">an environment.</span></li>
				<li>Gathering forensic data from affected systems and analyzing it. This helps to identify the attack source and determine the extent of the damage. It can also help to mitigate <span class="No-Break">future threats.</span></li>
				<li>Restoring systems to a secure state, which may involve repairing or reinstalling them in accordance <a id="_idIndexMarker1667"/>with the NIST <strong class="bold">Cybersecurity Framework</strong> (NIST <span class="No-Break"><strong class="bold">CSF</strong></span><span class="No-Break">) guidelines:</span></li>
			</ul>
			<p><a href="https://www.nist.gov/cyberframework/framework"><span class="No-Break">https://www.nist.gov/cyberframework/framework</span></a></p>
			<ul>
				<li>Implementing additional security controls to prevent similar threats in <span class="No-Break">the future.</span></li>
			</ul>
			<p>All three pillars combined build the protect, detect, and respond life cycle and should always be <a id="_idIndexMarker1668"/>focused on<a id="_idIndexMarker1669"/> with <span class="No-Break">equal importance.</span></p>
			<p>There are also many open source tools that can support a blue teamer to pursue the protect, detect, and respond approach. In the next section, we will explore some <span class="No-Break">of them.</span></p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor235"/>Common PowerShell blue team tools</h1>
			<p>As a<a id="_idIndexMarker1670"/> blue teamer, you are constantly on the lookout for tools and techniques that can help you protect your organization’s systems and networks from <span class="No-Break">cyber threats.</span></p>
			<p>In this section, we’ll <a id="_idIndexMarker1671"/>explore some common PowerShell open source tools that can be particularly helpful for blue teamers. These tools can assist with tasks such as analyzing system logs, gathering system information, and detecting malicious activity. Some of the tools can also help with tasks such as analyzing the attack surface of a system, identifying and decoding potentially malicious data, and searching for indicators of compromise. By leveraging these tools, you can streamline your workflows and more effectively defend your organization against <span class="No-Break">cyber threats.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor236"/>PSGumshoe</h2>
			<p><strong class="bold">PSGumshoe</strong> is a <a id="_idIndexMarker1672"/>powerful PowerShell module that is<a id="_idIndexMarker1673"/> designed to assist with tasks such as live response, hunt, and forensics. Developed by Carlos Perez, this open source tool is designed to help blue teamers collect artifacts from a variety of sources. Whether you are investigating a security incident, conducting a hunt for indicators of compromise, or performing forensic analysis, PSGumshoe can be a valuable asset in your toolkit. It also has functions included to support retrieving data from Sysmon-generated <a id="_idIndexMarker1674"/>events or to track <strong class="bold">Windows Management Instrumentation</strong> (<span class="No-Break"><strong class="bold">WMI</strong></span><span class="No-Break">) activity.</span></p>
			<p>You can install PSGumshoe from PowerShell Gallery using the <strong class="source-inline">Install-Module PSGumshoe</strong> command<a id="_idIndexMarker1675"/> or download it from <span class="No-Break">GitHub: </span><a href="https://github.com/PSGumshoe/PSGumshoe"><span class="No-Break">https://github.com/PSGumshoe/PSGumshoe</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor237"/>PowerShellArsenal</h2>
			<p><strong class="bold">PowerShellArsenal</strong> is a<a id="_idIndexMarker1676"/> PowerShell module<a id="_idIndexMarker1677"/> developed by Matt Graeber that is designed to assist reverse engineers in a variety of tasks. With its wide range of features and capabilities, this tool can help you disassemble code, perform .NET malware analysis, analyze and parse memory structures, and much more. Whether you are a seasoned reverse engineer or just starting out, PowerShellArsenal can be a valuable addition to <span class="No-Break">your toolkit.</span></p>
			<p>It can be downloaded<a id="_idIndexMarker1678"/> and installed as a module from <span class="No-Break">GitHub: </span><a href="https://github.com/mattifestation/PowerShellArsenal"><span class="No-Break">https://github.com/mattifestation/PowerShellArsenal</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor238"/>AtomicTestHarnesses</h2>
			<p><strong class="bold">AtomicTestHarnesses</strong> is a <a id="_idIndexMarker1679"/>PowerShell module that allows you to simulate and validate the execution of attack techniques. With a<a id="_idIndexMarker1680"/> PowerShell component for Windows and a Python component for macOS and Linux, this tool can be used <span class="No-Break">across platforms.</span></p>
			<p>Developed by Mike Haag, Jesse Brown, Matt Graeber, Jonathan Johnson, and Jared Atkinson, AtomicTestHarnesses is a valuable resource for blue teamers who are looking to test their defenses and ensure that they are prepared to respond to <span class="No-Break">real-world attacks.</span></p>
			<p>You can easily install <a id="_idIndexMarker1681"/>AtomicTestHarnesses from the PowerShell gallery using the <strong class="source-inline">Install-Module -Name AtomicTestHarnesses</strong> command, or you can download it from GitHub at the following <span class="No-Break">link: </span><a href="https://github.com/redcanaryco/AtomicTestHarnesses"><span class="No-Break">https://github.com/redcanaryco/AtomicTestHarnesses</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor239"/>PowerForensics</h2>
			<p><strong class="bold">PowerForensics</strong> is a<a id="_idIndexMarker1682"/> powerful framework for hard <a id="_idIndexMarker1683"/>drive forensics developed by Jared Atkinson. Currently <a id="_idIndexMarker1684"/>supporting <strong class="bold">NTFS</strong> (<strong class="bold">New Technology File System</strong>) and <strong class="bold">FAT </strong>(<strong class="bold">File Allocation Table</strong>) file <a id="_idIndexMarker1685"/>systems, this tool is designed to assist with tasks such as analyzing Windows artifacts, the Windows registry, boot sector, and application compatibility cache, as well as creating a <span class="No-Break">forensic timeline.</span></p>
			<p>With its <a id="_idIndexMarker1686"/>extensive <a id="_idIndexMarker1687"/>range of features and capabilities, PowerForensics is an invaluable resource for blue teamers who need to conduct forensic analysis on hard drives. You can easily install PowerForensics from the PowerShell <a id="_idIndexMarker1688"/>gallery using the <strong class="source-inline">Install-Module PowerForensics</strong> command, or you can download it from GitHub at the following <span class="No-Break">link: </span><a href="https://github.com/Invoke-IR/PowerForensics"><span class="No-Break">https://github.com/Invoke-IR/PowerForensics</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor240"/>NtObjectManager</h2>
			<p><strong class="bold">NtObjectManager</strong> is an <a id="_idIndexMarker1689"/>extensive PowerShell module <a id="_idIndexMarker1690"/>that allows you to access the NT Object Manager namespace. It is part of the sandbox attack surface analysis tools toolkit (which is also definitely worth a look!) that was developed by James Forshaw. The Object Manager itself is a subsystem within Windows that is responsible for managing the system’s objects, which represent various system resources such as processes, threads, files, <span class="No-Break">and devices.</span></p>
			<p>The Object Manager is also in charge of creating and deleting objects, as well as maintaining the relationships between objects. It also handles object access requests, ensuring that only authorized entities are able to access specific objects. The Object Manager is an integral part of the operating system and is involved in many aspects of system operation, including memory management, process and thread management, and <span class="No-Break">I/O operations.</span></p>
			<p>The NTObjectManager module offers a wide variety of capabilities, including working with symbolic links, auditing RPC servers, manipulating the Object Manager, and generally messing around with the Windows <span class="No-Break">operating system.</span></p>
			<p>NtObjectManager can be<a id="_idIndexMarker1691"/> easily installed using the <strong class="source-inline">Install-Module -Name NtObjectManager</strong> command, and the source code can be found on GitHub at the following <span class="No-Break">link: </span><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools"><span class="No-Break">https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor241"/>DSInternals</h2>
			<p><strong class="bold">DSInternals</strong> is a <a id="_idIndexMarker1692"/>powerful Active Directory suite developed by<a id="_idIndexMarker1693"/> Michael Grafnetter that consists of two parts – a framework that exposes various internal components of Active Directory that can be accessed from any .NET application, and a PowerShell module that provides a range of cmdlets built on top of the framework. The module offers extensive functionality, including the ability to audit Azure AD FIDO2 keys, AD passwords, and key credentials, and perform bare-metal recovery of <span class="No-Break">domain controllers.</span></p>
			<p>DSInternals can be easily installed using the <strong class="source-inline">Install-Module DSInternals</strong> command, or you can <a id="_idIndexMarker1694"/>download it from GitHub at the following <span class="No-Break">link: </span><a href="https://github.com/MichaelGrafnetter/DSInternals"><span class="No-Break">https://github.com/MichaelGrafnetter/DSInternals</span></a><span class="No-Break">.</span></p>
			<p>With its many features and capabilities, DSInternals is a valuable resource for blue teamers who need to manage and secure their Active <span class="No-Break">Directory environment.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor242"/>PSScriptAnalyzer and InjectionHunter</h2>
			<p><strong class="bold">PSScriptAnalyzer</strong> is a<a id="_idIndexMarker1695"/> tool that helps you <a id="_idIndexMarker1696"/>improve the quality and security of your PowerShell scripts and modules. It checks your code against predefined rules and provides recommendations for any potential defects it finds. You can install PSScriptAnalyzer using the <strong class="source-inline">Install-Module PSScriptAnalyzer</strong> command, or you can download it from GitHub at the<a id="_idIndexMarker1697"/> following <span class="No-Break">link: </span><a href="https://github.com/PowerShell/PSScriptAnalyzer"><span class="No-Break">https://github.com/PowerShell/PSScriptAnalyzer</span></a><span class="No-Break">.</span></p>
			<p><strong class="bold">InjectionHunter</strong> is a <a id="_idIndexMarker1698"/>module developed by <a id="_idIndexMarker1699"/>Lee Holmes that helps you detect potential opportunities for code injection in your own PowerShell scripts. To use InjectionHunter, you need to have PSScriptAnalyzer installed, as it relies on the <strong class="source-inline">ScriptAnalyzer.Generic.DiagnosticRecord</strong> output type and uses custom detection rules. You can install InjectionHunter using the <strong class="source-inline">Install-Module InjectionHunter</strong> command, or <a id="_idIndexMarker1700"/>you can find it in the PowerShell Gallery at the following <span class="No-Break">link: </span><a href="https://www.powershellgallery.com/packages/InjectionHunter/1.0.0"><span class="No-Break">https://www.powershellgallery.com/packages/InjectionHunter/1.0.0</span></a><span class="No-Break">.</span></p>
			<p>Also refer to the official blog post on<a id="_idIndexMarker1701"/> <span class="No-Break">InjectionHunter: </span><a href="https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/"><span class="No-Break">https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/</span></a><span class="No-Break">.</span></p>
			<p>Later in <a href="B16679_13_Final_PD.xhtml#_idTextAnchor341"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">What Else? – Further Mitigations and Resources</em>, we will also take a closer look at both tools and how they can <span class="No-Break">be used.</span></p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor243"/>Revoke-Obfuscation</h2>
			<p><strong class="bold">Revoke-Obfuscation</strong> is a <a id="_idIndexMarker1702"/>PowerShell obfuscation <a id="_idIndexMarker1703"/>detection framework developed by Daniel Bohannon and Lee Holmes. Compatible with PowerShell v3 and later, this tool helps blue teamers detect obfuscated PowerShell scripts and commands at scale. Unlike other solutions that rely on simple <strong class="bold">indicators of compromise</strong> (<strong class="bold">IOCs</strong>) or regular expression matching, Revoke-Obfuscation uses PowerShell’s <strong class="bold">abstract syntax tree</strong> (<strong class="bold">AST</strong>) to extract features from a script, making it more robust in detecting even unknown <span class="No-Break">obfuscation techniques.</span></p>
			<p>You can easily install <a id="_idIndexMarker1704"/>Revoke-Obfuscation using the <strong class="source-inline">Install-Module Revoke-Obfuscation</strong> command, or you can download it from GitHub at the following <span class="No-Break">link: </span><a href="https://github.com/danielbohannon/Revoke-Obfuscation"><span class="No-Break">https://github.com/danielbohannon/Revoke-Obfuscation</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor244"/>Posh-VirusTotal</h2>
			<p>As a defender, it’s <a id="_idIndexMarker1705"/>critical to regularly check files, domains, IPs, and URLs for malware. One popular service to do this is <strong class="bold">VirusTotal</strong> (<a href="https://www.virustotal.com">https://www.virustotal.com</a>), which <a id="_idIndexMarker1706"/>allows you to quickly check <a id="_idIndexMarker1707"/>whether a file hash or URL is considered malicious and whether it would be detected by one or more security vendors. However, manually uploading each file or checking URLs one by one can be time-consuming <span class="No-Break">and tedious.</span></p>
			<p>That’s where the PowerShell <a id="_idIndexMarker1708"/>module <strong class="bold">Posh-VirusTotal</strong> comes in. Developed by Carlos Perez, this tool enables you to automate your VirusTotal submissions and save time in your busy schedule. It’s compatible with PowerShell v3 and higher and can use either the public or private version 2 API provided <span class="No-Break">by VirusTotal.</span></p>
			<p>You can easily install Posh-VirusTotal using the <strong class="source-inline">Install-Module Posh-VirusTotal</strong> command, or <a id="_idIndexMarker1709"/>you can download it from GitHub at the following <span class="No-Break">link: </span><span class="No-Break">https://github.com/darkoperator/Posh-VirusTotal</span><span class="No-Break">.</span></p>
			<p>If you’re using an older version of PowerShell, such as v3, you can also install Posh-VirusTotal using the <strong class="source-inline">iex (New-Object </strong><span class="No-Break"><strong class="source-inline">Net.WebClient).DownloadString("https://gist.githubusercontent.com/darkoperator/9138373/raw/22fb97c07a21139a398c2a3d6ca7e3e710e476bc/PoshVTInstall.ps1")</strong></span><span class="No-Break"> command.</span></p>
			<p>With Posh-VirusTotal, you can streamline your malware checks and stay one step ahead <span class="No-Break">of threats.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor245"/>EventList</h2>
			<p><strong class="bold">EventList</strong> is<a id="_idIndexMarker1710"/> a <a id="_idIndexMarker1711"/>useful tool that I developed to help you improve your audit capabilities and build a more effective <strong class="bold">security operations center</strong> (<strong class="bold">SOC</strong>). Developed <a id="_idIndexMarker1712"/>to combine Microsoft security baselines with MITRE ATT&amp;CK, EventList enables you to generate hunting queries for your SIEM system, regardless of the product <span class="No-Break">you use.</span></p>
			<p>By leveraging the power of EventList, you can take a proactive approach to detecting and responding to <span class="No-Break">security threats.</span></p>
			<p>It can be<a id="_idIndexMarker1713"/> installed using the <strong class="source-inline">Install-Module EventList</strong> command or downloaded from <span class="No-Break">GitHub: </span><a href="https://github.com/miriamxyra/EventList"><span class="No-Break">https://github.com/miriamxyra/EventList</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor246"/>JEAnalyzer</h2>
			<p><strong class="bold">Just Enough Administration</strong> (<strong class="bold">JEA</strong>) is a <a id="_idIndexMarker1714"/>powerful tool to secure the<a id="_idIndexMarker1715"/> PowerShell commands<a id="_idIndexMarker1716"/> that administrators and users are allowed to use in your environment. However, configuring and auditing JEA roles can be a tedious and time-consuming task. That’s where JEAnalyzer <span class="No-Break">comes in.</span></p>
			<p>Developed by Miriam Wiesner and Friedrich Weinmann, this tool simplifies the implementation and management of JEA, as well as providing tools to scan commands for potential danger when exposed in a JEA endpoint and creating JEA endpoints simply <span class="No-Break">and conveniently.</span></p>
			<p>You can easily<a id="_idIndexMarker1717"/> install JEAnalyzer using the <strong class="source-inline">Install-Module JEAnalyzer</strong> command, or you can download it from GitHub at the following <span class="No-Break">link: </span><span class="No-Break">https://github.com/PSSecTools/JEAnalyzer</span><span class="No-Break">.</span></p>
			<p>All these PowerShell modules come in very handy for blue teamers, as they can assist in tasks such as live response, hunt, forensics, and reverse engineering. These tools can help streamline workflows and defend against cyber threats by analyzing system logs, gathering system information, detecting malicious activity, analyzing attack surfaces, identifying and decoding potentially malicious data, searching for indicators of compromise, and many more <span class="No-Break">use cases.</span></p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor247"/>Blue team cookbook</h1>
			<p>In the following <a id="_idIndexMarker1718"/>subsections, you will find some code snippets that come in handy for your daily life as a blue team PowerShell practitioner. Blue teaming is quite extensive; therefore, you won’t find use cases for every scenario but, rather, some of <span class="No-Break">the basics.</span></p>
			<p>Also, refer to <a href="B16679_08_Final_PD.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Red Team Tasks and Cookbook</em>, as you will find many red teamer code snippets and scripts there that can also sometimes be useful for a <span class="No-Break">blue teamer.</span></p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor248"/>Checking for installed updates</h2>
			<p>You<a id="_idIndexMarker1719"/> want to find out which updates were installed on one or more <span class="No-Break">remote systems.</span></p>
			<h3>Solution</h3>
			<p>You can use the <strong class="source-inline">Get-InstalledUpdates.ps1</strong> script to scan an IP range for installed Windows updates. You can find the script in the GitHub repository of this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter09/Get-InstalledUpdates.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter09/Get-InstalledUpdates.ps1</span></a><span class="No-Break">.</span></p>
			<p>Use this example to scan the <strong class="source-inline">172.29.0.10-20</strong> IP range for <span class="No-Break">installed updates:</span></p>
			<pre class="source-code">
&gt; .\Get-InstalledUpdates.ps1 -BaseIP "172.29.0" -MinIP 10 -MaxIP 20 -Verbose</pre>
			<p><strong class="source-inline">-MinIP</strong> represents the smallest last IP address octet, while -<strong class="source-inline">MaxIP</strong> represents the highest last IP address octet. Enabling the <strong class="source-inline">-Verbose</strong> parameter allows the script to display a detailed <a id="_idIndexMarker1720"/>output of its actions. It is also possible to use the <strong class="source-inline">-MaxJobs</strong> parameter to define how many jobs can be run in parallel to <span class="No-Break">check updates.</span></p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor249"/>Checking for missing updates</h2>
			<p>You <a id="_idIndexMarker1721"/>want to find out which updates are missing on one or more <span class="No-Break">remote host(s).</span></p>
			<h3>Solution</h3>
			<p>You can use the <strong class="source-inline">Scan-RemoteUpdates.ps1</strong> script to check for missing Windows updates – either on the localhost or on one or more remote host(s). You can find the script in the GitHub repository of this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter09/Scan-RemoteUpdates.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter09/Scan-RemoteUpdates.ps1</span></a><span class="No-Break">.</span></p>
			<p>Scanning only the localhost is done <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&gt; .\Scan-RemoteUpdates.ps1</pre>
			<p>Scanning for multiple remote hosts is done <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&gt; .\Scan-RemoteUpdates.ps1 -remoteHosts "PSSec-PC01", "PSSec-PC02", "PSSec-Srv01"</pre>
			<p>If the <strong class="source-inline">-Force</strong> parameter is specified, the <strong class="source-inline">wsusscn2.cab</strong> file will be deleted if present and a new version will be downloaded. Use the <strong class="source-inline">-CabPath</strong> parameter to specify where the <strong class="source-inline">wsusscn2.cab</strong> file should be downloaded. If nothing is specified, it will be downloaded to <strong class="source-inline">$env:temp\wsusscn2.cab</strong>. If <strong class="source-inline">-DoNotDeleteCabFile</strong> is present, the <strong class="source-inline">wsusscn2.cab</strong> file will not be deleted after <span class="No-Break">the check.</span></p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor250"/>Reviewing the PowerShell history of all users</h2>
			<p>During an<a id="_idIndexMarker1722"/> incident response, you want to review the PowerShell history of all users on <span class="No-Break">a system.</span></p>
			<h3>Solution</h3>
			<p>The <strong class="source-inline">Get-History</strong> cmdlet would only get the current shell’s history, which is not very helpful. To review the entire PowerShell history of each user, you can loop through the <strong class="source-inline">ConsoleHost_history.txt</strong> files on <span class="No-Break">a system:</span></p>
			<pre class="source-code">
$UserHistory = @(Get-ChildItem "C:\Users\*\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt").FullName;
$UserHistory += @(Get-ChildItem "c:\windows\system32\config\systemprofile\appdata\roaming\microsoft\windows\powershell\psreadline\consolehost_history.txt" -ErrorAction SilentlyContinue).FullName;
foreach ($Item in $UserHistory) {
    if ($Item) {
        Write-Output ""
        Write-Output "###############################################################################################################################"
        Write-Output "PowerShell history: $item"
        Write-Output "###############################################################################################################################"
        Get-Content $Item
    }
}</pre>
			<p>In this <a id="_idIndexMarker1723"/>example, you would loop through all the <strong class="source-inline">ConsoleHost_history.txt</strong> files of all users, as well as through the system profile (<span class="No-Break">if available).</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor251"/>Inspecting the event log of a remote host</h2>
			<p>You<a id="_idIndexMarker1724"/> want to inspect the event log of a remote host and search for <span class="No-Break">specific patterns.</span></p>
			<h3>Solution</h3>
			<p>You can use <strong class="source-inline">Get-WinEvent</strong> to get all events on a (remote) host and filter for specific patterns. Please note that the RemoteRegistry service needs to run on the remote host in order for the <strong class="source-inline">Get-WinEvent</strong> cmdlet to <span class="No-Break">work remotely:</span></p>
			<pre class="source-code">
$ComputerName = "PSSec-PC01.PSSec.local"
$EventLog = "Microsoft-Windows-Powershell/Operational"
$LogEntries = Get-WinEvent -LogName $EventLog -ComputerName $ComputerName
$LogEntries | Where-Object Id -eq 4104  | Where-Object Message -like "*Mimikatz*"</pre>
			<p>Using this example, you would connect to the remote host, <strong class="source-inline">PSSec-PC01.PSSec.local</strong>, and retrieve all events in the <strong class="source-inline">Microsoft-Windows-Powershell/Operational</strong> event log and save them into the <strong class="source-inline">$LogEntries</strong> variable. This allows you to quickly operate with the events by not always connecting remotely and, instead, operating <span class="No-Break">the variable.</span></p>
			<p>Using the <strong class="source-inline">$LogEntries</strong> variable, you could filter for specific events or strings. In this example, we filter for events with the <strong class="source-inline">4104</strong> event ID that contain the <strong class="source-inline">"Mimikatz"</strong> string in the message body. The wildcards, <strong class="source-inline">*</strong>, indicate that other characters could prefix or suffix the search <span class="No-Break">term </span><span class="No-Break"><strong class="source-inline">"Mimikatz"</strong></span><span class="No-Break">.</span></p>
			<p>Please note <a id="_idIndexMarker1725"/>that if you want to query the PowerShell Core log instead, you would need to change the <strong class="source-inline">$EventLog</strong> variable <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">"PowerShellCore/Operational"</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">PowerShell remoting versus the -ComputerName parameter</p>
			<p class="callout">It’s worth mentioning that PowerShell remoting can be used to remotely execute any cmdlet, regardless of whether the cmdlet has a <strong class="source-inline">-ComputerName</strong> parameter or not. This can be particularly useful in cases where the <strong class="source-inline">-ComputerName</strong> parameter does not work, due to closed DCOM ports or other reasons. As an example, to retrieve log entries from a remote computer, you can use the following command: – <strong class="source-inline">Invoke-Command -ComputerName $ComputerName -ScriptBlock { Get-WinEvent -LogName $EventLog | Where-Object Id -eq 4104 | Where-Object Message -like "</strong><span class="No-Break"><strong class="source-inline">Mimikatz" }</strong></span><span class="No-Break">.</span></p>
			<p>You could also assess multiple remote hosts by looping them through using <strong class="source-inline">foreach</strong>, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
$ComputerNames = @("DC01", "PSSec-PC01", "PSSec-PC02", "PSSec-Srv01")
$EventLog = "Microsoft-Windows-Powershell/Operational"
$LogEntries = foreach ($Computer in $ComputerNames) {
    Get-WinEvent -LogName $EventLog -ComputerName $Computer -ErrorAction SilentlyContinue
}
$LogEntries | Group-Object -Property MachineName
$LogEntries | Where-Object {($_.Id -eq 4104) -and ($_.Message -like "*Mimikatz*")} | Select-Object -Property TimeCreated, MachineName, Id, LevelDisplayName, Message | ft</pre>
			<p>You can assess the events collected using the <strong class="source-inline">$LogEntries</strong> variable. To get an overview of how many events were collected from which hosts, you can use <strong class="source-inline">Group-Object</strong> and <a id="_idIndexMarker1726"/>group <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">MachineName</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor252"/>Monitoring to bypass powershell.exe</h2>
			<p>You want to<a id="_idIndexMarker1727"/> monitor for the execution of PowerShell without the use of the <span class="No-Break"><strong class="source-inline">powershell.exe</strong></span><span class="No-Break"> binary.</span></p>
			<h3>Solution</h3>
			<p>To monitor the execution of PowerShell without the use of the <strong class="source-inline">powershell.exe</strong> binary, there are two solutions. Option number one is to use the Windows PowerShell event log and look for the <strong class="source-inline">400</strong> <span class="No-Break">event ID:</span></p>
			<pre class="source-code">
&gt; Get-WinEvent -LogName "Windows PowerShell" | Where-Object Id -eq 400 | Where-Object Message -notmatch "HostApplication.*powershell.exe" | fl Message,TimeCreated</pre>
			<p>Since there are multiple legitimate reasons to execute PowerShell without the <strong class="source-inline">powershell.exe</strong> binary, you might want to adjust this query to your environment. On a regular Windows 10 client system, on which the PowerShell ISE is also used, the following code snippet could <span class="No-Break">be helpful:</span></p>
			<pre class="source-code">
&gt; Get-WinEvent -LogName "Windows PowerShell" | Where-Object Id -eq 400 | Where-Object { ($_.Message -notmatch "HostApplication.*powershell.exe") -and ($_.Message -notmatch "HostApplication.*PowerShell_ISE.exe") -and ($_.Message -notmatch "HostApplication.*sdiagnhost.exe") } | fl Message,TimeCreated</pre>
			<p>For option number two, you need to have Sysmon installed on all systems on which you want to detect the bypass of the <strong class="source-inline">powershell.exe</strong> binary. Sysmon is part of the Sysinternals suite and can be downloaded <span class="No-Break">here: </span><a href="https://learn.microsoft.com/en-us/sysinternals/downloads/sysmon"><span class="No-Break">https://learn.microsoft.com/en-us/sysinternals/downloads/sysmon</span></a><span class="No-Break">.</span></p>
			<p>Once Sysmon is installed and configured, you will need to look for the following DLLs using Sysmon’s event ID 7, <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">Image loaded"</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">System.Management.Automation.dll</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">System.Management.Automation.ni.dll</strong></span></li>
			</ul>
			<p>You can <a id="_idIndexMarker1728"/>now search for potential bypasses of the <strong class="source-inline">powershell.exe</strong> binary, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
$ComputerName = "PSSec-PC01.PSSec.local"
$EventLog = "Microsoft-Windows-Sysmon/Operational"
$LogEntries = Get-WinEvent -LogName $EventLog -ComputerName $ComputerName
$LogEntries | Where-Object Id -eq 7 | Where-Object (($_.Message -like "*System.Management.Automation*") -or ($_.Message -like "*System.Reflection*"))</pre>
			<p>If you have an EDR in place that helps you detect similar events, you don’t need Sysmon to detect the PowerShell .NET assembly calls, <span class="No-Break">of course.</span></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor253"/>Getting specific firewall rules</h2>
			<p>You want to filter specific firewall rules <span class="No-Break">using PowerShell.</span></p>
			<h3>Solution</h3>
			<p>You can get all firewall rules and filter for specific ones using the <span class="No-Break"><strong class="source-inline">Get-NetFirewallRule</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; Get-NetFirewallRule -&lt;parameter&gt; &lt;value&gt;</pre>
			<p>There are many parameter filter options available using <strong class="source-inline">Get-NetFirewallRule</strong>. To get, for example, all enabled firewall rules that have the direction inbound and are allow rules, use the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; Get-NetFirewallRule -Direction Inbound -Enabled True -Action Allow</pre>
			<p>You can also use the <strong class="source-inline">Get-NetFirewallProfile</strong> cmdlet, together with <strong class="source-inline">Get-NetFirewallRule</strong>, to retrieve all firewall rules that were created for a particular firewall profile. By using the following example, you would get all firewall rules that were created for the <strong class="bold">Public</strong> <span class="No-Break">firewall profile:</span></p>
			<pre class="source-code">
&gt; Get-NetFirewallProfile -Name Public | Get-NetFirewallRule</pre>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor254"/>Allowing PowerShell communication only for private IP address ranges</h2>
			<p>You want to restrict PowerShell communication to happen only in your own network and avoid PowerShell communicating to potential <span class="No-Break">C2 servers.</span></p>
			<h3>Solution</h3>
			<p>Create a new firewall rule using <strong class="source-inline">New-NetFirewallRule</strong> to lock down PowerShell communication to private IP address <span class="No-Break">ranges only.</span></p>
			<p>The following example creates a new firewall rule, with the name <strong class="source-inline">Block Outbound PowerShell connections</strong>, that restricts Windows PowerShell from establishing connections with IP addresses outside of the <span class="No-Break">local network:</span></p>
			<pre class="source-code">
&gt; New-NetFirewallRule -DisplayName "Block Outbound PowerShell connections" -Enabled True -Direction Outbound -Action Block -Profile Any -Program "%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe" -RemoteAddress "Internet"</pre>
			<p>Use this example and adjust it to your needs. As most organizations still use Windows PowerShell as their default PowerShell instance, this example also refers to Windows PowerShell. If you are using PowerShell Core as your default PowerShell instance, you might want to adjust the path to <span class="No-Break">the program.</span></p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor255"/>Isolating a compromised system</h2>
			<p>You want to isolate a <span class="No-Break">compromised system.</span></p>
			<h3>Solution</h3>
			<p>You can do this by using the <strong class="source-inline">New-NetFirewallRule</strong> and <strong class="source-inline">Disable-NetAdapter</strong> cmdlets. The following code snippet demonstrates how you can remotely isolate a device. First, it sends a message to all users that are currently logged on <strong class="source-inline">PSSec-PC01</strong>, then it remotely creates firewall rules to block all inbound and outbound connections, and then disables all <span class="No-Break">network adapters:</span></p>
			<pre class="source-code">
$ComputerName = "PSSec-PC01"
msg * /server $ComputerName "Security issues were found on your computer. You are now disconnected from the internet. Please contact your helpdesk: +0012 3456789"
$session = Invoke-Command -ComputerName $ComputerName -InDisconnectedSession -ScriptBlock {
    New-NetFirewallRule -DisplayName "Isolate from outbound traffic" -Direction Outbound -Action Block | Out-Null;
    New-NetFirewallRule -DisplayName "Isolate from inbound traffic" -Direction Inbound -Action Block | Out-Null;
    Get-NetAdapter|foreach { Disable-NetAdapter -Name $_.Name -Confirm:$false }
}
Remove-PSSession -Id $session.Id -ErrorAction SilentlyContinue</pre>
			<p>Just <a id="_idIndexMarker1729"/>replace <strong class="source-inline">PSSec-PC01</strong> with the computer name of your choice, and feel free to adjust the message that will be sent to the <span class="No-Break">computer users.</span></p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor256"/>Checking out installed software remotely</h2>
			<p>You <a id="_idIndexMarker1730"/>want to find out what software is installed on a <span class="No-Break">remote PC.</span></p>
			<h3>Solution</h3>
			<p>You can check out what software is installed on a remote PC by using the <span class="No-Break"><strong class="source-inline">Get-CimInstance</strong></span><span class="No-Break"> cmdlet.</span></p>
			<p>The following example code will let you connect to a computer named <strong class="source-inline">PSSec-PC01</strong> and find out which software it currently <span class="No-Break">has installed:</span></p>
			<pre class="source-code">
$ComputerName = "PSSec-PC01"
Get-CimInstance -ClassName Win32_Product -ComputerName $ComputerName | Sort-Object Name</pre>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor257"/>Starting a transcript</h2>
			<p>You want to enable an over-the-shoulder transcription to track what is happening in a <span class="No-Break">PowerShell session.</span></p>
			<h3>Solution</h3>
			<p>Enable a transcript on the machine on which you want to track what is happening in a PowerShell session. This can be done by either enabling the transcript via Group Policy by configuring the <strong class="bold">Turn on PowerShell Transcription</strong> option under <strong class="bold">Windows Components</strong> | <strong class="bold">Administrative Templates</strong> | <strong class="bold">Windows PowerShell</strong>, or by configuring it using PowerShell to configure the registry, as shown in the blog article <em class="italic">PowerShell </em><em class="italic">♥</em><em class="italic"> the Blue </em><span class="No-Break"><em class="italic">Team</em></span><span class="No-Break">: </span><a href="https://devblogs.microsoft.com/powershell/powershell-the-blue-team/ "><span class="No-Break">https://devblogs.microsoft.com/powershell/powershell-the-blue-team/</span></a></p>
			<p>The following code snippet shows the <strong class="source-inline">Enable-PSTranscription</strong> function, which originates from <span class="No-Break">this article:</span></p>
			<pre class="source-code">
function Enable-PSTranscription {
    [CmdletBinding()]
    param(
        $OutputDirectory,
        [Switch] $IncludeInvocationHeader
    )
    $basePath = "HKLM:\Software\Policies\Microsoft\Windows\PowerShell\Transcription"
    if (-not (Test-Path $basePath)) {$null = New-Item $basePath -Force}
    Set-ItemProperty $basePath -Name EnableTranscripting -Value 1
    if ($PSCmdlet.MyInvocation.BoundParameters.ContainsKey("OutputDirectory")) {Set-ItemProperty $basePath -Name OutputDirectory -Value $OutputDirectory}
    if ($IncludeInvocationHeader) {Set-ItemProperty $basePath -Name IncludeInvocationHeader -Value 1}
}</pre>
			<p>If you used <a id="_idIndexMarker1731"/>this function to enable transcription to the <strong class="source-inline">C:\tmp</strong> folder, the syntax would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
&gt; Enable-PSTranscription -OutputDirectory "C:\tmp\"</pre>
			<p>You can also <a id="_idIndexMarker1732"/>use a <strong class="bold">Universal Naming Convention</strong> (<strong class="bold">UNC</strong>) path to save the transcript to a network folder. Make sure to secure the path so that a potential attacker cannot access and/or <span class="No-Break">delete it.</span></p>
			<p>To centralize PowerShell transcripts and maintain a secure audit trail, you can, for example, configure the transcript destination as a UNC path with a dynamic filename. This involves setting the transcript directory to a network share with write-only permission and using the PowerShell profile to log all activity to a file with a unique name, based on system and user variables, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
&gt; Enable-PSTranscription -OutputDirectory "\\fileserver\Transcripts$\$env:computername-$($env:userdomain)-$($env:username)-$(Get-Date -Format 'YYYYMMddhhmmss').txt"</pre>
			<p>This will create a unique transcript file for each user and computer combination, with the current date and time included in the filename. By storing transcripts in a centralized location with restricted access, you can ensure that all activity is logged and available for review and analysis <span class="No-Break">as needed.</span></p>
			<p>This will write all transcripts to the specified file server location, which can then be accessed by authorized personnel for review <span class="No-Break">and analysis.</span></p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor258"/>Checking for expired certificates</h2>
			<p>You want <a id="_idIndexMarker1733"/>to check for SSL certificates in your certificate store that have already expired or will expire in the next <span class="No-Break">60 days.</span></p>
			<h3>Solution</h3>
			<p>You can use the following script to check for SSL certificates in your certificate store that have already expired or will expire in the next <span class="No-Break">60 days:</span></p>
			<pre class="source-code">
$certificates = Get-ChildItem -Path "Cert:\" -Recurse | Where-Object { $_.Subject -like "*CN=*"} | Where-Object { $_.Extensions | Where-Object { $_.Oid.Value -eq "2.5.29.37" } | Where-Object { $_.Critical -eq $false } }
$expiringCertificates = @()
foreach ($certificate in $certificates) {
    if (($certificate.NotAfter) -and (($certificate.NotAfter -lt (Get-Date).AddDays(60)) -or ($certificate.NotAfter -lt (Get-Date)))) {
        $expiringCertificates += $certificate
    }
}
Write-Output "Expired or Expiring Certificates in the next 60 days:"
foreach ($expiringCertificate in $expiringCertificates) {
    Write-Output $expiringCertificate | Select-Object Thumbprint, FriendlyName, Subject, NotBefore, NotAfter
}</pre>
			<p>You can also alter the path to <strong class="source-inline">Cert:\LocalMachine\My</strong> to only assess certificates from the personal store. For certificates from the <strong class="source-inline">root</strong> store, change the path <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Cert:\LocalMachine\Root</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor259"/>Checking the digital signature of a file or a script</h2>
			<p>You want to check the authenticity and integrity of software or a script by checking the <span class="No-Break">digital signature.</span></p>
			<h3>Solution</h3>
			<p>You can check the status of a digital signature by using the <span class="No-Break"><strong class="source-inline">Get-AuthenticodeSignature</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; Get-AuthenticodeSignature "C:\Windows\notepad.exe" | Format-List</pre>
			<p>Using <strong class="source-inline">Get-AuthenticodeSignature</strong>, you get all sorts of useful information about the digital signature, such as the certificate chain, which is demonstrated in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer196">
					<img alt="Figure 9.2 – Query information about the digital signature of a file" src="image/B16679_09_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Query information about the digital signature of a file</p>
			<p>However, if<a id="_idIndexMarker1734"/> you prefer to query the status only, you can also use the <strong class="source-inline">(Get-AuthenticodeSignature "</strong><span class="No-Break"><strong class="source-inline">C:\Windows\notepad.exe").Status</strong></span><span class="No-Break"> command.</span></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor260"/>Checking file permissions of files and folders</h2>
			<p>You want to enumerate the access rights of files <span class="No-Break">and folders.</span></p>
			<h3>Solution</h3>
			<p>To enumerate the access rights of files and folders, you can use the <strong class="source-inline">Get-ChildItem</strong> and <strong class="source-inline">Get-Acl</strong> cmdlets. To enumerate, for example, all files and folders in the <strong class="source-inline">Windows Defender</strong> directory recursively, you can use the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
$directory = "C:\Program Files\Windows Defender"
$Acls = Get-ChildItem -Path $directory -Recurse | ForEach-Object {
    $fileName = $_.FullName
    (Get-Acl $_.FullName).Access | ForEach-Object {
        [PSCustomObject]@{
            FileName = $fileName
            FileSystemRights = $_.FileSystemRights
            AccessControlType = $_.AccessControlType
            IdentityReference = $_.IdentityReference
            IsInherited = $_.IsInherited
        }
    }
}
$Acls</pre>
			<p>If you want to enumerate on one level only, make sure to remove the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Recurse</strong></span><span class="No-Break"> parameter.</span></p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor261"/>Displaying all running services</h2>
			<p>You want to display all running services and their <span class="No-Break">command paths.</span></p>
			<h3>Solution</h3>
			<p>Although you can use the <strong class="source-inline">Get-Service</strong> cmdlet to display all running services, you can also use <strong class="source-inline">Get-CimInstance</strong> to access the WMI information of the services and get even more information, such as the command path <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">ProcessId</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-CimInstance win32_service | Where-Object State -eq "Running" | Select-Object ProcessId, Name, DisplayName, PathName | Sort-Object Name | fl</pre>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor262"/>Stopping a service</h2>
			<p>You<a id="_idIndexMarker1735"/> want to stop a service <span class="No-Break">from running.</span></p>
			<h3>Solution</h3>
			<p>To stop a service from running, you can use the <strong class="source-inline">Stop-Service</strong> cmdlet. The following example shows you how to combine <strong class="source-inline">Get-Service</strong> with <strong class="source-inline">Stop-Service</strong> to stop the <span class="No-Break"><strong class="source-inline">maliciousService</strong></span><span class="No-Break"> service:</span></p>
			<pre class="source-code">
&gt; Get-Service -Name "maliciousService" | Stop-Service -Force -Confirm:$false -verbose</pre>
			<p>Keep in mind that if you use the <strong class="source-inline">-Confirm:$false</strong> parameter, the confirmation prompt will be bypassed, and the command will be executed without any further confirmation. It’s recommended to use this parameter with caution and only in situations where you are fully aware of the potential risks and consequences. It’s important to thoroughly understand the implications of using this parameter and make an informed decision based on your specific <span class="No-Break">use case.</span></p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor263"/>Displaying all processes</h2>
			<p>You <a id="_idIndexMarker1736"/>want to display all processes, including their owners and <span class="No-Break">command lines.</span></p>
			<h3>Solution</h3>
			<p>You can display all processes and more information about them by using <strong class="source-inline">Get-WmiObject win32_process</strong>. To display all processes, including their owners and command lines, you can use the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
&gt; Get-WmiObject win32_process | Select ProcessID,Name,@{n='Owner';e={$_.GetOwner().User}},CommandLine | Sort-Object Name | ft -wrap -autosize</pre>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor264"/>Stopping a process</h2>
			<p>You <a id="_idIndexMarker1737"/>want to stop <span class="No-Break">a process.</span></p>
			<h3>Solution</h3>
			<p>To stop a process, you can use the <strong class="source-inline">Stop-Process</strong> cmdlet. To stop, for example, the process with <strong class="source-inline">Id 8336</strong>, you can use the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
&gt; Get-Process -Id 8336 | Stop-Process -Force -Confirm:$false -verbose</pre>
			<p>It is, of course, also possible to select a process by its name with the <strong class="source-inline">-Name</strong> parameter of the <strong class="source-inline">Get-Process</strong> cmdlet to stop it. If there is more than one process with the same name, it can happen that multiple processes will <span class="No-Break">be stopped.</span></p>
			<p>Keep in mind that if you use the <strong class="source-inline">-Confirm:$false</strong> parameter, the confirmation prompt will be bypassed, and the command will be executed without any further confirmation. It’s recommended to use this parameter with caution and only in situations where you are fully aware of the potential risks and consequences. It’s important to thoroughly understand the implications of using this parameter and make an informed decision based on your specific <span class="No-Break">use case.</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor265"/>Disabling a local account</h2>
			<p>You want to disable a <span class="No-Break">local account.</span></p>
			<h3>Solution</h3>
			<p>To disable a local account, you can use the <span class="No-Break"><strong class="source-inline">Disable-LocalUser</strong></span><span class="No-Break"> cmdlet.</span></p>
			<p>One way to improve security in Windows is to create a new user with administrative privileges and disable the default <strong class="source-inline">Administrator</strong> account. This helps prevent brute-force attacks that often target the default account. To achieve this, you can use the <span class="No-Break"><strong class="source-inline">Disable-LocalUser</strong></span><span class="No-Break"> cmdlet.</span></p>
			<p>Here’s an example that demonstrates how to disable the <strong class="source-inline">Administrator</strong> account using the <span class="No-Break"><strong class="source-inline">Disable-LocalUser</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; Disable-LocalUser -Name "Administrator"</pre>
			<p>After running the command, you can use the <strong class="source-inline">Get-LocalUser</strong> cmdlet to verify that the account has <span class="No-Break">been disabled:</span></p>
			<pre class="source-code">
&gt; Get-LocalUser -Name "Administrator"</pre>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor266"/>Enabling a local account</h2>
			<p>You want to enable a <span class="No-Break">local account.</span></p>
			<h3>Solution</h3>
			<p>To enable a local account, you can use the <strong class="source-inline">Enable-LocalUser</strong> cmdlet. Using the following example, the <strong class="source-inline">Administrator</strong> account would <span class="No-Break">be enabled:</span></p>
			<pre class="source-code">
&gt; Enable-LocalUser -Name "Administrator"</pre>
			<p>Using the <strong class="source-inline">Get-LocalUser</strong> cmdlet, you can verify that the account <span class="No-Break">was enabled:</span></p>
			<pre class="source-code">
&gt; Get-LocalUser -Name "Administrator"</pre>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor267"/>Disabling a domain account</h2>
			<p>You<a id="_idIndexMarker1738"/> want to disable a <span class="No-Break">domain account.</span></p>
			<h3>Solution</h3>
			<p>To disable a domain account, you can use the <strong class="source-inline">Disable-ADAccount</strong> cmdlet, which is part of the <strong class="source-inline">ActiveDirectory</strong> module. Using the following example, the <strong class="source-inline">vvega</strong> domain account would <span class="No-Break">be disabled:</span></p>
			<pre class="source-code">
&gt; Import-Module ActiveDirectory
&gt; Disable-ADAccount -Identity "vvega"</pre>
			<p>Using the <strong class="source-inline">Get-ADUser</strong> cmdlet, you can verify that the account <span class="No-Break">was disabled:</span></p>
			<pre class="source-code">
&gt; (Get-ADUser -Identity vvega).enabled</pre>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor268"/>Enabling a domain account</h2>
			<p>You <a id="_idIndexMarker1739"/>want to enable a <span class="No-Break">domain account.</span></p>
			<h3>Solution</h3>
			<p>To enable a domain account, you can use the <strong class="source-inline">Enable-ADAccount</strong> cmdlet, which is part of the <strong class="source-inline">ActiveDirectory</strong> module. Using the following example, the <strong class="source-inline">vvega</strong> domain account would <span class="No-Break">be enabled:</span></p>
			<pre class="source-code">
&gt; Import-Module ActiveDirectory
&gt; Enable-ADAccount -Identity "vvega"</pre>
			<p>Using the <strong class="source-inline">Get-ADUser</strong> cmdlet, you can verify that the account <span class="No-Break">was disabled:</span></p>
			<pre class="source-code">
&gt; (Get-ADUser -Identity vvega).enabled</pre>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor269"/>Retrieving all recently created domain users</h2>
			<p>You want to retrieve all domain users that were <span class="No-Break">recently created.</span></p>
			<h3>Solution</h3>
			<p>To retrieve all users that were created in the last 30 days, you can use the following <span class="No-Break">code </span><span class="No-Break"><a id="_idIndexMarker1740"/></span><span class="No-Break">snippet:</span></p>
			<pre class="source-code">
Import-Module ActiveDirectory
$timestamp = ((Get-Date).AddDays(-30)).Date
Get-ADUser -Filter {whenCreated -ge $timestamp} -Properties whenCreated | Sort-Object whenCreated -descending</pre>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor270"/>Checking whether a specific port is open</h2>
			<p>You <a id="_idIndexMarker1741"/>want to check whether a specific port on a remote system <span class="No-Break">is open.</span></p>
			<h3>Solution</h3>
			<p>To find out whether a specific port is open, you can use the following code snippet; this example checks whether port <strong class="source-inline">445</strong> is open on the <span class="No-Break">computer </span><span class="No-Break"><strong class="source-inline">DC01</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$result = Test-NetConnection -ComputerName DC01 -Port 445
$result
$result.TcpTestSucceeded</pre>
			<p>The following screenshot shows the output of the preceding <span class="No-Break">code snippet:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer197">
					<img alt="Figure 9.3 – Checking whether port 445 is open on DC01" src="image/B16679_09_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Checking whether port 445 is open on DC01</p>
			<p>This method is a good way to test for a single port or for very few ports, as the <strong class="source-inline">Test-NetConnection</strong> cmdlet <a id="_idIndexMarker1742"/>can be very time-consuming if used for a full port scan. Therefore, if you want to scan all ports of a remote system, you should instead <a id="_idIndexMarker1743"/><span class="No-Break">use </span><span class="No-Break"><strong class="bold">nmap</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor271"/>Showing TCP connections and their initiating processes</h2>
			<p>You <a id="_idIndexMarker1744"/>want to display all TCP connections, the initiating processes, as well as the command line that was used to open the <span class="No-Break">TCP connection.</span></p>
			<h3>Solution</h3>
			<p>You can use <strong class="source-inline">Get-NetTCPConnection</strong> and create manual properties by using <strong class="source-inline">Get-Process</strong> and <strong class="source-inline">Get-WmiObject</strong> as <span class="No-Break"><strong class="source-inline">Select-Object</strong></span><span class="No-Break"> expressions:</span></p>
			<pre class="source-code">
&gt; Get-NetTCPConnection | Select-Object LocalAddress,LocalPort,RemoteAddress,RemotePort,State,@{Label = 'ProcessName';Expression={(Get-Process -Id $_.OwningProcess).Name}}, @{Label="CommandLine";Expression={(Get-WmiObject Win32_Process -filter "ProcessId = $($_.OwningProcess)").CommandLine}} | ft -Wrap -AutoSize</pre>
			<p>This example shows all TCP connections, the local address and port, the remote address and port, the state of the connection, the name of the process, as well as the command line that was executed to initiate <span class="No-Break">the connection.</span></p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor272"/>Showing UDP connections and their initiating processes</h2>
			<p>You want to display all UDP connections, the initiating processes, as well as the command line that was used to open the <span class="No-Break">UDP connection.</span></p>
			<h3>Solution</h3>
			<p>You can use <strong class="source-inline">Get-NetUDPConnection</strong> and create manual properties by using <strong class="source-inline">Get-Process</strong> and <strong class="source-inline">Get-WmiObject</strong> as <span class="No-Break"><strong class="source-inline">Select-Object</strong></span><span class="No-Break"> expressions:</span></p>
			<pre class="source-code">
&gt; Get-NetUDPEndpoint | Select-Object CreationTime,LocalAddress,LocalPort,@{Label = 'ProcessName';Expression={(Get-Process -Id $_.OwningProcess).Name}}, @{Label="CommandLine";Expression={(Get-WmiObject Win32_Process -filter "ProcessId = $($_.OwningProcess)").CommandLine}} | ft -Wrap -AutoSize</pre>
			<p>This example<a id="_idIndexMarker1745"/> shows all UDP connections, the creation time, the local address and port, the name of the process, as well as the command line that was executed to initiate <span class="No-Break">the connection.</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor273"/>Searching for downgrade attacks using the Windows event log</h2>
			<p>You want to search for past downgrade attacks using the Windows <span class="No-Break">event log.</span></p>
			<h3>Solution</h3>
			<p>You can search for past downgrade attacks using the Windows event log with the following code snippet, which was originally written by <span class="No-Break">Lee Holmes:</span></p>
			<pre class="source-code">
Get-WinEvent -LogName "Windows PowerShell" | Where-Object Id -eq 400 | Foreach-Object {
        $version = [Version] ($_.Message -replace '(?s).*EngineVersion=([\d\.]+)*.*','$1')
        if($version -lt ([Version] "5.0")) { $_ }
}</pre>
			<p>Monitor for the <strong class="source-inline">400</strong> event ID in the Windows PowerShell event log. If <strong class="source-inline">EngineVersion</strong> is lower than <strong class="source-inline">5</strong>, you should definitely investigate further, as this could indicate a <span class="No-Break">downgrade attack.</span></p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor274"/>Preventing downgrade attacks</h2>
			<p>You <a id="_idIndexMarker1746"/>want to prevent downgrade attacks from happening and, therefore, use <strong class="bold">Windows Defender Application Control</strong> (<strong class="bold">WDAC</strong>) to disable<a id="_idIndexMarker1747"/> PowerShell version <span class="No-Break">2 binaries.</span></p>
			<h3>Solution</h3>
			<p>PowerShell version 2 cannot load if the <strong class="source-inline">System.Management.Automation.dll</strong> and <strong class="source-inline">System.Management.Automation.ni.dll</strong> assemblies are blocked, even if .NET Framework version 2 is installed and PowerShell version 2 <span class="No-Break">is enabled.</span></p>
			<p>Use the<a id="_idIndexMarker1748"/> following code snippets to find out where those binaries are located to block them, using WDAC or another application control software of <span class="No-Break">your choice:</span></p>
			<pre class="source-code">
&gt; powershell -version 2 -noprofile -command "(Get-Item ([PSObject].Assembly.Location)).VersionInfo"
&gt; powershell -version 2 -noprofile -command "(Get-Item (Get-Process -id $pid -mo | ? { $_.FileName -match 'System.Management.Automation.ni.dll' } | % { $_.FileName })).VersionInfo"</pre>
			<p>If you remove <strong class="source-inline">-version 2</strong> from the preceding code snippets, you will see that there are other binaries used for modern PowerShell versions. Therefore, you should not be afraid of breaking anything if your system relies on a modern PowerShell version and if you want to prohibit PowerShell version 2 <span class="No-Break">binaries globally.</span></p>
			<p>Now that you have located the PowerShell binaries, you can use WDAC to block these legacy versions. Make sure to block the native image as<a id="_idIndexMarker1749"/> well as the <strong class="bold">Microsoft intermediate language (</strong><span class="No-Break"><strong class="bold">MSIL)</strong></span><span class="No-Break"> assemblies.</span></p>
			<p>Refer to Lee Holmes’ blog post to learn more about detecting and preventing PowerShell downgrade <span class="No-Break">attacks: </span><a href="https://www.leeholmes.com/detecting-and-preventing-powershell-downgrade-attacks/"><span class="No-Break">https://www.leeholmes.com/detecting-and-preventing-powershell-downgrade-attacks/</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor275"/>Summary</h1>
			<p>This chapter first explored the <em class="italic">protect, detect, and respond</em> approach, emphasizing the importance of each pillar and its role in ensuring the security of <span class="No-Break">an organization.</span></p>
			<p>We then provided a comprehensive overview of commonly used PowerShell tools, which are essential for blue teamers to defend an organization against <span class="No-Break">security threats.</span></p>
			<p>Finally, the blue team cookbook, a collection of scripts and code snippets for security analysis and defense, was explored. The cookbook covers a wide range of tasks, including checking updates, monitoring bypasses, and analyzing event logs, processes, services, and network connections. The blue team cookbook serves as a valuable resource for information security practitioners, providing practical solutions to various <span class="No-Break">security challenges.</span></p>
			<p>Now that we’ve discussed daily blue team operations, let’s explore further mitigation options that can help you secure your environment when using PowerShell. In the next chapter, we’ll delve into language modes and <strong class="bold">Just Enough </strong><span class="No-Break"><strong class="bold">Administration</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JEA</strong></span><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor276"/>Further reading</h1>
			<p>If you want to explore some of the topics that were mentioned in this chapter, follow <span class="No-Break">these resources:</span></p>
			<ul>
				<li>Blue Team <span class="No-Break">Notes: </span><span class="No-Break">https://github.com/Purp1eW0lf/Blue-Team-Notes</span></li>
				<li>Blue Team <span class="No-Break">Tips: </span><a href="https://sneakymonkey.net/blue-team-tips/"><span class="No-Break">https://sneakymonkey.net/blue-team-tips/</span></a></li>
				<li>A collection of PowerShell functions and scripts a blue teamer might <span class="No-Break">use: </span><a href="https://github.com/tobor88/PowerShell-Blue-Team"><span class="No-Break">https://github.com/tobor88/PowerShell-Blue-Team</span></a></li>
				<li>Creating and Starting a Windows Service Remotely Using NtObjectManager Via Remote Procedure Calls (RPC) Over <span class="No-Break">SMB: </span><a href="https://blog.openthreatresearch.com/ntobjectmanager_rpc_smb_scm"><span class="No-Break">https://blog.openthreatresearch.com/ntobjectmanager_rpc_smb_scm</span></a></li>
				<li>Detecting and Preventing PowerShell Downgrade <span class="No-Break">Attacks: </span><a href="https://www.leeholmes.com/detecting-and-preventing-powershell-downgrade-attacks/"><span class="No-Break">https://www.leeholmes.com/detecting-and-preventing-powershell-downgrade-attacks/</span></a></li>
				<li>Directory Services Internals <span class="No-Break">Blog: </span><a href="https://www.dsinternals.com/en/"><span class="No-Break">https://www.dsinternals.com/en/</span></a></li>
				<li>Investigating PowerShell <span class="No-Break">Attacks: </span><a href="https://www.fireeye.com/content/dam/fireeye-www/global/en/solutions/pdfs/wp-lazanciyan-investigating-powershell-attacks.pdf&#13;"><span class="No-Break">https://www.fireeye.com/content/dam/fireeye-www/global/en/solutions/pdfs/wp-lazanciyan-investigating-powershell-attacks.pdf</span></a></li>
				<li>PowerForensics - PowerShell Digital <span class="No-Break">Forensics: </span><a href="https://powerforensics.readthedocs.io/en/latest/"><span class="No-Break">https://powerforensics.readthedocs.io/en/latest/</span></a></li>
				<li>PowerShell ♥ the Blue <span class="No-Break">Team: </span><a href="https://devblogs.microsoft.com/powershell/powershell-the-blue-team/"><span class="No-Break">https://devblogs.microsoft.com/powershell/powershell-the-blue-team/</span></a></li>
				<li>Testing adversary technique variations with <span class="No-Break">AtomicTestHarnesses: </span><a href="https://redcanary.com/blog/introducing-atomictestharnesses/"><span class="No-Break">https://redcanary.com/blog/introducing-atomictestharnesses/</span></a></li>
				<li>Tracking WMI Activity with <span class="No-Break">PSGumshoe: </span><a href="https://www.darkoperator.com/blog/2022/3/27/tracking-wmi-activity-with-psgumshoe"><span class="No-Break">https://www.darkoperator.com/blog/2022/3/27/tracking-wmi-activity-with-psgumshoe</span></a></li>
				<li>Windows Sandbox Attack Surface <span class="No-Break">Analysis: </span><a href="https://googleprojectzero.blogspot.com/2015/11/windows-sandbox-attack-surface-analysis.html"><span class="No-Break">https://googleprojectzero.blogspot.com/2015/11/windows-sandbox-attack-surface-analysis.html</span></a></li>
			</ul>
			<p>You can also find all links mentioned in this chapter in the GitHub repository for <a href="B16679_09_Final_PD.xhtml#_idTextAnchor228"><span class="No-Break"><em class="italic">Chapter 9</em></span></a> – there’s no need to manually type in every <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter09/Links.md"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter09/Links.md</span></a><span class="No-Break">.</span></p>
		</div>
	

		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer199">
			</div>
		</div>
		<div class="Content" id="_idContainer200">
			<h1 id="_idParaDest-267"><a id="_idTextAnchor277"/>Part 3: Securing PowerShell – Effective Mitigations In Detail</h1>
			<p>In this part, we will mostly concentrate on mitigations that can help you to secure your environment efficiently. However, again, although we will focus on a lot of blue team stuff, this section also helps red teamers understand how mitigation technologies work, what risks they contain, and how adversaries are attempting to <span class="No-Break">develop bypasses.</span></p>
			<p>First, we’ll explore J<strong class="bold">ust Enough Administration</strong> (<strong class="bold">JEA</strong>), a feature that helps with delegating administrative tasks to non-administrative users. Although this feature is not very well known widely, it can be a game-changer. In this part, we will dive deep into JEA and its configuration options, and we will learn how to simplify the <span class="No-Break">initial deployment.</span></p>
			<p>Next, we will look into code signing and Application Control. You will learn how to plan for deploying Application Control, and throughout our journey, we will work with Microsoft’s Application Control solutions AppLocker and <strong class="bold">Windows Defender Application Control</strong> (<strong class="bold">WDAC</strong>). You will familiarize yourself with how those solutions are configured and audited. You will also gain insights into how PowerShell will change when Application Control <span class="No-Break">is configured.</span></p>
			<p>Dive into the <strong class="bold">Antimalware Scan Interface</strong> (<strong class="bold">AMSI</strong>) – learn how it works and why it is really helpful in the fight against malware. We will also look into ways that adversaries bypass this useful feature, by either surrogating it or obfuscating their <span class="No-Break">malicious code.</span></p>
			<p>Many other features can help you mitigate risk in your environment; therefore, at the end of this part, we will glance at many different features that can help you improve your posture. We will look into secure scripting, the desired state configuration, hardening strategies for systems and environments, and attack detection with <strong class="bold">endpoint detection and response</strong> (<strong class="bold">EDR</strong>) software. We are not diving deep in this last section and you are more than welcome to explore some of the features mentioned further to learn more about them and possibly use them in <span class="No-Break">your environment.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B16679_10_Final_PD.xhtml#_idTextAnchor278"><em class="italic">Chapter 10</em></a>, <em class="italic">Language Modes and Just Enough Administration (JEA)</em></li>
				<li><a href="B16679_11_Final_PD.xhtml#_idTextAnchor306"><em class="italic">Chapter 11</em></a>, <em class="italic">AppLocker, Application Control, and Code Signing</em></li>
				<li><a href="B16679_12_Final_PD.xhtml#_idTextAnchor324"><em class="italic">Chapter 12</em></a>, <em class="italic">Exploring the Antimalware Scan Interface (AMSI)</em></li>
				<li><a href="B16679_13_Final_PD.xhtml#_idTextAnchor341"><em class="italic">Chapter 13</em></a>, <em class="italic">What Else? – Further Mitigations and Resources</em></li>
			</ul>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer201">
			</div>
		</div>
		<div>
			<div id="_idContainer202">
			</div>
		</div>
	</body></html>