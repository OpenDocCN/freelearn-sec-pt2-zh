- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blue Team Tasks and Cookbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a member of the blue team, your primary goal is to protect your organization’s
    systems and networks from cyber threats. However, this is no easy task. The threat
    landscape is constantly evolving, and you may be faced with challenges such as
    managing and analyzing large amounts of data, coordinating with other teams, and
    ensuring compliance with regulations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll first take a closer look at the *protect, detect, and
    respond* approach and some of the challenges that blue teamers face. Next, we
    will explore an overview of some useful open source tools written in PowerShell
    that can help you in your daily practice as a blue teamer. Finally, we will look
    at the blue team cookbook, a collection of PowerShell snippets that can come in
    handy in your daily work as a blue team practitioner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the protect, detect, and respond approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common PowerShell blue team tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The blue team cookbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the most out of this chapter, ensure that you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows PowerShell 5.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell 7.3 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access to the GitHub repository for this chapter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter09](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter09)'
  prefs: []
  type: TYPE_NORMAL
- en: Protect, detect, and respond
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being a blue teamer is not an easy thing to do. You need to constantly keep
    up with the evolving threat landscape and stay up to date. While a red teamer
    needs to find just one single vulnerability to be successful, a blue teamer needs
    to watch for everything, as one little error already means that your network could
    be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Blue teamers not only need to configure and manage their systems but also analyze
    large amounts of data and coordinate with other teams. They need to ensure compliance
    with regulations and standards. And while they do all that, they need to keep
    the right balance between security and usability, ensuring that their users don’t
    get overwhelmed with all the security measures and try to bypass them by themselves.
  prefs: []
  type: TYPE_NORMAL
- en: To help keep track of everything that needs to be taken into account, categorizing
    tasks into **protect**, **detect**, and **respond** types can help. This is an
    approach to secure your organization’s systems, as well as its network. It is
    structured into three different areas – protection, detection, and response. Every
    pillar is of equal importance to keep your infrastructure safe.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The protect, detect, and respond approach](image/B16679_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The protect, detect, and respond approach
  prefs: []
  type: TYPE_NORMAL
- en: Many companies just focus on the protection part, although detection and response
    are also very important to keep adversaries out of your network.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore what each area covers in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of **protection** measures is to mitigate security risks and implement
    controls to reduce and block threats *before they happen*. Protection measures
    could include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Regularly updating systems and monitoring them to fix vulnerabilities that could
    be exploited by attackers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing user authentication and authorization to ensure that only authorized
    users have access to data and systems. The least privilege approach also needs
    to be followed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting sensitive data to minimize the risk of it being accessed by unauthorized
    users. Encrypt hard drives to avoid credential theft from a person that has physical
    access or even data theft if a device was stolen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing security policies, baselines, and access control to ensure that
    systems are configured as safely as possible. A strong password policy also needs
    to be introduced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying firewalls and **intrusion detection systems** (**IDSs**)/intrusion
    **prevention systems** (**IPSs**) to block unauthorized activities and detect
    suspicious activities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, protection mechanisms could also have a second purpose, such as an
    IDS or IPS, which not only blocks suspicious activities but also detects and alerts
    you to them. Therefore, this solution could also be a part of the **detection**
    area.
  prefs: []
  type: TYPE_NORMAL
- en: Detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the detection phase, the goal is to identify and report potential security
    threats as quickly as possible. There are various things that you can do to improve
    your detection stance, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Collecting and analyzing event logs about potential security breaches, such
    as failed login attempts or configuration changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring network activity for anomalies and suspicious behavior, such as users
    that are logging in to machines that they usually never log in to or attempts
    to access restricted resources. Another example would be if PowerShell (or other)
    code was executed from a workstation of a person that usually never runs code,
    such as employees from accounting or marketing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating security alerts from antivirus software and IDSs/IPSs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularly scanning your network for vulnerabilities to identify potential weaknesses
    that could be abused by adversaries. Also, periodically hire external penetration
    testers to check your security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing good detection measures will help you raise your awareness of what
    happens in your network. This allows you to act on potential security threats
    in the response phase.
  prefs: []
  type: TYPE_NORMAL
- en: Response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a security threat was detected, it means that you need to act on it quickly
    to reduce the risk and restore systems to a secure state. This can involve a variety
    of activities, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Isolating compromised systems to prevent further damage and the threat spreading
    within an environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering forensic data from affected systems and analyzing it. This helps to
    identify the attack source and determine the extent of the damage. It can also
    help to mitigate future threats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Restoring systems to a secure state, which may involve repairing or reinstalling
    them in accordance with the NIST **Cybersecurity Framework** (NIST **CSF**) guidelines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.nist.gov/cyberframework/framework](https://www.nist.gov/cyberframework/framework)'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing additional security controls to prevent similar threats in the
    future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three pillars combined build the protect, detect, and respond life cycle
    and should always be focused on with equal importance.
  prefs: []
  type: TYPE_NORMAL
- en: There are also many open source tools that can support a blue teamer to pursue
    the protect, detect, and respond approach. In the next section, we will explore
    some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Common PowerShell blue team tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a blue teamer, you are constantly on the lookout for tools and techniques
    that can help you protect your organization’s systems and networks from cyber
    threats.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore some common PowerShell open source tools that
    can be particularly helpful for blue teamers. These tools can assist with tasks
    such as analyzing system logs, gathering system information, and detecting malicious
    activity. Some of the tools can also help with tasks such as analyzing the attack
    surface of a system, identifying and decoding potentially malicious data, and
    searching for indicators of compromise. By leveraging these tools, you can streamline
    your workflows and more effectively defend your organization against cyber threats.
  prefs: []
  type: TYPE_NORMAL
- en: PSGumshoe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PSGumshoe** is a powerful PowerShell module that is designed to assist with
    tasks such as live response, hunt, and forensics. Developed by Carlos Perez, this
    open source tool is designed to help blue teamers collect artifacts from a variety
    of sources. Whether you are investigating a security incident, conducting a hunt
    for indicators of compromise, or performing forensic analysis, PSGumshoe can be
    a valuable asset in your toolkit. It also has functions included to support retrieving
    data from Sysmon-generated events or to track **Windows Management Instrumentation**
    (**WMI**) activity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install PSGumshoe from PowerShell Gallery using the **Install-Module
    PSGumshoe** command or download it from GitHub: [https://github.com/PSGumshoe/PSGumshoe](https://github.com/PSGumshoe/PSGumshoe).'
  prefs: []
  type: TYPE_NORMAL
- en: PowerShellArsenal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PowerShellArsenal** is a PowerShell module developed by Matt Graeber that
    is designed to assist reverse engineers in a variety of tasks. With its wide range
    of features and capabilities, this tool can help you disassemble code, perform
    .NET malware analysis, analyze and parse memory structures, and much more. Whether
    you are a seasoned reverse engineer or just starting out, PowerShellArsenal can
    be a valuable addition to your toolkit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be downloaded and installed as a module from GitHub: [https://github.com/mattifestation/PowerShellArsenal](https://github.com/mattifestation/PowerShellArsenal).'
  prefs: []
  type: TYPE_NORMAL
- en: AtomicTestHarnesses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**AtomicTestHarnesses** is a PowerShell module that allows you to simulate
    and validate the execution of attack techniques. With a PowerShell component for
    Windows and a Python component for macOS and Linux, this tool can be used across
    platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: Developed by Mike Haag, Jesse Brown, Matt Graeber, Jonathan Johnson, and Jared
    Atkinson, AtomicTestHarnesses is a valuable resource for blue teamers who are
    looking to test their defenses and ensure that they are prepared to respond to
    real-world attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily install AtomicTestHarnesses from the PowerShell gallery using
    the **Install-Module -Name AtomicTestHarnesses** command, or you can download
    it from GitHub at the following link: [https://github.com/redcanaryco/AtomicTestHarnesses](https://github.com/redcanaryco/AtomicTestHarnesses).'
  prefs: []
  type: TYPE_NORMAL
- en: PowerForensics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PowerForensics** is a powerful framework for hard drive forensics developed
    by Jared Atkinson. Currently supporting **NTFS** (**New Technology File System**)
    and **FAT** (**File Allocation Table**) file systems, this tool is designed to
    assist with tasks such as analyzing Windows artifacts, the Windows registry, boot
    sector, and application compatibility cache, as well as creating a forensic timeline.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With its extensive range of features and capabilities, PowerForensics is an
    invaluable resource for blue teamers who need to conduct forensic analysis on
    hard drives. You can easily install PowerForensics from the PowerShell gallery
    using the **Install-Module PowerForensics** command, or you can download it from
    GitHub at the following link: [https://github.com/Invoke-IR/PowerForensics](https://github.com/Invoke-IR/PowerForensics).'
  prefs: []
  type: TYPE_NORMAL
- en: NtObjectManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**NtObjectManager** is an extensive PowerShell module that allows you to access
    the NT Object Manager namespace. It is part of the sandbox attack surface analysis
    tools toolkit (which is also definitely worth a look!) that was developed by James
    Forshaw. The Object Manager itself is a subsystem within Windows that is responsible
    for managing the system’s objects, which represent various system resources such
    as processes, threads, files, and devices.'
  prefs: []
  type: TYPE_NORMAL
- en: The Object Manager is also in charge of creating and deleting objects, as well
    as maintaining the relationships between objects. It also handles object access
    requests, ensuring that only authorized entities are able to access specific objects.
    The Object Manager is an integral part of the operating system and is involved
    in many aspects of system operation, including memory management, process and
    thread management, and I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: The NTObjectManager module offers a wide variety of capabilities, including
    working with symbolic links, auditing RPC servers, manipulating the Object Manager,
    and generally messing around with the Windows operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'NtObjectManager can be easily installed using the **Install-Module -Name NtObjectManager**
    command, and the source code can be found on GitHub at the following link: [https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools](https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools).'
  prefs: []
  type: TYPE_NORMAL
- en: DSInternals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DSInternals** is a powerful Active Directory suite developed by Michael Grafnetter
    that consists of two parts – a framework that exposes various internal components
    of Active Directory that can be accessed from any .NET application, and a PowerShell
    module that provides a range of cmdlets built on top of the framework. The module
    offers extensive functionality, including the ability to audit Azure AD FIDO2
    keys, AD passwords, and key credentials, and perform bare-metal recovery of domain
    controllers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'DSInternals can be easily installed using the **Install-Module DSInternals**
    command, or you can download it from GitHub at the following link: [https://github.com/MichaelGrafnetter/DSInternals](https://github.com/MichaelGrafnetter/DSInternals).'
  prefs: []
  type: TYPE_NORMAL
- en: With its many features and capabilities, DSInternals is a valuable resource
    for blue teamers who need to manage and secure their Active Directory environment.
  prefs: []
  type: TYPE_NORMAL
- en: PSScriptAnalyzer and InjectionHunter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PSScriptAnalyzer** is a tool that helps you improve the quality and security
    of your PowerShell scripts and modules. It checks your code against predefined
    rules and provides recommendations for any potential defects it finds. You can
    install PSScriptAnalyzer using the **Install-Module PSScriptAnalyzer** command,
    or you can download it from GitHub at the following link: [https://github.com/PowerShell/PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer).'
  prefs: []
  type: TYPE_NORMAL
- en: '**InjectionHunter** is a module developed by Lee Holmes that helps you detect
    potential opportunities for code injection in your own PowerShell scripts. To
    use InjectionHunter, you need to have PSScriptAnalyzer installed, as it relies
    on the **ScriptAnalyzer.Generic.DiagnosticRecord** output type and uses custom
    detection rules. You can install InjectionHunter using the **Install-Module InjectionHunter**
    command, or you can find it in the PowerShell Gallery at the following link: [https://www.powershellgallery.com/packages/InjectionHunter/1.0.0](https://www.powershellgallery.com/packages/InjectionHunter/1.0.0).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also refer to the official blog post on InjectionHunter: [https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/](https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/).'
  prefs: []
  type: TYPE_NORMAL
- en: Later in [*Chapter 13*](B16679_13_Final_PD.xhtml#_idTextAnchor341), *What Else?
    – Further Mitigations and Resources*, we will also take a closer look at both
    tools and how they can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Revoke-Obfuscation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Revoke-Obfuscation** is a PowerShell obfuscation detection framework developed
    by Daniel Bohannon and Lee Holmes. Compatible with PowerShell v3 and later, this
    tool helps blue teamers detect obfuscated PowerShell scripts and commands at scale.
    Unlike other solutions that rely on simple **indicators of compromise** (**IOCs**)
    or regular expression matching, Revoke-Obfuscation uses PowerShell’s **abstract
    syntax tree** (**AST**) to extract features from a script, making it more robust
    in detecting even unknown obfuscation techniques.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily install Revoke-Obfuscation using the **Install-Module Revoke-Obfuscation**
    command, or you can download it from GitHub at the following link: [https://github.com/danielbohannon/Revoke-Obfuscation](https://github.com/danielbohannon/Revoke-Obfuscation).'
  prefs: []
  type: TYPE_NORMAL
- en: Posh-VirusTotal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a defender, it’s critical to regularly check files, domains, IPs, and URLs
    for malware. One popular service to do this is **VirusTotal** ([https://www.virustotal.com](https://www.virustotal.com)),
    which allows you to quickly check whether a file hash or URL is considered malicious
    and whether it would be detected by one or more security vendors. However, manually
    uploading each file or checking URLs one by one can be time-consuming and tedious.
  prefs: []
  type: TYPE_NORMAL
- en: That’s where the PowerShell module **Posh-VirusTotal** comes in. Developed by
    Carlos Perez, this tool enables you to automate your VirusTotal submissions and
    save time in your busy schedule. It’s compatible with PowerShell v3 and higher
    and can use either the public or private version 2 API provided by VirusTotal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily install Posh-VirusTotal using the **Install-Module Posh-VirusTotal**
    command, or you can download it from GitHub at the following link: https://github.com/darkoperator/Posh-VirusTotal.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using an older version of PowerShell, such as v3, you can also install
    Posh-VirusTotal using the **iex (New-Object** **Net.WebClient).DownloadString("https://gist.githubusercontent.com/darkoperator/9138373/raw/22fb97c07a21139a398c2a3d6ca7e3e710e476bc/PoshVTInstall.ps1")**
    command.
  prefs: []
  type: TYPE_NORMAL
- en: With Posh-VirusTotal, you can streamline your malware checks and stay one step
    ahead of threats.
  prefs: []
  type: TYPE_NORMAL
- en: EventList
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**EventList** is a useful tool that I developed to help you improve your audit
    capabilities and build a more effective **security operations center** (**SOC**).
    Developed to combine Microsoft security baselines with MITRE ATT&CK, EventList
    enables you to generate hunting queries for your SIEM system, regardless of the
    product you use.'
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging the power of EventList, you can take a proactive approach to detecting
    and responding to security threats.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be installed using the **Install-Module EventList** command or downloaded
    from GitHub: [https://github.com/miriamxyra/EventList](https://github.com/miriamxyra/EventList).'
  prefs: []
  type: TYPE_NORMAL
- en: JEAnalyzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Just Enough Administration** (**JEA**) is a powerful tool to secure the PowerShell
    commands that administrators and users are allowed to use in your environment.
    However, configuring and auditing JEA roles can be a tedious and time-consuming
    task. That’s where JEAnalyzer comes in.'
  prefs: []
  type: TYPE_NORMAL
- en: Developed by Miriam Wiesner and Friedrich Weinmann, this tool simplifies the
    implementation and management of JEA, as well as providing tools to scan commands
    for potential danger when exposed in a JEA endpoint and creating JEA endpoints
    simply and conveniently.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily install JEAnalyzer using the **Install-Module JEAnalyzer** command,
    or you can download it from GitHub at the following link: https://github.com/PSSecTools/JEAnalyzer.'
  prefs: []
  type: TYPE_NORMAL
- en: All these PowerShell modules come in very handy for blue teamers, as they can
    assist in tasks such as live response, hunt, forensics, and reverse engineering.
    These tools can help streamline workflows and defend against cyber threats by
    analyzing system logs, gathering system information, detecting malicious activity,
    analyzing attack surfaces, identifying and decoding potentially malicious data,
    searching for indicators of compromise, and many more use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Blue team cookbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following subsections, you will find some code snippets that come in
    handy for your daily life as a blue team PowerShell practitioner. Blue teaming
    is quite extensive; therefore, you won’t find use cases for every scenario but,
    rather, some of the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Also, refer to [*Chapter 8*](B16679_08_Final_PD.xhtml#_idTextAnchor204), *Red
    Team Tasks and Cookbook*, as you will find many red teamer code snippets and scripts
    there that can also sometimes be useful for a blue teamer.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for installed updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find out which updates were installed on one or more remote systems.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the **Get-InstalledUpdates.ps1** script to scan an IP range for
    installed Windows updates. You can find the script in the GitHub repository of
    this chapter: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter09/Get-InstalledUpdates.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter09/Get-InstalledUpdates.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this example to scan the **172.29.0.10-20** IP range for installed updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**-MinIP** represents the smallest last IP address octet, while -**MaxIP**
    represents the highest last IP address octet. Enabling the **-Verbose** parameter
    allows the script to display a detailed output of its actions. It is also possible
    to use the **-MaxJobs** parameter to define how many jobs can be run in parallel
    to check updates.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking for missing updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find out which updates are missing on one or more remote host(s).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the **Scan-RemoteUpdates.ps1** script to check for missing Windows
    updates – either on the localhost or on one or more remote host(s). You can find
    the script in the GitHub repository of this chapter: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter09/Scan-RemoteUpdates.ps1](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter09/Scan-RemoteUpdates.ps1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scanning only the localhost is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Scanning for multiple remote hosts is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the **-Force** parameter is specified, the **wsusscn2.cab** file will be
    deleted if present and a new version will be downloaded. Use the **-CabPath**
    parameter to specify where the **wsusscn2.cab** file should be downloaded. If
    nothing is specified, it will be downloaded to **$env:temp\wsusscn2.cab**. If
    **-DoNotDeleteCabFile** is present, the **wsusscn2.cab** file will not be deleted
    after the check.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the PowerShell history of all users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During an incident response, you want to review the PowerShell history of all
    users on a system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Get-History** cmdlet would only get the current shell’s history, which
    is not very helpful. To review the entire PowerShell history of each user, you
    can loop through the **ConsoleHost_history.txt** files on a system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you would loop through all the **ConsoleHost_history.txt**
    files of all users, as well as through the system profile (if available).
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the event log of a remote host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to inspect the event log of a remote host and search for specific patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use **Get-WinEvent** to get all events on a (remote) host and filter
    for specific patterns. Please note that the RemoteRegistry service needs to run
    on the remote host in order for the **Get-WinEvent** cmdlet to work remotely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using this example, you would connect to the remote host, **PSSec-PC01.PSSec.local**,
    and retrieve all events in the **Microsoft-Windows-Powershell/Operational** event
    log and save them into the **$LogEntries** variable. This allows you to quickly
    operate with the events by not always connecting remotely and, instead, operating
    the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Using the **$LogEntries** variable, you could filter for specific events or
    strings. In this example, we filter for events with the **4104** event ID that
    contain the **"Mimikatz"** string in the message body. The wildcards, *****, indicate
    that other characters could prefix or suffix the search term **"Mimikatz"**.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that if you want to query the PowerShell Core log instead, you would
    need to change the **$EventLog** variable to **"PowerShellCore/Operational"**.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell remoting versus the -ComputerName parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth mentioning that PowerShell remoting can be used to remotely execute
    any cmdlet, regardless of whether the cmdlet has a **-ComputerName** parameter
    or not. This can be particularly useful in cases where the **-ComputerName** parameter
    does not work, due to closed DCOM ports or other reasons. As an example, to retrieve
    log entries from a remote computer, you can use the following command: – **Invoke-Command
    -ComputerName $ComputerName -ScriptBlock { Get-WinEvent -LogName $EventLog | Where-Object
    Id -eq 4104 | Where-Object Message -like "****Mimikatz" }**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also assess multiple remote hosts by looping them through using **foreach**,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can assess the events collected using the **$LogEntries** variable. To get
    an overview of how many events were collected from which hosts, you can use **Group-Object**
    and group by **MachineName**.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring to bypass powershell.exe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to monitor for the execution of PowerShell without the use of the **powershell.exe**
    binary.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To monitor the execution of PowerShell without the use of the **powershell.exe**
    binary, there are two solutions. Option number one is to use the Windows PowerShell
    event log and look for the **400** event ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there are multiple legitimate reasons to execute PowerShell without the
    **powershell.exe** binary, you might want to adjust this query to your environment.
    On a regular Windows 10 client system, on which the PowerShell ISE is also used,
    the following code snippet could be helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For option number two, you need to have Sysmon installed on all systems on
    which you want to detect the bypass of the **powershell.exe** binary. Sysmon is
    part of the Sysinternals suite and can be downloaded here: [https://learn.microsoft.com/en-us/sysinternals/downloads/sysmon](https://learn.microsoft.com/en-us/sysinternals/downloads/sysmon).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Sysmon is installed and configured, you will need to look for the following
    DLLs using Sysmon’s event ID 7, **"****Image loaded"**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System.Management.Automation.dll**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System.Management.Automation.ni.dll**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can now search for potential bypasses of the **powershell.exe** binary,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you have an EDR in place that helps you detect similar events, you don’t
    need Sysmon to detect the PowerShell .NET assembly calls, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Getting specific firewall rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to filter specific firewall rules using PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can get all firewall rules and filter for specific ones using the **Get-NetFirewallRule**
    cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many parameter filter options available using **Get-NetFirewallRule**.
    To get, for example, all enabled firewall rules that have the direction inbound
    and are allow rules, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the **Get-NetFirewallProfile** cmdlet, together with **Get-NetFirewallRule**,
    to retrieve all firewall rules that were created for a particular firewall profile.
    By using the following example, you would get all firewall rules that were created
    for the **Public** firewall profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Allowing PowerShell communication only for private IP address ranges
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to restrict PowerShell communication to happen only in your own network
    and avoid PowerShell communicating to potential C2 servers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a new firewall rule using **New-NetFirewallRule** to lock down PowerShell
    communication to private IP address ranges only.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates a new firewall rule, with the name **Block Outbound
    PowerShell connections**, that restricts Windows PowerShell from establishing
    connections with IP addresses outside of the local network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Use this example and adjust it to your needs. As most organizations still use
    Windows PowerShell as their default PowerShell instance, this example also refers
    to Windows PowerShell. If you are using PowerShell Core as your default PowerShell
    instance, you might want to adjust the path to the program.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating a compromised system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to isolate a compromised system.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can do this by using the **New-NetFirewallRule** and **Disable-NetAdapter**
    cmdlets. The following code snippet demonstrates how you can remotely isolate
    a device. First, it sends a message to all users that are currently logged on
    **PSSec-PC01**, then it remotely creates firewall rules to block all inbound and
    outbound connections, and then disables all network adapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Just replace **PSSec-PC01** with the computer name of your choice, and feel
    free to adjust the message that will be sent to the computer users.
  prefs: []
  type: TYPE_NORMAL
- en: Checking out installed software remotely
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find out what software is installed on a remote PC.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can check out what software is installed on a remote PC by using the **Get-CimInstance**
    cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code will let you connect to a computer named **PSSec-PC01**
    and find out which software it currently has installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Starting a transcript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to enable an over-the-shoulder transcription to track what is happening
    in a PowerShell session.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Enable a transcript on the machine on which you want to track what is happening
    in a PowerShell session. This can be done by either enabling the transcript via
    Group Policy by configuring the **Turn on PowerShell Transcription** option under
    **Windows Components** | **Administrative Templates** | **Windows PowerShell**,
    or by configuring it using PowerShell to configure the registry, as shown in the
    blog article *PowerShell* *♥* *the Blue* *Team*: [https://devblogs.microsoft.com/powershell/powershell-the-blue-team/](https://devblogs.microsoft.com/powershell/powershell-the-blue-team/
    )'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the **Enable-PSTranscription** function, which
    originates from this article:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you used this function to enable transcription to the **C:\tmp** folder,
    the syntax would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can also use a **Universal Naming Convention** (**UNC**) path to save the
    transcript to a network folder. Make sure to secure the path so that a potential
    attacker cannot access and/or delete it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To centralize PowerShell transcripts and maintain a secure audit trail, you
    can, for example, configure the transcript destination as a UNC path with a dynamic
    filename. This involves setting the transcript directory to a network share with
    write-only permission and using the PowerShell profile to log all activity to
    a file with a unique name, based on system and user variables, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will create a unique transcript file for each user and computer combination,
    with the current date and time included in the filename. By storing transcripts
    in a centralized location with restricted access, you can ensure that all activity
    is logged and available for review and analysis as needed.
  prefs: []
  type: TYPE_NORMAL
- en: This will write all transcripts to the specified file server location, which
    can then be accessed by authorized personnel for review and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for expired certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check for SSL certificates in your certificate store that have already
    expired or will expire in the next 60 days.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the following script to check for SSL certificates in your certificate
    store that have already expired or will expire in the next 60 days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can also alter the path to **Cert:\LocalMachine\My** to only assess certificates
    from the personal store. For certificates from the **root** store, change the
    path to **Cert:\LocalMachine\Root**.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the digital signature of a file or a script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check the authenticity and integrity of software or a script by
    checking the digital signature.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can check the status of a digital signature by using the **Get-AuthenticodeSignature**
    cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using **Get-AuthenticodeSignature**, you get all sorts of useful information
    about the digital signature, such as the certificate chain, which is demonstrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Query information about the digital signature of a file](image/B16679_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Query information about the digital signature of a file
  prefs: []
  type: TYPE_NORMAL
- en: However, if you prefer to query the status only, you can also use the **(Get-AuthenticodeSignature
    "****C:\Windows\notepad.exe").Status** command.
  prefs: []
  type: TYPE_NORMAL
- en: Checking file permissions of files and folders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to enumerate the access rights of files and folders.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enumerate the access rights of files and folders, you can use the **Get-ChildItem**
    and **Get-Acl** cmdlets. To enumerate, for example, all files and folders in the
    **Windows Defender** directory recursively, you can use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If you want to enumerate on one level only, make sure to remove the **-****Recurse**
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying all running services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to display all running services and their command paths.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although you can use the **Get-Service** cmdlet to display all running services,
    you can also use **Get-CimInstance** to access the WMI information of the services
    and get even more information, such as the command path or **ProcessId**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Stopping a service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to stop a service from running.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To stop a service from running, you can use the **Stop-Service** cmdlet. The
    following example shows you how to combine **Get-Service** with **Stop-Service**
    to stop the **maliciousService** service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that if you use the **-Confirm:$false** parameter, the confirmation
    prompt will be bypassed, and the command will be executed without any further
    confirmation. It’s recommended to use this parameter with caution and only in
    situations where you are fully aware of the potential risks and consequences.
    It’s important to thoroughly understand the implications of using this parameter
    and make an informed decision based on your specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying all processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to display all processes, including their owners and command lines.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can display all processes and more information about them by using **Get-WmiObject
    win32_process**. To display all processes, including their owners and command
    lines, you can use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Stopping a process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to stop a process.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To stop a process, you can use the **Stop-Process** cmdlet. To stop, for example,
    the process with **Id 8336**, you can use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It is, of course, also possible to select a process by its name with the **-Name**
    parameter of the **Get-Process** cmdlet to stop it. If there is more than one
    process with the same name, it can happen that multiple processes will be stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that if you use the **-Confirm:$false** parameter, the confirmation
    prompt will be bypassed, and the command will be executed without any further
    confirmation. It’s recommended to use this parameter with caution and only in
    situations where you are fully aware of the potential risks and consequences.
    It’s important to thoroughly understand the implications of using this parameter
    and make an informed decision based on your specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling a local account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to disable a local account.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To disable a local account, you can use the **Disable-LocalUser** cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: One way to improve security in Windows is to create a new user with administrative
    privileges and disable the default **Administrator** account. This helps prevent
    brute-force attacks that often target the default account. To achieve this, you
    can use the **Disable-LocalUser** cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that demonstrates how to disable the **Administrator** account
    using the **Disable-LocalUser** cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the command, you can use the **Get-LocalUser** cmdlet to verify
    that the account has been disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Enabling a local account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to enable a local account.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enable a local account, you can use the **Enable-LocalUser** cmdlet. Using
    the following example, the **Administrator** account would be enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the **Get-LocalUser** cmdlet, you can verify that the account was enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Disabling a domain account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to disable a domain account.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To disable a domain account, you can use the **Disable-ADAccount** cmdlet,
    which is part of the **ActiveDirectory** module. Using the following example,
    the **vvega** domain account would be disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the **Get-ADUser** cmdlet, you can verify that the account was disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Enabling a domain account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to enable a domain account.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enable a domain account, you can use the **Enable-ADAccount** cmdlet, which
    is part of the **ActiveDirectory** module. Using the following example, the **vvega**
    domain account would be enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the **Get-ADUser** cmdlet, you can verify that the account was disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving all recently created domain users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to retrieve all domain users that were recently created.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To retrieve all users that were created in the last 30 days, you can use the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Checking whether a specific port is open
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check whether a specific port on a remote system is open.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out whether a specific port is open, you can use the following code
    snippet; this example checks whether port **445** is open on the computer **DC01**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Checking whether port 445 is open on DC01](image/B16679_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Checking whether port 445 is open on DC01
  prefs: []
  type: TYPE_NORMAL
- en: This method is a good way to test for a single port or for very few ports, as
    the **Test-NetConnection** cmdlet can be very time-consuming if used for a full
    port scan. Therefore, if you want to scan all ports of a remote system, you should
    instead use **nmap**.
  prefs: []
  type: TYPE_NORMAL
- en: Showing TCP connections and their initiating processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to display all TCP connections, the initiating processes, as well as
    the command line that was used to open the TCP connection.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use **Get-NetTCPConnection** and create manual properties by using
    **Get-Process** and **Get-WmiObject** as **Select-Object** expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This example shows all TCP connections, the local address and port, the remote
    address and port, the state of the connection, the name of the process, as well
    as the command line that was executed to initiate the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Showing UDP connections and their initiating processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to display all UDP connections, the initiating processes, as well as
    the command line that was used to open the UDP connection.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use **Get-NetUDPConnection** and create manual properties by using
    **Get-Process** and **Get-WmiObject** as **Select-Object** expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This example shows all UDP connections, the creation time, the local address
    and port, the name of the process, as well as the command line that was executed
    to initiate the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for downgrade attacks using the Windows event log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to search for past downgrade attacks using the Windows event log.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can search for past downgrade attacks using the Windows event log with
    the following code snippet, which was originally written by Lee Holmes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Monitor for the **400** event ID in the Windows PowerShell event log. If **EngineVersion**
    is lower than **5**, you should definitely investigate further, as this could
    indicate a downgrade attack.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing downgrade attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to prevent downgrade attacks from happening and, therefore, use **Windows
    Defender Application Control** (**WDAC**) to disable PowerShell version 2 binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PowerShell version 2 cannot load if the **System.Management.Automation.dll**
    and **System.Management.Automation.ni.dll** assemblies are blocked, even if .NET
    Framework version 2 is installed and PowerShell version 2 is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code snippets to find out where those binaries are located
    to block them, using WDAC or another application control software of your choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you remove **-version 2** from the preceding code snippets, you will see
    that there are other binaries used for modern PowerShell versions. Therefore,
    you should not be afraid of breaking anything if your system relies on a modern
    PowerShell version and if you want to prohibit PowerShell version 2 binaries globally.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have located the PowerShell binaries, you can use WDAC to block
    these legacy versions. Make sure to block the native image as well as the **Microsoft
    intermediate language (****MSIL)** assemblies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to Lee Holmes’ blog post to learn more about detecting and preventing
    PowerShell downgrade attacks: [https://www.leeholmes.com/detecting-and-preventing-powershell-downgrade-attacks/](https://www.leeholmes.com/detecting-and-preventing-powershell-downgrade-attacks/).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter first explored the *protect, detect, and respond* approach, emphasizing
    the importance of each pillar and its role in ensuring the security of an organization.
  prefs: []
  type: TYPE_NORMAL
- en: We then provided a comprehensive overview of commonly used PowerShell tools,
    which are essential for blue teamers to defend an organization against security
    threats.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the blue team cookbook, a collection of scripts and code snippets for
    security analysis and defense, was explored. The cookbook covers a wide range
    of tasks, including checking updates, monitoring bypasses, and analyzing event
    logs, processes, services, and network connections. The blue team cookbook serves
    as a valuable resource for information security practitioners, providing practical
    solutions to various security challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed daily blue team operations, let’s explore further mitigation
    options that can help you secure your environment when using PowerShell. In the
    next chapter, we’ll delve into language modes and **Just Enough** **Administration**
    (**JEA**).
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to explore some of the topics that were mentioned in this chapter,
    follow these resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Blue Team Notes: https://github.com/Purp1eW0lf/Blue-Team-Notes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blue Team Tips: [https://sneakymonkey.net/blue-team-tips/](https://sneakymonkey.net/blue-team-tips/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A collection of PowerShell functions and scripts a blue teamer might use: [https://github.com/tobor88/PowerShell-Blue-Team](https://github.com/tobor88/PowerShell-Blue-Team)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating and Starting a Windows Service Remotely Using NtObjectManager Via
    Remote Procedure Calls (RPC) Over SMB: [https://blog.openthreatresearch.com/ntobjectmanager_rpc_smb_scm](https://blog.openthreatresearch.com/ntobjectmanager_rpc_smb_scm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detecting and Preventing PowerShell Downgrade Attacks: [https://www.leeholmes.com/detecting-and-preventing-powershell-downgrade-attacks/](https://www.leeholmes.com/detecting-and-preventing-powershell-downgrade-attacks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Directory Services Internals Blog: [https://www.dsinternals.com/en/](https://www.dsinternals.com/en/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Investigating PowerShell Attacks: [https://www.fireeye.com/content/dam/fireeye-www/global/en/solutions/pdfs/wp-lazanciyan-investigating-powershell-attacks.pdf](https://www.fireeye.com/content/dam/fireeye-www/global/en/solutions/pdfs/wp-lazanciyan-investigating-powershell-attacks.pdf'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerForensics - PowerShell Digital Forensics: [https://powerforensics.readthedocs.io/en/latest/](https://powerforensics.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PowerShell ♥ the Blue Team: [https://devblogs.microsoft.com/powershell/powershell-the-blue-team/](https://devblogs.microsoft.com/powershell/powershell-the-blue-team/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing adversary technique variations with AtomicTestHarnesses: [https://redcanary.com/blog/introducing-atomictestharnesses/](https://redcanary.com/blog/introducing-atomictestharnesses/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tracking WMI Activity with PSGumshoe: [https://www.darkoperator.com/blog/2022/3/27/tracking-wmi-activity-with-psgumshoe](https://www.darkoperator.com/blog/2022/3/27/tracking-wmi-activity-with-psgumshoe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows Sandbox Attack Surface Analysis: [https://googleprojectzero.blogspot.com/2015/11/windows-sandbox-attack-surface-analysis.html](https://googleprojectzero.blogspot.com/2015/11/windows-sandbox-attack-surface-analysis.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also find all links mentioned in this chapter in the GitHub repository
    for [*Chapter 9*](B16679_09_Final_PD.xhtml#_idTextAnchor228) – there’s no need
    to manually type in every link: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter09/Links.md](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter09/Links.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Securing PowerShell – Effective Mitigations In Detail'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will mostly concentrate on mitigations that can help you to
    secure your environment efficiently. However, again, although we will focus on
    a lot of blue team stuff, this section also helps red teamers understand how mitigation
    technologies work, what risks they contain, and how adversaries are attempting
    to develop bypasses.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll explore J**ust Enough Administration** (**JEA**), a feature that
    helps with delegating administrative tasks to non-administrative users. Although
    this feature is not very well known widely, it can be a game-changer. In this
    part, we will dive deep into JEA and its configuration options, and we will learn
    how to simplify the initial deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look into code signing and Application Control. You will learn
    how to plan for deploying Application Control, and throughout our journey, we
    will work with Microsoft’s Application Control solutions AppLocker and **Windows
    Defender Application Control** (**WDAC**). You will familiarize yourself with
    how those solutions are configured and audited. You will also gain insights into
    how PowerShell will change when Application Control is configured.
  prefs: []
  type: TYPE_NORMAL
- en: Dive into the **Antimalware Scan Interface** (**AMSI**) – learn how it works
    and why it is really helpful in the fight against malware. We will also look into
    ways that adversaries bypass this useful feature, by either surrogating it or
    obfuscating their malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: Many other features can help you mitigate risk in your environment; therefore,
    at the end of this part, we will glance at many different features that can help
    you improve your posture. We will look into secure scripting, the desired state
    configuration, hardening strategies for systems and environments, and attack detection
    with **endpoint detection and response** (**EDR**) software. We are not diving
    deep in this last section and you are more than welcome to explore some of the
    features mentioned further to learn more about them and possibly use them in your
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B16679_10_Final_PD.xhtml#_idTextAnchor278), *Language Modes
    and Just Enough Administration (JEA)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B16679_11_Final_PD.xhtml#_idTextAnchor306), *AppLocker, Application
    Control, and Code Signing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B16679_12_Final_PD.xhtml#_idTextAnchor324), *Exploring the Antimalware
    Scan Interface (AMSI)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B16679_13_Final_PD.xhtml#_idTextAnchor341), *What Else? – Further
    Mitigations and Resources*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
