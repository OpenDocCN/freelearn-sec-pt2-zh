<html><head></head><body>
		<div id="_idContainer254">
			<h1 class="chapter-number" id="_idParaDest-293"><a id="_idTextAnchor306"/>11</h1>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor307"/>AppLocker, Application Control, and Code Signing</h1>
			<p>In an enterprise environment, it is critical to keep control over what software is installed and what software is being kept out of the environment – not only to keep an overview of what software is available but also to help fight against threats such as malicious scripts or malware such <span class="No-Break">as ransomware.</span></p>
			<p>But how can code signing and application control help you secure your environment in a better way and how can it be implemented? What do you need to do when planning for implementing an application control solution and what built-in application control solutions are available on Windows <span class="No-Break">operating systems?</span></p>
			<p>We’ll explore this and much more in this chapter about AppLocker, application control, and code signing. In this chapter, you will get a deeper understanding of the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Preventing unauthorized script execution with <span class="No-Break">code signing</span></li>
				<li>Controlling applications <span class="No-Break">and scripts</span></li>
				<li>Getting familiar with <span class="No-Break">Microsoft AppLocker</span></li>
				<li>Exploring Windows Defender <span class="No-Break">Application Control</span></li>
			</ul>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor308"/>Technical requirements</h1>
			<p>To get the most out of this chapter, ensure that you have <span class="No-Break">the following:</span></p>
			<ul>
				<li>PowerShell 7.3 <span class="No-Break">and above</span></li>
				<li>Installed Visual <span class="No-Break">Studio Code</span></li>
				<li>A virtual machine running Windows 10 or above for <span class="No-Break">test purposes</span></li>
				<li>Access to the GitHub repository for <span class="No-Break"><strong class="source-inline">Chapter11</strong></span><span class="No-Break">: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter11"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter11</span></a><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter11"/></li>
			</ul>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor309"/>Preventing unauthorized script execution with code signing</h1>
			<p>If you <a id="_idIndexMarker1845"/>want to verify that the executed script is legit code and is allowed to be executed by your company, you want to<a id="_idIndexMarker1846"/> implement a proper code-signing strategy. It’s a brilliant way to protect your regularly executed scripts against tampering – or at least if someone were to tamper with your scripts, they would not be executed if your environment is configured in the <span class="No-Break">right way.</span></p>
			<p>It’s important to note that dynamic runtimes can pose a common blind spot when implementing application control policies. While PowerShell made a significant impact to ensure that the PowerShell runtime can be restricted by application control rules, other dynamic runtimes such as Python, Node, Perl, PHP, and more may still allow you to run unrestricted code, which might present a vulnerability if it’s not managed appropriately. If other dynamic runtimes are not needed on your clients, it’s better to block them or restrict them as much as possible to maintain a strong <span class="No-Break">security posture.</span></p>
			<p>The WSH language family has implemented application control awareness in a quite straightforward manner: they simply prevent the execution of any scripts that are not permitted by <span class="No-Break">the policy.</span></p>
			<p>When we talked about <strong class="bold">execution policies</strong> in earlier chapters, such as <a href="B16679_01_Final_PD.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Getting Started with PowerShell</em>, we looked at the <strong class="source-inline">AllSigned</strong> or <strong class="source-inline">RemoteSigned</strong> parameters. If <strong class="source-inline">AllSigned</strong> is configured, all unsigned PowerShell scripts are prevented from running – if <strong class="source-inline">RemoteSigned</strong> is configured, only local unsigned scripts are allowed. Of course, the execution policy can be bypassed at any time as it’s not a security boundary – however, this prevents your users from unintentionally running scripts they <span class="No-Break">don’t know.</span></p>
			<p>Combining code signing with other tools such as AppLocker or <strong class="bold">WDAC</strong> is powerful as you can ensure that no other scripts except for the configured signed ones are allowed in <span class="No-Break">your infrastructure.</span></p>
			<p>But to start with code signing, we first need a certificate to sign the code with. There are several options as to what kind of certificate you can use. You could either use a self-signed certificate or a corporate one (either on a forest or a public level) that your company <span class="No-Break">paid for.</span></p>
			<p>Self-signed certificates<a id="_idIndexMarker1847"/> are <a id="_idIndexMarker1848"/>usually for testing purposes only and if you want to take your code-signing infrastructure into production, you should at least consider using a certificate signed by your corporate <strong class="bold">certificate authority</strong> (<strong class="bold">CA</strong>) to <a id="_idIndexMarker1849"/>make your deployment <span class="No-Break">more secure.</span></p>
			<p>The following figure should provide you with an overview of some different scenarios when it comes to <span class="No-Break">code signing:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer223">
					<img alt="Figure 11.1 – Overview of the different possibilities of code-signing certificates" src="image/B16679_11_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Overview of the different possibilities of code-signing certificates</p>
			<p>In this chapter, we will use a self-signed certificate to sign our scripts – please make sure you adjust your certificate if you want to use it <span class="No-Break">in production.</span></p>
			<p>A self-signed certificate is only valid on your local computer and can be created using the <strong class="source-inline">New-SelfSignedCertificate</strong> cmdlet. In earlier days, <strong class="source-inline">makecert.exe</strong> was used to create self-signed certificates, but ever since <strong class="source-inline">New-SelfSignedCertificate</strong> was introduced with Windows 8, you can simply create self-signed certificates and sign scripts <span class="No-Break">using PowerShell.</span></p>
			<p>Certificates created using this cmdlet can be stored either in the current user’s personal certificate store by going to <strong class="bold">Certificates</strong> | <strong class="bold">Current User</strong> | <strong class="bold">Personal</strong> (<strong class="source-inline">Cert:\CurrentUser\My</strong>) or the local machine’s personal certificate store by going to <strong class="bold">Certificates</strong> | <strong class="bold">Local Computer</strong> | <strong class="bold">Personal</strong> (<strong class="source-inline">Cert:\LocalMachine\My</strong>). Certificates that are created in the local computer’s certificate store are available computer-wide, while the ones created in the current user’s store are scoped to the current <span class="No-Break">user only.</span></p>
			<p>Let’s <a id="_idIndexMarker1850"/>create a self-signed certificate<a id="_idIndexMarker1851"/> and add it to the computer’s root certificate store, as well as to the computer’s <strong class="source-inline">Trusted Publishers</strong> store. First, we must create a new certificate called <strong class="source-inline">"Test Certificate"</strong> in the local machine’s certificate store and save the output in the <strong class="source-inline">$testCert</strong> variable. We will need this variable later to <a id="_idIndexMarker1852"/>register the <span class="No-Break"><strong class="bold">authenticode certificate</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; $testCert = New-SelfSignedCertificate -Subject "Test Certificate" -CertStoreLocation Cert:\LocalMachine\My -Type CodeSigningCert</pre>
			<p>Once we’ve done this, we will add the authenticode certificate to our computer’s root certificate store. A root certificate store is a list of trusted root CA certificates, so every certificate in this store will <span class="No-Break">be trusted.</span></p>
			<p>We must move the newly created certificate from <a id="_idIndexMarker1853"/>the intermediate CA store to the <strong class="bold">root </strong><span class="No-Break"><strong class="bold">certificate store</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Move-Item Cert:\LocalMachine\CA\$($testCert.Thumbprint) Cert:\LocalMachine\Root</pre>
			<p>Now, your certificate should be available in<a id="_idIndexMarker1854"/> two <span class="No-Break">different locations:</span></p>
			<ul>
				<li><strong class="bold">The local machine’s personal certificate store</strong>: This certificate will be used as the <span class="No-Break">code-signing certificate.</span></li>
				<li><strong class="bold">The local machine’s root certificate store</strong>: Adding the certificate to the machine’s root certificate store ensures that the local computer trusts certificates in the personal as well as the <strong class="bold">Trusted Publishers </strong><span class="No-Break">certificate store.</span></li>
			</ul>
			<p>You can verify that all the certificates are in the right place by either using PowerShell or by using <strong class="source-inline">mmc</strong> with the local computer’s certificate snap-in (run <strong class="source-inline">mmc</strong>, add the <strong class="bold">Certificates</strong> snap-in, and add the local computer scope), as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer224">
					<img alt="Figure 11.2 – Looking for the newly created Test Certificate" src="image/B16679_11_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Looking for the newly created Test Certificate</p>
			<p>If you want <a id="_idIndexMarker1855"/>to use PowerShell to check if all the certificates were created, run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; Get-ChildItem Cert:\LocalMachine\ -Recurse -DnsName "*Test Certificate*"</pre>
			<p>You can <a id="_idIndexMarker1856"/>see the output of this command in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer225">
					<img alt="Figure 11.3 – Verifying that all the certificates are in the right place" src="image/B16679_11_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Verifying that all the certificates are in the right place</p>
			<p>Now that we have created our local certificate, we can start self-signing scripts using the <span class="No-Break"><strong class="source-inline">Set-AuthenticodeSignature</strong></span><span class="No-Break"> cmdlet.</span></p>
			<p>For this example, I am reusing the <strong class="source-inline">HelloWorld.ps1</strong> PowerShell script that we created in <a href="B16679_01_Final_PD.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Getting Started with PowerShell</em>, which can be downloaded from this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter01/HelloWorld.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter01/HelloWorld.ps1</span></a><span class="No-Break">.</span></p>
			<p>Save the script <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">C:\tmp\HelloWorld.ps1</strong></span><span class="No-Break">.</span></p>
			<p>If you still have the <strong class="source-inline">$testCert</strong> variable available in your session, which we used earlier when creating the certificate, you can, of course, reuse it, but most of the time, when you want to sign a script, time has already passed and you’ve closed the session so that the variable isn’t available for you <span class="No-Break">to use.</span></p>
			<p>Therefore, first, assign the certificate to a variable that you will use to sign <span class="No-Break">your script:</span></p>
			<pre class="source-code">
&gt; $signingCertificate = Get-ChildItem Cert:\LocalMachine\ -Recurse -DnsName "*Test Certificate*"</pre>
			<p>Make sure<a id="_idIndexMarker1857"/> you specify the correct name of the certificate that you <span class="No-Break">created earlier.</span></p>
			<p>To <a id="_idIndexMarker1858"/>ensure that the signature on the file remains valid, even after the certificate expires after a year, it is important to use a trustworthy timestamp server when signing the script. You can do this using <strong class="source-inline">Set-AuthenticodeSignature</strong>. The timestamp server adds a timestamp to the signed code that indicates the exact date and time when the code was signed. This timestamp is used to prove that the code was signed before the certificate expired, even if the certificate has <span class="No-Break">since expired.</span></p>
			<p>Therefore, it is recommended to always use a reliable and well-known timestamp server to ensure the longevity and authenticity <a id="_idIndexMarker1859"/>of your signed code. The <strong class="bold">Time-Stamp Protocol</strong> (<strong class="bold">TSP</strong>) standard is defined in <strong class="bold">RFC3161</strong> and you can read more <a id="_idIndexMarker1860"/>about it <span class="No-Break">here: </span><a href="https://www.ietf.org/rfc/rfc3161.txt"><span class="No-Break">https://www.ietf.org/rfc/rfc3161.txt</span></a><span class="No-Break">.</span></p>
			<p>There’s a great (but of course non-complete) list that’s been published by David Manouchehri that you can use to choose your preferred timestamp <span class="No-Break">server: </span><a href="https://gist.github.com/Manouchehri/fd754e402d98430243455713efada710"><span class="No-Break">https://gist.github.com/Manouchehri/fd754e402d98430243455713efada710</span></a><span class="No-Break">.</span></p>
			<p>For our example, I am using the <span class="No-Break"><strong class="source-inline">http://timestamp.digicert.com</strong></span><span class="No-Break"> s</span><span class="No-Break">erver:</span></p>
			<pre class="source-code">
&gt; Set-AuthenticodeSignature -FilePath "C:\tmp\HelloWorld.ps1" -Certificate $signingCertificate -TimeStampServer "http://timestamp.digicert.com"</pre>
			<p>Once the script has been signed successfully, the output will look similar to <span class="No-Break">the following:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer226">
					<img alt="Figure 11.4 – Script signed successfully" src="image/B16679_11_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Script signed successfully</p>
			<p>You can <a id="_idIndexMarker1861"/>verify that a script has <a id="_idIndexMarker1862"/>been signed by using the <strong class="source-inline">Get-AuthenticodeSignature -FilePath C:\tmp\HelloWorld.ps1 | Format-List</strong> command, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer227">
					<img alt="Figure 11.5 – Verifying that a file has been signed" src="image/B16679_11_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Verifying that a file has been signed</p>
			<p>But this is not the <a id="_idIndexMarker1863"/>only way to verify that a file has been signed. If you right-click on a signed file<a id="_idIndexMarker1864"/> and open its properties, under the <strong class="bold">Digital Signatures</strong> tab, you will see that the certificate you used for signing <span class="No-Break">was added:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer228">
					<img alt="Figure 11.6 – Verifying that a file has been signed using file properties" src="image/B16679_11_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Verifying that a file has been signed using file properties</p>
			<p>Also, if you <a id="_idIndexMarker1865"/>open the newly signed script, you will see that its content has changed: instead of only the code, you will see the <a id="_idIndexMarker1866"/>signature as well – introduced by <strong class="source-inline"># SIG # Begin signature block</strong> and closed out by <strong class="source-inline"># SIG # End signature block</strong> and in between a huge signature block. As shown in the following screenshot, I have shortened the signature block as the signature would be too big to show as a figure in <span class="No-Break">this book:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer229">
					<img alt="Figure 11.7 – The signed file now contains a signature block" src="image/B16679_11_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – The signed file now contains a signature block</p>
			<p>If we were to enable <strong class="source-inline">ExecutionPolicy AllSigned</strong> and attempt to run the self-signed script, we’d be asked if we really want to run software from this <span class="No-Break">untrusted publisher:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer230">
					<img alt="Figure 11.8 – The ExecutionPolicy prompt" src="image/B16679_11_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – The ExecutionPolicy prompt</p>
			<p>To execute <a id="_idIndexMarker1867"/>this script, we <a id="_idIndexMarker1868"/>must select <strong class="source-inline">[R] Run once</strong>. If you want to permanently run scripts from this publisher without being prompted each time, you can use the <strong class="source-inline">[A] Always </strong><span class="No-Break"><strong class="source-inline">Run</strong></span><span class="No-Break"> option.</span></p>
			<p>If you want to run scripts from this publisher without being prompted at all, you can add the self-signed certificate to the <strong class="bold">Trusted Publishers </strong>store. This allows you to establish a trusted relationship between the publisher and your computer, ensuring that scripts from the publisher are automatically trusted and executed <span class="No-Break">without interruptions.</span></p>
			<p>If we want to permanently run scripts from this publisher without being prompted, we need to add our self-signed certificate to the <a id="_idIndexMarker1869"/>computer’s <strong class="bold">Trusted Publishers </strong><span class="No-Break"><strong class="bold">certificate store</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; $publisherCertStore = [System.Security.Cryptography.X509Certificates.X509Store]::new("TrustedPublisher","LocalMachine")
&gt; $publisherCertStore.Open("ReadWrite")
&gt; $publisherCertStore.Add($testCert)
&gt; $publisherCertStore.Close()</pre>
			<p>By adding the certificate to the <strong class="bold">Trusted Publishers</strong> store, you can ensure that all the code signed by your self-signed certificate can be trusted. Since it is not possible to copy certificates from one store to another by using <strong class="source-inline">Copy-Item</strong>, we must use the <strong class="bold">Certificate Store API</strong> interface <a id="_idIndexMarker1870"/>to access the <strong class="bold">Trusted Publishers</strong> certificate store, then open it with read/write permissions, add the certificate that we created earlier, and close the <span class="No-Break">store again.</span></p>
			<p>Now, if we execute the <strong class="source-inline">HelloWorld.ps1</strong> script again, it will run without prompting us, whereas an unsigned file would <span class="No-Break">be rejected:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer231">
					<img alt="Figure 11.9 – A signed file can be executed without any problems" src="image/B16679_11_009.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – A signed file can be executed without any problems</p>
			<p>If you have<a id="_idIndexMarker1871"/> any application <a id="_idIndexMarker1872"/>control mechanism in place, such as AppLocker or WDAP, only a signed file will be allowed to run – <em class="italic">if</em> the publisher was added as a trusted source for the application control mechanism to run. Depending on the application control system in use, this can be done using, for example, a <strong class="bold">publisher rule</strong> in a <a id="_idIndexMarker1873"/>policy, or another similar mechanism to trust <span class="No-Break">the publisher.</span></p>
			<p>Since script signing adds a signature for exactly the file you signed, the file cannot be modified if the signature should remain valid. If you were to modify the content of the signed file and verify the signature using <strong class="source-inline">Get-AuthenticodeSignature</strong>, you would see that the hash of the signature does not match the content of the file anymore. Therefore, the signature will be invalid and the file cannot be executed any longer if protection mechanisms against unsigned scripts have <span class="No-Break">been applied:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer232">
					<img alt="Figure 11.10 – HashMismatch after changing the signed file’s content" src="image/B16679_11_010.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – HashMismatch after changing the signed file’s content</p>
			<p>Therefore, whenever<a id="_idIndexMarker1874"/> you modify the content of a signed file, you will need to sign it once more. If you have a <strong class="bold">continuous integration/continuous delivery</strong> (<strong class="bold">CI/CD</strong>) pipeline <a id="_idIndexMarker1875"/>in place, script signing can<a id="_idIndexMarker1876"/> easily be automated using the <span class="No-Break"><strong class="source-inline">Set-AuthenticodeSignature</strong></span><span class="No-Break"> cmdlet.</span></p>
			<p>There are several ways to build a CI/CD pipeline if you are new to this concept. Just to mention a few, a CI/CD pipeline can, for example, be realized using Azure DevOps <span class="No-Break">or GitHub.</span></p>
			<p>The following are some resources to help you get started <span class="No-Break">with this:</span></p>
			<ul>
				<li><em class="italic">Design a CI/CD pipeline using Azure </em><span class="No-Break"><em class="italic">DevOps</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/architectures/devops-pipelines-baseline-architecture&#13;"><span class="No-Break">https://learn.microsoft.com/en-us/azure/devops/pipelines/architectures/devops-pipelines-baseline-architecture</span></a></li>
				<li><em class="italic">How to build a CI/CD pipeline with GitHub Actions in four simple </em><span class="No-Break"><em class="italic">steps</em></span><span class="No-Break">: </span><a href="https://github.blog/2022-02-02-build-ci-cd-pipeline-github-actions-four-steps/ "><span class="No-Break">https://github.blog/2022-02-02-build-ci-cd-pipeline-github-actions-four-steps/</span></a></li>
			</ul>
			<p>It’s important to also make sure you apply code signing best practices when you are planning to use code signing in your production environment. Microsoft has published a <em class="italic">Code Signing Best Practices</em> document for this, which you use as a <span class="No-Break">reference: </span><span class="No-Break">http://download.microsoft.com/download/a/f/7/af7777e5-7dcd-4800-8a0a-b18336565f5b/best_practices.doc</span><span class="No-Break">.</span></p>
			<p>Code signing is a great way to ensure that your scripts are legit and were not tampered with. But as you learned earlier in this book, the execution policy alone is not a security boundary and can easily be bypassed. Therefore, only relying on the execution policy is not a good idea. If you want to prevent unauthorized scripts from running in your environment, you need to implement an application <span class="No-Break">control solution.</span></p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor310"/>Controlling applications and scripts</h1>
			<p>An application control <a id="_idIndexMarker1877"/>solution not only protects against unauthorized PowerShell scripts; it can also be used to define which applications, executables, and DLLs are allowed to run in <span class="No-Break">the environment.</span></p>
			<p>It is important<a id="_idIndexMarker1878"/> to keep in mind that while PowerShell attacks may seem like a concern for many professionals, they represent a relatively small portion of the malware that makes its way onto systems. It is essential to not overlook the danger posed by traditional executable and <span class="No-Break">DLL attacks.</span></p>
			<p>Application control solutions often provide a possibility to also just prohibit single unwanted applications, but the desired outcome should always be to prohibit everything and configure all allowed applications. As you may recall from <a href="B16679_05_Final_PD.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">PowerShell Is Powerful – System and API Access</em>, even if you block <strong class="source-inline">PowerShell.exe</strong> in your environment, it is still possible to run it by just using the native API functions, irrespective of whether it makes sense to block PowerShell (you shouldn’t, of course; it’s better to implement and leverage a proper logging and security <span class="No-Break">strategy instead).</span></p>
			<p>If you were to only prohibit unwanted applications, attackers would always find a way to circumvent your restrictions – there’s just too much to block and only prohibiting unwanted applications would make your environment always vulnerable <span class="No-Break">to attacks.</span></p>
			<p>It’s better to directly start by auditing what software is used and needed in your environment, implementing a proper application control strategy, and preventing everything else from <span class="No-Break">being run.</span></p>
			<p>There are many application control tools on the market, but in this book, we will only look at Microsoft AppLocker <span class="No-Break">and WDAC.</span></p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor311"/>Planning for application control</h2>
			<p>Before applying <a id="_idIndexMarker1879"/>strict rules to enforce application control to your production environment, make sure that you always audit and create a software catalog of the applications used. You don’t want to impact your employees in such a way that they are no longer able <span class="No-Break">to work.</span></p>
			<p>Even if you are only implementing an audit policy, you have already significantly improved the signal-to-noise ratio in your SIEM. Consider this scenario: before implementing application control, your SIEM is flooded with thousands of events every day from known and authorized applications, making it extremely challenging to identify potential malware or <span class="No-Break">unwanted software.</span></p>
			<p>But if you are only able to implement 80% of an application control policy, and therefore only enable auditing, the number of events already decreases to a manageable level. In this case, you would be left with only a few hundred events per day, which contain legitimate software operations and a potential subset of unwanted software or malware. This approach already reduces the noise in your SIEM significantly and enables you to defend your environment in a much <span class="No-Break">better way.</span></p>
			<p>Once you have<a id="_idIndexMarker1880"/> created the first policy, make sure you test it before rolling it out. Once you are ready to deploy it, follow the following <span class="No-Break">rollout strategy:</span></p>
			<ol>
				<li>Test your policy in a <span class="No-Break">test environment.</span></li>
				<li>It can be very useful to announce your configuration changes as early as possible so that your employees can <span class="No-Break">plan better.</span></li>
				<li>Divide your tech department into several groups, then slowly roll out the policy for the first group, review audit logs, and fix problems on the fly. Once fixed, roll out the policy to the next group and <span class="No-Break">so on.</span></li>
				<li>If everything worked during the last deployment step, enroll your policy for power users in your environment. Needless to say, always communicate it to the people who’d be affected before rolling out such <span class="No-Break">a policy.</span></li>
				<li>After fixing all probable configuration issues, slowly roll out the policy department by department. Always make sure you divide each group into sub-groups and communicate it to the affected employees before <span class="No-Break">enforcing changes.</span></li>
			</ol>
			<p>Always review your blocked applications regularly. This not only helps you identify problems your users might have but also helps you spot the beginning of <span class="No-Break">an attack.</span></p>
			<p>It takes some time to identify which applications are in use and to adjust your configuration accordingly, but it is worth the effort and it will help you harden your <span class="No-Break">environment enormously.</span></p>
			<p>First, let’s look at which application control options are available on Windows <span class="No-Break">operating systems.</span></p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor312"/>Built-in application control solutions</h2>
			<p>Over the<a id="_idIndexMarker1881"/> years, Microsoft has worked on several solutions for application control, starting with SRP with Windows XP to AppLocker, which was introduced with Windows 8 – until they finally released WDAC with <span class="No-Break">Windows 10.</span></p>
			<p>Over the years, capabilities have been improved enormously and each tool brought advantages to their former versions. If possible, always use WDAC for application control as it will be continuously improved. But if you are still using older operating system versions that you need to restrict, it is possible to run all three solutions <span class="No-Break">in parallel.</span></p>
			<p>The following figure provides you with a simplified comparison of all <span class="No-Break">three solutions:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer233">
					<img alt="Figure 11.11 – Simplified comparison of SRP, AppLocker, and WDAC" src="image/B16679_11_011.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – Simplified comparison of SRP, AppLocker, and WDAC</p>
			<p>Of course, this is not a complete list of all features. Please refer to the following links for a more detailed overview of which differences exist between SRP, AppLocker, <span class="No-Break">and WDAC:</span></p>
			<ul>
				<li><em class="italic">What features are different between Software Restriction Policies and </em><span class="No-Break"><em class="italic">AppLocker?</em></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/what-is-applocker#what-features-are-different-between-software-restriction-policies-and-applocker&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/what-is-applocker#what-features-are-different-between-software-restriction-policies-and-applocker</span></a></li>
				<li><em class="italic">Windows Defender Application Control and AppLocker feature </em><span class="No-Break"><em class="italic">availability</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/feature-availability"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/feature-availability</span></a><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/feature-availability&#13;"/></li>
			</ul>
			<p>These <a id="_idIndexMarker1882"/>solutions are huge topics, so you will only find an overview of each technology, as well as some tips and tricks that will help you start implementing your own application control rules. As the focus of this book is PowerShell, we will also focus mostly on restricting and using PowerShell in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor313"/>Getting familiar with Microsoft AppLocker</h1>
			<p>AppLocker is <a id="_idIndexMarker1883"/>Microsoft’s successor to SRP and was introduced with Windows 7. You can use it to extend SRP’s function, as well as <span class="No-Break">its features.</span></p>
			<p>In <a id="_idIndexMarker1884"/>comparison to SRP, AppLocker policies can be scoped to specific users or groups and it’s also possible to audit before you enforce rules. It is possible to deploy SRP and AppLocker policies in parallel in various ways; take a look at the <span class="No-Break">following documentation:</span></p>
			<ul>
				<li><em class="italic">Use AppLocker and Software Restriction Policies in the same </em><span class="No-Break"><em class="italic">domain</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/use-applocker-and-software-restriction-policies-in-the-same-domain"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/use-applocker-and-software-restriction-policies-in-the-same-domain</span></a></li>
				<li><em class="italic">Use Software Restriction Policies and AppLocker </em><span class="No-Break"><em class="italic">policies</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/using-software-restriction-policies-and-applocker-policies"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/using-software-restriction-policies-and-applocker-policies</span></a><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/using-software-restriction-policies-and-applocker-policies&#13;"/></li>
			</ul>
			<p>Computers on which you want to deploy AppLocker need to have an operating system installed that allows AppLocker policies to be enforced, such as Windows Enterprise. You can also create AppLocker rules on a computer running Windows Professional. However, it is only possible to enforce AppLocker rules on Windows Professional and other operating system versions if they are managed with Intune. If AppLocker rules are not enforced, they don’t apply and give you no protection <span class="No-Break">at all.</span></p>
			<p>If you <a id="_idIndexMarker1885"/>want to restrict applications on unsupported operating systems, you can either deploy SRP rules in parallel or <span class="No-Break">use WDAC.</span></p>
			<p>For AppLocker to work properly, it is required that the <strong class="bold">Application Identity</strong> service <span class="No-Break">is running</span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor314"/>Deploying AppLocker</h2>
			<p>You can<a id="_idIndexMarker1886"/> deploy AppLocker using GPO, Intune, <strong class="bold">Microsoft Configuration Manager</strong>, and PowerShell. Of course, you can also use Local Group Policy Editor for testing purposes. However, it is not possible to enforce AppLocker rules using this method, so you should avoid it <span class="No-Break">in production.</span></p>
			<p>When <a id="_idIndexMarker1887"/>working with AppLocker, there are five different rule types that you <span class="No-Break">can configure:</span></p>
			<ul>
				<li><strong class="bold">Executable Rules</strong>: Using <strong class="bold">Executable Rules</strong>, you can restrict executables that end in <strong class="source-inline">.exe</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">.com</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Windows Installer Rules</strong>: By configuring <strong class="bold">Windows Installer Rules</strong>, you can restrict <strong class="source-inline">.msi</strong>, <strong class="source-inline">.mst</strong>, and <strong class="source-inline">.msp</strong> Windows <span class="No-Break">Installer files.</span></li>
				<li><strong class="bold">Script Rules</strong>: With <strong class="bold">Script Rules</strong>, you can restrict <strong class="source-inline">.ps1</strong>, <strong class="source-inline">.bat</strong>, <strong class="source-inline">.cmd</strong>, <strong class="source-inline">.vbs</strong>, and <strong class="source-inline">.js</strong> <span class="No-Break">script files.</span></li>
				<li><strong class="bold">DLL rules</strong>: You can use DLL rules to restrict <strong class="source-inline">.dll</strong> and <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">ocx</strong></span><span class="No-Break"> files.</span></li>
			</ul>
			<p>Although DLL rules were once considered optional due to concerns about performance, in today’s security landscape, an app control system without DLL enforcement enabled is incomplete and leaves your environment vulnerable. These rules have to be enabled before they can be used and configured using GPO or a local Group Policy. If you are using GPOs for your configuration, go to <strong class="bold">Computer Configuration</strong> | <strong class="bold">Policies</strong> | <strong class="bold">Windows Settings</strong> | <strong class="bold">Security Settings</strong> | <strong class="bold">Applicatio<a id="_idTextAnchor315"/>n Control Policies</strong> | <strong class="bold">AppLocker</strong>. Then, right-click <strong class="bold">AppLocker</strong> and select <strong class="bold">Properties</strong> | <strong class="bold">Advanced</strong> | <strong class="bold">Enable the DLL </strong><span class="No-Break"><strong class="bold">rule collection.</strong></span></p>
			<ul>
				<li><strong class="bold">Packaged app Rules</strong>: Using <strong class="bold">Packaged app Rules</strong>, you can restrict <strong class="source-inline">.appx</strong> <span class="No-Break">package files.</span></li>
			</ul>
			<p>For every<a id="_idIndexMarker1888"/> rule you create, you need to select an action. Here, you must decide whether a file should be allowed or blocked by choosing either <strong class="bold">Allow</strong> or <strong class="bold">Deny</strong>. Usually, you want to block everything and only allow the <span class="No-Break">selected applications.</span></p>
			<p>Using<a id="_idIndexMarker1889"/> AppLocker rules, it is also possible to scope the rule to a particular <strong class="bold">User or group</strong>. If nothing is specified in particular, the rule applies <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Everyone</strong></span><span class="No-Break">.</span></p>
			<p>You will also need to decide on the <em class="italic">primary condition</em> that the rule should contain. For <strong class="bold">Packaged app Rules</strong>, you can only configure a <strong class="bold">Publisher</strong> condition; for all other rules, <strong class="bold">Path</strong> and <strong class="bold">File hash</strong> conditions can be applied – in addition to the <span class="No-Break"><strong class="bold">Publisher</strong></span><span class="No-Break"> conditions:</span></p>
			<ul>
				<li><strong class="bold">Path</strong>: Using the <strong class="bold">Path</strong> condition, you can specify a path that will be either allowed or denied by your rule. You can also define an exception. Using the <strong class="bold">Path</strong> condition is the most insecure condition as file and path names can easily be changed to bypass your rules. If possible, try to avoid <span class="No-Break">path rules.</span></li>
				<li><strong class="bold">Publisher</strong>: When using the <strong class="bold">Publisher</strong> condition, a file needs to be digitally signed. Using this condition, you can not only specify the publisher – you can also specify the product name, the filename, as well as the file version that a file should have to be allowed or denied. It is also possible to <span class="No-Break">define exceptions.</span></li>
				<li><strong class="bold">File hash</strong>: A cryptographic file hash will be calculated for this file. If the file changes, the file hash will change as well. Therefore, a hash can only apply to one file and you need to configure a file hash condition for every file you want to allow or deny if this condition <span class="No-Break">is used.</span></li>
			</ul>
			<p>All these rules, actions, user scopes, and conditions apply to all <span class="No-Break">configuration methods.</span></p>
			<p>Configuring AppLocker in your environment can take some time, but it is worth it once you have implemented it. To help you with your initial configuration, Aaron Margosis released <em class="italic">AaronLocker</em> on <span class="No-Break">GitHub: </span><a href="https://github.com/microsoft/AaronLocker"><span class="No-Break">https://github.com/microsoft/AaronLocker</span></a><span class="No-Break">.</span></p>
			<p>This script <a id="_idIndexMarker1890"/>and documentation collection should help make your initial configuration, as well as the maintenance of your AppLocker rules, as easy <a id="_idIndexMarker1891"/><span class="No-Break">as possible.</span></p>
			<p class="callout-heading">Behind AaronLocker – Where Did the Name Come From?</p>
			<p class="callout">The name <em class="italic">AaronLocker</em> was not Aaron’s idea himself – it was the idea of my friend and long-time mentor Chris Jackson, who unfortunately passed away some time ago (rest in peace, Chris!). Aaron was not especially fond to call his product after his first name, but since he could not think of a better name, he gave in to Chris’ idea and so the name <em class="italic">AaronLocker</em> <span class="No-Break">was born.</span></p>
			<p>However, we have only learned what AppLocker rules consist of and not how to deploy and configure them using different deployment methods. Therefore, as a next step, we’ll explore how AppLocker can <span class="No-Break">be managed.</span></p>
			<h3>GPO</h3>
			<p>If you <a id="_idIndexMarker1892"/>are using GPOs or Local Group Policy for your <a id="_idIndexMarker1893"/>configuration, navigate to <strong class="bold">Computer Configuration</strong> | <strong class="bold">Policies</strong> | <strong class="bold">Windows Settings</strong> | <strong class="bold">Security Settings</strong> | <strong class="bold">Application Control Policies</strong> | <strong class="bold">AppLocker</strong>. In this section, you will find the <strong class="bold">Executable Rules</strong>, <strong class="bold">Windows Installer Rules</strong>, <strong class="bold">Script Rules</strong>, and <strong class="bold">Packaged app Rules</strong> options, as <span class="No-Break">shown here:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer234">
					<img alt="Figure 11.12 – Configuring AppLocker using GPO" src="image/B16679_11_012.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Configuring AppLocker using GPO</p>
			<p>To <a id="_idIndexMarker1894"/>enable <a id="_idIndexMarker1895"/>the enforcement or auditing behavior, right-click on AppLocker and select <strong class="bold">Properties</strong>. In the window that appears, you can configure which AppLocker rules should be enforced <span class="No-Break">or audited.</span></p>
			<p>If you are using GPOs as a configuration method, make sure that all the systems you want to configure have at least Windows 10 Enterprise installed. Otherwise, you cannot enforce <span class="No-Break">AppLocker rules.</span></p>
			<p>If you also want to enable DLL rules, you can do this by right-clicking on <strong class="bold">AppLocker</strong> and selecting <strong class="bold">Properties</strong> | <strong class="bold">Advanced</strong> | <strong class="bold">Enable the DLL rule collection</strong>. Refer to the descriptions of the DLL rules to learn more about them. After enabling DLL rules, they will show up <span class="No-Break">under AppLocker.</span></p>
			<h3>Intune</h3>
			<p>Before you<a id="_idIndexMarker1896"/> can configure AppLocker via Intune, you <a id="_idIndexMarker1897"/>will need to create an AppLocker policy using GPO or Local Group Policy. Once your configuration is ready, export it by right-clicking on <strong class="bold">AppLocker</strong> and selecting <span class="No-Break"><strong class="bold">Export Policy</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer235">
					<img alt="Figure 11.13 – Exporting the AppLocker policy" src="image/B16679_11_013.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.13 – Exporting the AppLocker policy</p>
			<p>A <a id="_idIndexMarker1898"/>window will appear where you need to select where your exported policy should be saved to. Select a path and confirm it; your AppLocker policy will be successfully exported as a <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">xml</strong></span><span class="No-Break"> file.</span></p>
			<p>Unfortunately, you cannot just copy and paste the content of the file into your Intune configuration. Therefore, open the file with an editor and search for each rule type for its section. This is indicated by the <strong class="source-inline">&lt;RuleCollection …&gt; … &lt;/RuleCollection&gt;</strong> tags <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">RuleCollection</strong></span><span class="No-Break">.</span></p>
			<p>There’s one <strong class="source-inline">RuleCollection</strong> section for every rule type, so if you want to get the <strong class="source-inline">RuleCollection</strong> section for all executable files, select everything between <strong class="source-inline">&lt;RuleCollection Type="Exe" EnforcementMode="NotConfigured"&gt;</strong>, including the surrounding tags, as shown in the following screenshot. If needed, repeat this for the other available <span class="No-Break">rule types:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer236">
					<img alt="Figure 11.14 – Selecting the RuleCollection section for executable rules" src="image/B16679_11_014.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.14 – Selecting the RuleCollection section for executable rules</p>
			<p>Configuring AppLocker <a id="_idIndexMarker1899"/>using Intune relies on the AppLocker <strong class="bold">configuration service provider</strong> (<span class="No-Break"><strong class="bold">CSP</strong></span><span class="No-Break">): </span><a href="https://docs.microsoft.com/en-us/windows/client-management/mdm/applocker-csp"><span class="No-Break">https://docs.microsoft.com/en-us/windows/client-management/mdm/applocker-csp</span></a><span class="No-Break">.</span></p>
			<p>The CSP<a id="_idIndexMarker1900"/> provides an interface that allows <strong class="bold">mobile device management</strong> (<strong class="bold">MDM</strong>) solutions <a id="_idIndexMarker1901"/>to control, configure, read, delete, and edit the configuration settings of the device that’s being managed. A custom configuration for a Windows 10 device can be configured using<a id="_idIndexMarker1902"/> the <strong class="bold">Open Mobile Alliance Uniform Resource Identifier</strong> (<span class="No-Break"><strong class="bold">OMA-URI</strong></span><span class="No-Break">) string.</span></p>
			<p>Thanks to<a id="_idIndexMarker1903"/> Intune and the AppLocker CSP, most operating systems can be configured to use AppLocker in <span class="No-Break">Enforcement mode:</span></p>
			<ul>
				<li><em class="italic">Configuration Service </em><span class="No-Break"><em class="italic">Provider</em></span><span class="No-Break">: </span><a href="https://docs.microsoft.com/en-us/windows/client-management/mdm/configuration-service-provider-reference#csp-support&#13;"><span class="No-Break">https://docs.microsoft.com/en-us/windows/client-management/mdm/configuration-service-provider-reference#csp-support</span></a></li>
				<li><em class="italic">Deploy OMA-URIs to target a CSP through Intune, and a comparison to </em><span class="No-Break"><em class="italic">on-premises</em></span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/troubleshoot/mem/intune/device-configuration/deploy-oma-uris-to-target-csp-via-intune"><span class="No-Break">https://learn.microsoft.com/en-us/troubleshoot/mem/intune/device-configuration/deploy-oma-uris-to-target-csp-via-intune</span></a><a href="https://docs.microsoft.com/en-us/troubleshoot/mem/intune/deploy-oma-uris-to-target-csp-via-intune&#13;"/></li>
			</ul>
			<p>Now, in Intune, go to <strong class="bold">Devices</strong> | <strong class="bold">Configuration Profiles</strong> and click on <span class="No-Break"><strong class="bold">Create Profile</strong></span><span class="No-Break">.</span></p>
			<p>Select <strong class="bold">Windows 10 and Later</strong> under <strong class="bold">Platform</strong>, <strong class="bold">Templates</strong> under <strong class="bold">Profile Type</strong>, and <strong class="bold">Custom</strong> under <strong class="bold">Template</strong>, then <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Create</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer237">
					<img alt="Figure 11.15 – Create a profile" src="image/B16679_11_015.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.15 – Create a profile</p>
			<p>On<a id="_idIndexMarker1904"/> the next page, name your AppLocker policy – for<a id="_idIndexMarker1905"/> example, <strong class="source-inline">AppLocker Policy</strong> – and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break">.</span></p>
			<p>In the <strong class="bold">OMA-URI Settings</strong> section, select <strong class="bold">Add</strong> to add your AppLocker rule configuration. This is where you create the actual policy, using the snippet from your <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">xml</strong></span><span class="No-Break"> export.</span></p>
			<p>First, type a name that represents the policy well, such as <strong class="source-inline">Exe Policy</strong>, if you want to start configuring the policy for <strong class="source-inline">.exe</strong> files in <span class="No-Break">your environment.</span></p>
			<p>In the <strong class="bold">OMA-URI</strong> field, type the string according to the policy you are <span class="No-Break">just configuring:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">Exe</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">./Vendor/MSFT/AppLocker/AppLocker/ApplicationLaunchRestrictions/apps/EXE/Policy</strong></span></li>
				<li><span class="No-Break"><strong class="bold">MSI</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">./Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/apps/MSI/Policy</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Script</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">./Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/apps/Script/Policy</strong></span></li>
				<li><span class="No-Break"><strong class="bold">DLL</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">./Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/apps/DLL/Policy</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Appx</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">./Vendor/MSFT/AppLocker/ApplicationLaunchRestrictions/apps/StoreApps/Policy</strong></span></li>
			</ul>
			<p>Change <strong class="bold">Data type</strong> to <strong class="source-inline">String</strong> and paste the <strong class="source-inline">RuleCollection</strong> lines that you copied earlier from the <a id="_idIndexMarker1906"/>exported <strong class="source-inline">.xml</strong> file. Click <strong class="bold">Save</strong>. Add a policy using the <strong class="bold">OMA-URI Settings</strong> area for every rule type you want to configure. Once you are finished, click <strong class="bold">Review + save</strong> to save <span class="No-Break">your configuration:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer238">
					<img alt="Figure 11.16 – Configuring the OMA-URI settings" src="image/B16679_11_016.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.16 – Configuring the OMA-URI settings</p>
			<p>As a next step, you can add computer groups to which these rules should apply. Click <strong class="bold">Next</strong> until you are in the <strong class="bold">Review + create</strong> section and review your rules. If everything seems fine, click <strong class="bold">Create</strong> to create your <span class="No-Break">AppLocker rules.</span></p>
			<h3>Microsoft Configuration Manager</h3>
			<p><strong class="bold">Configuration Manager</strong> was <a id="_idIndexMarker1907"/>formerly <a id="_idIndexMarker1908"/>known as <strong class="bold">System Center Configuration Manager</strong> (<strong class="bold">SCCM</strong>). Configuration Manager contains a lot of preconfigured configuration options and packages, but unfortunately, there is no preconfigured option for AppLocker. However, it still can be deployed using custom <span class="No-Break">configuration options.</span></p>
			<p>Under <strong class="bold">Compliance Settings</strong>, create a new <strong class="bold">Configuration Item</strong>; in the <strong class="bold">Create Configuration Item Wizard</strong> area, specify a name for your new policy and select <strong class="bold">Windows 8.1 and Windows 10</strong> under <strong class="bold">Settings for devices managed without the Configuration </strong><span class="No-Break"><strong class="bold">Manager client</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer239">
					<img alt="Figure 11.17 – Creating a custom AppLocker policy using Configuration Manager" src="image/B16679_11_017.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.17 – Creating a custom AppLocker policy using Configuration Manager</p>
			<p>Similar to <a id="_idIndexMarker1909"/>the configuration with Intune, we can also use AppLocker CSP for the configuration with <span class="No-Break">Configuration Manager.</span></p>
			<p>Next, select for which platforms you want to configure AppLocker – in my example, I chose <strong class="bold">Windows 10</strong> only and <span class="No-Break">clicked </span><span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break">.</span></p>
			<p>As a <a id="_idIndexMarker1910"/>next step, don’t select any device settings; instead, check the <strong class="bold">Configure additional settings that are not in the default setting groups</strong> checkbox and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break">.</span></p>
			<p>In the <strong class="bold">Additional Settings</strong> pane, click <strong class="bold">Add</strong>. The <strong class="bold">Browse Settings</strong> window will open. Now, click <strong class="bold">Create Setting…</strong>. A new window called <strong class="bold">Create Setting</strong> will open, as <span class="No-Break">shown here:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer240">
					<img alt="Figure 11.18 – Specifying the policy’s name and the OMA-URI" src="image/B16679_11_018.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.18 – Specifying the policy’s name and the OMA-URI</p>
			<p>In the <strong class="bold">Create Setting</strong> dialog, enter the setting’s <strong class="bold">Name</strong> and specify the string of the OMA-URI, as we did in the <em class="italic">Intune configuration</em> section (this is also where you can find the summarized OMA-URI strings in this book). <span class="No-Break">Click </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></p>
			<p>As a <a id="_idIndexMarker1911"/>next <a id="_idIndexMarker1912"/>step, specify the rules for this setting by double clicking the setting that you just created and enter a meaningful <strong class="bold">Name</strong>, select <strong class="bold">Value</strong> under <strong class="bold">Rule type</strong>, and ensure <strong class="bold">EXE Policy</strong> (or the setting name that you configured earlier) <strong class="bold">Equals</strong> the <em class="italic">RuleCollection XML snippet</em> that we created earlier in the <span class="No-Break"><strong class="bold">Intune</strong></span><span class="No-Break"> section.</span></p>
			<p>Usually, Configuration Manager items are used to query a state. If the state is different from the desired outcome, you can optionally configure the rule to be remediated automatically by checking the <strong class="bold">Remediate noncompliant rules when </strong><span class="No-Break"><strong class="bold">supported</strong></span><span class="No-Break"> option.</span></p>
			<p>Repeat this step for every rule type that you want to configure until all the rules are <span class="No-Break">configured accordingly.</span></p>
			<p>Click <strong class="bold">Next</strong> until <strong class="bold">Create Configuration Item Wizard task</strong> shows up as <span class="No-Break">completed successfully.</span></p>
			<p>Now, create a <strong class="bold">Configuration Baseline</strong> task, enter a meaningful name, and click <strong class="bold">Add</strong>. Select the <a id="_idIndexMarker1913"/>formerly created policy to be added to this baseline and confirm this <span class="No-Break">with </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></p>
			<p>Last, but not least, <strong class="bold">Deploy</strong> the new configuration baseline by selecting the baseline and configuring a <strong class="bold">compliance evaluation schedule</strong> to <a id="_idIndexMarker1914"/>define in which interval the baseline is checked and applied. In my case, I have stated that this baseline should be run daily. Again, confirm this <span class="No-Break">with </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></p>
			<h3>PowerShell</h3>
			<p>Of course, you <a id="_idIndexMarker1915"/>can also use PowerShell to configure <a id="_idIndexMarker1916"/>and read AppLocker rules. You can use the module AppLocker for this, which already contains several functions to help you with <span class="No-Break">this job.</span></p>
			<p>The following screenshot provides an overview of all AppLocker-related <span class="No-Break">PowerShell commands:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer241">
					<img alt="Figure 11.19 – Functions within the AppLocker module" src="image/B16679_11_019.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.19 – Functions within the AppLocker module</p>
			<p>At first glance, it looks like the module provides very limited functionality, but let’s look deeper into each function; they have way more functionality than you would expect and allow you to work even more efficiently than with the <span class="No-Break">user interface.</span></p>
			<p><strong class="source-inline">Get-AppLockerPolicy</strong> helps you find out if there is an AppLocker policy in place. Using the <strong class="source-inline">-Effective</strong> parameter, you can see if a policy has been specified <span class="No-Break">at all:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer242">
					<img alt="Figure 11.20 – Getting the effective AppLocker policy using the Get-AppLocker policy" src="image/B16679_11_020.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.20 – Getting the effective AppLocker policy using the Get-AppLocker policy</p>
			<p>You <a id="_idIndexMarker1917"/>can also use the <strong class="source-inline">-Local</strong> parameter to see what is <a id="_idIndexMarker1918"/>defined in the local AppLocker policy. The <strong class="source-inline">-Domain</strong> parameter, combined with the <strong class="source-inline">-Ldap</strong> parameter, helps you see the current domain-configured AppLocker policy. And of course, you can also investigate a policy out of a <strong class="source-inline">.xml</strong> file using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Xml</strong></span><span class="No-Break"> parameter.</span></p>
			<p>Using <strong class="source-inline">Get-AppLockerFileInformation</strong> allows you to get all the information from either a file, a path, or an <span class="No-Break">event log:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer243">
					<img alt="Figure 11.21 – Retrieving AppLocker file information using Get-AppLockerFileInformation" src="image/B16679_11_021.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.21 – Retrieving AppLocker file information using Get-AppLockerFileInformation</p>
			<p>In the preceding screenshot, you can see the AppLocker information of both demo scripts from our code signing example earlier. Usually, if the script had been signed by a corporate or public CA, you would also see the publisher information, but since we used a self-signed script, which is only meant for testing purposes, this certificate has no publisher and therefore we cannot use it to create an AppLocker <span class="No-Break">publisher rule.</span></p>
			<p>Usually, the most common way to generate AppLocker rules is by creating a policy based on a <strong class="bold">golden image</strong> of a<a id="_idIndexMarker1919"/> server or client system, instead of manually selecting individual files and directories. To do this, you can use the <strong class="source-inline">Get-AppLockerFileInformation</strong> cmdlet to identify all the files that are authorized to run on the image and then use the <strong class="source-inline">New-AppLockerPolicy</strong> cmdlet to automatically generate the corresponding AppLocker rules for <span class="No-Break">each file.</span></p>
			<p>The following <a id="_idIndexMarker1920"/>example takes all the files in the <strong class="source-inline">C:\</strong> drive and generates a rule for each – the resulting file will be saved <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">C:\tmp\Applocker.xml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Get-AppLockerFileInformation -Directory 'C:\' -Recurse -ErrorAction SilentlyContinue | New-AppLockerPolicy -RuleType Publisher,Hash -User Everyone -RuleNamePrefix PSTmp -Xml | Out-File -FilePath "C:\tmp\Applocker.xml"</pre>
			<p>Once the file has been created, you will need to test and fine-grain it to deploy AppLocker rules for your <span class="No-Break">golden image.</span></p>
			<p>Another <a id="_idIndexMarker1921"/>very effective way to deploy AppLocker is to capture events from existing <em class="italic">known good</em> systems that have the required software installed and are considered uncompromised. Using those events to generate a policy with PowerShell can save you a lot of time and effort. It is even possible to pipe in file information from event logs to automatically generate AppLocker rules. This can be especially useful when dealing with large and complex environments where manually creating rules can be a <span class="No-Break">daunting task:</span></p>
			<pre class="source-code">
&gt; Get-AppLockerFileInformation -EventLog -EventType Audited | New-AppLockerPolicy -RuleType Publisher,Hash -User Everyone -RuleNamePrefix AuditedApps -Xml | Out-File -FilePath "C:\tmp\AuditedApps-Applocker.xml"</pre>
			<p>You can then use the <strong class="source-inline">Set-AppLockerPolicy</strong> cmdlet to configure Group Policy or Local Group Policy with the specified <span class="No-Break">AppLocker configuration:</span></p>
			<pre class="source-code">
Set-AppLockerPolicy -XmlPolicy "C:\tmp\AppLockerPolicy.xml"</pre>
			<p>To configure GPO on a remote domain controller, make sure you use the <strong class="source-inline">-Ldap</strong> parameter and configure the LDAP path to where the policy is located. If you want to merge the existing policy with a newly configured one, make sure you specify the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Merge</strong></span><span class="No-Break"> parameter.</span></p>
			<p>This cmdlet only works with Group Policy or local policy. If you have AppLocker configured via AppLocker CSP, this cmdlet <span class="No-Break">won’t work.</span></p>
			<p>Using the <strong class="source-inline">Test-AppLockerPolicy</strong> cmdlet, you can test your AppLocker policy to find out if a certain file would be allowed to be executed if the specified policy were <span class="No-Break">to apply:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer244">
					<img alt="Figure 11.22 – Using Test-AppLockerPolicy to find out ﻿whether notepad.exe or putty.exe would be allowed to run" src="image/B16679_11_022.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.22 – Using Test-AppLockerPolicy to find out whether notepad.exe or putty.exe would be allowed to run</p>
			<p>In this <a id="_idIndexMarker1922"/>screenshot, you can see that using this AppLocker policy, <strong class="source-inline">notepad.exe</strong> would be allowed to run, while <strong class="source-inline">putty.exe</strong> would be prohibited as no matching allow rule has <span class="No-Break">been configured.</span></p>
			<p>Before <a id="_idIndexMarker1923"/>you start deploying AppLocker in Enforce Rules Enforcement mode, you will want to audit what applications and scripts can be used in your environment regularly using <strong class="bold">Audit only Enforcement</strong> mode. This will let you allowlist them before you enforce your rules. You can do this using the logging capability by reviewing <span class="No-Break">event logs.</span></p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor316"/>Audit AppLocker events</h2>
			<p>When<a id="_idIndexMarker1924"/> using event logs, you can not only find out which applications would have been blocked when using <strong class="bold">Audit only Enforcement</strong> mode – you can also find a lot more interesting information on how your AppLocker policies were applied or what applications did run in <strong class="bold">Enforce Rules </strong><span class="No-Break"><strong class="bold">Enforcement</strong></span><span class="No-Break"> mode.</span></p>
			<p>Using PowerShell, you can quickly get an overview of all AppLocker-related event logs by running <strong class="source-inline">Get-WinEvent -</strong><span class="No-Break"><strong class="source-inline">ListLog *AppLocker*</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer245">
					<img alt="Figure 11.23 – AppLocker event logs" src="image/B16679_11_023.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.23 – AppLocker event logs</p>
			<p>To get all the <a id="_idIndexMarker1925"/>event IDs from a particular log, use <strong class="source-inline">Get-WinEvent</strong>, followed by the name of the event log. If you want to get all event IDs from the <strong class="source-inline">Microsoft-Windows-AppLocker/EXE and DLL</strong> log, for example, you can run <strong class="source-inline">Get-WinEvent "Microsoft-Windows-AppLocker/EXE </strong><span class="No-Break"><strong class="source-inline">and DLL"</strong></span><span class="No-Break">.</span></p>
			<p>You can find more detailed information on AppLocker event logs and all event IDs in <a href="B16679_04_Final_PD.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Detection – Auditing </em><span class="No-Break"><em class="italic">and Monitoring</em></span><span class="No-Break">.</span></p>
			<p>To plan for your AppLocker deployment, it can be also very useful to review the statistics of what applications were allowed, denied, or audited. You can achieve this using <strong class="source-inline">Get-AppLockerFileInformation</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer246">
					<img alt="Figure 11.24 – Reviewing the statistics of audited applications" src="image/B16679_11_024.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.24 – Reviewing the statistics of audited applications</p>
			<p>Using <strong class="source-inline">EventType</strong>, you can choose between <strong class="source-inline">Allowed</strong>, <strong class="source-inline">Denied</strong>, or <strong class="source-inline">Audited</strong>. By doing this, you can see all the information about the file, as well as how often it tried to run the application and the decision of whether a file was or would have been allowed <span class="No-Break">or denied.</span></p>
			<p>Please refer to the following link to learn more about how to monitor application usage with <span class="No-Break">AppLocker: </span><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/monitor-application-usage-with-applocker"><span class="No-Break">https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/monitor-application-usage-with-applocker</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor317"/>Exploring Windows Defender Application Control</h1>
			<p>With its<a id="_idIndexMarker1926"/> introduction in Windows 10, <strong class="bold">Windows Defender Application Control</strong> (<strong class="bold">WDAC</strong>) allows organizations to control the applications and drivers that are used in their environment. WDAC is implemented as part of the operating system and was also known under the <a id="_idIndexMarker1927"/>name <span class="No-Break"><strong class="bold">Device Guard</strong></span><span class="No-Break">.</span></p>
			<p>It is recommended to use WDAC in combination with <strong class="bold">virtualization-based security</strong> (<strong class="bold">VBS</strong>). When <a id="_idIndexMarker1928"/>used with VBS, WDAC’s security is enforced by hypervisor isolation, which makes it even harder for an adversary to circumvent your configured application control restrictions. While VBS is technically not required for WDAC, it can significantly enhance your overall system security and should always be enabled <span class="No-Break">if possible.</span></p>
			<p>In comparison to AppLocker rules, WDAC rules are deployed to the whole machine and affect every user logging on to this machine. But WDAC also offers more features and is considered more secure than AppLocker. Its principle is to trust nothing before its trust has <span class="No-Break">been earned.</span></p>
			<p>Applications that are installed from the Microsoft AppStore are, for example, considered trustworthy, as every app that makes it into the store undergoes a strict review process. Default Windows applications are also considered trustworthy and do not need to be separately allowlisted. Other applications can also earn trust via Microsoft Intelligence <span class="No-Break">Security Graph.</span></p>
			<p>Whether an application is allowed to be executed on a system or not is ensured by so-called <strong class="bold">code </strong><span class="No-Break"><strong class="bold">integrity policies</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor318"/>Creating code integrity policies</h2>
			<p><strong class="bold">Code integrity</strong> ensures<a id="_idIndexMarker1929"/> that only <a id="_idIndexMarker1930"/>trusted system files and drivers are loaded into memory during system boot and runtime. It verifies the digital signatures of files before allowing them to run, and it prevents unsigned or improperly signed files <span class="No-Break">from loading.</span></p>
			<p>The policy with <a id="_idIndexMarker1931"/>which you configure custom WDAC rules is called a <strong class="bold">code integrity policy</strong> (<strong class="bold">CI policy</strong>). Similar to other application control mechanisms, it is useful to first deploy your policies in audit mode and monitor for unexpected behaviors before turning on <span class="No-Break">enforcement mode.</span></p>
			<p>On every Windows system that supports WDAC, you can find some example policies under <strong class="source-inline">C:\Windows\schemas\CodeIntegrity\ExamplePolicies</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer247">
					<img alt="Figure 11.25 – Built-in example code integrity policies" src="image/B16679_11_025.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.25 – Built-in example code integrity policies</p>
			<p>If you create custom policies, it <a id="_idIndexMarker1932"/>makes sense to start from an existing example policy and then modify it accordingly to build your very own custom policy. The following list will help you determine which <strong class="bold">example policy</strong> would be the best base to add your <span class="No-Break">custom rules:</span></p>
			<ul>
				<li><strong class="source-inline">AllowAll.xml</strong>: This can be a good base if you are planning to prohibit unwanted applications – you just need to add all deny rules. Please keep in mind that the best option to protect your systems against unauthorized access is to control all applications and only allow the <span class="No-Break">selected ones.</span></li>
				<li><strong class="source-inline">AllowAll_EnableHVCI.xml</strong>: By applying this policy, you can enable <strong class="bold">memory integrity</strong>/<strong class="bold">hypervisor-protected code integrity</strong> to safeguard against <a id="_idIndexMarker1933"/>memory<a id="_idIndexMarker1934"/> attacks. Please refer to the following documentation to learn more about this <span class="No-Break">topic: </span><a href="https://support.microsoft.com/en-us/windows/core-isolation-e30ed737-17d8-42f3-a2a9-87521df09b78"><span class="No-Break">https://support.microsoft.com/en-us/windows/core-isolation-e30ed737-17d8-42f3-a2a9-87521df09b78</span></a><span class="No-Break">.</span></li>
				<li><strong class="source-inline">AllowMicrosoft.xml</strong>: This allows Windows, third-party hardware and software kernel drivers, and Windows Store apps, as well as apps that were signed by the Microsoft product <span class="No-Break">root certificate.</span></li>
				<li><strong class="source-inline">DefaultWindows_Audit.xml</strong>: Audit mode allows Windows, third-party hardware and software kernel drivers, and Windows <span class="No-Break">Store apps.</span></li>
				<li><strong class="source-inline">DefaultWindows_Enforced.xml</strong>: Enforced mode allows Windows, third-party hardware and software kernel drivers, and Windows Store apps but blocks everything else that is <span class="No-Break">not configured.</span></li>
				<li><strong class="source-inline">DenyAllAudit.xml</strong>: This policy was created to track all binaries on critical systems – it <a id="_idIndexMarker1935"/>audits what was to happen if everything was blocked. If enabled, this policy can cause long boot times on Windows Server 2019 <span class="No-Break">operating systems.</span></li>
			</ul>
			<p>In most <a id="_idIndexMarker1936"/>use cases, the <strong class="source-inline">DefaultWindows_Audit.xml</strong> and <strong class="source-inline">DefaultWindows_Enforced.xml</strong> policies are the best options to create a custom policy and extend them with custom rules <span class="No-Break">as needed.</span></p>
			<p>There’s also a list of Microsoft recommended block rules that you should <span class="No-Break">follow: </span><span class="No-Break">https://learn</span><a href="https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/microsoft-recommended-block-rules"><span class="No-Break">.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/microsoft-recommended-block-rules</span></a><span class="No-Break">.</span></p>
			<p>The recommendations in this list can also help you mitigate downgrade attacks. This is an attack in which an attacker uses the older PowerShell v2 to bypass the security features and logging mechanisms of newer versions. We explored this attack in <a href="B16679_04_Final_PD.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Detection – Auditing </em><span class="No-Break"><em class="italic">and Monitoring</em></span><span class="No-Break">.</span></p>
			<p>Although many items on this list may be permitted by default in common policies, it is important to carefully consider what executables and binaries are explicitly needed in your scenario and block all <span class="No-Break">unnecessary ones.</span></p>
			<p>On devices that are managed using Configuration Manager, there is an additional example policy under <strong class="source-inline">C:\Windows\CCM\DeviceGuard</strong>. This policy can be used as a base policy to deploy WDAC policies with <span class="No-Break">Configuration Manager.</span></p>
			<p>Once you have selected an example policy that you want to use as your base, you can start modifying a copy of the selected policy. There are many options that you can configure, so you might want to get started by checking out all the available configuration options in the official <span class="No-Break">documentation: </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/select-types-of-rules-to-create"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/select-types-of-rules-to-create</span></a><span class="No-Break">.</span></p>
			<p>You can<a id="_idIndexMarker1937"/> either edit an example policy XML file or automate the process of creating code integrity policies using PowerShell. The following screenshot shows which cmdlets are available to operate code <span class="No-Break">integrity policies:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer248">
					<img alt="Figure 11.26 – Code integrity policy-related cmdlets" src="image/B16679_11_026.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.26 – Code integrity policy-related cmdlets</p>
			<p>One possibility is, for example, the WDAC Policy Wizard, which utilizes the WDAC CI cmdlets that we will look into in the following sections and acts as a wrapper to create CI policies with the help of a GUI. You can download this helpful tool from the official <span class="No-Break">website: </span><a href="https://webapp-wdac-wizard.azurewebsites.net/"><span class="No-Break">https://webapp-wdac-wizard.azurewebsites.net/</span></a><span class="No-Break">.</span></p>
			<p>It is also possible to create a custom XML policy using the <strong class="source-inline">New-CIPolicy</strong> cmdlet: one option is to scan a reference system and create a reference <span class="No-Break">XML policy.</span></p>
			<h3>Scanning a reference system to create an XML CI policy</h3>
			<p>The <a id="_idIndexMarker1938"/>following example shows how to scan the System32 path and the Program Files folder, and subsequently merge both policies <span class="No-Break">into one.</span></p>
			<p>First, let’s scan the Windows <span class="No-Break">System32 path:</span></p>
			<pre class="source-code">
&gt; New-CIPolicy -FilePath "C:\AppControlPolicies\Windows.xml" -Level Publisher -UserPEs -ScanPath "C:\Windows\System32"</pre>
			<p>While the <strong class="source-inline">-ScanPath</strong> parameter indicates the path that should be scanned by <strong class="source-inline">New-CIPolicy</strong>, the <strong class="source-inline">-UserPEs</strong> parameter indicates that user-mode files will be scanned as well. Only use the <strong class="source-inline">-UserPEs</strong> and <strong class="source-inline">-ScanPath</strong> parameters if you are not providing driver files or rules but want to scan a reference system or <span class="No-Break">path instead.</span></p>
			<p>Using the <strong class="source-inline">-FilePath</strong> parameter, you can specify the output folder where your newly created CI policy should be saved. In this case, we have saved it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">C:\AppControlPolicies\Windows.xml</strong></span><span class="No-Break">.</span></p>
			<p>There is <a id="_idIndexMarker1939"/>also the <strong class="source-inline">-Level</strong> parameter, which indicates the level of the CI policy. Using it, you can specify what kind of files are allowed to run. In this case, the policy is set to the <strong class="source-inline">Publisher</strong> level, which means that all the code must be signed by a trusted publisher so that it <span class="No-Break">can run.</span></p>
			<p>The following levels can also <span class="No-Break">be used:</span></p>
			<ul>
				<li><strong class="source-inline">None</strong>: Disables code integrity enforcement. No rules are enforced. This level makes no sense if you want to configure a robust <span class="No-Break">CI policy.</span></li>
				<li><strong class="source-inline">Hash</strong>: Allows an application to run only if its hash matches a <span class="No-Break">specified value.</span></li>
				<li><strong class="source-inline">FileName</strong>: Allows an application to run only if it is located in a specific file path. This level might sound tempting at first, but it opens up more risks. If an adversary were to access files on the system, they could easily replace existing files with malicious files. It’s best not to use <span class="No-Break">this option.</span></li>
				<li><strong class="source-inline">SignedVersion</strong>: Allows an application to run only if it has a specific <span class="No-Break">signed version.</span></li>
				<li><strong class="source-inline">Publisher</strong>: Allows an application to run only if it is signed by a <span class="No-Break">specified publisher.</span></li>
				<li><strong class="source-inline">FilePublisher</strong>: Allows an application to run only if it is signed by a specified publisher and is located in a specific <span class="No-Break">file path.</span></li>
				<li><strong class="source-inline">LeafCertificate</strong>: Allows an application to run only if it is signed by a specified <span class="No-Break">leaf certificate.</span></li>
				<li><strong class="source-inline">PcaCertificate</strong>: Allows an application to run only if it is signed by a specified <span class="No-Break">PCA certificate.</span></li>
				<li><strong class="source-inline">RootCertificate</strong>: Allows an application to run only if it is signed by a specified <span class="No-Break">root certificate.</span></li>
				<li><strong class="source-inline">WHQL</strong>: Allows only signed drivers<a id="_idIndexMarker1940"/> that are <strong class="bold">Windows Hardware Quality Labs</strong> (<strong class="bold">WHQL</strong>) certified to <span class="No-Break">be loaded.</span></li>
				<li><strong class="source-inline">WHQLPublisher</strong>: Allows only signed drivers that are WHQL certified and signed by a specific publisher to <span class="No-Break">be loaded.</span></li>
				<li><strong class="source-inline">WHQLFilePublisher</strong>: Allows only signed drivers that are WHQL certified, signed by a specific publisher, and located in a specific file path to <span class="No-Break">be loaded.</span></li>
			</ul>
			<p>Next, let’s scan <a id="_idIndexMarker1941"/>the <strong class="source-inline">Program Files</strong> folder to create a policy from the specified <span class="No-Break">reference system:</span></p>
			<pre class="source-code">
&gt; New-CIPolicy -FilePath "C:\AppControlPolicies\ProgramFiles.xml" -Level Publisher -UserPEs -ScanPath "C:\Program Files" -NoScript -Fallback SignedVersion,FilePublisher,Hash</pre>
			<p>Again, we have included our user-mode files in the scan and want to ensure that all the files included in our policy are signed by a specified publisher. We must define that the newly created policy will be saved to <strong class="source-inline">C:\AppControlPolicies\ProgramFiles.xml</strong>. To avoid script files from being included in this reference policy, we must specify the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">NoScript</strong></span><span class="No-Break"> parameter.</span></p>
			<p>Using the <strong class="source-inline">-Fallback</strong> parameter, you can specify a fallback order; in this case, if there is no match at the <strong class="source-inline">FilePublisher</strong> level, the policy engine will fall back to the <strong class="source-inline">SignedVersion</strong>, <strong class="source-inline">FilePublisher</strong>, and <strong class="source-inline">Hash</strong> levels – exactly in <span class="No-Break">this order.</span></p>
			<p>Last, but not least, we need to merge the policies into one. To do so, we can use the <span class="No-Break"><strong class="source-inline">Merge-CIPolicy</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; Merge-CIPolicy -PolicyPaths "C:\App<a id="_idTextAnchor319"/>ControlPolicies\Windows.xml", "C:\AppControlPolicies\ProgramFiles.xml" -OutputFilePath "C:\AppControlPolicies\AppControlPolicy.xml"</pre>
			<p>Using the <strong class="source-inline">-PolicyPaths</strong> parameter, we can specify which policies should be merged, while with <strong class="source-inline">-OutputFilePath</strong>, we can define where the merged policy will be saved to. In this example, we’ll save the final policy <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">C:\AppControlPolicies\AppControlPolicy.xml</strong></span><span class="No-Break">.</span></p>
			<p>The policy is created in audit mode so that it can’t block and only audit the use of applications. This is especially useful for testing and evaluating what applications should <span class="No-Break">be blocked.</span></p>
			<p>Once you are<a id="_idIndexMarker1942"/> ready to apply a block policy to your systems, you can remove the audit-only configuration from your policy using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
&gt; Set-RuleOption -FilePath "C:\AppControlPolicies\AppControlPolicy.xml" -Option 3 -Delete</pre>
			<p>To deploy your newly generated policy, you will need to convert it into <span class="No-Break">binary format.</span></p>
			<h3>Converting the XML file into a binary CI policy</h3>
			<p>Once you <a id="_idIndexMarker1943"/>have obtained your CI policy XML configuration file, you will need to convert it into binary format to deploy it. This can be done using the <span class="No-Break"><strong class="source-inline">ConvertFrom-CIPolicy</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; ConvertFrom-CIPolicy -XmlFilePath "C:\AppControlPolicies\AppControlPolicy.xml" -BinaryFilePath "C:\Windows\System32\CodeIntegrity\AppControlPolicy.bin"</pre>
			<p>Here, the <strong class="source-inline">AppControlPolicy.xml</strong> CI policy, which we generated earlier, will be compiled into the <strong class="source-inline">AppControlPolicy.bin</strong> binary file and saved <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">C:\Windows\System32\CodeIntegrity\AppControlPolicy.bin</strong></span><span class="No-Break">.</span></p>
			<p>If a binary CI policy is saved under <strong class="source-inline">C:\Windows\System32\CodeIntegrity\</strong>, it will be enabled immediately after the affected system is restarted. Once the policy is removed again and the system is restarted, all changes introduced by the CI policy <span class="No-Break">are reverted.</span></p>
			<p>Of course, you can also save the converted CI policy under another path of your choice if you plan to deploy WDAC using Intune, MEM, GPO, or another deployment mechanism that requires <a id="_idIndexMarker1944"/>a binary <span class="No-Break">configuration file.</span></p>
			<p>There are also other ways to create a CI policy XML file – for example, from <span class="No-Break">audited events.</span></p>
			<h3>Using audited events from the event log as a reference</h3>
			<p>Another <a id="_idIndexMarker1945"/>way to create a WDAC policy is by running WDAC in audit mode and using the audit log to create the policy. Similar to AppLocker, if WDAC is running in audit mode, any application that would be blocked if the current WDAC configuration was enabled is logged to the <span class="No-Break">audit log.</span></p>
			<p>Depending on the<a id="_idIndexMarker1946"/> application type, these events can be found in one of <a id="_idIndexMarker1947"/>the following <span class="No-Break">event logs:</span></p>
			<ul>
				<li><strong class="bold">Binary-related events</strong>: <strong class="bold">Applications and Services Logs </strong>| <strong class="bold">Microsoft </strong>|<strong class="bold">Windows</strong> | <strong class="bold">CodeIntegrity</strong> | <span class="No-Break"><strong class="bold">Operational</strong></span></li>
				<li><strong class="bold">MSI and script-related events</strong>: <strong class="bold">Applications and Services Logs </strong>| <strong class="bold">Microsoft </strong>| <strong class="bold">Windows</strong> | <strong class="bold">AppLocker</strong> | <strong class="bold">MSI </strong><span class="No-Break"><strong class="bold">and Script</strong></span></li>
			</ul>
			<p>All events logged to these event logs can now be leveraged to either create a completely new CI policy or to merge audited configurations into an <span class="No-Break">existing policy:</span></p>
			<pre class="source-code">
&gt; New-CIPolicy -FilePath "C:\AppControlPolicies\AuditEvents.xml" -Audit -Level FilePublisher -Fallback SignedVersion,FilePublisher,Hash –UserPEs -MultiplePolicyFormat</pre>
			<p>This command creates a new CI policy under <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">C:\AppControlPolicies\AuditEvents.xml</strong></span><strong class="source-inline">
</strong>path. The <strong class="source-inline">-Audit</strong> parameter specifies that the actual audit events from the event log should be used to create <span class="No-Break">the policy.</span></p>
			<p>The <strong class="source-inline">-MultiplePolicyFormat</strong> parameter enables us to use multiple policies at the same time since the policy will be stored in a multiple-policy format, as introduced in <span class="No-Break">Windows 10.</span></p>
			<p>Now, you can review and edit the newly created policy before merging it with other existing <a id="_idIndexMarker1948"/>policies and/or converting it into binary format for <span class="No-Break">further use.</span></p>
			<h3>Creating a CI policy using the New-CIPolicyRule cmdlet</h3>
			<p>If you<a id="_idIndexMarker1949"/> want to define what applications should appear in your CI policy more granularly, the <strong class="source-inline">New-CIPolicyRule</strong> cmdlet <a id="_idIndexMarker1950"/>can help <span class="No-Break">you out:</span></p>
			<pre class="source-code">
&gt; $Rules = New-CIPolicyRule -FilePathRule "C:\Program Files\Notepad++\*"
&gt; $Rules += New-CIPolicyRule -FilePathRule "C:\Program Files\PowerShell\7\*"
&gt; New-CIPolicy -Rules $Rules -FilePath "C:\AppControlPolicies\GranularAppControlPolicy.xml" -UserPEs</pre>
			<p>The preceding code would create one CI policy rule for the <em class="italic">Notepad++</em> folder and its subfolders, as well as one for the <em class="italic">PowerShell 7</em> path, and saves both rules in the <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">Rules</strong></span><span class="No-Break"> variable.</span></p>
			<p>Then, both rules can be used to create a new CI policy that is saved under the <span class="No-Break"><strong class="source-inline">C:\AppControlPolicies\GranularAppControlPolicy.xml</strong></span><span class="No-Break"> path.</span></p>
			<p>Later, you can either combine it with other policies using <strong class="source-inline">Merge-CIPolicy</strong> or convert it into binary format with the help of <strong class="source-inline">ConvertFrom-CIPolicy</strong> so that you can use it for <span class="No-Break">other purposes.</span></p>
			<p>You can use<a id="_idIndexMarker1951"/> the ConfigCI PowerShell module to explore other ways of working with code <span class="No-Break">integrity: </span><a href="https://learn.microsoft.com/en-us/powershell/module/configci"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/configci</span></a><span class="No-Break">.</span></p>
			<p>Although it is not technically required, virtualization-based security features such as Secure Boot should be enabled so that code integrity functions properly. Secure Boot ensures that the system only boots to a trusted state, and that all boot files are signed with trusted signatures. This prevents the boot process from being tampered with and ensures the integrity of the operating system and <span class="No-Break">its drivers.</span></p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor320"/>Virtualization-based security (VBS)</h2>
			<p>VBS uses <a id="_idIndexMarker1952"/>virtualization as a base to isolate areas in memory from the <em class="italic">normal</em> operating system. By doing this, the isolated area can be protected in a better way by encrypting the available memory and the communication to and from this <span class="No-Break">memory area.</span></p>
			<p>Through this isolation, those memory areas can be better protected against vulnerabilities that are active in the <span class="No-Break">operating system.</span></p>
			<p>One example of this is protecting <a id="_idIndexMarker1953"/>credentials<a id="_idIndexMarker1954"/> in the <strong class="bold">local security authority</strong> (<strong class="bold">LSA</strong>), which makes it harder to extract and steal credentials from the <span class="No-Break">operating system.</span></p>
			<p>Another example is <strong class="bold">hypervisor-protected code integrity</strong> (<strong class="bold">HVCI</strong>), which uses VBS for <span class="No-Break">code integrity.</span></p>
			<h3>Hypervisor-protected code integrity (HVCI)</h3>
			<p>HVCI, also<a id="_idIndexMarker1955"/> called <strong class="bold">memory integrity</strong>, is <a id="_idIndexMarker1956"/>the key component of VBS. HVCI leverages VBS technology to protect against kernel-mode attacks by ensuring the integrity <a id="_idIndexMarker1957"/>of the kernel and critical system components. It does so by allowing only trusted and authorized code to run in <span class="No-Break">kernel mode.</span></p>
			<p>If HVCI is active, the CI functionality is forwarded to a secure virtual environment on the same machine, in which the WDAC functionality itself is executed to ensure integrity. As mentioned previously, HVCI uses VBS technology to protect against kernel-mode attacks. It enforces the integrity of the kernel and critical system components by verifying that only known and trusted code can run in kernel mode. But technically, VBS is not required <span class="No-Break">for WDAC.</span></p>
			<p>HVCI utilizes hardware features such as virtualization extensions in modern CPUs and the <strong class="bold">Trusted Platform Module</strong> (<strong class="bold">TPM</strong>) to<a id="_idIndexMarker1958"/> create a secure execution environment. The TPM is used to store a hash of the system’s boot firmware, UEFI, and operating system binaries. During system boot, the TPM measures these components and provides the measurements to the HVCI system. HVCI uses these measurements to verify that only known and trusted components are loaded into memory, thus preventing unauthorized code from running in <span class="No-Break">kernel mode.</span></p>
			<p>If you want to enable HVCI options for a CI policy, you can use the <span class="No-Break"><strong class="source-inline">Set-HVCIOptions</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; Set-HVCIOptions -Enabled -FilePath "C:\AppControlPolicies\GranularAppControlPolicy.xml"</pre>
			<p>You can take this even further by using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">Strict</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
&gt; Set-HVCIOptions -Strict -FilePath "C:\AppControlPolicies\GranularAppControlPolicy.xml"</pre>
			<p>If the <strong class="source-inline">-Strict</strong> option<a id="_idIndexMarker1959"/> is used, this means that only Microsoft and WHQL-signed drivers will be allowed to load after this policy <span class="No-Break">is applied.</span></p>
			<p>To <a id="_idIndexMarker1960"/>remove all HVCI settings from a CI policy, you can specify the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">None</strong></span><span class="No-Break"> parameter:</span></p>
			<pre class="source-code">
&gt; Set-HVCIOptions -None -FilePath "C:\AppControlPolicies\GranularAppControlPolicy.xml"</pre>
			<p>Another helpful VBS feature is Secure Boot, which helps you significantly enhance the security of your <span class="No-Break">Windows systems.</span></p>
			<h3>Enabling Secure Boot</h3>
			<p><strong class="bold">Secure Boot</strong> ensures<a id="_idIndexMarker1961"/> that the <a id="_idIndexMarker1962"/>system is booted into a trusted state. This means that all files that are used to boot the system need to be signed with signatures that are trusted by the organization. By doing this, the system will not be booted if those files have been tampered with. The device needs to have a TPM chip to support <span class="No-Break">Secure Boot.</span></p>
			<p>To verify if Secure Boot is enabled on your computer, you can utilize the <span class="No-Break"><strong class="source-inline">Confirm-SecureBootUEFI</strong></span><span class="No-Break"> cmdlet:</span></p>
			<pre class="source-code">
&gt; Confirm-SecureBootUEFI</pre>
			<p>If Secure Boot is enabled, the cmdlet will return <strong class="source-inline">True</strong>, as shown in the following screenshot; if not, <strong class="source-inline">False</strong> will <span class="No-Break">be returned:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer249">
					<img alt="Figure 11.27 – Secure Boot is enabled" src="image/B16679_11_027.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.27 – Secure Boot is enabled</p>
			<p>If the<a id="_idIndexMarker1963"/> hardware of your PC does not support Secure Boot, you will receive an error message stating <strong class="source-inline">Cmdlet not supported on </strong><span class="No-Break"><strong class="source-inline">this platform.</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer250">
					<img alt="Figure 11.28 – The hardware does not support Secure Boot" src="image/B16679_11_028.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.28 – The hardware does not support Secure Boot</p>
			<p>Have a look at <a id="_idIndexMarker1964"/>the following links if you want to learn more about <span class="No-Break">Secure Boot:</span></p>
			<ul>
				<li><em class="italic">Secure Boot</em>: <a href="https://learn.microsoft.com/en-us/powershell/module/secureboot"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/ secureboot</span></a><a href="https://learn.microsoft.com/en-us/powershell/module/secureboot&#13;"/></li>
				<li><em class="italic">Secure Boot </em><span class="No-Break"><em class="italic">Landing</em></span><span class="No-Break">: </span><span class="No-Break">https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/secure-boot-landing</span></li>
			</ul>
			<p>Adversaries<a id="_idIndexMarker1965"/> often use malicious drivers and manipulated system files. Secure Boot, when combined with code integrity, ensures that the booted operating system, as well as its used drivers, can <span class="No-Break">be trusted.</span></p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor321"/>Deploying WDAC</h2>
			<p>There <a id="_idIndexMarker1966"/>are different ways to deploy WDAC: MDM or Intune, Configuration Manager, GPO, <span class="No-Break">and PowerShell.</span></p>
			<p>As <a id="_idIndexMarker1967"/>describing every deployment method in detail would exceed the capacity of this book, please refer to the official deployment guide, where you can find detailed instructions for every deployment <span class="No-Break">method: </span><span class="No-Break">https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control-deployment-guide</span><span class="No-Break">.</span></p>
			<p>In the following sections, we will explore the pros and cons of each different <span class="No-Break">deployment method.</span></p>
			<h3>GPO</h3>
			<p>Group Policy<a id="_idIndexMarker1968"/> is not the preferred method to configure WDAC; it only supports single-policy format <strong class="bold">CI policies</strong> with a <strong class="source-inline">.bin</strong>, <strong class="source-inline">.p7b</strong>, or <strong class="source-inline">.p7</strong> file type. This<a id="_idIndexMarker1969"/> format was used for devices before Windows 10 version 1903. As a best practice, use a deployment mechanism other <span class="No-Break">than GPO.</span></p>
			<p>However, if you want to use this deployment method anyway, you can find the WDAC GPO setting under <strong class="bold">Computer Configuration</strong> | <strong class="bold">Administrative Templates</strong> | <strong class="bold">System</strong> | <strong class="bold">Device Guard</strong> | <strong class="bold">Deploy Windows Defender Application Control</strong>. Using this, you can deploy a <span class="No-Break">CI policy.</span></p>
			<p>The binary CI policy that you want to deploy needs to be located either on a file share or copied to the local system of each machine that you want <span class="No-Break">to restrict.</span></p>
			<p>Detailed documentation on how to deploy WDAC using GPO can be found <span class="No-Break">here: </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-using-group-policy"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-using-group-policy</span></a><span class="No-Break">.</span></p>
			<h3>Intune</h3>
			<p>You can <a id="_idIndexMarker1970"/>use an MDM solution to configure WDAC, such<a id="_idIndexMarker1971"/> as Intune. Using Intune, application control comes with some built-in policies that you can configure so that your clients can only run Windows components, third-party hardware and software kernel drivers, apps from the Microsoft store, and applications with a good reputation that are trusted by Microsoft Intelligence Security <span class="No-Break">Graph (optional).</span></p>
			<p>Of course, it is also possible to create custom WDAC policies using OMA-URI, which can be done similarly to configuring AppLocker policies <span class="No-Break">using Intune.</span></p>
			<p>In every XML CI policy file, you can find a policy ID. Copy this ID and replace <strong class="source-inline">{PolicyID}</strong> in the following string to get the OMA-URI for your <span class="No-Break">custom policy:</span></p>
			<pre class="source-code">
./Vendor/MSFT/ApplicationControl/Policies/{PolicyID}/Policy</pre>
			<p>Please note that you also need to replace the curly brackets. The following screenshot shows where you can <span class="No-Break">find </span><span class="No-Break"><strong class="source-inline">PolicyID</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer251">
					<img alt="Figure 11.29 – You can find the policy ID in the XML CI policy file" src="image/B16679_11_029.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.29 – You can find the policy ID in the XML CI policy file</p>
			<p>Using<a id="_idIndexMarker1972"/> this <strong class="source-inline">PolicyID</strong>, the corresponding OMA-URI would<a id="_idIndexMarker1973"/> be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
./Vendor/MSFT/ApplicationControl/Policies/<strong class="bold">A244370E-44C9-4C06-B551-F6016E563076</strong>/Policy</pre>
			<p>You can learn more about how to use Intune for deploying WDAC <span class="No-Break">at </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-using-intune"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-using-intune</span></a><span class="No-Break">.</span></p>
			<h3>Microsoft Configuration Manager</h3>
			<p>When<a id="_idIndexMarker1974"/> using Configuration Manager, it <a id="_idIndexMarker1975"/>becomes a trustworthy source itself. This means that every application and piece of software that was installed over Configuration Manager becomes trustworthy and is allowed to run. This option needs to be configured through a built-in <span class="No-Break">policy first.</span></p>
			<p>Similar to deploying with Intune, Configuration Manager also provides some more built-in policies so that you can configure your clients to only run Windows components and apps from the Microsoft Store. It is also optional to trust apps with a good reputation, verified by<a id="_idIndexMarker1976"/> the <strong class="bold">Intune Service Gateway</strong> (<strong class="bold">ISG</strong>). Configuration Manager comes with another optional built-in policy: it is possible to allow apps and other executables that were already installed in a <span class="No-Break">defined folder.</span></p>
			<p>You can learn more about WDAC can be deployed using Configuration Manager <span class="No-Break">at </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-with-memcm"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-with-memcm</span></a><span class="No-Break">.</span></p>
			<h3>PowerShell</h3>
			<p>Depending<a id="_idIndexMarker1977"/> on the operating system, there are<a id="_idIndexMarker1978"/> different ways to deploy WDAC using PowerShell since not all capabilities are available for every operating system version. The <strong class="bold">WDAC policy refresh tool</strong> also<a id="_idIndexMarker1979"/> needs to be downloaded and deployed to every managed <span class="No-Break">endpoint: </span><a href="https://www.microsoft.com/en-us/download/details.aspx?id=102925"><span class="No-Break">https://www.microsoft.com/en-us/download/details.aspx?id=102925</span></a><span class="No-Break">.</span></p>
			<p>For this method, you will also need the policy’s binary to copy it to each managed endpoint. However, compared to GPO, you can deploy multiple WDAC policies. To deploy signed policies, you will also need to copy the binary policy file to the device’s EFI partition. Signed policies provide an additional layer of security by ensuring that only policies signed by trusted entities are applied to the endpoint. This step will be done automatically if Intune or the CSP is used <span class="No-Break">for deployment.</span></p>
			<p>Matt Graeber’s <strong class="bold">WDACTools</strong> is also <a id="_idIndexMarker1980"/>a valuable resource for streamlining your deployment process. These tools were specifically designed to simplify the process of building, configuring, deploying, and auditing WDAC policies. You can download<a id="_idIndexMarker1981"/> them from Matt’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/mattifestation/WDACTools"><span class="No-Break">https://github.com/mattifestation/WDACTools</span></a><span class="No-Break">.</span></p>
			<p>For detailed information on how to deploy WDAC using PowerShell, please refer <span class="No-Break">to </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-with-script"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/deploy-wdac-policies-with-script</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor322"/>How does PowerShell change when application control is enforced?</h1>
			<p>When<a id="_idIndexMarker1982"/> application control is enforced, PowerShell acts as a safeguard to prevent the misuse of its features by potential <a id="_idIndexMarker1983"/>adversaries. By proactively implementing application control measures, PowerShell ensures that its powerful scripting language cannot be easily abused by attackers to bypass <span class="No-Break">imposed restrictions.</span></p>
			<p>PowerShell can be restricted in several ways, including disabling the ability to run PowerShell scripts or only allowing signed PowerShell scripts <span class="No-Break">to run.</span></p>
			<p>In <a href="B16679_05_Final_PD.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">PowerShell Is Powerful – System and API Access</em>, we discussed how it is possible to use PowerShell to run arbitrary <strong class="bold">.NET</strong> code or<a id="_idIndexMarker1984"/> even execute compiled code if the system is not restricted. This can make it very difficult to protect against malicious code. With application control enforced, it’s possible to eliminate unconstrained code execution methods such as <strong class="source-inline">Add-Type</strong>, arbitrary .NET scripting, and other options that are typically used to bypass <span class="No-Break">security mechanisms.</span></p>
			<p>PowerShell<a id="_idIndexMarker1985"/> includes a built-in <strong class="bold">Constrained Language mode</strong>, which<a id="_idIndexMarker1986"/> we explored in <a href="B16679_10_Final_PD.xhtml#_idTextAnchor278"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Language Modes and Just Enough Administration (JEA)</em>. Constrained Language mode limits PowerShell and restricts the user from executing risky language elements, such as accessing <span class="No-Break">arbitrary APIs.</span></p>
			<p>This means that<a id="_idIndexMarker1987"/> certain <em class="italic">dangerous</em> language elements such as <strong class="source-inline">Add-Type</strong>, <strong class="bold">COM objects</strong>, and <a id="_idIndexMarker1988"/>some .NET types that can be utilized to execute arbitrary code cannot be used. If enforced, Constrained Language mode can limit the attacker’s ability to execute arbitrary code and modify system configurations. In Constrained Language mode, the PowerShell environment retains only the core basic features of a traditional less powerful interactive shell, similar to CMD, Windows Explorer, <span class="No-Break">or Bash.</span></p>
			<p>One effective approach to ensure that PowerShell code is trusted is to enforce the use of <strong class="bold">signed scripts</strong>. With <a id="_idIndexMarker1989"/>application control in place, if a script is trusted and allowed to run in <strong class="bold">Full Language mode</strong>, it is executed accordingly. But if it is not trusted, a script will always run in Constrained Language mode, which means that the script will fail if it attempts to call arbitrary APIs and other risky <span class="No-Break">language elements.</span></p>
			<p>When application control is enforced, and therefore PowerShell were to run in Constrained Language mode, if you were to try to call methods directly from .NET, they would fail, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer252">
					<img alt="Figure 11.30 – .NET types cannot be accessed with application control enabled" src="image/B16679_11_030.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.30 – .NET types cannot be accessed with application control enabled</p>
			<p>Using <strong class="source-inline">Add-Type</strong> to add and access your C types from PowerShell would also not work – you would get the following <span class="No-Break">error message:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer253">
					<img alt="Figure 11.31 – Add-Type fails when application control is enforced" src="image/B16679_11_031.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.31 – Add-Type fails when application control is enforced</p>
			<p>These <a id="_idIndexMarker1990"/>are not the only commands that would fail, but they should demonstrate how the PowerShell experience is different with application <span class="No-Break">control enabled.</span></p>
			<p>If you allow signed Windows files with your application control policy, this means that PowerShell modules that come with your Windows installation will also be allowed to run in Full Language mode. However, custom-created modules would run in Constrained language mode, unless they have been configured to be trusted in your application control setup. This effectively reduces the attack surface of <span class="No-Break">the system.</span></p>
			<p>As mentioned earlier in this chapter, at the time of writing, PowerShell and the WSH family are the only dynamic runtimes that can be restricted using application control, while others still allow unrestricted code execution. Therefore, PowerShell is a huge advantage when locking down your environment with application <span class="No-Break">control policies.</span></p>
			<p>In summary, enforcing application control mechanisms such as WDAC and AppLocker can have a significant impact on improving PowerShell security. It’s possible to limit the ability of PowerShell scripts to execute arbitrary code or modify system configurations by enforcing constraints such as Constrained Language mode. By implementing these measures, it’s possible to reduce the attack surface of the system significantly and make it more difficult for attackers to execute <span class="No-Break">malicious code.</span></p>
			<p><span class="No-Break">Summary</span></p>
			<p>In this chapter, you learned how to configure your existing PowerShell scripts as trustworthy and how to allowlist them, but not just PowerShell scripts. At this point, you should have a good understanding of how you can implement a proper application control solution for all the applications in <span class="No-Break">your environment.</span></p>
			<p>First, you explored how to sign your code and how to create a self-signed script that you can use for testing purposes. With this knowledge, you can easily transfer to your enterprise scenario, in which you might already have corporate-signed or public-signed certificates <span class="No-Break">in use.</span></p>
			<p>Next, we dove into application control and learned what built-in application control solutions exist: SRP, AppLocker, and WDAC. You should now also be familiar with how to plan for allowlisting applications in <span class="No-Break">your environment.</span></p>
			<p>Then, we explored AppLocker and WDAC and learned how to audit AppLocker and WDAC. We also investigated how to configure AppLocker to avoid a possible PowerShell <span class="No-Break">downgrade attack.</span></p>
			<p>Last but not least, we learned that whenever possible, WDAC is the most secure option, followed by AppLocker. However, both can be combined in the same environment, depending on your operating systems and <span class="No-Break">use cases.</span></p>
			<p>However, only restricting scripts and applications is not enough for a secure and hardened environment. In the next chapter, we’ll explore how the Windows <strong class="bold">Antimalware Scan Interface</strong> (<strong class="bold">AMSI</strong>) can protect you from malicious code that is run directly in the console or <span class="No-Break">in memory.</span></p>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor323"/>Further reading</h1>
			<p>If you want to explore some of the topics that were mentioned in this chapter, take a look at the <span class="No-Break">following resources:</span></p>
			<p><span class="No-Break"><strong class="bold">Certificate operations</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><span class="No-Break">New-SelfSignedCertificate: </span><a href="https://docs.microsoft.com/en-us/powershell/module/pki/new-selfsignedcertificate"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/pki/new-selfsignedcertificate</span></a><a href="https://docs.microsoft.com/en-us/powershell/module/pki/new-selfsignedcertificate&#13;"/></li>
				<li><span class="No-Break">Set-AuthenticodeSignature: </span><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-authenticodesignature"><span class="No-Break">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-authenticodesignature</span></a><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-authenticodesignature&#13;"/></li>
				<li>Get-AuthenticodeSignature: <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/get-authenticodesignature">https://docs.microsoft.com/en-us/powershell/wwmodule/microsoft.powershell.security/get-authenticodesignature</a> <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.security/get-authenticodesignature&#13;"/></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">CI/CD</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>CI/CD: The what, why, and <span class="No-Break">how: </span><a href="https://resources.github.com/ci-cd/"><span class="No-Break">https://resources.github.com/ci-cd/</span></a><a href="https://resources.github.com/ci-cd/&#13;"/></li>
				<li>About continuous <span class="No-Break">integration: </span><a href="https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration"><span class="No-Break">https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration</span></a><a href="https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration&#13;"/></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Application control</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>Application Control for <span class="No-Break">Windows: </span><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control"><span class="No-Break">https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control</span></a><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control&#13;"/></li>
				<li>Authorize reputable apps with the Intelligent Security Graph (<span class="No-Break">ISG): </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/use-wdac-with-intelligent-security-graph"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/use-wdac-with-intelligent-security-graph</span></a><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/use-windows-defender-application-control-with-intelligent-security-graph&#13;"/></li>
				<li>Enable virtualization-based protection of code <span class="No-Break">integrity: </span><a href="https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/hardware-security/enable-virtualization-based-protection-of-code-integrity</span></a><a href="https://learn.microsoft.com/en-us/windows/security/threat-protection/device-guard/enable-virtualization-based-protection-of-code-integrity&#13;"/></li>
				<li>ConfigCI module reference (ConfigCI): <a href="https://docs.microsoft.com/en-us/powershell/module/configci">https://docs.microsoft.com/en-us/powershell/module/configci</a> <a href="https://docs.microsoft.com/en-us/powershell/module/configci&#13;"/></li>
				<li>Understand Windows Defender Application Control (WDAC) policy rules and file <span class="No-Break">rules</span><span class="No-Break">: </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/select-types-of-rules-to-create"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/select-types-of-rules-to-create</span></a><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/select-types-of-rules-to-create&#13;"/></li>
				<li>Understanding WDAC Policy <span class="No-Break">Settings: </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/understanding-wdac-policy-settings"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/understanding-wdac-policy-settings</span></a><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/understanding-wdac-policy-settings&#13;"/></li>
				<li>Use multiple Windows Defender Application Control <span class="No-Break">Policies: </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/deploy-multiple-wdac-policies"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/deploy-multiple-wdac-policies</span></a><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/deploy-multiple-windows-defender-application-control-policies&#13;"/></li>
				<li>Use signed policies to protect Windows Defender Application Control against <span class="No-Break">tampering: </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/use-signed-policies-to-protect-wdac-against-tampering"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/deployment/use-signed-policies-to-protect-wdac-against-tampering</span></a></li>
				<li>Windows Defender Application Control management with Configuration <span class="No-Break">Manager: </span><a href="https://learn.microsoft.com/en-us/mem/configmgr/protect/deploy-use/use-device-guard-with-configuration-manager"><span class="No-Break">https://learn.microsoft.com/en-us/mem/configmgr/protect/deploy-use/use-device-guard-with-configuration-manager</span></a></li>
				<li>Windows Defender Application Control <span class="No-Break">Wizard: </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/wdac-wizard"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/wdac-wizard</span></a><a href="https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/wdac-wizard&#13;"/></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">AppLocker</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>AppLocker Operations <span class="No-Break">Guide: </span><a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/ee791916(v=ws.10)"><span class="No-Break">https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/ee791916(v=ws.10)</span></a><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/ee791916(v=ws.10)&#13;"/></li>
				<li>Enable the DLL rule <span class="No-Break">collection: </span><a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/enable-the-dll-rule-collection"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/applocker/enable-the-dll-rule-collection</span></a><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/applocker/enable-the-dll-rule-collection&#13;"/></li>
			</ul>
			<p>You can also find all the links mentioned in this chapter in the GitHub repository for <a href="B16679_11_Final_PD.xhtml#_idTextAnchor306"><span class="No-Break"><em class="italic">Chapter 11</em></span></a> – no need to manually type in every <span class="No-Break">link: </span><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter11/Links.md</span><span class="No-Break">.</span></p>
		</div>
	</body></html>