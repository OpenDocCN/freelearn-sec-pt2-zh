<html><head></head><body>
		<div id="_idContainer282">
			<h1 class="chapter-number" id="_idParaDest-326"><span lang="en-US" xml:lang="en-US"><a id="_idTextAnchor341"/></span>13</h1>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor342"/>What Else? – Further Mitigations and Resources</h1>
			<p>In this book, we have looked at many topics and techniques that help you mitigate risks in your environment when it comes to PowerShell. But of course, there are many more things that you can do to secure your environment – many directly related to PowerShell, but also others that are not directly related but help you <span class="No-Break">secure PowerShell.</span></p>
			<p>In this chapter, we won’t deep dive into every mitigation; instead, I will provide an overview of what other mitigations exist so that you can explore each on your own. We will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li><span class="No-Break">Secure scripting</span></li>
				<li>Exploring Desired <span class="No-Break">State Configuration</span></li>
				<li>Hardening systems <span class="No-Break">and environment</span></li>
				<li>Attack detection – Endpoint Detection <span class="No-Break">and Response</span></li>
			</ul>
			<h1 id="_idParaDest-328"><a id="_idTextAnchor343"/>Technical requirements</h1>
			<p>To make the most out of this chapter, ensure that you have <span class="No-Break">the following:</span></p>
			<ul>
				<li>PowerShell 7.3 <span class="No-Break">and above</span></li>
				<li>Installed Visual <span class="No-Break">Studio Code</span></li>
				<li>Access to the GitHub repository for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter13"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter13</span></a><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-CyberSecurity/tree/master/Chapter13&#13;"/></li>
			</ul>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor344"/>Secure scripting</h1>
			<p>If you are leveraging self-written scripts in <a id="_idIndexMarker2038"/>your environment, secure scripting is indispensable. If your scripts can be manipulated, it doesn’t matter (most of the time) what other security mechanisms you <span class="No-Break">have implemented.</span></p>
			<p>Be aware that your scripts can be hacked, and malicious code can be injected. In these cases, you must do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Always <span class="No-Break">validate input</span></li>
				<li>Have your code reviewed when <span class="No-Break">developing scripts</span></li>
				<li>Secure the script’s location <span class="No-Break">and access</span></li>
				<li>Adopt a secure coding standard, such as the <em class="italic">OWASP Secure Coding Practices – Quick Reference </em><span class="No-Break"><em class="italic">Guide</em></span><span class="No-Break">: </span><a href="https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/&#13;"><span class="No-Break">https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/</span></a></li>
			</ul>
			<p>Additionally, two neat PowerShell modules come in handy when developing your own PowerShell scripts that you should know about – <strong class="bold">PSScriptAnalyzer</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">InjectionHunter</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor345"/>PSScriptAnalyzer</h2>
			<p><strong class="bold">PSScriptAnalyzer</strong> is a tool that <a id="_idIndexMarker2039"/>statically checks code for PowerShell scripts and modules. It checks against <a id="_idIndexMarker2040"/>predefined rules and returns all findings, along with recommendations on how to improve your potential <span class="No-Break">code defects.</span></p>
			<p>Using <strong class="source-inline">PSScriptAnalyzer</strong> to verify your code helps you to maintain higher code quality and avoid common issues. It is not necessarily a tool to check the security of your code (although it provides security checks such as <strong class="source-inline">Avoid using Invoke-Expression</strong>), but a tool to check whether you applied PowerShell <span class="No-Break">best practices.</span></p>
			<p>It can be installed from PowerShell Gallery using <span class="No-Break"><strong class="source-inline">Install-Module PSScriptAnalyzer</strong></span><span class="No-Break">.</span></p>
			<p>Once installed, it provides the <strong class="source-inline">Get-ScriptAnalyzerRule</strong>, <strong class="source-inline">Invoke-Formatter</strong>, and <span class="No-Break"><strong class="source-inline">Invoke-ScriptAnalyzer</strong></span><span class="No-Break"> cmdlets.</span></p>
			<p>For our use case, we will only look into <strong class="source-inline">Invoke-ScriptAnalyzer</strong>, but make sure you check out the entire module on your own to improve your PowerShell scripts <span class="No-Break">and modules.</span></p>
			<p>Use <strong class="source-inline">Invoke-ScriptAnalyzer</strong>, followed by <strong class="source-inline">-Path</strong> and the path to the script, to have your code checked, as<a id="_idIndexMarker2041"/> shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer272">
					<img alt="Figure 13.1 – Invoking ScriptAnalyzer" src="image/B16679_13_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Invoking ScriptAnalyzer</p>
			<p>When nothing else is <a id="_idIndexMarker2042"/>specified, <strong class="source-inline">PSScriptAnalyzer</strong> checks against its own set of rules. But you can also specify your own custom rules by using the <strong class="source-inline">-CustomRulePath</strong> and <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">RecurseCustomRulePath</strong></span><span class="No-Break"> parameters.</span></p>
			<p>If you’re using Visual Studio Code with the <em class="italic">PowerShell</em> extension to write PowerShell scripts, <strong class="source-inline">PSScriptAnalyzer</strong> is enabled by default. Here, your code will be automatically checked and you will be provided with warnings for any potential issues while writing <span class="No-Break">your code.</span></p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor346"/>InjectionHunter</h2>
			<p><strong class="bold">InjectionHunter</strong> is a module, written by Lee Holmes, that helps you detect ways to inject code into<a id="_idIndexMarker2043"/> your very own<a id="_idIndexMarker2044"/> PowerShell script. It can<a id="_idIndexMarker2045"/> be downloaded from <strong class="bold">PowerShell </strong><span class="No-Break"><strong class="bold">Gallery</strong></span><span class="No-Break">: </span><a href="https://www.powershellgallery.com/packages/InjectionHunter/1.0.0 "><span class="No-Break">https://www.powershellgallery.com/packages/InjectionHunter/1.0.0</span></a></p>
			<p>Install it by using <span class="No-Break"><strong class="source-inline">Install-Module InjectionHunter</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">InjectionHunter</strong> relies on <strong class="source-inline">ScriptAnalyzer.Generic.DiagnosticRecord</strong> as its output type and uses custom detection rules, so <strong class="bold">PSScriptAnalyzer</strong> also needs to <span class="No-Break">be</span><span class="No-Break"><a id="_idIndexMarker2046"/></span><span class="No-Break"> installed.</span></p>
			<p><strong class="source-inline">InjectionHunter</strong> comes with eight different functions, all of which can help you find out whether your code is vulnerable to various scenarios. These are <strong class="source-inline">Measure-AddType</strong>, <strong class="source-inline">Measure-CommandInjection</strong>, <strong class="source-inline">Measure-DangerousMethod</strong>, <strong class="source-inline">Measure-ForeachObjectInjection</strong>, <strong class="source-inline">Measure-InvokeExpression</strong>, <strong class="source-inline">Measure-MethodInjection</strong>, <strong class="source-inline">Measure-PropertyInjection</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Measure-UnsafeEscaping</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">InjectionHunter</strong> functions are used to create a new <strong class="source-inline">PSScriptAnalyzer</strong> plugin that can detect potential injection attacks in PowerShell scripts. These functions are designed to accept <strong class="source-inline">-ScriptBlockAst</strong> as a parameter, which represents the <strong class="bold">Abstract Syntax Tree</strong> (<strong class="bold">AST</strong>) of the script. The<a id="_idIndexMarker2047"/> AST groups tokens into structures and is a deliberate way to parse and analyze data <span class="No-Break">with PowerShell.</span></p>
			<p>The following example demonstrates how to use <strong class="source-inline">PSScriptAnalyzer</strong> to call the <span class="No-Break"><strong class="source-inline">InjectionHunter</strong></span><span class="No-Break"> rules:</span></p>
			<pre class="source-code">
&gt; Invoke-ScriptAnalyzer -Path C:\Users\Administrator\Downloads\PowerShell-Automation-and-Scripting-for-Cybersecurity-master\Chapter12\Examples_whyAMSI.ps1 -CustomRulePath ( Get-Module InjectionHunter -List | % Path )</pre>
			<p>The following screenshot shows what it looks like to call <strong class="source-inline">InjectionHunter</strong> rules <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">PSScriptAnalyzer</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer273">
					<img alt="Figure 13.2 – Calling the InjectionHunter rules from PSScriptAnalyzer" src="image/B16679_13_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Calling the InjectionHunter rules from PSScriptAnalyzer</p>
			<p><strong class="source-inline">InjectionHunter</strong> was not intended for direct use in analyzing scripts. However, you can use its functions to<a id="_idIndexMarker2048"/> develop a custom <strong class="source-inline">PSScriptAnalyzer</strong> plugin that can detect injection attacks in your <span class="No-Break">PowerShell scripts.</span></p>
			<p>But wouldn’t it be cool to immediately know whether you were implementing a potential injection risk while writing your scripts? Lee Holmes and the PowerShell team have you covered. The following blog article explains how this can be achieved when using Visual Studio Code to edit <span class="No-Break">scripts: </span><a href="https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/"><span class="No-Break">https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor347"/>Exploring Desired State Configuration</h1>
			<p>PowerShell <strong class="bold">Desired State Configuration</strong> (<strong class="bold">DSC</strong>) is a feature that enables you to manage your<a id="_idIndexMarker2049"/> servers using PowerShell configuration <span class="No-Break">as code.</span></p>
			<p>At the time of writing, the following versions of DSC are available that you can use for deployment: <strong class="bold">DSC 1.1</strong>, <strong class="bold">DSC 2.0</strong>, and <span class="No-Break"><strong class="bold">DSC 3.0</strong></span><span class="No-Break">.</span></p>
			<p>While DSC 1.1 was included in Windows PowerShell 5.1, in DSC 2.0, which must run DSC on PowerShell 7.2 and above, <strong class="source-inline">PSDesiredStateConfiguration</strong> is no longer included in the PowerShell package. This enables the DSC creators to develop DSC independently of PowerShell and enables users to upgrade DSC without the need to upgrade PowerShell <span class="No-Break">as well.</span></p>
			<h2 id="_idParaDest-333"><strong class="bold"><a id="_idTextAnchor348"/>DSC 1.1</strong></h2>
			<p>DSC 1.1 is included in Windows and updated through Windows Management Framework. It runs in <a id="_idIndexMarker2050"/>Windows PowerShell 5.1. This is the go-to version if Azure <a id="_idIndexMarker2051"/>Automanage Machine Configuration is not <span class="No-Break">in use.</span></p>
			<h3>Remediation</h3>
			<p>DSC 1.1 has two <span class="No-Break">configuration modes:</span></p>
			<ul>
				<li><strong class="bold">Push</strong>: The configuration<a id="_idIndexMarker2052"/> is <span class="No-Break">pushed manually</span></li>
				<li><strong class="bold">Pull</strong>: The nodes are configured to pull their configuration frequently from the <span class="No-Break">pull server</span></li>
			</ul>
			<p>One huge advance of DSC in pull mode is that your configuration, once specified, is self-healing. This means you configure your nodes using code and set up your configuration. Once activated, you can configure your configuration so that it’s frequently pulled from your nodes. This means that if someone were to change the local configuration of a server or endpoint configured with DSC, the configuration would be changed back after the <span class="No-Break">next pull.</span></p>
			<p>Pull mode is a more complex configuration, but in the end, it is easier to maintain and helps you keep your devices more secure than using push mode. When using this mode, systems <span class="No-Break">remediate themselves.</span></p>
			<p>If you’re interested in using DSC for central administration, it’s worth noting that signed configurations make DSC an even more secure form of remote policy management. Signed configurations ensure that only authorized changes are applied to a system. Without a valid signature, a configuration cannot <span class="No-Break">be applied.</span></p>
			<p>This can be particularly valuable in protecting against attacks that compromise central management channels, such as GPO. With signed configurations in DSC and tight control over your signing infrastructure, attackers cannot use compromised channels to deliver ransomware company-wide, <span class="No-Break">for example.</span></p>
			<p>You can learn more about the DSC module and configuration signing by visiting the following<a id="_idIndexMarker2053"/> documentation <span class="No-Break">page: </span><a href="https://learn.microsoft.com/en-us/powershell/scripting/windows-powershell/wmf/whats-new/dsc-improvements?#dsc-module-and-configuration-signing-validations"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/scripting/windows-powershell/wmf/whats-new/dsc-improvements?#dsc-module-and-configuration-signing-validations</span></a><span class="No-Break">.</span></p>
			<p>DSC is quite extensive, but<a id="_idIndexMarker2054"/> there’s a lot of documentation, including quick starts and tutorials, that can help you get <span class="No-Break">started: </span><a href="https://learn.microsoft.com/en-us/powershell/dsc/overview?view=dsc-1.1"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/dsc/overview?view=dsc-1.1</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-334"><strong class="bold"><a id="_idTextAnchor349"/>DSC 2.0</strong></h2>
			<p>DSC 2.0 is supported for PowerShell 7.2 and above. While the original DSC platform was built on top of WMI for <a id="_idIndexMarker2055"/>Windows, newer versions were decoupled from <span class="No-Break">that model.</span></p>
			<p>It can be deployed using PSGallery by running the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
Install-Module -Name PSDesiredStateConfiguration -Repository PSGallery -MaximumVersion 2.99</pre>
			<p>DSC version 2.0 should only be used if Azure Automanage Machine Configuration is in use. Although the <strong class="source-inline">Invoke-DscResource</strong> cmdlet is still available with this version, you should only use it for testing purposes and rely on Azure Automanage Machine <span class="No-Break">Configuration instead.</span></p>
			<h3>Remediation</h3>
			<p>Thanks to Azure Automanage <a id="_idIndexMarker2056"/>Machine Configuration, you don’t need to set up a pull server as you must with DSC 1.1 since Azure Automanage Machine Configuration deals with this responsibility <span class="No-Break">for you.</span></p>
			<p>There are three different machine configuration assignment types that you can <span class="No-Break">choose from:</span></p>
			<ul>
				<li><strong class="bold">Audit</strong>: Only report; don’t <span class="No-Break">change</span><span class="No-Break"><a id="_idIndexMarker2057"/></span><span class="No-Break"> anything.</span></li>
				<li><strong class="bold">ApplyAndMonitor</strong>: Apply the configuration<a id="_idIndexMarker2058"/> once, but if the configuration is changed, only report and don’t remediate until it’s <span class="No-Break">triggered manually.</span></li>
				<li><strong class="bold">ApplyAndAutoCorrect</strong>: Apply the configuration permanently. Once a change is made, the machine remediates at the <span class="No-Break">next evaluation.</span></li>
			</ul>
			<p><strong class="bold">ApplyAndAutoCorrect</strong> is a great option that is similar to the pull configuration mode in DSC 1.1; it helps your systems <a id="_idIndexMarker2059"/>become more secure as they<a id="_idIndexMarker2060"/> remediate changes <span class="No-Break">by themselves.</span></p>
			<p>Check out the following link to learn more about DSC <span class="No-Break">2.0: </span><a href="https://learn.microsoft.com/en-us/powershell/dsc/overview?view=dsc-2.0"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/dsc/overview?view=dsc-2.0</span></a><span class="No-Break"><strong class="source-inline">.</strong></span></p>
			<h2 id="_idParaDest-335"><strong class="bold"><a id="_idTextAnchor350"/>DSC 3.0</strong></h2>
			<p>DSC 3.0 is a<a id="_idIndexMarker2061"/> preview release that is still under development as of <span class="No-Break">April 2023.</span></p>
			<p>This version supports cross-platform features and is supported by Azure Automanage Machine Configuration in Azure Policy. It can be installed with PSGallery by using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
Install-Module -Name PSDesiredStateConfiguration -AllowPrerelease</pre>
			<p>For DSC 3.0, the remediation options are the same as for <span class="No-Break">DSC 2.0.</span></p>
			<p>You can find out more about DSC 3.0 by reading the official <span class="No-Break">documentation: </span><a href="https://learn.microsoft.com/en-us/powershell/dsc/overview?view=dsc-3.0"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/dsc/overview?view=dsc-3.0</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor351"/>Configuration</h2>
			<p>To get started with DSC, you need a DSC configuration, which you can compile into a <strong class="source-inline">.mof</strong> file. Often, you will <a id="_idIndexMarker2062"/>want to cover a scenario that has already been predefined as a resource and tweak it to your use case; in this case, you also want to include a predefined resource in <span class="No-Break">your configuration.</span></p>
			<p class="callout-heading">DSC resources</p>
			<p class="callout">Before creating your own DSC<a id="_idIndexMarker2063"/> resources, always check whether there is already a resource that fits your use case; there’s a multitude of existing resources that you can find on GitHub or PowerShell Gallery. Once you have found the right DSC resource for your use case, you can install it <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">PowerShellGet</strong></span><span class="No-Break">:</span></p>
			<p class="callout"><strong class="bold">&gt; Install-Module -</strong><span class="No-Break"><strong class="bold">Name AuditPolicyDSC</strong></span></p>
			<p class="callout">In this<a id="_idIndexMarker2064"/> example, the <strong class="source-inline">AuditPolicyDSC</strong> resource would be installed, which helps you configure and manage the advanced audit policy on <span class="No-Break">Windows machines.</span></p>
			<p>The following example shows a configuration that imports the <strong class="source-inline">AuditPolicyDsc</strong> resource and then uses it to<a id="_idIndexMarker2065"/> ensure that all successful logons are being audited on the host, on which this configuration will be applied, via the equivalent advanced audit <span class="No-Break">policy setting:</span></p>
			<pre class="source-code">
Configuration AuditLogon
{
    Import-DscResource -ModuleName AuditPolicyDsc
    Node 'localhost'
    {
        AuditPolicySubcategory LogonSuccess
        {
            Name      = 'Logon'
            AuditFlag = 'Success'
            Ensure    = 'Present'
        }
    }
}
AuditLogon</pre>
			<p>We must save this code in a file named <strong class="source-inline">AuditLogon.ps1</strong> under <strong class="source-inline">C:\temp\</strong> to dot <span class="No-Break">source it:</span></p>
			<pre class="source-code">
&gt; . C:\temp\AuditLogon.ps1</pre>
			<p>The following screenshot shows how the file is being compiled into a <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">mof</strong></span><span class="No-Break"> file:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer274">
					<img alt="Figure 13.3 – Compiling your DSC configuration into a .mof file" src="image/B16679_13_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Compiling your DSC configuration into a .mof file</p>
			<p>Depending on the setup and the DSC version that you are running, you can now use this file to apply your DSC <a id="_idIndexMarker2066"/>configuration to the system of your choice. Please refer to the official documentation for <span class="No-Break">more information:</span></p>
			<ul>
				<li>DSC <span class="No-Break">1.1: </span><a href="https://learn.microsoft.com/en-us/powershell/dsc/configurations/write-compile-apply-configuration?view=dsc-1.1&#13;"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/dsc/configurations/write-compile-apply-configuration?view=dsc-1.1</span></a></li>
				<li>DSC <span class="No-Break">2.0: </span><a href="https://learn.microsoft.com/en-us/powershell/dsc/concepts/configurations?view=dsc-2.0&#13;"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/dsc/concepts/configurations?view=dsc-2.0</span></a></li>
				<li>DSC <span class="No-Break">3.0: </span><a href="https://learn.microsoft.com/en-us/powershell/dsc/concepts/configurations?view=dsc-3.0&#13;"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/dsc/concepts/configurations?view=dsc-3.0</span></a></li>
			</ul>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor352"/>Hardening systems and environments</h1>
			<p>In the end, you can harden PowerShell as much as you like; if the systems on which PowerShell is running are <a id="_idIndexMarker2067"/>not protected, adversaries will make use of that if they have the chance. Therefore, it is important to also look at how you can harden the security of <span class="No-Break">your infrastructure.</span></p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor353"/>Security baselines</h2>
			<p>A great start<a id="_idIndexMarker2068"/> to hardening your Windows systems – regardless of the server, domain controller, or client – are the so-called security <a id="_idIndexMarker2069"/>baselines provided by Microsoft. These security baselines are part of Microsoft’s <strong class="bold">Security Compliance Toolkit</strong> (<strong class="bold">SCT</strong>) 1.0, which can be <a id="_idIndexMarker2070"/>downloaded from <span class="No-Break">here: </span><span class="No-Break">https://www.microsoft.com/en-us/download/details.aspx?id=55319</span><span class="No-Break">.</span></p>
			<p class="callout-heading">Please be careful when applying security baselines!</p>
			<p class="callout">You should never just apply a security baseline to a running production system. Before applying it, carefully audit your settings and evaluate them. Then, work on a plan to enroll your changes. Many settings are included that could break the functioning of your systems if they are not carefully planned for <span class="No-Break">and enrolled.</span></p>
			<p>When you download SCT, you will see that there are many files within it that you can download. Most of the files are the actual baselines (most baseline packages end with <span class="No-Break"><strong class="source-inline">Security Baseline.zip</strong></span><span class="No-Break">).</span></p>
			<p>But helpful tools are also included, including <strong class="bold">LGPO</strong>, <strong class="bold">SetObjectSecurity</strong>, and <span class="No-Break"><strong class="bold">Policy Analyzer</strong></span><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="bold">LGPO</strong>: This tool can be used to<a id="_idIndexMarker2071"/> perform local Group Policy Object (GPO) operations. You can use this tool to import settings into a local Group Policy, export a local Group Policy, parse a <strong class="source-inline">registry.pol</strong> file in <strong class="bold">LGPO text</strong> format, build a <strong class="source-inline">registry.pol</strong> file from <strong class="bold">LGPO text</strong>, and<a id="_idIndexMarker2072"/> enable Group Policy client-side extensions for local policy processing. Since it’s a command-line tool, LGPO can be used to automate local <span class="No-Break">GPO operations.</span></li>
				<li><strong class="bold">SetObjectSecurity</strong>: Using <strong class="source-inline">SetObjectSecurity</strong>, you can set the security descriptor for any type of Windows <a id="_idIndexMarker2073"/>securable object – be it files, registry hives, event logs, and <span class="No-Break">many more.</span></li>
				<li><strong class="bold">Policy Analyzer</strong>: Policy Analyzer<a id="_idIndexMarker2074"/> is a tool for comparing baselines and GPOs, but not only <a id="_idIndexMarker2075"/>exported GPOs – you can also compare a GPO with your local policy. It can highlight differences between the policies, as well as help you <span class="No-Break">spot redundancies.</span></li>
			</ul>
			<p>All three tools are standalone, which<a id="_idIndexMarker2076"/> means that you don’t need to install them to <span class="No-Break">use them.</span></p>
			<p>You can use <strong class="bold">PolicyAnalyzer</strong> to check the current state of your machines. Download <strong class="bold">PolicyAnalyzer</strong> and the security baseline that you want to use to check your systems against. In our example, I used the <em class="italic">Windows Server 2022 Security Baseline</em> as my <span class="No-Break">example baseline.</span></p>
			<p>We looked into the <strong class="bold">SCT</strong> in <a href="B16679_04_Final_PD.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Detection – Auditing and Monitoring</em>, when we talked about auditing recommendations and EventList. There, we learned that security baselines contain auditing recommendations. But they also contain some system settings recommendations, such as the Lan Manager authentication level (<strong class="source-inline">LmCompatibilityLevel</strong>), which you can use to deny insecure authentication mechanisms in your domain. Please be extremely careful and audit which authentication protocols are used before applying this setting to the <span class="No-Break">recommended one.</span></p>
			<p>Before you can work with baselines, you will need to extract them. The following code snippet shows how you can use PowerShell to <span class="No-Break">extract them:</span></p>
			<pre class="source-code">
$baselineZipPath = $env:TEMP + "\baselines\Windows 11 version 22H2 Security Baseline.zip"
$baselineDirPath = $env:TEMP + "\baselines\"
if ( !( Test-Path -Path $baselineDirPath ) ) {
    New-Item -ItemType Directory -Path $baselineDirPath
}
Expand-Archive -Path $baselineZipPath -DestinationPath $baselineDirPath</pre>
			<p>While the <strong class="source-inline">$baselineZipPath</strong> variable leads to the path where the baseline ZIP file is located, the <strong class="source-inline">$baselineDirPath</strong> variable points to the folder into which the baselines should be extracted. If the <strong class="source-inline">$baselineDirPath</strong> folder is not available yet, the folder will be created. The archive can be extracted using the <span class="No-Break"><strong class="source-inline">Expand-Archive</strong></span><span class="No-Break"> cmdlet.</span></p>
			<p>After extracting a security baseline, you will find the five following folders in the ZIP file, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer275">
					<img alt="Figure 13.4 – Contents of a security baseline" src="image/B16679_13_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Contents of a security baseline</p>
			<p>The actual baselines reside in the <strong class="source-inline">GPOs</strong> folder. You can use the files in there to import the baselines for testing<a id="_idIndexMarker2077"/> purposes on a test system or to add them to <span class="No-Break">Policy Analyzer.</span></p>
			<p>When initially executing Policy Analyzer, you will see its starting interface, which looks <span class="No-Break">as follows:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer276">
					<img alt="Figure 13.5 – Policy Analyzer" src="image/B16679_13_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Policy Analyzer</p>
			<p>To get started, click on <strong class="bold">Add …</strong> to add a new baseline to compare. Navigate to the GPOs folder within the selected baseline<a id="_idIndexMarker2078"/> and select it. Since many baseline files are included that you won’t want to add, you need to remove all the unnecessary ones by selecting them in the <strong class="bold">Policy File Importer</strong> view and removing them by using the <em class="italic">Delete</em> key on <span class="No-Break">your keyboard.</span></p>
			<p>In this example, I want to investigate a domain controller, so I deleted every other baseline except for the domain controller ones, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer277">
					<img alt="Figure 13.6 – Importing domain controller security baselines" src="image/B16679_13_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Importing domain controller security baselines</p>
			<p>Once all the necessary baselines are in the <strong class="bold">Policy File Importer</strong> view, click on <strong class="bold">Import...</strong> to import them. Before they are imported, you will be prompted to enter a name and save the policy. In this <a id="_idIndexMarker2079"/>example, I have called the <span class="No-Break">policy </span><span class="No-Break"><strong class="source-inline">2022_DC</strong></span><span class="No-Break">.</span></p>
			<p>Once the baselines have been imported, you can either add another baseline or exported GPO to compare their settings (using <strong class="bold">View / Compare</strong>). Alternatively, you can also compare a baseline with the effective state of the current system (using <strong class="bold">Compare to </strong><span class="No-Break"><strong class="bold">Effective State</strong></span><span class="No-Break">):</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer278">
					<img alt="Figure 13.7 – The imported 2022_DC policy within Policy Analyzer" src="image/B16679_13_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – The imported 2022_DC policy within Policy Analyzer</p>
			<p>In our example, I have selected the <strong class="source-inline">2022_DC</strong> policy and compared the <strong class="source-inline">DC01</strong> demo environment’s <a id="_idIndexMarker2080"/>domain controller with the effective state. A new window will appear so that you can investigate all the recommended and effective settings: if a setting remains white, then it matches, while if a setting is marked in gray, it’s not been configured or has been left empty. Finally, if a setting is marked in yellow, that means that there’s a conflict and there’s a <span class="No-Break">setting mismatch:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer279">
					<img alt="Figure 13.8 – Comparing settings with Policy Analyzer" src="image/B16679_13_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Comparing settings with Policy Analyzer</p>
			<p>By doing this, you can check whether the recommendation reflects the current state of your configuration and what you need to configure if it doesn’t match yet. Again – please do not just apply the <a id="_idIndexMarker2081"/>recommendations without evaluating what these changes mean for <span class="No-Break">your environment.</span></p>
			<p>There are not only security baselines for domain controllers but also for member servers and clients, as well as for settings for <span class="No-Break">other areas.</span></p>
			<p>It is also possible to use PowerShell to interact with those baselines. Every baseline is an exported GPO that you can parse. The <strong class="source-inline">gpreport.xml</strong> file contains every setting that was configured in this GPO. So, if we import the <strong class="source-inline">gpreport.xml</strong> file of a security baseline as a PowerShell object, we can query all the settings available while referring to the <span class="No-Break">XML syntax.</span></p>
			<p>The following <strong class="source-inline">Import-Baseline</strong> function helps you with <span class="No-Break">this task:</span></p>
			<pre class="source-code">
function Import-Baseline {
    [cmdletbinding()]
    param (
        [Parameter(Mandatory)]
        [string]$Path
    )
    $Item  = Join-Path -Path (Get-ChildItem -Path $Path -Filter "gpreport.xml" -Recurse | Select-Object -First 1).DirectoryName -ChildPath "\gpreport.xml"
    if (Test-Path -Path $Item) {
        [xml]$Settings = Get-Content $Item
    }
    return $Settings.GPO
}</pre>
			<p>It looks for the first <strong class="source-inline">gpreport.xml</strong> file in the specified folder recursively and returns its settings as an <span class="No-Break">XML object.</span></p>
			<p>For example, if you want to <a id="_idIndexMarker2082"/>access the recommended audit settings of the <em class="italic">Windows 10 22H2 – Computer, </em>baseline, we would first import it into the <strong class="source-inline">$Baseline</strong> variable, as shown in this <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
&gt; $Baseline = Import-Baseline -Path "C:\baselines\Windows-10-v22H2-Security-Baseline\GPOs\{AA94F467-FC14-4789-A1C4-7F74B23184B2}"</pre>
			<p>Now, all XML nodes are available and can be queried using the <strong class="source-inline">$Baseline</strong> variable. First, let’s check the name of the baseline to make sure that we imported the <span class="No-Break">right one:</span></p>
			<pre class="source-code">
&gt; $Baseline.Name
MSFT Windows 10 22H2 - Computer</pre>
			<p>Next, we want to access the audit settings, which are located under the <span class="No-Break"><strong class="source-inline">Computer.ExtensionData.Extension.AuditSetting</strong></span><span class="No-Break"> node:</span></p>
			<pre class="source-code">
&gt; $Baseline.Computer.ExtensionData.Extension.AuditSetting</pre>
			<p>As shown in the following screenshot, you can see every recommended audit setting and its value – that is, the output of <span class="No-Break">the command:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer280">
					<img alt="Figure 13.9 – Querying the audit setting XML nodes of the baseline" src="image/B16679_13_009.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – Querying the audit setting XML nodes of the baseline</p>
			<p>Here, you <a id="_idIndexMarker2083"/>can see <strong class="source-inline">SettingValue</strong>, which indicates whether it is recommended to audit for <strong class="bold">Success</strong> (<strong class="source-inline">1</strong>), <strong class="bold">Failure</strong> (<strong class="source-inline">2</strong>), or for both <strong class="bold">Success and Failure</strong> (<strong class="source-inline">3</strong>). <strong class="source-inline">0</strong> would indicate that there it is explicitly not recommended to audit this setting (that is, <em class="italic">audit setting disabled</em>) – a value that you will never find in the security baselines distributed <span class="No-Break">by Microsoft.</span></p>
			<p>With this, you can now query all imported XML nodes that were configured in <span class="No-Break">this GPO.</span></p>
			<p>Another great tool that can help you monitor your security settings for compliance using <strong class="bold">DSC</strong> is the <strong class="source-inline">BaselineManagement</strong> module. With its help, you can convert baselines as well as Group Policies into DSC configuration scripts (<strong class="source-inline">.ps1</strong>) and <strong class="source-inline">.mof</strong> files, which you can use to monitor the compliance of <span class="No-Break">your systems.</span></p>
			<p>You can find more information on how to set this up in the GPO DSC quick start <span class="No-Break">documentation: </span><a href="https://learn.microsoft.com/en-us/powershell/dsc/quickstarts/gpo-quickstart"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/dsc/quickstarts/gpo-quickstart</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor354"/>Applying security updates and patch compliance monitoring</h2>
			<p>During my work as Premier Field Engineer at Microsoft, I performed a lot of security assessments for<a id="_idIndexMarker2084"/> companies and organizations of all sizes, all around the world. One of the most critical, but also most common, findings in<a id="_idIndexMarker2085"/> those security assessments was missing updates. Believe it or not, but of all the organizations I assessed, in perhaps 2% of the assessments, I found that all updates were installed. For all other assessments, at least one critical update <span class="No-Break">was missing.</span></p>
			<p>In addition to other attack vectors, such as social engineering and abusing legitimate admin capabilities, missing updates are a common reason for systems being breached: if a security update was released, this means that a vulnerability was fixed and that knowledge about this vulnerability exists publicly. Adversaries can even reverse-engineer the released patch to find out what exactly <span class="No-Break">was fixed.</span></p>
			<p>This means that as soon as an update is released, it is only a race against time before adversaries will have an exploit ready. And if a system is missing a patch, it will be vulnerable in <span class="No-Break">no time.</span></p>
			<p>So, apply security updates as soon as possible. Establish a plan to test and install your updates as soon as possible after a release and prioritize <span class="No-Break">this properly.</span></p>
			<p>It is not enough to just install updates – you also need to verify whether all needed updates are <span class="No-Break">installed regularly.</span></p>
			<p class="callout-heading">Checking for updates</p>
			<p class="callout">Many organizations use WSUS and/or SCCM to deploy and monitor security updates. Although it’s a great method to deploy them, it is not enough for checking that all required updates were installed. Therefore, if you have only relied on WSUS or SSCM so far, you need to set up another mechanism to check whether all the relevant updates have <span class="No-Break">been installed.</span></p>
			<p>Often, organizations only deploy Windows Security updates and forget about other products. But there are so many tools that are installed on servers worldwide that come with Microsoft Visual C++ or other programs. Once installed, they are never updated, even though critical vulnerabilities exist, which leaves a hole in the infrastructure for adversaries <span class="No-Break">to exploit.</span></p>
			<p>For earlier Windows versions, checking<a id="_idIndexMarker2086"/> whether all relevant updates were installed could be achieved by using <strong class="bold">Microsoft Baseline Security Analyzer</strong> (<strong class="bold">MBSA</strong>) and the <strong class="bold">WSUS offline catalog</strong> known as <strong class="source-inline">wsusscn2.cab</strong>. But since MBSA got deprecated and is no longer developed, there are <a id="_idIndexMarker2087"/>new ways to scan for <span class="No-Break">patch compliance.</span></p>
			<p>One option is to use the PowerShell <strong class="source-inline">Scan-UpdatesOffline.ps1</strong> script, which is available in PowerShell <span class="No-Break">Gallery: </span><a href="https://www.powershellgallery.com/packages/Scan-UpdatesOffline/1.0"><span class="No-Break">https://www.powershellgallery.com/packages/Scan-UpdatesOffline/1.0.</span></a></p>
			<p>You can install the <a id="_idIndexMarker2088"/>script <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Install-Script</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Install-Script -Name Scan-UpdatesOffline</pre>
			<p>Before running the script, download the latest <strong class="source-inline">wsusscn2.cab</strong> file from <a href="http://go.microsoft.com/fwlink/?linkid=74689">http://go.microsoft.com/fwlink/?linkid=74689</a> and save it <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">C:\temp\wsusscn2.cab</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&gt; Invoke-WebRequest http://go.microsoft.com/fwlink/?linkid=74689 -OutFile c:\temp\wsusscn2.cab</pre>
			<p>It is important to note that this specific path is hardcoded into the <strong class="source-inline">Scan-UpdatesOffline</strong> script, so make sure that the <strong class="source-inline">wsusscn2.cab</strong> file is in the right location before running <span class="No-Break">this script.</span></p>
			<p>Once everything is in place, you can start the scan using <strong class="source-inline">Scan-UpdatesOffline.ps1</strong>, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer281">
					<img alt="Figure 13.10 – Scanning for missing updates" src="image/B16679_13_010.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – Scanning for missing updates</p>
			<p>Now, you can use this<a id="_idIndexMarker2089"/> script to create<a id="_idIndexMarker2090"/> regular checks to ensure the latest updates are installed on your servers and clients. Make sure you always download the latest <strong class="source-inline">wsusscn2.cab</strong> file <span class="No-Break">before scanning.</span></p>
			<p>Since you can only use this method to check for Windows and Microsoft product updates, make sure you also keep an inventory of all available software in your organization and monitor <span class="No-Break">patch compliance.</span></p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor355"/>Avoiding lateral movement</h2>
			<p>Lateral movement is<a id="_idIndexMarker2091"/> a technique that attackers use to dive deeper into a network to compromise endpoints, servers, <span class="No-Break">and identities.</span></p>
			<p>Once an adversary has managed to compromise a device within an organization, they try to gather more credentials and identities to use them to move laterally and compromise the <span class="No-Break">entire network.</span></p>
			<p>To detect lateral movement, organizations can use PowerShell to monitor remote logon event logs, specifically event ID <em class="italic">4624</em>. This event ID provides information on successful logons, including the logon’s type, process, and authentication package. For example, to get all events with event ID <em class="italic">4624</em> that have a logon type of 3 (network logon) from the last 7 days, you can use the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
&gt; Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624; StartTime=(Get-Date).AddDays(-7)} | Where-Object {$_.Properties[8].Value -eq 3}</pre>
			<p>Logon type 3 indicates that<a id="_idIndexMarker2092"/> the logon attempt was made over the network. This can happen, for example, when a user connects to a network share or when a process running on one computer accesses resources on <span class="No-Break">another computer.</span></p>
			<p>By monitoring logon-type-3 events, organizations can detect attempts by an attacker to access network resources from a compromised system, which can be an early sign of lateral movement within the network. Depending on your network, it makes sense to fine-grain this example and adjust it to <span class="No-Break">your needs.</span></p>
			<p>Please refer to <a href="B16679_04_Final_PD.xhtml#_idTextAnchor090"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Detection – Auditing and Monitoring</em>, to learn more about how to leverage the different event logs for detecting <span class="No-Break">malicious activities.</span></p>
			<p>You should abide by the following guidelines to avoid lateral movement as much <span class="No-Break">as possible:</span></p>
			<ul>
				<li>Enforce unique passwords <a id="_idIndexMarker2093"/>for workstations and servers by using <strong class="bold">Local Administrator Password </strong><span class="No-Break"><strong class="bold">Solution</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">LAPS</strong></span><span class="No-Break">)</span></li>
				<li>Implement a <strong class="bold">Red Forest</strong> for <a id="_idIndexMarker2094"/>Active Directory administrators, also called <strong class="bold">Enhanced Security Administrative </strong><span class="No-Break"><strong class="bold">Environment (ESAE)</strong></span></li>
				<li>Implement a tiering model and have your <a id="_idIndexMarker2095"/>administrators use <strong class="bold">Privileged Access Workstations</strong> (<strong class="bold">PAWs</strong>) for their <span class="No-Break">administrative tasks</span></li>
				<li>Restrict logins and maintain proper <span class="No-Break">credential hygiene</span></li>
				<li>Have updates installed as soon <span class="No-Break">as possible</span></li>
				<li>Audit your identity relations by using tools such as BloodHound <span class="No-Break">or SharpHound</span></li>
			</ul>
			<p>Of course, this is not a 100% guarantee that attackers will not be able to move laterally, but it already covers<a id="_idIndexMarker2096"/> a lot and will keep attackers busy for <span class="No-Break">some time.</span></p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor356"/>Multi-factor authentication for elevation</h2>
			<p><strong class="bold">Multi-Factor Authentication</strong> (<strong class="bold">MFA</strong>) always adds<a id="_idIndexMarker2097"/> another layer of security to your administrative accounts. Of <a id="_idIndexMarker2098"/>course, people can be tricked into allowing authentication, but with MFA, it is so much harder for adversaries to steal and <span class="No-Break">abuse identities.</span></p>
			<p>There are many options that you can use for MFA. Depending on your scenario, you can leverage <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Smartcard authentication</span></li>
				<li><span class="No-Break">Windows Hello</span></li>
				<li>OAuth <span class="No-Break">hardware tokens</span></li>
				<li>OAuth <span class="No-Break">software tokens</span></li>
				<li>Fido2 <span class="No-Break">security keys</span></li>
				<li><span class="No-Break">Biometrics</span></li>
				<li>SMS or <span class="No-Break">voice calls</span></li>
				<li>An authenticator application (for example, <span class="No-Break">Microsoft Authenticator)</span></li>
			</ul>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor357"/>Time-bound privileges (Just-in-Time administration)</h2>
			<p>A great option<a id="_idIndexMarker2099"/> for following the principles of least privilege is to implement time-bound privileges, also <a id="_idIndexMarker2100"/>known as <strong class="bold">Just-in-Time administration</strong>. Using this approach, no administrators have any rights <span class="No-Break">by default.</span></p>
			<p>Once they request privilege elevation, a timestamp is bound to their privileges. Once the specified time has run out, the privileges don’t apply <span class="No-Break">any longer.</span></p>
			<p>If an account is compromised, the adversary can’t do any harm since the rights of the account were not requested by the administrator. Usually, the elevation request comes <span class="No-Break">with MFA.</span></p>
			<p>Moreover, <strong class="bold">privileged identity management</strong> (<strong class="bold">PIM</strong>) and <strong class="bold">privileged access management</strong> (<strong class="bold">PAM</strong>) solutions can<a id="_idIndexMarker2101"/> be used to automate the process <a id="_idIndexMarker2102"/>of granting and revoking time-bound privileges. These solutions provide a centralized platform for managing and monitoring <a id="_idIndexMarker2103"/>privileged access across <span class="No-Break">an organization.</span></p>
			<p>They can also offer additional security measures, such as approval workflows, audit trails, and session recordings to ensure accountability and compliance. Implementing PIM and PAM solutions can greatly enhance the security of time-bound privileges and reduce the risk of unauthorized access to critical systems <span class="No-Break">and data.</span></p>
			<h1 id="_idParaDest-343"><a id="_idTextAnchor358"/>Attack detection – Endpoint Detection and Response</h1>
			<p>Another really important point is to have a product in place to detect attacks and react to them. There are many great products out there that can help you with this task. Make sure that the <a id="_idIndexMarker2104"/>product of your choice also supports PowerShell and helps you detect suspicious commands that were launched via PowerShell and other <span class="No-Break">command-line tools.</span></p>
			<p>Microsoft’s solution, for example, is called Microsoft Defender for Endpoint. But other vendors provide <span class="No-Break">similar solutions.</span></p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor359"/>Enabling free features from Microsoft Defender for Endpoint</h2>
			<p>Even if you do not use Microsoft Defender<a id="_idIndexMarker2105"/> for Endpoint, various features are free to use without <span class="No-Break">any subscription:</span></p>
			<ul>
				<li>Hardware-based<a id="_idIndexMarker2106"/> <span class="No-Break">isolation/Application Guard</span></li>
				<li>Attack surface <span class="No-Break">reduction rules</span></li>
				<li>Controlled <span class="No-Break">folder access</span></li>
				<li>Removable <span class="No-Break">storage protection</span></li>
				<li><span class="No-Break">Network protection</span></li>
				<li><span class="No-Break">Exploit Guard</span></li>
				<li>Windows Defender Firewall with <span class="No-Break">advanced security</span></li>
			</ul>
			<p>Many of these features <a id="_idIndexMarker2107"/>can even be used while Microsoft Defender is disabled. Check out the ASR capabilities to learn more about these <span class="No-Break">features: </span><a href="https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/overview-attack-surface-reduction?view=o365-worldwide#configure-attack-surface-reduction-capabilities"><span class="No-Break">https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/overview-attack-surface-reduction?view=o365-worldwide#configure-attack-surface-reduction-capabilities</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor360"/>Summary</h1>
			<p>This chapter sums up this book on PowerShell security. It was not meant to provide deep technical information, but rather an outlook of what else can be done to improve the security of your network. With this, you have a good overview of what to do next and what to <span class="No-Break">look up.</span></p>
			<p>You got some insights into secure scripting and what tools you can use to improve your scripting security. You also learned what DSC is and how to get started. And last but not least, you also got insights into hardening <span class="No-Break">your systems.</span></p>
			<p>I hope you enjoyed this book and could make the most of it. <span class="No-Break">Happy scripting!</span></p>
			<h1 id="_idParaDest-346"><a id="_idTextAnchor361"/>Further reading</h1>
			<p>If you want to explore some of the topics that were mentioned in this chapter, take a look at <span class="No-Break">these resources:</span></p>
			<p><span class="No-Break"><strong class="bold">LAPS</strong></span></p>
			<ul>
				<li><span class="No-Break">LAPS: </span><a href="https://www.microsoft.com/en-us/download/details.aspx?id=46899"><span class="No-Break">https://www.microsoft.com/en-us/download/details.aspx?id=46899</span></a><a href="https://www.microsoft.com/en-us/download/details.aspx?id=46899&#13;"/></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">PSScriptAnalyzer</strong></span></p>
			<ul>
				<li>PSScriptAnalyzer on <span class="No-Break">GitHub: </span><a href="https://github.com/PowerShell/PSScriptAnalyzer"><span class="No-Break">https://github.com/PowerShell/PSScriptAnalyzer</span></a><a href="https://github.com/PowerShell/PSScriptAnalyzer&#13;"/></li>
				<li>PSScriptAnalyzer <span class="No-Break">reference: </span><a href="https://learn.microsoft.com/en-us/powershell/module/psscriptanalyzer/?view=ps-modules&#13;"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/module/psscriptanalyzer/?view=ps-modules</span></a></li>
				<li>PSScriptAnalyzer module <span class="No-Break">overview: </span><a href="https://learn.microsoft.com/en-us/powershell/utility-modules/psscriptanalyzer/overview?view=ps-modules&#13;"><span class="No-Break">https://learn.microsoft.com/en-us/powershell/utility-modules/psscriptanalyzer/overview?view=ps-modules</span></a></li>
			</ul>
			<p><strong class="bold">Security baselines </strong><span class="No-Break"><strong class="bold">and SCT</strong></span></p>
			<ul>
				<li>Microsoft SCT 1.0 – How to use <span class="No-Break">it: </span><a href="https://learn.microsoft.com/en-us/windows/security/operating-system-security/device-management/windows-security-configuration-framework/security-compliance-toolkit-10"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/operating-system-security/device-management/windows-security-configuration-framework/security-compliance-toolkit-10</span></a><a href="https://learn.microsoft.com/en-us/windows/security/threat-protection/windows-security-configuration-framework/security-compliance-toolkit-10&#13;"/></li>
				<li><strong class="source-inline">LGPO.exe</strong> – Local Group Policy Object Utility, <span class="No-Break">v1.0: </span><a href="https://techcommunity.microsoft.com/t5/microsoft-security-baselines/lgpo-exe-local-group-policy-object-utility-v1-0/ba-p/701045"><span class="No-Break">https://techcommunity.microsoft.com/t5/microsoft-security-baselines/lgpo-exe-local-group-policy-object-utility-v1-0/ba-p/701045</span></a><a href="https://techcommunity.microsoft.com/t5/microsoft-security-baselines/lgpo-exe-local-group-policy-object-utility-v1-0/ba-p/701045&#13;"/></li>
				<li>New and Updated Security <span class="No-Break">Tools: </span><a href="https://techcommunity.microsoft.com/t5/microsoft-security-baselines/new-amp-updated-security-tools/ba-p/1631613"><span class="No-Break">https://techcommunity.microsoft.com/t5/microsoft-security-baselines/new-amp-updated-security-tools/ba-p/1631613</span></a><a href="https://techcommunity.microsoft.com/t5/microsoft-security-baselines/new-amp-updated-security-tools/ba-p/1631613&#13;"/></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Security Updates</strong></span></p>
			<ul>
				<li>A new version of the Windows Update offline scan file, <strong class="source-inline">wsusscn2.cab</strong>, is available for advanced <span class="No-Break">users: </span><a href="https://support.microsoft.com/en-us/topic/a-new-version-of-the-windows-update-offline-scan-file-wsusscn2-cab-is-available-for-advanced-users-fe433f4d-44f4-28e3-88c5-5b22329c0a08"><span class="No-Break">https://support.microsoft.com/en-us/topic/a-new-version-of-the-windows-update-offline-scan-file-wsusscn2-cab-is-available-for-advanced-users-fe433f4d-44f4-28e3-88c5-5b22329c0a08</span></a><a href="https://support.microsoft.com/en-us/topic/a-new-version-of-the-windows-update-offline-scan-file-wsusscn2-cab-is-available-for-advanced-users-fe433f4d-44f4-28e3-88c5-5b22329c0a08&#13;"/></li>
				<li>Detailed information for developers who use the Windows Update offline scan file can be found <span class="No-Break">here: </span><a href="https://support.microsoft.com/en-us/topic/detailed-information-for-developers-who-use-the-windows-update-offline-scan-file-51db1d9e-038b-0b15-16e7-149aba45f295"><span class="No-Break">https://support.microsoft.com/en-us/topic/detailed-information-for-developers-who-use-the-windows-update-offline-scan-file-51db1d9e-038b-0b15-16e7-149aba45f295</span></a><a href="https://support.microsoft.com/en-us/topic/detailed-information-for-developers-who-use-the-windows-update-offline-scan-file-51db1d9e-038b-0b15-16e7-149aba45f295&#13;"/></li>
				<li>What is Microsoft Baseline Security Analyzer and its <span class="No-Break">uses?: </span><a href="https://learn.microsoft.com/en-us/windows/security/threat-protection/mbsa-removal-and-guidance"><span class="No-Break">https://learn.microsoft.com/en-us/windows/security/threat-protection/mbsa-removal-and-guidance</span></a><a href="https://learn.microsoft.com/en-us/windows/security/threat-protection/mbsa-removal-and-guidance&#13;"/></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">VBS</strong></span></p>
			<ul>
				<li>Virtualization-based <span class="No-Break">security: </span><a href="https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-vbs"><span class="No-Break">https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-vbs</span></a></li>
			</ul>
			<p>You can also find all the links mentioned in this chapter in the GitHub repository for <a href="B16679_13_Final_PD.xhtml#_idTextAnchor341"><span class="No-Break"><em class="italic">Chapter 13</em></span></a> – there’s no need to manually type in every <span class="No-Break">link: </span><a href="https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter13/Links.md"><span class="No-Break">https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter13/Links.md</span></a><span class="No-Break">.</span></p>
		</div>
	</body></html>