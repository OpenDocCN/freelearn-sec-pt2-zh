- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Else? – Further Mitigations and Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have looked at many topics and techniques that help you mitigate
    risks in your environment when it comes to PowerShell. But of course, there are
    many more things that you can do to secure your environment – many directly related
    to PowerShell, but also others that are not directly related but help you secure
    PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we won’t deep dive into every mitigation; instead, I will
    provide an overview of what other mitigations exist so that you can explore each
    on your own. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Secure scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Desired State Configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardening systems and environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attack detection – Endpoint Detection and Response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make the most out of this chapter, ensure that you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell 7.3 and above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access to the GitHub repository for this chapter: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter13](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/tree/master/Chapter13)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are leveraging self-written scripts in your environment, secure scripting
    is indispensable. If your scripts can be manipulated, it doesn’t matter (most
    of the time) what other security mechanisms you have implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware that your scripts can be hacked, and malicious code can be injected.
    In these cases, you must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Always validate input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have your code reviewed when developing scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure the script’s location and access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adopt a secure coding standard, such as the *OWASP Secure Coding Practices
    – Quick Reference* *Guide*: [https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, two neat PowerShell modules come in handy when developing your
    own PowerShell scripts that you should know about – **PSScriptAnalyzer** and **InjectionHunter**.
  prefs: []
  type: TYPE_NORMAL
- en: PSScriptAnalyzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**PSScriptAnalyzer** is a tool that statically checks code for PowerShell scripts
    and modules. It checks against predefined rules and returns all findings, along
    with recommendations on how to improve your potential code defects.'
  prefs: []
  type: TYPE_NORMAL
- en: Using **PSScriptAnalyzer** to verify your code helps you to maintain higher
    code quality and avoid common issues. It is not necessarily a tool to check the
    security of your code (although it provides security checks such as **Avoid using
    Invoke-Expression**), but a tool to check whether you applied PowerShell best
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: It can be installed from PowerShell Gallery using **Install-Module PSScriptAnalyzer**.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, it provides the **Get-ScriptAnalyzerRule**, **Invoke-Formatter**,
    and **Invoke-ScriptAnalyzer** cmdlets.
  prefs: []
  type: TYPE_NORMAL
- en: For our use case, we will only look into **Invoke-ScriptAnalyzer**, but make
    sure you check out the entire module on your own to improve your PowerShell scripts
    and modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use **Invoke-ScriptAnalyzer**, followed by **-Path** and the path to the script,
    to have your code checked, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Invoking ScriptAnalyzer](image/B16679_13_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Invoking ScriptAnalyzer
  prefs: []
  type: TYPE_NORMAL
- en: When nothing else is specified, **PSScriptAnalyzer** checks against its own
    set of rules. But you can also specify your own custom rules by using the **-CustomRulePath**
    and **-****RecurseCustomRulePath** parameters.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using Visual Studio Code with the *PowerShell* extension to write
    PowerShell scripts, **PSScriptAnalyzer** is enabled by default. Here, your code
    will be automatically checked and you will be provided with warnings for any potential
    issues while writing your code.
  prefs: []
  type: TYPE_NORMAL
- en: InjectionHunter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**InjectionHunter** is a module, written by Lee Holmes, that helps you detect
    ways to inject code into your very own PowerShell script. It can be downloaded
    from **PowerShell** **Gallery**: [https://www.powershellgallery.com/packages/InjectionHunter/1.0.0](https://www.powershellgallery.com/packages/InjectionHunter/1.0.0
    )'
  prefs: []
  type: TYPE_NORMAL
- en: Install it by using **Install-Module InjectionHunter**.
  prefs: []
  type: TYPE_NORMAL
- en: '**InjectionHunter** relies on **ScriptAnalyzer.Generic.DiagnosticRecord** as
    its output type and uses custom detection rules, so **PSScriptAnalyzer** also
    needs to be installed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**InjectionHunter** comes with eight different functions, all of which can
    help you find out whether your code is vulnerable to various scenarios. These
    are **Measure-AddType**, **Measure-CommandInjection**, **Measure-DangerousMethod**,
    **Measure-ForeachObjectInjection**, **Measure-InvokeExpression**, **Measure-MethodInjection**,
    **Measure-PropertyInjection**, and **Measure-UnsafeEscaping**.'
  prefs: []
  type: TYPE_NORMAL
- en: The **InjectionHunter** functions are used to create a new **PSScriptAnalyzer**
    plugin that can detect potential injection attacks in PowerShell scripts. These
    functions are designed to accept **-ScriptBlockAst** as a parameter, which represents
    the **Abstract Syntax Tree** (**AST**) of the script. The AST groups tokens into
    structures and is a deliberate way to parse and analyze data with PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to use **PSScriptAnalyzer** to call
    the **InjectionHunter** rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows what it looks like to call **InjectionHunter**
    rules from **PSScriptAnalyzer**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Calling the InjectionHunter rules from PSScriptAnalyzer](image/B16679_13_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Calling the InjectionHunter rules from PSScriptAnalyzer
  prefs: []
  type: TYPE_NORMAL
- en: '**InjectionHunter** was not intended for direct use in analyzing scripts. However,
    you can use its functions to develop a custom **PSScriptAnalyzer** plugin that
    can detect injection attacks in your PowerShell scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But wouldn’t it be cool to immediately know whether you were implementing a
    potential injection risk while writing your scripts? Lee Holmes and the PowerShell
    team have you covered. The following blog article explains how this can be achieved
    when using Visual Studio Code to edit scripts: [https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/](https://devblogs.microsoft.com/powershell/powershell-injection-hunter-security-auditing-for-powershell-scripts/).'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Desired State Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PowerShell **Desired State Configuration** (**DSC**) is a feature that enables
    you to manage your servers using PowerShell configuration as code.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the following versions of DSC are available that you
    can use for deployment: **DSC 1.1**, **DSC 2.0**, and **DSC 3.0**.'
  prefs: []
  type: TYPE_NORMAL
- en: While DSC 1.1 was included in Windows PowerShell 5.1, in DSC 2.0, which must
    run DSC on PowerShell 7.2 and above, **PSDesiredStateConfiguration** is no longer
    included in the PowerShell package. This enables the DSC creators to develop DSC
    independently of PowerShell and enables users to upgrade DSC without the need
    to upgrade PowerShell as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**DSC 1.1**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DSC 1.1 is included in Windows and updated through Windows Management Framework.
    It runs in Windows PowerShell 5.1\. This is the go-to version if Azure Automanage
    Machine Configuration is not in use.
  prefs: []
  type: TYPE_NORMAL
- en: Remediation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DSC 1.1 has two configuration modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Push**: The configuration is pushed manually'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pull**: The nodes are configured to pull their configuration frequently from
    the pull server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One huge advance of DSC in pull mode is that your configuration, once specified,
    is self-healing. This means you configure your nodes using code and set up your
    configuration. Once activated, you can configure your configuration so that it’s
    frequently pulled from your nodes. This means that if someone were to change the
    local configuration of a server or endpoint configured with DSC, the configuration
    would be changed back after the next pull.
  prefs: []
  type: TYPE_NORMAL
- en: Pull mode is a more complex configuration, but in the end, it is easier to maintain
    and helps you keep your devices more secure than using push mode. When using this
    mode, systems remediate themselves.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in using DSC for central administration, it’s worth noting
    that signed configurations make DSC an even more secure form of remote policy
    management. Signed configurations ensure that only authorized changes are applied
    to a system. Without a valid signature, a configuration cannot be applied.
  prefs: []
  type: TYPE_NORMAL
- en: This can be particularly valuable in protecting against attacks that compromise
    central management channels, such as GPO. With signed configurations in DSC and
    tight control over your signing infrastructure, attackers cannot use compromised
    channels to deliver ransomware company-wide, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the DSC module and configuration signing by visiting
    the following documentation page: [https://learn.microsoft.com/en-us/powershell/scripting/windows-powershell/wmf/whats-new/dsc-improvements?#dsc-module-and-configuration-signing-validations](https://learn.microsoft.com/en-us/powershell/scripting/windows-powershell/wmf/whats-new/dsc-improvements?#dsc-module-and-configuration-signing-validations).'
  prefs: []
  type: TYPE_NORMAL
- en: 'DSC is quite extensive, but there’s a lot of documentation, including quick
    starts and tutorials, that can help you get started: [https://learn.microsoft.com/en-us/powershell/dsc/overview?view=dsc-1.1](https://learn.microsoft.com/en-us/powershell/dsc/overview?view=dsc-1.1).'
  prefs: []
  type: TYPE_NORMAL
- en: '**DSC 2.0**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DSC 2.0 is supported for PowerShell 7.2 and above. While the original DSC platform
    was built on top of WMI for Windows, newer versions were decoupled from that model.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be deployed using PSGallery by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: DSC version 2.0 should only be used if Azure Automanage Machine Configuration
    is in use. Although the **Invoke-DscResource** cmdlet is still available with
    this version, you should only use it for testing purposes and rely on Azure Automanage
    Machine Configuration instead.
  prefs: []
  type: TYPE_NORMAL
- en: Remediation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thanks to Azure Automanage Machine Configuration, you don’t need to set up a
    pull server as you must with DSC 1.1 since Azure Automanage Machine Configuration
    deals with this responsibility for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three different machine configuration assignment types that you can
    choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Audit**: Only report; don’t change anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ApplyAndMonitor**: Apply the configuration once, but if the configuration
    is changed, only report and don’t remediate until it’s triggered manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ApplyAndAutoCorrect**: Apply the configuration permanently. Once a change
    is made, the machine remediates at the next evaluation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ApplyAndAutoCorrect** is a great option that is similar to the pull configuration
    mode in DSC 1.1; it helps your systems become more secure as they remediate changes
    by themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to learn more about DSC 2.0: [https://learn.microsoft.com/en-us/powershell/dsc/overview?view=dsc-2.0](https://learn.microsoft.com/en-us/powershell/dsc/overview?view=dsc-2.0)**.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**DSC 3.0**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DSC 3.0 is a preview release that is still under development as of April 2023.
  prefs: []
  type: TYPE_NORMAL
- en: 'This version supports cross-platform features and is supported by Azure Automanage
    Machine Configuration in Azure Policy. It can be installed with PSGallery by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For DSC 3.0, the remediation options are the same as for DSC 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find out more about DSC 3.0 by reading the official documentation:
    [https://learn.microsoft.com/en-us/powershell/dsc/overview?view=dsc-3.0](https://learn.microsoft.com/en-us/powershell/dsc/overview?view=dsc-3.0).'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started with DSC, you need a DSC configuration, which you can compile
    into a **.mof** file. Often, you will want to cover a scenario that has already
    been predefined as a resource and tweak it to your use case; in this case, you
    also want to include a predefined resource in your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: DSC resources
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating your own DSC resources, always check whether there is already
    a resource that fits your use case; there’s a multitude of existing resources
    that you can find on GitHub or PowerShell Gallery. Once you have found the right
    DSC resource for your use case, you can install it using **PowerShellGet**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**> Install-Module -****Name AuditPolicyDSC**'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the **AuditPolicyDSC** resource would be installed, which helps
    you configure and manage the advanced audit policy on Windows machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a configuration that imports the **AuditPolicyDsc**
    resource and then uses it to ensure that all successful logons are being audited
    on the host, on which this configuration will be applied, via the equivalent advanced
    audit policy setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We must save this code in a file named **AuditLogon.ps1** under **C:\temp\**
    to dot source it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how the file is being compiled into a **.****mof**
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Compiling your DSC configuration into a .mof file](image/B16679_13_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Compiling your DSC configuration into a .mof file
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the setup and the DSC version that you are running, you can now
    use this file to apply your DSC configuration to the system of your choice. Please
    refer to the official documentation for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'DSC 1.1: [https://learn.microsoft.com/en-us/powershell/dsc/configurations/write-compile-apply-configuration?view=dsc-1.1](https://learn.microsoft.com/en-us/powershell/dsc/configurations/write-compile-apply-configuration?view=dsc-1.1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'DSC 2.0: [https://learn.microsoft.com/en-us/powershell/dsc/concepts/configurations?view=dsc-2.0](https://learn.microsoft.com/en-us/powershell/dsc/concepts/configurations?view=dsc-2.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'DSC 3.0: [https://learn.microsoft.com/en-us/powershell/dsc/concepts/configurations?view=dsc-3.0](https://learn.microsoft.com/en-us/powershell/dsc/concepts/configurations?view=dsc-3.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: Hardening systems and environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the end, you can harden PowerShell as much as you like; if the systems on
    which PowerShell is running are not protected, adversaries will make use of that
    if they have the chance. Therefore, it is important to also look at how you can
    harden the security of your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Security baselines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A great start to hardening your Windows systems – regardless of the server,
    domain controller, or client – are the so-called security baselines provided by
    Microsoft. These security baselines are part of Microsoft’s **Security Compliance
    Toolkit** (**SCT**) 1.0, which can be downloaded from here: https://www.microsoft.com/en-us/download/details.aspx?id=55319.'
  prefs: []
  type: TYPE_NORMAL
- en: Please be careful when applying security baselines!
  prefs: []
  type: TYPE_NORMAL
- en: You should never just apply a security baseline to a running production system.
    Before applying it, carefully audit your settings and evaluate them. Then, work
    on a plan to enroll your changes. Many settings are included that could break
    the functioning of your systems if they are not carefully planned for and enrolled.
  prefs: []
  type: TYPE_NORMAL
- en: When you download SCT, you will see that there are many files within it that
    you can download. Most of the files are the actual baselines (most baseline packages
    end with **Security Baseline.zip**).
  prefs: []
  type: TYPE_NORMAL
- en: But helpful tools are also included, including **LGPO**, **SetObjectSecurity**,
    and **Policy Analyzer**.
  prefs: []
  type: TYPE_NORMAL
- en: '**LGPO**: This tool can be used to perform local Group Policy Object (GPO)
    operations. You can use this tool to import settings into a local Group Policy,
    export a local Group Policy, parse a **registry.pol** file in **LGPO text** format,
    build a **registry.pol** file from **LGPO text**, and enable Group Policy client-side
    extensions for local policy processing. Since it’s a command-line tool, LGPO can
    be used to automate local GPO operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SetObjectSecurity**: Using **SetObjectSecurity**, you can set the security
    descriptor for any type of Windows securable object – be it files, registry hives,
    event logs, and many more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy Analyzer**: Policy Analyzer is a tool for comparing baselines and
    GPOs, but not only exported GPOs – you can also compare a GPO with your local
    policy. It can highlight differences between the policies, as well as help you
    spot redundancies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All three tools are standalone, which means that you don’t need to install them
    to use them.
  prefs: []
  type: TYPE_NORMAL
- en: You can use **PolicyAnalyzer** to check the current state of your machines.
    Download **PolicyAnalyzer** and the security baseline that you want to use to
    check your systems against. In our example, I used the *Windows Server 2022 Security
    Baseline* as my example baseline.
  prefs: []
  type: TYPE_NORMAL
- en: We looked into the **SCT** in [*Chapter 4*](B16679_04_Final_PD.xhtml#_idTextAnchor090),
    *Detection – Auditing and Monitoring*, when we talked about auditing recommendations
    and EventList. There, we learned that security baselines contain auditing recommendations.
    But they also contain some system settings recommendations, such as the Lan Manager
    authentication level (**LmCompatibilityLevel**), which you can use to deny insecure
    authentication mechanisms in your domain. Please be extremely careful and audit
    which authentication protocols are used before applying this setting to the recommended
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can work with baselines, you will need to extract them. The following
    code snippet shows how you can use PowerShell to extract them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While the **$baselineZipPath** variable leads to the path where the baseline
    ZIP file is located, the **$baselineDirPath** variable points to the folder into
    which the baselines should be extracted. If the **$baselineDirPath** folder is
    not available yet, the folder will be created. The archive can be extracted using
    the **Expand-Archive** cmdlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'After extracting a security baseline, you will find the five following folders
    in the ZIP file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Contents of a security baseline](image/B16679_13_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Contents of a security baseline
  prefs: []
  type: TYPE_NORMAL
- en: The actual baselines reside in the **GPOs** folder. You can use the files in
    there to import the baselines for testing purposes on a test system or to add
    them to Policy Analyzer.
  prefs: []
  type: TYPE_NORMAL
- en: 'When initially executing Policy Analyzer, you will see its starting interface,
    which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Policy Analyzer](image/B16679_13_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – Policy Analyzer
  prefs: []
  type: TYPE_NORMAL
- en: To get started, click on **Add …** to add a new baseline to compare. Navigate
    to the GPOs folder within the selected baseline and select it. Since many baseline
    files are included that you won’t want to add, you need to remove all the unnecessary
    ones by selecting them in the **Policy File Importer** view and removing them
    by using the *Delete* key on your keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, I want to investigate a domain controller, so I deleted every
    other baseline except for the domain controller ones, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Importing domain controller security baselines](image/B16679_13_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.6 – Importing domain controller security baselines
  prefs: []
  type: TYPE_NORMAL
- en: Once all the necessary baselines are in the **Policy File Importer** view, click
    on **Import...** to import them. Before they are imported, you will be prompted
    to enter a name and save the policy. In this example, I have called the policy
    **2022_DC**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the baselines have been imported, you can either add another baseline
    or exported GPO to compare their settings (using **View / Compare**). Alternatively,
    you can also compare a baseline with the effective state of the current system
    (using **Compare to** **Effective State**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – The imported 2022_DC policy within Policy Analyzer](image/B16679_13_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.7 – The imported 2022_DC policy within Policy Analyzer
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, I have selected the **2022_DC** policy and compared the **DC01**
    demo environment’s domain controller with the effective state. A new window will
    appear so that you can investigate all the recommended and effective settings:
    if a setting remains white, then it matches, while if a setting is marked in gray,
    it’s not been configured or has been left empty. Finally, if a setting is marked
    in yellow, that means that there’s a conflict and there’s a setting mismatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – Comparing settings with Policy Analyzer](image/B16679_13_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.8 – Comparing settings with Policy Analyzer
  prefs: []
  type: TYPE_NORMAL
- en: By doing this, you can check whether the recommendation reflects the current
    state of your configuration and what you need to configure if it doesn’t match
    yet. Again – please do not just apply the recommendations without evaluating what
    these changes mean for your environment.
  prefs: []
  type: TYPE_NORMAL
- en: There are not only security baselines for domain controllers but also for member
    servers and clients, as well as for settings for other areas.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to use PowerShell to interact with those baselines. Every
    baseline is an exported GPO that you can parse. The **gpreport.xml** file contains
    every setting that was configured in this GPO. So, if we import the **gpreport.xml**
    file of a security baseline as a PowerShell object, we can query all the settings
    available while referring to the XML syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following **Import-Baseline** function helps you with this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It looks for the first **gpreport.xml** file in the specified folder recursively
    and returns its settings as an XML object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to access the recommended audit settings of the *Windows
    10 22H2 – Computer,* baseline, we would first import it into the **$Baseline**
    variable, as shown in this code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all XML nodes are available and can be queried using the **$Baseline**
    variable. First, let’s check the name of the baseline to make sure that we imported
    the right one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to access the audit settings, which are located under the **Computer.ExtensionData.Extension.AuditSetting**
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, you can see every recommended audit setting
    and its value – that is, the output of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – Querying the audit setting XML nodes of the baseline](image/B16679_13_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.9 – Querying the audit setting XML nodes of the baseline
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see **SettingValue**, which indicates whether it is recommended
    to audit for **Success** (**1**), **Failure** (**2**), or for both **Success and
    Failure** (**3**). **0** would indicate that there it is explicitly not recommended
    to audit this setting (that is, *audit setting disabled*) – a value that you will
    never find in the security baselines distributed by Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: With this, you can now query all imported XML nodes that were configured in
    this GPO.
  prefs: []
  type: TYPE_NORMAL
- en: Another great tool that can help you monitor your security settings for compliance
    using **DSC** is the **BaselineManagement** module. With its help, you can convert
    baselines as well as Group Policies into DSC configuration scripts (**.ps1**)
    and **.mof** files, which you can use to monitor the compliance of your systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information on how to set this up in the GPO DSC quick start
    documentation: [https://learn.microsoft.com/en-us/powershell/dsc/quickstarts/gpo-quickstart](https://learn.microsoft.com/en-us/powershell/dsc/quickstarts/gpo-quickstart).'
  prefs: []
  type: TYPE_NORMAL
- en: Applying security updates and patch compliance monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During my work as Premier Field Engineer at Microsoft, I performed a lot of
    security assessments for companies and organizations of all sizes, all around
    the world. One of the most critical, but also most common, findings in those security
    assessments was missing updates. Believe it or not, but of all the organizations
    I assessed, in perhaps 2% of the assessments, I found that all updates were installed.
    For all other assessments, at least one critical update was missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to other attack vectors, such as social engineering and abusing
    legitimate admin capabilities, missing updates are a common reason for systems
    being breached: if a security update was released, this means that a vulnerability
    was fixed and that knowledge about this vulnerability exists publicly. Adversaries
    can even reverse-engineer the released patch to find out what exactly was fixed.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that as soon as an update is released, it is only a race against
    time before adversaries will have an exploit ready. And if a system is missing
    a patch, it will be vulnerable in no time.
  prefs: []
  type: TYPE_NORMAL
- en: So, apply security updates as soon as possible. Establish a plan to test and
    install your updates as soon as possible after a release and prioritize this properly.
  prefs: []
  type: TYPE_NORMAL
- en: It is not enough to just install updates – you also need to verify whether all
    needed updates are installed regularly.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for updates
  prefs: []
  type: TYPE_NORMAL
- en: Many organizations use WSUS and/or SCCM to deploy and monitor security updates.
    Although it’s a great method to deploy them, it is not enough for checking that
    all required updates were installed. Therefore, if you have only relied on WSUS
    or SSCM so far, you need to set up another mechanism to check whether all the
    relevant updates have been installed.
  prefs: []
  type: TYPE_NORMAL
- en: Often, organizations only deploy Windows Security updates and forget about other
    products. But there are so many tools that are installed on servers worldwide
    that come with Microsoft Visual C++ or other programs. Once installed, they are
    never updated, even though critical vulnerabilities exist, which leaves a hole
    in the infrastructure for adversaries to exploit.
  prefs: []
  type: TYPE_NORMAL
- en: For earlier Windows versions, checking whether all relevant updates were installed
    could be achieved by using **Microsoft Baseline Security Analyzer** (**MBSA**)
    and the **WSUS offline catalog** known as **wsusscn2.cab**. But since MBSA got
    deprecated and is no longer developed, there are new ways to scan for patch compliance.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is to use the PowerShell **Scan-UpdatesOffline.ps1** script, which
    is available in PowerShell Gallery: [https://www.powershellgallery.com/packages/Scan-UpdatesOffline/1.0.](https://www.powershellgallery.com/packages/Scan-UpdatesOffline/1.0)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install the script using **Install-Script**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running the script, download the latest **wsusscn2.cab** file from [http://go.microsoft.com/fwlink/?linkid=74689](http://go.microsoft.com/fwlink/?linkid=74689)
    and save it under **C:\temp\wsusscn2.cab**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that this specific path is hardcoded into the **Scan-UpdatesOffline**
    script, so make sure that the **wsusscn2.cab** file is in the right location before
    running this script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once everything is in place, you can start the scan using **Scan-UpdatesOffline.ps1**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Scanning for missing updates](image/B16679_13_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.10 – Scanning for missing updates
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can use this script to create regular checks to ensure the latest updates
    are installed on your servers and clients. Make sure you always download the latest
    **wsusscn2.cab** file before scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Since you can only use this method to check for Windows and Microsoft product
    updates, make sure you also keep an inventory of all available software in your
    organization and monitor patch compliance.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding lateral movement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lateral movement is a technique that attackers use to dive deeper into a network
    to compromise endpoints, servers, and identities.
  prefs: []
  type: TYPE_NORMAL
- en: Once an adversary has managed to compromise a device within an organization,
    they try to gather more credentials and identities to use them to move laterally
    and compromise the entire network.
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect lateral movement, organizations can use PowerShell to monitor remote
    logon event logs, specifically event ID *4624*. This event ID provides information
    on successful logons, including the logon’s type, process, and authentication
    package. For example, to get all events with event ID *4624* that have a logon
    type of 3 (network logon) from the last 7 days, you can use the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Logon type 3 indicates that the logon attempt was made over the network. This
    can happen, for example, when a user connects to a network share or when a process
    running on one computer accesses resources on another computer.
  prefs: []
  type: TYPE_NORMAL
- en: By monitoring logon-type-3 events, organizations can detect attempts by an attacker
    to access network resources from a compromised system, which can be an early sign
    of lateral movement within the network. Depending on your network, it makes sense
    to fine-grain this example and adjust it to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [*Chapter 4*](B16679_04_Final_PD.xhtml#_idTextAnchor090), *Detection
    – Auditing and Monitoring*, to learn more about how to leverage the different
    event logs for detecting malicious activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should abide by the following guidelines to avoid lateral movement as much
    as possible:'
  prefs: []
  type: TYPE_NORMAL
- en: Enforce unique passwords for workstations and servers by using **Local Administrator
    Password** **Solution** (**LAPS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a **Red Forest** for Active Directory administrators, also called
    **Enhanced Security Administrative** **Environment (ESAE)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a tiering model and have your administrators use **Privileged Access
    Workstations** (**PAWs**) for their administrative tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict logins and maintain proper credential hygiene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have updates installed as soon as possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audit your identity relations by using tools such as BloodHound or SharpHound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, this is not a 100% guarantee that attackers will not be able to move
    laterally, but it already covers a lot and will keep attackers busy for some time.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-factor authentication for elevation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Multi-Factor Authentication** (**MFA**) always adds another layer of security
    to your administrative accounts. Of course, people can be tricked into allowing
    authentication, but with MFA, it is so much harder for adversaries to steal and
    abuse identities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many options that you can use for MFA. Depending on your scenario,
    you can leverage the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Smartcard authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Hello
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth hardware tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth software tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fido2 security keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Biometrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS or voice calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An authenticator application (for example, Microsoft Authenticator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time-bound privileges (Just-in-Time administration)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great option for following the principles of least privilege is to implement
    time-bound privileges, also known as **Just-in-Time administration**. Using this
    approach, no administrators have any rights by default.
  prefs: []
  type: TYPE_NORMAL
- en: Once they request privilege elevation, a timestamp is bound to their privileges.
    Once the specified time has run out, the privileges don’t apply any longer.
  prefs: []
  type: TYPE_NORMAL
- en: If an account is compromised, the adversary can’t do any harm since the rights
    of the account were not requested by the administrator. Usually, the elevation
    request comes with MFA.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, **privileged identity management** (**PIM**) and **privileged access
    management** (**PAM**) solutions can be used to automate the process of granting
    and revoking time-bound privileges. These solutions provide a centralized platform
    for managing and monitoring privileged access across an organization.
  prefs: []
  type: TYPE_NORMAL
- en: They can also offer additional security measures, such as approval workflows,
    audit trails, and session recordings to ensure accountability and compliance.
    Implementing PIM and PAM solutions can greatly enhance the security of time-bound
    privileges and reduce the risk of unauthorized access to critical systems and
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Attack detection – Endpoint Detection and Response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another really important point is to have a product in place to detect attacks
    and react to them. There are many great products out there that can help you with
    this task. Make sure that the product of your choice also supports PowerShell
    and helps you detect suspicious commands that were launched via PowerShell and
    other command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft’s solution, for example, is called Microsoft Defender for Endpoint.
    But other vendors provide similar solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling free features from Microsoft Defender for Endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Even if you do not use Microsoft Defender for Endpoint, various features are
    free to use without any subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware-based isolation/Application Guard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attack surface reduction rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlled folder access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removable storage protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploit Guard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows Defender Firewall with advanced security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many of these features can even be used while Microsoft Defender is disabled.
    Check out the ASR capabilities to learn more about these features: [https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/overview-attack-surface-reduction?view=o365-worldwide#configure-attack-surface-reduction-capabilities](https://learn.microsoft.com/en-us/microsoft-365/security/defender-endpoint/overview-attack-surface-reduction?view=o365-worldwide#configure-attack-surface-reduction-capabilities).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter sums up this book on PowerShell security. It was not meant to provide
    deep technical information, but rather an outlook of what else can be done to
    improve the security of your network. With this, you have a good overview of what
    to do next and what to look up.
  prefs: []
  type: TYPE_NORMAL
- en: You got some insights into secure scripting and what tools you can use to improve
    your scripting security. You also learned what DSC is and how to get started.
    And last but not least, you also got insights into hardening your systems.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed this book and could make the most of it. Happy scripting!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to explore some of the topics that were mentioned in this chapter,
    take a look at these resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LAPS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'LAPS: [https://www.microsoft.com/en-us/download/details.aspx?id=46899](https://www.microsoft.com/en-us/download/details.aspx?id=46899)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PSScriptAnalyzer**'
  prefs: []
  type: TYPE_NORMAL
- en: 'PSScriptAnalyzer on GitHub: [https://github.com/PowerShell/PSScriptAnalyzer](https://github.com/PowerShell/PSScriptAnalyzer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PSScriptAnalyzer reference: [https://learn.microsoft.com/en-us/powershell/module/psscriptanalyzer/?view=ps-modules](https://learn.microsoft.com/en-us/powershell/module/psscriptanalyzer/?view=ps-modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'PSScriptAnalyzer module overview: [https://learn.microsoft.com/en-us/powershell/utility-modules/psscriptanalyzer/overview?view=ps-modules](https://learn.microsoft.com/en-us/powershell/utility-modules/psscriptanalyzer/overview?view=ps-modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**Security baselines** **and SCT**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft SCT 1.0 – How to use it: [https://learn.microsoft.com/en-us/windows/security/operating-system-security/device-management/windows-security-configuration-framework/security-compliance-toolkit-10](https://learn.microsoft.com/en-us/windows/security/operating-system-security/device-management/windows-security-configuration-framework/security-compliance-toolkit-10)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LGPO.exe** – Local Group Policy Object Utility, v1.0: [https://techcommunity.microsoft.com/t5/microsoft-security-baselines/lgpo-exe-local-group-policy-object-utility-v1-0/ba-p/701045](https://techcommunity.microsoft.com/t5/microsoft-security-baselines/lgpo-exe-local-group-policy-object-utility-v1-0/ba-p/701045)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New and Updated Security Tools: [https://techcommunity.microsoft.com/t5/microsoft-security-baselines/new-amp-updated-security-tools/ba-p/1631613](https://techcommunity.microsoft.com/t5/microsoft-security-baselines/new-amp-updated-security-tools/ba-p/1631613)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security Updates**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new version of the Windows Update offline scan file, **wsusscn2.cab**, is
    available for advanced users: [https://support.microsoft.com/en-us/topic/a-new-version-of-the-windows-update-offline-scan-file-wsusscn2-cab-is-available-for-advanced-users-fe433f4d-44f4-28e3-88c5-5b22329c0a08](https://support.microsoft.com/en-us/topic/a-new-version-of-the-windows-update-offline-scan-file-wsusscn2-cab-is-available-for-advanced-users-fe433f4d-44f4-28e3-88c5-5b22329c0a08)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detailed information for developers who use the Windows Update offline scan
    file can be found here: [https://support.microsoft.com/en-us/topic/detailed-information-for-developers-who-use-the-windows-update-offline-scan-file-51db1d9e-038b-0b15-16e7-149aba45f295](https://support.microsoft.com/en-us/topic/detailed-information-for-developers-who-use-the-windows-update-offline-scan-file-51db1d9e-038b-0b15-16e7-149aba45f295)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is Microsoft Baseline Security Analyzer and its uses?: [https://learn.microsoft.com/en-us/windows/security/threat-protection/mbsa-removal-and-guidance](https://learn.microsoft.com/en-us/windows/security/threat-protection/mbsa-removal-and-guidance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VBS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtualization-based security: [https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-vbs](https://learn.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-vbs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also find all the links mentioned in this chapter in the GitHub repository
    for [*Chapter 13*](B16679_13_Final_PD.xhtml#_idTextAnchor341) – there’s no need
    to manually type in every link: [https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter13/Links.md](https://github.com/PacktPublishing/PowerShell-Automation-and-Scripting-for-Cybersecurity/blob/master/Chapter13/Links.md).'
  prefs: []
  type: TYPE_NORMAL
