<html><head></head><body>
		<div id="_idContainer075">
			<h1 id="_idParaDest-99"><em class="italic"><a id="_idTextAnchor103"/>Chapter 4</em>: Network Scanning</h1>
			<p>This chapter deals with the first phase of ethical hacking: information gathering and reconnaissance. Information gathering is one of the most important aspects of ethical hacking. Without having proper access to the required information, it is extremely hard to carry out a successful attack. We will learn what network scanning is and how it can be used to carry out attacks in a network. We will go through the following topics in this chapter:</p>
			<ul>
				<li>Introduction to networking</li>
				<li>Data encapsulation in TCP/IP</li>
				<li>Introduction to Scapy</li>
				<li>Introduction to ARP</li>
				<li>Network scanner using Scapy based on ARP</li>
			</ul>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor104"/>Introduction to networking</h1>
			<p>In <a href="B14788_03_Final_JC_ePub.xhtml#_idTextAnchor070"><em class="italic">Chapter 3</em></a>, <em class="italic">Reconnaissance and Information Gathering</em>, we learned about the basics of <a id="_idIndexMarker229"/>networking from a very high perspective. We learned about the different components and devices present in a network and what the role of each component is. In this section, we will learn a bit more about the actual packets and data that are delivered over a network. </p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor105"/>Data representation in digital systems</h2>
			<p>Let's first <a id="_idIndexMarker230"/>understand how your<a id="_idIndexMarker231"/> computer system manages to transmit data over a network. Every part of data in a computer system is<a id="_idIndexMarker232"/> defined by <strong class="bold">binary logic levels</strong>. These levels are defined as <em class="italic">low</em> or <em class="italic">high</em>. Every image, file, video, voice recording, or anything else that is stored in a modern-day computing system is represented by these logic levels. In physical hardware, these levels are mapped to either voltage levels or switch statuses. For example, a voltage of 5 V in a digital system might represent high logic and a voltage of 0 V will represent low logic. You might be wondering how these different types of data are represented by logic levels. Let's see how that works. Let's say you want to send the message <strong class="source-inline">Hello</strong> to a friend. For the sake of simplicity, let's consider that your friend is present in the same network. For now, we will assume that the underlying communication works. Now, in order to send this <strong class="source-inline">Hello</strong> message, we need to convert this message into a form that is understandable by the computers. We just learned that computers only understand the low and high logic levels, so we will have to <em class="italic">encode</em> our message into these logic<a id="_idIndexMarker233"/> levels. Now, as we can see, <strong class="source-inline">Hello</strong> contains five letters and we only have two <a id="_idIndexMarker234"/>logic levels, so it is not possible to encode the complete message with just one <em class="italic">instance</em> of just two levels. This<a id="_idIndexMarker235"/> instance is called a <strong class="bold">bit</strong>. In order to achieve this encoding, a system was <a id="_idIndexMarker236"/>developed called <strong class="bold">American Standard Code for Information Interchange </strong>(<strong class="bold">ASCII</strong>). Using this coding scheme, we can represent English letters easily along with a few other symbols and letters. Every single letter of the English alphabet is represented by a sequence of 8 bits called a <em class="italic">byte</em>. To represent the letter <strong class="source-inline">H</strong> of our <strong class="source-inline">Hello</strong> message, we can encode it as the following sequence of bits. <strong class="source-inline">H</strong> is <strong class="source-inline">01001000</strong> in ASCII format. This value is predefined in an ASCII code table; similarly, other characters are also defined in the same format:</p>
			<ul>
				<li><strong class="source-inline">H</strong> = <strong class="source-inline">01001000</strong></li>
				<li><strong class="source-inline">e</strong> = <strong class="source-inline">01000101</strong></li>
				<li><strong class="source-inline">l</strong> = <strong class="source-inline">01101100</strong></li>
				<li><strong class="source-inline">l</strong> = <strong class="source-inline">01101100</strong></li>
				<li><strong class="source-inline">o</strong> = <strong class="source-inline">01101111</strong></li>
			</ul>
			<p>Now we have a stream of data that can we send using any digital system. Note that this is a very simplified explanation of data representation. Real systems also use other<a id="_idIndexMarker237"/> encodings, such <a id="_idIndexMarker238"/>as Unicode and byte representation, to send complex data. </p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor106"/>Data encapsulation</h2>
			<p>Now that<a id="_idIndexMarker239"/> we understand the data representation, let's <a id="_idIndexMarker240"/>turn our focus back to our original topic on how to send this data. We've already learned about different layers in a TCP/IP stack and how they are used to send data. In the preceding section, we said that we want to send a <strong class="source-inline">Hello</strong> message to someone in our local network. Let's call this message our <em class="italic">data</em>:</p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B14788_04_01.jpg" alt="Figure 4.1 – Data representation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"><a id="_idTextAnchor107"/>Figure 4.1 – Data representation</p>
			<p>Now, in order for it to successfully reach the other computer, the packet must know its exact destination, similar to how a postal delivery system works. You have a country, city, postal code, street, and house number. In digital systems, you have IP addresses, MAC addresses, and source and destination ports. Let's say you write your message in your browser application and your friend is also waiting for your message in their browser. In order to successfully send the message to the exact same <em class="italic">process</em> in the destination computer, the IP protocol will add a new <em class="italic">header</em> to your message. </p>
			<p>From the topmost layer, the <strong class="bold">application header</strong> is <a id="_idIndexMarker241"/>added. Similarly, each layer below the application layer adds its own header. The overall process looks as in <em class="italic">Figure 4.2</em>. <em class="italic">Figure 4.2</em> shows how data is encapsulated in the TCP/IP stack before it is sent over the network. We will learn about what each of these segments contains and how this helps the packet to go to its destination:</p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B14788_04_02.jpg" alt="Figure 4.2 – Data encapsulation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – Data encapsulation</p>
			<p>We will talk <a id="_idIndexMarker242"/>about these segments in detail in the<a id="_idIndexMarker243"/> following section. </p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor108"/>The packet delivery process</h2>
			<p>The packet <a id="_idIndexMarker244"/>delivery process depends on whether<a id="_idIndexMarker245"/> the destination device is located in the same local network or not. If the device is located in the same subnet, we can directly use the Ethernet addresses to send the data. There is a lot of information present in these headers and for the scope of this book, you will not be concerned with most of them, I will only explain the fields that are relevant to this book. </p>
			<h3>TCP header</h3>
			<p>The TCP <a id="_idIndexMarker246"/>header has the fields shown in the <a id="_idIndexMarker247"/>following diagram:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B14788_04_03.jpg" alt="Figure 4.3 – TCP header&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – TCP header</p>
			<p>In this header, we are only concerned with the source and destination ports. The source port relates to the process in your local machine associated with the message you want to send. The destination port is where the packet should go. The source port is usually randomly generated from the sending side while the receiving port is defined by the message. For example, when you request an HTTPS website, your PC generates request packets with the destination port number set to <strong class="source-inline">443</strong>. Some services have fixed port numbers. For example, <em class="italic">FTP</em> works on port <strong class="source-inline">21</strong> and <em class="italic">HTTP</em> on port <strong class="source-inline">80</strong>. In our case, if we are sending the <strong class="source-inline">Hello</strong> message to a browser application working on HTTPS, the source port field in the sending packet will be randomly selected (you can also set it manually as well; for example, the SSH default port is <strong class="source-inline">22</strong>, but if we changed SSH to work on a different port and <strong class="source-inline">22</strong> has become available, it can be used as source port in packets) and the destination would be <strong class="source-inline">443</strong>. Note that some ports are reserved, as seen previously, so your PC will assign a source port number between <strong class="source-inline">10000</strong> and <strong class="source-inline">65355</strong>. Once the TCP header is added to the data, it is called the <em class="italic">TCP segment</em>. </p>
			<h3>IP header</h3>
			<p>Next, an IP<a id="_idIndexMarker248"/> header is added that looks as <a id="_idIndexMarker249"/>shown in <em class="italic">Figure 4.4</em>:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B14788_04_04.jpg" alt="Figure 4.4 – IP header&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – IP header</p>
			<p>Here, the fields that we are interested in are the source IP and destination IP. This defines where your packet will go and where it is originating from. Once the IP header is added, it is called an <em class="italic">IP datagram</em>. </p>
			<h3>Ethernet header</h3>
			<p>The Ethernet<a id="_idIndexMarker250"/> header helps the data to navigate <a id="_idIndexMarker251"/>in the local network. The most important fields here are the source and destination MAC addresses. As the name implies, the source MAC address will be your MAC address and the destination will be the MAC address of the recipient in the local network:</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B14788_04_05.jpg" alt="Figure 4.5 – Ethernet header&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Ethernet header</p>
			<p>Once an Ethernet header is added, it is now called an <em class="italic">Ethernet frame</em>. We have learned about the most important fields in the packets being sent over the network. We have also learned how data is encapsulated and which fields it uses to route<a id="_idIndexMarker252"/> it <a id="_idIndexMarker253"/>over the network. In the next section, we will learn about creating our network scanner using the information we have just learned. </p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor109"/>Introduction to Scapy</h1>
			<p>In order to<a id="_idIndexMarker254"/> create a network scanner, we will use a Python networking library called Scapy. This library is designed to send, sniff, dissect, and edit network packets. Scapy is a very powerful network packet manipulation tool. To read more <a id="_idIndexMarker255"/>about the tool, you can go to the following link: <a href="https://scapy.readthedocs.io/en/latest/introduction.html">https://scapy.readthedocs.io/en/latest/introduction.html</a>.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor110"/>Installing Scapy</h2>
			<p>To install <a id="_idIndexMarker256"/>Scapy, first open the terminal. Let's understand a few things first. In Linux, there are two user privileges, user and root, and the environment for both users is different. Higher privileges are required for system-level commands. To send and receive packets, we will need to install Scapy as a root user as well as a normal user. We will write our program as a normal user and when we run it, we will run it as root as sending packets requires higher privileges in Linux (you can think of it as the <em class="italic">Run as Administrator</em> equivalent in Windows). You will see what I mean in a moment. To install Scapy as a root user, write the following command: </p>
			<p class="source-code">sudo pip3 install scapy</p>
			<p>This will install Scapy with administrator privileges. Once this is done, open your Visual Studio Code and create a new folder for the new project. We will call this <strong class="source-inline">example2-introduction-scapy</strong>.</p>
			<p>Note that if you face some problems, you will need to update your system's Python with the following commands:</p>
			<p class="source-code">sudo apt-get update &amp;&amp; sudo apt-get upgrade &amp;&amp; sudo apt-get install python3-virtualenv -y</p>
			<p>Now, we will <a id="_idIndexMarker257"/>create a new virtual environment for this specific project. To create a new virtual environment, navigate to the folder directory just created and write the following command: </p>
			<p class="source-code">python3 -m venv venv</p>
			<p>Now, if everything is done properly, you will see a folder created named <strong class="source-inline">venv</strong>. </p>
			<p>Next, activate the virtual environment by running the following command: </p>
			<p class="source-code">source venv/bin/activate</p>
			<p>Now, your virtual environment should be activated. Once it is activated, you can see the installed packages in the environment by typing the following command: </p>
			<p class="source-code">pip freeze</p>
			<p>If you have any packages already installed in the environment, they will be listed down; otherwise, you will have nothing showing. Now, to install Scapy, write the following command:</p>
			<p class="source-code">pip3 install scapy</p>
			<p>This should take some time to install. Once done, you can write the <strong class="source-inline">pip freeze</strong> command again to see the installed packages: </p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B14788_04_06.jpg" alt="Figure 4.6 – Installed packages in a virtual environment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Installed packages in a virtual environment</p>
			<p>In this section, we have learned how we can install Scapy in our virtual environment and how to see whether it has been installed properly. Note that some functionalities of Scapy require the program to be run with higher privileges, otherwise they won't work. In the next section, we will learn more about how Scapy<a id="_idIndexMarker258"/> is used and how we can manipulate network packets with Scapy. </p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor111"/>Understanding how Scapy works</h2>
			<p>In this part, we<a id="_idIndexMarker259"/> will learn about how Scapy works and how we can use it to create our own network manipulation tools. Let's create a new file called <strong class="source-inline">main.py</strong> and open it. Once the file is open, we can import any Scapy module inside the file. In this section, we will create a small ping request to any website. Ping requests are usually used to test whether a device is available or not. A ping request (also called an <em class="italic">echo request</em>) uses an underlying ICMP application layer protocol. To import a package inside your program, write the following code:</p>
			<p class="source-code">from scapy.all import scapy</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that in the latest version of Kali Linux, some dependencies have been changed and you may see an error related to missing files. To correct this issue, you can write the following command:</p>
			<p class="callout"><strong class="source-inline">cd /usr/lib/x86_64-linux-gnu/sudo ln -s -f libc.a liblibc.a</strong></p>
			<p>To send a ping request, you will need to create an IP layer packet, which will help you set the source and destination IP addresses. To import the IP layer, we can write the following command:</p>
			<p class="source-code">from scapy.all import IP</p>
			<p>And lastly, to send and receive packets, we can use a function called <strong class="source-inline">sr</strong>. To import this function, use the following command:</p>
			<p class="source-code">from scapy.all import sr</p>
			<p>This IP will be different for you depending on your system. You can find this IP using the <strong class="source-inline">sudo ifconfig</strong> command.</p>
			<p>Then, we will define our source and destination IP:</p>
			<p class="source-code">src_ip = "192.168.74.128"</p>
			<p>Then, we will<a id="_idIndexMarker260"/> define the destination IP. We want to create a ping request to a <strong class="source-inline">google.com</strong> server. You can either manually write the IP address of this server, which you can find by writing <strong class="source-inline">ping www.google.com</strong> in your terminal, or you can simply give <strong class="source-inline">www.google.com</strong>.</p>
			<p>Scapy will automatically translate this address:</p>
			<p class="source-code">dest_ip = "www.google.com"</p>
			<p>Now, we will create an <strong class="source-inline">ip_layer</strong> packet and print it out to see what it contains:</p>
			<p class="source-code">from scapy.all import ICMP </p>
			<p class="source-code">from scapy.all import IP</p>
			<p class="source-code">from scapy.all import sr</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    src_ip = "192.168.74.128"</p>
			<p class="source-code">    dest_ip = "www.google.com"</p>
			<p class="source-code">    ip_layer = IP(</p>
			<p class="source-code">        src = src_ip,</p>
			<p class="source-code">        dst = dest_ip</p>
			<p class="source-code">    )</p>
			<p class="source-code">    print(ip_layer.show())</p>
			<p>This will create an IP layer packet and display the content of the created packet. Note that the packet has not been sent yet. </p>
			<p>The output of this program looks like this: </p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B14788_04_07.jpg" alt="Figure 4.7 – IP layer packet creation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – IP layer packet creation</p>
			<p>Take a look<a id="_idIndexMarker261"/> at the <strong class="source-inline">src</strong> and <strong class="source-inline">dst</strong> fields. The destination is an instance of <strong class="source-inline">Net</strong>, which means that Scapy will take care of translating it into an actual IP address. Now, if you check the fields displayed here and compare them with <em class="italic">Figure 4.4</em>, you will see that these are the same fields. </p>
			<p>Next, to send an ICMP request, you can call the class to create an instance like this:</p>
			<p class="source-code">icmp_req = ICMP(id=100)</p>
			<p><strong class="source-inline">id=100</strong> helps the protocol to trace packets. To see what fields are present inside this request, you can write the following command: </p>
			<p class="source-code">print(icmp_req.show())</p>
			<p>The result will look something like this: </p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B14788_04_08.jpg" alt="Figure 4.8 – ICMP packet contents&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – ICMP packet contents</p>
			<p>From here, you can see that the packet type is an echo request, which is used for testing the<a id="_idIndexMarker262"/> connection availability. </p>
			<p>From our previous discussion, we know that the application layer resides on top of the IP layer, and we have created two layers up until now. Now, the next goal would be to combine these two layers into a single packet that can be sent over the network. To do this, we can write the following code: </p>
			<p class="source-code">packet = ip_layer / icmp_req</p>
			<p class="source-code">print(packet.show())</p>
			<p>This will list out the combined packet. Note the <strong class="source-inline">/</strong> operator. This operator is used to combine different layers in Scapy. You start with the lower layer and keep on adding new layers with this <strong class="source-inline">/</strong> operator. The <strong class="source-inline">print</strong> result will show the result of the packet with the previous layers combined into one: </p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B14788_04_09.jpg" alt="Figure 4.9 – Combined layers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9 – Combined layers</p>
			<p>Now, our <a id="_idIndexMarker263"/>request is ready to be sent. To send it, we can use the <strong class="source-inline">sr1</strong> method we already imported:  </p>
			<p class="source-code">    response = sr1(packet, iface="eth0")</p>
			<p class="source-code">    if response:</p>
			<p class="source-code">        print(response.show())</p>
			<p>The response will look something like this:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B14788_04_10.jpg" alt="Figure 4.10 – ICMP reply&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – ICMP reply</p>
			<p>You can see the<a id="_idIndexMarker264"/> type of response is <strong class="source-inline">echo-reply</strong> and the <strong class="source-inline">src</strong> field in the reply is the IP address of the server that replied to this ping request. </p>
			<p>Now you have learned how to craft and send packets using Python. Theoretically, you can create any network application with Scapy. </p>
			<p>The complete code mentioned previously to send a packet is shown next:</p>
			<p class="source-code">from scapy.all import ICMP </p>
			<p class="source-code">from scapy.all import IP</p>
			<p class="source-code">from scapy.all import sr,</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    src_ip = "192.168.74.128"</p>
			<p class="source-code">    dest_ip = "www.google.com"</p>
			<p class="source-code">    ip_layer = IP(src = src_ip, dst = dest_ip)</p>
			<p class="source-code">    icmp_req = ICMP(id=100)</p>
			<p class="source-code">    packet = ip_layer / icmp_req</p>
			<p class="source-code">    response = sr(packet, iface="eth0") </p>
			<p class="source-code">// to see available interfaces, write ifconfig command in</p>
			<p class="source-code"> // terminal</p>
			<p class="source-code">    if response:</p>
			<p class="source-code">        print(response.show())</p>
			<p>The good thing about Scapy is that it lets you create <strong class="source-inline">raw_packets</strong>, which means that even packets with false information (malformed packets) can be created and there is no mechanism for checking whether the packet has correct values or not. You can change the <strong class="source-inline">src ip</strong> field from your computer and put the value of some other packet, and in some cases, the destination will have no way of knowing which PC actually generated these packets (idle scan). This way, you can <em class="italic">spoof</em> packets. </p>
			<p>So, until now, we <a id="_idIndexMarker265"/>have learned about IP stack and header fields. We also learned about how to install Scapy and use it to create raw packets that can be sent over the network. Let's now take a look at few more helpful functions that will help us understand the workings of Scapy in a bit more detail.</p>
			<p>If you want to see more details about a certain layer in Scapy and what options are available in the layer to modify, you can use the <strong class="source-inline">ls</strong> function in Scapy. To import this function, you can use this command:</p>
			<p class="source-code">from scapy.all import ls, IP</p>
			<p>To get information about <strong class="source-inline">ip_layer</strong>, we can print <strong class="source-inline">ls</strong> like this:</p>
			<p class="source-code">dest_ip = "www.google.com"</p>
			<p class="source-code">ip_layer = IP(dst = dest_ip)</p>
			<p class="source-code">print(ls(ip_layer)) </p>
			<p>In the next screenshot, you will see the execution of the previously mentioned code. The screenshot shows the list of fields in the IP packet:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B14788_04_11.jpg" alt="Figure 4.11 – The ls function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11 – The ls function</p>
			<p>If you want to access the individual field of any layer, you can simply use the dot (<strong class="source-inline">.</strong>) operator. For<a id="_idIndexMarker266"/> example, if you want to print <strong class="source-inline">dst</strong> in <strong class="source-inline">ip_layer</strong>, you can write the following code:</p>
			<p class="source-code">ip_layer = IP(dst = dest_ip)</p>
			<p class="source-code">print("Destination  = ", ip_layer.dst)</p>
			<p>The result is as follows: </p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B14788_04_12.jpg" alt="Figure 4.12 – Accessing individual fields&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – Accessing individual fields</p>
			<p>If you want to see a quick summary of the layer, you can call the <strong class="source-inline">summary</strong> method on the layer:</p>
			<p class="source-code">print("Summary  = ",ip_layer.summary())</p>
			<p>The summary result will be as follows: </p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B14788_04_13.jpg" alt="Figure 4.13 – Layer summary&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – Layer summary</p>
			<p>So now, we have familiarized ourselves with Scapy and how it works. We learned about creating<a id="_idIndexMarker267"/> basic packets and how to manipulate these packets. In the next section, we will move toward how to use Scapy for information gathering. </p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor112"/>Network scanner using Scapy</h1>
			<p>In this<a id="_idIndexMarker268"/> section, we will create a simple scanner, scan <a id="_idIndexMarker269"/>hosts in our local network, and find their MAC addresses. In order to create the scanner, we need to first understand what the <strong class="bold">Address Resolution Protocol</strong> (<strong class="bold">ARP</strong>) is and how it can be used for creating a network scanner. </p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor113"/>Address Resolution Protocol</h2>
			<p>ARP in its<a id="_idIndexMarker270"/> simplest form is a translation tool that helps us to translate IP addresses into MAC addresses. Whenever a device needs to communicate with a device within the same local network, it needs the device's MAC address. IP addresses are not used for local communication. </p>
			<p>Let's say that device A wants to communicate with device B in a local network. In order to find the MAC address of device B, computer A will first look inside an internal list maintained by it called the ARP cache to see whether computer B's IP addresses are mapped to a physical MAC address inside its table. This is called an ARP table as well. You can check the ARP table on your PC by typing the <strong class="source-inline">arp -a</strong> command.</p>
			<p>Here is the result of running the <strong class="source-inline">arp -a</strong> command on Kali Linux: </p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B14788_04_14.jpg" alt="Figure 4.14 – ARP table&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14 – ARP table</p>
			<p>You can see that it lists out the IP addresses and corresponding MAC addresses associated with them. You can use the same command in Windows as well. </p>
			<p>If the corresponding MAC address of the requested device is not present locally, device A will send out a broadcast request to the whole network to ask which device has the respective IP. In our case, it will be device B. Those devices that are not device B will ignore this request while device B will give out a reply with the corresponding MAC address of device B. This way, device A will get to know the MAC address of device B. Once both devices get to know each other, the communication between them can follow. Once device A gets the MAC address of device B, it will update its ARP table. <em class="italic">Figure 4.15</em> shows how an ARP request is generated by the source device and how the destination device replies with the correct MAC<a id="_idIndexMarker271"/> address:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B14788_04_15.jpg" alt="Figure 4.15 – ARP request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 4.15 – ARP request</p>
			<p>Now that we understand how ARP works, we can start working on creating our own ARP scanner with Scapy to find out the MAC address of these devices. You might be wondering why we need an ARP scanner. Well, knowing the MAC addresses of a device can help<a id="_idIndexMarker272"/> us perform a <strong class="bold">man-in-the-middle attack</strong>, which we will perform in <a href="B14788_05_Final_JC_ePub.xhtml#_idTextAnchor116"><em class="italic">Chapter 5</em></a>, <em class="italic">Man in the Middle Attacks</em>. </p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor114"/>ARP scanner using Scapy</h2>
			<p>The ARP<a id="_idIndexMarker273"/> protocol works on the Ethernet layer, so using Scapy, we<a id="_idIndexMarker274"/> will import the Ethernet layer. Let's import the layers and functions we will use:</p>
			<p class="source-code">from scapy.all import Ether, ARP, srp</p>
			<p>If all the bits of a MAC address are set to <strong class="source-inline">1</strong>, it means that the packet is a broadcast and it should go to every device in the network. Scapy uses hexadecimal representation, so we will create the following variable to denote the broadcast address: </p>
			<p class="source-code">broadcast = "FF:FF:FF:FF:FF:FF"</p>
			<p>Then, we can create an Ethernet layer packet and put the destination as <strong class="source-inline">broadcast</strong>. </p>
			<p>We will also need to define the <strong class="source-inline">ip</strong> range we want to scan. In my case, I want to scan my local network: </p>
			<p class="source-code">ip_range = "192.168.74.1/24"</p>
			<p>This represents that we want to scan all the devices starting with IP address <strong class="source-inline">192.168.74.1</strong> up to <strong class="source-inline">192.168.74.255</strong>. The last 8 bits are called a bitmask and represent the number of hosts we want to scan. Remember that an IP address is 32 bits, and we say here that we want to mask 24 bits, so the remaining <strong class="source-inline">32-24 = 8</strong> bits are addressable only, which means that we are only scanning the last 256 hosts in the network. </p>
			<p>Now, to create an ARP layer packet, use these commands:</p>
			<p class="source-code">ip_range = "192.168.74.1/24"</p>
			<p class="source-code">arp_layer = ARP(pdst = ip_range)</p>
			<p>Now we have created two layers, <strong class="source-inline">Ether</strong> and <strong class="source-inline">ARP</strong>. Next, we will create a packet with both these layers:</p>
			<p class="source-code">packet = ether_layer / arp_layer</p>
			<p>Next, we will send this packet as a broadcast. To do this, we can use the following <strong class="source-inline">srp</strong> function:</p>
			<p class="source-code">ans, unans = srp(packet, iface = "eth0", timeout=2)</p>
			<p><strong class="source-inline">packet</strong> is the name of the packet we want to send, <strong class="source-inline">iface</strong> is the network interface card we want to use to send this packet, and <strong class="source-inline">timeout</strong> is to make sure that if we don't get a reply in 2 seconds this means that the device is most probably offline. </p>
			<p><strong class="source-inline">srp</strong> returns both answered and unanswered packets. We are interested in answered packets from online devices only. Now, to get the IP addresses and MAC addresses of the online devices, we can write the following code. We can iterate over the answer to see the IP and corresponding MAC addresses: </p>
			<p class="source-code">    for snd, rcv in ans:</p>
			<p class="source-code">        ip = rcv[ARP].psrc</p>
			<p class="source-code">        mac = rcv[Ether].src</p>
			<p class="source-code">        print("IP = ", ip, " MAC = ", mac)</p>
			<p><strong class="source-inline">rcv</strong> represents <a id="_idIndexMarker275"/>the packets that have been received by the <a id="_idIndexMarker276"/>sender. To get the IP address, we can use the ARP layer, and to get the MAC address, we can use the <strong class="source-inline">Ether</strong> layer. Remember the fields set in packets correspond to the respective layer. </p>
			<p>The complete code will look something like this: </p>
			<p class="source-code">from scapy.all import Ether, ARP, srp</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    broadcast = "FF:FF:FF:FF:FF:FF"</p>
			<p class="source-code">    ether_layer = Ether(dst = broadcast)</p>
			<p class="source-code">    ip_range = "192.168.74.1/24"</p>
			<p class="source-code">    arp_layer = ARP(pdst = ip_range)</p>
			<p class="source-code">    packet = ether_layer / arp_layer</p>
			<p class="source-code">    ans, unans = srp(packet, iface = "eth0", timeout=2)</p>
			<p class="source-code">    for snd, rcv in ans:</p>
			<p class="source-code">        ip = rcv[ARP].psrc</p>
			<p class="source-code">        mac = rcv[Ether].src</p>
			<p class="source-code">        print("IP = ", ip, " MAC = ", mac)</p>
			<p>The output of the program looks like this: </p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B14788_04_16.jpg" alt="Figure 4.16 – ARP scan result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16 – ARP scan result</p>
			<p>Now you <a id="_idIndexMarker277"/>can <a id="_idIndexMarker278"/>see the MAC and IP addresses of all the devices available in the network. The third one, <strong class="source-inline">IP = 192.168.72.129</strong> is my Windows machine, which I will use as a victim/target machine in later chapters. To verify that the result we obtained in our program is correct, we can check these fields manually from the network connection settings:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B14788_04_17.jpg" alt="Figure 4.17 – Victim's IP configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.17 – Victim's IP configuration</p>
			<p>Here, you can <a id="_idIndexMarker279"/>see that the results obtained in our scan match these <a id="_idIndexMarker280"/>values. Take a look at the MAC address as well. The other devices can also be seen. </p>
			<p><strong class="source-inline">192.168.74.254</strong> represents the DHCP server. DHCP servers assign IP addresses to devices in a network when the devices are configured to automatic IP assignment. <strong class="source-inline">192.168.72.2</strong> represents the default gateway in the network. </p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor115"/>Summary</h1>
			<p>In this chapter, we learned how data is sent from one device to another over the network. We learned about how data is encapsulated in the TCP/IP protocol and what fields are added to each header. Next, we learned about a very important network manipulation and packet crafting tool called Scapy. We also learned how to craft packets using Scapy and how these packets can be sent over the network. We then learned about the ARP protocol and finally, we created an ARP scanner to get the IP and mac addresses of live devices in a network. In the next chapter, we will learn how to use this scanner to create a man-in-the-middle attack to intercept network traffic from a victim machine.</p>
		</div>
	</body></html>