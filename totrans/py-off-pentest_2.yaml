- en: Advanced Scriptable Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem with the back door, which we created in the previous chapter, is
    that if the attacker IP changes we don't have a built-in mechanism to inform our
    target that it should connect to the new IP address. In this chapter we will look
    into a method that lets you keep a fixed reserved name for your attacker machine
    even if its IP changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic DNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with Twitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicating Metasploit's screen capturing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicating Metasploit searching for content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating a low-level port scanner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, one of the methods we''ll discuss here is dynamic DNS. Let''s say that
    the attacker IP is `1.1.1.1` on day 1\. Then, the next day, we get an IP address
    of `2.2.2.2`. Then, how would our target know the new IP address ? The answer
    is **dynamic DNS** (**DDNS**). It is a method to preserve a unique name for you
    on a DNS server. While the reserved name is fixed, the correlated IP address will
    change each time you change your public IP address. For demonstration, we will
    use [noip.com](https://www.noip.com/). It provides a free dynamic DNS service.
    So I have previously preserved a name called `pythonhussam.ddns.net`. So on the
    target side, instead of hard-coding the IP address on that script, we will do
    a DNS lookup for this name; then we will retrieve the IP address to make the connection.
    Now, you''re probably asking: When the attacker IP address changes, how does [noip.com](https://www.noip.com/) know
    the new IP address to update its DNS record? Well, the answer is via a software
    agent, which should be installed on our Kali machine. The agent will connect to
    [noip.com](https://www.noip.com/) servers, and let them know our new IP address.'
  prefs: []
  type: TYPE_NORMAL
- en: To save time, you can create a free account on [noip.com](https://www.noip.com/).
    It should be quite simple and straightforward. Then, reserve a name of your choice,
    In the next section, we will install **No-IP agent** on our Kali Linux and modify
    the code in our previous TCP reverse shell version to resolve a DNS lookup on
    `pythonhussam.ddns.net`, which will be the reserved name that we will use for
    demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: DNS aware shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will start by installing the No-IP agent on our Kali Linux
    machine. Ensure that our Kali machine is connected to the internet so that we
    can download and install the agent software:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parse to `/usr/local/src/` by executing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the agent software:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Extract the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`cd` into the `noip` folder we just extracted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the agent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So, at this point, it''ll prompt you to enter your `email` and `password`,
    which you used to register on the [noip.com](http://noip.com) website. So I''ll
    type my email address here. And now we can see that `pythonhussam.ddns.net` is
    already registered to our account, and a new configuration file has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s jump to the target machine. In Python, it''s very simple to do
    a DNS lookup. It''s just a matter of a single line to resolve the IP address,
    and we will do that using either `socket.gethostname` or `socket.gethostbyname`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we store the result, which is the IP address of the attacker machine,
    in a variable called `ip`. For now, we will just comment the `connect(ip)` function
    and print out the result, just to make sure that our script is working fine here.
    So we''ll run the module, and it says the IP address is `37.202.101`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's go back to the attacker machine and verify our public IP address by searching
    `what is my ip address` in Google. If everything goes well we will see the same
    address that the target identified as the updated public IP address of the attacker
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: So since the IP variable stores our attacker IP, we will pass this value into
    the connect function and use this value to connect back to the attacker machine.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have replaced the static IP address in `s.connect((ip, 8080))` 
    with a variable called `ip`.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Twitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will discuss a technique that is used frequently these days: relying
    on well-known servers to perform certain tasks or transfer a piece of information.
    This technique has been used by a Russian malware. What the attackers did was
    they sent the data over their Twitter account and made the target parse it later
    on. So, on the attacker machine, we just send an order or command as a normal
    tweet to our Twitter account. Note that there is no direct communication between
    the attacker and its target, which is really evil here. Later on, the target will
    parse the tweet and execute that order. The benefits of doing this is are:'
  prefs: []
  type: TYPE_NORMAL
- en: Twitter is a trusted website and it has a very good reputation; most likely,
    it's a whitelisted website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This type of attack is very hard to detect, where an unskilled security team
    would never have thought that this data could be malicious—and one of my goals
    here is to open your eyes to such malicious attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, from the Kali machine we will send `hello` from the Python
    string as a normal tweet to our account. On the client side, we will parse the
    tweet, then we will print out the result.
  prefs: []
  type: TYPE_NORMAL
- en: Now, technically speaking, anybody can view your tweet without even logging
    into Twitter. I recommend you read the FireEye report to see how attackers took
    advantage of this situation, [https://www2.fireeye.com/APT29-HAMMERTOSS-WEB-2015-RPT.html](https://www2.fireeye.com/APT29-HAMMERTOSS-WEB-2015-RPT.html).
  prefs: []
  type: TYPE_NORMAL
- en: Believe it or not, in five lines of Python script, you will connect to the attacker
    page over HTTPS retrieve the HTML and parse it and finally extract the data from
    the tweet.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a tweet in three lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this demonstration, I created an account on Twitter. My profile name is
    `@HussamKhrais`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, I will log into my Twitter account from the Kali machine and send a tweet,
    and we will see how easy it is to grab that tweet from the target machine. So
    let''s get started by first composing a new tweet (for example `Hello from kali
    python`) and log out from the account. Let''s now have a quick look at the HTML
    page that gets created after posting the tweet, by viewing the page source. Search
    and find the the tweet we just made. Then, if we scroll to the left a little bit,
    notice the HTML meta tag parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, `name`, has `description` as a value,  and the second parameter
    called `content` contains our tweet. Now, we'll use these HTML tags to parse the
    HTML and extract the tweet eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Python has a library called Beautiful Soup, which is a very well-known tool
    used to parse HTML pages. You can download it from: [https://pypi.python.org/pypi/BeautifulSoup/](https://pypi.python.org/pypi/BeautifulSoup/).
  prefs: []
  type: TYPE_NORMAL
- en: To install this library, just navigate to the directory where Beautiful Soup
    exists, then run `python setup.py` and install it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a quick look at the code, which we will use on the target side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So using `urllib` or the URL library, we'll browse to my Twitter home page.
    And once we retrieve the HTML page, we'll store it on the `html` variable. Then,
    we pass the HTML page or a variable to the `soupy` function.  Remember the HTML
    meta tag that contains our tweet? We will look for it using the `find` function
    in Beautiful Soup. So, we will look for a `meta name` and a value of `description`. Using
    a regular expression, we will do a final filter to print only the exact string
    between the quotation mark, which is basically the tweet that we sent. On running
    the script you will see that we got back the same tweet that we sent.
  prefs: []
  type: TYPE_NORMAL
- en: So, we will clean the code a little bit by removing the `print x` command. We
    will log into the Twitter account one more time and send another tweet. This time,
    we will tweet `We made it`. So, on the target side, we should be able to view
    the latest tweet on running the script.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that we were able to get the tweet without any login or authentication.
    Now, in the next section, you will see how you could use this information or script
    in a real-world scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Countermeasures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll discuss possible countermeasures for malware that is
    designed to interact with Twitter. Now, notice that I said a possible countermeasure,
    because this is not an easy job to do; and that''s because of one of the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Blocking Twitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminating SSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first thing that may come to your mind is to simply block Twitter, and
    this will definitely prevent the attack. However, what if you work for a social
    marketing company or your daily job involves the use of Twitter? Then in this
    case, it''s not an option. Also, it''s not only limited to Twitter. Imagine that
    the target downloads an image from Instagram, and then, using stenography, the
    target parses a hidden text or hidden command within that image. The second point
    you might think about is, we have seen that the Twitter home page is using HTTPS,
    where the traffic is encrypted. And you might think that we can simply terminate
    the SSL and see the traffic in clear text. So let''s assume that we have such
    a device for decryption, and we can see the tweet as clear text and the transit
    path. But the question is: What resources do we need to check each single packet
    going back and forth from our network to Twitter, as it could be 100 MB of data?
    Also, how we can distinguish between the good and the bad one?'
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s say that we have a tweet saying, `Follow this website`. So how can
    we tell that this is a malicious or innocent site, without actively inspecting
    that website? And overall, this will be a bigger headache in our process. Another
    point to consider here is: What if the tweet itself was encrypted? So, instead
    of seeing hello world or `ipconfig`, the attacker could encrypt this tweet in
    AES and send it to Twitter, and decrypt it back once it reaches the target side.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, what the attacker can do is mislead anyone watching the traffic. He can
    make the malware parse hundreds of Twitter pages in addition to the hacker page,
    and this leads us back into the resource issue which we discussed. Last but not
    least, the attacker can tweet another IP to create a chain of connections. If
    you read the report from FireEye on how the Russian malware works, then you will
    see that the attackers tweeted a link for an image located on GitHub. So, the
    victim initiated a new session to GitHub, and that's what's called a **chained
    connection**.
  prefs: []
  type: TYPE_NORMAL
- en: So if we think again about how we get infected with this malware, it will tell
    us that the same countermeasures we discussed in the previous chapter are still
    valid in our current scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Replicating Metasploit's screen capturing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will automate capturing a screenshot from the target machine
    and retrieve it over HTTP reverse shell. Getting a screenshot from the target
    `Desktop` can be useful to see what programs and activities are going on on the
    target side. In Metasploit Meterpreter, there is a function called **`screengrab()`**,
    which will take a snapshot from the target machine and transfer it back to the
    attacker machine. So here, we will do something similar in our existing HTTP shell.
    For this purpose, we will be using a library called `Pillow` at the target. This
    is a high-level image library in Python. The installation is quite simple. You
    just need to run `pip install Pillow` via `cmd`.
  prefs: []
  type: TYPE_NORMAL
- en: Before doing that, just make sure that you have internet access. Once we install
    this library, I will go to Devices|Network|Network Settings... in VirtualBox, and
    change the network mode back to Internal Network as we did in the previous chapter. We
    will also give our target the static IP address so that we can reach out to the
    attacker machine.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that we got a connection with our attacker by pinging its IP address
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'In our HTTP code, we start by importing our library. So we import the `ImageGrab()`
    function and we need to add a new `if` statement saying that, if we received a
    `screencap` keyword, then we will take a snapshot and save it to the current working
    directory with the name `img.jpg`. Then, we will transfer it back to the attacker
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's now try and test the script. Ensure the HTTP Data Exfiltration Server
    script is running at the attacker end. Once we get the `Shell>` run `screencap` at
    the attacker go to the `Desktop` and change the file extension to `.jpeg` so that
    we will be able to view the screenshot. If we go to the target machine, you will
    see that our `screencap` image is saved on the same current working directory
    as our script.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the problem with this is that it's very obvious that someone is doing some
    malicious activity on our PC. Even if we remove the image after doing the transfer,
    there is still a chance that the target could catch us. Now, to overcome this,
    we will use the OS's `temp` directory to create a temporary directory and save
    the image over there. And once the transfer is completed, we will remove the entire
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Python has a built-in library that uses the operating system's temporary directory.
    Let's have a quick look. We will go to Command Prompt and open a Python interactive
    mode and run `import tempfile`. This `tempfile` will handle the task of creating
    a `temporary` directory. But before creating one, open the Windows `temp` directory.
    Run `print tempfile.mkdtemp`, which will make a temporary directory for us and
    print out all the directory names. Now, to get rid of this temporary directory,
    we will use another library called `shutil`. We will `import` this one and we
    will create a new temporary directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that, once we do this, a new folder is created in the `temp` directory.
    Now, we will remove it by running `shutil.rmtree(x)` since the variable `x` contains
    the name of that `temp` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To reflect these changes in our script, we will just go back and edit our target
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we'll create a `temp` directory and store its path in the `dirpath` variable.
    Then, we will tell`ImageGrab` to save the `screencap` in the newly created `temp`
    directory. Also we'll modify the save directory. We will also need to reflect
    this change to the file transfer function, so it knows the new path for the image
    file. The last thing is, once the transfer gets completed, we have to make sure
    that the file gets closed since we cannot remove a file that is currently opened
    by an application or a process. We will delete the whole directory.
  prefs: []
  type: TYPE_NORMAL
- en: Give it a try, and verify that we didn't leave any track behind. Try a filter
    on `img` inside the `temp` directory, which is the filename or the image name,
    and we will see if anything shows up by running the script as we did before. Once
    we get the `Shell>` at the attacker machine run a `screencap`. Once you get the
    screenshot on the attacker rename it, jump to the target side, and see if any
    file has been created. You will see that there is nothing there because we removed
    the `temp` directory after we did the transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Replicating Metasploit searching for content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now code a Python function that will search into target directories
    and provide us with a list of file locations for a certain specific file extension.
    For instance, say we need to search for a PDF or document file on the target machine;
    instead of checking each directory, we will add a new function to automatically
    do the job for us. This is very useful when you first land in a target machine
    and try to explore as much data as possible such as documents, PDF files, and
    so on. The coding part is quite easy. We will use the Python `os` library to do
    the job for us. So, as usual, I have added a new `if` statement to specify that
    if we get a `search` keyword we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So first, we define the format as `search C:\\*.pdf` . Note that we are only
    interested in the second part, which is the directory that we want to search and
    the file extension. Right now, to clean the `received` command and to split it
    into parameters, we will have to cut off the first leading seven characters; and
    we will do so to get rid of the unwanted search string and space. Now, if we count
    the first seven characters, it will be up to the `C` directory here; the output
    after doing that, will be much cleaner. Next, we split the string into path and
    file extensions, and we store them in path and extension variables. So the first
    parameter will be the `path`, which will be stored in the path variable, and the
    second one will be stored in the extension variable. Next, we define a list variable,
    and this one will be our placeholder to store the file directories. Now, the actual
    function that will do the search for us is the `os.walk(path)` function. This
    function will navigate all the directories specified in the provided `path` directory,
    and return three values: the `dirpath`, which is a string that contains the path
    to the directory; the `dirname` , which is a list of the names for the sub directories
    in the `dirpath`; and  finally `files`, which is a list of filenames in `dirpath`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we perform another loop to check each file in the `files` list. If the
    files end with our desired extension, such as `.pdf`, then we add the directory
    value into the list string. In the end, the `os.path.join()` function represents
    a path relative to our file to the current directory, and in our case, it's the
    `C:\` directory. Finally, we'll post the result back to the attacker side.
  prefs: []
  type: TYPE_NORMAL
- en: 'On running the script on both sides, as a start let''s search for every PDF
    file in the `C:\` directory by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After this let''s try to grab `Documents\Module 3.pdf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also search for each text file in the system. It should be a huge list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can narrow down our search, and just do a search for the `Desktop` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And we have a file there called `passwords.txt`. Try to grab that one, and verify
    its content as we did in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Target directory navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now address a directory navigation issue. Now, the problem is that browsing
    directories is restricted to the shell working directories. For instance, if the
    target has executed our Python script on the `Desktop`, then our working directory
    will be the `Desktop`. And due to shell limitations, we cannot simply type `cd`
    and move on to another directory. Remember we learned that some commands won't
    work in a shell, and `cd` is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Once we run our previous TCP reverse shell on both sides, you will see our current
    working directory is on the `Desktop`, where our Python exists. Notice what will
    happen when a `cd` command is issued to change the current working directory to
    `C:\Users`. Our script will become non-responsive once we try the `cd C:\Users`
    command, and this is because the shell fails to handle the `cd` command properly.
    Now, to overcome this problem, we need to explicitly tell the script to change
    its working directory. Again, that's because our shell working directory is restricted
    to the working directory of our Python script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula here will be `cd` followed by space, then the path that we want
    to go to. Then, we will split up the received command based on the space into
    two variables. Thankfully, changing the directory is a matter of a single line
    in Python. Finally, we send back a string mentioning the new current working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we try the previous script, after typing `cd C:\Users`, you will be able
    to see whether we have changed or moved to the `Users` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Try navigating to the location of the file that you want to `grab`. You will
    notice that, once we are on the same directory as the file we want to `grab`,
    then we don''t need to specify the absolute path anymore. We can simply grab the
    file by specifying just the filename, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will get us the file on the Kali machine.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating low-level port scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During penetration testing, sometimes you encounter a scenario where your client
    is using some kind of an internal server that is not accessible through the internet.
    And just because of this they think it's secure. In this section, we will see
    how we can integrate a simple port scanner with our script to prevent a possible
    attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, once you get into your target machine, you start looking for other
    possible targets. For example, if we were able to access machine A, then we can
    extend our attack and scan machine B to see what ports and services are running
    on that machine. The other usages are to make the target scan an online server
    on our behalf to hide our activities. Now, let''s get to the coding part. We will
    build a basic low-level scanner. It''s named low-level because we will use the
    built-in socket library and then build on it. The formula or the format for sending
    scan requests is `scan` followed by a space, then the IP address followed by a
    colon, and then the port list, for example `scan 10.0.2.15:22,80` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, the first thing to do is to cut off the leading first character, so this
    part will be removed. After that, we will split the right part into two sections.
    The first section is the IP address that we want to scan, and we will store it
    in the `ip` variable. The second section is the list of ports for which we want
    to check the access status, and it will be saved in the `ports` variable. To keep
    the coding clean, an entire function called scanner is there to do our stuff.
    So, we will pass the `socket` object, the `ip`, and the `ports` variables to this
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get these variables, we will define `scan_result` as a variable, which
    stores our scanning result. Now, remember that the ports are separated by a comma,
    like this: `21, 22, 80, 443, 445`, for example. So what we will do is, we will
    loop over each one of these ports and try to make a connection using a `socket` library
    for each one of them. Notice that I have used the `connect_ex()` function, where
    the function returns `0` if the operation succeeds. And, in our case, the operation
    succeeded, which means that the connection happens and that the port is open.
    Otherwise, the port would be closed or the host would be unreachable in the first
    place. In the end, we will close the socket and repeat the whole process until
    the last port in our list here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So we'll go for port `22` until we reach the last one. The result of our scan
    will be stored in `scan_result`, and the `+` sign is used to append the result.
    Finally, we send back the result to our Kali machine. Since our Kali machine and
    the target are on the same virtual subnet here, we should appear on the target
    `arp` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets proceed to the rest of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'On running our scripts on both sides, we will do an `arp -a` and this will
    give the IP address of our Kali machine: `10.0.2.15`. So, as a proof of concept,
    we can scan our Kali machine from the target side and run Wireshark to confirm
    the scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we run Wireshark and filter on TCP, we can see that the TCP session comes
    over. In the scan result, we can see that port `8080` is opened and all others
    are closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can check the completed three-way handshake for TCP on port `8080`. We can
    see the `[SYN]`, `[SYN, ACK]`, then `[ACK]` that complete the three-way handshake;
    and we can see that the target, after completing the three-way handshake, sends
    a `[FIN]` request to close the socket here because we opted to close the socket
    after scanning. If you still remember, in the code here we said `sock.close()`.
    So `[FIN]` acts as an indicator to close the socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to double-check, we can open a terminal to see what process is using port
    `8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We will see that it's opened by another Python script. But if we do the same
    for port `21`, we will get nothing since the port is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do another test: we will use a `netcat` to open port `21`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Then, I will do the scan again to see whether the result is going to change.
    Right now, we are listening on port `21` since it's opened.  So if we go back
    to our shell, and then repeat the same scan; if it's working, we should see port
    `21` open.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about DDNS and the DDNS-aware shell. We also learned
    how to interact with Twitter, and replicate Metasploit's screen capturing, and
    we searched for the content and looked into target directory navigation. Last,
    we saw how to integrate a low-level port scanner.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about password hacking.
  prefs: []
  type: TYPE_NORMAL
