- en: Password Hacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most hackers assume that their target is running a legacy unpatched Windows
    XP, where the antivirus is disabled, the firewall is turned off, and the IPS may
    not be in place. After all, you may or may not hack into their systems. This is
    definitely not real-world penetration testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will deal with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Antivirus free keylogger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Man in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firefox API hooking with Immunity Debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python in Firefox **proof of concept** (**POC**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python in Firefox EXE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password phishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Countermeasures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Antivirus free keylogger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will code a simple software keylogger, purely in Python.
    To do so, we will be using a library called `pyHook`. The `pyHook` library wraps
    the low-level mouse and keyboard hooks in Windows. As per the `pyHook` documentation,
    any application that wishes to receive notification from a global input event
    must have a Windows message pump. For this, we need another library, called `pywin`.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's start by installing these libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Installing pyHook and pywin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can download the `pyHook` library from [http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/](http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/)
    and install it easily following the on-screen instructions.[ ](http://sourceforge.net/projects/pyhook/files/pyhook/1.5.1/)
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you do not have another Python instance running in the background
    or you will get an error during installation.The `pywin` library can also be installed
    in the same manner. You can download the library from [https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/](https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/).
  prefs: []
  type: TYPE_NORMAL
- en: Adding code to keylogger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is the script for keylogger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look into the steps in the script:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `pyHook` and `pythoncom` libraries, as shown in the previous script, `import
    pythoncom, pyHook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `pyHook` library will handle low-level communication with a Windows function
    called `SetWindowsHookExA`. This function will install a hook for us to monitor
    the keyboard event.
  prefs: []
  type: TYPE_NORMAL
- en: Import the `pythoncom` library, which will do the Windows message pumping for
    us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a string `store`. This is where we will store all of the pressed keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and register a `HookManager`. Once the user hits any keyboard button,
    the `keypressed()` function will be executed, and that action will be stored in
    the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the hooking loop and pump out the messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep in mind that, as per the `pyHook` documentation, we must have a Windows
    message pump here.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `Enter` and `Back space` buttons are not handled properly. we need
    to statically configure their values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep in mind that we know whether the user input was *Enter* or *Backspace*,
    based on their ASCII values.
  prefs: []
  type: TYPE_NORMAL
- en: Append the ASCII key to the `store` variable, and finally write them in a `keylogs.txt`
    file here. We can append the data and the text file instead of writing over them,
    but it is suggested to use the write technique instead of the append for more
    stability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After intercepting the keyboard event, we need to return a `True` value; otherwise,
    we will simply disable the keyboard functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, let's do a quick test by running the module. We will create a new text file
    just for testing. Lets type into the text Error! Hyperlink reference not valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to use *Backspace* in between while typing the above lines. Notice
    that we will get our key logs in the `keylogs` file that we created. It will look
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since we typed *Backspace*, you can see that we got `BACK SPACE` in keylogs.
  prefs: []
  type: TYPE_NORMAL
- en: Now, terminate the `keylogger` and remove the files `keylogs` and `New Text
    Document`. Copy the name of the file `keylogger` so that we can export it to EXE
    using the setup file for `py2exe`. You can then run the module. The `keylogger`
    EXE will be created. Now, let's do a quick scan of the `.exe` file named `keylogger`
    with AVG antivirus, just to see if we've got a signature for this EXE file. If
    it says No threats detected, run the keylogger in EXE format. Next, log into your
    Facebook account and notice that once we type even a single key on the keyboard,
    we get that on our `keylogs.txt` file. Enter your email address and password to
    open the Facebook page and open the `keylogs.txt` file. You can see your password
    and the email there.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that you have to terminate the `keylogger` process manually. Also,
    the `keylogs` file is located on the same directory as our binary.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to enhance our keylogger features.
  prefs: []
  type: TYPE_NORMAL
- en: Hijacking KeePass password manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever worked with network engineers or system administrators who
    work on multiple devices, then you have probably come across a password manager,
    simply because remembering each password is impossible for them. Usually, they
    use a password manager to securely store device credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will use a very common cross-platform software called KeePass
    and we will see how we can hijack passwords with the help of this software. You
    can download and install the software from [https://keepass.info/download.html](https://keepass.info/download.html).
    After installing:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `NewDatabase` by clicking on the New icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define Master password and click on OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click on eMail and create a new account or a new entry for the `gmail`
    account by right-clicking and selecting the Add Entry... option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's create a new entry for the PayPal account. Click on Homebanking,
    then right-click and select the Add Entry... option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, let's log in and see whether we can use the password manager for the login.
    Let's go to [https://accounts.google.com](https://accounts.google.com), the login
    page. In the case of password manager, you need to copy and paste the username
    and the password to the login page from the database. Note that in this case the
    keylogger will not work, simply because the passwords are copied into the clipboard
    and it's just a matter of copy and paste without touching the keyboard here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, log out from your account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Python, to interact with a clipboard, you need a library called `pyperclip`,
    which you can download from [https://pypi.python.org/pypi/pyperclip/1.5.11](https://pypi.python.org/pypi/pyperclip/1.5.11).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing the `pyperclip` library is quite simple. We just need to copy and
    paste the library file into the `site-packages` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you experienced some issues while using the setup file, then do it manually.
  prefs: []
  type: TYPE_NORMAL
- en: The directory is `Python27/Lib`, then `site-packages`. The file is now installed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, go to the `password manager` folder and open the file to take a look at
    the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We start by importing the libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a `list`, which will store the clipboard content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will go into an infinite loop to continuously check the clipboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the clipboard content is not empty (here, empty means `None`), then we will
    take its value, and store it in a variable called `value`. To make sure that we
    don't get replicated items in our `list`, before appending the `value` variable
    into our `list`, we will check whether the value is stored in the first place.
    If not, then this means that it is a new item, and we will store it. In the end,
    we will print out our result, or you could save it to a text file. Then, we will
    sleep for `3` seconds, and check the clipboard status again.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's run the the script and repeat the whole process one more time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's see what happens once we copy the username and password of the Gmail account.
    Once it is copied into the clipboard, our script will immediately get the clipboard
    value and print it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's try with our stored PayPal account. Once we make a copy, we can see the
    random password we entered earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is how the password manager works.
  prefs: []
  type: TYPE_NORMAL
- en: Man in the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss a new method. As you may already know, all
    browsers offer to save your username and password when you submit the data into
    a login page. The next time you visit the same login page, you will see that your
    username and password are automatically filled in without typing a single letter.
    Also, there is dedicated third-party software such as **LastPass,** that can do
    the same job for you. The point here is that, if the target is using this method
    to log in, then neither the keylogger nor the clipboard methods will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look. We''ll be using the LastPass plugin on the Firefox
    browser. Open the browser here and go to the Gmail account. We will use the previous
    clipboard script before logging into the Gmail account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run the script and then log into the Gmail account using LastPass. You will
    notice that LastPass has inserted the email and password automatically.
  prefs: []
  type: TYPE_NORMAL
- en: After logging in successfully, you will notice that the clipboard script could
    not catch anything here. Let's log out from the Gmail account.
  prefs: []
  type: TYPE_NORMAL
- en: In response to this, hackers have created a new attack, called **man in the
    browser attack** to overcome this dilemma. In a nutshell, man in the browser attack
    intercepts the browser API calls and extracts the data while it's in clear text,
    before it gets out to the network socket where the SSL encryption happened.
  prefs: []
  type: TYPE_NORMAL
- en: Firefox process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will debug and get inside the Firefox process now. Then, we will intercept
    the API calls for a specific Function inside a DLL module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00039.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the DLL and we will perform intercepting for a specific Function inside
    the DLL. After that, we will extract data and continue the flow. In summary, the
    steps for doing so are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the process ID of the browser process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach our debugger to this process ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the DLL library that we want to intercept, as well as the function name
    inside the DLL. Keep in mind that we need to know the memory address of the function
    so that we can continue the flow after intercepting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a breakpoint and register a `callback` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `callback` function, we will print out the sensitive data from the memory
    in clear text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the debug event using the debug loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the debug event happens, execute the `callback` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After executing the `callback` function, we will return to the original process
    to continue the normal flow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next two sections, we will see these steps in action. It's much simpler
    than it appears to be.
  prefs: []
  type: TYPE_NORMAL
- en: Firefox API hooking with Immunity Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firefox uses a function called `PR_Write` to write data into a TCP socket. This
    function is located inside a DLL module called `nss3.dll`. For this demonstration,
    we need to prepare a Twitter account. Once that account is created and you are
    logged in, sign out of the account and then log in again. Since we use LastPass,
    the login credentials will already have been entered by LastPass. Once we click
    on the Log in button, what will happen behind the scenes?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00040.gif)'
  prefs: []
  type: TYPE_IMG
- en: Behind the scenes, Firefox will load the `nss3.dll` library and call the `PR_Write`
    function to submit the data (login ID and password). Once Firefox performs these
    steps, we'll set up a breakpoint and intercept traffic. Let's start by installing
    the **Immunity Debugger** software from [https://debugger.immunityinc.com/ID_register.py](https://debugger.immunityinc.com/ID_register.py).
    The installation part is quite straightforward. Immunity Debugger will get the
    process ID of the browser process and attach a debugger to the PID in one shot.
    We just need to attach the Firefox process from the list of processes to attach
    shown when we go to File | Attach. By default, Immunity Debugger will resolve
    the process ID and attach it for us. The next action is to specify the DLL library
    and function name, that is, `nss3.dll` and `PR_Write`, respectively. To do so,
    you just need to go to View | Executable modules. Search for the proper DLL by
    checking the Name field. Right-click on the highlighted DLL and then select View
    names. Scroll down until you find the `PR_Write` function.
  prefs: []
  type: TYPE_NORMAL
- en: So, at this point, we have accomplished the first four steps from our previous
    section on the *Firefox process*.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are doing the hooking manually using Immunity Debugger, we don't need
    to specify a `callback` function.
  prefs: []
  type: TYPE_NORMAL
- en: To set a breakpoint, you just need to press *F2* on your keyboard or right-click
    and specify a Toggle breakpoint. Once you do that, hit the Play button a couple
    of times.
  prefs: []
  type: TYPE_NORMAL
- en: Now bring up the Firefox window again. Notice that each time we get a breakpoint,
    we will be notified by the task manager located in the bottom of the Immunity
    Debugger screen. Also, the execution will be stopped. You can see the paused window.
    It'll be paused unless we manually hit the Play button once again. Now hit on
    the Log in button. To view the memory content, just right-click and go to Address
    | Relative to ESP register, which is the stack pointer. Then you just need to
    click on the Play button multiple times. Right-click on one of the ESP registers
    and select Follow in Dump so that we can see the memory dump here. Again we need
    to click on the Play button multiple times. Once again, right-click and select Follow
    in Dump. After a few clicks we will first copy the memory dump in the new text
    file and then we will terminate the debugger. You will see that there is the same
    username and password that we used for logging into the Twitter account. The username/email
    was `bigtasty@gmail.com`. We can see that we got some hexa characters, which we
    need to move back to ASCII. We can do this by checking with the ASCII code table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let the following be the mail and password that we got above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start with the email address. Notice that `40` in hexa means `@` in
    ASCII. So we got `bigtasty` through `321@gmail`. For the password, the `58` is
    represented by a left bracket (`[`) and the `5D` is represented with a right bracket
    (`]`). So, our username and password will be set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will try to log in to the Twitter account using the information that
    we have just figured out here. So, go to the Twitter login page and copy the username
    and password, and you will see that you can log in.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that all that this is just a manual method, and it was just an
    introduction to the next section. In the next section, we will see how to get
    the same result using a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: Python in Firefox proof of concept (PoC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will write a Python script, that will automate the exact
    steps that we did using Immunity Debugger. For this purpose, we will be using
    a Python library called `winappdbg`, to automate the debugging of the Firefox
    process. So, let's start by installing this library. You can download the library
    from [http://winappdbg.sourceforge.net/](http://winappdbg.sourceforge.net/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps mentioned in the Firefox process section, which we explained earlier
    can be translated into code. Let''s do this step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to get the process ID and then attach it to a debugger. The
    code in Python to do this is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, first we search for the Firefox process and then retrieve its
    process ID. We will then attach the process ID to the debugger and pass a class
    called `MyEventHandler` to the `debug` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MyEventHandler` class, we specify the DLL library that we want to intercept
    as well as the function name, and we will resolve its memory address. Let''s look
    at the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the DLL name `nss3.dll` and the function name `PR_Write`. We have
    resolved the memory address for the function. We then set the breakpoint, and
    register the `callback` function. Notice that we need to pass some mandatory information
    to the `callback` function, such as the process ID and the resolved memory address
    for the function. You can see the `pid` and the `address`. Notice that we have
    named the `callback` function `PR_Write`. When the breakpoint occurs, `3` parameters
    should be returned to the `callback` function. Now, the question is: what are
    these `3` parameters, and how could I know their number here? The answer to these
    questions comes from the Mozilla Firefox developers themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: If we open the [https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSPR/Reference/PR_Write](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSPR/Reference/PR_Write)
    link, we will get more details about the PR function parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PR_Write` is the function name and the purpose of this function is to write
    a buffer of data to the file or socket. You can also see function parameters such
    as `*fd`, `*buf`, and `amount`. If you still remember, in Immunity Debugger, we
    were tracing the memory content each time we get a breakpoint to `PR_ function`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a second parameter, `buf`, will give us a pointer to the memory address
    for the submitted data; in our case, we are looking for the username and password.
    So, all we need to do is resolve the memory address for this pointer. So, let''s
    reflect this in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the three parameters are `arg1`, `arg2`, and `arg3`; we have
    already mentioned `paramCount=3`. We pass them to our `callback` function. As
    we said, our main interest is in the second parameter only, which is again the
    memory pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step we need to do is read the first 1 KB of the memory address for
    that pointer, and this code will do the job for us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Argument 2 contains parameter 2, which is the memory pointer and we will read
    the first KB of that address.
  prefs: []
  type: TYPE_NORMAL
- en: So, at this point, we have completed the rest of the steps mentioned in the
    Firefox process section executing the `callback` function and printing the memory
    dump.
  prefs: []
  type: TYPE_NORMAL
- en: 'When will a debug take care of completing the normal flow? In the previous
    section, using Immunity Debugger, we tried doing that with a Twitter account.
    Let''s try with a PayPal account now:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the PayPal login page and try to retrieve the login info.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the script. Once I log in, notice the output we get.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we enter the wrong credentials, we will get a regret message from PayPal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Interrupt the script and export the output into a text file here. To do this,
    go to File | Save As..., to save the file in text format. Search for the username in
    the text file. If you pay close attention, you will see that we got the login
    email ID as well as the login password, and both of them in clear text. Now, let's
    verify that these are the same credentials that were stored in LastPass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to Sites | Finance | paypal.com then right-click and select Edit. If you
    click on the eye icon beside the Password option, you can see the password which
    will be the same as what we extracted from the Firefox process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before on moving to the next section, keep in mind that intercepting a function
    like `PR_Write` will badly affect the Firefox's process performance, since the
    function will be called frequently. Each time we intercept, this function, it
    will result in a delay and may crash the entire process.
  prefs: []
  type: TYPE_NORMAL
- en: Python in Firefox EXE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will enhance our previous PoC script to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you get a pass in the memory, print out the memory dump and stop debugging
    to minimize performance issues
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export your script into a standalone EXE file, so it can be used in the postexploitation
    phase (using `Py2exe`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test it against antivirus
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try and make sure that it's fully functional by testing it while logging into
    Twitter, Gmail, PayPal, and Facebook accounts
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the callback function, add a new `if` statement to terminate the debugging
    once we get a pass keyword. It's always a good thing before sending this script
    to your target, to test it locally first. To do so, you may need to change the
    setting in the `py2exe` setup file to the console mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the script, we will log in to the Facebook account:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the login page of Facebook. As you will see, LastPass has entered our
    username and password for us.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run our script. You will get the Firefox process ID and the memory address for
    the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we click on the Log In button, notice the credentials that we extracted
    from the memory. You will see the email address and password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's check whether this was really the correct password stored on LastPass.
    To do this, first log out from Facebook and then go to Sites | Social; now, right-click
    on Facebook.com and select Edit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you click on Edit, if you want to see the password value, you can see the
    same that we got from our script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's see whether the same tool and the same technique will work with other
    websites. For this, we will close the Facebook page and go to[ https://www.paypal.com/in/signin](https://www.paypal.com/in/signin) to
    login.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's run our tool and go to the PayPal account. You will see that we get  the
    username and password that we used for the login.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's verify that this is the same password and username stored on LastPass.
    You just need to follow the same process as earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will try the same thing with Twitter by going to the Twitter log in page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tool here as usual, and, once we hit on the Log In button, we can see
    the email ID and the password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we saw earlier, these values are in hexa format, and need to be converted
    into ASCII.
  prefs: []
  type: TYPE_NORMAL
- en: A little reminder that neither the keylogger or  the clipboard hijacking techniques
    that we saw earlier, will work in a similar scenario, and this is because we are
    not typing or pasting any data.
  prefs: []
  type: TYPE_NORMAL
- en: Dumping saved passwords out of Google Chrome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss another password-hacking technique. This technique
    was originally created to recover your password if you forget it. Here we will
    take advantage and hack the saved password remotely. For this attack to work successfully,
    your target should be using Google Chrome, and they should have previously saved
    the login password. Let's look at how this works. Log into your Facebook account.
    You will notice a prompt at the top-right corner of the screen, which asks you
    whether to save the password with a Save password button. If our target has clicked
    on Save password, then we will be able to grab that password remotely.
  prefs: []
  type: TYPE_NORMAL
- en: We will now see how to do that. To do this, we will Log out from Facebook first.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring the password remotely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started by understanding how Google Chrome stores and recovers the
    saved password in the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, the first fact is, we should know that Google Chrome uses the Windows login
    password as a key to do both the encryption and decryption phases. The second
    thing we need to know is that encrypted passwords are stored in a SQLite database
    called Login Data DB and that database is located in the path `C:\Users\%USERNAME%\AppData\Local\Google\Chrome\User
    Data\Default`.
  prefs: []
  type: TYPE_NORMAL
- en: Google Chrome calls a specific Windows API function called `CryptProtectData`,
    which utilizes the Windows login password as an encryption key. In reverse operation,
    a Windows API `CryptUnProtectData` is called to decrypt the password value back
    to clear text. Now let's summarize how Chrome works in saving passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that our target has logged into Facebook for the first time. Google
    Chrome will prompt them to save the password. If they click on Save password,
    then Google Chrome will take this password in a clear-text format and call the `CryptProtectData`
    API, which will encrypt this password using the Windows login password and save
    it in the login data database. Later on, when our target visits the Facebook page
    one more time, Google Chrome will retrieve the encrypted password and pass it
    to the `CryptUnProtectData` API function. After that, we will get the clear text
    password. Then, Google Chrome will submit it on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Now technically, if we code a Python script to grab the encrypted password from
    the Chrome database and pass that value to `CryptUnprotectData` API function,
    then we should be able to see the saved password in a clear text format after
    that; that's exactly what we'll do here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving to the coding part, let''s have a look at the SQL database. Here,
    we will be using a free open source database browser for SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to SQLite, which gets created by Google Chrome. In my case, the path
    is `C:\Users\Hussam\AppData\Local\Google\Chrome\User Data\Default` that Chrome
    creates its database, and we will copy the `Login Data` file to the desktop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have to change the extension to SQLite so that we can import it in the database
    browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So all we have to do right now is click on Open Database and go to the Desktop to
    open `Login Data.sqlite3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we import it, you can see that there is a table called `logins`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we click on Browse Data, we can see some interesting columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '`action_url` is the URL that the user navigated to when submitting the login
    credentials, and in our case, it''s a Facebook URL. The value, or `username_value`
    and the `password_value` are the values of the username and the password that
    have been submitted.'
  prefs: []
  type: TYPE_NORMAL
- en: We need to locate the SQLite database, as the `USERNAME` directory is a variable
    and will be different from one PC to another.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to grab the values of `action_url` and `username_value` and the `password_value`
    columns from that database.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we pass `password_value` to the `CryptUnProtectData` function, or API
    function, to decrypt it back into clear text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, let''s start with the coding part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will start with importing the necessary libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: We will import `getenv`, to resolve the Windows environment variable and find
    out the Google Chrome SQL path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we import SQLite3 to read the Chrome SQLite database and fetch its raw
    values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We import `win32crypt`, which provides a high-level library to call the Windows
    API `CryptUnProtectData`. Keep in mind that, in order to use this library, we
    need to first install the `pywin32` library from [http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/](http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LOCALAPPDATA` is a Windows environment variable, which points to `C:\Users`,
    then `username`, and then the `AppData\Local` path—and that is half of our full
    path. So, once we''ve got this part, all we have to do is append the second part
    of the path by adding `\Google\Chrome\User Data\Default\Login Data` to get the
    absolute path of the `Login Data` database.'
  prefs: []
  type: TYPE_NORMAL
- en: If the target is logging into a site, which has an entry into the database,
    then sometimes reading the Chrome database will return an error that the database
    is locked; and you will get an exception called `database is locked`, once you
    run the Python script. In our example, if the target is logged into Facebook at
    the time that we want to read from the Chrome database, then we want to be able
    to do that. The workaround for this is to make a copy of the login database and
    pull the data out of the copied database. So here, the copied database has the
    name `Login2`, and it's located on the same directory as the original one. And,
    at this point, we have accomplished the first step of locating the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the original database can be locked, we will read data from the copied
    database. We''ll do this using the `sqlite3.connect` function, pointing to the
    copied database path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then, we create a cursor object so that we can execute the SQL queries to pull
    out the desired columns. If you remember, the table name was `login` and it has
    three important columns, which are `username` and `password_value`, along with
    the `action_url`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we''ll select these columns and fetch their values using a `for` loop with
    a `fetchall` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The result will be a list stored in a raw variable. Then, we'll print the first
    two values in this list, which are `action_url` and `username_value`. So, by doing
    that at this point we have achieved the second step of our plan, and we grabbed
    the data out of a Chrome database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step would be to call the `CryptUnProtectData` API function and pass
    the encrypted password, which is by the way stored in the third element of our
    raw list. Finally we''ll print out the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, upon running the module you will see that we get three items: the URL,
    the username, and the clear-text password.'
  prefs: []
  type: TYPE_NORMAL
- en: Try to double-check that these are the correct credentials to log into my Facebook
    account. Also try with other websites like Twitter, PayPal, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting the recovered password over HTTP session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will modify our previous script to automate the submitting
    of the recovered or hacked password over the HTTP session. And then, we will send
    it back to the hacker machine, where the end result should be a standalone file,
    which can be used in post-exploitation or as a function integrated with a new
    Python shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start our HTTP server on the Kali machine to receive the hacked password
    of the target site. We will simply double-click on the Chrome Dumper EXE file.
    You will see that we were able to have the saved password remotely out of a Chrome
    database. Here, we grabbed the Facebook email and password, and also the Twitter
    account. Now, if we move to the target machine, we will see that the following
    are the two sessions that are currently open on the target site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Testing the file against antivirus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using the well-known website, VirusTotal, and will upload our Google
    Dumper file.
  prefs: []
  type: TYPE_NORMAL
- en: For this, navigate to our `Chrome Dumper` file and Upload and scan file. Upload
    the `Chrome Dumper` file and scan the content.
  prefs: []
  type: TYPE_NORMAL
- en: You will see how many antivirus could raise a flag. Now, I would say that we
    got a fair result if the number of antivirus raised is few, and if anybody can
    try and compile the script using `PyInstaller` and test it, then they could have
    a different result.
  prefs: []
  type: TYPE_NORMAL
- en: Password phishing – DNS poisoning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the easiest ways to manipulate the direction of the traffic remotely
    is to play with DNS records. Each operating system contains a host file in order
    to statically map hostnames to specific IP addresses. The host file is a plain
    text file, which can be easily rewritten as long as we have admin privileges.
    For now, let's have a quick look at the host file in the Windows operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows, the file will be located under `C:\Windows\System32\drivers\etc`.
    Let''s have a look at the contents of the `host` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you read the description, you will see that each entry should be located
    on a separate line. Also, there is a sample of the record format, where the IP
    should be placed first. Then, after at least one space, the name follows. You
    will also see that each record's that the IP address begins first, then we get
    the hostname.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the traffic on the packet level:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Wireshark on our target machine and start the capture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Filter on the attacker IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have an IP address of `10.10.10.100`, which is the IP address of our attacker.
    We can see the traffic before poisoning the DNS records. You need to click on
    Apply to complete the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open [https://www.google.jo/?gws_rd=ssl](https://www.google.jo/?gws_rd=ssl).
    Notice that once we ping the name from the command line, the operating system
    behind the scene will do a DNS lookup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will get the real IP address. Now, notice what happens after DNS poisoning.
    For this, close all the windows except the one where the Wireshark application
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that we should run as admin to be able to modify the host file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, even though we are running as an admin, when it comes to running an application
    you should explicitly do a right-click and then run as admin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory where the `hosts` file is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `dir` and you will get the `hosts` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `type hosts`. You can see the original host here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will enter the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`10.10.100`, is the IP address of our Kali machine. So, once the target goes
    to `google.jo`, it should be redirected to the attacker machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Once again verify the host by executing `type hosts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, after doing a DNS modification, it''s always a good thing to flush the
    DNS cache, just to make sure that we will use the updated record. For this, enter
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, watch what happens after DNS poisoning. For this, we will open our browser
    and navigate to [https://www.google.jo/?gws_rd=ssl](https://www.google.jo/?gws_rd=ssl).
    Notice that on Wireshark the traffic is going to the Kali IP address instead of
    the real IP address of `google.jo`. This is because the DNS resolution for `google.jo`
    was `10.10.10.100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will stop the capturing and recover the original `hosts` file. We will then
    place that file in the `drivers\etc` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s flush the poisoned DNS cache first by running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Then, open the browser again. We should go to [https://www.google.jo/?gws_rd=ssl](https://www.google.jo/?gws_rd=ssl)
    right now. Now we are good to go!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Python script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we'll automate the steps, but this time via a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the script and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we will do is change our current working directory to be the
    same as the `hosts` file, and that will be done using the `OS` library. Then,
    using subprocesses, we will append a static DNS record, pointing Facebook to `10.10.10.100`:
    the Kali IP address. In the last step, we will flush the DNS record. We can now
    save the file and export the script into EXE.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we need to make the target execute it as admin. To do that, in
    the setup file for the `py2exe`, we will add a new line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, we have added a new option, specifying that when the target executes the
    EXE file, we will ask to elevate our privilege into admin. To do this, we will
    require administrator privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Let's run the setup file and start a new capture. Now, I will copy our EXE file
    onto the desktop. Notice here that we got a little shield indicating that this
    file needs an admin privilege, which will give us the exact result for running
    as admin. Now, let's run the file. Verify that the file host gets modified. You
    will see that our line has been added.
  prefs: []
  type: TYPE_NORMAL
- en: Now, open a new session and we will see whether we got the redirection. So,
    let's start a new capture, and we will add on the Firefox. As you will see, the
    DNS lookup for `google.jo` is pointing to our IP address, which is `10.10.10.100`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how we can take advantage of this for password
    phishing.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook password phishing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have seen that with a few lines of Python code we
    can redirect traffic to the attacker machine instead of going to [https://www.google.jo/?gws_rd=ssl](https://www.google.jo/?gws_rd=ssl).
    This time, we will see how an attacker can take advantage of manipulating the
    DNS record for Facebook, redirect traffic to the phishing page, and grab the account
    password.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to set up a phishing page.
  prefs: []
  type: TYPE_NORMAL
- en: You need not be an expert in web programming. You can easily Google the steps
    for preparing a phishing account.
  prefs: []
  type: TYPE_NORMAL
- en: To create a phishing page, first open your browser and navigate to the Facebook
    login page. Then, on the browser menu, click on File and then on Save page as....
    Then, make sure that you choose a complete page from the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output should be an `.html` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's extract some data here. Open the `Phishing` folder from the code files
    provided with this book. Rename the Facebook HTML page `index.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this HTML, we have to change the login form. If you search for `action=`,
    you will see it. Here, we change the login form to redirect the request into a
    custom PHP page called `login.php`. Also, we have to change the request method
    to `GET` instead of `POST`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see that I have added a `login.php` page in the same `Phishing` directory.
    If you open the file, you will find the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As soon as our target clicks on the Log In button, we will send the data as
    a `GET` request to this `login.php` and we will store the submitted data in our
    `passwords.txt` file; then, we will close it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create the `passwords.txt` file, where the target credentials
    will be stored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will copy all of these files into `\var\www` and start the Apache services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we open the `index.html` page locally, we will see that this is the phishing
    page that the target will see.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's recap really quickly what will happen when the target clicks on the Log
    In button? As soon as our target clicks on the Log In button, the target's credentials
    will be sent as `GET` requests to `login.php`. Remember that this will happen
    because we have modified the action parameter to send the credentials to `login.php`.
    After that, the `login.php` will eventually store the data into the `passwords.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, before we start the Apache services, let me make sure that we get an IP
    address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that we are running on `10.10.10.100` and we will also start the
    Apache service using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify that we are listening on port `80`, and the service that is listening
    is Apache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's jump to the target side for a second.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous section, we have used `google.jo` in our script. Here, we have
    already modified our previous script to redirect the Facebook traffic to our attacker
    machine. So, all our target has to do is double-click on the EXE file. Now, to
    verify:'
  prefs: []
  type: TYPE_NORMAL
- en: Let us start Wireshark and then start the capture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will filter on the attacker IP, which is `10.10.10.100`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the browser and navigate to [https://www.facebook.com/](https://www.facebook.com/):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once we do this, we're taken to the phishing page instead. Here, you will see
    the destination IP, which is the Kali IP address. So, on the target side, once
    we are viewing or hitting [https://www.facebook.com/](https://www.facebook.com/),
    we are basically viewing `index.html`, which is set up on the Kali machine. Once
    the victim clicks on the login page, we will send the data as a `GET` request
    to `login.php`, and we will store it into `passwords.txt`, which is currently
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, log into your Facebook account using your username and password. and jump
    on the Kali side and see if we get anything on the `passwords.txt` file. You can
    see it is still empty. This is because, by default, we have no permission to write
    data. Now, to fix this, we will give all files full privilege, that is, to read,
    write, and execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that we made this, since we are running in a VirtualBox environment. If
    you have a web server exposed to the public, it's bad practice to give full permission
    to all of your files due to privilege escalation attacks, as an attacker may upload
    a malicious file or manipulate the files and then browse to the file location
    to execute a command on his own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after giving the permission, we will `stop` and `start` the Apache server
    just in case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: After doing this modification, go to the target machine and try to log into
    Facebook one more time. Then, go to Kali and click on `passwords.txt`. You will
    see the submitted data from the target side, and we can see the username and the
    password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the end, a good sign for a phishing activity is missing the `https` sign.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will discuss how to protect yourself and secure
    your account from these attacks. Also, you need to make sure to turn off your
    Apache server once you're done with your assessment.
  prefs: []
  type: TYPE_NORMAL
- en: Countermeasures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss four methods that you can use to secure your
    online account. Note that these are not the only available methods. However, following
    these steps should give your account a fair level of security.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the online account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, let's start with using the security services provided by the vendor. I really
    recommend to enable Step 2 authentication (or sometimes called one-time password)
    on all of your accounts such as Gmail, LinkedIn, and PayPal whenever this option
    is available. And when you do so, once you decide to log in, it'll ask you for
    the username and password. And the second step is to enter the one-time password,
    which you will usually get via an SMS or application, or even by email. Now, this
    one-time password will be valid only for 30 seconds or less.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are few links which guide you on how easy and powerful it is to enable
    this feature for some services such as Gmail, Twitter, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gmail provides SMS and Gmail mobile app:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.google.com/landing/2step/](https://www.google.com/landing/2step/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&hl=en](https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&hl=en)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Twitter provides mobile app and SMS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://support.twitter.com/articles/20170388](https://support.twitter.com/articles/20170388)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Before moving to the next point, I need to mention that even after enabling
    Step 2 authentication, we're still vulnerable to session hijacking vulnerability,
    where an attacker can hijack the session or the cookies after Step 2 authentication,
    and reinject that session on his own. One more thing you want to pay attention
    to is the login. Each time a new device is logged in your account, you will get
    a notification message, by email most likely, to inform you with this strange
    access.
  prefs: []
  type: TYPE_NORMAL
- en: And it will give you some kind of information such as the operating system or
    the timestamp. The preceding screenshot shows the Windows operating system, that
    has newly signed to your account. Also, it will advise you what to do if this
    was a suspicious activity.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, you need to make sure that your password itself should be complex
    enough, and try to avoid trivial and weak passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your computer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now see how to secure your own device. When it comes to computers,
    the following are the steps you need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a nonadmin account all the time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep your browser and system updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the countermeasures we discussed in the previous section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing your network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's see how to secure your own network to protect your data in transit.
    If you have to use untrusted network, such as a cafe Wi-Fi, to access your sensitive
    data such as your bank account or PayPal account, then you should use a trusted
    VPN to establish a secure tunnel and prevent local LAN attacks. No doubt that
    VPN will add values such as authentication and encryption, which will be used
    to defeat local LAN attacks such as man-in-the-middle attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping a watch on any suspicious activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's see how to keep your eyes open on anything abnormal on the login
    page, such as a missing https in the URL field is a good indicator for phishing
    activity, where the attacker can redirect your traffic to a malicious login page;
    or if the attacker is in between, like man-in-the-middle attack, he can use a
    tool such as SSL strip to strip off the SSL encryption and turn your data into
    clear text.
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you are a security paranoid person, even if you see the `https` label
    in green, you can double-check the certificate status that you got from the website.
    For instance, this is a screenshot of a Facebook server certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that it's issued to all Facebook domain, and we can see that the
    issuer is DigiCert.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the certificate path will show us the health status for this certificate;
    and if there is any sub-CA or subcertificate authority and intermediate certificate
    in between.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we should be really careful on sites that your browser shows a certificate
    error before showing the login page, as an attacker could set up a proxy server
    and provide you with a fake certificate to intercept the traffic during a man-in-the-middle
    attack. Each browser may show you a different notification for this certificate
    error.
  prefs: []
  type: TYPE_NORMAL
- en: For scam emails, keep in mind that no one should ask you about your password
    over email, or even post a login link to you by email.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to configure a keylogger and also dealt with password
    manager to securely store the device credentials. We also learned about a new
    method—Man in the Browser. Further, we saw the process of Firefox API hooking
    with Immunity Debugger and performed the password phishing process.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we discussed the countermeasures on how to protect yourself and
    secure your account from the attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will set up our own hacking environment in VirtualBox.
  prefs: []
  type: TYPE_NORMAL
