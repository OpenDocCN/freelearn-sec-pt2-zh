- en: Catch Me If You Can!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's world, bypassing and hijacking software is all over the internet.
    However, clear usage and execution is what makes you a good amateur hacker.
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved by choosing your tools correctly and following the necessary
    processes to complete the tasks at hand impeccably.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics to help you achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing host-based firewalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hijacking IE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing repudiation filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with SourceForge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with Google Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing botnet filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing IPS with handmade XOR encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing host-based firewalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all our previous chapters, we assumed that any process on the target machine
    can initiate a session to the internet without any restrictions. Now, in many
    enterprise networks, they don't rely on the built-in Windows Firewall. Instead,
    they use an advanced host-based firewall to limit what process can initiate a
    session to the internet, just like how the access lists work. So, for instance,
    let's assume that the system administrator has allowed only some business-needed
    processes to access the internet. For example, let's say that the system administrator
    allowed the Windows update and the antivirus update, as well as the most common
    browsers, such as Chrome, Internet Explorer, and Firefox. So, only these processes
    are allowed to reach over the internet; any other process will be blocked. By
    implementing such a policy, our backdoor has no chance to survive since it won't
    be listed in the administrator list by default. Eventually, we don't get any shell
    to the attacker machine.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we find a way to somehow control **Internet Explorer** (**IE**)
    on our behalf using our Python script and then force it to connect to our Kali
    HTTP server in the background and transfer commands back and forth, then we can
    bypass the host-based firewall policy here. Microsoft offers **Component Object
    Model** (**COM**) to enable interprocess communication and programmatically create
    an object to control and automate multiple Microsoft products, such as Outlook,
    Internet Explorer, Word, and Excel. Internet Explorer is a built-in browser in
    all Windows versions; so, it should be available all the time in our target and
    is usually whitelisted to security administrators as it is considered as a backup
    browser in case other browsers fail. Another benefit of making Internet Explorer
    initiate the connection on our behalf is if the target was using an internal proxy
    before connecting to the internet, then you don't have to worry about knowing
    the proxy information as Internet Explorer will take care of this on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: So, what we'll do here is we'll assume that the host-based firewall only allows
    some process such as antivirus, Firefox, Internet Explorer, or Windows Update,
    and nothing else. In response to this, in our Python script, we will define a
    COM object to control Internet Explorer. Then, we will make Internet Explorer
    navigate to our HTTP server, which is located on the Kali machine, and get the
    command to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get the command that we need to execute, we will initiate a subprocess.
    We retrieve the command to EXE. Then, using the COM object, we will take it back
    using our Python script and initiate the `cmd.exe` as a subprocess. The result
    for the command, using the COM object we will pass it to Internet Explorer and
    then post it to our website, which is located on the Kali machine here. If you
    remember, this technique is very similar to our previous HTTP reverse shell, but
    the key difference here is that we use Internet Explorer as our web client instead
    of using the `requests` library, as we did earlier. The end result, from the host-based
    firewall's perspective, is that the Python script did not initiate any session
    to the outside world, it was Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: The following link will provide more insight on COM protocol:  [http://claudihome.com/html/LR/WebHelp/Content/VuGen/132800_click_and_script.htm.](http://claudihome.com/html/LR/WebHelp/Content/VuGen/132800_click_and_script.htm)
  prefs: []
  type: TYPE_NORMAL
- en: Hijacking IE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As always, coding with Python will make your life much easier. Now, to use
    COM in Python, you just need a Python for Windows or `pywin` library. Since we''ve
    already installed this library while creating our previous key-logger, we won''t
    cover that again here. Now, let''s jump to the coding part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we start by creating an `InternetExplorer` object instance and set the
    Visible option to 0, which means that Internet Explorer will run in the background.
  prefs: []
  type: TYPE_NORMAL
- en: If we set the value to 1, then Internet Explorer window will show up to the
    target desktop and this is something we don't want.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, we start by going into an infinite loop, and navigate to our Kali IP address.
    We will wait for the browser to finish loading. If the browser doesn't load the
    page entirely, we will sleep for one second. Note that, when the browser has finished
    loading, `ReadyState` will have a value of `4` and the second loop will be terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we retrieve the HTML page into a variable called `command`; then, we convert
    the HTML entities into `unicode`. Finally, we encode the command into ASCII string
    and ignore any exception, which may have occurred while doing so. The final result
    will be the command that we should execute and we will print it out. As with our
    previous shells, if we get a `terminate` command from the Kali machine, we will
    quit Internet Explorer instance and `break` the loop. If the command was not terminated,
    then we inject the command into a shell and store the result in a variable called
    `Data`. Now, in order to submit or post the `Data` using the COM technique, it
    requires to `buffer` the `Data` first, and we used a built-in Python `buffer()`
    function to do so. Then, at the end, we post the command execution result along
    with the `POST` parameters, which we defined earlier. We have never used `Flags`
    or `TargetFrame`, so we set them to their default values. The main parameter here
    is the `dURL`, which defines the destination URL that we wish to submit the data
    for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump to the attacker side a little bit and here we had the exact HTTP
    web server that we used earlier in our HTTP reverse shell. After starting the
    script on the target side, Internet Explorer will start in the background, as
    we can see from the Windows Task Manager''s Processes tab in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it''s totally invisible to the user. The IE is running, but
    as we can see, the GUI is not showing up in the Applications tab. On executing `ipconfig`
    on the Kali machine, at the victim side, we get the `ipconfig` command. Let''s
    go for directories and other commands. You can also perform a quick `ping 10.10.10.100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The outputs will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We got our shell fully functional here. So, one more time, let''s just explain
    what just happened here:'
  prefs: []
  type: TYPE_NORMAL
- en: Our Python script has initiated an Internet Explorer process in the background
    and we have used Internet Explorer to navigate to our command and control the
    server on the Kali side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we transferred the data using `GET` and `POST` back and forth between
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, at the end, note that it's not only limited to a shell. You can also transfer
    files and submit data using COM protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will leave it to you to discover the other features that you can do with
    a COM protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypassing reputation filtering in next generation firewalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next-generation firewalls are all-in-one firewalls. They have all the security
    features, such as IPS, antivirus, anti-spam, and reputation filtering, in a single
    box. In this section, we will discuss a major security feature, which can prevent
    us from getting our shell on our target. Now, let's assume that we were able to
    plant our Python reverse shell successfully on our target machine. Now, in a traditional
    firewall, if the **access control list** (**ACL**) was allowing the traffic to
    the outside, then we will get our shell back successfully. But if the firewall
    was doing reputation filtering, then what will happen is that once the client
    initiates a session back to our Kali machine and reaches the firewall, the firewall
    will do a lookup and check on the destination IP. Then, it checks whether the
    destination IP belongs to a malicious site. This checking is based on an IP pool,
    which is a list of an IP that the firewall will download from the vendor database.
    So, if this is a Cisco firewall, it will use a Cisco database. If this firewall
    was a Palo Alto, it would use a Palo Alto pool. This database or a pool contains
    a large list of IPs with its reputation rank.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say in the IP or in the database we have an IP of `1.1.1.1`
    and it has a rank of `10`, which means it can totally be trusted. Also, we have
    an IP of `2.2.2.2`, which has a low rank of `2`. This means that it has been reported
    as a malicious IP. Let's say that the attacker IP address was `3.3.3.3`. When
    the initiated session reaches the firewall with the destination IP address of
    `3.3.3.3`, if this IP was not whitelisted and has a low rank in the IP database,
    then the firewall will drop the traffic and log the decision to the administrator.
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is to use a server or website such as Google Forms to submit a
    text or maybe to use SourceForge to upload the files. The benefit of doing so
    is, firstly, these two servers or services are very well-known and have a high
    reputation rank out of `10`. So, we are expecting to see [https://www.google.com](https://www.google.com)
    or Google Forms in the IP pool or on the IP database with a rank of `10`. Secondly,
    it may have never been flagged as suspicious to the security administrator or
    to anyone watching the traffic in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with SourceForge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how easily we can upload files to SourceForge.
    SourceForge is usually whitelisted from the reputation filtering perspective and
    probably never looked by security administrators. SourceForge provides multiple
    ways to interact with its repository. We will be using SCP, which is transferring
    the file over an SSH session. Now, creating an account in SourceForge is easy
    and hence we will skip this part. Before we start, take a minute and read the
    SourceForge documentation for using SCP and the format needed, [https://sourceforge.net/p/forge/documentation/SCP/](https://sourceforge.net/p/forge/documentation/SCP/).
    I'll log into my account, which I have already created and proceed to my profile.
    There, I have created a project called `Test` with zero files currently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go to the coding part right now. We will be using two libraries to get
    our job done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first library is `paramiko`.  `paramiko` is a Python implementation of the
    SSHv2 protocol, providing both client and server functionality. The `scp` is a
    higher library built over `paramiko` that is used to transfer the file in just
    a matter of a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Before using any of these libraries, a prerequisite library called `PyCrypto` has
    to be installed first from [http://www.voidspace.org.uk/python/modules.shtml#pycrypto](http://www.voidspace.org.uk/python/modules.shtml#pycrypto). The
    steps are rather straight forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to install `paramiko` using the `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The last step is to install the `scp` library. If you face any problems with
    the library setup script, simply copy the library manually into Python site-packages
    directory. Simply paste the scp script by navigating to Python27 | Lib | site-packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets look into rest of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, our script will start with creating an `ssh_client` instance using the `paramiko.SSHClient()`
    class. Now, when you connect to an SSH server for the first time and if the SSH
    server keys are not stored on the client side, you will get a warning message
    saying that the server keys are not cached in the system; it will prompt you to
    accept these keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open PuTTY software, connect to the SourceForge server with `web.sourceforge.net`
    as the hostname, port `22`, and protocol SSH. Now, click on Open:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will get a warning pop up because the keys are not cached in the system.
    Now, since we perform an automation, we will inform `Paramiko` to accept these
    keys for the first time without interrupting the session or prompting the user
    for it. This will be done via  `client.set_missing_host_key_policy`, then `AutoAddPolicy()`.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in the code block is to define the SourceForge server name that
    we want to connect and upload our file to. Also, we provide the login credentials.
    After providing `username` and `password`, we will authenticate ourselves to the
    SourceForge server. After a successful authentication, the SSH session ID will
    be passed to the `SCPClient()` function and the `get_transport()` function will
    return the session ID for us. Now, after performing this step, all we have to
    do is specify the file path that we want to exfiltrate and upload it to our repository.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I have used Module 5 or the `M5.pdf` file. So, we will use
    the `put()` function from the SCP to perform the upload and in the end we will
    close the session using the `.close()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the script, we will get a successful authentication message as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s jump to the attacker side and verify that we got the file. First,
    install FileZilla FTP client to access our repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the software by running `filezilla` and enter the name of the server/hostname,
    username, password, and port number, as entered previously in the script to log
    into your account. A warning message will be presented because we have logged
    in for the first time, and if we scroll a little bit we can see that we got our
    file. `M5` has been uploaded here successfully as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Try to download this file by right-clicking on the filename and selecting Download.
    The console prints that the file has been transferred successfully in the absence
    of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Now, repeat the preceding steps for a `.txt` extension to check whether you're
    successful. Refresh the attacker side and view the contents. Make sure to remove
    the files from your SourceForge repository once the penetration testing assessment
    is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Google Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we have seen how we can exfiltrate data into the SourceForge
    website. Now, we will use Google Forms to submit normal text. Note that this text
    could be a command execution output for our shell. The point here is, similar
    to SourceForge, Google Forms has a pretty high reputation rank. Follow these steps
    to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to Google Forms
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Google form by clicking Start a new form
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the Question as `Isn't Python awesome?`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Response tab keep the default name for the spreadsheet
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change type of the Question to Paragraph from the default Multiple choice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the form is created, click on Send
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the link that is provided to a Notepad or a text file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the link we copied and submit a trivial text
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the response in the Google Sheet that we created, which will be in your
    Google Drive by this time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will code a Python script that will submit text data from the target
    side into our Google Form and the best part here is that we can accomplish that
    without having to log in into a Google account. Now, as usual, the best Python
    library to interact with web is `requests`and we have used `requests` in the previous
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, the installation is quite easy: it''s just `pip install requests`.
    Now, what we see here is the `requests` documentation for submitting an HTML form-encoded
    `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, as per the documentation, we first define the URL for the submit form and,
    in our case, it's the Google form URL. And the second parameter is our data in
    a dictionary format, where we have a `key` and a corresponding value. Keep in
    mind that the `key` is the form name and its value is our text data that we want
    to send.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump to our Google form link to discover the form name, which will be
    our `key` in the dictionary. Open the source code of the form that we created
    and, in HTML, search for the `Python` string. If you take a close look, you will
    catch the HTML form name for submitting a text. In our case, the form name which
    comes as the value of `<textarea name>` is `entry.1542374001`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00054.gif)'
  prefs: []
  type: TYPE_IMG
- en: At this point, we have discovered the `key` name, which is what we need to automate
    the process. Remember that the value is the data that we want to send or submit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the form name on a Notepad file for now. Then, we have to go to the previous `Interacting
    with Google Forms` script and fill this information over there. First copy, the
    URL of the form and assign it to the `url` variable below the `import requests`
    line and, at the end, append `/formResponse` after removing the `/viewform` part
    from the URL. Put the form name, `entry.1542374001` , as the key and the data
    for now will be `Hello From Python`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Save the script. At this point, we have everything in place. Let's run the script
    and if everything is working fine as expected, we should see `Hello From Python`
    added in our form response.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how we can use this script in real world penetration
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing botnet filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have read the previous sections in order, then at this point you should
    be able to grab a command over Twitter without the need to log into Twitter and
    submit a text into a Google form, also without logging into the Google account.
    Lastly, you should be able to upload files to SourceForge. So, you might be asking:
    what can a hacker do with these services?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, they can send a command such as `ipconfig` as a tweet and then they can
    make multiple infected targets to parse the tweet and execute the commands. After
    executing the commands, we get the execution results, which can be submitted to
    a Google form. Alternatively, if the command syntax or format was containing the
    `grab` keyword, then the target will upload the files into our SourceForge repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in modern firewalls, the botnet filtering feature is looking for a certain
    criteria or parameter, like the application or protocol being used by the modern
    botnets such as IRC, Dynamic DNS, as well as the number of sessions created from
    the inside to the outside host. All of these will be considered by the modern
    or next-generation firewall to check whether this traffic belonged to a botnet
    or not. Also, there is no need to mention that the reputation filtering is also
    a part of these inspections and filtering.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits for building a botnet based on well-known servers are that first,
    we don't use IRC channels or Dynamic DNS. Next, we don't have to interact or have
    a direct interaction with the attacker machine. The last point is that all of
    these servers or services are well known and trusted.
  prefs: []
  type: TYPE_NORMAL
- en: If you do abuse these services and use them out of the lab environment, you
    are violating the terms and agreement, and eventually you will be prosecuted to
    the full extent of law accordingly as per the jurisdiction prevalent in the concerned
    region.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that my point here is to open your eyes to similar types of attacks,
    so you can be aware of them. So, what I want you to do is challenge yourself and
    try to combine and squeeze all of these scripts into one advanced shell and then
    try to infect multiple virtual machines running Windows 7 within your home lab
    environment. After that, or finally, you will be able to control them and exfiltrate
    data. The last point which we didn't mention up to this section is the encryption.
    In the next section, we will see how easily to build XOR encryption and mask our
    clear-text traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing IPS with handmade XOR encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will build a simple XOR encryption in Python. Now, traffic
    encryption is one of the most powerful techniques to evade network analyzer or
    IPS sensors but first, before jumping into the coding part, let's have a quick
    overview on how these devices work in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, these devices can operate in two modes: the first mode,
    which is the **signature-based mode**, where it inspects the packet parameters
    and data payloads, which are passing through the sensor. Then, similar to an antivirus,
    it checks whether there is any match against its signature database and based
    on the action specified for the matched rule, it may drop or log the traffic.
    The second mode is **behavior-based** or **anomaly-based**, where you install
    the IPS in the network and it will learn the types of the protocol, as well as
    the packet rate passing through the sensor. Then, it''ll build its database or
    its baseline database based on the current network traffic.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in a network, let's say that we have 50 PCs that usually use SSH
    to access a remote server. If the IPS is behavior-based, it will learn that on
    average we have 50 SSH sessions and it will create a baseline for this. Later
    on, if any PC has used Telnet, then the IPS will consider this protocol as a suspicious
    activity and may drop the bucket. Although the Telnet session is a legitimate
    one, but since the IPS during the learning phase did not notice any Telnet session,
    it won't be included in the IPS baseline and this incorrect behavior is called
    **false positive**. This is why behavior-based IPSes are not frequently used due
    to these false positives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will code a very simple XOR encryption to mask our data payload. You''re
    probably thinking: why an XOR encryption? Why not create a SSH or HTTPs shell,
    since these protocols provide encryption by design? Well, I do not recommend this
    because, in many enterprise networks, you may find your target has installed a
    decryption device where it can terminate the SSL and SSH. So basically, once the
    traffic comes into this device, it will convert or remove the encryption from
    these protocols and convert it into clear text before passing it to the IPS sensor
    for inspection. Technically, you won''t have an end-to-end encryption shell and
    if you shall face this decrypter device, you won''t have any added value.'
  prefs: []
  type: TYPE_NORMAL
- en: Many modern firewalls or next-generation firewalls can terminate the SSL and
    SSH encryption for inspection purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump to the coding part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look into the first section. We will generate a random key, which will
    be used for XOR encryption. Now, our key should be complex enough and match the
    following criteria: it should contain lowercase, uppercase, digits, and special
    characters here. Now, the `for` loop at the end defines the key size. The key
    size is 1 KB, which, if you remember in our TCP shell, matches the TCP socket
    size. The empty string `.join` at the start will put the result for the random
    strings into a sequence and finally, we will store it in a `key` variable. So,
    all in all, the `for` loop will generate `1024` random strings, which match our
    criteria, and the `.join` is used to gather these strings into a sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On running the code, a key for length `1024` will be generated that we can
    use for encryption. If you run the script one more time, you will get a totally
    different key with the same size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second part of XOR encryption, keep in mind that the key size should
    be equal to or greater than the clear-text message. We will pass two values to
    the dedicated function `str_xor()`. The first parameter, `s1`, is the message
    that we want to encrypt or decrypt and the second parameter, `s2`, is the XOR
    key. Notice that the same `key` is used for both the encryption and decryption
    processes. Also, the message could be the encrypted message that we want to decrypt
    or the clear-text message that we want to encrypt. So, the XOR operation is exactly
    the same when we encrypt or decrypt. The only difference is that when we encrypt,
    we pass the message in a clear text and when we want to decrypt, we pass the encrypted
    message. The following line from the `XOR Encryption` script does both the XOR
    encryption and decryption for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, first, we split the message and the XOR key to a list of character pairs
    in a tuples format. Next, we will go through each tuple and convert them into
    integers using the `ord()` function. Now, once they're converted into integers,
    we can perform an exclusive XOR on them. Then, in the last part, we will convert
    the result back to ASCII, using the character or the `chr()`, function. In the
    end, we will merge the resulting array of characters as a sequence, using the
    `.join()` function here. So, in summary, we will print the clear-text message
    then the encrypted version, and finally, the decrypted one.
  prefs: []
  type: TYPE_NORMAL
- en: After running the script, you'll see in the output the XOR key, the message
    that we passed, the encrypted message, and the decrypted message.
  prefs: []
  type: TYPE_NORMAL
- en: Each time we run the script, a new key will be generated and hence a new encrypted
    message will show up.
  prefs: []
  type: TYPE_NORMAL
- en: Once you generate your XOR key, make sure that the same key is hardcoded into
    your Kali server script and the Windows backdoor; otherwise, you won't be able
    to decrypt your messages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered a wide range of topics ranging from bypassing
    firewalls to interacting with websites. We've performed these tasks after usage
    of various tools and different methodologies, which enabled us to attack the victim
    machine with our attacker machine or encrypt and decrypt our messages.
  prefs: []
  type: TYPE_NORMAL
- en: In this next chapter, we'll cover privilege escalations pertaining to weak service
    file permissions, preparing vulnerable software, breaching legitimate windows
    service via a backdoor, and creating a new admin account.
  prefs: []
  type: TYPE_NORMAL
