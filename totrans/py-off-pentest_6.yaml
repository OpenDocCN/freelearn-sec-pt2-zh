- en: Abuse of Cryptography by Malware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will protect our tunnel with something more solid than a
    simple XOR, as modern malware is using a well-known ciphering algorithm to protect
    its traffic in the transit path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to encryption algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting your tunnel with AES – stream mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting your tunnel with RSA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid encryption key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to encryption algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll have a quick overview of the most common encryption algorithms
    in the cryptography world. Basically, there are two types of encryption algorithms.
    The first one is called **symmetric** and the second one is called **asymmetric**.
    Now, this classification is made based on the number of needed keys and how they
    are operated. Let's discuss the difference between these algorithms a little bit,
    and we will start with the symmetric one.
  prefs: []
  type: TYPE_NORMAL
- en: Now, symmetric encryption uses one key for both the encryption and the decryption
    process and this key is shared on both the client and the server side. Now, the
    most common examples of symmetric encryption are AES, Blowfish, RC4, and Triple
    DES. In asymmetric encryption, we have the concept of the key pair, where we have
    a key called **public** key that is used for encryption and we have a **private**
    key that is used for decryption. Now, the key name implies that the public key
    can be published over the untrusted network like the internet and doing so will
    cause no harm. On the other hand, the private key should never leave the operating
    system or the machine that is intended to decrypt the data. If the private key
    is leaked out of the operating system, then anybody who has that private key can
    decrypt the traffic.
  prefs: []
  type: TYPE_NORMAL
- en: The client or the target has to generate his/her own key pair and the server
    or the attacker has to generate his own keys. Now, after generating the key pair
    on each side, the operation will be as follows. The client will hold his own private
    key, and the server's public key. On the other hand, the server will hold his
    own private key and the client's public key. So, to quickly recap, after switching
    over, at this point on the Kali side we have our own private key and the target's
    public key. Also, on the target side, we have our own private key and we also
    hold the Kali public key. So, reflecting this to our shell, when we get a reverse
    shell prompt to enter our command to be executed, such as `ipconfig` it will be
    encrypted using the client's public key and we will send it over the tunnel.
  prefs: []
  type: TYPE_NORMAL
- en: When we enter `ipconfig` in the shell prompt, before sending over the `ipconfig`
    in a clear text, we will use the target's public key to encrypt this message and
    we will send it over the tunnel. No matter who's watching that traffic, only the
    client can decrypt it, and that's because only the client is the one who holds
    the private key. Using the target private key, we will decrypt the command and
    revert it to clear text, which is again, the `ipconfig` command. Now, when the
    client executes the `ipconfig`, instead of sending the output in clear text, the
    output will be encrypted using the server or Kali public key and we will send
    it over the tunnel. Now, on the Kali side, once we get the encrypted message,
    we will pass it over to our private key, which will be used to decrypt the traffic
    or to decrypt the message and print it out in clear text. Now, the last thing
    I should mention about asymmetric encryption are the most common examples of this
    algorithm, which are the RSA and **Pretty Good Privacy** (**PGP**).
  prefs: []
  type: TYPE_NORMAL
- en: There are certain advantages and disadvantages to both methods. The asymmetric
    algorithm is considered hard to break, more solid, and more secure than the symmetric
    one. However, it requires more processes and is much slower than the symmetric
    one. So, the question is, can we create a hybrid system or hybrid algorithm that
    can take advantage of both the symmetric and asymmetric systems? The answer is
    yes.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the asymmetric algorithm to securely transfer a random and complex
    key. Now, this key will be used later on to encrypt our transfer data using symmetric
    algorithm. So, basically, here's the deal. The Kali machine will hold the target's
    public key, then we will generate symmetric key on the Kali side. Now, we will
    take advantage of the asymmetric public key of the target side and we will use
    it to encrypt the generated symmetric key and send it over to the target side.
    Now, the target will decrypt the symmetric key using its private key.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the target private key to export or to decrypt the symmetric key
    here. So, at this point, we can use this symmetric key for our tunnel encryption.
    Now, once we have securely transferred the symmetric key, we can use it to encrypt
    each command or output going through this tunnel. So, to recap really quickly,
    as soon as the target initiates a session back to us on the Kali side, we will
    generate the symmetric key. Now, to securely transfer this symmetric key, we will
    encrypt it using the target's public key, and send it over. On the target side,
    we will decrypt that message and extract the symmetric key one more time. At this
    point, we have the symmetric key on both ends. Now, we can securely transfer our
    commands back and forth using the symmetric key. The last thing we should talk
    about are the benefits for using a hybrid method, which are, first, we keep our
    generated symmetric key secure by transferring it securely over the internet.
    Second, keep in mind that this is a randomly generated key and will be changed
    on each connection. Instead of hardcoding the key on both sides or on both ends,
    the key will change per connection. Moreover, we can change the key whenever we
    want. So for example, in VPN IPSEC protocol you can set a criteria where you can
    change the encryption key after a certain amount of time or after consuming a
    certain bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting your tunnel with AES – stream mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will protect our TCP tunnel with AES encryption. Now, generally
    speaking, AES encryption can operate in two modes, the **Counter (CTR) mode encryption**
    (also called the **Stream Mode**) and the **Cipher Block Chaining (CBC) mode encryption**
    (also called the **Block Mode**)**.**
  prefs: []
  type: TYPE_NORMAL
- en: Cipher Block Chaining (CBC) mode encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Block Mode** means that we need to send data in the form of chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For instance, if we say that we have a block size of 512 bytes and we want to
    send 500 bytes, then we need to add 12 bytes additional padding to reach 512 bytes
    of total size. If we want to send 514 bytes, then the first 512 bytes will be
    sent in a chunk and the second chunk or the next chunk will have a size of 2 bytes.
    However, we cannot just send 2 bytes alone, as we need to add additional padding
    of 510 bytes to reach 512 in total for the second chunk. Now, on the receiver
    side, you would need to reverse the steps by removing the padding and decrypting
    the message.
  prefs: []
  type: TYPE_NORMAL
- en: Counter (CTR) mode encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s jump to the other mode, which is the **Counter (CTR) mode encryption**
    or the **Stream Mode**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, in this mode, the message size does not matter since we are not limited
    with a block size and we will encrypt in stream mode, just like XOR does. Now,
    the block mode is considered stronger by design than the stream mode. In this
    section, we will implement the stream mode and I will leave it to you to search
    around and do the block mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most well-known library for cryptography in Python is called `PyCrypto`.
    For Windows, there is a compiled binary for it, and for the Kali side, you just
    need to run the setup file after downloading the library. You can download the
    library from [http://www.voidspace.org.uk/python/modules.shtml#pycrypto](http://www.voidspace.org.uk/python/modules.shtml#pycrypto).
    So, as a start, we will use `AES` without TCP or HTTP tunneling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code is quite straightforward. We will start by importing the `os` library,
    and we will import the `AES` class from `Crypto.Cipher` library. Now, we use the
    `os` library to create the random `key` and random `counter`. The counter length
    is `16` bytes, and we will go for `32` bytes length for the key size in order
    to implement AES-256\. Next, we create an encryption object by passing the `key`,
    the AES mode (which is again the stream or CTR mode) and the `counter` value.
    Now, note that the `counter` is required to be sent as a callable object. That's
    why we used `lambda` structure or `lambda` construct, where it's a sort of anonymous
    function, like a function that is not bound to a name. The decryption is quite
    similar to the encryption process. So, we create a decryption object, and then
    pass the encrypted message and finally, it prints out the decrypted message, which
    should again be clear text.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s quickly test this script and encrypt my name. Once we run the script
    the encrypted version will be printed above and the one below is the decrypted
    one, which is the clear-text one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, to test the message size, I will just invoke a space and multiply the size
    of my name with `5`. So, we have `5` times of the length here. The size of the
    clear-text message does not matter here. No matter what the clear-text message
    was, with the stream mode, we get no problem at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us integrate our encryption function to our TCP reverse shell. The
    following is the client side script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What I have added was a new function for encryption and decryption for both
    sides and, as you can see, the key and the counter values are hardcoded on both
    sides. A side note I need to mention is that we will see in the hybrid encryption
    later how we can generate a random value from the Kali machine and transfer it
    securely to our target, but for now, let's keep it hardcoded here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the server side script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is how it works. Before sending anything, we will pass whatever we want
    to send to the encryption function first. When we get the shell prompt, our input
    will be passed first to the encryption function; then it will be sent out of the
    TCP socket. Now, if we jump to the target side, it's almost a mirrored image.
    When we get an encrypted message, we will pass it first to the decryption function,
    and the decryption will return the clear-text value. Also, before sending anything
    to the Kali machine, we will encrypt it first, just like we did on the Kali side.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the script on both sides. Keep Wireshark running in background at the
    Kali side. Let's start with the `ipconfig`. So on the target side, we will able
    to decipher or decrypt the encrypted message back to clear text successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to verify that we got the encryption in the transit path, on the Wireshark,
    if we right-click on the particular IP and select Follow TCP Stream in Wireshark,
    we will see that the message has been encrypted before being sent out to the TCP
    socket.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting your tunnel with RSA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will be using the RSA asymmetric algorithm to protect our
    tunnel. Now, to review the requirements for asymmetric encryption: as we said,
    each entity has its own key pair; when I say key pair, I mean a public and a private
    key. The final key-pair distribution will be as follows. The client will hold
    its own private key and the server''s public key. On the other side, the server
    or the Kali machine will hold its own private key and the target''s public key.
    So, when we want to send a message or command to our target from the Kali side,
    first we will encrypt that message using the target''s public key and then we
    will send it over the tunnel in encrypted format. The target will grab that command
    or message, and using its private key it can decrypt it and extract it back to
    clear text. The reply, after executing the command, will be encrypted using the
    server''s public key. After that, we will send it out in encrypted format to the
    network and once we received that message or that encrypted message on the Kali
    machine, we will use the Kali private key to decrypt it back to clear text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the first step is to generate a key pair on both sides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So, we start with importing the `RSA` class. Then, we create a new object to
    generate a key with a size of `4096` bits. Now, this is the maximum size that
    `RSA` can support, but the tax that you will pay for having a complex key is the
    slowness. The more key size the more secure, but slower will be the operation.
    Next, we export the keys in `PEM` format. `PyCrypto` supports other formats such
    as `DER`, which is binary encoding. The most common format is the `PEM`, which
    is also used on network devices such as firewalls and routers for VPN or HTTPS
    access purposes. Now, after printing out the generated keys, we'll save them to
    the `private.pem` and `public.pem` files.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start, and run the Generate Keys script given previously on both sides,
    at target and attacker. On the Kali side we will get the RSA private key and the
    public key. The begin and the end of keys will be marked. We will get a similar
    result on the Windows side too. So, what we'll do right now is we'll copy each
    key on the Kali machine end and save it to a separate file. Let's start with the
    private key on the attacker machine and simply paste the private key in a notepad
    file. Rename this file to `private.pem`. Now, let's go and do the same for the
    public key. Let's call this one `public.pem`. After this, jump to the Windows
    side and do what we have done on the Kali machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as we did with the AES encryption, before integrating the encryption to
    our tunnel, let''s first have a look at how the encryption and decryption will
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first define an encryption function, where we will pass the message
    that we want to encrypt, and a decryption function down below, just as we did
    in the AES case. Now, after getting the clear-text message, we will open the public
    key file that will encrypt the message for us and link the imported key into the
    `encryptor` object. Now, the `encryptor` object will do the actual encryption
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: The encryption function in the `RSA` class takes two parameters. The first one
    is the plaintext message and the second one can be simply discarded. Therefore,
    we have passed a `0` value. Another thing is that, the encryption output is returned
    in a tuple format. The first item contains the encrypted text, so we'll print
    it out and for testing purposes—I'm starting with encrypting my name.
  prefs: []
  type: TYPE_NORMAL
- en: Let's jump to the decryption process and we will do something similar to the
    encryption process by importing. Now, here's the key difference. In the decryption,
    we'll import the `privatekey` and pass the `cipher` value and print it out in
    a clear text after doing the decryption.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try and run the script on the Windows side and if you encounter an error
    message saying that we've got no file or directory for `public.pem` most likely,
    this error message is because of the format for the saved file. View the complete
    extension and remove the `.txt` and make it `.pem` for both public and private
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we want to start by encrypting my name, and we will pass my name in clear
    text to the encryption function. Now, once we import the public key for encryption,
    we will print the encrypted message. Then, we will pass the encrypted message
    back to the decryption function so we can print it out in clear-text format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, if we jump to the Kali side and run the script with a slight change
    in the `encrypt()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, notice that I have encrypted a message that has a size of `512` bytes in
    the code block. The point that I want to show you is that RSA is working as a
    block `cipher` type and, per `PyCrypto` implementation, the block size is `512`
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see what'll happen if I raised the message size by 1 byte. So, instead
    of multiplying this one with `512`, I will simply multiply with `513`. So, an
    exception will be thrown saying that the plaintext is too large to be handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the maximum size of the message must be `512` bytes. Now, what I will do
    first is I will integrate the RSA to our TCP tunnel and then I will show you how
    we can solve the block size issue within a few lines of Python code. Now, the
    integration is quite similar to what we have done in the previous section. Let''s
    look into the client side script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, I have created two functions: one for the encryption and a second one for
    the decryption. Before sending any command, we will pass it first to the encryption
    function and before printing any result, we will pass what we get to the decryption
    function. Now, remember that the target holds its private key and the server''s
    public key and the Kali machine holds its private key and the client''s public
    key. Now, go to the Kali machine and open the public key which you had saved in
    the text file. Copy and paste the public key into the variable. So, obviously,
    we would need to import these keys manually before exporting the script on the
    target side into EXE format. Now, we will open the public key from the target
    side that we have just generated. Remember, this public key should be located
    in the public key variable on the Kali machine. Perform the same operation as
    the previous one.'
  prefs: []
  type: TYPE_NORMAL
- en: Right now, it's time for the private key. So, the private key for the Kali machine
    will be located on the script for the Kali machine. Copy-paste the private keys
    from the text files into the strings on both server and client side and save them.
    Now, let's find out whether our scripts will work after the integration to the
    TCP tunnel. Start Wireshark and run it on the server side. Let's jump to the target
    side and, basically, we get a connection and a shell prompt. Check the connection
    with something less heavy like `whoami`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, keep in mind that `whoami` is less than `512` bytes; so, we were able to
    encrypt it successfully on the Kali machine and send it over to the target side.
    Also, since the output of the executing `whoami` on the target side is also less
    than `512` bytes we get the reply successfully. So, we have verified that the
    encryption is working here. Now, let's try with another command say, `ipconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that we have received the command successfully but for some
    reason we get no output on the Kali side and this is because the execution output
    of the `ipconfig` on the client side or on the target side is larger than `512`
    bytes, and therefore the script will crash as we have exceeded the message size.
    Now, as I said earlier, this can be resolved by verifying the message length and
    breaking it down into chunks, where each chunk should be less than or equal to
    `512` bytes. So, let''s jump to the latest code, which resolves the bulk size
    problem for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created an `if` statement to check the size of the command execution
    output. For instance, let''s say the command that we got from Kali was `ipconfig`.
    So, we''ll see if the output or the size of the output of `ipconfig` is larger
    than `512` bytes. If it''s not, then we got no problem: we will send the output
    to the `encrypt()` function, then it will be sent directly to the Kali machine.
    However, if the output was larger than `512` bytes, we will split it into chunks,
    where the maximum size for each chunk is `512` bytes. The splitting will happen
    by making a `for` loop, where we''ll start from `0` until the length of our command
    execution output. And each time we make a loop, we will increment our `i` counter
    with `512` bytes. So, what we''ll achieve by doing this is, the chunk variable
    will hold the split result, where the first chunk will cut the result from `0`
    to `512` bytes and the second chunk will be from `500` to `1024` bytes, and so
    on, until reaching the length of the command output. Now, note that each time
    we got a chunk we are good to go and we will send it immediately to the attacker
    machine after for sure passing out or passing into the encryption function.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, on the target side, since the maximum size of the received data is already
    known to us, which is again `512` bytes, instead of reading 1 KB and splitting
    into chunks again, we will read one chunk each time. So, that's why we have changed
    the received value from `1` KB to `512` bytes. So, now, after decrypting the chunk,
    if we got a clear-text message with full size of `512` bytes, this probably means
    that this message has been split into chunks on the target side, right? So, the
    next message or chunk is related to the first one. Now, this is why the stored
    variable will hold both of them, and when I say both, I mean `store + decrypt`
    message and the next coming `store + decrypt`. Finally, we will `print` out the
    `result`.
  prefs: []
  type: TYPE_NORMAL
- en: If the command execution was larger than two messages or, in other words, was
    larger than 1 KB, then we may need to link the third message as well to the stored
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's verify if our code is working right now. Start running the server
    side and the client side. Let's start with the command that we failed to run earlier,
    that is `ipconfig`. We will see that we get the output in a single piece, even
    it is bigger than `512` bytes. The same goes for `whoami` and directories.
  prefs: []
  type: TYPE_NORMAL
- en: RSA is also being used in developing something called **ransomware**. Now, in
    ransomware, the attackers can encrypt the target files using a public key and
    ask for money to provide the private key, which will decrypt their important files.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid encryption key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should be able to code and implement both the RSA asymmetric
    and the AES symmetric encryption, and integrate both of them over our TCP shell.
    So, now, we will implement a hybrid way to take advantage of both the algorithms.
    So let's quickly recap. The client will hold its own private key, and the server
    or the Kali machine will hold the target's public key. Once the TCP connection
    is started, the Kali machine will generate a random AES key and we will securely
    send this key to the target side. The reason that I say **securely** is because
    the transfer will happen via encryption or via encrypting the random AES key with
    a target's public key. Once the target gets that message, it will decrypt it using
    the target private key and extract the AES key back to clear text. At this point,
    both the Kali and the target machines have the same random generated AES keys
    which can, and will, be used for AES encryption. Now, the AES encryption at this
    point will be used to encrypt our commands that will be transferred back and forth
    between the Kali machine and our target.
  prefs: []
  type: TYPE_NORMAL
- en: Upon a new connection, both Kali and the target will repeat the whole process,
    and a new random key will be derived. Now, this is why it's called a **hybrid
    method**, since we are using the asymmetric algorithm to securely transfer a generated
    symmetric key, which eventually will be used to encrypt our commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s jump to the coding part, which is sort of a mix between the symmetric
    and the asymmetric. The following is the server side-script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon completing the TCP three-way handshake, we will create two random values,
    which are the `key` and the `counter`. Their values are a combination of an uppercase,
    lowercase, digits, and special characters. Before going to the infinite loop—which
    will be used to transfer the command that we want to be executed—we''ll encrypt
    these values with the target''s public key and then send it over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'On the target side, and also before going into the infinite loop, we will decrypt
    the key and the counter that we have received from the Kali machine; we will do
    this encryption using our private key. Then, we will store them in a global variable,
    which will be used for AES encryption. One more time, this will happen before
    going to the infinite loop. The definition of our private key is under a function
    called `GET_AES_KEY()`. So, at this point, we get the key and the `counter` values,
    and as I said, we''ll use them for AES encryption. So, the encrypt function and
    the decrypt function are used to protect our commands that will be going back
    and forth between the Kali and the Windows machines. Now, once we are within the
    infinite loop, we will use the AES''s stream mode to protect our tunnel later
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's run the scripts, start with the Kali side, then with Windows side.
    You will notice that once we fire up the target, we get a random AES key that
    gets generated on the Kali machine, which is then transferred to the target side.
  prefs: []
  type: TYPE_NORMAL
- en: If we open Wireshark and right-click on any IP and select Follow TCP Stream,
    we can see that the AES key gets transferred successfully after being encrypted
    with the target's public key.
  prefs: []
  type: TYPE_NORMAL
- en: So, once we get the key, everything that is being sent, will be encrypted using
    the AES's key stream. So, when we run `ipconfig` on the Kali machine and again
    click on Follow TCP Stream, `ipconfig` gets encrypted using the AES algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try with another command, such as `whoami`. If we stop this session by
    typing `terminate` and then re-establish a new session, you will see that we will
    get a new random AES key generated as per the new session.
  prefs: []
  type: TYPE_NORMAL
- en: So, each time the target connects to the Kali machine, a new random key will
    be generated.
  prefs: []
  type: TYPE_NORMAL
- en: Technically speaking, you can enhance the script here and make both sides change
    the AES key after a certain amount of time or after certain amount of bytes being
    sent over, just like the IPSEC in VPN tunnel does.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've discussed a wide range of topics ranging from introduction
    to encryption algorithms to discussing different types of algorithms. We've also
    implemented AES and RSA to protect the tunnel during passage of information.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we've arrived at the end of the book! I hope you've learned some
    great techniques to test with Python.
  prefs: []
  type: TYPE_NORMAL
