<html><head></head><body>
		<div id="_idContainer130">
			<p><a id="_idTextAnchor068"/></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor069"/><em class="italic">Chapter 4</em>: Attacking Web, Mobile, and IoT Applications</h1>
			<p>Here we are at the fun part of our journey—the core of the practical section of this book. So far, we have looked at both the basics and the mechanics of SQL injection, including a glimpse of what a successful SQL injection attack can do. We also provided a safe and controlled environment that anyone can experience, at their own pace, of what a SQL injection attack consists of. </p>
			<p>In this chapter, we will deal with SQL injection attacks against traditional web applications, which is the most common scenario, using both manual and automated techniques, relying on the toolset that we discussed in the previous chapter.</p>
			<p>This chapter is split into the following sections:</p>
			<ul>
				<li><strong class="bold">Attacking traditional web applications – manual techniques</strong>: This section shows SQL injection attacks performed manually against the vulnerable web applications contained in the OWASP <strong class="bold">Broken Web Applications</strong> (<strong class="bold">BWA</strong>) virtual web server. These attacks will be familiar to you, as they are similar to what you've already encountered in <a href="B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, <em class="italic">Manipulating SQL – Exploiting SQL Injection</em>. However, here, we will try a more realistic approach by guiding you through the steps that an attacker would follow.</li>
				<li><strong class="bold">Attacking traditional web applications– automated techniques</strong>: Once again, our target will consist of web applications included within the OWASP BWA project. This time, though, we will show the capabilities of automated tools for SQL injection, which are used by attackers (and security professionals alike) for efficiency purposes.</li>
				<li><strong class="bold">Attacking mobile targets</strong>: In this section, we will look at how mobile applications can also be vulnerable to SQL injection attacks, showing practical examples.</li>
				<li><strong class="bold">Attacking IoT targets</strong>: SQL databases can be vulnerable to SQL injection whatever the context they find themselves in. The IoT world is no exception. We are showing here an attack scenario that could interest IoT systems.</li>
			</ul>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor070"/>Technical requirements</h1>
			<p>For this very practical chapter, we strongly recommend that you familiarize yourself with the main tools involved. We recommend the following resources, including the references from the previous chapter:</p>
			<ul>
				<li>https://<a href="https://www.virtualbox.org/">www</a>.virtualbox.org/</li>
				<li><a href="https://www.kali.org/docs/">https://www.kali.org/docs/</a></li>
				<li><a href="https://owasp.org/www-project-broken-web-applications/">https://owasp.org/www-project-broken-web-applications/</a></li>
				<li><a href="https://developer.android.com/studio">https://developer.android.com/studio</a></li>
				<li><a href="https://www.eclipse.org/downloads/">https://www.eclipse.org/</a><span class="hidden"> </span></li>
				<li><a href="https://www.kali.org/docs/">https://www.kali.org/docs/</a></li>
				<li><a href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a></li>
				<li><a href="https://www.zaproxy.org/">https://www.zaproxy.org/</a></li>
				<li><a href="https://owasp.org/www-project-broken-web-applications/">https://owasp.org/www-project-broken-web-applications/</a></li>
			</ul>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/32d3s2b ">https://bit.ly/32d3s2b</a></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor071"/>Attacking traditional web applications– manual techniques</h1>
			<p>Let's begin with manual attacks against OWASP BWA web applications. We already found, in <a href="B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, <em class="italic">Manipulating SQL – Exploiting SQL Injection</em>, an easy attack point for <a id="_idIndexMarker157"/>extracting information through SQL injection, but we will pretend that each application is independent and does not share the same instance of MySQL. For this reason, we will not consider the OWASP Vicnum application for this purpose, as it would make things too easy for us. Each application <a id="_idIndexMarker158"/>will be considered as a separate <a id="_idIndexMarker159"/>target so that we can explore the intrinsic vulnerabilities <a id="_idIndexMarker160"/>residing in them. In this section, we will <a id="_idIndexMarker161"/>perform SQL attacks against three of the OWASP BWA applications: <strong class="bold">Mutillidae II</strong>, <strong class="bold">Magical Code Injection Rainbow</strong>, and <strong class="bold">Peruggia</strong>, putting in practice what you have learned so far in a guided setting.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor072"/>Attacking Mutillidae II</h2>
			<p>Our first <a id="_idIndexMarker162"/>target is kind of a warm-up—<strong class="bold">Mutillidae II</strong> is an application designed to provide a test environment for SQL injection using an educational approach, also providing some hints about possible attacks that can be executed. You can access the SQL Injection section by going through the drop-down menu on the left (<strong class="bold">OWASP 2013</strong> | <strong class="bold">A1 - injection (SQL)</strong>):</p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B15632_04_001.jpg" alt="Figure 4.1 – SQL data extraction page in Mutillidae II&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – SQL data extraction page in Mutillidae II</p>
			<p>Let's now <a id="_idIndexMarker163"/>demonstrate how to attack this web application in its SQL injection-vulnerable web forms.</p>
			<h3>Extracting data with SQL injection</h3>
			<p>Let's go to the <a id="_idIndexMarker164"/>specific page for data extraction with SQL injection testing provided by Mutillidae II, following the drop-down menu. First and foremost, we will perform the first step in any SQL injection attack: checking whether any input validation is present by inserting the most basic injection character—the single quote—in the <strong class="bold">Name</strong> field:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B15632_04_002.jpg" alt="Figure 4.2 – SQL data extraction page in Mutillidae II: web form&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – SQL data extraction page in Mutillidae II: web form</p>
			<p>Just inserting SQL injection enabling characters can be enough to prove the presence of a SQL injection vulnerability. If we have a SQL error, it means that the input is interpreted, thus making <a id="_idIndexMarker165"/>the query syntax incorrect. After inserting the single quote, we do, in fact, get a SQL syntax error:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B15632_04_003.jpg" alt="Figure 4.3 – Error message visualization provided by Mutillidae II (0 security)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – Error message visualization provided by Mutillidae II (0 security)</p>
			<p>In the case of Mutillidae II set at the lowest security level, the error information is complete, and also helps us to visualize the complete error information. Let's increase the security level using the <strong class="bold">Toggle Security</strong> option, by clicking on it once and applying client-side security:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B15632_04_004.jpg" alt="Figure 4.4 – Example of client-side control in Mutillidae II&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Example of client-side control in Mutillidae II</p>
			<p>In this case, client-side controls have been applied, preventing blank input fields and blocking suspicious characters if both fields are filled, such as inserting <strong class="source-inline">' -- -</strong> as the username and any character as the password (such input should, if no security controls are applied, entirely ignore what's after the single quote character).</p>
			<p>However, client-side controls are not enough to prevent SQL injection. What if we bypass them by using, for example, the parameters in the URL address? (Yes, this login happens using <strong class="source-inline">GET</strong> requests by sending data in the URL as input parameters.)</p>
			<p>Let's modify the page URL in the following way. Here, we have a normal URL for this page, with <strong class="source-inline">a</strong> as the username and <strong class="source-inline">b</strong> as the p<a href="http://192.168.56.101/mutillidae/index.php?page=user-info.php&amp;username=a&amp;password=b&amp;user-info-php-submit-button=View+Account+Details">assword:</a></p>
			<p class="source-code"><a href="http://192.168.56.101/mutillidae/index.php?page=user-info.php&amp;username=a&amp;password=b&amp;user-info-php-submit-button=View+Account+Details">http://192.168.56.101/mutillidae/index.php?page=user-info.php&amp;username=a&amp;password=b&amp;user-info-php-submit-button=View+Accoun</a>t+Details </p>
			<p>We are <a id="_idIndexMarker166"/>just adding a single quote instead of the <a href="http://192.168.56.101/mutillidae/index.php?page=user-info.php&amp;username='&amp;password=b&amp;user-info-php-submit-button=View+Account+Details">username:</a></p>
			<p class="source-code"><a href="http://192.168.56.101/mutillidae/index.php?page=user-info.php&amp;username='&amp;password=b&amp;user-info-php-submit-button=View+Account+Details">http://192.168.56.101/mutillidae/index.php?page=user-info.php&amp;username='&amp;password=b&amp;user-info-php-submit-button=View+Accou</a>nt+Details </p>
			<p>This triggers another error message, as follows:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B15632_04_005.jpg" alt="Figure 4.5 – Error message visualization provided by Mutillidae II (client-side security)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 – Error message visualization provided by Mutillidae II (client-side security)</p>
			<p>Keep in mind that, if this was a <strong class="source-inline">POST</strong> request instead of <strong class="source-inline">GET</strong>, modifying the request fields would have been enough to cause a SQL injection. This points to the importance of having server-side security controls in place. This is the only way to ensure that input is properly handled, independent of the means of injection.</p>
			<p>Therefore, we have proved that the page is vulnerable to SQL injection. The input is interpreted as SQL syntax, causing a syntax error due to the incorrect statement. The error message also leaks some important information regarding the query structure, which could be used to our advantage, and the presence of an <strong class="source-inline">accounts</strong> table with fields named <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong>.</p>
			<p>Let's go a little further with data extraction, shall we? Once we've seen that SQL injection is possible, we can try and see whether other techniques work so that we can extract data. In a greedy approach, we will now try to see whether tautologies work or not.</p>
			<p>Let's try the infa<a id="_idTextAnchor073"/>mous <strong class="source-inline">' or 1=1 -- -</strong> string in the username field (in the case of client-side security, we would <a id="_idIndexMarker167"/>need to edit the parameters just like in the previous example without actually using the form). This attempt leads to the result in the following screenshot:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B15632_04_006.jpg" alt="Figure 4.6 – Result page for all of the account information records&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 – Result page for all of the account information records</p>
			<p>Using this tautology, we have found the complete login information for all application users. At this point, an attacker could gain administrator (<strong class="bold">admin</strong>) access to the application, with potentially terrible consequences.</p>
			<p>So, the application was vulnerable to probably the most powerful SQL injection attack to extract information. Let's pretend that this attack was blocked by the web application and try a more subtle approach.</p>
			<p>We will now <a id="_idIndexMarker168"/>try to extract database versioning information using a <strong class="source-inline">UNION</strong> query. We need to implement a trial-and-error approach in order to see how many columns, and which columns, are shown by the application. We're saving you this process: inserting <strong class="source-inline">' UNION SELECT 1,@@VERSION,3,4,5,6,7 -- -</strong> will work, as, apparently, the <strong class="source-inline">accounts</strong> table (we know its name due to the error information) has 7 columns, and the application only shows columns 2, 3, and 4:</p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B15632_04_007.jpg" alt="Figure 4.7 – Results page for a UNION query to display the system version&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 – Results page for a UNION query to display the system version</p>
			<p>At this point, we discovered not only the versioning of the system but also the total number of columns in the <strong class="source-inline">accounts</strong> table, as the original query selected all of the fields (<strong class="source-inline">SELECT *</strong>) for that table.</p>
			<p>We should now be able to extract information about the database schema. We already know the database is MySQL from the error messages and the versioning information. So, let's ask for the schema names in the database schema, as discussed in <a href="B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, <em class="italic">Manipulating SQL – Exploiting SQL Injection</em>. Using the same trick as before, by showing the information we need in the second field, we can extract the schema names contained in the database:</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B15632_04_008.jpg" alt="Figure 4.8 – Schema names extraction&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 – Schema names extraction</p>
			<p>We can <a id="_idIndexMarker169"/>now move on to the next section of Mutillidae II SQL injection.</p>
			<h3>Bypassing authentication with SQL injection</h3>
			<p>This section <a id="_idIndexMarker170"/>is about bypassing the login screen of the Mutillidae II web application. You can access this section from the same drop-down menu, as shown in the previous section:</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B15632_04_009.jpg" alt=" Figure 4.9 – SQL data extraction page in Mutillidae II&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 4.9 – SQL data extraction page in Mutillidae II</p>
			<p>We will now face a typical login web form that requires authenticating with both <strong class="bold">Username</strong> and <strong class="bold">Password</strong>. Let's first check whether this form is vulnerable to SQL injection by triggering some errors using SQL characters, such as single quotes:</p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B15632_04_010.jpg" alt="Figure 4.10 – The Mutillidae II login page showing an undisclosed error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10 – The Mutillidae II login page showing an undisclosed error</p>
			<p>This time, we <a id="_idIndexMarker171"/>can tell that an error has occurred. However, the application doesn't show (in accordance with the known best practices) the complete error information. Nevertheless, we know that the form is vulnerable, as the response differs if the wrong account information is used.</p>
			<p>We have already extracted the login information from the previous section, so we will try the <strong class="source-inline">admin</strong> access using known credentials:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B15632_04_011.jpg" alt="Figure 4.11 – Admin access success&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption"> </p>
			<p class="figure-caption">Figure 4.11 – Admin access success</p>
			<p>We can also check whether the form is vulnerable to a tautology attack, thus granting us access. Let's try inserting the <strong class="source-inline">' OR 1=1 -- -</strong> string in the <strong class="bold">Username</strong> field:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B15632_04_012.jpg" alt="Figure 4.12 – Tautology login attempt&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12 – Tautology login attempt</p>
			<p>This authentication bypass attack will also succeed, granting us access once again as the <strong class="bold">admin</strong> account. Keep in mind that, even if we can authenticate as any account in the system, attackers will try to obtain the <a id="_idIndexMarker172"/>highest level of privilege possible (after all, most applications allow for the creation of user-level accounts).</p>
			<p>Let's now move on to the last SQL injection form type for this application.</p>
			<h3>SQL injection in INSERT statements</h3>
			<p>So far, we've looked at SQL injection only in <strong class="source-inline">SELECT</strong> statements. Mutillidae II offers an account <a id="_idIndexMarker173"/>creation page that is linked to an <strong class="source-inline">INSERT</strong> statement in order to add new records to the accounts table of the database. It also offers two other pages with the capability of adding data to the database. However, we will only cover this page in this section, so as not to take too much from other topics. Feel free to explore the other two on your own:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B15632_04_013.jpg" alt="Figure 4.13 – Accessing the account creation page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13 – Accessing the account creation page</p>
			<p>The account creation page is not supposed to return any records, as its primary purpose is to (yes—you guessed it) add users to the accounts table of the database. Therefore, it looks like a nice place to try blind SQL injection in this context:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B15632_04_014.jpg" alt="Figure 4.14 – Account creation form&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14 – Account creation form</p>
			<p>First, we can trigger an error message to check the query syntax and examine where we could inject our commands:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B15632_04_015.jpg" alt="Figure 4.15 – Error message for inserting a single quote as the username&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.15 – Error message for inserting a single quote as the username</p>
			<p>We now have the query structure so that we can alter the command through SQL syntax. One example <a id="_idIndexMarker174"/>could be to retrieve sensitive information using subqueries with the help of <strong class="source-inline">SELECT</strong> statements. Let's try creating a user with the MySQL root account password as a signature. We will first try the <strong class="source-inline">test','test',(SELECT password FROM mysql.user WHERE user='root'))-- -</strong> payload in the username field to obtain this result:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B15632_04_016.jpg" alt="Figure 4.16 – MySQL error; the subquery returns more than one result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16 – MySQL error; the subquery returns more than one result</p>
			<p>Here, the <strong class="source-inline">SELECT</strong> query apparently returned more rows than we thought. To solve this problem, we need a way to view a single result. A trivial solution is through the <strong class="source-inline">LIMIT 1</strong> clause at the end of the <strong class="source-inline">SELECT</strong> query, which is used for limiting the results to only one, resulting in a success. Let's use the login panel to finally check our value using our newly created credentials:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B15632_04_017.jpg" alt="Figure 4.17 – The Mutillidae II upper panel after successful authentication&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.17 – The Mutillidae II upper panel after successful authentication</p>
			<p>Here, an attacker could have used the registration form to retrieve sensitive information (in this case, the password hash for the MySQL root account). This is despite it not being a query designed <a id="_idIndexMarker175"/>to return data. This example was to show how SQL injection can provide attackers with versatile tools, as long as the attacker knows the appropriate SQL syntax.</p>
			<p>We can now approach the next web application of our crash course: the Magical Code Injection Rainbow.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor074"/>The Magical Code Injection Rainbow</h2>
			<p>With the <strong class="bold">Magical Code Injection Rainbow</strong>, we have an application designed for training in code injection. We <a id="_idIndexMarker176"/>are interested in the SQL part, aptly <a id="_idIndexMarker177"/>named <strong class="bold">SQLol</strong>, which also provides examples including some server-side defenses. This time, we will be going through the first six challenges provided by this application and providing solutions for each. Feel free to try them (or the following ones) on your own. At this point, with the help of the MySQL documentation, you should be able to complete them using what you have learned in <a href="B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020"><em class="italic">Chapter 1</em></a>, <em class="italic">Structured Query Language for SQL Injection</em>, and <a href="B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>, <em class="italic">Manipulating SQL – Exploiting SQL Injection</em>:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B15632_04_018.jpg" alt="Figure 4.18 – Magical Code Injection Rainbow SQLol - the Challenges screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.18 – Magical Code Injection Rainbow SQLol - the Challenges screen</p>
			<p>Access the challenges by selecting <strong class="bold">SQLol</strong> from the home screen, and then selecting <strong class="bold">Challenges</strong>. You will <a id="_idIndexMarker178"/>always have a single text field to insert the payload into, so you know that's the only way to insert SQL payloads.</p>
			<h3>Challenge 0 – Hello, world!</h3>
			<p>This is the <a id="_idIndexMarker179"/>most basic challenge in the list. Here, you need to return all of the usernames from the user <a id="_idIndexMarker180"/>table of the database using a <strong class="source-inline">SELECT</strong> query, and perform the injection in the <strong class="source-inline">WHERE</strong> clause. This is a typical setting for the <strong class="source-inline">SELECT</strong> queries that we've seen so far.</p>
			<p>This is pretty simple to do. It's enough to provide a condition where the <strong class="source-inline">WHERE</strong> condition is always true, and we know the exact way to do tautologies.</p>
			<p>Our payload will be <strong class="source-inline">' OR 1=1 -- -</strong>, resulting in our desired output:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B15632_04_019.jpg" alt="Figure 4.19 – SQLol challenge 0 results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.19 – SQLol challenge 0 results</p>
			<p>This was <a id="_idIndexMarker181"/>pretty easy, right? We just returned all of the usernames <a id="_idIndexMarker182"/>with the simplest SQL injection possible. Let's now move on to the second challenge.</p>
			<h3>Challenge 1 – SQL injection 101</h3>
			<p>This is also a fairly simple challenge; that said, it requires a bit of reconnaissance in order to discover the <a id="_idIndexMarker183"/>query structure. This time, we need to find the table containing the social security numbers that are present in the database <a id="_idIndexMarker184"/>and return the full content in the query output. Once again, we are dealing with a <strong class="source-inline">SELECT</strong> query and injecting in the <strong class="source-inline">WHERE</strong> clause:</p>
			<ol>
				<li>First, we need to uncover what the social security number table is called. To do this, we need to check the MySQL <strong class="source-inline">information_schema</strong> table using <strong class="source-inline">UNION</strong> queries. We first need to find the table name with the <strong class="source-inline">' UNION SELECT table_name FROM information_schema.tables -- -</strong> payload. Alternatively, we could also refine the search by adding clauses such as <strong class="source-inline">LIKE</strong> with certain desired characteristics (for example, <strong class="source-inline">WHERE table_name LIKE ' %ssn%'</strong> for table names containing <strong class="source-inline">ssn</strong>):<div id="_idContainer081" class="IMG---Figure"><img src="image/B15632_04_020.jpg" alt="Figure 4.20 – SQLol challenge 1 results&#13;&#10;"/></div><p class="figure-caption">Figure 4.20 – SQLol challenge 1 results</p></li>
				<li>At this point, we need to extract the column names from the table using the <strong class="source-inline">' UNION SELECT column_name FROM information_schema.columns WHERE table_name='ssn' -- -</strong> payload:<div id="_idContainer082" class="IMG---Figure"><img src="image/B15632_04_021.jpg" alt="Figure 4.21 – SQLol challenge 1 results&#13;&#10;"/></div><p class="figure-caption">Figure 4.21 – SQLol challenge 1 results</p></li>
				<li>Now we <a id="_idIndexMarker185"/>just have to query the <strong class="source-inline">ssn</strong> table for <a id="_idIndexMarker186"/>each field one at a time. Alternatively, we could use a more elegant solution with the <strong class="source-inline">CONCAT()</strong> operator:</li>
			</ol>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B15632_04_022.jpg" alt="Figure 4.22 – SQLol challenge 1 final results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.22 – SQLol challenge 1 final results</p>
			<p>Here, we have the social security numbers for all users in one place. Let's move on to the third challenge.</p>
			<h3>Challenge 2 – The Failure of Quote Filters</h3>
			<p>This challenge <a id="_idIndexMarker187"/>is a carbon copy of the previous one but with <a id="_idIndexMarker188"/>a twist: the single quote character, which is the most common enabler for SQL, is entirely ignored from the query string, rendering the attack that we just performed ineffective. However, the sanitization measure just ignores the character at the input level. But what if it's still evaluated by the database at runtime? Consider the following steps:</p>
			<ol>
				<li value="1">Let's use the <strong class="source-inline">CHAR(27) UNION SELECT 1 -- -</strong> payload to add the value of <strong class="source-inline">1</strong> to the end of the query. <strong class="source-inline">CHAR()</strong> is a function, supported in MySQL, that translates a number <a id="_idIndexMarker189"/>to its ASCII character equivalent. In this case, it is the single quote:<div id="_idContainer084" class="IMG---Figure"><img src="image/B15632_04_023.jpg" alt="Figure 4.23 – SQLol challenge 2: defeating single quote escaping&#13;&#10;"/></div><p class="figure-caption">Figure 4.23 – SQLol challenge 2: defeating single quote escaping</p></li>
				<li>At this <a id="_idIndexMarker190"/>point, we can perform <a id="_idIndexMarker191"/>the challenge 1 attack by substituting the single quote with <strong class="source-inline">CHAR(27)</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B15632_04_024.jpg" alt="Figure 4.24 – SQLol challenge 2 final results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.24 – SQLol challenge 2 final results</p>
			<p>Let's now move on to the next challenge.</p>
			<h3>Challenge 3 – Death Row</h3>
			<p>This challenge is another clone of the first challenge. However, this time, it will only show one result at a time.</p>
			<p>Luckily, we already <a id="_idIndexMarker192"/>know the contents of the table, so we will skip to the final step of the attack, directly moving to the approach required for this specific challenge.</p>
			<p>We can try <a id="_idIndexMarker193"/>the same payload. However, this time, add <strong class="source-inline">LIMIT 1</strong> to the end to ensure our SQL query returns only one result, independent of the application server measures applied to this challenge, and then use <strong class="source-inline">OFFSET</strong> to go through each result one at a time. The resulting payload for returning only the second result will, therefore, be <strong class="source-inline">' UNION SELECT CONCAT(name, " ", ssn) FROM ssn LIMIT 1 OFFSET 1-- -</strong>, as <strong class="source-inline">OFFSET</strong> starts from <strong class="source-inline">0</strong> for the first result and increases by one for each subsequent row:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B15632_04_025.jpg" alt="Figure 4.25 – The second result of SQLol challenge 3&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.25 – The second result of SQLol challenge 3</p>
			<p>We can now move on to the next challenge.</p>
			<h3>Challenge 4 – War on Error</h3>
			<p>This challenge is another clone of the social security number challenge. However, this time, the output will <a id="_idIndexMarker194"/>not be visualized. The challenge consists of extracting information using only the verbose error messages provided, without the blind SQL injection techniques.</p>
			<p>Our best bet <a id="_idIndexMarker195"/>is to show the query results inside an error message. One possible way to do this is through the use of expressions that evaluate some kind of non-strictly SQL syntax. </p>
			<p>An example of this is the <strong class="source-inline">ExtractValue()</strong> function, which extracts values from <strong class="source-inline">XML</strong> (the first argument) using the <strong class="source-inline">XPATH</strong> syntax (the second argument). We need to make sure there are no empty spaces in between, so as not to generate SQL syntax errors. Instead, we need to cause an XML evaluation error, possibly via the misconstruction of the <strong class="source-inline">XPATH</strong> syntax, and insert our SQL query inside of it. This is so that the SQL syntax is correctly evaluated and the query results are leaked in the error message. </p>
			<p>We will try the following payload. Note that since we can only view one result at a time, we need the <strong class="source-inline">LIMIT 1</strong> clause when changing the offset each time:</p>
			<p class="source-code">'AND ExtractValue('randomxml',CONCAT('=',(SELECT CONCAT(name,'-',ssn) FROM ssn LIMIT 1 OFFSET 0)))='x </p>
			<p>The payload worked as intended, and the query result is shown as an <strong class="source-inline">XPATH</strong> syntax error. We only need to iterate the query with all of the remaining offsets, and we can extract the entirety of the table's contents through error messages:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B15632_04_026.jpg" alt="Figure 4.26 – SQLol challenge 4 result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.26 – SQLol challenge 4 result</p>
			<p>Now that we <a id="_idIndexMarker196"/>have demonstrated this interesting <a id="_idIndexMarker197"/>attack method, let's finally move on to our last challenge from this application.</p>
			<h3>Challenge 5 – Blind Luck</h3>
			<p>This final challenge is another social security number challenge. However, this time, both the output and error messages are not visualized. The challenge consists of extracting information <a id="_idIndexMarker198"/>using blind SQL injection techniques. To help us, we have Boolean results that tell us whether the query is successful (that is, whether it returns at least one record) or not.</p>
			<p>If we were to <a id="_idIndexMarker199"/>extract the information from the SSN table, then, this time, we would need to use inference techniques. Luckily, we don't need to check for particularly cryptic clues in the response, since we can rely on the Boolean result. First, just to show the Boolean result, we will look for the <strong class="source-inline">ssn</strong> table by querying the <strong class="source-inline">information_schema.tables</strong> table. We will inject the <strong class="source-inline">' UNION SELECT table_name FROM information_schema.tables WHERE table_name='ssn'-- -</strong> payload to check for it:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B15632_04_027.jpg" alt="Figure 4.27 – SQLol challenge 5 Boolean result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.27 – SQLol challenge 5 Boolean result</p>
			<p>Now that we know what a true result looks like, we can guess the output using checks. Since we need to reconstruct the data, we need a way to spot the content of the table using only Boolean answers. The most common technique we can use is to check for single characters using the <strong class="source-inline">SUBSTRING(s, d, n)</strong> function. This takes, given s tring <strong class="source-inline">s</strong>, the number (<strong class="source-inline">n</strong>) of characters after the position, <strong class="source-inline">p</strong>, of that string. <strong class="source-inline">SUBSTRING('hello', 1, 1)</strong> would return <strong class="source-inline">h</strong>, which is located at a <strong class="source-inline">1</strong> character distance after the first position (<strong class="source-inline">1</strong>).</p>
			<p>For each record, we will check the characters of the fields one by one, using both the <strong class="source-inline">SUBSTRING()</strong> function and the <strong class="source-inline">LIMIT 1 OFFSET</strong> clause, as we need to check each record separately in order to infer them with certainty. This is definitely a long process, but we have another trick up our sleeve to speed it all up: <strong class="bold">binary search</strong>. We will use the <strong class="source-inline">ASCII()</strong> function, which returns <a id="_idIndexMarker200"/>the ASCII encoding number of a single character, and compare it each time with a number, which will be the pivot of our binary search. In the ASCII encoding, we have 255 possible values, so our optimal pivot will be the middle value (128). By comparing this with 128, we can tell whether the character belongs to the lower or upper part <a id="_idIndexMarker201"/>of the range, and we will split our possible range into two each time.</p>
			<p>If, for example, our check tells us that the character's ASCII is equal or greater than 128, then next time <a id="_idIndexMarker202"/>we will try with 192 as the pivot. If not, we will go down to 64. Each time, we will be splitting the range into two, thus drastically reducing the number of steps for guessing.</p>
			<p>For this walk-through, once again, we will skip directly to the <strong class="source-inline">ssn</strong> table. However, for the complete attack, you should apply this method to all of the earlier discovery steps and the table fields too. We prefer to leave this up to the reader to decide.</p>
			<p>Let's try using the <strong class="source-inline">' OR ASCII(SUBSTRING((SELECT NAME FROM SSN LIMIT 1 OFFSET 0),1,1)) &gt;= 128 -- -</strong> payload to apply this principle to our specific case, with number 128 as the pivot of our search:</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B15632_04_028.jpg" alt="Figure 4.28 – SQLol challenge 5 inference attempt; no results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.28 – SQLol challenge 5 inference attempt; no results</p>
			<p>Here is the step-by-step iterative process for the binary search:</p>
			<ol>
				<li value="1">With a false result, we can infer that our character belongs to the first 128 (0 to 127) ASCII characters. </li>
				<li>Using 64 (128/2) as the pivot for our binary search returns a true result. This means our character is within the range of 64 and 127.</li>
				<li>Pivot 96 (64 + 32) doesn't return any results, so we will try 80 (96-16). Still, there are no results.</li>
				<li>Our next attempt is 72 (80 - 8), which succeeds. This means we will try 76 (72 + 4) next.</li>
				<li>76 fails, which means our number is within the range of 72 and 75. At this point, we will try 72:</li>
			</ol>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B15632_04_029.jpg" alt="Figure 4.29 – Final step of inference; direct comparison (success)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.29 – Final step of inference; direct comparison (success)</p>
			<p>Following these steps, we know <a id="_idIndexMarker203"/>that the first character <a id="_idIndexMarker204"/>of the first record corresponds to the ASCII character of 72, which is capital <strong class="source-inline">H</strong> (the first letter of the name, <strong class="source-inline">Herp Derper</strong>, in the <strong class="source-inline">ssn</strong> table).</p>
			<p>Finally, we can obtain all of the values from our table by applying the same principle for all characters of any entries and fields we want, and also use it for double-checking:</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B15632_04_030.jpg" alt="Figure 4.30 – SQLol Challenge 5; inference double-check&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.30 – SQLol Challenge 5; inference double-check</p>
			<p>This concludes our guided tour through the SQL challenges of the Magical Code Injection Rainbow. We would love to go on with this fun walk-through, but we don't want to give too much space to this application, so instead, we'll focus on a wider range of targets. We will now proceed with our last OWASP BWA target for this section: the Peruggia web app.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor075"/>Attacking Peruggia</h2>
			<p>As stated in <a href="B15632_03_Final_JC_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Setting Up the Environment</em>, Peruggia is a purposely vulnerable web app that <a id="_idIndexMarker205"/>mimics the behavior of a regular (despite possibly dated) web application. In this case, we won't have tutorials or challenges, but it's just us and the application, with no hints or help whatsoever:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B15632_04_031.jpg" alt="Figure 4.31 – The Peruggia home screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.31 – The Peruggia home screen</p>
			<p>Let's now look at how we can use SQL injection to attack this application.</p>
			<h3>SQL injection in the login panel</h3>
			<p>Our first stop is the login panel of the application. We can access it by clicking on <strong class="bold">Login</strong> at the top of the page. Here, we have a scenario where we don't have any output from our SQL injection attempts. In fact, no <a id="_idIndexMarker206"/>SQL errors are even displayed (as it should be in a secure application, after all).</p>
			<p>Additionally, by examining the page and its response and interaction, we can't grasp any meaningful differences between a successful SQL injection attempt or an unsuccessful one. This means that we have no way of extracting information from the login form. The application enforces a good design principle in this case by not letting the database server communicate directly with the user. However, this is not enough. Even if the application does not let the database server expose query results, errors, or any other meaningful information, that does not mean it is not vulnerable to SQL injection. </p>
			<p>Let's attempt the most trivial SQL injection attack: a tautology. In most cases, an attempt like this would result in a total login bypass, granting us access to the application. In the following screenshot, we are attempting a tautology attack, as demonstrated in the previous applications:</p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B15632_04_032.jpg" alt="Figure 4.32 – Peruggia login bypass attempt&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.32 – Peruggia login bypass attempt</p>
			<p>The tautology attack has succeeded. This not only means that the web application is vulnerable to SQL injection, but we can use the login screen to perform inference attacks. Whenever <a id="_idIndexMarker207"/>access is granted, this means that the Boolean check we are performing is true, as confirmed in the following screenshot:</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B15632_04_033.jpg" alt="Figure 4.33 – Peruggia's upper screen after a successful admin login&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.33 – Peruggia's upper screen after a successful admin login</p>
			<p>This means that, similarly to challenge 5 of the Magical Code Injection Rainbow SQLol, we can extract whatever information we want from the database. Let's try the same double-check query we made at the end of challenge 5. This time, we will extract data from a different schema, so we need to specify the schema of the table we are extracting data from:</p>
			<p class="source-code">' OR (SELECT NAME FROM SQLOL.SSN LIMIT 1 OFFSET 0) = "Herp Derper" -- -</p>
			<p>This will grant us access, which means that the information we checked (again) is true. This can be done to apply inference techniques to the content of the database.</p>
			<p>This example confirms the power of SQL injection as a flexible means to obtain all sorts of information from a database. This attempt could have also worked if we had created a new account legitimately. In Peruggia, we also have the <strong class="source-inline">User</strong> account, and the login bypass allows us to log in for every user that we want, as long as we specify it:</p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B15632_04_034.jpg" alt="Figure 4.34– Peruggia login bypass example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.34– Peruggia login bypass example</p>
			<p>The resulting query just checks for the <strong class="source-inline">WHERE</strong> condition. In this case, it is just the existence of a <a id="_idIndexMarker208"/>record with the username, <strong class="source-inline">User</strong>, as we cut the rest of the query as a comment. In the end, if this example of SQL injection is present, even if the results are not shown directly, the same principles of blind SQL injection and inference can be applied.</p>
			<h3>SQL injection in the Add Comment page</h3>
			<p>Besides the <a id="_idIndexMarker209"/>login screen, we also can try other parameters in the application. In Peruggia's home screen, we can try accessing (unauthenticated) the comment section through the link marked <strong class="bold">Comment on this picture</strong>:</p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B15632_04_035.jpg" alt="Figure 4.35 – Peruggia's Add Comment page (with URL)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.35 – Peruggia's Add Comment page (with URL)</p>
			<p>We have a <strong class="source-inline">pic_id</strong> parameter in the page URL, which we could try to manipulate. If we changed it to a nonexistent ID, such as <strong class="source-inline">123456789</strong>, we would visualize an empty picture:</p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B15632_04_036.jpg" alt="Figure 4.36 – Peruggia's Add Comment page for nonexistent pictures&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.36 – Peruggia's Add Comment page for nonexistent pictures</p>
			<p>Now we will <a id="_idIndexMarker210"/>try to insert the correct SQL syntax and see whether it's evaluated by the application. Let's try inserting <strong class="source-inline">123456789 OR 1=1</strong> into our address bar as the <strong class="source-inline">pic_id</strong> parameter. We can see that, even if we insert the wrong ID, we visualized the picture present with ID <strong class="source-inline">1</strong> anyway. This proves that the parameter evaluates SQL input, and, therefore, is vulnerable to SQL injection:</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B15632_04_037.jpg" alt="Figure 4.37 – The pic_id parameter is vulnerable to SQL injection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.37 – The pic_id parameter is vulnerable to SQL injection</p>
			<p>At this point, using a trial-and-error approach, we can see whether we can visualize information from the database. We can try the <strong class="source-inline">UNION</strong> query techniques and guess the number of <a id="_idIndexMarker211"/>parameters in the underlying SQL query. We can assume that the picture ID corresponds to one of these parameters along with, possibly, the picture URL (we will see a broken picture icon in the case of a nonexistent ID) and <strong class="bold">Uploaded By</strong> displayed on the page. However, using the <strong class="source-inline">123456789 UNION SELECT 1,2,3</strong> payload still returns the empty picture, probably due to a MySQL error. Let's instead try using one more argument, with the <strong class="source-inline">123456789 UNION SELECT 1,2,3,4</strong> payload:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B15632_04_038.jpg" alt="Figure 4.38 – Successful UNION SQL injection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.38 – Successful UNION SQL injection</p>
			<p>At this point, we know that the underlying query has four arguments, and the fourth argument corresponds to the <strong class="bold">Uploaded By</strong> value on the page. We can use this query to extract all the information we like. As an example, we will try to extract the password for the admin <a id="_idIndexMarker212"/>account of the application. We could query the <strong class="source-inline">information_schema</strong> table to extract the schema of the application (Peruggia) and its tables to find the one that corresponds to its user information (users). We will then use the <strong class="source-inline">123456789 UNION SELECT 1,2,username,password FROM users WHERE username='admin'</strong> payload to return the password for the account admin next to <strong class="bold">Uploaded By</strong> on the page:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B15632_04_039.jpg" alt="Figure 4.39 – Admin password hash returned in the Add Comment page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.39 – Admin password hash returned in the Add Comment page</p>
			<p>Of course, we could use the same field to return any information that we've seen so far, such as the password for the <strong class="bold">root</strong> MySQL account, the database system version, or any data belonging to other tables. This tutorial was primarily created to show the consequences and implications <a id="_idIndexMarker213"/>of manual SQL injection attacks (while also, of course, having fun trying these attacks in a safe and controlled environment).</p>
			<p>We will now move on to the second part of our practical section, showing what can be done with advanced and automated tools using Kali Linux.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor076"/>Attacking traditional web applications – automated techniques</h1>
			<p>As we mentioned earlier, besides performing manual attack techniques to exploit SQL injection, it's possible to use specific software that can handle some of the tasks involved in SQL injection <a id="_idIndexMarker214"/>attacks, producing useful results in a timely manner. These tools are used by both attackers and security professionals alike, as they optimize operations and help to save a lot of time by simplifying the tasks we need to perform.</p>
			<p>First, we will <a id="_idIndexMarker215"/>go through what is possible to do, in terms of SQL injection, with <strong class="bold">Zed Attack Proxy</strong> (<strong class="bold">ZAP</strong>), which is the attack proxy by OWASP.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor077"/>OWASP ZAP for SQL injection</h2>
			<p>OWASP ZAP is a versatile tool that consists of an attack proxy—a piece of software that is used to <a id="_idIndexMarker216"/>intercept traffic in order to monitor it or modify it before it's sent to an application—with other functionalities that help to automate the process. In this sense, through automation, this tool can be used to scan web applications for vulnerabilities by testing the response received against specific inputs. This scanning feature can be used to identify many types of vulnerabilities, including SQL injection. Let's see it action, as follows:</p>
			<ol>
				<li value="1">First, let's start the <a id="_idIndexMarker217"/>software from our Kali Linux machine by typing <strong class="source-inline">zaproxy</strong> into our command line. This should load our graphic interface, allowing us to insert our target website in the panel on the right (<strong class="bold">Quick Start</strong>). We will select the <strong class="bold">Automated Scan</strong> mode so that we can test the automated capabilities of this tool:<div id="_idContainer101" class="IMG---Figure"><img src="image/B15632_04_040.jpg" alt="Figure 4.40 – OWASP ZAP main screen&#13;&#10;"/></div><p class="figure-caption">Figure 4.40 – OWASP ZAP main screen</p></li>
				<li>After <a id="_idIndexMarker218"/>selecting the <strong class="bold">Automated Scan</strong> option, we are prompted to insert our target URL for our tests to begin. We will insert the URL for the instance of the Peruggia web application, which is simple enough to show what ZAP is capable of:<div id="_idContainer102" class="IMG---Figure"><img src="image/B15632_04_041.jpg" alt="Figure 4.41 – OWASP ZAP Automated Scan panel&#13;&#10;"/></div><p class="figure-caption">Figure 4.41 – OWASP ZAP Automated Scan panel</p></li>
				<li>After clicking on <strong class="bold">Attack</strong>, our automated scan will begin. First, OWASP ZAP will perform a spidering of the application, exploring the links of the application and checking the pages that can be explored, in a very period short time. The second step of this <a id="_idIndexMarker219"/>automated analysis is to activate the scanner module, which checks for vulnerabilities by sending specific data to the application, which correspond to the input. After a few seconds, we will get our results on the <strong class="bold">Alerts</strong> tab, as follows:</li>
			</ol>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B15632_04_042.jpg" alt="Figure 4.42 – The OWASP ZAP Alerts tab displaying the issues found&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.42 – The OWASP ZAP Alerts tab displaying the issues found</p>
			<p>OWASP ZAP identified the SQL injection vulnerability in both the <strong class="source-inline">username</strong> parameter and the <strong class="source-inline">pic_id</strong> parameter (like we did manually earlier) in just a few seconds. Of course, most of the time, the results of these automated scanners need to be validated manually, as the scanner indicates the possible presence of the SQL injection vulnerability based on the responses received. Despite the degree of uncertainty, this functionality returns an indication of such vulnerabilities in a matter of seconds along with others (such as <strong class="bold">Cross-Site Scripting</strong> and <strong class="bold">Path Traversal</strong>).</p>
			<p>OWASP ZAP's automated capabilities can also be used in your own browser. To do this, you need to set up your browser's proxy as ZAP's proxy (the default is <strong class="source-inline">localhost</strong> on port <strong class="source-inline">8080</strong>). Alternatively, you can launch a browser instance directly from ZAP's interface, using the <strong class="bold">Manual Explore</strong> option from the main screen. This way, OWASP ZAP opens up a browser window on the specified URL:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B15632_04_043.jpg" alt="Figure 4.43 – The OWASP ZAP Manual Explore panel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.43 – The OWASP ZAP Manual Explore panel</p>
			<p>This way, once new pages are discovered, you can independently run ZAP's <strong class="bold">Spider</strong> and <strong class="bold">Scanner</strong> modules on <a id="_idIndexMarker220"/>each request that is identified through manual exploration. While you're exploring a website, the <strong class="bold">Sites</strong> tab gets updated with the pages you visit, showing the different requests sent:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B15632_04_044.jpg" alt="Figure 4.44 – Options provided by ZAP for analyzing requests (Attack)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.44 – Options provided by ZAP for analyzing requests (Attack)</p>
			<p>One of the most relevant modules, besides the two we've just described, is the Fuzzer module, which you can select by choosing <strong class="bold">Fuzz…</strong> from the <strong class="bold">Attack</strong> options. By choosing insertion points in a request, the Fuzzer module can try a set range of inputs to check for an unusual response. To use the Fuzzer module, you just need to select the part of input in which to inject the fuzzing, and then select the format and the actual input list. We will use strings of text with a word list made up of common SQL injection inputs. You can find many such word lists on the web, which you can easily copy and paste as your payload. Once done, you should be ready to launch your attack:</p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B15632_04_045.jpg" alt="Figure 4.45 – The Fuzzer window ready to start&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.45 – The Fuzzer window ready to start</p>
			<p>You can insert any list of inputs and also apply special encoding. This served as a demonstration in case you wish to attempt more customized attacks. However, keep in mind that the <strong class="bold">Scanner</strong> module already performs fuzzing attacks with common inputs, used for identifying common vulnerabilities.</p>
			<p>After dealing <a id="_idIndexMarker221"/>with OWASP ZAP, which can be used to save time while examining web applications and spotting vulnerabilities in a reduced amount of time with respect to manual analysis, we will now move on to possibly the most famous tool for automated SQL injection; we'll be using the sqlmap command-line interface.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor078"/>Automated SQL injection attacks using sqlmap</h2>
			<p>As mentioned earlier, sqlmap is a well-known utility within the software included in Kali Linux. While OWASP ZAP is a tool made for discovering and analyzing all sorts of vulnerabilities <a id="_idIndexMarker222"/>within a web application, sqlmap is designed specifically for SQL injection and provides many options for such attacks. It is, however, not very <a id="_idIndexMarker223"/>user friendly (as is the case for most of the command-line utilities available), so it's best to view all of the available options using the complete help (<strong class="source-inline">-hh</strong>) option. You can do this by typing <strong class="source-inline">sqlmap -hh</strong> into the Kali Linux terminal:</p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B15632_04_046.jpg" alt="Figure 4.46 – sqlmap help output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.46 – sqlmap help output</p>
			<p>Let's try it against Peruggia again. First, let's scan the <strong class="bold">Add Comment</strong> page to see whether sqlmap discovers the page is vulnerable. We will type <strong class="source-inline">sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&amp;pic_id=1"</strong> in the terminal. sqlmap will <a id="_idIndexMarker224"/>ask us whether we want to try various attack techniques during execution. Since we are scanning the web page, we are interested <a id="_idIndexMarker225"/>in checking whether any attacks work, so we will answer <strong class="source-inline">Y</strong> or <strong class="source-inline">N</strong> depending on the request to perform all possible attacks. After a few seconds, we will get our final result:</p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B15632_04_047.jpg" alt="Figure 4.47 – sqlmap basic scan result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.47 – sqlmap basic scan result</p>
			<p>Here, sqlmap has confirmed that Peruggia's <strong class="bold">Add Comment</strong> page is vulnerable to SQL injection, both by attempting time-based blind SQL injection and <strong class="source-inline">UNION</strong> queries. At this point, we <a id="_idIndexMarker226"/>know that the parameter is vulnerable, and we can dig deeper.</p>
			<p>We will <a id="_idIndexMarker227"/>now use sqlmap for database enumeration. First, we will try to obtain all the databases from the server. To do so, we need to insert the following input into the terminal:</p>
			<p class="source-code">sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&amp;pic_id=1" –-dbs</p>
			<p>After running the command, we will get our results. This confirms our manual enumeration attempt, by listing all of the databases that are present on the server:</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B15632_04_048.jpg" alt="Figure 4.48 – sqlmap successful database enumeration attempt&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.48 – sqlmap successful database enumeration attempt</p>
			<p>Now, we can <a id="_idIndexMarker228"/>select a database to explore further. We can <a id="_idIndexMarker229"/>retrieve tables within one of them (Peruggia) by running sqlmap with the <strong class="source-inline">sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&amp;pic_id=1" –-tables -D peruggia</strong> input:</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B15632_04_049.jpg" alt="Figure 4.49 – sqlmap extracting tables belonging to Peruggia's database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.49 – sqlmap extracting tables belonging to Peruggia's database</p>
			<p>At this point, since we have tables, we can proceed to extract all the information inside the table. We will use the dump functionality of sqlmap, which will extract the full content of a table. To do this, we need to use <strong class="source-inline">sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&amp;pic_id=1" –dump -D peruggia -T users</strong> in the terminal for the full extraction of the <strong class="source-inline">users</strong> table. sqlmap also has a built-in password cracking module to check for password hashes, which we will use here.</p>
			<p>The final result, complete with the passwords obtained from the stored hashes, will be displayed at the end of the output in a table-like format:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B15632_04_050.jpg" alt="Figure 4.50 – Dumping the users table from the Peruggia database, complete with passwords&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.50 – Dumping the users table from the Peruggia database, complete with passwords</p>
			<p>Of course, besides <a id="_idIndexMarker230"/>supporting HTTP <strong class="source-inline">GET</strong> requests (such as in this example) sqlmap also supports <strong class="source-inline">POST</strong> requests with the <strong class="source-inline">--data</strong> option. In this way, we can <a id="_idIndexMarker231"/>also attack web pages containing forms. We will try <a id="_idIndexMarker232"/>an attack payload suggested by the <strong class="bold">Mutillidae II</strong> application hint section, just to show the functionality in an easy and replicable way:</p>
			<p class="source-code">sqlmap -u "http://192.168.56.101/mutillidae/index.php?page=view-someones-blog.php" --data="author=6C57C4B5-B341-4539-977B-7ACB9D42985A&amp;view-someones-blog-php-submit-button=View+Blog+Entries" --level=1 --dump</p>
			<p>The <strong class="source-inline">--data</strong> option is accompanied by the data to pass within the form for the request. This will result in a similar outcome with respect to the previous attacks made against <strong class="source-inline">GET</strong> requests. <strong class="source-inline">POST</strong> parameters can be extracted by examining valid requests and can be inserted as data. Be warned, however: due to the multiple parameters, this attack might take much longer than the previous ones.</p>
			<p>sqlmap results, including logs and dumps, are always saved in the filesystem, in a folder specified at the end of the sqlmap output (usually, <strong class="source-inline">/home/&lt;linux user&gt;/.sqlmap/output</strong>). This turns out to be very useful, especially in the case of a rich output (such as this one):</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B15632_04_051.jpg" alt="Figure 4.51 – sqlmap results for a POST-based attack, as displayed in a CLI text editor&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.51 – sqlmap results for a POST-based attack, as displayed in a CLI text editor</p>
			<p>Database dumps are also saved—in CSV format—preserving the table-like structure that is typical of SQL:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B15632_04_052.jpg" alt="Figure 4.52 – The resulting dump files from the last extraction&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.52 – The resulting dump files from the last extraction</p>
			<p>In the end, sqlmap is a very useful tool for testing SQL injection, providing the capability of both scanning for possible SQL injection vulnerabilities and extracting data in an automated way, and even <a id="_idIndexMarker233"/>avoiding manual intervention altogether in some cases. Data is also conveniently saved in your filesystem for future reference, while the built-in password cracking module can crack passwords from stored hashes at runtime, by brute-forcing.</p>
			<p>This concludes <a id="_idIndexMarker234"/>our voyage through web application testing for SQL injection. We have explored manual techniques in great depth, while also examining possibilities for automated testing, showing how this can be convenient by saving precious time in testing operations.</p>
			<p>We will now change the topic to discuss how SQL injection can be extended to other environments that are different from traditional web applications and can be accessed and explored through web browsers.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor079"/>Attacking mobile targets</h1>
			<p>Mobile applications are, as their <a id="_idIndexMarker235"/>name suggests, applications that reside, even partially, on mobile devices. This means that they differ, both in approach and execution, with respect to traditional web applications.</p>
			<p>In traditional web applications, our main access is usually in the form of a web browser. This is so that the entire interface is rendered within it, and it is sent by servers in the form of an HTTP response containing all that is needed to visualize it as intended, including client-side code (such as JavaScript).</p>
			<p>Mobile applications have, as opposed to a browser that can interpret any HTTP response, a specific client residing on the mobile device itself. This already has all of the graphics and client-side code within it. This means that the communication between the client and the server in a mobile environment is usually more lightweight, that is, it only consists of the little information that is essential to communicate. This is where web services come into play: they represent a way to exchange only the information that is needed for an application to function.</p>
			<p>Let's look at <a id="_idIndexMarker236"/>the web services in action. Mutillidae II gives us the option to test in the web service (<strong class="bold">SOAP</strong> or <strong class="bold">Simple Object Access Protocol</strong>) environment. Provided we send data in a format that the web service accepts, we can perform <a id="_idIndexMarker237"/>the same basic functionalities of the application. Let's go to the <strong class="bold">User Lookup (SQL)</strong> page that we saw in Mutillidae II, and click on the <strong class="bold">Switch to SOAP Web Service version</strong> button:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B15632_04_053.jpg" alt="Figure 4.53 – Mutillidae II User Lookup page; notice the Web Service version button&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.53 – Mutillidae II User Lookup page; notice the Web Service version button</p>
			<p>By clicking <a id="_idIndexMarker238"/>on the highlighted link, we will access a very minimal web page, consisting only of links to the <strong class="bold">Web Service Declaration Language</strong> (<strong class="bold">WSDL</strong>)—the language definition for our SOAP web service—and the functions supported by it:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B15632_04_054.jpg" alt="Figure 4.54 – Mutillidae II User Lookup Web Service page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.54 – Mutillidae II User Lookup Web Service page</p>
			<p>By clicking <a id="_idIndexMarker239"/>on each function, we can see the input and output information for each operation. We can interact with such web services by using specifically crafted requests in the language specified by the <strong class="bold">WSDL</strong>. For example, if we wanted to interact using the <strong class="source-inline">getUser</strong> function, we would need a request with the following body:</p>
			<p class="source-code">&lt;soapenv:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:urn="urn:ws-user-account"&gt;</p>
			<p class="source-code">   &lt;soapenv:Header/&gt;</p>
			<p class="source-code">   &lt;soapenv:Body&gt;</p>
			<p class="source-code">      &lt;urn:getUser soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"&gt;</p>
			<p class="source-code">         &lt;username xsi:type="xsd:string"&gt;username_here&lt;/username&gt;</p>
			<p class="source-code">      &lt;/urn:getUser&gt;</p>
			<p class="source-code">   &lt;/soapenv:Body&gt;</p>
			<p class="source-code">&lt;/soapenv:Envelope&gt;</p>
			<p>We will try using the <strong class="source-inline">getUser</strong> function to return all users with a tautology. We will insert the <strong class="source-inline">' OR 1=1 -- -</strong> payload as the username to send (in place of <strong class="source-inline">username_here</strong> in the preceding request). We should get a similar response to the one obtained in the web app scenario:</p>
			<p class="source-code">      &lt;a<a id="_idTextAnchor080"/>ccounts message="Results for ' OR 1=1 -- -"&gt;</p>
			<p class="source-code">         &lt;account&gt;</p>
			<p class="source-code">            &lt;username&gt;admin&lt;/username&gt;</p>
			<p class="source-code">            &lt;signature&gt;g0t r00t?&lt;/signature&gt;</p>
			<p class="source-code">         &lt;/account&gt;</p>
			<p class="source-code">         &lt;account&gt;</p>
			<p class="source-code">            &lt;username&gt;adrian&lt;/username&gt;</p>
			<p class="source-code">            &lt;signature&gt;Zombie Films Rock!&lt;/signature&gt;</p>
			<p class="source-code">         &lt;/account&gt;</p>
			<p class="source-code">…</p>
			<p>In this example, we've seen that web services, despite using a different means of communication with respect to traditional web applications, can still be vulnerable to SQL injection. We will now explore what this means for mobile applications specifically.</p>
			<p>Many mobile <a id="_idIndexMarker240"/>applications, much like web applications, rely on databases to store data permanently. Some of these have a SQLite database in the client itself. This, by best practice, should not contain sensitive information, as it can be extracted from the device itself. We are more interested in server-stored databases. In this case, they function identically to web applications, with the only difference being the means of sending and receiving information. You guessed it: mobile applications can be vulnerable to SQL injection too.</p>
			<p>We have prepared an Android mobile application and a simple web service. We will guide you through the import and deployment process so that you can use them for testing too.</p>
			<p>First, we need to configure and run the we<a href="https://github.com/PacktPublishing/SQL-Injection-Attack-and-Defense-Strategies">b service:</a></p>
			<ol>
				<li value="1"><a href="https://github.com/PacktPublishing/SQL-Injection-Attack-and-Defense-Strategies">Download the web service application from GitHub, using this reposi</a>tory: https://github.com/PacktPublishing/SQL-Injection-Attack-and-Defense-Strategies. You can find the web service in the <strong class="source-inline">C4</strong> subdirectory, inside <strong class="source-inline">MasteringSQLInjection-WebServices</strong>:<div id="_idContainer116" class="IMG---Figure"><img src="image/B15632_04_055.jpg" alt="Figure 4.55 – GitHub repository&#13;&#10;"/></div><p class="figure-caption">Figure 4.55 – GitHub repository</p></li>
				<li>Open <a id="_idIndexMarker241"/>Eclipse and create a new <strong class="bold">Dynamic Web Project</strong> (<strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Dynamic Web Project</strong>), then select the <strong class="bold">New Runtime</strong> option. Set the runtime by selecting, as <strong class="bold">Target runtime</strong>, <strong class="bold">Apache Tomcat v9</strong>. Then, click on <strong class="bold">Finish</strong>:<div id="_idContainer117" class="IMG---Figure"><img src="image/B15632_04_056.jpg" alt="Figure 4.56 – Creating a server runtime in new dynamic web project&#13;&#10;"/></div><p class="figure-caption">Figure 4.56 – Creating a server runtime in new dynamic web project</p></li>
				<li>Open the <a id="_idIndexMarker242"/>directory that you downloaded to your computer, go to the <strong class="source-inline">src</strong> folder, and drag and drop the files below the <strong class="source-inline">src</strong> folder in the <strong class="source-inline">Java Resources</strong> folder, which is contained in Eclipse's <strong class="bold">Project Explorer</strong> tab. Click on <strong class="bold">OK</strong> in the pop-up window:<div id="_idContainer118" class="IMG---Figure"><img src="image/B15632_04_057.jpg" alt="Figure 4.57 – The src folder in Java Resources, in Eclipse&#13;&#10;"/></div><p class="figure-caption">Figure 4.57 – The src folder in Java Resources, in Eclipse</p></li>
				<li>Double-click <a id="_idIndexMarker243"/>on the server in the <strong class="bold">Servers</strong> tab. Then, set port number <strong class="source-inline">8081</strong> in the configuration that opens. Save the settings by pressing <em class="italic">Ctrl</em> + <em class="italic">S</em>:<div id="_idContainer119" class="IMG---Figure"><img src="image/B15632_04_058.jpg" alt="Figure 4.58 – Setting up the server&#13;&#10;"/></div><p class="figure-caption">Figure 4.58 – Setting up the server</p></li>
				<li>Now that you have your code and runtime, navigate to the <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Web Service</strong> option. Be sure to bring the two sliders up to <strong class="bold">Test Client</strong> and <strong class="bold">Test Service</strong>, respectively, in the interface. Keep everything else in their default settings: <div id="_idContainer120" class="IMG---Figure"><img src="image/B15632_04_059.jpg" alt="Figure 4.59 – Setting up the web service (1)&#13;&#10;"/></div><p class="figure-caption">Figure 4.59 – Setting up the web service (1)</p></li>
				<li>Use the <strong class="bold">Browse</strong> button <a id="_idIndexMarker244"/>pointing at your package in the <strong class="bold">Service implementation</strong> field and implementation class (<strong class="source-inline">com.packt.masteringsqlj.service.IOTMgmtServiceImplementation</strong>), and then click on <strong class="bold">Next</strong>. Then, click on <strong class="bold">Next</strong> again:<div id="_idContainer121" class="IMG---Figure"><img src="image/B15632_04_060.jpg" alt="Figure 4.60 – Setting up the web service (2)&#13;&#10;"/></div><p class="figure-caption">Figure 4.60 – Setting up the web service (2)</p></li>
				<li>After a while, you'll see a <strong class="bold">Server startup</strong> window. Click on <strong class="bold">Start server</strong> to finally start the server, then click on <strong class="bold">Next</strong>, and select <strong class="bold">Launch</strong> in the following window. Your web <a id="_idIndexMarker245"/>service should now start:</li>
			</ol>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B15632_04_061.jpg" alt="Figure 4.61 – Server startup&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.61 – Server startup</p>
			<p>After loading and setting up the web service, let's load the application to our Android emulator using Android Studio:</p>
			<ol>
				<li value="1">You should already have the code from the repository you previously downloaded. This time, you can find it in the <strong class="source-inline">MasteringSQLInjection-AndroidApp</strong> subdirectory in <strong class="source-inline">C4</strong>.</li>
				<li>Open Android Studio. Select <strong class="bold">Open an existing Android Studio project</strong>. Select the downloaded folder when prompted:<div id="_idContainer123" class="IMG---Figure"><img src="image/B15632_04_062.jpg" alt="Figure 4.62 – Android Studio startup instructions&#13;&#10;"/></div><p class="figure-caption">Figure 4.62 – Android Studio startup instructions</p></li>
				<li>From the <a id="_idIndexMarker246"/>newly started web service screen, take the <strong class="bold">Endpoints</strong> information from the <strong class="bold">Actions</strong> tab:<div id="_idContainer124" class="IMG---Figure"><img src="image/B15632_04_063.jpg" alt="Figure 4.63 – Endpoint information of the web service&#13;&#10;"/></div><p class="figure-caption">Figure 4.63 – Endpoint information of the web service</p></li>
				<li>Copy the endpoint information in the <strong class="source-inline">ENDPOINT</strong> variable of the <strong class="source-inline">Utils</strong> class. Remember to change <strong class="source-inline">localhost</strong> to your computer's IP address:<div id="_idContainer125" class="IMG---Figure"><img src="image/B15632_04_064.jpg" alt="Figure 4.64 – Editing the Utils class&#13;&#10;"/></div><p class="figure-caption">Figure 4.64 – Editing the Utils class</p></li>
				<li>Start the application by clicking on the run/play icon, as shown in the following screenshot: </li>
			</ol>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B15632_04_065.jpg" alt="Figure 4.65 – The run icon in Android Studio&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.65 – The run icon in Android Studio</p>
			<p>Now that we <a id="_idIndexMarker247"/>have our environment up and running, we can use our simple application and show SQL injection in a mobile setting:</p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B15632_04_066.jpg" alt="Figure 4.66 – Mobile application login screen&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.66 – Mobile application login screen</p>
			<p>The application shows a rather simple login screen. We can try the tautology attack with our usual payload (<strong class="source-inline">' OR 1=1 -- -</strong>). This will grant us access. The reason for this is the same as the web service example we saw earlier; that is, because the underlying database (MySQL) does not <a id="_idIndexMarker248"/>apply any security measure, and it does not sanitize input on its own.</p>
			<p>Now that we've demonstrated how SQL injection can impact mobile applications too, we will move on to the IoT environment. Keep the mobile application running it will be useful for our next attack scenario.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor081"/>Attacking IoT targets</h1>
			<p>When dealing with IoT devices, we usually consider a complex environment in which these devices are usually at the outermost end of an interconnected network. We usually refer to small devices <a id="_idIndexMarker249"/>with low computational power—such as sensors, little appliances, and more—often running embedded systems with minimal functionality. This is because these devices are designed to perform very specialized tasks, which do not require complex operating systems. The result consists of small, handy devices that are always connected and are communicating with other devices, being other small IoT devices or servers, that might collect some kind of data, be it from measuring or input from the device itself.</p>
			<p>IoT has been a hot topic recently, and many are investing in these practical technologies, which help to integrate technology in the everyday world. However, at the same time, security has sometimes been neglected in these systems. This is probably due to the limited <a id="_idIndexMarker250"/>resources that are available on such devices. This includes the possibility that some devices that use information from a database can be, affected by SQL injection.</p>
			<p>For this scenario, we will use our mobile application—the same that we used in the previous section—to interact with (hypothetical) IoT devices through a database running on a web server. In the IoT environment, the network is distributed, and instructions may come from different parts of a network, even a mobile device. The application, in fact, after a successful admin level login, will allow the authenticated user to modify the status of an IoT device that is connected to the application:</p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B15632_04_067.jpg" alt="Figure 4.67 – Status panel for our application&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.67 – Status panel for our application</p>
			<p>Behind this panel, there is, of course, a SQL query. Once the query is sent, we can modify it similarly to <a id="_idIndexMarker251"/>how we did earlier, in the web service scenario. This time, we will insert <strong class="source-inline">', status =(SELECT password FROM iot_mgmt_system.user WHERE username='admin' LIMIT 1) --</strong> (don't forget the blank space at the end) to edit the status of the device, including relevant information (in this case, the password for the <strong class="source-inline">admin</strong> account of the mobile application):</p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B15632_04_068.jpg" alt="Figure 4.68 – Status changed by our payload&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.68 – Status changed by our payload</p>
			<p>IoT devices could also be attacked in other ways. However, most of the time, these are in the realm of web application attacks—as devices can have a web interface for interacting with settings or configurations—or other traditional means, such as any computer system (for example, attacking open ports and services).</p>
			<p>While our example is, of course, a simplified mock-up scenario, the message is always the same: if any application, be it web-based, mobile, or a web service, does not properly check for the input, the underlying <a id="_idIndexMarker252"/>database can be irremediably compromised.</p>
			<p>Imagine a scenario in which a controller sends non-sanitized SQL input to a server that controls critical devices, in a more realistic scenario. What if a malicious user could entirely alter the database, totally compromising its control functionality? In this way, the damage could be extended to the real world, as IoT can be responsible for performing tasks <a id="_idIndexMarker253"/>in critical environments such as smart cities, surveillance (for example, cameras), smart meters for critical infrastructure (for example, water distribution), or medical facilities.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Practice these skills in controlled environments only, without involving third parties. The use of security tools and attack techniques is illegal without the consent of the owner of the targets, so you could get yourself in trouble if you try these techniques on websites or systems you don't own.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor082"/>Summary</h1>
			<p>So, here we are at the end of this long and practical chapter. We've explored many different scenarios, applications, and attacks that are made possible by exploiting vulnerable application components that interact with SQL databases. </p>
			<p>Mutillidae II gave us a glimpse of the basic attacks that can occur through SQL injection. Additionally, the Magical Code Injection Rainbow provided us with some challenges to wrap our heads around (which you could solve by applying what you've learned so far), sometimes, with twists. Finally, Peruggia helped us to apply our knowledge to a pseudo-realistic environment.</p>
			<p>After dealing with manual SQL injection attacks, we learned what is possible using common software tools to automate SQL injection, both for scanning and attacking. We saw this with the Spider, Scan, and Fuzz modules of OWASP ZAP and sqlmap. We showed how manual intervention can be reduced significantly, improving efficiency for attackers and security testers alike (and demonstrating, once again, the importance of securing web applications that could be compromised in a matter of seconds).</p>
			<p>Finally, we looked at simple web service and mobile applications, where a SQL injection vulnerability can extend far beyond the concept of traditional web applications, ranging from mobile applications to even IoT devices, as long as they deal with SQL.</p>
			<p>In the next chapter, we will see, more specifically, what can be done to secure web applications in general, and how attempts at performing SQL injection can be thwarted using various measures. We have already looked at several examples using the Magical Code Injection Rainbow, as some of the earlier challenges applied some (incomplete) measures. We will learn how, if done right, correct security measures can prevent this type of attack.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor083"/>Questions</h1>
			<ol>
				<li value="1">Why is binary search useful when performing blind SQL injection?</li>
				<li>Do you know a way to perform data extraction through a SQL error?</li>
				<li>Which OWASP ZAP tools can be used for automated SQL injection?</li>
				<li>Can sqlmap be used to extract passwords from hashes?</li>
				<li>Is SQL injection limited to web applications? Name all the target typologies you've seen in this chapter.</li>
			</ol>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor084"/>Further reading</h1>
			<p>To explore attack vectors an<a href="https://osandamalith.com/2017/02/08/mysql-injection-in-update-insert-and-delete/">d further research on <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, and <strong class="source-inline">DELETE</strong> statements, we suggest the foll</a>ow<a href="https://osandamalith.com/2014/04/26/injection-in-insert-update-and-delete-statements/">ing resources:</a></p>
			<ul>
				<li><a href="https://osandamalith.com/2014/04/26/injection-in-insert-update-and-delete-statements/">https://osandamalith.com/2017/02/08/mysql-injection-in-update-insert-a</a>n<a href="https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/">d-delete/ </a></li>
				<li><a href="https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/">https://osandamalith.com/2014/04/26/injection-in-insert-update-and-delete-state</a>ments/</li>
				<li>https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/</li>
			</ul>
		</div>
	</body></html>