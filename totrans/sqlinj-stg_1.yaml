- en: '*Chapter 4*: Attacking Web, Mobile, and IoT Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we are at the fun part of our journey—the core of the practical section
    of this book. So far, we have looked at both the basics and the mechanics of SQL
    injection, including a glimpse of what a successful SQL injection attack can do.
    We also provided a safe and controlled environment that anyone can experience,
    at their own pace, of what a SQL injection attack consists of.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will deal with SQL injection attacks against traditional
    web applications, which is the most common scenario, using both manual and automated
    techniques, relying on the toolset that we discussed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is split into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attacking traditional web applications – manual techniques**: This section
    shows SQL injection attacks performed manually against the vulnerable web applications
    contained in the OWASP **Broken Web Applications** (**BWA**) virtual web server.
    These attacks will be familiar to you, as they are similar to what you''ve already
    encountered in [*Chapter 2*](B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031),
    *Manipulating SQL – Exploiting SQL Injection*. However, here, we will try a more
    realistic approach by guiding you through the steps that an attacker would follow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attacking traditional web applications– automated techniques**: Once again,
    our target will consist of web applications included within the OWASP BWA project.
    This time, though, we will show the capabilities of automated tools for SQL injection,
    which are used by attackers (and security professionals alike) for efficiency
    purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attacking mobile targets**: In this section, we will look at how mobile applications
    can also be vulnerable to SQL injection attacks, showing practical examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attacking IoT targets**: SQL databases can be vulnerable to SQL injection
    whatever the context they find themselves in. The IoT world is no exception. We
    are showing here an attack scenario that could interest IoT systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this very practical chapter, we strongly recommend that you familiarize
    yourself with the main tools involved. We recommend the following resources, including
    the references from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: https://[www](https://www.virtualbox.org/).virtualbox.org/
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.kali.org/docs/](https://www.kali.org/docs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://owasp.org/www-project-broken-web-applications/](https://owasp.org/www-project-broken-web-applications/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.android.com/studio](https://developer.android.com/studio)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.eclipse.org/](https://www.eclipse.org/downloads/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.kali.org/docs/](https://www.kali.org/docs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/sqlmapproject/sqlmap](https://github.com/sqlmapproject/sqlmap)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.zaproxy.org/](https://www.zaproxy.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://owasp.org/www-project-broken-web-applications/](https://owasp.org/www-project-broken-web-applications/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/32d3s2b](https://bit.ly/32d3s2b
    )'
  prefs: []
  type: TYPE_NORMAL
- en: Attacking traditional web applications– manual techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s begin with manual attacks against OWASP BWA web applications. We already
    found, in [*Chapter 2*](B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031), *Manipulating
    SQL – Exploiting SQL Injection*, an easy attack point for extracting information
    through SQL injection, but we will pretend that each application is independent
    and does not share the same instance of MySQL. For this reason, we will not consider
    the OWASP Vicnum application for this purpose, as it would make things too easy
    for us. Each application will be considered as a separate target so that we can
    explore the intrinsic vulnerabilities residing in them. In this section, we will
    perform SQL attacks against three of the OWASP BWA applications: **Mutillidae
    II**, **Magical Code Injection Rainbow**, and **Peruggia**, putting in practice
    what you have learned so far in a guided setting.'
  prefs: []
  type: TYPE_NORMAL
- en: Attacking Mutillidae II
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first target is kind of a warm-up—**Mutillidae II** is an application designed
    to provide a test environment for SQL injection using an educational approach,
    also providing some hints about possible attacks that can be executed. You can
    access the SQL Injection section by going through the drop-down menu on the left
    (**OWASP 2013** | **A1 - injection (SQL)**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – SQL data extraction page in Mutillidae II'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – SQL data extraction page in Mutillidae II
  prefs: []
  type: TYPE_NORMAL
- en: Let's now demonstrate how to attack this web application in its SQL injection-vulnerable
    web forms.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data with SQL injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s go to the specific page for data extraction with SQL injection testing
    provided by Mutillidae II, following the drop-down menu. First and foremost, we
    will perform the first step in any SQL injection attack: checking whether any
    input validation is present by inserting the most basic injection character—the
    single quote—in the **Name** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – SQL data extraction page in Mutillidae II: web form'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.2 – SQL data extraction page in Mutillidae II: web form'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just inserting SQL injection enabling characters can be enough to prove the
    presence of a SQL injection vulnerability. If we have a SQL error, it means that
    the input is interpreted, thus making the query syntax incorrect. After inserting
    the single quote, we do, in fact, get a SQL syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Error message visualization provided by Mutillidae II (0 security)'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Error message visualization provided by Mutillidae II (0 security)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Mutillidae II set at the lowest security level, the error information
    is complete, and also helps us to visualize the complete error information. Let''s
    increase the security level using the **Toggle Security** option, by clicking
    on it once and applying client-side security:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Example of client-side control in Mutillidae II'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Example of client-side control in Mutillidae II
  prefs: []
  type: TYPE_NORMAL
- en: In this case, client-side controls have been applied, preventing blank input
    fields and blocking suspicious characters if both fields are filled, such as inserting
    **' -- -** as the username and any character as the password (such input should,
    if no security controls are applied, entirely ignore what's after the single quote
    character).
  prefs: []
  type: TYPE_NORMAL
- en: However, client-side controls are not enough to prevent SQL injection. What
    if we bypass them by using, for example, the parameters in the URL address? (Yes,
    this login happens using **GET** requests by sending data in the URL as input
    parameters.)
  prefs: []
  type: TYPE_NORMAL
- en: Let's modify the page URL in the following way. Here, we have a normal URL for
    this page, with **a** as the username and **b** as the p[assword:](http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=a&password=b&user-info-php-submit-button=View+Account+Details)
  prefs: []
  type: TYPE_NORMAL
- en: '[http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=a&password=b&user-info-php-submit-button=View+Accoun](http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=a&password=b&user-info-php-submit-button=View+Account+Details)t+Details'
  prefs: []
  type: TYPE_NORMAL
- en: We are just adding a single quote instead of the [username:](http://192.168.56.101/mutillidae/index.php?page=user-info.php&username='&password=b&user-info-php-submit-button=View+Account+Details)
  prefs: []
  type: TYPE_NORMAL
- en: '[http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=''&password=b&user-info-php-submit-button=View+Accou](http://192.168.56.101/mutillidae/index.php?page=user-info.php&username=''&password=b&user-info-php-submit-button=View+Account+Details)nt+Details'
  prefs: []
  type: TYPE_NORMAL
- en: 'This triggers another error message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Error message visualization provided by Mutillidae II (client-side
    security)'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Error message visualization provided by Mutillidae II (client-side
    security)
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that, if this was a **POST** request instead of **GET**, modifying
    the request fields would have been enough to cause a SQL injection. This points
    to the importance of having server-side security controls in place. This is the
    only way to ensure that input is properly handled, independent of the means of
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we have proved that the page is vulnerable to SQL injection. The
    input is interpreted as SQL syntax, causing a syntax error due to the incorrect
    statement. The error message also leaks some important information regarding the
    query structure, which could be used to our advantage, and the presence of an
    **accounts** table with fields named **username** and **password**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go a little further with data extraction, shall we? Once we've seen that
    SQL injection is possible, we can try and see whether other techniques work so
    that we can extract data. In a greedy approach, we will now try to see whether
    tautologies work or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try the infamous **'' or 1=1 -- -** string in the username field (in
    the case of client-side security, we would need to edit the parameters just like
    in the previous example without actually using the form). This attempt leads to
    the result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Result page for all of the account information records'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.6 – Result page for all of the account information records
  prefs: []
  type: TYPE_NORMAL
- en: Using this tautology, we have found the complete login information for all application
    users. At this point, an attacker could gain administrator (**admin**) access
    to the application, with potentially terrible consequences.
  prefs: []
  type: TYPE_NORMAL
- en: So, the application was vulnerable to probably the most powerful SQL injection
    attack to extract information. Let's pretend that this attack was blocked by the
    web application and try a more subtle approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now try to extract database versioning information using a **UNION**
    query. We need to implement a trial-and-error approach in order to see how many
    columns, and which columns, are shown by the application. We''re saving you this
    process: inserting **'' UNION SELECT 1,@@VERSION,3,4,5,6,7 -- -** will work, as,
    apparently, the **accounts** table (we know its name due to the error information)
    has 7 columns, and the application only shows columns 2, 3, and 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Results page for a UNION query to display the system version'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.7 – Results page for a UNION query to display the system version
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we discovered not only the versioning of the system but also
    the total number of columns in the **accounts** table, as the original query selected
    all of the fields (**SELECT ***) for that table.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should now be able to extract information about the database schema. We
    already know the database is MySQL from the error messages and the versioning
    information. So, let''s ask for the schema names in the database schema, as discussed
    in [*Chapter 2*](B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031), *Manipulating
    SQL – Exploiting SQL Injection*. Using the same trick as before, by showing the
    information we need in the second field, we can extract the schema names contained
    in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Schema names extraction'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.8 – Schema names extraction
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to the next section of Mutillidae II SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing authentication with SQL injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section is about bypassing the login screen of the Mutillidae II web application.
    You can access this section from the same drop-down menu, as shown in the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 4.9 – SQL data extraction page in Mutillidae II'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.9 – SQL data extraction page in Mutillidae II
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now face a typical login web form that requires authenticating with
    both **Username** and **Password**. Let''s first check whether this form is vulnerable
    to SQL injection by triggering some errors using SQL characters, such as single
    quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – The Mutillidae II login page showing an undisclosed error'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.10 – The Mutillidae II login page showing an undisclosed error
  prefs: []
  type: TYPE_NORMAL
- en: This time, we can tell that an error has occurred. However, the application
    doesn't show (in accordance with the known best practices) the complete error
    information. Nevertheless, we know that the form is vulnerable, as the response
    differs if the wrong account information is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already extracted the login information from the previous section,
    so we will try the **admin** access using known credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Admin access success'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.11 – Admin access success
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check whether the form is vulnerable to a tautology attack, thus
    granting us access. Let''s try inserting the **'' OR 1=1 -- -** string in the
    **Username** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Tautology login attempt'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.12 – Tautology login attempt
  prefs: []
  type: TYPE_NORMAL
- en: This authentication bypass attack will also succeed, granting us access once
    again as the **admin** account. Keep in mind that, even if we can authenticate
    as any account in the system, attackers will try to obtain the highest level of
    privilege possible (after all, most applications allow for the creation of user-level
    accounts).
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to the last SQL injection form type for this application.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection in INSERT statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we''ve looked at SQL injection only in **SELECT** statements. Mutillidae
    II offers an account creation page that is linked to an **INSERT** statement in
    order to add new records to the accounts table of the database. It also offers
    two other pages with the capability of adding data to the database. However, we
    will only cover this page in this section, so as not to take too much from other
    topics. Feel free to explore the other two on your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Accessing the account creation page'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.13 – Accessing the account creation page
  prefs: []
  type: TYPE_NORMAL
- en: 'The account creation page is not supposed to return any records, as its primary
    purpose is to (yes—you guessed it) add users to the accounts table of the database.
    Therefore, it looks like a nice place to try blind SQL injection in this context:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Account creation form'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.14 – Account creation form
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can trigger an error message to check the query syntax and examine
    where we could inject our commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Error message for inserting a single quote as the username'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.15 – Error message for inserting a single quote as the username
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the query structure so that we can alter the command through SQL
    syntax. One example could be to retrieve sensitive information using subqueries
    with the help of **SELECT** statements. Let''s try creating a user with the MySQL
    root account password as a signature. We will first try the **test'',''test'',(SELECT
    password FROM mysql.user WHERE user=''root''))-- -** payload in the username field
    to obtain this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – MySQL error; the subquery returns more than one result'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.16 – MySQL error; the subquery returns more than one result
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the **SELECT** query apparently returned more rows than we thought. To
    solve this problem, we need a way to view a single result. A trivial solution
    is through the **LIMIT 1** clause at the end of the **SELECT** query, which is
    used for limiting the results to only one, resulting in a success. Let''s use
    the login panel to finally check our value using our newly created credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – The Mutillidae II upper panel after successful authentication'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.17 – The Mutillidae II upper panel after successful authentication
  prefs: []
  type: TYPE_NORMAL
- en: Here, an attacker could have used the registration form to retrieve sensitive
    information (in this case, the password hash for the MySQL root account). This
    is despite it not being a query designed to return data. This example was to show
    how SQL injection can provide attackers with versatile tools, as long as the attacker
    knows the appropriate SQL syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now approach the next web application of our crash course: the Magical
    Code Injection Rainbow.'
  prefs: []
  type: TYPE_NORMAL
- en: The Magical Code Injection Rainbow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the **Magical Code Injection Rainbow**, we have an application designed
    for training in code injection. We are interested in the SQL part, aptly named
    **SQLol**, which also provides examples including some server-side defenses. This
    time, we will be going through the first six challenges provided by this application
    and providing solutions for each. Feel free to try them (or the following ones)
    on your own. At this point, with the help of the MySQL documentation, you should
    be able to complete them using what you have learned in [*Chapter 1*](B15632_01_Final_JC_ePub.xhtml#_idTextAnchor020),
    *Structured Query Language for SQL Injection*, and [*Chapter 2*](B15632_02_Final_JC_ePub.xhtml#_idTextAnchor031),
    *Manipulating SQL – Exploiting SQL Injection*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Magical Code Injection Rainbow SQLol - the Challenges screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_018.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.18 – Magical Code Injection Rainbow SQLol - the Challenges screen
  prefs: []
  type: TYPE_NORMAL
- en: Access the challenges by selecting **SQLol** from the home screen, and then
    selecting **Challenges**. You will always have a single text field to insert the
    payload into, so you know that's the only way to insert SQL payloads.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 0 – Hello, world!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the most basic challenge in the list. Here, you need to return all of
    the usernames from the user table of the database using a **SELECT** query, and
    perform the injection in the **WHERE** clause. This is a typical setting for the
    **SELECT** queries that we've seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty simple to do. It's enough to provide a condition where the **WHERE**
    condition is always true, and we know the exact way to do tautologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our payload will be **'' OR 1=1 -- -**, resulting in our desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – SQLol challenge 0 results'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.19 – SQLol challenge 0 results
  prefs: []
  type: TYPE_NORMAL
- en: This was pretty easy, right? We just returned all of the usernames with the
    simplest SQL injection possible. Let's now move on to the second challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 1 – SQL injection 101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is also a fairly simple challenge; that said, it requires a bit of reconnaissance
    in order to discover the query structure. This time, we need to find the table
    containing the social security numbers that are present in the database and return
    the full content in the query output. Once again, we are dealing with a **SELECT**
    query and injecting in the **WHERE** clause:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to uncover what the social security number table is called. To
    do this, we need to check the MySQL **information_schema** table using **UNION**
    queries. We first need to find the table name with the **' UNION SELECT table_name
    FROM information_schema.tables -- -** payload. Alternatively, we could also refine
    the search by adding clauses such as **LIKE** with certain desired characteristics
    (for example, **WHERE table_name LIKE ' %ssn%'** for table names containing **ssn**):![Figure
    4.20 – SQLol challenge 1 results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_020.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.20 – SQLol challenge 1 results
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At this point, we need to extract the column names from the table using the
    **' UNION SELECT column_name FROM information_schema.columns WHERE table_name='ssn'
    -- -** payload:![Figure 4.21 – SQLol challenge 1 results
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_021.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.21 – SQLol challenge 1 results
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we just have to query the **ssn** table for each field one at a time. Alternatively,
    we could use a more elegant solution with the **CONCAT()** operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.22 – SQLol challenge 1 final results'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_022.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.22 – SQLol challenge 1 final results
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have the social security numbers for all users in one place. Let's
    move on to the third challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2 – The Failure of Quote Filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This challenge is a carbon copy of the previous one but with a twist: the single
    quote character, which is the most common enabler for SQL, is entirely ignored
    from the query string, rendering the attack that we just performed ineffective.
    However, the sanitization measure just ignores the character at the input level.
    But what if it''s still evaluated by the database at runtime? Consider the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the **CHAR(27) UNION SELECT 1 -- -** payload to add the value of
    **1** to the end of the query. **CHAR()** is a function, supported in MySQL, that
    translates a number to its ASCII character equivalent. In this case, it is the
    single quote:![Figure 4.23 – SQLol challenge 2: defeating single quote escaping'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_023.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 4.23 – SQLol challenge 2: defeating single quote escaping'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we can perform the challenge 1 attack by substituting the single
    quote with **CHAR(27)**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.24 – SQLol challenge 2 final results'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_024.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.24 – SQLol challenge 2 final results
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to the next challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 3 – Death Row
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This challenge is another clone of the first challenge. However, this time,
    it will only show one result at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we already know the contents of the table, so we will skip to the final
    step of the attack, directly moving to the approach required for this specific
    challenge.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try the same payload. However, this time, add **LIMIT 1** to the end
    to ensure our SQL query returns only one result, independent of the application
    server measures applied to this challenge, and then use **OFFSET** to go through
    each result one at a time. The resulting payload for returning only the second
    result will, therefore, be **'' UNION SELECT CONCAT(name, " ", ssn) FROM ssn LIMIT
    1 OFFSET 1-- -**, as **OFFSET** starts from **0** for the first result and increases
    by one for each subsequent row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25 – The second result of SQLol challenge 3'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_025.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.25 – The second result of SQLol challenge 3
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to the next challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 4 – War on Error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This challenge is another clone of the social security number challenge. However,
    this time, the output will not be visualized. The challenge consists of extracting
    information using only the verbose error messages provided, without the blind
    SQL injection techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Our best bet is to show the query results inside an error message. One possible
    way to do this is through the use of expressions that evaluate some kind of non-strictly
    SQL syntax.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this is the **ExtractValue()** function, which extracts values
    from **XML** (the first argument) using the **XPATH** syntax (the second argument).
    We need to make sure there are no empty spaces in between, so as not to generate
    SQL syntax errors. Instead, we need to cause an XML evaluation error, possibly
    via the misconstruction of the **XPATH** syntax, and insert our SQL query inside
    of it. This is so that the SQL syntax is correctly evaluated and the query results
    are leaked in the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will try the following payload. Note that since we can only view one result
    at a time, we need the **LIMIT 1** clause when changing the offset each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '''AND ExtractValue(''randomxml'',CONCAT(''='',(SELECT CONCAT(name,''-'',ssn)
    FROM ssn LIMIT 1 OFFSET 0)))=''x'
  prefs: []
  type: TYPE_NORMAL
- en: 'The payload worked as intended, and the query result is shown as an **XPATH**
    syntax error. We only need to iterate the query with all of the remaining offsets,
    and we can extract the entirety of the table''s contents through error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26 – SQLol challenge 4 result'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_026.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.26 – SQLol challenge 4 result
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have demonstrated this interesting attack method, let's finally
    move on to our last challenge from this application.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 5 – Blind Luck
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This final challenge is another social security number challenge. However, this
    time, both the output and error messages are not visualized. The challenge consists
    of extracting information using blind SQL injection techniques. To help us, we
    have Boolean results that tell us whether the query is successful (that is, whether
    it returns at least one record) or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to extract the information from the SSN table, then, this time,
    we would need to use inference techniques. Luckily, we don''t need to check for
    particularly cryptic clues in the response, since we can rely on the Boolean result.
    First, just to show the Boolean result, we will look for the **ssn** table by
    querying the **information_schema.tables** table. We will inject the **'' UNION
    SELECT table_name FROM information_schema.tables WHERE table_name=''ssn''-- -**
    payload to check for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27 – SQLol challenge 5 Boolean result'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_027.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.27 – SQLol challenge 5 Boolean result
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what a true result looks like, we can guess the output using
    checks. Since we need to reconstruct the data, we need a way to spot the content
    of the table using only Boolean answers. The most common technique we can use
    is to check for single characters using the **SUBSTRING(s, d, n)** function. This
    takes, given s tring **s**, the number (**n**) of characters after the position,
    **p**, of that string. **SUBSTRING('hello', 1, 1)** would return **h**, which
    is located at a **1** character distance after the first position (**1**).
  prefs: []
  type: TYPE_NORMAL
- en: 'For each record, we will check the characters of the fields one by one, using
    both the **SUBSTRING()** function and the **LIMIT 1 OFFSET** clause, as we need
    to check each record separately in order to infer them with certainty. This is
    definitely a long process, but we have another trick up our sleeve to speed it
    all up: **binary search**. We will use the **ASCII()** function, which returns
    the ASCII encoding number of a single character, and compare it each time with
    a number, which will be the pivot of our binary search. In the ASCII encoding,
    we have 255 possible values, so our optimal pivot will be the middle value (128).
    By comparing this with 128, we can tell whether the character belongs to the lower
    or upper part of the range, and we will split our possible range into two each
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: If, for example, our check tells us that the character's ASCII is equal or greater
    than 128, then next time we will try with 192 as the pivot. If not, we will go
    down to 64\. Each time, we will be splitting the range into two, thus drastically
    reducing the number of steps for guessing.
  prefs: []
  type: TYPE_NORMAL
- en: For this walk-through, once again, we will skip directly to the **ssn** table.
    However, for the complete attack, you should apply this method to all of the earlier
    discovery steps and the table fields too. We prefer to leave this up to the reader
    to decide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try using the **'' OR ASCII(SUBSTRING((SELECT NAME FROM SSN LIMIT 1
    OFFSET 0),1,1)) >= 128 -- -** payload to apply this principle to our specific
    case, with number 128 as the pivot of our search:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28 – SQLol challenge 5 inference attempt; no results'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_028.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.28 – SQLol challenge 5 inference attempt; no results
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the step-by-step iterative process for the binary search:'
  prefs: []
  type: TYPE_NORMAL
- en: With a false result, we can infer that our character belongs to the first 128
    (0 to 127) ASCII characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using 64 (128/2) as the pivot for our binary search returns a true result. This
    means our character is within the range of 64 and 127.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pivot 96 (64 + 32) doesn't return any results, so we will try 80 (96-16). Still,
    there are no results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our next attempt is 72 (80 - 8), which succeeds. This means we will try 76 (72
    + 4) next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '76 fails, which means our number is within the range of 72 and 75\. At this
    point, we will try 72:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.29 – Final step of inference; direct comparison (success)'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_029.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.29 – Final step of inference; direct comparison (success)
  prefs: []
  type: TYPE_NORMAL
- en: Following these steps, we know that the first character of the first record
    corresponds to the ASCII character of 72, which is capital **H** (the first letter
    of the name, **Herp Derper**, in the **ssn** table).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can obtain all of the values from our table by applying the same
    principle for all characters of any entries and fields we want, and also use it
    for double-checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30 – SQLol Challenge 5; inference double-check'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_030.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.30 – SQLol Challenge 5; inference double-check
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes our guided tour through the SQL challenges of the Magical Code
    Injection Rainbow. We would love to go on with this fun walk-through, but we don''t
    want to give too much space to this application, so instead, we''ll focus on a
    wider range of targets. We will now proceed with our last OWASP BWA target for
    this section: the Peruggia web app.'
  prefs: []
  type: TYPE_NORMAL
- en: Attacking Peruggia
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated in [*Chapter 3*](B15632_03_Final_JC_ePub.xhtml#_idTextAnchor050),
    *Setting Up the Environment*, Peruggia is a purposely vulnerable web app that
    mimics the behavior of a regular (despite possibly dated) web application. In
    this case, we won''t have tutorials or challenges, but it''s just us and the application,
    with no hints or help whatsoever:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31 – The Peruggia home screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_031.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.31 – The Peruggia home screen
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at how we can use SQL injection to attack this application.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection in the login panel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first stop is the login panel of the application. We can access it by clicking
    on **Login** at the top of the page. Here, we have a scenario where we don't have
    any output from our SQL injection attempts. In fact, no SQL errors are even displayed
    (as it should be in a secure application, after all).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, by examining the page and its response and interaction, we can't
    grasp any meaningful differences between a successful SQL injection attempt or
    an unsuccessful one. This means that we have no way of extracting information
    from the login form. The application enforces a good design principle in this
    case by not letting the database server communicate directly with the user. However,
    this is not enough. Even if the application does not let the database server expose
    query results, errors, or any other meaningful information, that does not mean
    it is not vulnerable to SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s attempt the most trivial SQL injection attack: a tautology. In most
    cases, an attempt like this would result in a total login bypass, granting us
    access to the application. In the following screenshot, we are attempting a tautology
    attack, as demonstrated in the previous applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32 – Peruggia login bypass attempt'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_032.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.32 – Peruggia login bypass attempt
  prefs: []
  type: TYPE_NORMAL
- en: 'The tautology attack has succeeded. This not only means that the web application
    is vulnerable to SQL injection, but we can use the login screen to perform inference
    attacks. Whenever access is granted, this means that the Boolean check we are
    performing is true, as confirmed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33 – Peruggia''s upper screen after a successful admin login'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_033.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.33 – Peruggia's upper screen after a successful admin login
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that, similarly to challenge 5 of the Magical Code Injection Rainbow
    SQLol, we can extract whatever information we want from the database. Let''s try
    the same double-check query we made at the end of challenge 5\. This time, we
    will extract data from a different schema, so we need to specify the schema of
    the table we are extracting data from:'
  prefs: []
  type: TYPE_NORMAL
- en: ''' OR (SELECT NAME FROM SQLOL.SSN LIMIT 1 OFFSET 0) = "Herp Derper" -- -'
  prefs: []
  type: TYPE_NORMAL
- en: This will grant us access, which means that the information we checked (again)
    is true. This can be done to apply inference techniques to the content of the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example confirms the power of SQL injection as a flexible means to obtain
    all sorts of information from a database. This attempt could have also worked
    if we had created a new account legitimately. In Peruggia, we also have the **User**
    account, and the login bypass allows us to log in for every user that we want,
    as long as we specify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.34– Peruggia login bypass example'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_034.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.34– Peruggia login bypass example
  prefs: []
  type: TYPE_NORMAL
- en: The resulting query just checks for the **WHERE** condition. In this case, it
    is just the existence of a record with the username, **User**, as we cut the rest
    of the query as a comment. In the end, if this example of SQL injection is present,
    even if the results are not shown directly, the same principles of blind SQL injection
    and inference can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection in the Add Comment page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides the login screen, we also can try other parameters in the application.
    In Peruggia''s home screen, we can try accessing (unauthenticated) the comment
    section through the link marked **Comment on this picture**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.35 – Peruggia''s Add Comment page (with URL)'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_035.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.35 – Peruggia's Add Comment page (with URL)
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a **pic_id** parameter in the page URL, which we could try to manipulate.
    If we changed it to a nonexistent ID, such as **123456789**, we would visualize
    an empty picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.36 – Peruggia''s Add Comment page for nonexistent pictures'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_036.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.36 – Peruggia's Add Comment page for nonexistent pictures
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will try to insert the correct SQL syntax and see whether it''s evaluated
    by the application. Let''s try inserting **123456789 OR 1=1** into our address
    bar as the **pic_id** parameter. We can see that, even if we insert the wrong
    ID, we visualized the picture present with ID **1** anyway. This proves that the
    parameter evaluates SQL input, and, therefore, is vulnerable to SQL injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.37 – The pic_id parameter is vulnerable to SQL injection'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_037.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.37 – The pic_id parameter is vulnerable to SQL injection
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, using a trial-and-error approach, we can see whether we can
    visualize information from the database. We can try the **UNION** query techniques
    and guess the number of parameters in the underlying SQL query. We can assume
    that the picture ID corresponds to one of these parameters along with, possibly,
    the picture URL (we will see a broken picture icon in the case of a nonexistent
    ID) and **Uploaded By** displayed on the page. However, using the **123456789
    UNION SELECT 1,2,3** payload still returns the empty picture, probably due to
    a MySQL error. Let''s instead try using one more argument, with the **123456789
    UNION SELECT 1,2,3,4** payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.38 – Successful UNION SQL injection'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_038.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.38 – Successful UNION SQL injection
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we know that the underlying query has four arguments, and the
    fourth argument corresponds to the **Uploaded By** value on the page. We can use
    this query to extract all the information we like. As an example, we will try
    to extract the password for the admin account of the application. We could query
    the **information_schema** table to extract the schema of the application (Peruggia)
    and its tables to find the one that corresponds to its user information (users).
    We will then use the **123456789 UNION SELECT 1,2,username,password FROM users
    WHERE username=''admin''** payload to return the password for the account admin
    next to **Uploaded By** on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.39 – Admin password hash returned in the Add Comment page'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_039.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.39 – Admin password hash returned in the Add Comment page
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could use the same field to return any information that we've
    seen so far, such as the password for the **root** MySQL account, the database
    system version, or any data belonging to other tables. This tutorial was primarily
    created to show the consequences and implications of manual SQL injection attacks
    (while also, of course, having fun trying these attacks in a safe and controlled
    environment).
  prefs: []
  type: TYPE_NORMAL
- en: We will now move on to the second part of our practical section, showing what
    can be done with advanced and automated tools using Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking traditional web applications – automated techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, besides performing manual attack techniques to exploit
    SQL injection, it's possible to use specific software that can handle some of
    the tasks involved in SQL injection attacks, producing useful results in a timely
    manner. These tools are used by both attackers and security professionals alike,
    as they optimize operations and help to save a lot of time by simplifying the
    tasks we need to perform.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will go through what is possible to do, in terms of SQL injection,
    with **Zed Attack Proxy** (**ZAP**), which is the attack proxy by OWASP.
  prefs: []
  type: TYPE_NORMAL
- en: OWASP ZAP for SQL injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OWASP ZAP is a versatile tool that consists of an attack proxy—a piece of software
    that is used to intercept traffic in order to monitor it or modify it before it''s
    sent to an application—with other functionalities that help to automate the process.
    In this sense, through automation, this tool can be used to scan web applications
    for vulnerabilities by testing the response received against specific inputs.
    This scanning feature can be used to identify many types of vulnerabilities, including
    SQL injection. Let''s see it action, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's start the software from our Kali Linux machine by typing **zaproxy**
    into our command line. This should load our graphic interface, allowing us to
    insert our target website in the panel on the right (**Quick Start**). We will
    select the **Automated Scan** mode so that we can test the automated capabilities
    of this tool:![Figure 4.40 – OWASP ZAP main screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_040.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.40 – OWASP ZAP main screen
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After selecting the **Automated Scan** option, we are prompted to insert our
    target URL for our tests to begin. We will insert the URL for the instance of
    the Peruggia web application, which is simple enough to show what ZAP is capable
    of:![Figure 4.41 – OWASP ZAP Automated Scan panel
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_041.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.41 – OWASP ZAP Automated Scan panel
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After clicking on **Attack**, our automated scan will begin. First, OWASP ZAP
    will perform a spidering of the application, exploring the links of the application
    and checking the pages that can be explored, in a very period short time. The
    second step of this automated analysis is to activate the scanner module, which
    checks for vulnerabilities by sending specific data to the application, which
    correspond to the input. After a few seconds, we will get our results on the **Alerts**
    tab, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.42 – The OWASP ZAP Alerts tab displaying the issues found'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_042.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.42 – The OWASP ZAP Alerts tab displaying the issues found
  prefs: []
  type: TYPE_NORMAL
- en: OWASP ZAP identified the SQL injection vulnerability in both the **username**
    parameter and the **pic_id** parameter (like we did manually earlier) in just
    a few seconds. Of course, most of the time, the results of these automated scanners
    need to be validated manually, as the scanner indicates the possible presence
    of the SQL injection vulnerability based on the responses received. Despite the
    degree of uncertainty, this functionality returns an indication of such vulnerabilities
    in a matter of seconds along with others (such as **Cross-Site Scripting** and
    **Path Traversal**).
  prefs: []
  type: TYPE_NORMAL
- en: 'OWASP ZAP''s automated capabilities can also be used in your own browser. To
    do this, you need to set up your browser''s proxy as ZAP''s proxy (the default
    is **localhost** on port **8080**). Alternatively, you can launch a browser instance
    directly from ZAP''s interface, using the **Manual Explore** option from the main
    screen. This way, OWASP ZAP opens up a browser window on the specified URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.43 – The OWASP ZAP Manual Explore panel'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_043.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.43 – The OWASP ZAP Manual Explore panel
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, once new pages are discovered, you can independently run ZAP''s **Spider**
    and **Scanner** modules on each request that is identified through manual exploration.
    While you''re exploring a website, the **Sites** tab gets updated with the pages
    you visit, showing the different requests sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.44 – Options provided by ZAP for analyzing requests (Attack)'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_044.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.44 – Options provided by ZAP for analyzing requests (Attack)
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most relevant modules, besides the two we''ve just described, is
    the Fuzzer module, which you can select by choosing **Fuzz…** from the **Attack**
    options. By choosing insertion points in a request, the Fuzzer module can try
    a set range of inputs to check for an unusual response. To use the Fuzzer module,
    you just need to select the part of input in which to inject the fuzzing, and
    then select the format and the actual input list. We will use strings of text
    with a word list made up of common SQL injection inputs. You can find many such
    word lists on the web, which you can easily copy and paste as your payload. Once
    done, you should be ready to launch your attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.45 – The Fuzzer window ready to start'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_045.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.45 – The Fuzzer window ready to start
  prefs: []
  type: TYPE_NORMAL
- en: You can insert any list of inputs and also apply special encoding. This served
    as a demonstration in case you wish to attempt more customized attacks. However,
    keep in mind that the **Scanner** module already performs fuzzing attacks with
    common inputs, used for identifying common vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: After dealing with OWASP ZAP, which can be used to save time while examining
    web applications and spotting vulnerabilities in a reduced amount of time with
    respect to manual analysis, we will now move on to possibly the most famous tool
    for automated SQL injection; we'll be using the sqlmap command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: Automated SQL injection attacks using sqlmap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, sqlmap is a well-known utility within the software included
    in Kali Linux. While OWASP ZAP is a tool made for discovering and analyzing all
    sorts of vulnerabilities within a web application, sqlmap is designed specifically
    for SQL injection and provides many options for such attacks. It is, however,
    not very user friendly (as is the case for most of the command-line utilities
    available), so it''s best to view all of the available options using the complete
    help (**-hh**) option. You can do this by typing **sqlmap -hh** into the Kali
    Linux terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.46 – sqlmap help output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_046.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.46 – sqlmap help output
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it against Peruggia again. First, let''s scan the **Add Comment**
    page to see whether sqlmap discovers the page is vulnerable. We will type **sqlmap
    -u "192.168.56.101/peruggia/index.php?action=comment&pic_id=1"** in the terminal.
    sqlmap will ask us whether we want to try various attack techniques during execution.
    Since we are scanning the web page, we are interested in checking whether any
    attacks work, so we will answer **Y** or **N** depending on the request to perform
    all possible attacks. After a few seconds, we will get our final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.47 – sqlmap basic scan result'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_047.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.47 – sqlmap basic scan result
  prefs: []
  type: TYPE_NORMAL
- en: Here, sqlmap has confirmed that Peruggia's **Add Comment** page is vulnerable
    to SQL injection, both by attempting time-based blind SQL injection and **UNION**
    queries. At this point, we know that the parameter is vulnerable, and we can dig
    deeper.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now use sqlmap for database enumeration. First, we will try to obtain
    all the databases from the server. To do so, we need to insert the following input
    into the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&pic_id=1" –-dbs
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the command, we will get our results. This confirms our manual
    enumeration attempt, by listing all of the databases that are present on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.48 – sqlmap successful database enumeration attempt'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_048.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.48 – sqlmap successful database enumeration attempt
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can select a database to explore further. We can retrieve tables within
    one of them (Peruggia) by running sqlmap with the **sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&pic_id=1"
    –-tables -D peruggia** input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.49 – sqlmap extracting tables belonging to Peruggia''s database'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_049.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.49 – sqlmap extracting tables belonging to Peruggia's database
  prefs: []
  type: TYPE_NORMAL
- en: At this point, since we have tables, we can proceed to extract all the information
    inside the table. We will use the dump functionality of sqlmap, which will extract
    the full content of a table. To do this, we need to use **sqlmap -u "192.168.56.101/peruggia/index.php?action=comment&pic_id=1"
    –dump -D peruggia -T users** in the terminal for the full extraction of the **users**
    table. sqlmap also has a built-in password cracking module to check for password
    hashes, which we will use here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result, complete with the passwords obtained from the stored hashes,
    will be displayed at the end of the output in a table-like format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.50 – Dumping the users table from the Peruggia database, complete
    with passwords'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_050.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.50 – Dumping the users table from the Peruggia database, complete with
    passwords
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, besides supporting HTTP **GET** requests (such as in this example)
    sqlmap also supports **POST** requests with the **--data** option. In this way,
    we can also attack web pages containing forms. We will try an attack payload suggested
    by the **Mutillidae II** application hint section, just to show the functionality
    in an easy and replicable way:'
  prefs: []
  type: TYPE_NORMAL
- en: sqlmap -u "http://192.168.56.101/mutillidae/index.php?page=view-someones-blog.php"
    --data="author=6C57C4B5-B341-4539-977B-7ACB9D42985A&view-someones-blog-php-submit-button=View+Blog+Entries"
    --level=1 --dump
  prefs: []
  type: TYPE_NORMAL
- en: 'The **--data** option is accompanied by the data to pass within the form for
    the request. This will result in a similar outcome with respect to the previous
    attacks made against **GET** requests. **POST** parameters can be extracted by
    examining valid requests and can be inserted as data. Be warned, however: due
    to the multiple parameters, this attack might take much longer than the previous
    ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'sqlmap results, including logs and dumps, are always saved in the filesystem,
    in a folder specified at the end of the sqlmap output (usually, **/home/<linux
    user>/.sqlmap/output**). This turns out to be very useful, especially in the case
    of a rich output (such as this one):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.51 – sqlmap results for a POST-based attack, as displayed in a CLI
    text editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_051.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.51 – sqlmap results for a POST-based attack, as displayed in a CLI
    text editor
  prefs: []
  type: TYPE_NORMAL
- en: 'Database dumps are also saved—in CSV format—preserving the table-like structure
    that is typical of SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.52 – The resulting dump files from the last extraction'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_052.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.52 – The resulting dump files from the last extraction
  prefs: []
  type: TYPE_NORMAL
- en: In the end, sqlmap is a very useful tool for testing SQL injection, providing
    the capability of both scanning for possible SQL injection vulnerabilities and
    extracting data in an automated way, and even avoiding manual intervention altogether
    in some cases. Data is also conveniently saved in your filesystem for future reference,
    while the built-in password cracking module can crack passwords from stored hashes
    at runtime, by brute-forcing.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our voyage through web application testing for SQL injection.
    We have explored manual techniques in great depth, while also examining possibilities
    for automated testing, showing how this can be convenient by saving precious time
    in testing operations.
  prefs: []
  type: TYPE_NORMAL
- en: We will now change the topic to discuss how SQL injection can be extended to
    other environments that are different from traditional web applications and can
    be accessed and explored through web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking mobile targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile applications are, as their name suggests, applications that reside, even
    partially, on mobile devices. This means that they differ, both in approach and
    execution, with respect to traditional web applications.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional web applications, our main access is usually in the form of a
    web browser. This is so that the entire interface is rendered within it, and it
    is sent by servers in the form of an HTTP response containing all that is needed
    to visualize it as intended, including client-side code (such as JavaScript).
  prefs: []
  type: TYPE_NORMAL
- en: 'Mobile applications have, as opposed to a browser that can interpret any HTTP
    response, a specific client residing on the mobile device itself. This already
    has all of the graphics and client-side code within it. This means that the communication
    between the client and the server in a mobile environment is usually more lightweight,
    that is, it only consists of the little information that is essential to communicate.
    This is where web services come into play: they represent a way to exchange only
    the information that is needed for an application to function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the web services in action. Mutillidae II gives us the option
    to test in the web service (**SOAP** or **Simple Object Access Protocol**) environment.
    Provided we send data in a format that the web service accepts, we can perform
    the same basic functionalities of the application. Let''s go to the **User Lookup
    (SQL)** page that we saw in Mutillidae II, and click on the **Switch to SOAP Web
    Service version** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.53 – Mutillidae II User Lookup page; notice the Web Service version
    button'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_053.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.53 – Mutillidae II User Lookup page; notice the Web Service version
    button
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on the highlighted link, we will access a very minimal web page,
    consisting only of links to the **Web Service Declaration Language** (**WSDL**)—the
    language definition for our SOAP web service—and the functions supported by it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.54 – Mutillidae II User Lookup Web Service page'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_054.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.54 – Mutillidae II User Lookup Web Service page
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on each function, we can see the input and output information for
    each operation. We can interact with such web services by using specifically crafted
    requests in the language specified by the **WSDL**. For example, if we wanted
    to interact using the **getUser** function, we would need a request with the following
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: <soapenv:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:urn="urn:ws-user-account">
  prefs: []
  type: TYPE_NORMAL
- en: <soapenv:Header/>
  prefs: []
  type: TYPE_NORMAL
- en: <soapenv:Body>
  prefs: []
  type: TYPE_NORMAL
- en: <urn:getUser soapenv:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/">
  prefs: []
  type: TYPE_NORMAL
- en: <username xsi:type="xsd:string">username_here</username>
  prefs: []
  type: TYPE_NORMAL
- en: </urn:getUser>
  prefs: []
  type: TYPE_NORMAL
- en: </soapenv:Body>
  prefs: []
  type: TYPE_NORMAL
- en: </soapenv:Envelope>
  prefs: []
  type: TYPE_NORMAL
- en: 'We will try using the **getUser** function to return all users with a tautology.
    We will insert the **'' OR 1=1 -- -** payload as the username to send (in place
    of **username_here** in the preceding request). We should get a similar response
    to the one obtained in the web app scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: <accounts message="Results for ' OR 1=1 -- -">
  prefs: []
  type: TYPE_NORMAL
- en: <account>
  prefs: []
  type: TYPE_NORMAL
- en: <username>admin</username>
  prefs: []
  type: TYPE_NORMAL
- en: <signature>g0t r00t?</signature>
  prefs: []
  type: TYPE_NORMAL
- en: </account>
  prefs: []
  type: TYPE_NORMAL
- en: <account>
  prefs: []
  type: TYPE_NORMAL
- en: <username>adrian</username>
  prefs: []
  type: TYPE_NORMAL
- en: <signature>Zombie Films Rock!</signature>
  prefs: []
  type: TYPE_NORMAL
- en: </account>
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we've seen that web services, despite using a different means
    of communication with respect to traditional web applications, can still be vulnerable
    to SQL injection. We will now explore what this means for mobile applications
    specifically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many mobile applications, much like web applications, rely on databases to
    store data permanently. Some of these have a SQLite database in the client itself.
    This, by best practice, should not contain sensitive information, as it can be
    extracted from the device itself. We are more interested in server-stored databases.
    In this case, they function identically to web applications, with the only difference
    being the means of sending and receiving information. You guessed it: mobile applications
    can be vulnerable to SQL injection too.'
  prefs: []
  type: TYPE_NORMAL
- en: We have prepared an Android mobile application and a simple web service. We
    will guide you through the import and deployment process so that you can use them
    for testing too.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to configure and run the we[b service:](https://github.com/PacktPublishing/SQL-Injection-Attack-and-Defense-Strategies)
  prefs: []
  type: TYPE_NORMAL
- en: '[Download the web service application from GitHub, using this reposi](https://github.com/PacktPublishing/SQL-Injection-Attack-and-Defense-Strategies)tory:
    https://github.com/PacktPublishing/SQL-Injection-Attack-and-Defense-Strategies.
    You can find the web service in the **C4** subdirectory, inside **MasteringSQLInjection-WebServices**:![Figure
    4.55 – GitHub repository'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_055.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.55 – GitHub repository
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open Eclipse and create a new **Dynamic Web Project** (**File** | **New** |
    **Dynamic Web Project**), then select the **New Runtime** option. Set the runtime
    by selecting, as **Target runtime**, **Apache Tomcat v9**. Then, click on **Finish**:![Figure
    4.56 – Creating a server runtime in new dynamic web project
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_056.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.56 – Creating a server runtime in new dynamic web project
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the directory that you downloaded to your computer, go to the **src** folder,
    and drag and drop the files below the **src** folder in the **Java Resources**
    folder, which is contained in Eclipse's **Project Explorer** tab. Click on **OK**
    in the pop-up window:![Figure 4.57 – The src folder in Java Resources, in Eclipse
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_057.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.57 – The src folder in Java Resources, in Eclipse
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Double-click on the server in the **Servers** tab. Then, set port number **8081**
    in the configuration that opens. Save the settings by pressing *Ctrl* + *S*:![Figure
    4.58 – Setting up the server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_058.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.58 – Setting up the server
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that you have your code and runtime, navigate to the **File** | **New**
    | **Web Service** option. Be sure to bring the two sliders up to **Test Client**
    and **Test Service**, respectively, in the interface. Keep everything else in
    their default settings:![Figure 4.59 – Setting up the web service (1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_059.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.59 – Setting up the web service (1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use the **Browse** button pointing at your package in the **Service implementation**
    field and implementation class (**com.packt.masteringsqlj.service.IOTMgmtServiceImplementation**),
    and then click on **Next**. Then, click on **Next** again:![Figure 4.60 – Setting
    up the web service (2)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_060.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.60 – Setting up the web service (2)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After a while, you''ll see a **Server startup** window. Click on **Start server**
    to finally start the server, then click on **Next**, and select **Launch** in
    the following window. Your web service should now start:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.61 – Server startup'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_061.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.61 – Server startup
  prefs: []
  type: TYPE_NORMAL
- en: 'After loading and setting up the web service, let''s load the application to
    our Android emulator using Android Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: You should already have the code from the repository you previously downloaded.
    This time, you can find it in the **MasteringSQLInjection-AndroidApp** subdirectory
    in **C4**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Android Studio. Select **Open an existing Android Studio project**. Select
    the downloaded folder when prompted:![Figure 4.62 – Android Studio startup instructions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_062.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.62 – Android Studio startup instructions
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: From the newly started web service screen, take the **Endpoints** information
    from the **Actions** tab:![Figure 4.63 – Endpoint information of the web service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_063.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.63 – Endpoint information of the web service
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the endpoint information in the **ENDPOINT** variable of the **Utils**
    class. Remember to change **localhost** to your computer's IP address:![Figure
    4.64 – Editing the Utils class
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15632_04_064.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 4.64 – Editing the Utils class
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the application by clicking on the run/play icon, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.65 – The run icon in Android Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_065.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.65 – The run icon in Android Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our environment up and running, we can use our simple application
    and show SQL injection in a mobile setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.66 – Mobile application login screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_066.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.66 – Mobile application login screen
  prefs: []
  type: TYPE_NORMAL
- en: The application shows a rather simple login screen. We can try the tautology
    attack with our usual payload (**' OR 1=1 -- -**). This will grant us access.
    The reason for this is the same as the web service example we saw earlier; that
    is, because the underlying database (MySQL) does not apply any security measure,
    and it does not sanitize input on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've demonstrated how SQL injection can impact mobile applications
    too, we will move on to the IoT environment. Keep the mobile application running
    it will be useful for our next attack scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking IoT targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with IoT devices, we usually consider a complex environment in
    which these devices are usually at the outermost end of an interconnected network.
    We usually refer to small devices with low computational power—such as sensors,
    little appliances, and more—often running embedded systems with minimal functionality.
    This is because these devices are designed to perform very specialized tasks,
    which do not require complex operating systems. The result consists of small,
    handy devices that are always connected and are communicating with other devices,
    being other small IoT devices or servers, that might collect some kind of data,
    be it from measuring or input from the device itself.
  prefs: []
  type: TYPE_NORMAL
- en: IoT has been a hot topic recently, and many are investing in these practical
    technologies, which help to integrate technology in the everyday world. However,
    at the same time, security has sometimes been neglected in these systems. This
    is probably due to the limited resources that are available on such devices. This
    includes the possibility that some devices that use information from a database
    can be, affected by SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this scenario, we will use our mobile application—the same that we used
    in the previous section—to interact with (hypothetical) IoT devices through a
    database running on a web server. In the IoT environment, the network is distributed,
    and instructions may come from different parts of a network, even a mobile device.
    The application, in fact, after a successful admin level login, will allow the
    authenticated user to modify the status of an IoT device that is connected to
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.67 – Status panel for our application'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_067.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.67 – Status panel for our application
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind this panel, there is, of course, a SQL query. Once the query is sent,
    we can modify it similarly to how we did earlier, in the web service scenario.
    This time, we will insert **'', status =(SELECT password FROM iot_mgmt_system.user
    WHERE username=''admin'' LIMIT 1) --** (don''t forget the blank space at the end)
    to edit the status of the device, including relevant information (in this case,
    the password for the **admin** account of the mobile application):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.68 – Status changed by our payload'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15632_04_068.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.68 – Status changed by our payload
  prefs: []
  type: TYPE_NORMAL
- en: IoT devices could also be attacked in other ways. However, most of the time,
    these are in the realm of web application attacks—as devices can have a web interface
    for interacting with settings or configurations—or other traditional means, such
    as any computer system (for example, attacking open ports and services).
  prefs: []
  type: TYPE_NORMAL
- en: 'While our example is, of course, a simplified mock-up scenario, the message
    is always the same: if any application, be it web-based, mobile, or a web service,
    does not properly check for the input, the underlying database can be irremediably
    compromised.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario in which a controller sends non-sanitized SQL input to a
    server that controls critical devices, in a more realistic scenario. What if a
    malicious user could entirely alter the database, totally compromising its control
    functionality? In this way, the damage could be extended to the real world, as
    IoT can be responsible for performing tasks in critical environments such as smart
    cities, surveillance (for example, cameras), smart meters for critical infrastructure
    (for example, water distribution), or medical facilities.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Practice these skills in controlled environments only, without involving third
    parties. The use of security tools and attack techniques is illegal without the
    consent of the owner of the targets, so you could get yourself in trouble if you
    try these techniques on websites or systems you don't own.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, here we are at the end of this long and practical chapter. We've explored
    many different scenarios, applications, and attacks that are made possible by
    exploiting vulnerable application components that interact with SQL databases.
  prefs: []
  type: TYPE_NORMAL
- en: Mutillidae II gave us a glimpse of the basic attacks that can occur through
    SQL injection. Additionally, the Magical Code Injection Rainbow provided us with
    some challenges to wrap our heads around (which you could solve by applying what
    you've learned so far), sometimes, with twists. Finally, Peruggia helped us to
    apply our knowledge to a pseudo-realistic environment.
  prefs: []
  type: TYPE_NORMAL
- en: After dealing with manual SQL injection attacks, we learned what is possible
    using common software tools to automate SQL injection, both for scanning and attacking.
    We saw this with the Spider, Scan, and Fuzz modules of OWASP ZAP and sqlmap. We
    showed how manual intervention can be reduced significantly, improving efficiency
    for attackers and security testers alike (and demonstrating, once again, the importance
    of securing web applications that could be compromised in a matter of seconds).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at simple web service and mobile applications, where a SQL
    injection vulnerability can extend far beyond the concept of traditional web applications,
    ranging from mobile applications to even IoT devices, as long as they deal with
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see, more specifically, what can be done to secure
    web applications in general, and how attempts at performing SQL injection can
    be thwarted using various measures. We have already looked at several examples
    using the Magical Code Injection Rainbow, as some of the earlier challenges applied
    some (incomplete) measures. We will learn how, if done right, correct security
    measures can prevent this type of attack.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is binary search useful when performing blind SQL injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do you know a way to perform data extraction through a SQL error?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which OWASP ZAP tools can be used for automated SQL injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can sqlmap be used to extract passwords from hashes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is SQL injection limited to web applications? Name all the target typologies
    you've seen in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explore attack vectors an[d further research on **INSERT**, **UPDATE**, and
    **DELETE** statements, we suggest the foll](https://osandamalith.com/2017/02/08/mysql-injection-in-update-insert-and-delete/)ow[ing
    resources:](https://osandamalith.com/2014/04/26/injection-in-insert-update-and-delete-statements/)
  prefs: []
  type: TYPE_NORMAL
- en: '[https://osandamalith.com/2017/02/08/mysql-injection-in-update-insert-a](https://osandamalith.com/2014/04/26/injection-in-insert-update-and-delete-statements/)n[d-delete/](https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://osandamalith.com/2014/04/26/injection-in-insert-update-and-delete-state](https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/)ments/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://osandamalith.com/2017/03/13/mysql-blind-injection-in-insert-and-update-statements/
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
