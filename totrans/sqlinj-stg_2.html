<html><head></head><body>
		<div id="_idContainer133">
			<h1 id="_idParaDest-75"><em class="italic"><a id="_idTextAnchor085"/>Chapter 5</em>: Preventing SQL Injection with Defensive Solutions</h1>
			<p>Up until now, we have focused on the offensive aspect of SQL injection. We saw how a malicious user can perform main attack techniques in previous chapters, and what consequences a successful SQL injection attack could have. In a general sense, we saw how in principle, a SQL injection can quite easily result in a fully compromised database, which could leak sensitive information, give attackers full access to connected applications, or totally break the functionality of databases, applications, web services, or even connected devices, independent of the technology used.</p>
			<p>In this chapter, we will focus more on the defensive side of things; now that we know that such an impressive and destructive vulnerability exists—and how simple, in principle, it would be to exploit it—how can we stop it? This is the question we are trying to answer here. Obviously, the solution to this problem is not simple, and it usually involves applying various defenses at the same time. We will go through the most important defenses, tackling what, generally speaking, the differences are in securing applications that deal with databases.</p>
			<p>This chapter is split into the following sub-sections:</p>
			<ul>
				<li><strong class="bold">Understanding general weaknesses and SQL injection enablers</strong>: After a very brief recap of the general weaknesses that make a SQL injection possible, we will analyze the nature of the problem so that we can move to the root cause.</li>
				<li><strong class="bold">Treating user input</strong>: Behind every SQL injection, there is always some input coming from a malicious agent that tries to tamper database queries to perform operations that are outside the range of what would normally be possible in a regular application. For this reason, we need a way to address how a user can interact with an application that sends queries to a database.</li>
				<li><strong class="bold">Sanitization and input control</strong>: When we start to view user input as not trusted, we need to process it in a secure way. This is done by applying some control techniques that may prevent SQL injection attempts right from the start by not giving attackers access to potentially dangerous commands or instructions.</li>
				<li><strong class="bold">Defending against SQL injection – code-level defenses</strong>: Some of these techniques can be applied directly when developing the application code. We will see some examples of how security can be pursued efficiently through secure coding since the design phase.</li>
				<li><strong class="bold">Defending against SQL injection – platform-level defenses</strong>: Other controls can be applied, besides at code-level, to other layers of the application flow, applying the concept of defense-in-depth at multiple stages of interaction.</li>
			</ul>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor086"/>Technical requirements</h1>
			<p>For this chapter, we strongly recommend familiarizing yourself with the main technologies involved in SQL injection scenarios. Besides going through the <em class="italic">Technical requirements</em> sections of previous chapters, we recommend taking a look at the documentation for some of the programming languages commonly used in conjunction with SQL so that we're on the same page when talking about some solutions that can be adopted in application development:</p>
			<ul>
				<li><a href="https://docs.oracle.com/en/java/">https://docs.oracle.com/en/java/</a></li>
				<li><a href="https://www.php.net/manual/en/">https://www.php.net/manual/en/</a></li>
				<li><a href="https://docs.microsoft.com/en-us/dotnet/">https://docs.microsoft.com/en-us/dotnet/</a></li>
			</ul>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor087"/>Understanding general weaknesses and SQL injection enablers </h1>
			<p>SQL is an immensely powerful and effective tool for interacting with relational databases as it provides an <a id="_idIndexMarker254"/>opportunity to perform various tasks through the wide array of functions and commands available. Unfortunately, from a security standpoint, this boon is also a bane; allowing access to many different types of operations means that if no control is in place, anyone could potentially turn an application that utilizes databases on its head, leaving malicious imagination as the only limit to what attackers could achieve.</p>
			<p>You saw firsthand what a vulnerable application can lead to (and we hope you also had fun in the process) in the previous chapter, and if you've reached this point in the book, you may also be <a id="_idIndexMarker255"/>wondering whether there's any way to improve security to prevent all of this. SQL databases are still extensively used today, so you can probably guess that the short answer is definitely yes. The long answer is that these defenses need to be applied all at once. </p>
			<p>When <a id="_idIndexMarker256"/>exploring the challenges of <strong class="bold">Magical Code Injection Rainbow</strong> or even the <strong class="bold">Mutillidae II</strong> web application, we saw how simple solutions alone <a id="_idIndexMarker257"/>may not be enough as there is usually a way to bypass them. However, if defense was applied at multiple points in the application, these workarounds would not work anymore due to the presence of other simultaneous defenses that may render SQL injection attacks almost <a id="_idIndexMarker258"/>impossible without the existence of other vulnerabilities.</p>
			<p>The main problem behind a SQL injection is how user input can interact with the actual syntax of SQL, mainly because, at the code level, SQL statements are usually constructed from text strings. Various programming languages use specific functions that take text strings as an argument. This text string is obviously written in SQL syntax in order to be interpreted as SQL input. The following is a SQL <strong class="source-inline">String</strong> declaration from the vulnerable Java web service we used in <a href="B15632_04_Final_JC_ePub.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Attacking Web, Mobile, and IoT Applications</em>:</p>
			<p class="source-code">String query = "SELECT * FROM " + USER_TABLE + " WHERE username='" + user_id + "' AND password='" + password + "'";</p>
			<p>The <strong class="source-inline">query</strong> string will then be sent as a command to the database using <strong class="source-inline">executeQuery(query)</strong>, a Java function that, within a database connection, sends the input string to the database so that it can be processed.</p>
			<p>You can see that while some parts of the query have fixed content, as delimited by double quotes, other parts are made up of previously declared variables. You can already tell where we are going now as you have already seen a SQL injection in action. By inserting a malicious payload into the query structure, attackers could in fact make it possible to execute arbitrary commands as if they were writing parts of the query themselves. In the attacks we previously mentioned, it's enough for an attacker to insert the malicious payload in place of the <strong class="source-inline">user_id</strong> parameter, altering the structure of the query in doing so. The resulting query, with respect to a tautology attack for bypassing authentication, would be the following:</p>
			<p class="source-code">SELECT * FROM USER WHERE username=<strong class="bold">'' OR 1=1 -- -'</strong> AND password='password'</p>
			<p>Inserting legal SQL expressions can alter the originally intended query functionality, as in this case, by using string delimiters and commenting. That is why user input needs to be taken into account in terms of security.</p>
			<p>Approaching this aspect in a naive way can lead to a plethora of attack scenarios made possible by a SQL injection, possibly causing widespread damage to the integrity and security of an application. For this reason, when dealing with parts of code that take input from the outside of the application, this data needs to be treated safely and you should always consider the worst-case scenario—that this input is from a potentially malicious user or it has been <a id="_idIndexMarker259"/>purposely altered in order to cause damage to the application context. That's why we need to talk about trust in terms of user input.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor088"/>Treating user input</h1>
			<p>What do we mean by trust when talking about security? It is actually one of the most important concepts when dealing with security in general, not just application security.</p>
			<p>Let's say you <a id="_idIndexMarker260"/>are walking along the street when a stranger approaches you asking for directions. You make a decision on whether to give directions to this person—sure, they could be an ill-intentioned person who is willing to attack you to steal your money, but you may decide that this risk is low; after all, there are many people around you, and you feel pretty confident that you'll be fine even if the situation takes a wrong turn. You then decide to trust this person in this specific case.</p>
			<p>Of course, how wise this choice is depends on the context. Let's say you are now guarding an important energy plant when suddenly a person approaches you saying they forgot some important documents on the site and want to go through. As your role is making sure no one accesses the site without authorization, you have the specific duty to check the identity of this person and your default approach should be not letting anyone pass unless you recognize this person as having the right to do so based on their permissions.</p>
			<p>When dealing with security, of course, the second approach is the one we should replicate. Zero-trust is the name of the game. Considering how malicious users can also spoof their identity, you should trust nobody by default. The basic assumption is considering the worst-case scenario every time; each user might be a malicious user because you cannot tell their intentions and cannot state otherwise. It would be a shame if you acted the other way around, trusting everybody, as one single malicious agent is enough to turn your application—and possibly your entire IT infrastructure—to smithereens.</p>
			<p>In our case, this <a id="_idIndexMarker261"/>means applying defenses to our application and database because, as far as we know, anybody could perform SQL injection attacks against us—especially considering how simple it is to do so. These defenses can usually be summarized by the simple concept of sanitization and input control. The general solution of avoiding malicious input can in fact alter the behavior of our application, so that such input won't be interpreted by the application as possible un-envisioned instructions.</p>
			<p>We will now explore what it means to sanitize input and apply defensive controls in this way, as well as consider all the stages that can be applied for foiling any possible SQL injection plan that an attacker may have.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor089"/>Sanitization and input control</h1>
			<p>We saw that all SQL (and other) databases are inherently vulnerable to SQL injection on their own as the only thing a database does is accept instructions. Therefore, we need to act at the early <a id="_idIndexMarker262"/>stages of the data flow, before a query actually reaches our database to prevent an injection from happening.</p>
			<p>This is where sanitization comes in. Input, coming from the outside, is cleaned up from any possible malicious element that could result in dangerous commands. You can imagine this process like introducing a compulsory shower for people before they enter a public pool—you can assume that people have a good hygiene level, but since there is no guarantee of it, it's a wise choice to make up for people who don't by leveling out the field and making everyone do it. In most cases, this might not be necessary, but it ensures that cases in which a shower may be needed are covered.</p>
			<p>Obviously, there is no single way in which sanitization can be done as these controls can be applied at various stages in the flow of the application. However, in most cases, there are two major areas for applying these defenses:</p>
			<ul>
				<li><strong class="bold">Application coding</strong>: This is <a id="_idIndexMarker263"/>where the magic happens in terms of <a id="_idIndexMarker264"/>application functionality. Most defense mechanisms are in this domain, which we can call <strong class="bold">code-level defenses</strong>. By acting on code and information processing, most application attacks can be thwarted here, rigorously ensuring that input and commands are structured and formatted just the way we want. This can be done by transforming the input, accepting only some characters or input lengths, or generating queries dynamically. This generally foils SQL injection attempts, if done correctly.</li>
				<li><strong class="bold">Platform and infrastructure configuration</strong>: Besides acting on the application code, security <a id="_idIndexMarker265"/>controls can be applied in the context in which the application is situated (in terms of the server and infrastructure in general). This includes the use of external modules, appliances, and network flow controls. While this might seem like overkill for secure application code, but it can help drastically reduce successful attacks in general by preventing any malicious input from reaching the application altogether, thereby also avoiding collateral damage and other types of attacks against your application or systems. We will <a id="_idIndexMarker266"/>refer to these mechanisms as <strong class="bold">platform-level defenses</strong>.</li>
			</ul>
			<p>All of these measures are a form of <strong class="bold">input control</strong> as they represent a way in which application input is checked, analyzed, and altered to be rendered inoffensive or blocked altogether before it reaches our running software. </p>
			<p>Of course, applying just a single control mechanism at once does not guarantee our application is <a id="_idIndexMarker267"/>secure and safe against possible attacks. We already saw, in <a href="B15632_04_Final_JC_ePub.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Attacking Web, Mobile, and IoT Applications</em>, that applying just a single means of control might not be enough. When we looked at Mutillidae II, we saw some simple client-side controls in action. The following screenshot will remind you of when we tried performing a regular SQL injection using the web form with client-side controls:</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B15632_05_001.jpg" alt="Figure 5.1 – Client-side controls in Mutillidae II&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Client-side controls in Mutillidae II</p>
			<p>This client-side <a id="_idIndexMarker268"/>control just prevented information from being submitted with empty fields. Another measure that Mutillidae II has (client-side wise) is checking for forbidden characters—in this case, SQL injection enablers (such as single quotes and hyphens—this is called <strong class="bold">blacklisting</strong>, and we <a id="_idIndexMarker269"/>will see it in action shortly). Performing an SQL injection attempt using the input web form will fail and the application will return a message with a JavaScript alert:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B15632_05_002.jpg" alt="Figure 5.2 – Client-side control message in Mutillidae II&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Client-side control message in Mutillidae II</p>
			<p>While this is definitely a code-level defense, we already saw that client-side controls alone are useless as <a id="_idIndexMarker270"/>long as the server side is vulnerable. We inserted the malicious payload at the HTTP request level, totally bypassing the web form input and ignoring this defense. </p>
			<p>What does this mean? In the end, the best thing to do is to apply many different layers of defense, dramatically decreasing the likelihood of a successful attack.</p>
			<p>In the following sections, we will see how these defense mechanisms can be applied, both at a code level and at a platform/infrastructure level, giving you a look at the tools available for securing an application against SQL injection.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor090"/>Defending against SQL injection – code-level defenses</h1>
			<p>As we said earlier, applying code-level defenses, if done correctly, should foil all the plans of a malicious <a id="_idIndexMarker271"/>agent that wishes to attack your application. Of course, mistakes can always be made, and that is why the wisest thing to do is to apply various defense mechanisms all at once. In this section, we will explore the main tools at our disposal to thwart possible attacks against our application in terms of SQL injection. We will also see how these controls can be implemented into actual code in three common programming languages for developing web applications: Java, PHP, and .NET.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor091"/>Input validation</h2>
			<p>Input validation is the process of accepting or rejecting input based on its content. We only want safe <a id="_idIndexMarker272"/>input to be processed by our application, preventing <a id="_idIndexMarker273"/>most of the attacks against us. So, only valid input, according to our rules, is accepted and processed by our application.</p>
			<p>Validation follows two main approaches, which are also common to other areas of information security:</p>
			<ul>
				<li><strong class="bold">Blacklisting</strong>: The approach of blacklisting consists of determining what is not allowed <a id="_idIndexMarker274"/>and refusing any input that falls into <a id="_idIndexMarker275"/>specific blacklisting rules. It's definitely easy to implement, but it might be defeated in cases where particular encodings that were not considered by the rules are used, or if new ways of attacking are discovered.</li>
				<li><strong class="bold">Whitelisting</strong>: The approach of whitelisting is the logical opposite of blacklisting; these rules <a id="_idIndexMarker276"/>define what is allowed and everything that does not fall into this model is rejected, only accepting input that satisfies <a id="_idIndexMarker277"/>the correctness rules. Its implementation may be more difficult, but it definitely pays off as it can thwart newly discovered attacks, totally ignoring what is not originally envisioned by the application itself. After all, what would be the reason for a user to try some exotic input if not for performing some kind of attack attempt? </li>
			</ul>
			<p>Input validation is probably the most basic and simple way to prevent malicious input from reaching our application and is by far the most common method.</p>
			<h3>Input validation in Java</h3>
			<p>Java is a very flexible language and it has a long history of frameworks developed for it, many of these <a id="_idIndexMarker278"/>being particularly useful for developing web applications. Due to the plethora of available frameworks, we will focus on the most basic side of it. </p>
			<p>As we said <a id="_idIndexMarker279"/>earlier, implementing blacklisting is quite easy, and you could simply check whether strings contain sensitive characters. In the following example, we are just blacklisting the single quote and the hyphen characters for simplicity.</p>
			<p>The following code checks the input string, sent as a variable named <strong class="source-inline">input</strong>, and proceeds to build the SQL statement by calling another function named <strong class="source-inline">constructQuery()</strong>, but only if the string does not contain any blacklisted characters:</p>
			<p class="source-code">String s = input;</p>
			<p class="source-code">if(s.contains("\'") OR s.contains("-")){</p>
			<p class="source-code">	throw new IllegalArgumentException("Illegal input");</p>
			<p class="source-code">} else {</p>
			<p class="source-code">	constructQuery(s);</p>
			<p class="source-code">}</p>
			<p>Whitelists <a id="_idIndexMarker280"/>can be slightly more complex in terms of coding as we need to know exactly what a legal input is. If we are expecting a name to be inputted, we can <a id="_idIndexMarker281"/>use expressions based on the alphabet:</p>
			<p class="source-code">String s = input;</p>
			<p class="source-code">if(s.matches("[[A-Z][a-zA-Z]*]"){</p>
			<p class="source-code">	constructQuery(s);</p>
			<p class="source-code">} else {</p>
			<p class="source-code">	throw new IllegalArgumentException("Illegal input");</p>
			<p class="source-code">}</p>
			<p>You will notice that the inner logic is a reversed version of that for blacklisting; we only accept our input if we can tell for sure that it's legal.</p>
			<p>Of course, there are more refined ways to apply input validation to Java code, and they tend to be dependent on the specific frameworks used. You can check the documentation for your framework, but the principle is always the same and you will find yourself understanding how it works easily.</p>
			<h3>Input validation in PHP</h3>
			<p>As for PHP, like Java, implementations will depend on the framework used. Similarly to Java, it provides <a id="_idIndexMarker282"/>some useful functions that can help with implementing <a id="_idIndexMarker283"/>input validation in a simple way. One of these functions is <strong class="source-inline">preg_match(regex, string)</strong>, which, like the <strong class="source-inline">String.matches()</strong> function, checks whether a <strong class="source-inline">string</strong> string matches the regular <strong class="source-inline">regex</strong> expression pattern. This can, of course, be used both for blacklisting and whitelisting:</p>
			<p class="source-code">$s = $_POST['input'];</p>
			<p class="source-code">if(preg_match("/\'/", $s) OR preg_match("\-", $s)){</p>
			<p class="source-code">	// failed validation handling</p>
			<p class="source-code">}</p>
			<p>Now, for the whitelisting case, we are keeping the same structure but reversing it in a logical way, as <strong class="source-inline">if</strong> now <a id="_idIndexMarker284"/>checks for any mismatches with the regular <a id="_idIndexMarker285"/>expression:</p>
			<p class="source-code">$s = $_POST['input'];</p>
			<p class="source-code">if(!preg_match("/[[A-Z][a-zA-Z]*]/", $s){</p>
			<p class="source-code">	// failed validation handling</p>
			<p class="source-code">}</p>
			<p>In the end, different languages aside, the mechanisms are quite the same for both Java and PHP.</p>
			<h3>Input validation in .NET</h3>
			<p>In a different way from Java and PHP, ASP.NET has various built-in controls that are used to develop <a id="_idIndexMarker286"/>an application. One simple control is <strong class="source-inline">RegularExpressionValidator</strong>, which follows the same approach as the pattern-matching <a id="_idIndexMarker287"/>functions we saw for Java and PHP. This control enforces both server- and client-side validation.</p>
			<p>In the following example, we are applying the same whitelisting approach we saw for the previous two code examples, matching against a regular expression that only allows a string of letters, the first of which is uppercase:</p>
			<p class="source-code">&lt;asp:textbox id="input" runat="server"/&gt;</p>
			<p class="source-code">&lt;asp:RegularExpressionValidator id="inputRegEx"  runat="server" </p>
			<p class="source-code">ControlToValidate="input"</p>
			<p class="source-code">ErrorMessage="Parameter must contain letters only, the first of which must be uppercase."</p>
			<p class="source-code">ValidationExpression="[A-Z][a-zA-Z]*" /&gt; </p>
			<p>ASP.NET also has other built-in controls, but this one is generally the most useful as it natively validates input against regular expressions.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor092"/>Parametrized queries</h2>
			<p>Another way <a id="_idIndexMarker288"/>of defeating SQL injection is through <a id="_idIndexMarker289"/>the use of so-called parameterized queries. The main reasoning behind this is that input is never sent to the database as it is—that is, as a string, as is the case in dynamic string building—but it is instead serialized and stored in separate parameters (hence the name).</p>
			<p>This is done by using variables when building the SQL statement, using identifiers as placeholders so that the actual string can be built safely. This is made even more accessible through the use of an API that is available for most modern programming languages and is used for interacting with database systems.</p>
			<p>It's worth noting, however, that the use of parameterized queries alone does not mean an application is not vulnerable to SQL injection; sometimes, parameters can also contain stored procedures, which, if vulnerable, can still lead to an SQL injection. This is just one more reason to combine defense mechanisms.</p>
			<p>Another perk of parametrized queries is the simplicity in which it's possible to convert already-existing dynamic strings for SQL queries into parameterized queries. We will see how this is done in Java, PHP, and .NET by starting from a regular (vulnerable) SQL query build:</p>
			<p class="source-code">User = request("username")</p>
			<p class="source-code">Pass = request("password")</p>
			<p class="source-code">Query = "SELECT * FROM users WHERE username='" + User + "' AND password='" + Pass + "'"</p>
			<p class="source-code">Check = Db.Execute(Query)</p>
			<p class="source-code">If (Check) {</p>
			<p class="source-code">	Login()</p>
			<p class="source-code">}</p>
			<p>Let's now see how we can parametrize the query in the preceding snippet.</p>
			<h3>Parametrized queries in Java</h3>
			<p>One of the <a id="_idIndexMarker290"/>most used frameworks within Java when dealing with any database is the <strong class="bold">Java DataBase Connectivity</strong> (<strong class="bold">JDBC</strong>) framework. It's available <a id="_idIndexMarker291"/>natively and supports database connectivity independently from the database technology used, providing useful functions for <a id="_idIndexMarker292"/>connecting to databases. One of these is the <strong class="source-inline">PreparedStatement</strong> class, which allows the use of the following code:</p>
			<p class="source-code">Connection con = DriverManager.getConnection(connectionString);</p>
			<p class="source-code">String query = "SELECT * FROM users WHERE username=? AND password=?";</p>
			<p class="source-code">PreparedStatement ps = con.prepareStatement(query);</p>
			<p class="source-code">ps.setString(1, user);</p>
			<p class="source-code">ps.setString(2, pass);</p>
			<p class="source-code">rs = ps.executeQuery();</p>
			<p>The basic SQL statement is altered by replacing the values with question marks, which are then referred to by the <strong class="source-inline">PreparedStatement</strong> instance, <strong class="source-inline">ps</strong>. The <strong class="source-inline">setString()</strong> method then inserts the values in place of the placeholder question marks in the order that they are found in the original query, <strong class="source-inline">query</strong> (<strong class="source-inline">1</strong> for <strong class="source-inline">user</strong> and <strong class="source-inline">2</strong> for <strong class="source-inline">pass</strong>). In the end, the <strong class="source-inline">executeQuery()</strong> method is called based on the prepared statement.</p>
			<h3>Parametrized queries in PHP</h3>
			<p>PHP also <a id="_idIndexMarker293"/>has several frameworks for implementing parameterized queries. Some of these are available in PHP.</p>
			<p>We will <a id="_idIndexMarker294"/>change the original snippet using the <strong class="bold">PHP Data Object</strong> (<strong class="bold">PDO</strong>) framework as it is the direct equivalent to the JDBC framework in Java in terms of <a id="_idIndexMarker295"/>compatibility and functionality. It's included in PHP version 5.1 onward:</p>
			<p class="source-code">$query = "SELECT * FROM users WHERE user=? AND pass=?";</p>
			<p class="source-code">$stmt = $dbh-&gt;prepare($query);</p>
			<p class="source-code">$stmt-&gt;bindParam(1, $user, PDO::PARAM_STR);</p>
			<p class="source-code">$stmt-&gt;bindParam(2, $pass, PDO::PARAM_STR);</p>
			<p class="source-code">$stmt-&gt;execute();</p>
			<p>This code <a id="_idIndexMarker296"/>is almost the perfect equivalent to the JDBC example; the statement is prepared starting from an SQL query, <strong class="source-inline">query</strong>, containing placeholders <a id="_idIndexMarker297"/>in the form of a question mark. Then, the <strong class="source-inline">bindParam()</strong> function binds the input parameter to the question mark instances, ordered by number (<strong class="source-inline">1</strong> for <strong class="source-inline">user</strong> and <strong class="source-inline">2</strong> for <strong class="source-inline">pass</strong>), specifying the data type of the parameter (<strong class="source-inline">PDO::PARAM_STR</strong> defines a string parameter). The prepared statement is finally executed with <strong class="source-inline">execute()</strong>.</p>
			<h3>Parametrized queries in .NET</h3>
			<p>As for .NET, a way <a id="_idIndexMarker298"/>to implement parameterized queries is provided <a id="_idIndexMarker299"/>by the ADO.NET framework. The name derives from the previous <strong class="bold">ActiveX Data Object</strong> (<strong class="bold">ADO</strong>) technology on which it is based.</p>
			<p>ADO.NET interacts with databases through the use of <strong class="bold">data providers</strong>, one for each supported <a id="_idIndexMarker300"/>database system. The code syntax <a id="_idIndexMarker301"/>varies with each provider, so we will show examples for the <strong class="source-inline">System.Data.SqlClient</strong> provider, which works with Microsoft SQL Server, and <strong class="source-inline">System.Data.OracleClient</strong> for Oracle Database. Let's first see what the code looks like with <strong class="source-inline">SqlClient</strong>:</p>
			<p class="source-code">SqlConnection con = new SqlConnection(ConnectionString);</p>
			<p class="source-code">string Query = "SELECT * FROM users WHERE username=@user" AND password=@pass";</p>
			<p class="source-code">cmd = new SqlCommand(Query, con);</p>
			<p class="source-code">cmd.Parameters.Add("@user", SqlDbType.NVarChar); </p>
			<p class="source-code">cmd.Parameters.Add("@pass", SqlDbType.NVarChar);</p>
			<p class="source-code">cmd.Parameters.Value[„@user"] = user;</p>
			<p class="source-code">cmd.Parameters.Value["@pass"] = pass;</p>
			<p class="source-code">reader = cmd.ExecuteReader();</p>
			<p>The parameters <a id="_idIndexMarker302"/>here are referred to with the <strong class="source-inline">@</strong> character, and they are added to the <strong class="source-inline">cmd</strong> prepared statement using <strong class="source-inline">Parameters.Add()</strong>, which sends in the parameter name and type (in this case, a string of characters denoted by <strong class="source-inline">SqlDbType.NVarChar</strong>). <strong class="source-inline">OracleClient</strong> works in a similar way:</p>
			<p class="source-code">OracleConnection con = new OracleConnection(ConnectionString);</p>
			<p class="source-code">string Query = "SELECT * FROM users WHERE username=:user AND password=:pass";</p>
			<p class="source-code">cmd = new OracleCommand(Query, con);</p>
			<p class="source-code">cmd.Parameters.Add("user",  OracleType.VarChar); </p>
			<p class="source-code">cmd.Parameters.Add("pass", OracleType.VarChar);</p>
			<p class="source-code">cmd.Parameters.Value["user"] = user; </p>
			<p class="source-code">cmd.Parameters.Value["pass"] = pass; </p>
			<p class="source-code">reader = cmd.ExecuteReader(); </p>
			<p>This structure <a id="_idIndexMarker303"/>is almost identical to the <strong class="source-inline">SqlClient</strong> example. The only differences reside in the way that the parameters are referred to (with a semicolon in the query statement and with no special character elsewhere) and the object names.</p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor093"/>Character encoding and escaping</h2>
			<p>Another popular way of applying countermeasures against malicious input leading to SQL injection is by <a id="_idIndexMarker304"/>using specific character encoding and escaping techniques so that enabling characters are not sent to the database. This prevents <a id="_idIndexMarker305"/>the most common types of SQL injection attacks. There are also times where other defenses cannot be applied—for example, in databases <a id="_idIndexMarker306"/>that expect surnames, as some surnames <a id="_idIndexMarker307"/>may contain an apostrophe, such as O'Malley or O'Brian, which of course is still encoded as a single quote. In this case, there is no other way of allowing these surnames in your database.</p>
			<p>This time, however, we are not acting at the same level of sanitization at the input level as instead, we more concerned with sanitizing the output so that SQL statements are deprived of dangerous characters. The objective here is avoiding non-sanitized statements from traveling within the application flow and outside it when they are supposed to reach the database system.</p>
			<p>Of course, these techniques vary from one database system to another due to the differences in syntax among them. We will see these techniques applied to MySQL, Microsoft SQL Server, and Oracle Database.</p>
			<h3>Character encoding and escaping in MySQL</h3>
			<p>As MySQL uses <a id="_idIndexMarker308"/>single quotes as a string termination, this character <a id="_idIndexMarker309"/>needs to be encoded when included in strings used for SQL statement construction. This can be done by replacing the <a id="_idIndexMarker310"/>single quote with two single quotes or by escaping <a id="_idIndexMarker311"/>the use of a single quote by using the backslash character (<strong class="source-inline">\</strong>) instead.</p>
			<p>In Java, this can be done with a simple <strong class="source-inline">replace()</strong> function to replace occurrences of one character with other characters:</p>
			<p class="source-code">query1 = query1.replace("'", "\'");</p>
			<p class="source-code">query2 = query2.replace("'", "''");</p>
			<p>From the PHP side of things, within the <strong class="source-inline">mysqli</strong> framework, a PHP framework for interacting specifically with MySQL is available on PHP 5.x onward. There is a pretty nifty function named <strong class="source-inline">mysql_real_escape_string( )</strong> that automatically puts a backslash in front of single quotes in a text string. This form of escaping is also applied to other dangerous characters:</p>
			<p class="source-code">mysql_real_escape_string($parameter);</p>
			<p>Of course, a <strong class="source-inline">REPLACE</strong> function is still available in PHP:</p>
			<p class="source-code">SET @query1 = REPLACE(@query1, '\'', '\\\'');</p>
			<p class="source-code">SET @query2 = REPLACE(@query2 '\'', '"');</p>
			<p>Another thing to keep in mind for sanitization is that other harmful characters include wildcards in a <strong class="source-inline">LIKE</strong> clause that can define any character, possibly causing tautology when added maliciously to a query. The most relevant wildcard is the <strong class="source-inline">%</strong> character, which corresponds to a wildcard of zero or more of any character. It can be escaped via a <strong class="source-inline">replace()</strong> function by adding a backslash before it:</p>
			<p class="source-code">query3 = query3.replace("%", "\%"); // Java</p>
			<p class="source-code">SET @query3 = REPLACE(@query3, '%', '\\%'); // PHP</p>
			<p>You can apply this mechanism to any possibly dangerous character before sending a query statement to the database or other parts of the application.</p>
			<h3>Character encoding and escaping in SQL Server</h3>
			<p>The same assumptions and mechanisms we considered for MySQL can be applied to SQL Server. So, both the <a id="_idIndexMarker312"/>Java and PHP functions we have considered <a id="_idIndexMarker313"/>are valid for suppressing the single quote <a id="_idIndexMarker314"/>character. This time, when we talk about SQL server, we will consider the corresponding C# code, too, for replacing single quotes <a id="_idIndexMarker315"/>with double quotes:</p>
			<p class="source-code">query3 = query3.replace("'", "''"); </p>
			<p>In addition to what we already considered for MySQL, SQL Server has an <strong class="source-inline">ESCAPE</strong> clause, which can be used to escape any character within a SQL query in a <strong class="source-inline">LIKE</strong> clause:</p>
			<p class="source-code">SELECT * from users WHERE name LIKE 'a\%' ESCAPE '\'</p>
			<p>The preceding query escapes the backslash character in the <strong class="source-inline">LIKE</strong> clause, only returning records with a <strong class="source-inline">a%</strong> username (provided it exists).</p>
			<h3>Character encoding and escaping in Oracle Database</h3>
			<p>While considering <a id="_idIndexMarker316"/>the same assumptions made for MySQL, Oracle <a id="_idIndexMarker317"/>Database also usually <a id="_idIndexMarker318"/>relies on the PL/SQL language. This also has a <strong class="source-inline">replace()</strong> function, which can be used as follows:</p>
			<p class="source-code">query = replace(query, '''', '''''');</p>
			<p>Oracle <a id="_idIndexMarker319"/>Database also supports an <strong class="source-inline">ESCAPE</strong> clause for the <strong class="source-inline">LIKE</strong> clauses, as was the case for SQL Server.</p>
			<p>After dealing with these specific techniques, let's now move on to something more high-level in terms of code-level countermeasures.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor094"/>Secure coding practices</h2>
			<p>In most <a id="_idIndexMarker320"/>cases, the root of all the application <a id="_idIndexMarker321"/>security problems resides in the design and development phase. More often than not, in fact, designers and developers tend not to consider security <a id="_idIndexMarker322"/>aspects in the applications <a id="_idIndexMarker323"/>they find themselves working on, usually giving more importance to the functional aspects. This leads not only to vulnerabilities such as SQL injection but also to the increasing difficulty in remediating these vulnerabilities. Addressing security problems during the design and development phase takes much less effort as the only thing to do is apply the tools we described earlier and some secure design principles.</p>
			<p class="callout-heading">The OWASP SAMM Framework</p>
			<p class="callout">OWASP, among other relevant projects, has devised an important framework to give organizations <a id="_idIndexMarker324"/>the tools to ensure the application of a model that promotes secure software development for all stages and stakeholders involved in the process of software design and development—the <strong class="bold">Software Assurance Maturity Model</strong> (<strong class="bold">SAMM</strong>). This framework provides a way for enterprises to self-assess their software development life cycle in terms of security, independent from the technologies used. For further information, you can access the project's web page at <a href="https://owasp.org/www-project-samm/">https://owasp.org/www-project-samm/</a>.</p>
			<p>We will now consider some good practices that can help in producing more secure code against SQL injection. This serves as an introduction to a security-focused approach for dealing with SQL injection from a coding perspective, introducing secure coding aspects to your application that can prove particularly effective and saving time and effort in subsequent stages of the application life cycle.</p>
			<h3>Introducing additional abstraction layers</h3>
			<p>When we talk <a id="_idIndexMarker325"/>about abstraction layers, we mean different logical components, each devised to interact with your application logic. General examples of application layers are the presentation layer, which incorporates the more graphical and interactive aspects of the application, and the data access layer, designed to interact with data separately from the core application logic. Separating layers in an application generally improves security as moving from one layer to another is generally subject to more controls and makes applying security measures much more linear and practical.</p>
			<p>An example <a id="_idIndexMarker326"/>of special additional layers introduced for security reasons is the ADO.NET framework we saw earlier, which can be used to interact with the database by introducing an additional level to the application specifically to send secure commands to the database, much like a dedicated data-access layer.</p>
			<h3>Managing sensitive data securely</h3>
			<p>Another important security principle when designing a secure application is deciding how to manage <a id="_idIndexMarker327"/>and handle potentially sensitive data. Some of the information used and stored by the application might be extremely valuable to potential malicious attackers, including authentication information, such as passwords or credit card numbers, or even other sensitive or personal identifying information, such as names, surnames, physical addresses, and social security numbers.</p>
			<p>When dealing with passwords, usually we are talking about particularly relevant information that is often <a id="_idIndexMarker328"/>specifically targeted by attackers. One of the most useful measures to take is storing passwords with a particularly <strong class="bold">Secure Hashing Algorithm</strong> (<strong class="bold">SHA</strong>), such as SHA-2, which provides one of the highest standards in cryptographic hash, producing one-way digests with 256- or 512-bit lengths. We saw, in our previous chapter, how <a id="_idIndexMarker329"/>other surpassed standards, such as <strong class="bold">Message Digest 5</strong> (<strong class="bold">MD5</strong>), are no longer secure and could easily be broken into, with the attacker extracting the original password value, in the case of a successful SQL injection attack.</p>
			<p>Another means of securing sensitive information includes masking data by only showing parts of the data to the application while keeping the original data unaltered. This can be achieved by treating this data appropriately in the application, applying pseudonymization techniques that substitute, for example, a large part of the information with special characters (such as <strong class="source-inline">*</strong>), making it recognizable to the owner of the information while at the same time not leaking more information than necessary to outsiders.</p>
			<p>Of course, we want our application to be as invulnerable as possible to SQL injection, but considering that this risk will never be zero, this type of protection can definitely make a difference in securing an application and its data, minimizing the effects of a successful attack.</p>
			<h3>Stored procedures</h3>
			<p>This measure is probably the most specific so far as it is directly linked to SQL databases. Stored procedures <a id="_idIndexMarker330"/>are specific instructions that are stored within the database itself and on which it's possible to apply stricter access control.</p>
			<p>We saw how an application can potentially access the whole database so that when it's compromised with a SQL injection attack, it can give access to attackers, even to information residing on the same database in which the application database is not linked to the application itself, as we saw in the previous chapter with the shared MySQL database of the OWASP Broken Web Applications virtual machine, which allowed access to information belonging to other applications.</p>
			<p>When you are using stored procedures, you can change the access permissions for the instructions <a id="_idIndexMarker331"/>contained within it, giving less privilege than the application to the commands that are executed. This means enforcing the principle of <strong class="bold">least privilege</strong>, which means that if for some reason an attacker can compromise the stored procedure containing the SQL commands, the damage would be contained due to the stricter access controls implemented.</p>
			<p>This concludes our look at what can be done in terms of application development and coding. Applying as many of these measures as possible can definitely help in securing your application against SQL injection attacks. However, this is not the only way in which you can apply additional security measures to your application, as you can also act outside of it in the context that the running application is in. Let's look at what this means.</p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor095"/>Defending against SQL injection – platform-level defenses</h1>
			<p>As mentioned earlier, platform-level defenses refer to all of the security measures we can apply at a <a id="_idIndexMarker332"/>platform and infrastructure level, possibly preventing malicious commands from entering or leaving the application and identifying and stopping harmful traffic. This also includes applying security measures to the database system itself.</p>
			<p>Here, we are presenting a view of what can be done to secure an application against SQL injection by applying security controls and measures outside of it, in this way, granting <a id="_idIndexMarker333"/>additional layers of protection. This concept is called <strong class="bold">defense-in-depth</strong> and is one of the most relevant aspects of information security, helping to minimize possible threats against systems and applications alike.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor096"/>Application-level firewall logic</h2>
			<p>The first, and probably most well-known, concept of protection is firewalling. A firewall is, generally speaking, an object that decides, usually according to some specific rules, whether a data flow—usually network traffic—is allowed to pass. In enterprise security, firewalls are usually physical <a id="_idIndexMarker334"/>appliances located at <a id="_idIndexMarker335"/>the boundaries of networks and sub-networks, acting as gatekeepers. These appliances are usually hardened computers whose only purpose is to filter traffic that enters or exits a network.</p>
			<p>While, of course, traditional firewalls can help thwart any type of attack, we are more focused on the application-level side of things. Usually, firewalls exist independently of the presence of applications within a network, so we consider them external entities with respect to our scope. The same logic of firewalls, however, has also been applied to application-level concepts, filtering requests directed at application components in the same way that a traditional firewall would do, discarding whatever, according to a set rules, is deemed harmful to the specified application components. Let's see some examples of this concept.</p>
			<h3>Web application firewalls</h3>
			<p>When <a id="_idIndexMarker336"/>talking about web application security, not mentioning <strong class="bold">Web Application Firewalls</strong> (<strong class="bold">WAFs</strong>) is almost impossible. A WAF, usually <a id="_idIndexMarker337"/>in the form of a software solution or built within a specific network appliance, is designed to protect web applications from possible attacks against them, including SQL injection attacks. The most practical solution is using software-based WAFs. These are usually built into a web application or web server and require little configuration effort as they do not alter the web infrastructure surrounding the applications. Appliance-based WAFs, on the other hand, can be useful in certain scenarios as their activity does not take up web server resources, thereby not impacting functionality and performance. However, as application developers usually tend not to meddle with the surrounding infrastructure, we will mostly refer to software-based WAFs, also because of how simply they can be implemented.</p>
			<p>WAFs <a id="_idIndexMarker338"/>tend to work by using filters that define what is accepted and what is not. These act as the rules of the WAF <a id="_idIndexMarker339"/>and they are responsible for accepting or rejecting requests. Filters need to be properly configured in order to prevent most attacks against your application. There are many ways in which filters can be implemented:</p>
			<ul>
				<li><strong class="bold">Web server filters</strong>: These <a id="_idIndexMarker340"/>are filters that are installed as <a id="_idIndexMarker341"/>extra modules on a web server and tend to work as an additional component, evaluating requests entering the web server. Implementations <a id="_idIndexMarker342"/>can vary depending on the web server technology. Some examples include <strong class="bold">ModSecurity</strong> (available at <a href="https://modsecurity.org/">https://modsecurity.org/</a>), which <a id="_idIndexMarker343"/>works for Apache, and <strong class="bold">UrlScan</strong> by Microsoft, which is made for IIS web servers (<a href="https://docs.microsoft.com/en-us/iis/extensions/working-with-urlscan/urlscan-3-reference">https://docs.microsoft.com/en-us/iis/extensions/working-with-urlscan/urlscan-3-reference</a>).</li>
				<li><strong class="bold">Application filters</strong>: These filters can be implemented as additional modules of your application <a id="_idIndexMarker344"/>in the same programming language. For <a id="_idIndexMarker345"/>application developers, this option is often considered as these filters tend to be independent of the web server technology and can be included as additional application plugins. A notable example by OWASP is OWASP Stinger, which, however, it is not supported by OWASP anymore.</li>
				<li><strong class="bold">Web service filters</strong>: Another useful option is filtering web service messages. This can be <a id="_idIndexMarker346"/>done in a custom way—for example, by filtering <a id="_idIndexMarker347"/>input messages containing SQL injection attempts or even output messages containing information disclosures.</li>
			</ul>
			<p>WAFs are a very versatile tool for protecting web applications as they can be used in various modes to further improve security.</p>
			<h3>Application intrusion detection systems</h3>
			<p>Aside from regular network-based <strong class="bold">Intrusion Detection Systems</strong> (<strong class="bold">IDSes</strong>), which can be used to <a id="_idIndexMarker348"/>identify cyberattacks <a id="_idIndexMarker349"/>in general and provide alerting functionalities, WAFs can be used as an application-level IDS to apply this concept directly to the specific applications it protects.</p>
			<p>The way this works is to use the WAF in passive mode so that it can inspect the application request and send alerts if suspicious requests are found. This way, network administrators can be warned if a security incident occurs, thereby acting in a timely fashion based on the alert trigger.</p>
			<h3>Database firewalls</h3>
			<p>The last <a id="_idIndexMarker350"/>firewall we will consider is the database firewall. A database firewall <a id="_idIndexMarker351"/>is basically a proxy server positioned between the application and its database that inspects the queries that are sent to it. </p>
			<p>The application sends the query in the same way as if it were directed directly to the database, but the query is sent to the database firewall instead. At this point, the database firewall can <a id="_idIndexMarker352"/>inspect the query to check whether there is anything wrong with it (for example, whether it contains statements that deviate from the normal application <a id="_idIndexMarker353"/>behavior, tautologies, or any specified illegal characters). The proxy might then decide, based on its evaluation rules, whether the query can reach the database so that the database does not even receive harmful queries.</p>
			<p>Since a database is usually contacted by an application to execute a specific set of functions, as defined by the application requisites, modeling whitelisting rules is the best approach, making it possible only for accepted queries to pass through the proxy. </p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor097"/>Database server security mechanisms</h2>
			<p>Now that <a id="_idIndexMarker354"/>we have seen <a id="_idIndexMarker355"/>how it is possible to secure our application perimeter ny blocking malicious input and output data, the only missing element to be secured is the database server itself. We can apply some concepts of what we have seen so far also to secure the database itself.</p>
			<h3>Protecting the database data</h3>
			<p>Besides applying the measures we already seen—such as hashing passwords and masking sensitive <a id="_idIndexMarker356"/>data—the most obvious security step to take in securing the database itself is applying cryptography to the stored data. Cryptography ensures that if the database is read directly—for example, if the data residing on it is copied or dumped in some way—its content remains protected and cannot be read by malicious attackers.</p>
			<p>Cryptography by itself does not offer 100% certainty that the data can never be read by unauthorized individuals or organizations, but it does guarantee that breaking this protection requires a sufficiently long time and a lot of computational power, thereby rendering these attacks impractical or almost impossible.</p>
			<p>Cryptographic algorithms always evolve over time, and they can be rendered obsolete whenever a <a id="_idIndexMarker357"/>major technological breakthrough takes place and more computational power is available to individuals and organizations. This has been the case for older cryptographical standards, such as the <strong class="bold">Data Encryption Standard</strong> (<strong class="bold">DES</strong>), which has been used for a long time. However, as common use computers have increasingly become more powerful, its cryptography was deemed no longer secure. Other, more reliable standards, such as 3DES—a triple iteration of the DES algorithm—are now considered insecure for the same reason. While a few years ago, they provided enough security, some actors might possess enough computational power to break them, thus being able to access protected information.</p>
			<p>The de facto <a id="_idIndexMarker358"/>standard for modern cryptography is now the <strong class="bold">Advanced Encryption Standard</strong> (<strong class="bold">AES</strong>)—specifically, AES-256 with a 256-bit key, which provides a high guarantee of security. It works as a symmetrical cryptography algorithm as the same secret key is used for both the encrypting and decrypting of data. As long as the key remains secret, encrypted information will stay protected. To put this security feature <a id="_idIndexMarker359"/>in perspective, breaking a 256-bit key by brute-forcing, trying all the possible combinations, can require up to 2 to the power of 256 attempts (the resulting number is a 78-digit number). Even if a single attempt took a nanosecond (one billionth of a second), the seconds needed to try all the possible combinations exceeds any 68-digit number. If a program was used to break the encryption, it would run for far longer than the estimated life of the sun, which is estimated to be 5 billion years.</p>
			<p>The only challenge to securing data through cryptography is keeping the encryption key secret. This is far from simple; if the key is stored on the database server as it is, it could be read by <a id="_idIndexMarker360"/>attackers. One of the most feasible solutions is storing the key in a safe way in a different location—for example, on a secure location in the application server. In order to use it, an attacker would need to compromise both the application server and the database server.</p>
			<p>Encrypting data on a database with the appropriate mechanisms should provide enough security in case raw data gets exfiltrated or the actual device on which the data is stored is outright stolen, preserving the confidentiality of the information.</p>
			<h3>Protecting the database server</h3>
			<p>After <a id="_idIndexMarker361"/>acting on the stored data, let's now see how a database server can be protected. A database server is, first and foremost, a system within a network. As such, it might be inherently vulnerable to cyberattacks. There are a lot of ways to prevent or minimize the effects of malicious actions, of which we will look at some examples:</p>
			<ul>
				<li><strong class="bold">Patching</strong>: The database <a id="_idIndexMarker362"/>server is a server in your infrastructure. As such, you need to be sure that it has the least number of vulnerabilities so that attackers have the fewest possible amount of ways to compromise it. A fundamental security principle is ensuring that software running on the database server is always up to date and has the most recent security updates installed. <p>Most updates are released to provide remediation to vulnerabilities, some of which present critical risks to the server and the surrounding infrastructure. It's of the utmost importance to have security updates installed on not only the database system but also the operating system and all the software installed. </p><p>Vulnerabilities <a id="_idIndexMarker363"/>could, in fact, be exploited one after the other, and the presence of more vulnerabilities increases the risk of a system being compromised. Patching can be enforced not only manually but also through automatic patching agents, which are widely used in various enterprise networks.</p></li>
				<li><strong class="bold">Enforcing the least privilege principle</strong>: We already talked about the least privilege <a id="_idIndexMarker364"/>principle when dealing with stored procedures. This time, we need to address it more broadly. On an operating system, programs can be run at various levels, from a low-privileged to an administrator level. <p>One way to improve security is by ensuring that database programs are run at a low privilege level in terms of reading, writing, and executing. Applying the least privilege principle ensures that, if the database is compromised, the actions resulting from this compromise are mitigated in their impact—an attacker has lower chances of causing damage to the system itself and possibly has a limited chance for lateral movement (which means attacking other systems in the network).</p></li>
				<li><strong class="bold">Enforcing authentication and monitoring controls</strong>: Finally, another way to prevent attackers from causing damage is by improving the security controls relating to <a id="_idIndexMarker365"/>authentication and monitoring. This includes ensuring that passwords are not weak by enforcing a strong password policy, disabling <a id="_idIndexMarker366"/>default accounts (which are often targeted by attackers as they already know their username and only need to guess the password), and enabling logging so that possible authentication attempts are tracked, as well as actions on the server itself.</li>
			</ul>
			<p>This concludes our overview of the more practical measures that can be taken against SQL injection in terms of platform-level defenses. Besides these, it's worth noting some more general principles to be taken into account when securing applications. </p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor098"/>Other security measures</h2>
			<p>In addition to <a id="_idIndexMarker367"/>what we have seen so far, the infrastructure <a id="_idIndexMarker368"/>and platform-level defense can also include some other general principles that, if followed, can further improve the overall security of your environment. Generally speaking, applying all the measures we've seen so far would definitely put your application and systems at quite a satisfying security level, but for the sake <a id="_idIndexMarker369"/>of completeness, we will now list some other possible <a id="_idIndexMarker370"/>tweaks that can provide additional protection against SQL injection.</p>
			<h3>Reducing information disclosure</h3>
			<p>When performing offensive actions against an application or a system, a malicious agent will always try <a id="_idIndexMarker371"/>everything in their power to obtain as much information as possible about your environment so that they can attempt various <a id="_idIndexMarker372"/>attacks depending on the information they obtain. Limiting the information that they can access can effectively reduce their attack potential, thereby minimizing the risk that your application will be compromised. Here, we will present some areas in which reducing leaked information can prove useful and might effectively limit attackers' potential:</p>
			<ul>
				<li><strong class="bold">Not showing error messages</strong>: When we dealt with offensive SQL injection techniques, we tried to rely as much as possible on error messages. Default SQL error messages can leak information regarding versioning and query syntax, and can also give other clues to attackers for trying other attacks. Showing error messages can give an attacker more hints than you would probably wish for, so avoiding the display of error messages is a good idea. <p>Sometimes, it is a wise choice not to show that an error has occurred at all, avoiding possible blind SQL injection attempts. You could either not show any errors at all in your application, or else provide a general, customized HTTP error page (for example, an HTTP 500 error page). This, of course, can make things more difficult for debugging purposes, but if the application is in a production environment, this should not be an issue.</p></li>
				<li><strong class="bold">Prevent Google (and other search engine) hacking</strong>: Google hacking techniques are a way to return specific information from websites by inserting specific operators within the search string of Google. Inserting certain keywords could allow attackers to obtain relevant information about your application by accessing specific web pages containing a specific keyword. This can be prevented by editing a file in the root directory of your website, which instructs search engines not to crawl your website so that inner pages cannot be accessed by them. This file is called <strong class="source-inline">robots.txt</strong>, and its content to prevent this behavior looks as follows:<p class="source-code">User-agent: *</p><p class="source-code">Disallow: /</p><p>This means that web crawlers are not allowed to index your website, thereby preventing specific web searches from displaying content that could be used against you, which could provide useful information to attackers.</p></li>
			</ul>
			<p>Reducing the <a id="_idIndexMarker373"/>quantity of information that an application shows, limiting it to what is only strictly necessary, greatly improves security as it discourages potential attackers from trying to compromise your application.</p>
			<h3>Secure server deployment</h3>
			<p>Another critical step for security is server deployment, which needs to be made in the least risky approach possible. </p>
			<p>In general, it's best to keep your application infrastructure elements separated. This includes the <a id="_idIndexMarker374"/>application/web server and the database server. If they are deployed on the same machine, by compromising one, an attacker could easily obtain access to the other one. This could, in addition, defeat the point of measures such as cryptography as an attacker would have access to the database and the stored encryption key at the same time. In general, splitting your architecture<a id="_idTextAnchor099"/> into more components helps preserve security by reducing the impact caused by possible malicious actions.</p>
			<p>Deployments <a id="_idIndexMarker375"/>should also take place while guaranteeing that the machine's configuration is made secure by removing settings that are typical of the testing and debugging stages of development. For example, some exposed services used for debugging and remote access can provide attack points that attackers could use to compromise your systems and application.</p>
			<h3>Network access control</h3>
			<p>Finally, another security measure that is used in conjunction with separate machines for each server <a id="_idIndexMarker376"/>is applying <strong class="bold">Network Access Control</strong> (<strong class="bold">NAC</strong>). NAC involves only allowing selected hosts to connect to specific servers and services. In a setting <a id="_idIndexMarker377"/>in which we have deployed a web server and database server separately, for example, we would want the database server to only accept connections coming from that web server. Otherwise, an attacker who has gained access to the network could interact with the database server directly, bypassing most of the security measures we put in place at the application level.</p>
			<p>This can be achieved, for example, by allowing a connection from hosts that have a specific certificate <a id="_idIndexMarker378"/>installed or through the use of firewalls, only allowing connections from specific hosts. Routers could also be instructed to enforce this principle by implementing access control lists that provide a set of hosts from which to accept connections.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor100"/>Summary</h1>
			<p>That was quite a lot of information. When dealing with defense mechanisms, there are a lot of factors to consider, and the more defense mechanisms you apply to your context, the less chance an attacker has to cause damage to your environment. For this reason, using all of the security measures we described in this chapter—or almost all, depending on the context and the applicability of these controls—is very important for security. </p>
			<p>This chapter first covered the general aspects of countermeasures against SQL injection—specifically, dealing with user input and controlling data flows. Then, we analyzed specific defenses for dealing with application coding, general patterns to follow in application development, and securing the infrastructure surrounding the application.</p>
			<p>As for code-level defenses, we saw how to validate input, using both blacklisting and whitelisting, to only accept safe input. Then, we applied sanitizing measures, both for query statement construction—using parameterized queries—and character encoding and escaping, to avoid harmful characters that could enable SQL injection. Secure coding practices were also examined, showing some rationales for building code that is secure against SQL injection and, collaterally, other attacks in general.</p>
			<p>Platform-level defenses can fall outside the strict scope of application security and involve more general security principles. We saw how firewall logic can be applied to application components through WAFs and database firewalls. We then analyzed ways to secure the database itself, which is one of the most important parts of database-reliant application architecture, both considering the data and the database server. Finally, other general security measures were discussed in order to improve the overall security of your application.</p>
			<p>While all of these measures help against SQL injection, you will have realized that the focus tends to be directed more toward security in general. The next chapter will put all you have learned in perspective, giving you a way to critically examine all that you have learned. Consider it as looking back after a long journey, putting you in the position to think about all that you have seen and experienced. Hopefully, you will have become more educated not only about SQL injection but also about security in general. Maybe (just maybe) this will also spark an interest in cybersecurity in a broader sense!</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor101"/>Questions</h1>
			<ol>
				<li>How should user input be treated when designing an application?</li>
				<li>What does input validation mean? Describe two approaches for validation.</li>
				<li>What is a parameterized query?</li>
				<li>Why is character encoding and escaping useful against SQL injection?</li>
				<li>What does a WAF do?</li>
				<li>Is it safe to store an encryption key in the same place where the encrypted data is stored?</li>
			</ol>
		</div>
	</body></html>