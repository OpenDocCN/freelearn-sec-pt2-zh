<html><head></head><body>
		<div id="_idContainer134">
			<h1 id="_idParaDest-91"><a id="_idTextAnchor102"/><em class="italic">Chapter 6</em>: Putting It All Together</h1>
			<p>Here we are, finally, at the end of our journey of going through the secrets of SQL injection. By now, you have experienced what SQL injection is, what it implies in the context of an application or a more complex system, what consequences can be brought to security in case of such an oversight, and what countermeasures can be taken in order to mitigate or totally prevent its effects from happening.</p>
			<p>This final chapter serves as an overall review of what you learned by reading this book. It will do this by summarizing and analyzing what we've seen in brief, hoping to put everything into a critical perspective while also considering the broader implications not only of SQL injection, but also security vulnerabilities in general, in a world that is always relying on information technology and data.</p>
			<p>The aim is to, besides helping you to briefly go through this book's content in terms of knowledge and practice in a structured and easy-to-follow manner, provide you with food for thought and give all of these notions a deeper meaning through critically examining them. This book, after all, is meant for mastering SQL injection, not only from a technical standpoint but also by knowing exactly what it is all about.</p>
			<p>This chapter covers the following topics:</p>
			<ul>
				<li><strong class="bold">SQL injection – theory in perspective</strong>: In this section, the theory aspects of SQL injection will be summarized, with the main concepts behind SQL injection being described, with comments also being provided.</li>
				<li><strong class="bold">SQL injection – practice in perspective</strong>: Here, the more practical aspects will be described in short and discussed, especially in terms of meaning and implications. We will also highlight real-world aspects related not only to SQL injection testing and countermeasures, but also more in general with respect to vulnerabilities.</li>
				<li><strong class="bold">SQL injection and security implications – final comments</strong>: Finally, some additional, final comments will help you focus on the real objective of this book and what it means to be a cyber security professional in order to spark your interest in this enticing path.</li>
			</ul>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor103"/>SQL injection – theory in perspective </h1>
			<p>Summarizing <a id="_idIndexMarker379"/>all the theory aspects we examined in the first part of this book may seem quite difficult. Here, we will provide an overview of what we have covered in the same order in which we encountered them.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor104"/>SQL injection in general</h2>
			<p>Let's first recap what<a id="_idIndexMarker380"/> SQL injection is and why it exists. SQL injection is caused inherently by SQL, which is a language responsible for interacting with relational database models. SQL is a very powerful language that's capable of performing a wide array of actions, including creating (<strong class="source-inline">CREATE</strong>) and inserting (<strong class="source-inline">INSERT</strong>) information within a database, deleting (<strong class="source-inline">DROP</strong> for tables and databases, <strong class="source-inline">DELETE</strong> for single entries), modifying (<strong class="source-inline">ALTER</strong>) or, much more commonly in an application setting, just selecting and querying (<strong class="source-inline">SELECT</strong>) its content with many different options. SQL injection allows malicious users to inject, within an existing operation, operations into the database that were not originally envisioned by the design of the application, possibly leading to harmful commands.</p>
			<p>The most common uses of SQL injection can range from making reserved information available to malicious users, including sensitive information such as access credentials or personal information, to directly exploiting the application logic, thereby bypassing authentication checks without inserting any credentials at all. This includes modifying the database without the consent of the owner, which could possibly lead to rendering the application unusable by irremediably damaging its functionality (for example, by deleting the table containing all access information, or even critical information for the correct functionality of the application). </p>
			<p>While different SQL-based database systems exist (such as MySQL, SQLite, Oracle Database, and Microsoft SQL Server), from a user's perspective, they only differ in terms of the syntax of the queries. In some cases, some characters are reserved for different purposes (such as commenting), while some built-in functions can vary from one implementation to another. In any case, the logic behind their functionality is mostly the same – think of their query language as some kind of local dialect of the same language: SQL.</p>
			<p>SQL is the main tool applications have to interact with a supported database system. SQL injection is a software vulnerability since the malicious payloads are injected at the application level, bypassing the limited set of operations that are usually allowed by the software. The database will only evaluate SQL code that is sent to it, so we can say that SQL injection, while being possible thanks to the possibilities offered by SQL itself, it's not a database problem. Instead, applications should contain security controls that ensure that the only operations performed on linked databases are the only ones defined by design, according to the application design requirements.</p>
			<p>Some of the design <a id="_idIndexMarker381"/>principles that, if applied to the development of applications interacting with SQL databases, could avoid SQL injection usually involve treating query content correctly; for example, by suppressing dangerous characters and commands. In general, the application should enforce a strict control of what is possible to a user.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor105"/>SQL injection attack techniques</h2>
			<p>In terms of specific attack techniques, SQL injection<a id="_idIndexMarker382"/> can offer potential attackers various ways to play with a database and alter its functionality. Let's talk about the most common ones individually.</p>
			<h3>Damaging application functionality</h3>
			<p>An attacker could use SQL <a id="_idIndexMarker383"/>injection to perform arbitrary commands on the database by concatenating any possible SQL command to an existing query string, then using the semicolon to terminate statements. A very simple but destructive case would be using a <strong class="source-inline">DROP</strong> statement, or modifying information in a database, such as login information, which could be vital for the application's functionality. These totally arbitrary commands are, however, in most cases, ineffective as SQL usually supports a single query at a time. Multiple queries, such as inline queries, tend not to be supported, thus hindering this type of attack. </p>
			<p>However, if the application already supports statements that can alter the database's content, these commands could be altered to cause serious harm to the application. Think of what could happen if an operation intended to delete a single user deletes all the users in a database instead. This is, however, quite uncommon since well-designed applications tend to mostly use <strong class="source-inline">SELECT</strong> statements. However, these can also be exploited.</p>
			<h3>SQL injection using UNION queries</h3>
			<p><strong class="source-inline">UNION</strong> is a SQL clause <a id="_idIndexMarker384"/>that can be added to existing <strong class="source-inline">SELECT</strong> statements to return results from another query within the same output of the first one. To do so, the two queries need to have the same number of attributes. However, an attacker can easily exploit this by adding arbitrary static values, such as fixed numbers, and proceeding with a trial-and-error approach.</p>
			<p>SQL injection using <strong class="source-inline">UNION</strong> can be used to gather a huge deal of information from a vulnerable database. The database schema itself, which can usually be accessed thanks to some default tables, can be queried to get information about databases within the system, tables, and table fields, thus disclosing what type of information is contained within a database. The resulting information can be used to directly query the database, providing the attacker with some sort of a blueprint for conducting successive information gathering attempts. The potential of <strong class="source-inline">UNION</strong> queries differs from database to database. In some cases, they can be used to retrieve a much larger set of information than the database being used by a single application, especially in MySQL and MSSQL, as many databases can be queried all at once if the target system hosts many database-reliant applications on it.</p>
			<h3>Escalating privileges</h3>
			<p>SQL injection can also be<a id="_idIndexMarker385"/> used by malicious users to gain higher privileges than they normally would have access to, thus being able to abuse otherwise inaccessible application functionalities.</p>
			<p>Using information gathering techniques, such as <strong class="source-inline">UNION</strong> queries, can allow malicious users to extract information from the database, which can sometimes lead to password disclosure. Login information, in fact, is usually stored within specific parts of the database. It's common practice to store password information as password hashes only, but those might be decrypted by password attacks, even offline, if weak hashing algorithms such as MD5 are used. In some cases, authentication could be directly bypassed by including an always true Boolean expression as the logical check used for the login process.</p>
			<h3>Blind SQL injection</h3>
			<p>One of the most common <a id="_idIndexMarker386"/>SQL attack techniques is called <a id="_idIndexMarker387"/>blind SQL injection. The name stems from the fact that, sometimes, the operations performed on the database do not return the database query output in the application, so an attacker is left on their own in guessing the database's contents. All the previous techniques that do not display the full query result, including authentication bypassing, can be technically included in this definition, but there are many other techniques in this category.</p>
			<p>In some cases, an application that's vulnerable to SQL injection, despite not showing actual query results, can present differences if query results exist or not. This is generally linked to satisfying a specific Boolean condition. In this case, we are talking about Boolean-based SQL injection since an attacker could use this information to conduct inference on the database content by using Boolean conditions to their advantage.</p>
			<p>There are, however, cases in which the application does not show any difference between a successful and an unsuccessful query. In this case, using Boolean-based SQL injection does not provide any value to the attacker. However, malicious users could find ways to generate such differences in application output. The most common way to do this is by adding a time delay in case an arbitrary condition is fulfilled. In this case, we are talking about time-based SQL injection.</p>
			<p>Finally, another technique in the spectrum of blind SQL injection is called <strong class="bold">splitting and balancing</strong>. The goal is to check whether, using equivalent SQL queries, the SQL code is evaluated by the system. In this case, the attacker could also insert arbitrary sub-queries in the same structure, still ensuring that the syntax is correct, thus performing potentially dangerous commands.</p>
			<h3>NoSQL injection</h3>
			<p>Finally, it is worth <a id="_idIndexMarker388"/>mentioning that <a id="_idIndexMarker389"/>despite SQL injection being the most common case of database injection, this vulnerability can also be of interest in terms of non-relational databases.</p>
			<p>While databases, in fact, do not always rely on query languages that provide the same possibilities with respect to SQL, and usually they are considered more secure than SQL itself, some arbitrary commands could be injected at the application level. These may be evaluated by the database, leading to potentially harmful operations.</p>
			<p>In the case of NoSQL databases, this is referred to as NoSQL injection. Despite the fact the many of the various techniques we have discussed do not concern NoSQL databases (for example, database dumping with <strong class="source-inline">UNION</strong> queries and the use of complex arbitrary statements), some of the command semantics can be altered at will by attackers who are able to place input in the <a id="_idIndexMarker390"/>application. In general, a<a id="_idIndexMarker391"/> malicious user can tamper with NoSQL databases by inserting, within parameters, elements that can alter the syntax and trick the underlying database into evaluating unexpected values, which could result in harmful behavior.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor106"/>SQL injection and other security flaws</h2>
			<p>SQL injection sure is an <a id="_idIndexMarker392"/>interesting topic, especially considering the inner workings that make it possible, as it shines the light on a much broader problem. SQL injection is, in fact, a specific type of software vulnerability that concerns applications that interact, in some form or another, with databases. The presence of such a vulnerability triggers an unexpected behavior that can result in damaging consequences, not only to the applications but more generally to the world around it.</p>
			<p>Let's take a look at an example. Think of an application that allows, for authenticated individuals, access to sensitive information such as personally identifying information, physical addresses, and even social security numbers or other details a person would not normally disclose to anybody. Through SQL injection, an attacker has obtained all the information included in the database, while also deleting it. In this case, not only is the application damaged, but also all the people such data belongs to. The malicious attacker could disclose the content of such a database on the internet, exposing these people to any malicious person that could, in turn, make use of this information any way they like –this includes consequences that could range from harassment to fraud, or even direct persecution. Public data can be used by anybody, regardless of their intentions, so it is key to keep data secure, without leaking any more information than strictly necessary, in order to avoid such consequences.</p>
			<p>Data in today's world is always a critical asset. Many people have already, unknowingly, given access to their personal information to various entities on the internet, which mostly use this information for commercial advantage by way of targeted advertisements. This information is also used to direct people to content they may like. </p>
			<p>In a twisted way, this could also be used to force some thoughts and ideas on targeted people, thus controlling, even indirectly, their way of thinking and acting. This is just an example to give you a glimpse into how data is important, and how anybody may consider it valuable, so you should never give too much information away to anybody. In this sense, a vulnerability that allows attackers to access information that is kept secret on purpose is, of course, much more critical and should make everybody worried about it.</p>
			<p>Many other vulnerabilities exist, and these can possibly lead not only to destructive consequences against targeted systems but could also disclose reserved information. Most vulnerabilities, if not all, are the result of the sometimes unexpected functionality of hardware or software. This may mean a coding bug, issues in terms of managing memory within a program, faulty protocols used for connectivity, or minor oversights that can result even in critical issues. </p>
			<p>One of the reasons why it is necessary<a id="_idIndexMarker393"/> to keep all software and firmware updated is that, usually, updates are used to fix these issues when they're discovered. This does not necessarily mean that updated software does not have any vulnerabilities on it, but it ensures that vulnerabilities known at that point are fixed. Since, in the case of security vulnerabilities, we are talking about issues that are usually not expected, it could happen that vulnerabilities stay undiscovered for long periods of time.</p>
			<p>In this context, information security's mission is to protect IT environments by identifying vulnerabilities, providing countermeasures, and setting protective layers around systems to prevent security issues from happening. Information security acts in a collaborative effort for anybody involved: vulnerabilities are made publicly known as soon as they are discovered in order to warn all people about them. This, of course, could, in principle, favor malicious attackers, who could obtain this knowledge of possible vulnerabilities and try to exploit it, but this risk is irrelevant compared to the possibility that a vulnerability stays secret for a long time, possibly known only to some attackers that can exploit it undisturbed. </p>
			<p>Cases of known vulnerabilities that were not disclosed include some Windows vulnerabilities that stayed secret for a long time, allowing some surveillance agencies (which I will not mention) to have some kind of a backdoor—a privileged means of access—to computers around the world. While this conduct can be arguable, the fact that manufacturers and system managers are kept oblivious about such vulnerabilities introduces a very high risk in case such secret information is exfiltrated unknowingly to those who are in charge of protecting it. Recent examples include the vulnerability responsible for making the EternalBlue attack possible, which affected Windows systems. </p>
			<p>Such vulnerabilities allow malicious attackers to exploit a bug in the <strong class="bold">Service Message Block</strong> (<strong class="bold">SMB</strong>) protocol<a id="_idIndexMarker394"/> implementation in Windows, which, if unpatched, could lead to executing arbitrary commands on the target machine. This attack was devised <a id="_idIndexMarker395"/>by the <strong class="bold">National Security Agency</strong> (<strong class="bold">NSA</strong>) of the United States. Information about such an attack and the vulnerability it exploited surfaced in 2017, shortly after the vulnerability was patched, but it is estimated that the NSA knew about it for about 5 years prior. The secrecy of such a vulnerability allowed many cyber criminals to exploit it in the years prior to it being patched, providing users with a good reason to never keep vulnerability information secret – attackers could <a id="_idIndexMarker396"/>discover it anyway, and they would never release information about it to the public.</p>
			<p>Information security's mission leads to the reason why we looked at practical aspects in the second part of this book: testing is one of the key elements in finding vulnerabilities so that they can be fixed. Countermeasures are what make testing useful, thus allowing vulnerabilities to be effectively remediated. Let's go through this practical part together once again, explaining what we did and why.</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor107"/>SQL injection – practice in perspective</h1>
			<p>For our practical part, we set<a id="_idIndexMarker397"/> up a safe environment so that we didn't cause problems for any external entities through our testing – this way simulating as if we were testing a real system belonging to us – identifying and exploiting SQL injection specifically. After dealing with probably the most fun aspect in the practical part, we described what can be done to prevent SQL injection from happening.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor108"/>Attacking using SQL injection</h2>
			<p>Let's review the tests we<a id="_idIndexMarker398"/> performed on the targets we selected and go through the techniques we put into practice.</p>
			<h3>Manual techniques</h3>
			<p>By taking advantage<a id="_idIndexMarker399"/> of the OWASP BWA project, we have been able to explore most of the attack techniques we have previously seen in the theory section. This was made possible by us selecting three specific web applications, against which we could try a wide spectrum of SQL injection attacks.</p>
			<p>Our first target was the Mutillidae II web application, which is a training web application for testing a wide range of known vulnerabilities. Among these, SQL injection was present too. We learned how to exploit both <strong class="source-inline">SELECT</strong> statements, to retrieve arbitrary information from the database, and <strong class="source-inline">INSERT</strong> statements, to make it possible to extract information by creating accounts within the application. These accounts have been manipulated to include, within their information, private data present in the database.</p>
			<p>With the second target, Magical Code Injection Rainbow, we explored multiple SQL injection exercises in the form of challenges. Here, we tested techniques such as blind SQL injection and error-based SQL injection and exploited functions that can return query results through error messages.</p>
			<p>Finally, with Peruggia, we looked at a pseudo-realistic web application that was intentionally vulnerable but without hints or guides. One of its vulnerabilities was SQL injection. We saw how SQL injection can give malicious users a way to bypass login authentication. This technique can also be used as a way to perform inference through blind SQL injection since access is only granted if the condition is satisfied. This way, by using Boolean checks, it is possible to verify information on the database.</p>
			<p>With these manual techniques, we saw the potential of SQL injection and the ways to test for this vulnerability in order to assess the security of an application.</p>
			<h3>Automated techniques</h3>
			<p>Another tool at our <a id="_idIndexMarker400"/>disposal is using specific software tools that can help in verifying whether an application is vulnerable to SQL injection in an automated way, saving time during testing.</p>
			<p>OWASP ZAP is a versatile tool suite for web application security testing and includes a variety of tools. Specifically, the Spider tool helps us find web pages within an application and set up crawlers that explore hypertextual links within the pages, thus discovering dynamic web pages containing web forms. The Scan tool, on the other hand, tries various payloads against dynamic pages in an automated fashion. This helps us find vulnerabilities, depending on the response it gets from the web application: if the output matches a vulnerable response, ZAP registers it as a vulnerability. While this is, of course, not completely error-proof, sometimes leading to false positives, it definitely helps with efficiency. An additional useful tool is the Fuzzer module, which automatically sends web requests by substituting a list of set values to a target parameter, thus allowing more targeted tests with special user-defined payloads.</p>
			<p>sqlmap is another important tool that, thanks to its options, can help in identifying the SQL injection vulnerability on a target web page. Various customization options are available that allow many different attack techniques to be implemented, which also generate database dumps. sqlmap also has the functionality to crack password hashes, which can be retrieved from the database dumps.</p>
			<p>Both tools are used by<a id="_idIndexMarker401"/> security professionals worldwide and can help make testing for SQL injection much more efficient and less time-consuming. Of course, these are not a substitute for manual tests, but they are usually enough for us to tell if a web application is vulnerable to SQL injection or not.</p>
			<h3>SQL injection against web services and mobile applications </h3>
			<p>Finally, for our <a id="_idIndexMarker402"/>SQL injection testing, we added tests against web services and <a id="_idIndexMarker403"/>mobile applications that can define a huge range of possible scenarios. Web services, in fact, can be responsible for simple applications based on web services that contain lightweight logic. This is particularly true for mobile applications, which usually represent an interface for remote web services, and IoT scenarios, which are usually quite simple in terms of their implementation and encourage low computationally intensive devices to interact through these.</p>
			<p>We looked at these to prove that SQL injection does not only interest web applications, but also any kind of application that relies, in some way, on a SQL database.</p>
			<p>After these tests, we moved on to the defensive side in terms of SQL injection, that is, evaluating possible countermeasures.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor109"/>Defending against SQL injection</h2>
			<p>In terms <a id="_idIndexMarker404"/>of defense, generally speaking, it's all about checking and applying controls to the input and the output of an application. After all, attacking an application usually consists of sending malicious input. As we have seen with SQL injection, the principle is always the same. First, input coming from users needs to be considered as potentially malicious so that we can start thinking about security measures we can apply.</p>
			<p>In this book, we examined defense mechanisms based on where we intend to apply them and then divided them into code-level and platform-level defenses, depending on whether we were acting on the actual coding of the application or the infrastructure around it.</p>
			<h3>Defending against SQL injection with code-level defenses</h3>
			<p>When applying defense <a id="_idIndexMarker405"/>mechanisms to our application code, these can be divided in different categories, depending on their objective.</p>
			<p>Input validation consists of examining the input and checking if it's valid according to our rules. There are generally two ways in which we can define our validation rules. The simplest one is based on a blacklist, so that if such input belongs to a set of input we deem potentially dangerous, we do not accept it. However, while this method is easy to implement, we need to specifically define what dangerous input is, and it may happen that we miss some dangerous cases, especially if new ones are discovered. Whitelisting, on the other hand, is a stricter way of doing things and is usually more secure: we only accept input belonging to a list of accepted input, this way excluding anything that we do not consider normal.</p>
			<p>Another way to treat input correctly is by constructing query statements in a secure manner. We have seen that the magic of SQL injection usually happens when the query statement is constructed using user-provided input, thus generating unexpected commands. To prevent this, we can refer to parameterized queries, in which input is saved into specific parameters and an additional step is added before we actually send the query to the database. This ensures, if correctly applied, that user input is not interpreted as part of a query that could alter the syntax.</p>
			<p>Another option is building our code so that it excludes harmful characters from user input, or even ignores them. If we transform a character into another encoding so that our application can read it without making it harmful to the SQL database, this is known as character encoding. Character escaping is where we insert escaping mechanisms that make the database ignore such characters, even if they're present as they are inserted into the query.</p>
			<p>Besides these techniques, there are also some useful principles to keep in mind when developing an application. These include building the application using various abstraction layers, such as separating the user interface from the actual application logic, thus not giving direct access to more sensitive areas. </p>
			<p>Treating sensitive data securely by adding cryptography and masking data is also very important as it can prevent malicious agents from obtaining private information that could result in harm, not only to the application, but also to users' privacy in some cases. This is especially relevant if you consider applicable laws for privacy and data protection.</p>
			<p>Finally, even if specifically focused <a id="_idIndexMarker406"/>on SQL, we looked at the use of stored procedures instead of building queries on the application. This can ensure that such operations can be executed with the privilege level decided on the database itself, as an application that sends commands to a database usually has a high privilege level. This means that if the application is compromised (for example, using SQL injection), an attacker can have full access to the database. Restricting privilege in stored procedures, on the other hand, can limit attackers' potential exclusively to what is strictly allowed, thus avoiding unexpected results.</p>
			<p>This concludes our overview of the countermeasures we can apply to our application code and design. Now, let's move on and look at the aspects surrounding the application context.</p>
			<h3>Defending against SQL injection with platform-level defenses</h3>
			<p>When talking <a id="_idIndexMarker407"/>about platform-level defenses, we need to move on from what is strictly intended as application security since we can deal with more collateral aspects. We are interested in protecting the application by applying measures outside of it, thus limiting the attack's potential and decreasing the likelihood of a successful attack against our application.</p>
			<p>The first example to mention for this type of<a id="_idIndexMarker408"/> defense is the <strong class="bold">web application firewall</strong>, or <strong class="bold">WAF</strong> for short. WAFs are components, usually software, that are able to accept or refuse application-level requests coming to our application. This is similar to code-level input validation, but it happens outside of the application, thus preventing malicious requests from even touching our application logic, as if nothing was sent at all. WAFs can act directly at the web server level, by processing requests directed to the web server; at the application level, by using software modules external to our application, thus being independent from server technology; and at the web service level, which is useful when using web services with SOAP.</p>
			<p>WAFs can also be used in passive mode as they act as an intrusion detection system. This way, the WAF can be continuously listening for traffic and can also send alerts in case something unusual is sent to the application. This way, the administrator can act in a timely fashion in case of an attack attempt.</p>
			<p>Firewalling logic can also be applied at the database level using database firewalls. These are like proxy servers, located between the application and the database, that examine commands meant to be sent to the database. In the case of malicious commands, nothing is sent to<a id="_idIndexMarker409"/> the actual database, preventing attacks such as SQL injection from happening.</p>
			<p>Another level of security can be added directly by securing the database. This means securing data stored on it through encryption or masking, and by securing the database server that the database is running on by applying patching and secure configuration, while also guaranteeing proper authentication mechanisms.</p>
			<p>Finally, some other security principles that can be applied at the platform level consist of avoiding unnecessary information leaks, suppressing error messages, and preventing search engines from exploring your web applications. </p>
			<p>Another important principle is deploying your application securely by separating elements such as application logic from the database and from the frontend and backend. Applying network-level authentication using <strong class="bold">Network Access Control</strong> (<strong class="bold">NAC</strong>) can also<a id="_idIndexMarker410"/> prevent many attacks since only some network entities are allowed to perform sensitive actions on the application. They can also authenticate using a specific certificate or through network rules enforced by firewalls.</p>
			<p>Now that we've gone through all the topics we covered during this journey, let's examine the importance of these topics from the practical part of this book in terms of application security and computer security in general.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor110"/>Managing vulnerabilities and security flaws</h2>
			<p>To really put what we've <a id="_idIndexMarker411"/>been talking about into perspective, we need to focus on the <a id="_idIndexMarker412"/>entire life cycle of security issues and vulnerabilities in a complex environment, such as companies or large enterprises.</p>
			<p>Part of the job of some security professionals is finding vulnerabilities and security flaws that are present in the network infrastructure, including assets – such as servers or workstations – or, more specifically, in applications. The most common way to identify security issues is by performing vulnerability assessments, which analyze target systems to find out if there are any known security issues, for example, in the system configuration itself, due to any missing security updates, or by using various tools and techniques. A significant part of these activities is testing for such issues in order to verify if such vulnerabilities can really be exploited by possible malicious agents.</p>
			<p>What we experienced in <a href="B15632_04_Final_JC_ePub.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Attacking Web, Mobile, and IoT Applications</em>, was mimicking exactly the work of a security professional in charge of identifying security flaws – in this case, applications – by assessing the actual degree to which they could be exploited, thereby correctly evaluating their impact. Of course, we focused on SQL injection, but since there are many other vulnerabilities, such work can be quite complex – but also thrilling and, in some cases, simply fun. This provides you with new challenges and ways to wrap your head around different puzzles.</p>
			<p>Security testing and discovering security issues is, obviously, about putting remediation plans that can effectively fix those issues into practice. <a href="B15632_05_Final_JC_ePub.xhtml#_idTextAnchor085"><em class="italic">Chapter 5</em></a>, <em class="italic">Preventing SQL Injection with Defensive Solutions</em>, helped us find out what can be done to remediate a SQL injection vulnerability. Depending on the context, and possibly effort and time constraints, an effective vulnerability remediation plan can be optimized by applying the most effective remediations in order to provide the greatest level of security possible with the smallest amount of action. </p>
			<p>Security professionals need, in this case, to know what the most effective responses are by considering the context in which these issues are found, and to ensure the impact of such actions is acceptable for organizations. While, in most cases, security professionals won't have to actually implement the solutions themselves, they need to know what they are about so that they can instruct the tech staff to apply those changes to the infrastructure and/or systems that are impacted.</p>
			<p>In its practical sections, this book was meant to give you, with a particular focus on SQL injection, a small sample of the most practical aspects of dealing with a vulnerability – from the discovery part, through testing to assess how far damage could extend, to the actual remediation of it, through exploring various countermeasures that could be taken. This provided us with specific examples, especially when it came to dealing with common programming languages.</p>
			<p>This way, we can consider, by extending the path we followed in this specific case, the full life cycle of a security issue. First, the vulnerability is discovered—usually in an automated way, as we also saw in the case of SQL injection with the use of the Scanner module of OWASP ZAP. A single scan, of course, will probably identify a considerable quantity of issues, which need to be evaluated one by one in the following phase. </p>
			<p>In the second step, in fact, such<a id="_idIndexMarker413"/> a vulnerability is tested—alongside many others—in <a id="_idIndexMarker414"/>order to assess if the result of the automated analysis is a false positive and to see the actual impact of such an issue. By following our tutorial in <a href="B15632_04_Final_JC_ePub.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Attacking Web, Mobile, and IoT Applications</em>, we did exactly that: we knew such applications were vulnerable to SQL injection, but we studied the vulnerabilities to see what the issue could lead to. </p>
			<p>It can happen, in fact, that an application is indeed vulnerable, but exploiting the vulnerability could lead to minor consequences – changes, in this case, that could have an impact that is much lower than a SQL injection vulnerability but could lead to the full compromise of an application. The degree of exploitability of a SQL injection attack may depend on the countermeasures present, which, even if not all simultaneously present, can hinder, even partially, the work of an attacker.</p>
			<p>Finally, after the vulnerability has been tested, countermeasures can be considered, all while keeping in mind the presence of any possible defense mechanism that is already present. This requires precise knowledge of the security issue at hand. This is why, for SQL injection, we showed the most relevant countermeasures that can be taken to secure an application against this specific vulnerability. An expert security professional can tell, by the behavior of the application, which countermeasure has been applied, thus better advising about possible countermeasures. </p>
			<p>Suggested defenses occur in the formulation of a remediation plan, which is meant to instruct technicians about which defenses to apply. At this point, with such a plan, it is possible to decide if the risk linked to the security issue can be remediated through the implementation of the proper defense mechanisms. Alternatively, such a risk could also be accepted, depending<a id="_idIndexMarker415"/> on its criticality, so we don't have to apply a<a id="_idIndexMarker416"/> countermeasure that could be, for example, too demanding in terms of operational trade-offs (for example, applying a security mechanism would require critical servers to stay offline for a longer period than is tolerable for organizations). </p>
			<p>Cyber security is a subject that is always evolving and requires professionals to always stay up to date with respect to threats, vulnerabilities, and risks. With this practical section, we hope we have given you a taste of what is like to be a professional in this interesting area. Now, let's wrap everything up by considering our main issue once again.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor111"/>SQL injection and security implications – final comments</h1>
			<p>Now that we've explored SQL injection through this book, we can talk about SQL injection and security issues in today's world, all while considering the implications in terms of security in the World Wide Web and the repercussions in the real world.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor112"/>SQL injection in today's world</h2>
			<p>SQL injection is <a id="_idIndexMarker417"/>indeed an old and well-known vulnerability and, as such, it is usually taken into consideration when developing or releasing new applications, especially in the World Wide Web as web applications. Most basic attacks are usually ineffective due to the fact that most common countermeasures are usually applied to the vast majority of cases, and many web frameworks with built-in controls are often used. However, it may happen that vulnerable applications still exist, often due to bugs and oversights in the source code, or some other unforeseen condition.</p>
			<p>According to OWASP, as mentioned in the latest<a id="_idIndexMarker418"/> version of the <strong class="bold">OWASP Top Ten Web Application Security Risks</strong> (2017), injection is the top risk factor for web applications due to the consequences – which we looked at throughout this book – of it being exploited. SQL injection is, of course, part of this category as it is still one of the most common ways in which malicious users can interact with the inner logic of applications by inserting arbitrary commands, thus exploiting the expressive power of the SQL language. </p>
			<p>SQL and NoSQL injection is, in fact, commonly reported as the first example of this category: it is definitely one of the most common attack techniques malicious users tend to try against web applications, given the advantage it could provide, both from a strategic perspective and from the standpoint of sheer impact of operations. Despite how infamous it is, many attacks based on it still occur.</p>
			<p>Recent examples have also made their way to the news. In 2014, it was reported that cyber-crime operations – attributed <a id="_idIndexMarker419"/>to Russian cyber-crime groups – obtained 1.2 billion username and password pairs through various SQL injection attacks (source: <em class="italic">The New York Times</em>, August 5th 2014, <a href="https://www.nytimes.com/2014/08/06/technology/russian-gang-said-to-amass-more-than-a-billion-stolen-internet-credentials.html?_r=0">https://www.nytimes.com/2014/08/06/technology/russian-gang-said-to-amass-more-than-a-billion-stolen-internet-credentials.html?_r=0</a>). </p>
			<p>More recently, a Bug Bounty Hunter – a security professional that looks for vulnerabilities online within specific programs with the consent of the owners, who can award money in the case of a success – found a SQL injection vulnerability that lead to an accounting database belonging to Starbucks (source: The Daily Swig – Portswigger's news blog – September 2019, <a href="https://portswigger.net/daily-swig/sql-injection-flaw-opened-doorway-to-starbucks-accounting-database">https://portswigger.net/daily-swig/sql-injection-flaw-opened-doorway-to-starbucks-accounting-database</a>). Despite accessing the vulnerability required – in this case, a more complex attack exploiting other weaknesses of an application – this demonstrates that SQL injection is still an issue today and can still represent a high security risk, possibly exposing critical information.</p>
			<p>Other issues connected to SQL injection can always be present as bugs in frameworks and software. It happens now and then that some new vulnerabilities affecting software are used for building web applications that, if properly exploited, usually through complex and unusual attack techniques, could lead to SQL injection in the applications that use them; that is, if no further countermeasures are applied. These vulnerabilities are usually patched when they're discovered, so it's imperative, if external software components are used, that they are always up to date with the most recent version available.</p>
			<p>With this, we have seen how SQL injection, despite being a dated vulnerability, is still relevant today, underlining once again the importance of applying security measures against it. Malicious agents and cyber criminals will always attempt SQL injection against web applications, so it is best to be prepared for it by putting all the defense mechanisms you know into practice.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor113"/>Beyond SQL injection</h2>
			<p>While SQL injection is still one of the most common attack techniques attempted by whoever wants to compromise an application, it's definitely not the only security risk in the realm of web application security.</p>
			<h3>The OWASP Top 10 Web Application Security Risks</h3>
			<p>We already mentioned the<a id="_idIndexMarker420"/> OWASP Top Ten Web Application Security Risks, but let's provide a general overview of it. It contains the most relevant web application security risks, sorted by risk level. The list gets updated on a non-regular basis. The most recent chart is dated 2017, but a 2020 version is currently in the making.</p>
			<p>Here is the full OWASP TOP 10 for Web Application Security Risks, alongside a brief description:</p>
			<ul>
				<li><strong class="bold">Injection</strong>: Injection means inserting untrusted data to be interpreted as part of a query or, more generally, a command. This includes SQL injection, NoSQL injection, and OS command injection.</li>
				<li><strong class="bold">Broken authentication</strong>: Authentication and user session management are implemented incorrectly, allowing attackers to compromise applications by gaining higher privileges than intended or stealing user identities.</li>
				<li><strong class="bold">Sensitive data exposure</strong>: Sensitive data, such as financial, healthcare, and personal information can be leaked by the application, for example, through error messages or accessible<a id="_idIndexMarker421"/> resources. This exposes such data to fraud, identity theft, or other crimes. </li>
				<li><strong class="bold">XML External Entities (XXE)</strong>: Arbitrary external entity references in XML documents, if evaluated, can be used to disclose internal files, sensitive information, and possibly allow remote code execution and denial of service.</li>
				<li><strong class="bold">Broken access control</strong>: Restrictions on user permissions (that is, what specific users can do in an application) are not enforced correctly. This can allow users to perform actions that should be restricted only to administrators or higher privileges.</li>
				<li><strong class="bold">Security misconfiguration</strong>: The application and/or system that users reside on is not properly configured in terms of security. This includes insecure default configurations, incomplete or ad hoc configurations, and unnecessary error messages.</li>
				<li><strong class="bold">Cross-Site Scripting (XSS)</strong>: XSS allows attackers to execute client-side scripts – usually JavaScript – by inserting them into the victim's browser, which can compromise user sessions or trick the user into visiting dangerous websites.</li>
				<li><strong class="bold">Insecure deserialization</strong>: Input is not processed correctly and can be accepted as it is by the application, thus possibly resulting in remote code execution or injection attacks.</li>
				<li><strong class="bold">Using components with known vulnerabilities</strong>: External components with known vulnerabilities can expose the application to various attacks, depending on the<a id="_idIndexMarker422"/> vulnerability. Such components need to have the most recent security updates applied.</li>
				<li><strong class="bold">Insufficient logging and monitoring</strong>: Insufficient logging and monitoring means that possible malicious actions are not properly tracked by the targeted systems and applications, thus hindering any possible investigation.</li>
			</ul>
			<p>As you can see, SQL injection, while being one of the most important vulnerability typologies, is just the tip of the iceberg. This list is just meant to show you in how many ways a web application can be attacked by security weaknesses being exploited.</p>
			<p>In a context like this, the role of security professionals in helping keep applications and services protected and secure is obvious. Whenever a security issue is identified, it is best to proceed by mitigating or resolving it as soon as possible. Also, by reading the top 10 list, you probably noticed how some risks can be linked to other ones. For example, insecure deserialization can lead to, among other things, injection due to the insecure treatment of user input, while XSS can be the result of a missing input validation, which could also lead to SQL injection. XSS itself is actually a form of injection (in the case of client-side scripting code such as JavaScript). Due to the interconnection of these risks and depending on the context they're examined in, a proper analysis that's lead by a security professional can help optimize the process of mitigating such risks. Here, they choose to prioritize the most critical issues first in order to minimize the possible resulting impact.</p>
			<p>The OWASP Top Ten for Web Application Security Risks further confirms SQL injection as one of the most critical security issues for web applications. This leads, once again, to the mission of this book: to deal with SQL injection, which is one of the most prominent risks in terms of security. It acts as an ideal entry point to the much complex and comprehensive world of web application security, which itself is part of the larger branch of computer security, most commonly known an information security or cyber security.</p>
			<h3>Further exploring information security</h3>
			<p>Exploring application security<a id="_idIndexMarker423"/> in more depth is, of course, a thrilling path as it can allow us, through test environments such as the one we set up for the practical section of this book, to always meet new challenges and put both intuition and technical skills to practice. This can put you in the place of some sort of a detective, or a doctor trying to perform a correct diagnosis. This can be especially fruitful for people with some experience in application development that wish to approach already known issues from a security perspective.</p>
			<p>In general, security professionals can be required to act more at an infrastructural level. The approach is similar to web application security as in this case, you can find vulnerabilities on target systems, this time at the system level. This can require precise knowledge of how OSes work, or even protocols and services running on servers and workstations alike. Exploitation can also be quite challenging due to the necessity of interacting directly at the system level, without the chance of using a user-friendly interface, as you would for web application security assessment.</p>
			<p>The ultimate goal of cyber security is to provide additional layers of security for computers and enterprise systems. This can also result in the adoption of targeted security solutions, which can help organizations and individuals bolster their security posture. This way, an expert in security can suggest the best possible security solutions when considering the starting context.</p>
			<p>Information security is, in any case, one of the most discussed topics nowadays. In the last few years, governments and supranational entities around the world have started to discipline aspects of information security through many legislative efforts. This is especially relevant when thinking about the concept of cyber war, in which even state-sponsored cyber attacks can be carried out against organizations and entities worldwide. It is of the utmost important to guarantee that security is properly addressed while considering the risks organizations and, consequently, states can face if they are not properly prepared for the risks linked to computer security. </p>
			<p>Every day, information security in some way or another always reaches the headlines of newspapers and news around the world: this is just a symptom of how much <strong class="bold">information technology</strong> (<strong class="bold">IT</strong>) has become central to our society. Consequently, its security has become extremely relevant since protecting IT means protecting the real world. This statement always make more sense as time goes by since technology is entwined with our lives and permeates into everything we do in our daily lives.</p>
			<p>Even if you are not specifically<a id="_idIndexMarker424"/> interested in information security, it is advised that you are kept aware of how important it is as it will always encompass our lives, especially in the future. We hope this book has inspired you to further explore the topic of information security. After all, you have seen the possible consequences of SQL injection for yourself.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor114"/>Summary</h1>
			<p>Here we are, at the end of this journey. After dealing with all the topics we've faced, but this time in a more synthetic fashion, you grasped some topics regarding information security and saw how even SQL injection, which you have hopefully mastered as a topic, can be relevant to the real world.</p>
			<p>Now that you've reached the end of this book, feel free to explore information security topics in general or keep practicing in controlled environments. Our hope is that this experience sparked curiosity in you, thus inviting you to look at security topics in more detail.</p>
			<p>We wish to thank you for reading this book and hope that you also had fun in the process. Feel free to use your emulated environment as you please to test for SQL injection. You can even use the applications from the OWASP BWA project to learn about other security issues. We recommend that you begin by exploring all that Mutillidae II has to offer by going through all the suggestions and guides provided. This will give you a taste of the main web application security risks.</p>
			<p>Now that you've mastered SQL injection, we hope you can use what you've learned for good, without causing any harm to anybody, especially considering the possible consequences your actions may bring. </p>
			<p>You know what they say: <em class="italic">with great power comes great responsibility</em>. Keep this in mind now that you've mastered SQL injection.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor115"/>Questions</h1>
			<ol>
				<li>What are security flaws, including SQL injection, usually caused by?</li>
				<li>What is the job of a security professional in testing for vulnerabilities?</li>
				<li>Describe the three main phases of security assessment that we identified in this book, excluding the implementation of defense mechanisms.</li>
				<li>Do you think SQL injection, being an old vulnerability, is not a real issue anymore?</li>
				<li>Which position is SQL injection in the OWASP Top 10 Web Application Security Risks list?</li>
			</ol>
		</div>
	</body></html>