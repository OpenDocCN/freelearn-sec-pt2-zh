<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer077">
<h1 id="_idParaDest-51"><em class="italic"><a id="_idTextAnchor050"/>Chapter 3</em>: Sniffing and Spoofing</h1>
<p>During the 1970s, the United States conducted a daring <strong class="bold">Signals Intelligence</strong> (<strong class="bold">SIGINT</strong>) operation against the Soviet Union called Operation Ivy Bells in the Sea of Okhotsk. Whereas any other message with a reasonable expectation of being intercepted would have been encrypted, some key communications under the Sea of Okhotsk took place in plaintext. Using a device that captured signals moving through the cable via electromagnetic induction, United States intelligence was able to retrieve sensitive military communication from hundreds of feet below the surface of the sea. It was a powerful demonstration of <em class="italic">sniffing</em> – the ability to capture and analyze data moving through a communications channel.</p>
<p>Decades earlier, the Allies were preparing to liberate Nazi-occupied Western Europe in the 1944 Battle of Normandy. A critical component of success was catching the Germans unprepared, but they knew an invasion was imminent; so, a massive deception campaign called Operation Fortitude was employed. Part of this deception operation was convincing the Germans that an invasion would take place in Norway (Fortitude North) by generating fake radio traffic in Operation Skye. The generated traffic was a perfect simulation of the radio signature of army units coordinating their movements and plans for attack. The strategy was deployed, and its ingenious attention to detail is a powerful demonstration of <em class="italic">spoofing</em> – false traffic intended to mislead the receiver. </p>
<p>Our discussion in this chapter will be in the context of modern computer networks and your consideration of these concepts as a pentester, but these historical examples should help illuminate the theory behind the technical details. For now, let’s demonstrate some hands-on examples of sniffing and spoofing for a pentester armed with Kali Linux.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Advanced Wireshark statistical analysis and filtering to find the individual bits we need on a network</li>
<li>Targeting WLANs with the Aircrack-ng suite</li>
<li>Advanced Ettercap to build a stealthy eavesdropping access point</li>
<li>Ettercap packet filters to analyze, drop, and manipulate traffic in transit through our access point</li>
<li>Getting better with BetterCAP fundamentals</li>
</ul>
<h1 id="_idParaDest-52"><a id="_idTextAnchor051"/>Technical requirements</h1>
<p>To get started, you will need to have the following:</p>
<ul>
<li>A laptop running Kali Linux</li>
<li>A wireless card that can be run as an access point</li>
<li>Basic Wireshark knowledge</li>
</ul>
<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Advanced Wireshark – going beyond simple captures</h1>
<p>I assume you’ve had some experience with Wireshark (formerly known as Ethereal) by now. Even if you’re new to pen<a id="_idIndexMarker179"/> testing, it’s hard to avoid Wireshark in lab environments. If you aren’t familiar with this fantastic packet analyzer, you’ll no doubt be familiar with packet analyzers in general. A sniffer is a great challenge for anyone learning how to code.</p>
<p>So, I won’t be covering the basics of Wireshark. We are all familiar with packet analyzers as a concept; we know about Wireshark’s color-coded protocol analysis and so on. We’re going to take Wireshark beyond theory and ordinary capture, and apply it to some practical examples. We’ll look at passive wireless analysis with Wireshark, and we’ll learn how to use Wireshark as our sidekick when we use our attack tools.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Passive wireless analysis</h2>
<p>So far, we’ve been studying layer 2 and above. The magical world of layer 1 – the physical layer – is a subject<a id="_idIndexMarker180"/> for another (very thick) book, but<a id="_idIndexMarker181"/> in today’s world, we can’t talk about the physical means of accessing networks without playing around with wireless. </p>
<p>There are two core strategies in sniffing attacks: <em class="italic">passive</em> and <em class="italic">active</em>. A passive<a id="_idIndexMarker182"/> sniffing attack is also<a id="_idIndexMarker183"/> commonly referred to as <em class="italic">stealthy</em> as it can’t be detected by the target. We’re going to take a look at passive wireless reconnaissance – which is just a fancy way of saying <em class="italic">listening to the radio</em>. When you tune into your favorite station on your car’s FM radio, the radio station has no way of knowing that you have started listening. Passive wireless reconnaissance is the same concept, except we’re going to record the radio show so that we can analyze it in detail later. </p>
<p>To pull this off, we need<a id="_idIndexMarker184"/> the right hardware. A wireless card has to be willing to record<a id="_idIndexMarker185"/> everything it can see and pass it along to the operating system. This is known as <strong class="bold">monitor mode</strong> and not all wireless cards support it. My card of choice<a id="_idIndexMarker186"/> is an Alfa AWUS036NEH, but a little research online will help you find an ideal device.</p>
<p>We’ll use <strong class="source-inline">iwconfig</strong> to enable monitor mode and confirm its status after bringing the device up:</p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<img alt="Figure 3.1 – Using iwconfig to enable monitor mode " height="465" src="image/Figure_3.01_B17616.jpg" width="1110"/>
</div>
</div>
<p class="figure-caption">Figure 3.1 – Using iwconfig to enable monitor mode</p>
<p>Note the use of both configuration utilities: <strong class="source-inline">ifconfig</strong> and <strong class="source-inline">iwconfig</strong>. Don’t mix up their names!</p>
<p>When we run the last command, we can confirm that monitor mode is enabled. If you check the RX packet count, you’ll see it’s already rapidly climbing (depending on how busy your RF surroundings are) – it’s receiving packets, even though you are not associated with an access point. This is what makes this type of analysis stealthy – no devices that are merely listening are detected.  </p>
<p>It’s important to note that true stealth requires that your device is <em class="italic">not</em> sending any data. Sometimes, we intend to simply listen, so assume we’re being stealthy, but if the card is announcing its presence in some way, it isn’t passive. When you’re good at analyzing your environment, use your skills to check your stealth! </p>
<p>Now, we’ll fire up Wireshark<a id="_idIndexMarker187"/> and select the interface we specified<a id="_idIndexMarker188"/> previously – in this example, <strong class="source-inline">wlan0</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<img alt="Figure 3.2 – Raw wireless capture with Wireshark " height="687" src="image/Figure_3.02_B17616.jpg" width="1195"/>
</div>
</div>
<p class="figure-caption">Figure 3.2 – Raw wireless capture with Wireshark</p>
<p>Whoa, okay – hold on a second. The screen just lit up at a pace of 27 packets per second, and this is a relatively quiet environment. (Fire this up in an apartment building and enjoy the fun.) Don’t get me wrong – I’m a data hound and this number of packets excites me – but we need to find out what’s happening in this environment so that we can tune in on the good stuff. We’ll revisit the high-altitude view of a wireless environment with Wireshark in the next section.</p>
<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Targeting WLANs with the Aircrack-ng suite</h2>
<p>No discussion on wireless<a id="_idIndexMarker189"/> attacks is adequate without<a id="_idIndexMarker190"/> the Aircrack-ng suite. Though the name<a id="_idIndexMarker191"/> implies it’s just a password cracker, it’s a fully-featured wireless attack suite. In our example, we’re going to take a look at the wireless sniffer with the <strong class="source-inline">airodump-ng wlan0</strong> command. Here’s the output: </p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<img alt="Figure 3.3 – airodump-ng output " height="789" src="image/Figure_3.03_B17616.jpg" width="1569"/>
</div>
</div>
<p class="figure-caption">Figure 3.3 – airodump-ng output</p>
<p>This is the same task, but this tool can organize the wireless environment and the identities of all participating devices. An especially useful column is <strong class="source-inline">#Data</strong>, which tells us how many observed packets contain network data. This is handy because as we saw when watching the raw<a id="_idIndexMarker192"/> environment, there are a lot of packets that are for wireless management. It’s easy enough to sort packets in Wireshark, but now, we’re getting a tidy list of networks, the MAC addresses of the clients and access points (BSSIDs), and an idea of how busy they are.</p>
<p>The <strong class="source-inline">ENC</strong> column tells us what encryption method – if any – is in use for the listed network. <strong class="source-inline">OPN</strong> means there is no encryption. This is unusual these days, but in this example, the open network is a guest network. It’s been left open on purpose to allow easy access, but clients will be dropped into a captive portal environment once they’ve been associated. You’ll recall from <a href="B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Bypassing Network Access Control</em> that we worked to intercept authentication to the captive portal from the network layer by attacking the data link layer. But in this case, we’re sitting in radio range and the packets aren’t encrypted. We should be able to intercept anything that isn’t protected with some tunneling method (for instance, HTTPS) by merely listening – no injection required, and with a zero detectable footprint. So, how do we leverage the information here to sift through the wilderness captured in monitor mode? Let’s target the guest network by filtering on the access point’s MAC address (the BSSID): <strong class="source-inline">40:16:7E:59:A7:A0</strong>. </p>
<p>As you know, the 2.4 GHz band for 802.11 communication is split into channels. Airodump-ng will hop these channels by default – jump from one channel to the next, rapidly, listening for data on whatever channel it’s on at the moment. As you can imagine, if a juicy packet is being<a id="_idIndexMarker193"/> transmitted on channel 1 while<a id="_idIndexMarker194"/> Airodump-ng is listening on channel 4, you’ll miss it. So, when you know your target, you need to tell Airodump-ng to focus. In our<a id="_idIndexMarker195"/> example, the open network is on <strong class="source-inline">channel 1</strong>. We use <strong class="source-inline">--channel</strong> to specify our listening frequency, and we use <strong class="source-inline">--bssid</strong> to filter out our target access point by MAC address. We’ll use <strong class="source-inline">--output-format</strong> to specify a <strong class="source-inline">.pcap</strong> file (any packet analyzer can work with this output format):</p>
<p class="source-code"># airodump-ng -w test_capture --output-format pcap --bssid 40:16:7e:59:a7:a0 --channel 11 wlan0</p>
<p>While we watch the metadata on our screen, our test file is being written. We can let this run as long as we like; then, we must hit <em class="italic">Ctrl</em> + <em class="italic">C</em> and import it into Wireshark:</p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<img alt="Figure 3.4 – Opening our test capture file in Wireshark " height="175" src="image/Figure_3.04_B17616.jpg" width="882"/>
</div>
</div>
<p class="figure-caption">Figure 3.4 – Opening our test capture file in Wireshark</p>
<p>Without sending any data whatsoever, we’ve already discovered a legit IP address (<strong class="source-inline">192.168.80.80</strong>), and we can watch the DNS queries being sent by this host. We have a decent start on our reconnaissance phase for this particular network, and we haven’t even sent any packets. </p>
<p class="callout-heading">We’re Living in a 5 GHz World</p>
<p class="callout">Though 2.4 GHz remains dominant, there are more and more 5 GHz devices out there and you might need to sniff those out. A newer wireless card should support it. When you’re working with airodump-ng, use the <strong class="source-inline">band</strong> flag and set it to <strong class="source-inline">abg</strong>, which will enable 5 GHz.</p>
<p>Now that we have some experience with raw wireless sniffing, let’s check out Wireshark’s built-in analysis features.</p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>WLAN analysis with Wireshark</h2>
<p>Let’s review using Wireshark<a id="_idIndexMarker196"/> to interpret a wireless environment. We disabled<a id="_idIndexMarker197"/> channel hopping in the previous section so that we could focus on a target, but now, let’s try to capture as much as possible and let Wireshark do the explaining. With a wireless capture open, click <strong class="bold">Wireless</strong> | <strong class="bold">WLAN Traffic</strong>. The resulting window is <strong class="bold">Wireshark - Wireless LAN Statistics - test_wifi_capture-01</strong> with sortable columns. I’m interested in finding the busiest networks, so I have sorted by <strong class="bold">Percent Packets</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<img alt="Figure 3.5 – Wireless LAN statistics in Wireshark " height="570" src="image/Figure_3.05_B17616.jpg" width="929"/>
</div>
</div>
<p class="figure-caption">Figure 3.5 – Wireless LAN statistics in Wireshark</p>
<p>By expanding <strong class="bold">BSSID</strong> on the left, we can see nested BSSIDs: the parent is the access point, while the nested devices are associated<a id="_idIndexMarker198"/> clients. Right-click on a target and click <strong class="bold">Apply as Filter</strong> | <strong class="bold">Selected</strong>. Close the statistics box to return to Wireshark’s main window. The display filter text<a id="_idIndexMarker199"/> box will be populated with our chosen filter. Apply the filter and enjoy the time you’ve saved digging through packets:</p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<img alt="Figure 3.6 – Filtering by BSSID " height="217" src="image/Figure_3.06_B17616.jpg" width="1176"/>
</div>
</div>
<p class="figure-caption">Figure 3.6 – Filtering by BSSID</p>
<p>Let’s get back to the network layer and see what Wireshark can do for us once we’ve established a presence on the LAN. I’ve been sniffing for a few minutes on a network with several actively browsing clients. In a short time, I have a juicy amount of data to analyze.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Active network analysis with Wireshark</h2>
<p>As we can expect in today’s world of casual web browsing, almost all traffic is TLS-encrypted. It’s hard to even<a id="_idIndexMarker200"/> read the news or search for a dictionary definition<a id="_idIndexMarker201"/> without passing through a tunnel. Sniffing isn’t what it used to be in the old days when sitting on a LAN in promiscuous mode was everything you needed to intercept full HTTP sessions. So, our goal here is to apply some statistical analysis and filtering to learn more about the captured data and infer relationships.</p>
<p>In the previous section, we looked at WLAN statistics. Now that we’re established on the network, we can get much more granular with protocol and service-level analysis.</p>
<p>Let’s learn a little more about everyone chatting on the network. In Wireshark parlance, we call all the individual devices endpoints. Every IP address is considered an endpoint, and endpoints have conversations with each other. Let’s select <strong class="bold">Endpoints</strong> from the <strong class="bold">Statistics</strong> menu. </p>
<p>I’m interested in the endpoint with an ASN belonging to the <strong class="bold">Orange</strong> network in France. I can right-click to apply a filter based on this particular endpoint:</p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<img alt="Figure 3.7 – Filtering endpoints " height="495" src="image/Figure_3.07_B17616.jpg" width="892"/>
</div>
</div>
<p class="figure-caption">Figure 3.7 – Filtering endpoints</p>
<p>Now, I’m going to review just<a id="_idIndexMarker202"/> the HTTP 200 responses from this particular<a id="_idIndexMarker203"/> endpoint. I will use this filter and apply it:</p>
<pre class="source-code">ip.addr==81.52.133.24 and http contains 200</pre>
<p>I’ve narrowed down five packets of interest out of the 33,644 that we captured. At this point, I can right-click any packet to create a filter for that particular TCP session, allowing me to follow the HTTP conversation in an easy-to-read format:</p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<img alt="Figure 3.8 – Reviewing the filtered packets " height="532" src="image/Figure_3.08_B17616.jpg" width="848"/>
</div>
</div>
<p class="figure-caption">Figure 3.8 – Reviewing the filtered packets</p>
<p>So, what’s going on with this display filter? The syntax should be familiar to coders. You start with a layer and specify subcategories separated by a period. In our example, we started with <strong class="source-inline">ip</strong> and then specified<a id="_idIndexMarker204"/> the IP address with <strong class="source-inline">addr</strong>. The address subcategory is an option for other layers; for example, <strong class="source-inline">eth.addr</strong> would be used to specify a MAC address. Wireshark display filters are extremely powerful, and we simply don’t have enough pages to dive in, but you can easily build filters from scratch by reviewing packets manually and honing in on the data you need. For example, we were just filtering out packets from the endpoint that belongs to the AS5511 network in France. Could I filter any packets from France?</p>
<pre class="source-code">ip.geoip.src_country==France</pre>
<p>Let’s take GeoIP a step further by looking for any TCP ACK packets going to <strong class="source-inline">Mountain View</strong>, California:</p>
<pre class="source-code">ip.geoip.dst_city=="Mountain View, CA" and tcp.flags.ack==1</pre>
<p>Let’s look for any SSL-encrypted alerts where the TCP window scale factor is set to <strong class="source-inline">128</strong>:</p>
<pre class="source-code">ssl.alert_message and tcp.window_size_scalefactor==128</pre>
<p>I know what the hacker in you is saying: <em class="italic">we can build out Wireshark display filters to fingerprint operating systems just like p0f</em>. Very good, I’m so proud! How about we look for packets that are not destined<a id="_idIndexMarker205"/> for HTTPS while matching a Linux TCP signature<a id="_idIndexMarker206"/> and layer 2 destined for the gateway (in other words, leaving the network, so we’re fingerprinting local hosts)? </p>
<pre class="source-code">ip.ttl==64 and tcp.len==0 and tcp.window_size_scalefactor==128 and eth.dst==00:aa:2a:e8:33:7a and not tcp.dstport==443</pre>
<p>I warned you that this would get fun.</p>
<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Advanced Ettercap – the man-in-the-middle Swiss Army Knife</h1>
<p>In the previous chapter, we fooled around with ARP poisoning in Ettercap. I’m like every other normal person: I love a good ARP spoof. However, it’s infamously noisy. It just screams, HEY! I’M A BAD GUY, SEND ME ALL THE DATA! Did you fire up Wireshark during the attack? Even Wireshark<a id="_idIndexMarker207"/> knows that something is wrong and warns the analyst that <em class="italic">duplicate use has been detected!</em> It’s the nature of the beast when<a id="_idIndexMarker208"/> we’re convincing the network to send everything to a single interface – what is called unified sniffing.</p>
<p>Now, we’re going to take man-in-the-middle to the next level with bridged sniffing, which is bridging together<a id="_idIndexMarker209"/> two interfaces on our Kali box and conducting our operations between the two interfaces. Those interfaces are local to us and bridged together, all on the fly, by Ettercap; in other words, a user won’t see anything amiss. We aren’t telling the network to do anything funky. If we can place ourselves in a privileged position between two endpoints pointing at an interface on either side of our host, the network will look normal to the endpoints. Back in my day, we had to manually set up the bridge to pull off this kind of thing, but now, Ettercap is kind enough to take care of everything for us. </p>
<p>The first (and obvious) question is, how do we place ourselves in such a position? There are many scenarios to consider and covering them all would be beyond the scope of this book. For our purposes, we’re going to set up a malicious access point by building on our Host AP Daemon knowledge from <a href="B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Bypassing Network Access Control</em>. </p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Bridged sniffing and the malicious access point</h2>
<p>In <a href="B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Bypassing Network Access Control</em>, we built an access point to serve as a backdoor into a network. This access point<a id="_idIndexMarker210"/> provided us with DHCP, DNS, and NAT to get us out of the <strong class="source-inline">eth0</strong> interface<a id="_idIndexMarker211"/> attached to the inside network. The attached client was not a victim; it was the attacker on the outside of the building. This time, we’re creating<a id="_idIndexMarker212"/> an access point, but it’s intended for our target(s) to connect to it. The access<a id="_idIndexMarker213"/> point will grant them some kind of wanted network access, and the destination network will handle them like normal – in fact, we’re going to let the destination network handle DHCP and DNS, so don’t even bother with <strong class="source-inline">dnsmasq</strong> this time. The idea is that we’re essentially invisible: aside from providing an access point, we offer no network services. What we will be doing is sniffing everything that passes through our bridge. </p>
<p>These principles can be applied to any bridged sniffing scenario, so I encourage you to let your hacking imagination run wild with the possibilities. For our demonstration, we’re firing up the timeless classic <em class="italic">Free Wi-Fi</em> attack. The idea is simple: offer free internet and let the fish<a id="_idIndexMarker214"/> come to you. This attack has potential in legitimate pen tests; attacking your client’s users can be difficult in secure networks and setting up free Wi-Fi in a corporate environment is surprisingly effective. (Wouldn’t you like the opportunity<a id="_idIndexMarker215"/> to bypass your company’s web filters?) Another possibility is the <em class="italic">evil twin</em> concept, where you’re masquerading as a legitimate ESSID, or even the ESSID of a lonely wireless device’s probes, looking for a familiar face in a strange place. (Check out Fluxion if you want to dive deeper into Wi-Fi MitM attacks). Again, I leave the rest to your imagination.</p>
<p class="callout-heading">Don’t Forget to Open Your WLAN!</p>
<p class="callout">If you’re following along from the previous example with <strong class="source-inline">hostapd</strong>, your configuration file is probably still specifying a WPA-protected network! Make sure you open that up again with nano and remove the lines about WPA encryption. Don’t forget to change your SSID to something like <strong class="source-inline">Free Wi-Fi</strong> as well.</p>
<p>First, I must set<a id="_idIndexMarker216"/> up my access point. If you’re following the <strong class="source-inline">hostapd</strong> example from <a href="B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, <em class="italic">Bypassing Network Access Control</em>, note the differences here – I don’t need <strong class="source-inline">dnsmasq</strong> and I don’t need <strong class="source-inline">iptables</strong>, so I’ll use <strong class="source-inline">ifconfig</strong> and <strong class="source-inline">grep</strong> to quickly<a id="_idIndexMarker217"/> confirm the subnet of our Ethernet interface’s existing<a id="_idIndexMarker218"/> connection, set up forwarding, and prepare the wireless<a id="_idIndexMarker219"/> interface for hosting:</p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<img alt="Figure 3.9 – Configuring bridged sniffing with hostapd " height="1025" src="image/Figure_3.09_B17616.jpg" width="1212"/>
</div>
</div>
<p class="figure-caption">Figure 3.9 – Configuring bridged sniffing with hostapd</p>
<p>I gave the wireless interface an IP assignment<a id="_idIndexMarker220"/> in the Ethernet interface’s network. By running <strong class="source-inline">ifconfig</strong> and piping the output<a id="_idIndexMarker221"/> into <strong class="source-inline">grep</strong> so that it matches <strong class="source-inline">inet</strong>, we can confirm the assigned IP address, so I’ll just pick another one in that same subnet. I also ran <strong class="source-inline">airmon-ng check kill</strong> to ensure that any wireless networking utilities are killed, as they will prevent <strong class="source-inline">hostapd</strong> from doing its thing.</p>
<p>We used the graphical<a id="_idIndexMarker222"/> interface last time; I’m going to keep it clean and just fire<a id="_idIndexMarker223"/> off this command in a new terminal window:</p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<img alt="Figure 3.10 – Firing off the bridge with Ettercap " height="465" src="image/Figure_3.10_B17616.jpg" width="939"/>
</div>
</div>
<p class="figure-caption">Figure 3.10 – Firing off the bridge with Ettercap</p>
<p>This command is easy thanks to Ettercap’s behind-the-scenes power to manage the bridge and sniffing:</p>
<ul>
<li><strong class="source-inline">-T</strong> tells Ettercap to go <em class="italic">old school</em> and use a text-only interface.</li>
<li><strong class="source-inline">-q</strong> means <em class="italic">be quiet</em>. We don’t want Ettercap reporting every packet to our interface; that’s what our capture file is for. We are analyzing later, not now. Let’s just let it run.</li>
<li><strong class="source-inline">-B</strong> starts up <em class="italic">bridged sniffing</em>. Remember, we need two interfaces (in our example, <strong class="source-inline">eth0</strong> and <strong class="source-inline">wlan0</strong>), so I run this flag twice for each interface. </li>
<li><strong class="source-inline">-w</strong> will write the packets to a <strong class="source-inline">.pcap</strong> file for later analysis in Wireshark.</li>
</ul>
<p>Then, we must apply<a id="_idIndexMarker224"/> ordinary Wireshark analysis. With this privileged position, we can<a id="_idIndexMarker225"/> proceed to more advanced attacks:</p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<img alt="Figure 3.11 – The Conversation view of our bridged sniffing capture file " height="942" src="image/Figure_3.11_B17616.jpg" width="1535"/>
</div>
</div>
<p class="figure-caption">Figure 3.11 – The Conversation view of our bridged sniffing capture file</p>
<p>Now, we’ll pull<a id="_idIndexMarker226"/> out our surgical scalpel<a id="_idIndexMarker227"/> and learn how to find and even<a id="_idIndexMarker228"/> manipulate<a id="_idIndexMarker229"/> packets based on their properties. </p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Ettercap filters – fine-tuning your analysis</h2>
<p>We’ve seen just how powerful Ettercap can be out of the box. Ettercap shines due to its content filtering engine<a id="_idIndexMarker230"/> and its ability to interpret custom scripts. Ettercap makes man-in-the-middle attacks a no-brainer; however, with filters, we can turn a Kali box running Ettercap into, for instance, an IDS. Imagine the combined power of our bridged sniffing attack and custom filters, which have been designed to interpret packets, and take action on them: dropping them and even modifying them in transit.</p>
<p>Let’s take a look at a basic example to whet our appetite. You may immediately notice the C-like syntax and the similarity to Wireshark display filters. There’s a lot of conceptual overlap here; you’ll find that analyzing patterns with Wireshark can yield some powerful Ettercap filters:</p>
<pre class="source-code">if (ip.proto == TCP) {</pre>
<pre class="source-code">  if (tcp.src == 80 || tcp.dst == 80) {</pre>
<pre class="source-code">    msg("HTTP traffic detected.\n");</pre>
<pre class="source-code">  }</pre>
<pre class="source-code">}</pre>
<p>Translated into plain English, this says, <em class="italic">test if the IP protocol is TCP; if so, do another test to see if the source port is </em><strong class="source-inline">80</strong><em class="italic">, or if the destination port is </em><strong class="source-inline">80</strong><em class="italic">; if either is true, display a message to the user that says </em><strong class="source-inline">HTTP traffic detected</strong>. This is an example of nested<a id="_idIndexMarker231"/> if statements, which are embedded in graph parentheses.</p>
<p>Let’s take a look at an ability that should intrigue the Scapy/Python part of your brain:</p>
<pre class="source-code">if (ip.proto == TCP) {</pre>
<pre class="source-code">  if (tcp.dst == 12345) {</pre>
<pre class="source-code">    msg("Port 12345 pattern matched, executing script.\n");</pre>
<pre class="source-code">    exec("./12345_exec");</pre>
<pre class="source-code">  }</pre>
<pre class="source-code">}</pre>
<p>In this sample, we’re testing for any TCP packet destined for port <strong class="source-inline">12345</strong>. If the packet is seen, we alert the user that an executable is being triggered. The script then launches <strong class="source-inline">12345_exec</strong>. We could write up a Python script (and yes, import Scapy to craft packets) that will trigger upon meeting a condition in Ettercap. </p>
<h3>Killing connections with Ettercap filters</h3>
<p>Now, let’s try to construct a filter to kill SSH and SMTP connections while allowing all other traffic. This will give us hands-on experience<a id="_idIndexMarker232"/> with setting up a basic service filtering mechanism on our Kali box. Pay attention: my first shot at this short filter will have a troublemaking function in it. We’ll review the results and see if we can fix the problem.</p>
<p>First, I will fire up nano and create a file with this filter:</p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<img alt="Figure 3.12 – Finishing the filter in nano " height="297" src="image/Figure_3.12_B17616.jpg" width="1125"/>
</div>
</div>
<p class="figure-caption">Figure 3.12 – Finishing the filter in nano</p>
<p>Let’s review this line by line:</p>
<ul>
<li><strong class="source-inline">if (ip.proto == TCP) {</strong> is our parent <strong class="source-inline">if</strong> statement, checking if the packet in question is a TCP packet. If so, the script proceeds.</li>
<li><strong class="source-inline">if (tcp.src == 22 || tcp.dst == 22 || tcp.src == 25 || tcp.dst == 25) {</strong> is the nested if statement that checks if the TCP packet that passed<a id="_idIndexMarker233"/> our first check is coming from or destined to ports <strong class="source-inline">22</strong> or <strong class="source-inline">25</strong>. The double pipe means <em class="italic">or</em>, so any of these four checks will pass the if statement, taking us to the functions:<ul><li><strong class="source-inline">msg()</strong> displays a message in our Ettercap window. I would always recommend using this so that we know that the filter was triggered.</li><li><strong class="source-inline">drop()</strong> simply drops the packet; since we’re in the middle, it means we received it but we won’t be passing it on. The sender doesn’t get any confirmation of receipt, and the recipient never gets it.</li><li><strong class="source-inline">kill()</strong> gets aggressive and sends an RST packet to both ends of the communication. </li></ul></li>
<li>The two closing graph parentheses correspond to each <strong class="source-inline">if</strong> statement.</li>
</ul>
<p>I will save this text file with nano and prepare to compile it.</p>
<p>Why are we compiling the filter? Because interpreting code is slow, and we’re dealing with analysis and manipulation in the middle of the packet’s flight. The compiler is very simple to use and is included, so we can simply issue the command with the name of the file we just created:</p>
<p class="source-code"># etterfilter [filter text file]</p>
<p>We’ll see the compiler introduce<a id="_idIndexMarker234"/> itself and then it gets to work:</p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<img alt="Figure 3.13 – Compiling our filter with etterfilter " height="682" src="image/Figure_3.13_B17616.jpg" width="1066"/>
</div>
</div>
<p class="figure-caption">Figure 3.13 – Compiling our filter with etterfilter</p>
<p>The default output is <strong class="source-inline">filter.ef</strong>, but you can name it whatever you want.</p>
<p>Now, we can simply fire up Ettercap like we did previously, but this time, we’re going to be loading our filter with <strong class="source-inline">-F</strong>. Ettercap does everything else automatically:</p>
<p class="source-code"># ettercap -T -q -F filter.ef -B eth0 -B wlan0 -w SSH_SMTP_Filter_Testcapture</p>
<p>I connect to our naughty network, and I try to connect to my SSH server at home. The connection fails, just as we had planned – but the console starts lighting up with my filter message. Let’s look in Wireshark and filter by port <strong class="source-inline">22</strong> traffic to see what’s going on:</p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<img alt="Figure 3.14 – Lighting up the LAN with RST packets " height="534" src="image/Figure_3.14_B17616.jpg" width="1505"/>
</div>
</div>
<p class="figure-caption">Figure 3.14 – Lighting up the LAN with RST packets</p>
<p>What in tarnation? 26,792 RST packets in a matter of a couple of minutes! We just flooded ourselves with RST packets. How did we manage this with such a dinky script? </p>
<p>I know what the hacker in you is thinking: <em class="italic">we included a kill function in bridged sniffing, so the filter is running</em><em class="italic"><a id="_idIndexMarker235"/></em><em class="italic"> on two interfaces and designed to match any packet going to and from SSH, which would, by definition, include our RST packets</em>. Nicely done – I’m impressed. Let’s recompile our script and take out <strong class="source-inline">kill()</strong>. </p>
<p>That’s better:</p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<img alt="Figure 3.15 – Dropping the kill function " height="496" src="image/Figure_3.15_B17616.jpg" width="1538"/>
</div>
</div>
<p class="figure-caption">Figure 3.15 – Dropping the kill function</p>
<p>The network calms down and our bridge merely drops the packets without sending any RST packets. My SSH client<a id="_idIndexMarker236"/> running on our victim Windows box never gets the SYN-ACK it was hoping for:</p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<img alt="Figure 3.16 – Port 22 successfully dropped " height="627" src="image/Figure_3.16_B17616.jpg" width="1005"/>
</div>
</div>
<p class="figure-caption">Figure 3.16 – Port 22 successfully dropped</p>
<p>Any good pen tester has a variety of tools at his or her disposal. Often, different tools are comparable to each other in functionality, but one does something better than the other and vice versa. A common pain point for any pen tester is the wonderfully powerful tool that is no longer supported, so you make do with what was last updated a decade ago. Hey, if it ain’t broke, don’t fix it – some attacks, such as ARP spoofing, don’t change over the years at their core. However, any bugs that were present are there for life. Ettercap has proven itself to security practitioners, and we’ve seen its power here, but I’m going to wrap up the sniffing and spoofing discussion with the new kid on the block (relatively speaking): BetterCAP.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Getting better – scanning, sniffing, and spoofing with BetterCAP</h1>
<p>We can get started and grab BetterCAP on Kali very easily as it’s in the repository:</p>
<p class="source-code"># apt-get install bettercap</p>
<p>Back in my day, the legacy BetterCAP used a command-line interface. Now, there’s a very slick web interface<a id="_idIndexMarker237"/> to bring sniffing and spoofing into the current<a id="_idIndexMarker238"/> century. As with any locally hosted web interface, you’ll want to be aware<a id="_idIndexMarker239"/> of the credentials that are used for logging in. Grab nano and configure the HTTP caplet at <strong class="source-inline">/usr/share/bettercap/caplets/http-ui.cap</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<img alt="Figure 3.17 – Configuring the HTTP UI " height="521" src="image/Figure_3.17_B17616.jpg" width="1069"/>
</div>
</div>
<p class="figure-caption">Figure 3.17 – Configuring the HTTP UI</p>
<p class="callout-heading">Take a Break from the Command Line</p>
<p class="callout">Once you’ve logged in with the HTTP UI, you can modify any caplet parameters from there, including the username and password specified here.</p>
<p>Now, let’s get this party started by running the <strong class="source-inline">bettercap –caplet http-ui</strong> command. Then, you can fire up your browser and head on over to your localhost:</p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<img alt="Figure 3.18 – The Events window for BetterCAP " height="943" src="image/Figure_3.18_B17616.jpg" width="1578"/>
</div>
</div>
<p class="figure-caption">Figure 3.18 – The Events window for BetterCAP</p>
<p>Our first stop is the <strong class="bold">Events</strong> tab. You can<a id="_idIndexMarker240"/> also keep an eye on what’s happening in the terminal window. Since we haven’t started<a id="_idIndexMarker241"/> anything yet, not much is happening<a id="_idIndexMarker242"/> here. Let’s click on the <strong class="bold">LAN</strong> tab and see if we can find some targets. Click the <strong class="bold">net.probe</strong> play button and grab some coffee while BetterCAP does the rest:</p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<img alt="Figure 3.19 – Starting the network probe " height="277" src="image/Figure_3.19_B17616.jpg" width="990"/>
</div>
</div>
<p class="figure-caption">Figure 3.19 – Starting the network probe</p>
<p>Immediately, we start probing the local<a id="_idIndexMarker243"/> network for hosts – and boy oh boy, those are some<a id="_idIndexMarker244"/> fast results! Hopefully, this concerns<a id="_idIndexMarker245"/> you: there’s no way it’s that fast without being all kinds of noisy. So, let’s take a look at Wireshark while we’re running this module:</p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<img alt="Figure 3.20 – The net.probe module behind the scenes " height="659" src="image/Figure_3.20_B17616.jpg" width="1307"/>
</div>
</div>
<p class="figure-caption">Figure 3.20 – The net.probe module behind the scenes</p>
<p>There you have it – it’s an ARP sweep of the local network at a rate of over 80 probes per second. In a real-world pen test, you’ll probably want this much lower (unless you are stress testing or making a point to your client). Click on the <strong class="bold">Advanced</strong> tab at the top, find the <strong class="bold">net.probe</strong> module in the listing on the left, and adjust the <strong class="bold">net.probe.throttle</strong> value based on your needs:</p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<img alt="Figure 3.21 – Throttling the LAN probe " height="631" src="image/Figure_3.21_B17616.jpg" width="1309"/>
</div>
</div>
<p class="figure-caption">Figure 3.21 – Throttling the LAN probe</p>
<p>I know what you’re thinking now: <em class="italic">whoa. There is a lot of cool stuff here</em>. This is where you can get a feel for the caplets that are installed and how they work. Along the left-hand side of the screen is a listing<a id="_idIndexMarker246"/> of BetterCAP’s capabilities. You’ll find <strong class="bold">arp.spoof</strong> to pull<a id="_idIndexMarker247"/> off the work from this chapter with a beautiful<a id="_idIndexMarker248"/> interface (move over, Cain sniffer). Some of the additional flexibility offered by BetterCAP can be found under <strong class="bold">Parameters</strong> and includes<a id="_idIndexMarker249"/> the following:</p>
<ul>
<li><strong class="bold">arp.spoof.fullduplex</strong> allows you to poison the ARP table of just your target, or the tables of both the target and the gateway. In other words, are you pretending to be just your target, or both your target and the gateway? Since the target intends to chat with the gateway, setting <strong class="bold">fullduplex</strong> to <strong class="source-inline">false</strong> means you’ll only see the target’s half of the conversation. This may be desirable to stay under the radar.</li>
<li><strong class="bold">arp.spoof.internal</strong> simply attacks the entire LAN, allowing you to capture chatter between hosts. This need depends on the specific environment you’re in.</li>
<li><strong class="bold">arp.spoof.skip_restore</strong> can be thought of as whether you’ll stop your attack rudely or politely. Remember that the ARP table is maintained by each host independently; the table will only change when it’s updated by ARP packets on the wire. If you run your attack, grab the loot you need, then unplug and run away, you’re leaving the network looking for your MAC address. <em class="italic">Restoring</em> in this context is what I call re-ARPing. Setting <strong class="bold">skip_restore</strong> to <strong class="source-inline">true</strong> is more disruptive.</li>
<li><strong class="bold">arp.spoof.targets</strong> allows you to specify the targets for your attack. What’s nice about this field is that it accepts <a id="_idIndexMarker250"/>Nmap format as well, so it’s easier to drop in that data.</li>
<li><strong class="bold">arp.spoof.whitelist</strong> is for those situations where you need to specify your non-targets. </li>
</ul>
<p>What you would normally be doing with the <strong class="bold">set</strong> command in BetterCAP is what the HTTP UI is handling for you here. My favorite thing about this is the aesthetics: it makes presentations for the client more exciting.</p>
<p>Finally, click<a id="_idIndexMarker251"/> on the <strong class="bold">Caplets</strong> tab to get a look at the attacks you can<a id="_idIndexMarker252"/> pull off once BetterCAP has placed your interface in the privileged<a id="_idIndexMarker253"/> position you desire. I like to think of these as <em class="italic">recipes</em> using BetterCAP’s native capabilities. For example, check out the parameters under <strong class="bold">http-req-dump</strong>. You’ll see that it configures <strong class="bold">net.probe</strong>, <strong class="bold">net.sniff</strong>, <strong class="bold">http.proxy</strong>, <strong class="bold">https.proxy</strong>, and <strong class="bold">arp.spoof</strong>. For those of you who are adventurous, you’ll find exceptional configurability for your needs.</p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor061"/>Summary</h1>
<p>In this chapter, we learned about passive versus active sniffing. We started by exploring wireless LANs in monitor mode, which allowed us to capture data without revealing our presence. We used Airodump-ng to organize the wireless environment and inform more precise sniffing with Wireshark. After exploring the basics with Wireshark, we moved on to advanced statistical analysis of both passive and active sniffing methods. For the active sniffing phase, we connected to a network (thus revealing our presence) and captured data visible to our card. We applied advanced display filters to hone in on interesting packets within even very large network dumps. We then moved on to advanced Ettercap sniffing techniques, focusing on bridged sniffing with two interfaces. To demonstrate the power of this attack, we configured a malicious access point and set up our Kali box to function as a full-fledged traffic interceptor and IDS, including using Ettercap filters to capture and drop select data from the network. We then introduced BetterCAP, a sophisticated alternative to Ettercap.</p>
<p>In the next chapter, we will discuss Windows password fundamentals, and we will demonstrate practical attacks to capture Windows credentials off the wire and a host to feed into a password cracker. We will then discuss password cracking methods.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li>You put your wireless card in monitor mode and capture raw wireless packets without associating them with a WLAN. What sniffing concept is this?</li>
<li>The BSSID of an access point is the same as the hardware’s _____________.</li>
<li>Individual devices that participate in conversations are called ___________ by Wireshark.</li>
<li>What is the Wireshark display filter called that’s used to find any packet with the TCP ACK flag set?</li>
<li>When writing Ettercap filters, you can put a space between a function name and the opening parenthesis. (True | False)</li>
<li>What Ettercap filter function will quietly prevent packets from passing to a destination?</li>
<li>How do you reduce the verbosity of Ettercap’s command-line interface?</li>
<li>What is the file extension of a binary Ettercap filter?</li>
<li>What does ICMP stand for?</li>
</ol>
<h1 id="_idParaDest-64"><a id="_idTextAnchor063"/>Further reading</h1>
<p>For more information regarding the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>Ettercap main page: <a href="https://linux.die.net/man/8/ettercap">https://linux.die.net/man/8/ettercap</a></li>
<li>etterfilter main page, which includes details about scripting syntax: <a href="https://linux.die.net/man/8/etterfilter">https://linux.die.net/man/8/etterfilter</a></li>
<li>Advanced Wireshark usage guide: <a href="https://www.wireshark.org/docs/wsug_html_chunked/ChapterAdvanced.xhtml">https://www.wireshark.org/docs/wsug_html_chunked/ChapterAdvanced.xhtml</a></li>
<li>RFC 792: <a href="https://datatracker.ietf.org/doc/html/rfc792">https://datatracker.ietf.org/doc/html/rfc792</a></li>
<li>RFC 793: <a href="https://datatracker.ietf.org/doc/html/rfc793">https://datatracker.ietf.org/doc/html/rfc793</a></li>
</ul>
</div>
</div></body></html>