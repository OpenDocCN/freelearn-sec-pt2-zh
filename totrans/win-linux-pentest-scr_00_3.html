<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer055">
<h1 id="_idParaDest-34"><em class="italic"><a id="_idTextAnchor033"/>Chapter 2</em>: Bypassing Network Access Control</h1>
<p>The network is the first thing we think about when we imagine computers getting hacked. It’s the pen tester’s playground. It’s both the first step and the final frontier of compromising a computer. It’s also what makes the compromise of a single computer effectively the compromise of an entire building full of computers. It’s fitting, then, that we continue our journey with a discussion about compromising the network and using its own power and weaknesses to inform the pen test.</p>
<p>The first step is getting on the network, and there are human, architectural, and protocol factors that make the mere presence of an attacker on the network potentially devastating. For this reason, defenders often deploy <strong class="bold">Network Access Control</strong> (<strong class="bold">NAC</strong>) systems. The intent of these systems is to detect and/or prevent an intrusion on the network by identifying and authenticating devices on the network. In this chapter, we will review some of the methods employed by NACs and demonstrate practical methods of bypassing these controls.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Bypassing NACs with physical access to clone an authorized device</li>
<li>Captive portal methods and their weaknesses</li>
<li>Policy checks for new devices</li>
<li>Masquerading the stack of an authorized device</li>
</ul>
<h1 id="_idParaDest-35"><a id="_idTextAnchor034"/>Technical requirements</h1>
<p>The following are required before you move further into the chapter:</p>
<ul>
<li>Kali Linux installed on a laptop</li>
<li>A USB wireless network interface card that supports promiscuous mode in Kali – I recommend Alfa cards</li>
</ul>
<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Bypassing media access control filtering – considerations for the physical assessor</h1>
<p>An attacker needs to be aware of methods for remote compromise: attacking the VPN, wireless <a id="_idIndexMarker102"/>infiltration from a distance using high-gain antennas, and so on. However, the pen tester can never forget the big picture. This is a field where it is very easy to get caught up in the highly specific technical details and miss the human element of security design.</p>
<p>There is a design flaw concept that pen testers like to call the <em class="italic">candy bar model</em>. This simply refers to a network that is tough and crunchy on the outside but gooey on the inside. In other words, it is a model that emphasizes the threats of the outside world when designing the security architecture, while assuming that someone who is physically inside company facilities has been vetted and is therefore trusted. The mindset here dates back many years; in the earliest days of what became the internet, the physical access points to the network were inside highly secure facilities. Packets coming in over the network were safely assumed to be from a secure environment and sent by an authorized individual. In today’s world, a packet hitting the border of a company’s network could be from an authorized individual on a business trip or it could be from a clever teenager on the other side of the planet, eager to try out some newly learned tricks.</p>
<p>The candy bar model will come up in later chapters when we discuss other network attacks. Once you crack that outer shell, you’ll often find that the path forward seems paved especially for you – and a successful compromise will inform your client of the devastating consequences of this mistaken assumption. Feel free to treat yourself to an actual candy bar upon successful compromise – you deserve it.</p>
<p>How you social-engineer your target is a subject for another book altogether, but for the purposes of this discussion, let’s assume that you have physical access to network drops. Not all physical access is the same, though; if you convinced your target to hire you as a full-time employee, then you’ll have constant physical access. They’ll even hand you a computer. However, what’s more likely is that you’ve exploited a small gap in their physical security stance, and your presence can be undetected or tolerated for only a short period of time. You’ve snuck in through the smokers’ door after striking up some conversation with an unwitting employee, or you’ve been given permission to walk around for an hour with a convincing-looking contractor uniform and clipboard, or (my personal favorite) you’ve earned trust and affection by bringing in a big box of donuts for the people expecting an auditor’s visit based on a well-scripted phone call. (My clients, still shaken after the test, would ask whether the donuts were real.) For now, we’ll <a id="_idIndexMarker103"/>demonstrate how to set up a Kali box <a id="_idIndexMarker104"/>to function as a rogue wireless access point while <a id="_idIndexMarker105"/>impersonating the <strong class="bold">Media Access Control</strong> (<strong class="bold">MAC</strong>) address of a <strong class="bold">Voice over Internet Protocol</strong> (<strong class="bold">VoIP</strong>) phone.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Configuring a Kali wireless access point to bypass MAC filtering</h2>
<p>You’ve found an unoccupied cubicle with an empty desk and a generic IP phone. The phone <a id="_idIndexMarker106"/>is plugged in <a id="_idIndexMarker107"/>and working, so you know the network drop is active. We’ll drop our small laptop running Kali here and continue the attack from outside.</p>
<p>First, we unplug the IP phone so that our bad guy can take the port. We are then going to clone the MAC address of the IP phone on our Kali box’s Ethernet port. From the perspective of a simple MAC address whitelisting methodology of NAC, this will look like the phone merely rebooted.</p>
<p>I use <strong class="source-inline">ifconfig</strong> to bring up the interface configuration. In my example, my Ethernet port interface is called <strong class="source-inline">eth0</strong> and my wireless interface is called <strong class="source-inline">wlan0</strong>. I’ll note this for later, as I will <a id="_idIndexMarker108"/>need to configure the system <a id="_idIndexMarker109"/>to run an access point with <strong class="bold">Dynamic Host Configuration Protocol</strong> (<strong class="bold">DHCP</strong>) and <strong class="bold">Domain Name System</strong> (<strong class="bold">DNS</strong>) on <strong class="source-inline">wlan0</strong>, while <a id="_idIndexMarker110"/>running <strong class="bold">Network Address Translation</strong> (<strong class="bold">NAT</strong>) through to my <strong class="source-inline">eth0</strong> interface. I can use <strong class="source-inline">ifconfig eth0 hw ether</strong> to change the physical address of the <strong class="source-inline">eth0</strong> interface. I’ve sneaked a peek at the label on the back of the IP phone – the MAC address is <strong class="source-inline">AC:A0:16:23:D8:1A</strong>.</p>
<p>So, I bring the interface down for the change, bring it back up, then run <strong class="source-inline">ifconfig</strong> one more time to confirm the status of the interface with the new physical address, as shown in <em class="italic">Figure 2.1</em>:</p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<img alt="Figure 2.1 – Bringing up the interface with its new MAC address " height="1004" src="image/Figure_2.01_B17616.jpg" width="1208"/>
</div>
</div>
<p class="figure-caption">Figure 2.1 – Bringing up the interface with its new MAC address</p>
<p class="callout-heading">Don’t Forget to Sudo!</p>
<p class="callout">The <a id="_idIndexMarker111"/>subject of running <a id="_idIndexMarker112"/>things as <strong class="source-inline">root</strong> in Kali has been a contentious one. One of the fundamental rules of Linux usage is that you should never log in as <strong class="source-inline">root</strong> – if the need for <strong class="source-inline">root</strong> privileges comes along, use the <strong class="source-inline">sudo</strong> command. Kali Linux used to do things a little differently; it was expected that you would log on as <strong class="source-inline">root</strong>. The idea is that Kali is only meant for pen testing, not to be your personal machine (and certainly not a production server). Accordingly, in the first edition of this book, we never used <strong class="source-inline">sudo</strong> because we were always logged on as <strong class="source-inline">root</strong>. This time around, I’ll switch to a <strong class="source-inline">root</strong> session with <strong class="source-inline">sudo -s</strong>. The folks at Offensive Security have kept their sense of humor – you’ll be reminded of your superpowers with a skull icon.</p>
<p>Two handy tools in the Kali repository are <strong class="source-inline">dnsmasq</strong> and <strong class="source-inline">hostapd</strong>:</p>
<ul>
<li><strong class="source-inline">dnsmasq</strong> is a lightweight network infrastructure utility. Completely free and written in C, this is a nifty tool for setting up a quick and dirty network on the fly, complete with DHCP and DNS forwarding. In our example, we’re using it as a DHCP and DNS service for the wireless clients who connect to our access point (which would be you and your colleagues, of course).</li>
<li><strong class="source-inline">hostapd</strong> (<strong class="bold">host access point daemon</strong>) is, as the name implies, access point software <a id="_idIndexMarker113"/>for turning your ordinary wireless network interface into an access point and even an authentication server. You can confirm that whatever Wi-Fi card you’re using supports AP mode with this command:<p class="source-code"><strong class="bold"># iw list |grep "Supported interface modes" -A 8</strong></p></li>
</ul>
<p>If you <a id="_idIndexMarker114"/>see <strong class="source-inline">AP</strong> in the <a id="_idIndexMarker115"/>results, you’re good to go. We use <strong class="source-inline">apt-get install hostapd dnsmasq</strong> to grab the tools.</p>
<p>If you run into problems with <strong class="source-inline">apt-get</strong> (for instance, <strong class="source-inline">package not found</strong>), always review your repository’s <strong class="source-inline">sources.list</strong> file as a first step. Don’t add arbitrary sources to the <strong class="source-inline">sources.list</strong> file; this is a great way to break your Kali installation. In my copy of Kali 2021.1, I had to first run <strong class="source-inline">apt-get update</strong>. You shouldn’t need to do this more than once.</p>
<p>Back to our AP adventure. First, let’s configure <strong class="source-inline">dnsmasq</strong>. Open up <strong class="source-inline">/etc/dnsmasq.conf</strong> using the <strong class="source-inline">nano</strong> command. Then, punch in the following:</p>
<p class="figure-caption"> </p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<img alt="Figure 2.2 – The dnsmasq configuration file " height="1002" src="image/Figure_2.02_B17616.jpg" width="1209"/>
</div>
</div>
<p class="figure-caption">Figure 2.2 – The dnsmasq configuration file</p>
<p>You can <a id="_idIndexMarker116"/>see that the <a id="_idIndexMarker117"/>configuration file has everything you need to know commented out; I strongly recommend you sit down with the <strong class="source-inline">readme</strong> file to understand the full capability of this tool, especially so that you can fine-tune your use for whatever you’re doing in the field. Since this is a hands-on demonstration, I’m keeping it pretty simple:</p>
<ul>
<li><strong class="source-inline">interface=wlan0</strong>: I set my interface to <strong class="source-inline">wlan0</strong>, where the USB wireless card that will play the role of the access point is located.</li>
<li><strong class="source-inline">dhcp-range=10.11.12.2,10.11.12.20,4h</strong>: I set the DHCP range where new clients will be assigned IP addresses when they request an assignment. The format is <strong class="source-inline">[bottom address],[top address],[lease time]</strong>. The address range here is what would be assigned to new clients, so make sure you don’t overlap with the gateway address. You’re the gateway!</li>
<li><strong class="source-inline">dhcp-option=3,10.11.12.1</strong> and <strong class="source-inline">dhcp-option=6,10.11.12.1</strong>: DHCP options specification. This isn’t arbitrary – these numbers are specified in RFC 2132 and subsequent RFCs, so there’s a lot of power here. For our purposes here, I’m setting the gateway with option <strong class="source-inline">3</strong> and DNS with option <strong class="source-inline">6</strong>. In this case, they’re the <a id="_idIndexMarker118"/>same address, as <a id="_idIndexMarker119"/>we would expect on a tiny LAN like this one. Note the address: <strong class="source-inline">10.11.12.1</strong>. That’s the gateway that, by definition, will be your <strong class="source-inline">wlan0</strong> interface. You’ll define that address when you bring up the wireless interface just prior to firing up the access point.</li>
<li><strong class="source-inline">server=8.8.8.8</strong>: I defined the upstream DNS server; I set it to Google <strong class="source-inline">8.8.8.8</strong>, but you can use something different. </li>
<li><strong class="source-inline">log-queries</strong> and <strong class="source-inline">log-dhcp</strong>: I did some logging, just in case we need it.</li>
</ul>
<p>Hit <em class="italic">Ctrl</em> + <em class="italic">X</em> and confirm the file name to save it. Now, we’ll move on to the <strong class="source-inline">hostapd</strong> configuration. Open up <strong class="source-inline">/etc/hostapd/hostapd.conf</strong> using the <strong class="source-inline">nano</strong> command. Keep in mind that this file doesn’t already exist, but <strong class="source-inline">hostapd</strong> will know to use what we create here:</p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<img alt="Figure 2.3 – Configuring our access point for hostapd " height="689" src="image/Figure_2.03_B17616.jpg" width="1208"/>
</div>
</div>
<p class="figure-caption">Figure 2.3 – Configuring our access point for hostapd</p>
<p>Again, this <a id="_idIndexMarker120"/>is a tool <a id="_idIndexMarker121"/>with a lot of power, so check out the <strong class="source-inline">readme</strong> file so you can fully appreciate everything it can do. You can create a rather sophisticated access point with this software, but we’ll just keep it simple for this example:</p>
<ul>
<li><strong class="source-inline">interface=wlan0</strong>: I set the interface to <strong class="source-inline">wlan0</strong>, of course.</li>
<li><strong class="source-inline">driver=nl80211</strong>: I defined the wireless driver; this is <strong class="source-inline">nl80211</strong>, the interface between <strong class="source-inline">cfg80211</strong> and user space, and it allows for management of the device.</li>
<li><strong class="source-inline">ssid=NotABadGuy</strong>: This is our service set identifier – our network’s name. I’m using <strong class="source-inline">NotABadGuy</strong> because I want to convince the world that I’m really a good guy, but of course, you’ll fine-tune this to your needs. There’s a bit of social-engineering potential here to minimize suspicion on the part of those casually scanning the environment.</li>
<li><strong class="source-inline">hw_mode=g</strong>: This is the 802.11 modulation standard; <strong class="source-inline">b</strong>, <strong class="source-inline">g</strong>, and <strong class="source-inline">n</strong> are common.</li>
<li><strong class="source-inline">channel=2</strong>: I’ve defined the channel here, but you can configure it to pick the channel automatically based on surveying.</li>
<li><strong class="source-inline">macaddr_acl=0</strong>: This is a Boolean flag to tell <strong class="source-inline">hostapd</strong> if we’re using a MAC-based access control list. You’ll have to decide whether this is something you need for your purposes. In my example, I’ve configured encryption, and I like to use randomly generated MACs on my devices anyway, so I’d rather not deal with whitelisting MACs.</li>
<li><strong class="source-inline">max_num_sta=1</strong>: This is a way to keep the population of wireless clients restricted – this is the maximum number of clients that are allowed to join. I set mine as <strong class="source-inline">1</strong> here since I only expect myself to be joining, but you could omit this.</li>
<li><strong class="source-inline">ignore_broadcast_ssid=0</strong>: This option simply allows you to hide the network. What it really does is cause your AP to ignore probe request frames that don’t specify the SSID, so it will hide your network from active scans, but you should never consider a functional access point to be hidden. I want to see it in my example, so I set it to <strong class="source-inline">0</strong>.</li>
<li>The remaining options allow me to configure WPA2 encryption.</li>
</ul>
<p>Believe <a id="_idIndexMarker122"/>it or not, those <a id="_idIndexMarker123"/>are the basics for our quick and dirty access point to the physical network. Now, I’ll bring up the <strong class="source-inline">wlan0</strong> interface and specify the gateway address I defined earlier. Then, I bring up <strong class="source-inline">dnsmasq</strong> and tell it to use my configuration file. We enable IP forwarding to tell Kali to act as a router with <strong class="source-inline">sysctl</strong>. We allow our traffic through and enable NAT functionality with <strong class="source-inline">iptables</strong>. Finally, we fire up <strong class="source-inline">hostapd</strong> with our configuration file.</p>
<p>We’ll be looking at <strong class="source-inline">iptables</strong> again, so don’t worry about the details here.</p>
<p>When a wireless client connects to this network, they will have access to the corporate network via <strong class="source-inline">eth0</strong>; to a MAC filter, traffic coming from that port will appear to be coming from a Cisco IP phone:</p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<img alt="Figure 2.4 – Configuring routing with iptables to make our AP work " height="822" src="image/Figure_2.04_B17616.jpg" width="1208"/>
</div>
</div>
<p class="figure-caption">Figure 2.4 – Configuring routing with iptables to make our AP work</p>
<p>As <a id="_idIndexMarker124"/>you’ve no doubt <a id="_idIndexMarker125"/>noticed, this is a really useful setup. Having your box work as a hotspot can be invaluable, and since Kali will run on such a wide variety of hardware, the limit is your imagination.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Design weaknesses – exploiting weak authentication mechanisms</h1>
<p>With NAC, authentication <a id="_idIndexMarker126"/>is the name of the game. In our first attack scenario, we saw that the network verifies that a device is permitted by MAC address whitelisting. The principle is simple – a list of allowed devices is checked when a device joins the network. Many people, even outside of the field, are familiar with MAC filtering from the common implementation of this technique in SOHO wireless routers. However, you may be surprised at how often the VoIP phone masquerade will work in highly secured environments.</p>
<p>It’s network security 101 – MAC addresses are very easily faked, and networks will take your word for it when you claim to be a particular value. I’ve had clients detail, at length, the <a id="_idIndexMarker127"/>various features of their state-of-the-art NAC, only to look puzzled when I show them I had network access to their server environment by pretending to be a conference-room phone. It’s important to test for this bypass; not many clients are aware of simple threats.</p>
<p>We’re now going to look at another attack that can fly surprisingly low under the radar: exploiting authentication communications in the initial restricted network. We’ll be using Wireshark for quick and easy packet analysis in this section; a more advanced Wireshark discussion will take place in <a href="B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Sniffing and Spoofing</em>.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Capturing captive portal authentication conversations in the clear</h2>
<p>Speaking <a id="_idIndexMarker128"/>of security mechanisms that even non-security folks will have some familiarity with, captive portals are a common NAC strategy. They’re the walls you encounter when trying to get online in a hotel or an airplane; everything you try to access takes you to a specially configured login screen. You will receive credentials from an administrator, or you will submit a payment – either way, after you’ve authenticated, the captive <a id="_idIndexMarker129"/>portal will grant access via some means (a common one is <strong class="bold">Simple Network Management Protocol</strong> (<strong class="bold">SNMP</strong>) management post-authentication).</p>
<p>I know what the hacker in you is saying: <em class="italic">When the unauthenticated client tries to send an HTTP request, they get a 301 redirect to the captive portal authentication page, so it's really nothing more than a locally hosted web page. Therefore, it may be susceptible to ordinary web attacks.</em> Well done, I couldn’t have said it better. But don’t fire up <strong class="source-inline">sslstrip</strong> just yet; would it surprise you to learn that unencrypted authentication is actually fairly common? We’re going to take a look at an example: the captive portal to grant internet access to guests in my house. This isn’t your run-of-the-mill captive portal functionality built into an off-the-shelf home router; this is a pfSense firewall running on a dedicated server.</p>
<p>This is used in some enterprises, so trust me, you will run into something like this in your adventures as a pen tester. I don’t think you’ll see my cat in your clients’ captive portals, but you can never be too sure.</p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<img alt="Figure 2.5 – A pfSense-powered captive portal, guarded by my cat " height="1073" src="image/Figure_2.05_B17616.jpg" width="1290"/>
</div>
</div>
<p class="figure-caption">Figure 2.5 – A pfSense-powered captive portal, guarded by my cat</p>
<p>What <a id="_idIndexMarker130"/>we see here is the captive portal presented to a user immediately upon joining the network. I wanted to have a little fun with it, so I wrote up the HTML myself (the bad cat pun is courtesy of my wife). However, the functionality is exactly the same as you’ll see in companies that utilize this NAC method.</p>
<p>Let’s get in the Kali driver’s seat. We’ve already established a connection to this network, and we’re immediately placed into the restricted zone. Fire up a terminal and start Wireshark as the superuser:</p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<img alt="Figure 2.6 – Capturing traffic on a switched network with Wireshark " height="630" src="image/Figure_2.06_B17616.jpg" width="1496"/>
</div>
</div>
<p class="figure-caption">Figure 2.6 – Capturing traffic on a switched network with Wireshark</p>
<p>Not <a id="_idIndexMarker131"/>a lot is going on here, even with our card in promiscuous mode. This looks like we’re dealing with a switched network, so traffic between our victim and the gateway is not broadcasted for us to see. But, take a closer look at the highlighted packet: it’s being broadcasted to <strong class="source-inline">255.255.255.255</strong> – the broadcast address of the zero network (that is, the network we’re on). We can see that it’s a DHCP request. So, our victim with an unknown IP address is joining the network and will soon authenticate to the portal. Though the victim isn’t the destination, we’ll find the IP address assignment in the DHCP Ack packet:</p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<img alt="Figure 2.7 – Examining a DHCP packet with Wireshark " height="1038" src="image/Figure_2.07_B17616.jpg" width="1436"/>
</div>
</div>
<p class="figure-caption">Figure 2.7 – Examining a DHCP packet with Wireshark</p>
<p>Wireshark <a id="_idIndexMarker132"/>is kind enough to convert that hex into a human-friendly IP address: <strong class="source-inline">192.168.80.71</strong>. We’re on a switched LAN, so our victim’s HTTP authentication is going directly to the gateway, right? Yes, it is, but the keyword here is LAN.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Layer-2 attacks against the network</h2>
<p>The lowest layer <a id="_idIndexMarker133"/>of the internet protocol suite is the link layer, which is the realm of adjacent hosts on a LAN segment. Link-layer communication protocols don’t leave the network via routers, so it’s important to be aware of them and their weaknesses when you are attacking LANs. When you join a LAN, even a restricted one outside of the protected network, you’re sharing that space with anything else on that segment: the captive portal host itself, other clients waiting to be authenticated, and, in some cases, even with authenticated clients.</p>
<p>The unqualified term <strong class="bold">LAN</strong> doesn’t necessarily mean that all members of the LAN are in the same broadcast <a id="_idIndexMarker134"/>domain, also called a <strong class="bold">layer-2 segment</strong>. For our purposes here, we’re talking about hosts sharing the same link-layer environment, as the attack described won’t work in private VLANs.</p>
<p>When our victim joined the LAN, it was assigned an IP address by DHCP. But any device with a message for that IP address has to know the link-layer hardware address associated <a id="_idIndexMarker135"/>with the destination IP. This layer-2–layer-3 mapping is accomplished with the <strong class="bold">Address Resolution Protocol</strong> (<strong class="bold">ARP</strong>). An ARP message informs the requester <em class="italic">where</em> (that is, at which link-layer address) a particular IP address is assigned. The clients on the network maintain a local table of ARP mappings. For example, on Windows, you can check the local ARP table with the <strong class="source-inline">arp -a</strong> command. The fun begins when we learn that these tables are updated by ARP messages without any kind of verification. If you’re an ARP table and I tell you that the gateway IP address is mapped to <strong class="source-inline">00:01:02:aa:ab:ac</strong>, you’re going to just believe it and update accordingly. This opens the possibility of <em class="italic">poisoning</em> the ARP table – feeding it bad information.</p>
<p>What we’re <a id="_idIndexMarker136"/>going to do is feed the network bad ARP information so that the gateway believes that the Kali attacker’s MAC address is assigned the victim’s IP address; meanwhile, we’re also telling the network that the Kali attacker’s MAC address is assigned the gateway IP address. The victim will send data meant for the gateway to me, and the gateway will send data meant for the victim to me. Of course, that would mean nothing is getting from the gateway to the victim and vice versa, so we’ll need to enable packet forwarding so that the Kali machine will hand off the message to the actual destination. By the time the packet gets to where it was meant to go, we’ve processed it and sniffed it.</p>
<p>We will cover spoofing in more detail in <a href="B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Sniffing and Spoofing</em>.</p>
<p>First, we enable packet forwarding with the following command:</p>
<p class="source-code"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward </p>
<p>An alternative command is as follows:</p>
<p class="source-code"># sysctl -w net.ipv4.ip_forward=1</p>
<p><strong class="source-inline">arpspoof</strong> is a lovely tool for really fast and easy ARP poisoning attacks. Overall, I prefer Ettercap; however, I will be covering Ettercap later on, and it’s always nice to be aware of the quick and dirty ways of doing things for when you’re in a pinch. Ettercap is ideal for more sophisticated reconnaissance and attack, but with <strong class="source-inline">arpspoof</strong>, you can literally have an ARP man-in-the-middle attack running in a matter of seconds.</p>
<p>Earlier versions of Kali had this tool ready to go – in Kali 2021.1, you’ll need to run <strong class="source-inline">apt-get install dsniff</strong> first. A few seconds later, you’ll be ready to go.</p>
<p>I fire off the <strong class="source-inline">arpspoof –i wlan0 –t 192.168.80.1 -r 192.168.80.71</strong> command. The <strong class="source-inline">-i</strong> flag is the interface, the <strong class="source-inline">-t</strong> flag is the target, and the <strong class="source-inline">-r</strong> flag tells <strong class="source-inline">arpspoof</strong> to poison both sides to <a id="_idIndexMarker137"/>make it bidirectional. (The older version didn’t have the <strong class="source-inline">-r</strong> flag, so we had to set up two separate attacks.) Keep in mind that the target can be the gateway or the victim; since we’re creating a bidirectional attack, it doesn’t matter:</p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<img alt="Figure 2.8 – Poisoning the ARP tables with arpspoof " height="401" src="image/Figure_2.08_B17616.jpg" width="1266"/>
</div>
</div>
<p class="figure-caption">Figure 2.8 – Poisoning the ARP tables with arpspoof</p>
<p>Here, we can see <strong class="source-inline">arpspoof</strong> in action, telling the network that the gateway and the victim are actually my Kali box. Meanwhile, the packets will be forwarded as received to the other side of the intercept. When it works properly (that is, your machine doesn’t create a bottleneck), neither side will know the difference unless they are sniffing the network. When we check back with Wireshark, we can see what an ARP poisoning attack looks like.</p>
<p>We can see communication between the victim and the gateway, so now it’s a matter of filtering for what you need. In our demonstration here, we’re looking for authentication to a web portal – likely a <strong class="source-inline">POST</strong> message. When I find it, I follow the conversation in Wireshark <a id="_idIndexMarker138"/>by right-clicking a packet and selecting <strong class="bold">Follow</strong>, and there are the victim’s credentials in plain text:</p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<img alt="Figure 2.9 – Capturing credentials by following the authentication HTTP stream with Wireshark " height="648" src="image/Figure_2.09_B17616.jpg" width="992"/>
</div>
</div>
<p class="figure-caption">Figure 2.9 – Capturing credentials by following the authentication HTTP stream with Wireshark</p>
<p class="callout-heading">Take Only Packets, Leave Only Re-ARP</p>
<p class="callout">Make sure you don’t close the terminal window where <strong class="source-inline">arpspoof</strong> is running – use <em class="italic">Ctrl </em>+ <em class="italic">C</em> to send the kill signal. The program will recognize it and attempt to re-ARP your network. Remember, you’ve been poisoning the ARP tables on other hosts; that data will persist until new ARP messages correct it. Gracefully closing <strong class="source-inline">arpspoof</strong> will do just that.</p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Bypassing validation checks</h1>
<p>We’ve seen <a id="_idIndexMarker139"/>how NAC systems can employ simple MAC address filtering and captive portal authentication to control network access. Now, suppose that you’re coming away from the ARP poisoning attack just described, excited that you scored yourself some legitimate credentials. You try to log in with your Kali box and you’re slapped down by a validation check that you hadn’t foreseen. You have the correct username and password – how does the NAC know it isn’t the legitimate user?</p>
<p>NAC vendors quickly figured out that it was a simple matter for anyone to spoof a MAC address, so some systems perform additional verification to match the hardware address to other characteristics of the system. Imagine the difference between authenticating <a id="_idIndexMarker140"/>someone by fingerprint alone and authenticating someone by fingerprint, clothing style, vocal patterns, and so on. The latter prevents simple spoof attacks. In this context, the NAC is checking that the MAC address matches other characteristics: the manufacturer, operating system, and user-agent are common checks. It turns out that the captive portal knows this <strong class="source-inline">Phil</strong> user you’ve just spoofed, and it was expecting an Apple iPad (common in the enterprise as an <em class="italic">approved device</em>). Let’s review these three checks in detail.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>Confirming the organizationally unique identifier</h2>
<p>There <a id="_idIndexMarker141"/>are two <a id="_idIndexMarker142"/>main parts to a MAC address: the first three octets are the <strong class="bold">Organizationally Unique Identifier</strong> (<strong class="bold">OUI</strong>), and the last three octets are <strong class="bold">Network Interface Controller-specific</strong> (<strong class="bold">NIC-specific</strong>). The OUI is important <a id="_idIndexMarker143"/>here because it uniquely identifies a manufacturer. The manufacturer will purchase an OUI from the IEEE Registration Authority and then hardcode it into their devices in-factory. This is not a secret – it’s public information, encoded into all the devices a particular manufacturer makes. A simple Google search for <strong class="source-inline">Apple OUI</strong> helps us narrow it down, though you can also pull up the IEEE Registration Authority website directly. We quickly find out that <strong class="source-inline">00:21:e9</strong> belongs to Apple, so we can try to spoof a random NIC address with that (for example, <strong class="source-inline">00:21:e9:d2:11:ac</strong>).</p>
<p>But again, vendors are already well aware of the fact that MAC addresses are not reliable for filtering, so they’re likely going to look for more indicators.</p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>Passive operating system fingerprinter</h2>
<p>Anyone <a id="_idIndexMarker144"/>who has dissected a packet off a network should be familiar with the concept of operating system fingerprinting. Essentially, operating systems have little nuances in how they construct packets to send over the network. These nuances are useful as signatures, giving us a good idea of the operating system that sent the packet. We’re preparing to spoof the stack of a chosen OS as previously explained, so let’s cover a tool in Kali that will come <a id="_idIndexMarker145"/>in handy for a variety of recon situations – the <strong class="bold">passive operating system fingerprinter</strong> (<strong class="bold">p0f</strong>).</p>
<p>Its power is in its simplicity: it watches for packets, matches signatures according to a signature database of known systems, and gives you the results. Of course, your network card has to be able to see the packets that are to be analyzed. We saw with our example that the restricted network is switched, so we can’t see other traffic in a purely passive manner; we had to trick the network into routing traffic through our Kali machine. So, we’ll do that again, except on a larger scale, as we want to fingerprint a handful of clients on the network. Let’s ARP-spoof with Ettercap, a tool that should easily be in your handiest tools top 10. Once Ettercap is running and doing its job, we’ll fire up p0f and see what we find.</p>
<p>We’re going to bring up Ettercap with the graphical interface, featuring a very scary-looking network-sniffing spider:</p>
<p class="HTML-Preformatted"><strong class="bold"># ettercap -G</strong></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<img alt="Figure 2.10 – The startup screen for Ettercap " height="565" src="image/Figure_2.10_B17616.jpg" width="1220"/>
</div>
</div>
<p class="figure-caption">Figure 2.10 – The startup screen for Ettercap</p>
<p>Let’s start sniffing, and then we’ll configure our man-in-the-middle attack. Note that <strong class="bold">Bridged sniffing</strong> is currently unchecked – this means we’re in unified sniffing mode. Unified sniffing means we’re just sniffing from one network card; we aren’t forwarding anything to another interface right now. We will cover the beauty of bridged sniffing in the next chapter.</p>
<p>Now, we tell Ettercap to find out who’s on the network. Click the check at the top to approve <a id="_idIndexMarker146"/>the initial settings (make sure your primary interface is correct), and then click the three dots button. Under <strong class="bold">Hosts</strong>, click on <strong class="bold">Scan for hosts</strong>. When the scan is complete, you can click <strong class="bold">Hosts</strong> again to bring up the host list. This tells us what Ettercap knows about who’s on the network.</p>
<p>Now, we’re doing something rather naughty; I’ve selected the gateway as <strong class="bold">Target 1</strong> (by selecting it and then clicking <strong class="bold">Add to Target 1</strong>) and a handful of clients as <strong class="bold">Target 2</strong>. This means Ettercap is going to poison the network with ARP announcements for all of those hosts, and we’ll soon be managing the traffic for all of those hosts.</p>
<p class="callout-heading">Always Poison ARP Responsibly</p>
<p class="callout">Be very careful when playing man-in-the-middle with more than a few hosts at a time. Your machine can quickly bottleneck the network. I’ve been known to kill a client’s network doing this.</p>
<p>Select <strong class="bold">MITM</strong> (small globe icon at the top)| <strong class="bold">ARP poisoning</strong>. I like to select <strong class="bold">Sniff remote connections</strong>, though you don’t have to for this particular scenario.</p>
<p>That’s it. Click <strong class="bold">OK</strong> and now Ettercap will work its magic. Click <strong class="bold">View</strong> | <strong class="bold">Connections</strong> to see all the details on connections that Ettercap has seen so far.</p>
<p>Those of you who are familiar with Ettercap may know that the <strong class="bold">Profiles</strong> option in the <strong class="bold">View</strong> menu will allow us to fingerprint the OS of the targets, but in keeping with presenting the tried-and-true, quick-and-dirty tool for our work, let’s fire up p0f. (You’ll need to first install p0f on Kali 2021.1 with <strong class="source-inline">apt-get install p0f</strong>.) The <strong class="source-inline">-o</strong> flag allows us to output to a file – trust me, you’ll want to do this, especially for a spoofing attack of this magnitude:</p>
<p class="source-code"># p0f -o poflog</p>
<p>p0f likes to show you some live data as it’s collecting the juicy gossip. Here, we can see that <strong class="source-inline">192.168.108.199</strong> is <a id="_idIndexMarker147"/>already fingerprinted as a Linux host by looking at a single SYN packet:</p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<img alt="Figure 2.11 – p0f capturing OS fingerprints " height="1004" src="image/Figure_2.11_B17616.jpg" width="1209"/>
</div>
</div>
<p class="figure-caption">Figure 2.11 – p0f capturing OS fingerprints</p>
<p><em class="italic">Ctrl</em> + <em class="italic">C</em> closes p0f. Now, let’s open up our (greppable) log file with nano:</p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<img alt="Figure 2.12 – Reviewing the raw signatures in the p0f log file " height="1004" src="image/Figure_2.12_B17616.jpg" width="1211"/>
</div>
</div>
<p class="figure-caption">Figure 2.12 – Reviewing the raw signatures in the p0f log file</p>
<p>Beautiful, isn’t it? The interesting stuff is the raw signature at the end of each packet detail <a id="_idIndexMarker148"/>line, which is made up of colon-delimited fields in the following order:</p>
<ol>
<li>Internet protocol version (for example, <em class="italic">4</em> means <em class="italic">IPv4</em>).</li>
<li>Initial <strong class="bold">Time To Live</strong> (<strong class="bold">TTL</strong>). It <a id="_idIndexMarker149"/>would be weird if you saw anything other than <em class="italic">64</em>, <em class="italic">128</em>, or <em class="italic">255</em>, but some OSes use different values; for example, you may see AIX hosts using <em class="italic">60</em>, and legacy Windows (‘95 and ‘98) using <em class="italic">32</em>.</li>
<li><em class="italic">IPv4</em> options length, which will usually be <em class="italic">0</em>.</li>
<li><strong class="bold">Maximum Segment Size</strong> (<strong class="bold">MSS</strong>), which is not to be confused with MTU. It’s the <a id="_idIndexMarker150"/>maximum size in bytes of a single TCP segment that the device can handle. The difference from MTU is that the TCP or IP header is not included in the MSS.</li>
<li>TCP receive window size, usually specified as a multiple of the MTU or MSS.</li>
<li>Window-scaling factor, if specified.</li>
<li>A comma-delimited ordering of the TCP options (if any are defined).</li>
<li>A field that the <strong class="source-inline">readme</strong> file calls <em class="italic">quirks</em> – weird stuff in the TCP or IP headers that can help us narrow down the stack creating it. Check out the <strong class="source-inline">readme</strong> file to see what kind of options are displayed here; an example is <strong class="source-inline">df</strong> for the <strong class="source-inline">don't fragment</strong> flag set.</li>
</ol>
<p>Why <a id="_idIndexMarker151"/>are we concerned with these options anyway? That’s what the fingerprint database is for, isn’t it? Of course, but part of the wild and wacky fun of this tool is the ability to customize your own signatures. You might see some funky stuff out there and it may be up to you, playing with a quirky toy in your lab, to make it easier to identify in the wild. However, of particular concern to the pen tester is the ability to craft packets that have these signatures to fool these NAC validation mechanisms. We’ll be doing that in the next section, but for now, you have the information needed to research the stack you want to spoof.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Spoofing the HTTP user agent</h2>
<p>Some budding hackers may be surprised to learn that browser user-agent data is a consideration <a id="_idIndexMarker152"/>in NAC systems, but it is commonly employed as an additional validation of a client. Thankfully for us, spoofing the <strong class="bold">HTTP user agent</strong> (<strong class="bold">UA</strong>) field is easy. Back in my day, we used custom UA strings <a id="_idIndexMarker153"/>with cURL, but now you have fancy browsers that allow you to override the default.</p>
<p>Let’s try to emulate an iPad. Sure, you can experiment with an actual iPad to capture the UA data, but UA strings are kind of like MAC addresses in that they’re easy to spoof, and detailed information is readily available online. So, I’ll just search the web for iPad UA data and go with the more common ones. As the software and hardware change over time, the UA string can change as well. Keep that in mind if you think all iPads (or any device) are created equal.</p>
<p>In Kali, we open up Mozilla Firefox and navigate to <strong class="source-inline">about:config</strong> in the address bar. Firefox will <a id="_idIndexMarker154"/>politely warn you that this area isn’t for noobs; go ahead and accept the warning. Now, search for <strong class="source-inline">useragent</strong> and you’ll see the configuration preferences that reference the UA:</p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<img alt="Figure 2.13 – Accessing advanced configuration of Firefox " height="755" src="image/Figure_2.13_B17616.jpg" width="1469"/>
</div>
</div>
<p class="figure-caption">Figure 2.13 – Accessing advanced configuration of Firefox</p>
<p>Note that there isn’t an override preference name with a string data type (so we can provide a <strong class="source-inline">useragent</strong> string). So, we have to create it. Go back to the search bar and type <strong class="source-inline">general.useragent.override</strong>. The only result here will be the option for you to create it; select the <strong class="bold">String</strong> data type and then click the plus sign:</p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<img alt="Figure 2.14 – Creating the UA override in Firefox Advanced Preferences " height="381" src="image/Figure_2.14_B17616.jpg" width="1362"/>
</div>
</div>
<p class="figure-caption">Figure 2.14 – Creating the UA override in Firefox Advanced Preferences</p>
<p>A field will appear where you type in the value for this new preference. Keep in mind that there <a id="_idIndexMarker155"/>isn’t a handy builder that will take specific values and put together a nicely formatted UA string; you have to punch it in character by character, so check the data you’re putting there for accuracy. You could pretend to be a refrigerator if you wanted to, but I’m not sure that helps us here:</p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<img alt="Figure 2.15 – Firefox is now telling the world it's an iPhone " height="382" src="image/Figure_2.15_B17616.jpg" width="1364"/>
</div>
</div>
<p class="figure-caption">Figure 2.15 – Firefox is now telling the world it’s an iPhone</p>
<p>I’ve just dumped in the UA data for an iPhone running iOS 12.2, opened a new tab, and verified what the web thinks I am:</p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Figure 2.16 – Confirming the UA spoof worked " height="807" src="image/Figure_2.16_B17616.jpg" width="834"/>
</div>
</div>
<p class="figure-caption">Figure 2.16 – Confirming the UA spoof worked</p>
<p>The <strong class="bold">Website Goodies</strong> page is now convinced that my Kali box is actually a friendly iPhone.</p>
<p>While <a id="_idIndexMarker156"/>we’re here, we should cover ourselves from JavaScript validation techniques as well. Some captive portals may inject some JavaScript to validate the operating system by checking the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) fields in the browser. You can manipulate these responses in the same <a id="_idIndexMarker157"/>way you did for the UA data:</p>
<p class="source-code">general.[DOM key].override</p>
<p>For example, the <strong class="source-inline">oscpu</strong> field will disclose the CPU type on the host, so we can override the response with the following:</p>
<p class="source-code">general.oscpu.override</p>
<p>As before, the data type is a string. This seems too easy, but keep in mind that the only code <a id="_idIndexMarker158"/>that will get the true information instead of your override preferences that are defined here is privileged code (for example, code with <strong class="source-inline">UniversalBrowserRead</strong> privileges). If it was easy enough to inject JavaScript that could run privileged code, then we’d have a bit of a security nightmare on our hands. This is one of those cases where the trade-off helps us.</p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Breaking out of jail – masquerading the stack</h1>
<p>Imagine you’re trying to get past a guarded door. The moment you open that door, a guard sees <a id="_idIndexMarker159"/>you and, identifying you as unauthorized, immediately kicks you out. But, suppose that an authorized person opens the door and props it open, and the guard will only verify the identity of the person walking through every 10 minutes or so, instead of continuously. They assume that an authorized person is using the door during that 10-minute window because they already authenticated the first person who opened it and propped it open.</p>
<p>Of course, this wouldn’t happen in the real world (at least, I sure hope not), but the principle is often seen even in sophisticated industry-standard NAC systems. Instead of people, we’re talking about packets on the network. As we learned from our fingerprinting exercise, the fine details of how a packet is formed betray a particular source system. These details make them handy indicators of a source. It quacks like a duck and it walks like a duck, so it is a duck, and definitely not a guy in a duck costume.</p>
<p>NACs employing this kind of fingerprinting technique will conduct an initial evaluation, and then assume the subsequent packets match the signature, just like our guard who figures the door is being used by the good guy after they do their first check. The reason for this is simple: performance. Whether the follow-up checks are every few minutes or never will depend on the NAC and configuration.</p>
<p>We’re going <a id="_idIndexMarker160"/>to introduce a tool called <strong class="bold">Scapy</strong> to demo this particular attack. As we progress through this book, you will see that Scapy could easily replace most of the tools that pen <a id="_idIndexMarker161"/>testers take for granted: port scanners, fingerprinters, spoofers, and so on. We’re going to do a quick demo for our NAC bypass here, but we will be leveraging the power of Scapy in the coming chapters.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Following the rules spoils the fun – suppressing normal TCP replies</h2>
<p>The details of a TCP handshake are beyond the scope of this chapter, but we’ll discuss the basics <a id="_idIndexMarker162"/>to understand what we need to do to pull off the masquerade. Most of us are familiar with the TCP three-way handshake:</p>
<ol>
<li value="1">The client sends a <strong class="source-inline">SYN</strong> request (<strong class="bold">synchronize</strong>).</li>
<li>The receiver replies with a <strong class="source-inline">SYN-ACK</strong> acknowledgment (<strong class="bold">synchronize-acknowledge</strong>).</li>
<li>The client confirms with an <strong class="source-inline">ACK</strong> acknowledgment; the channel is established, and communication can begin.</li>
</ol>
<p>This is a very simple description (I’ve left out sequence numbers; we’ll discuss those later), and it’s nice when it works as designed. However, those of you with any significant Nmap experience should be familiar with the funny things that can happen when a service receives something out of sequence. <em class="italic">Section 3.4</em> of RFC 793 is where the fun is really laid out, and I encourage everyone to read it. Basically, the design of TCP has mechanisms to abort if something goes wrong – in TCP terms, we abort with the <strong class="source-inline">RST</strong> control packet (<strong class="bold">reset</strong>) Make sure there is a space between (reset) and this new addition: (We’ll cover TCP and Nmap in greater detail in <a href="B17616_05_Final_VK_ePub.xhtml#_idTextAnchor085"><em class="italic">Chapter 5</em></a>, <em class="italic">Assessing Network Security</em>). This matters to us here because we’re about to establish a fraudulent TCP connection, designed to mimic one created by the Safari browser on an iPad. Kali will be very confused when we get our acknowledgment back:</p>
<ol>
<li value="1">Scapy uses our network interface to send the forged <strong class="source-inline">SYN</strong> packet.</li>
<li>The captive portal web service sends a <strong class="source-inline">SYN-ACK</strong> acknowledgment back to our address.</li>
<li>The Kali Linux system itself, having not sent any <strong class="source-inline">SYN</strong> requests, will receive an unsolicited <strong class="source-inline">SYN-ACK</strong> acknowledgment.</li>
<li>Per RFC specification, Kali decides something is wrong here and aborts with the <strong class="source-inline">RST</strong> packet, exposing our operating system’s identity.</li>
</ol>
<p>Well, this won’t do. We have to duct-tape the mouth of our Kali box until we get through validation. It’s easy enough with <strong class="source-inline">iptables</strong>.</p>
<p><strong class="source-inline">iptables</strong> is the Linux firewall. It works with policy chains where rules for handling packets are defined. There are three policy categories: <em class="italic">input</em>, <em class="italic">output</em>, and <em class="italic">forward</em>. Input is data destined for your machine, output is data originating from your machine, and forward is for data not really destined for your machine but that will be passed on to its destination. Unless you’re doing some sort of routing or forwarding – like during our man-in-the-middle <a id="_idIndexMarker163"/>attack earlier in the chapter – then you won’t be doing anything with the forward policy chain. For our purposes here, we just need to restrict data originating from our machine.</p>
<p>Extra credit if you’ve already realized that, if we aren’t careful, we’ll end up restricting the Scapy packets! So, what are we restricting, exactly? We want to restrict a TCP <strong class="source-inline">RST</strong> packet destined for port <strong class="source-inline">80</strong> on the gateway and coming from our Kali box. For our demonstration, we’ve set up the listener at <strong class="source-inline">192.168.108.239</strong> and our Kali attack box is at <strong class="source-inline">192.168.108.253</strong>:</p>
<p class="source-code"># iptables -F &amp;&amp; iptables -A OUTPUT -p tcp --destination-port 80 --tcp-flags RST RST -s 192.168.108.225 -d 192.168.108.215 -j DROP</p>
<p>Let’s break this down:</p>
<ul>
<li><strong class="source-inline">-F</strong> tells <strong class="source-inline">iptables</strong> to <em class="italic">flush</em> any currently configured rules. We were tinkering with rules for our ARP attack, so this resets everything.</li>
<li><strong class="source-inline">-A</strong> means <em class="italic">append</em> a rule. Note that I didn’t use the potentially misleading term <em class="italic">add</em>. Remember that firewall rules have to be in the correct order to work properly. We don’t need to worry about that here as we don’t have any other rules, so that’s for a different discussion.</li>
<li><strong class="source-inline">OUTPUT</strong> identifies the policy chain to which we’re about to append a rule.</li>
<li><strong class="source-inline">-p</strong> identifies the protocol – in this case, TCP.</li>
<li><strong class="source-inline">--destination-port</strong> and <strong class="source-inline">--tcp-flags</strong> are self-explanatory: we’re targeting any <strong class="source-inline">RST</strong> control packets destined for the HTTP port.</li>
<li><strong class="source-inline">-s</strong> is our source and <strong class="source-inline">-d</strong> is our destination.</li>
<li><strong class="source-inline">-j</strong> is the <em class="italic">jump</em>, which specifies the rule target. This just defines the actual action taken. If this were omitted, then nothing would happen, but the rule packet counter would increment.</li>
</ul>
<p>The following <a id="_idIndexMarker164"/>screenshot illustrates the output of the preceding command:</p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 2.17 – Listing our modifications in iptables " height="671" src="image/Figure_2.17_B17616.jpg" width="1208"/>
</div>
</div>
<p class="figure-caption">Figure 2.17 – Listing our modifications in iptables</p>
<p>We’re ready to send our forged packets to the captive portal authentication page.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Fabricating the handshake with Scapy and Python</h2>
<p>You can bring up the Scapy interpreter interface by simply commanding <strong class="source-inline">scapy</strong>, but for this discussion, we’ll be importing its power into a Python script.</p>
<p>Scapy is a <a id="_idIndexMarker165"/>sophisticated packet manipulation and <a id="_idIndexMarker166"/>crafting program. It is a Python program, but Python plays an even bigger role in Scapy as the syntax and interpreter for Scapy’s domain-specific language. What this means for the pen tester is a packet manipulator and forger with unmatched versatility because it allows you to literally write your own network tools, on the fly, with very few lines of code – and it leaves the interpretation up to you, instead of within the confines of what a tool author imagined.</p>
<p>What we’re doing here is a crash course in scripting with Python and Scapy, so don’t be intimidated. We will be covering Scapy and Python in detail later on in the book. We’ll step through everything happening here in our NAC bypass scenario so that, when we fire up Scapy in the future, it will quickly make sense. If you’re like me, you learn faster when you’re <a id="_idIndexMarker167"/>shoved into the pool. That being said, don’t <a id="_idIndexMarker168"/>neglect curling up with the Scapy documentation and some hot cocoa. The documentation on Scapy is excellent.</p>
<p>As you know, we set up our captive portal listener and OS fingerprinter at <strong class="source-inline">192.168.108.239</strong>. Let’s try to browse this address with an unmodified Firefox ESR in Kali and see what p0f picks up:</p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<img alt="Figure 2.18 – Busted: p0f knows it's Linux " height="840" src="image/Figure_2.18_B17616.jpg" width="1649"/>
</div>
</div>
<p class="figure-caption">Figure 2.18 – Busted: p0f knows it’s Linux</p>
<p>We can see in the very top line, representing the very first <strong class="source-inline">SYN</strong> packet received, that p0f has already identified us as a Linux client. Remember, p0f is looking at how the TCP packet is constructed, so we don’t need to wait for any HTTP requests to divulge system information. Linux fingerprints are all over the TCP three-way handshake before the browser has even established a connection to the site.</p>
<p>In our example, let’s emulate our trusty iPhone from earlier. Putting on our hacker hat (the white one, please), we can put two and two together:</p>
<ul>
<li>p0f has a database of signatures (<strong class="source-inline">p0f.fp</strong>) that it references in order to fingerprint a source.</li>
<li>Scapy allows us to construct TCP packets, and, with a little scripting, we can tie together several Scapy lines into a single TCP three-way handshake utility.</li>
</ul>
<p>We now have a recipe for our spoofing attack. Now, Scapy lets you construct communications in its interpreter, using the same syntax as Python, but what we’re going to do <a id="_idIndexMarker169"/>is fire up nano and put together a Python <a id="_idIndexMarker170"/>script that will import Scapy. We’ll discuss what’s happening here after we confirm the attack works:</p>
<pre class="source-code">#!/usr/bin/python3</pre>
<pre class="source-code">from scapy.all import *</pre>
<pre class="source-code">import random</pre>
<pre class="source-code">CPIPADDRESS = "192.168.108.239"</pre>
<pre class="source-code">SOURCEP = random.randint(1024,65535)</pre>
<pre class="source-code">ip = IP(dst=CPIPADDRESS, flags="DF", ttl=64)</pre>
<pre class="source-code">tcpopt = [("MSS",1460), ("NOP",None), ("WScale",2), ("NOP",None), ("NOP",None), ("Timestamp",(123,0)), ("SAckOK",""), ("EOL",None)]</pre>
<pre class="source-code">SYN = TCP(sport=SOURCEP, dport=80, flags="S", seq=1000, window=0xffff, options=tcpopt)</pre>
<pre class="source-code">SYNACK = sr1(ip/SYN)</pre>
<pre class="source-code">ACK = TCP(sport=SOURCEP, dport=80, flags="A", seq=SYNACK.ack+1, ack=SYNACK.seq+1, window=0xffff)</pre>
<pre class="source-code">send(ip/ACK)</pre>
<pre class="source-code">request = "GET / HTTP/1.1\r\nHost: " + CPIPADDRESS + "\rMozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148\r\n\r\n"</pre>
<pre class="source-code">PUSH = TCP(sport=SOURCEP, dport=80, flags="PA", seq=1001, ack=0, window=0xffff)</pre>
<pre class="source-code">send(ip/PUSH/request)</pre>
<pre class="source-code">RST = TCP(sport=SOURCEP, dport=80, flags="R", seq=1001, ack=0, window=0xffff)</pre>
<pre class="source-code">send(ip/RST)</pre>
<p>Once I’m <a id="_idIndexMarker171"/>done typing this up in nano, I save it as a <strong class="source-inline">.py</strong> file <a id="_idIndexMarker172"/>and <strong class="source-inline">chmod</strong> it to allow execution. That’s it – the attack is ready:</p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<img alt="Figure 2.19 – Our Scapy Python script is ready " height="821" src="image/Figure_2.19_B17616.jpg" width="1650"/>
</div>
</div>
<p class="figure-caption">Figure 2.19 – Our Scapy Python script is ready</p>
<p>The <strong class="source-inline">iptables</strong> outbound rule is set, and the script is ready to execute. Let it fly:</p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<img alt="Figure 2.20 – Scapy reporting the successful transmission " height="730" src="image/Figure_2.20_B17616.jpg" width="1265"/>
</div>
</div>
<p class="figure-caption">Figure 2.20 – Scapy reporting the successful transmission</p>
<p>That’s it – not <a id="_idIndexMarker173"/>very climactic at this end. But let’s take <a id="_idIndexMarker174"/>a look at the receiving end:</p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<img alt="Figure 2.21 – p0f thinks we're an iOS device " height="847" src="image/Figure_2.21_B17616.jpg" width="1650"/>
</div>
</div>
<p class="figure-caption">Figure 2.21 – p0f thinks we’re an iOS device</p>
<p>Voila! The OS fingerprinter is convinced that the packets were sent by an iOS device. When we scroll down, we can see the actual HTTP request with the UA data. At this point, the NAC allows access and we can go back to doing our usual business. Don’t forget to open up <strong class="source-inline">iptables</strong>:</p>
<p class="source-code"># iptables -F</p>
<p>So what happened here, exactly? Let’s break it down:</p>
<pre class="source-code">CPIPADDRESS = "192.168.108.215"</pre>
<pre class="source-code">SOURCEP = random.randint(1024,65535)</pre>
<p>We’re declaring <a id="_idIndexMarker175"/>a variable for the captive portal IP address <a id="_idIndexMarker176"/>and the source port. The source port is a random integer between <strong class="source-inline">1024</strong> and <strong class="source-inline">65535</strong> so that an ephemeral port is used:</p>
<pre class="source-code">ip = IP(dst=CPIPADDRESS, flags="DF", ttl=64)</pre>
<pre class="source-code">tcpopt = [("MSS",1460), ("NOP",None), ("WScale",2), ("NOP",None), ("NOP",None), ("Timestamp",(123,0)), ("SAckOK",""), ("EOL",None)]</pre>
<pre class="source-code">SYN = TCP(sport=SOURCEP, dport=80, flags="S", seq=1000, window=0xffff, options=tcpopt)</pre>
<pre class="source-code">SYNACK = sr1(ip/SYN)</pre>
<p>Now we’re defining the layers of the packets we will send. <strong class="source-inline">ip</strong> is the IP layer of our packet with our captive portal as the destination, a don’t-fragment flag set, and a TTL of <strong class="source-inline">64</strong>. Now, when Scapy is ready to send this particular packet, we’ll simply reference <strong class="source-inline">ip</strong>.</p>
<p>We define <strong class="source-inline">tcpopt</strong> with the TCP options we’ll be using. This is the meat and potatoes of the OS signature, so this is based on our signature research.</p>
<p>Next, we declare <strong class="source-inline">SYN</strong>, which is the TCP layer of our packet, defining our randomly chosen ephemeral port, the destination port <strong class="source-inline">80</strong>, the <strong class="source-inline">SYN</strong> flag set, a sequence number, and a window size (also part of the signature). We set the TCP options with our just-defined <strong class="source-inline">tcpopt</strong>.</p>
<p>Then, we send the <strong class="source-inline">SYN</strong> request with <strong class="source-inline">sr1</strong>. However, <strong class="source-inline">sr1</strong> means <em class="italic">send a packet, and record 1 reply</em>. The reply is then stored as <strong class="source-inline">SYNACK</strong>:</p>
<pre class="source-code">ACK = TCP(sport=SOURCEP, dport=80, flags="A", seq=SYNACK.ack+1, ack=SYNACK.seq+1, window=0xffff)</pre>
<pre class="source-code">send(ip/ACK)</pre>
<p>We sent a <strong class="source-inline">SYN</strong> packet with <strong class="source-inline">sr1</strong>, which told Scapy to record the reply – in other words, record the <strong class="source-inline">SYN-ACK</strong> acknowledgment that comes back from the server. That packet is now stored as <strong class="source-inline">SYNACK</strong>. So, now we’re constructing the third part of the handshake, our <strong class="source-inline">ACK</strong>. We use the same port information and switch the flag accordingly, and we take the sequence number from <strong class="source-inline">SYN-ACK</strong> and increment it by one. Since we’re just acknowledging <strong class="source-inline">SYN-ACK</strong> and thus completing the handshake, we only send this packet without needing a reply, so we use the <strong class="source-inline">send</strong> command instead of <strong class="source-inline">sr1</strong>:</p>
<pre class="source-code">request = "GET / HTTP/1.1\r\nHost: " + CPIPADDRESS + "\rMozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148\r\n\r\n"</pre>
<pre class="source-code">PUSH = TCP(sport=SOURCEP, dport=80, flags="PA", seq=1001, ack=0, window=0xffff)</pre>
<pre class="source-code">send(ip/PUSH/request)</pre>
<p>Now that the TCP session is established, we craft our <strong class="source-inline">GET</strong> request for the HTTP server. We’re <a id="_idIndexMarker177"/>constructing the payload and storing it as <strong class="source-inline">request</strong>. Note the use of Python syntax to concatenate the target IP address and create returns <a id="_idIndexMarker178"/>and newlines. We construct the TCP layer with the <strong class="source-inline">PSH + ACK</strong> flag and an incremented sequence number. Finally, we use another <strong class="source-inline">send</strong> command to send the packet using the same IP layer, the newly defined TCP layer called <strong class="source-inline">PUSH</strong>, and the HTTP payload as <strong class="source-inline">request</strong>:</p>
<pre class="source-code">RST = TCP(sport=SOURCEP, dport=80, flags="R", seq=1001, ack=0, window=0xffff)</pre>
<pre class="source-code">send(ip/RST)</pre>
<p>Finally, we tidy up, having completed our duty. We build a <strong class="source-inline">RST</strong> packet to tear down the TCP connection we have just established and send it with the <strong class="source-inline">send</strong> command.</p>
<p>I hope I have whetted your appetite for Scapy and Python, because we will be taking these incredibly powerful tools to the next level later in this book.</p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Summary</h1>
<p>In this chapter, we reviewed NAC systems and some of their techniques. We learned how to construct a wireless access point with Kali for a physical drop while masquerading as an authorized IP phone. We learned how to attack switched networks with layer-2 poisoning to intercept authentication data for authorized users while trapped in a restricted LAN. Other validation checks were discussed and methods for bypassing them were demonstrated.</p>
<p>We learned how operating system fingerprinting works and developed ways to research signatures for recon and construct spoofing attacks for a target system, using the iOS running on an iPad as an example. We reviewed a more advanced operating system fingerprinting method, fingerprinting the stack, and introduced the packet manipulation utility Scapy to demonstrate a stack masquerade by writing up a Python script.</p>
<p>In the next chapter, we will take our sniffing and spoofing to the next level, and even combine the two concepts to create a clean and quiet man-in-the-middle attack.</p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li value="1">What does <strong class="source-inline">apd</strong> in <strong class="source-inline">hostapd</strong> stand for?</li>
<li>How can you quickly tell whether your wireless card supports access point mode?</li>
<li>What does the <strong class="source-inline">hostapd</strong> configuration parameter <strong class="source-inline">ignore_broadcast_ssid</strong> do?</li>
<li><strong class="source-inline">255.255.255.255</strong> is the broadcast address of the ____________.</li>
<li>You’re running an ARP poisoning attack. You know the target and gateway IP addresses, so you immediately fire up <strong class="source-inline">arpspoof</strong>. Suddenly, communication between the target and the gateway is broken. What happened?</li>
<li>What do the first three octets and the last three octets of the MAC address represent respectively?</li>
<li>The MSS and the MTU are the same size. True or false?</li>
<li>What does the <strong class="source-inline">-j</strong> flag do in <strong class="source-inline">iptables</strong>?</li>
<li>You have defined the IP and TCP layers of a specially crafted packet as <strong class="source-inline">IP</strong> and <strong class="source-inline">TCP</strong> respectively. You want Scapy to send the packet and save the reply as <strong class="source-inline">REPLY</strong>. What’s the command?</li>
</ol>
<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Further reading</h1>
<p>For more information regarding the topics that were covered in this chapter, take a look at the following resource: </p>
<ul>
<li>Scapy documentation: <a href="https://scapy.readthedocs.io/en/latest/">https://scapy.readthedocs.io/en/latest/</a></li>
</ul>
</div>
</div></body></html>