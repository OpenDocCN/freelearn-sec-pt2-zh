<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer130">
<h1 id="_idParaDest-86"><em class="italic"><a id="_idTextAnchor085"/>Chapter 5</em>: Assessing Network Security</h1>
<p>We’ve had a lot of fun poking around the network in the first few chapters. There has been an emphasis on man-in-the-middle attacks, and it’s easy to see why – they’re particularly devastating when performed properly. However, your focus when educating your clients should be on the fact that these are fairly old attacks, and yet, they still often work.</p>
<p>One reason is that we still rely on very old technology in our networks, and man-in-the-middle attacks generally exploit inherent design vulnerabilities at the protocol level. Consider the internet protocol suite, underlying the internet as we know it today – the original research that ultimately led to TCP/IP dates back to the 1960s, with official activation and adoption gaining traction in the early 1980s. Old doesn’t necessarily imply insecure, but the issue here is the context in which these protocols were designed – there weren’t millions upon millions of devices attached to networks of networks, operated by everyone on the street from the teenager in his parents’ basement to his grandmother, and they weren’t supported by network stacks embedded into devices ranging from physical mechanisms in nuclear power plants down to a suburban home’s refrigerator, sending packets to alert someone that they’re running low on milk. This kind of adoption and proliferation wasn’t a consideration; the reality was that physical access to nodes was tightly controlled. This inherent problem hasn’t gone unnoticed—the next version of the internet protocol, IPv6, was formally defined in the <strong class="bold">Request for Comments</strong> (<strong class="bold">RFC</strong>) document during the late 1990s (with the most recent RFC being published in 2017). We’ll touch on IPv6 in this chapter, but we’ll also demonstrate how to practically interface IPv4 with IPv6. This highlights that adoption has been slow and a lot of effort has been placed into making IPv6 work well with IPv4 environments, ensuring that we’re going to be playing with all the inherent insecurity goodies of IPv4 for some time to come.</p>
<p>As a pen tester on a job, it’s exciting to watch that shell pop up on your system. But when the fun and games are over, you’re left with a mountain of findings that will be laid out in a report for your client. Remember that your job is to help your client secure their enterprise, and it’s about more than just software flaws. Look for opportunities to educate as well as inform.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Network probing with Nmap</li>
<li>Exploring binary injection with BetterCAP</li>
<li>Smuggling data – dodging firewalls with HTTPTunnel</li>
<li>IPv6 addressing, recon, man-in-the-middle, and mapping from IPv4</li>
</ul>
<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>Technical requirements</h1>
<p>For this chapter, you will need a laptop running Kali Linux.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor087"/>Network probing with Nmap</h1>
<p>Let’s play <em class="italic">Jeopardy</em>. Here’s the answer – “<em class="italic">This network mapping tool, first released 24 years ago, caused a stir when its accurate portrayal in Hollywood films prompted organizations such as Scotland Yard to remind the public that its use is potentially illegal</em>.” If you said, “<em class="italic">What is Nmap?</em>” as the question, then you have won this Daily Double. Nmap <a id="_idIndexMarker333"/>is the go-to tool for just about anyone working on networked computers. Nmap means <strong class="bold">network mapper</strong>, and it’s useful in a wide variety of disciplines <a id="_idIndexMarker334"/>outside of security: network engineering, systems administration, and so on. Nmap’s innovation is that it allows the probes that you send to be customized to a high degree, allowing for unique responses that reveal a great deal of information about the target, and even finding shortcuts through a firewall.</p>
<p>Nmap is the embodiment of the colloquialism <em class="italic">Swiss-army knife</em>, so let’s break down its key purposes.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor088"/>Host discovery</h2>
<p>Nmap <a id="_idIndexMarker335"/>can perform ping and port scans, but <a id="_idIndexMarker336"/>this is no ordinary scanner – it allows you to send a variety of probes to improve the chances of finding a target. You can simply ping targets, or you can send special lightweight probes to certain ports. The whole idea is sending something that elicits a response from the target. The flexibility here allows Nmap to function as an ideal sidekick for any administrator as well as a pen tester.</p>
<h3>List Scan (-sL)</h3>
<p>This <a id="_idIndexMarker337"/>merely lists hosts for scanning, including reverse DNS lookups along the way. However, no traffic is sent to the targets. This is useful for validating the range of IPs you’re working with.</p>
<h3>Ping Scan (-sn)</h3>
<p>Ping Scan<a id="_idIndexMarker338"/> allows you to effectively run a <em class="italic">ping sweep</em> against the targets – that is, there is no port scanning, but unlike the List Scan, we are sending data in the form of pings (specifically, an ICMP ECHO request) to the targets. There is <em class="italic">some</em> port activity with the default settings – Nmap will send an SYN to port <strong class="source-inline">443</strong>, an ACK to port <strong class="source-inline">80</strong>, and an ICMP timestamp request. This can be combined with the discovery probes discussed next, in which case this default behavior is skipped.</p>
<h3>Skip host discovery (-Pn)</h3>
<p>This is a<a id="_idIndexMarker339"/> setting for Nmap users who know what they want: it won’t bother determining if hosts are up, so it effectively treats <em class="italic">every IP address in the range</em> as online. There may be times when you will want this, such as if you don’t fully trust the results of host discovery. Firewalls can be configured to make online hosts silent to popular discovery methods. The upside of this setting is that you can be sure no host is ignored when the port scan starts. The downside is that the scan will take a lot longer, as Nmap will be waiting for responses and timing out for every specified port on every specified IP address – this means a whole lot of probing computers that aren’t even there. </p>
<h3>Specialized discovery probes (-PS, -PA, -PU, -PY, -PO)</h3>
<p>Somewhere<a id="_idIndexMarker340"/> between using the <strong class="source-inline">ping</strong> utility to find hosts and running port scans to find services lies Nmap’s host discovery options. SYN Ping (<strong class="source-inline">-PS</strong>), for example, sends an empty SYN packet either to a default port of 80 or to one you specify. If the host responds, no connection is established, but it tells Nmap that the host is there. Very similar to this discovery option is ACK Ping (<strong class="source-inline">-PA</strong>), which does the same thing – it sends an empty packet but with the <strong class="source-inline">ACK</strong> flag set. This option can help in discovering hosts behind firewalls configured to drop SYN requests but aren’t fancy enough to<a id="_idIndexMarker341"/> drop an unsolicited ACK. UDP Ping is similar and lets you configure specific ports, but it uses UDP instead of TCP. Since there is no three-way handshake in UDP, what Nmap is waiting for is an ICMP <strong class="source-inline">port unreachable</strong> message, which proves the host is there. The port number matters less here; in fact, you’ll want to avoid the common ports. The default is <strong class="source-inline">40125</strong> – surely an uncommonly used port number for<a id="_idIndexMarker342"/> hosting services. <strong class="bold">Stream Control Transmission Protocol</strong> (<strong class="bold">SCTP</strong>) also has a discovery option along with a scanning option: <strong class="source-inline">-PY</strong> sends an SCTP message with an INIT chunk set, waiting for either an ABORT or INIT-ACK in response. Another fine-tuned probe that can be sent is the IP Protocol Ping (<strong class="source-inline">-PO</strong>), which sends packets with a specific protocol defined in the header. For example, suppose you want to try probing for hosts with IGMP. You may get an <strong class="source-inline">unreachable</strong> message, or even an IGMP response – in either case, the host proved its existence. </p>
<h3>Ping on steroids (-PE, -PP, -PM)</h3>
<p>You’re <a id="_idIndexMarker343"/>probably already aware that often, a host won’t reply to a basic ping – administrators often configure hosts and firewalls to drop these ubiquitous ECHO requests, especially from untrusted networks. It’s not uncommon for the <em class="italic">other</em> message types in ICMP to be overlooked. This is where the different ping options come into play. You can use <strong class="source-inline">–PE</strong> for that classic ping taste, but <strong class="source-inline">–PP</strong> and <strong class="source-inline">–PM</strong> allow you to send timestamp queries and address mask queries over ICMP, respectively. </p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>Port scanning – scan types</h2>
<p>Nmap has come a long <a id="_idIndexMarker344"/>way from its debut as a user-friendly and fast port scanner. It allows for fine-tuning to hone in on the actual condition of your target with incredible reliability. However, any tool can be quickly whipped together and trusted to try connecting to ports – where Nmap earns its stripes is in its ability to send carefully crafted unexpected messages and<a id="_idIndexMarker345"/> analyze the response. Let’s take a look at the different techniques.</p>
<h3>TCP SYN scan (-sS)</h3>
<p>This scan<a id="_idIndexMarker346"/> sends the initial synchronize (SYN) request of a TCP three-way handshake but with no intention of completing the transaction. The goal here is to listen for the expected SYN-ACK of a service ready for communication, and if received, mark the port as open. This technique is sometimes <a id="_idIndexMarker347"/>called <strong class="bold">stealth scanning</strong>, but I would regard it as a bit of a misnomer – any intrusion detection system will know a port scan when it sees one. It’s stealthy in the sense that the transaction is never completed, meaning there’s no connection to pass up the remaining OSI layers. Therefore, the application never gets a connection and won’t log one. Don’t be discouraged from using it – it’s better to be a network nuisance alone than a network nuisance <em class="italic">and</em> an application log nuisance. It also has the potential for speed, as we aren’t waiting for established connections. </p>
<h3>TCP Connect() scan (-sT) </h3>
<p>If you <a id="_idIndexMarker348"/>ask someone the difference between SYN scans and the Connect() scan, a common answer is <em class="italic">reliability</em>. SYN scans, being half-opened, may give unexpected results; but what about a completed three-way handshake? That’s a demonstrated open port that’s ready for communication. The reality is that SYN scans are plenty reliable against any proper and compliant TCP stack – there isn’t a lot of room for interpretation when you get an SYN-ACK response from an SYN. The practical difference between the two options is your local privileges. This won’t mean much to all of you Kali hackers – you’re already running as root. But perhaps you have lowly user privileges – the fancier SYN scan isn’t an option since it is a customized packet and thus requires raw socket privileges. The Connect() scan makes use of the <strong class="source-inline">connect()</strong> system call, just as any ordinary program that needs to establish a connection would. It’s reliable, but it’s slower, and the target application will notice it. </p>
<h3>UDP scan (-sU)</h3>
<p>I could<a id="_idIndexMarker349"/> tell you a joke about UDP, but you may not get it. Get it? The good ol’ fire-and-forget <strong class="bold">User Datagram Protocol</strong> is often ignored by pen testers, but <a id="_idIndexMarker350"/>the potential for attack vectors is the same as with the more obvious TCP. What’s counterintuitive about UDP scanning is speed – though UDP is associated with the blistering fast streaming services of today, thanks to the eliminated need to wait for confirmation on every packet, an open UDP port may not even send a response to Nmap’s probe. There’s no need for a handshake, after all. Knowing the difference between a lost datagram and one that was received but unanswered means Nmap has to retry and wait to decide. This is less of an issue with the well-known<a id="_idIndexMarker351"/> protocols such as SNMP, where Nmap knows to send data specific to that protocol. </p>
<h3>SCTP INIT and COOKIE ECHO scans (-sY / -sZ)</h3>
<p>These<a id="_idIndexMarker352"/> scans make use of SCTP, which is a blend of TCP reliability and UDP speed. You may not encounter a need for it, but Nmap is ready for it just in case. INIT is the SCTP equivalent of an SYN request, and INIT-ACK is the expected response when the port is open. COOKIE ECHO is a special response; as designed, the<a id="_idIndexMarker353"/> remote system sends a <strong class="bold">cookie</strong> as part of its INIT-ACK, and the initiator responds with COOKIE ECHO. However, an unsolicited COOKIE ECHO will just be dropped by an open port, allowing Nmap to differentiate between open and closed ports. Like the TCP NULL/FIN/Xmas scans discussed next, this is an example of Nmap’s genius in exploiting an RFC technicality: things are <em class="italic">supposed</em> to go a certain way, and the RFCs prescribe what to do when they don’t. Nmap exploits this.</p>
<h3>TCP NULL/FIN/Xmas/Maimon scans (-sN / -sF / -sX / -sM)</h3>
<p>To <a id="_idIndexMarker354"/>understand these scans, let’s dive into some theories for a bit. Deep in the RFC for <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>), in the <em class="italic">Event Processing</em> section of the functional <a id="_idIndexMarker355"/>specification, there are some key prescriptions for handling weird events. Every TCP segment has a header containing information about the role that particular chunk of the payload plays in a connection. It’s a fixed length and contains information such as the source port and destination port. There is a section<a id="_idIndexMarker356"/> of <strong class="bold">reserved bits</strong> that are <a id="_idIndexMarker357"/>used for setting <strong class="bold">flags</strong>. This is where a packet is defined as a, say, SYN request. If these flags are set strangely, the design specification dictates what to do about it. Here’s an example from the RFC regarding closed ports – “<em class="italic">If the state is CLOSED, then all the data in the incoming segment is discarded. An incoming segment containing an RST is discarded. An incoming segment not containing an RST causes an RST to be sent in response</em>.” Another key point is on the next page, which discusses open ports – “<em class="italic">An incoming RST segment could not be valid, since it could not have been sent in response to anything sent by this incarnation of the connection. So, you are unlikely to get here, but if you do, drop the segment, and return</em>.” Even though this specific event is called out as being invalid, the specification still describes how to handle it. Thus, Nmap can infer the state of the port.</p>
<p>The <a id="_idIndexMarker358"/>NULL scan (<strong class="source-inline">-sN</strong>) doesn’t set any flags; that is, the reserved bits are all zero. The FIN scan (<strong class="source-inline">-sF</strong>) only sets the FIN bit. The Xmas scan (<strong class="source-inline">-sX</strong>) sets FIN (gracefully close the connection), PSH (push the data to the application immediately), and URG (some or all of the payload should be prioritized) bits all at once – a situation that wouldn’t happen in a legitimate context. This causes the packet to be <em class="italic">lit up</em> like a Christmas tree. The Maimon scan (<strong class="source-inline">-sM</strong>) is similar to the Xmas scan, except it sets FIN/ACK.</p>
<p>Now, let’s pull ourselves out of the theory and jump back into the practical – are these scans useful? To answer this, keep the main implication of this technique in mind: it’s only meaningful against TCP stacks that have faithfully executed the RFC’s specification. There are no RFC cops who come knocking on your door if your software fails to silently drop a weird packet. A notable example is the Windows <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>), which will send an RST (a forceful way of shutting down a connection) in response to these silly packets, regardless of port state. Some BSD-based systems will drop a Maimon packet instead of an RST when the port is open, creating a rare scenario where that scan type is meaningful. Speaking for myself, I have very rarely used these scans.</p>
<h3>TCP ACK scan (-sA)</h3>
<p>Similarly, the<a id="_idIndexMarker359"/> ACK scan exploits a nuance in how stacks reply to strangeness: only the ACK flag is set. A port that receives such a packet will send back an RST, regardless of its state – so, this isn’t for determining state. If we get an RST back, we’ll know that the message got to our target. Thus, it’s a relatively stealthy way to map out firewall holes. </p>
<h3>Zombie scan (-sI)</h3>
<p>Now, we’re <a id="_idIndexMarker360"/>getting to my favorite scan type: the idle zombie scan. It is <em class="italic">actually</em> stealthy – you don’t send any data whatsoever to your target. The only caveat is similar to the previous discussion about how different systems are designed – the idle zombie scan requires a host that will <em class="italic">play by the rules</em> of IP packet incrementation. Let’s dive a little deeper into the theory. So, suppose I send an SYN packet to a host on an open port. That host will reply with an SYN-ACK and wait for our final ACK. Now, suppose I send an SYN packet to a closed port on that host. It’ll angrily fire back an RST and I’ll know the port isn’t open for a chat. Let’s go through this again, but this time, I will <em class="italic">forge</em> the return address – the address of the zombie – on my SYN request. That open port will reply SYN-ACK and send it to the <em class="italic">forged</em> address, not mine. Let’s do this with the closed port, too: our target fires back an RST but again, it’s addressed to the forged address. We never get a reply.</p>
<p>The genius of<a id="_idIndexMarker361"/> the idle zombie scan is that it leverages both the nature of how TCP handles weirdness per the RFC, as discussed previously, and the fact that every single packet on any network has a fragment identification number. Let’s consider a few conditions:</p>
<ul>
<li>The zombie is running an OS that merely <em class="italic">increments</em> the fragment ID number for each one it sends.</li>
<li>The zombie is truly <em class="italic">idle</em>.</li>
<li>The zombie’s TCP stack behaves as expected when it receives an unsolicited SYN/ACK: it responds with an RST, whereas the unsolicited RST is <em class="italic">ignored</em>.</li>
</ul>
<p>The zombie scan monitors the zombie with pings and carefully tracks the incrementation while sending carefully timed forged SYN packets to the target. It’s truly a beautiful thing to behold.</p>
<p>All of that being said, how practical is this attack? The challenge today is finding zombies that are truly idle. This kind of analysis requires high confidence that any packets sent by the zombie during the scan are related to our scan – it’s hard to have this sort of confidence. The other concern has to do with how faithful the zombie’s stack is to the RST; if it’s going to fire RSTs back to our target with every unsolicited message that’s received, we can’t infer anything.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Port scanning – port states</h2>
<p>In <a href="B17616_09_Final_VK_ePub.xhtml#_idTextAnchor165"><em class="italic">Chapter 9</em></a>, <em class="italic">PowerShell Fundamentals</em>, we’ll build a basic port scanner with PowerShell. While handy, you’ll notice that it doesn’t discriminate the results beyond an open or closed port. Nmap<a id="_idIndexMarker362"/> reports the port status as one of six states. The first three are the most commonly encountered for most enumeration exercises, while the last three are special responses based on the different scan techniques:</p>
<ul>
<li><strong class="source-inline">open</strong>: As its <a id="_idIndexMarker363"/>name suggests, the reported port is actively accepting connection requests; that is, a service on the target is up and available to serve clients.</li>
<li><strong class="source-inline">Closed</strong>: This <a id="_idIndexMarker364"/>is where the granularity of Nmap’s report starts to show. Suppose that on one target, a port isn’t being blocked by any kind of packet filtering mechanism, but there’s simply no service running there. Now, suppose that, on a different target, we can’t tell if there’s a service or not because there’s an active filtering mechanism in play. Your <em class="italic">run-of-the-mill</em> port scan will not distinguish those conditions – Nmap will. Closed is the former scenario – the port is reachable and can respond to the probes, but there’s no service present. The next state is where filtering comes into play.</li>
<li><strong class="source-inline">Filtered</strong>: Now, Nmap<a id="_idIndexMarker365"/> has established that something is preventing our probes from getting to this port, whether it’s a network-based firewall, host-based firewall, or even some kind of routing rule.</li>
<li><strong class="source-inline">Unfiltered</strong>: This <a id="_idIndexMarker366"/>is a special result from ACK scans that shows that the port is accessible, but Nmap couldn’t establish its state. The other scan types can resolve this ambiguity. Narrowing down the ports where you may need to resort to an SYN scan can help with stealth.</li>
<li><strong class="source-inline">Open|Filtered</strong>: This is to be read, in plain English, as “open or filtered.” It’s one of the<a id="_idIndexMarker367"/> special results for certain scan types and it means Nmap can’t be sure if the port is open or filtered when running a scan type where open ports are expected to give no response. For example, consider the UDP scan that we discussed previously. UDP is connectionless, so an open UDP port may not respond to our probes. Another example is the NULL or Xmas scans, which rely on the RFC’s prescription of merely dropping weird packets received at open ports – Nmap is expecting that there will be no response. Naturally, this leaves us asking, “<em class="italic">How do we know that there isn’t a firewall that silently dropped our packet, and it never even made it to the port?</em>” This is why Nmap is telling you “open or filtered.” </li>
<li><strong class="source-inline">Closed|Filtered</strong>: Just<a id="_idIndexMarker368"/> like the previous one, but “<em class="italic">closed</em>” instead of “<em class="italic">open</em>” – Nmap can’t tell if the targeted port is actually closed or if it’s just being filtered. The special situation here is the idle zombie scan. Recall that if our probe hits an open port on the target, the target will reply SYN/ACK and send it to the zombie. The zombie, not expecting any SYN/ACK from our target, responds with an RST packet – thus, this packet increments the fragment ID counter and Nmap will consider the port open. But what if our probe hits a closed port on the target? Then the target sends an RST to the zombie – and if the zombie is following the functional specification, it will <em class="italic">ignore</em> our target’s RST packet. Thus, there is no response and no fragment ID is incremented. Now, suppose the port can’t be reached because of a firewall – then nothing ever reaches the target, which means it has no reason to send anything to the zombie, which accordingly sends no packets to increment the fragment ID. From the perspective of the Nmap scanner that is monitoring the zombie, there’s no way to know the difference between closed and filtered. </li>
</ul>
<p>Now that we have a nice foundation for Nmap discovery, probing, and the responses from these probes, it’s time to dive into Nmap’s ability to evade detection. </p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Firewall/IDS evasion, spoofing, and performance</h2>
<p class="author-quote">“Oh, the Noise! Noise! Noise! Noise! That’s one thing he hated!”</p>
<p class="author-quote">–Dr. Seuss</p>
<p>We have <a id="_idIndexMarker369"/>already covered some scanning techniques <a id="_idIndexMarker370"/>that can serve as firewall or IDS evasion: the NULL, FIN, Xmas, and Maimon scans. However, keep in mind that this tool is fairly old <a id="_idIndexMarker371"/>and has been in active development for several years. The clever tricks that Nmap can cook up have been known for a long time, so any IDS will know something is up. The story isn’t over, though: advancements in technology have been accompanied by an increase in network chatter. Just loading a simple website takes a lot more data than it used to, and there are many legitimate reasons why a host may be querying others in a way that’s exciting for hackers. This all adds up to <em class="italic">noise</em>. Add into this equation the business component: your clients are businesses first and foremost. This is the entire reason your role even exists, so respect it! Business needs will always clash with security needs, and the ideal solution is going to be a delicate balance between the two. What this means for us during our Nmap analysis is simple – attempting to research every single potentially suspicious activity is simply unfeasible. Thus, the defense tends to work with <em class="italic">thresholds</em>. There are two main perspectives here: you can confuse the defender, or you can fly under the radar. </p>
<p>First, let’s look at <a id="_idIndexMarker372"/>confusing the defender. Nmap <a id="_idIndexMarker373"/>lets you fragment its packets (<strong class="source-inline">-f</strong>), and you can precisely define how fragmented things will get. The idea here is that there are just so many packets for any given task that it makes it harder for the<a id="_idIndexMarker374"/> defenders to screen them. Keep in mind that firewalls and hosts can choose to queue up all the fragments – however, this might be impractical for large networks. One of my favorite ways of creating confusion is the decoy option (<strong class="source-inline">-D</strong>), which performs your scanning activities normally but also generates packets with spoofed return addresses. Unlike the idle zombie scan, we get our probes back here; however, the defender will see any number of <em class="italic">other</em> hosts scanning them, too! The best way for this to work is by using hosts that are up, so use IP addresses from your host discovery phase. You can also just do a good old-fashioned source address spoof (<strong class="source-inline">–S</strong>), but as you may imagine, you won’t get the responses back. There might be situations in which this source address spoof is useful, though. For example, perhaps you’re able to intercept all the traffic so that you can see the response anyway. The other kind of source spoof that is useful is spoofing the port number (<strong class="source-inline">-g</strong>). Due to oversight or otherwise, many firewalls don’t restrict source ports. An additional step you can take when creating confusion is appending custom data to the packets (<strong class="source-inline">--data</strong> for hex and <strong class="source-inline">--data-string</strong> for strings). This is very much dependent on the situation, but you can imagine the amount of power Nmap gives you over your probes.</p>
<p>The other perspective is flying under the radar. Any intrusion detection system has some means of logging something that triggered a rule, and it’s surprising how often we can go unnoticed simply by being slow. Though Nmap is well-known for its speed, sometimes, that’s the opposite of what you need – and not just for dodging defenses, either. You may be stuck with rate limiting or a bad connection. Nmap gives you some timing control by offering both timing templates (<strong class="source-inline">-T</strong>) and the ability to define the time between probes and parallelization. Let’s take a look at the templates, which have predefined values for the<a id="_idIndexMarker375"/> time between probes and how parallelization works. First, you have <strong class="bold">paranoid</strong> (<strong class="source-inline">-T0</strong>). As its name suggests, it is extremely slow – 5 minutes between probes and no parallelization. The next level up is <strong class="bold">sneaky</strong> (<strong class="source-inline">-T1</strong>), which is more<a id="_idIndexMarker376"/> reasonable while still being evasive. The delay between probes reaches 15 seconds, but packets are still sent one at a time. Next <a id="_idIndexMarker377"/>is <strong class="bold">polite</strong> (<strong class="source-inline">-T2</strong>), which increases the speed to 0.4 seconds between probes. This sounds decently fast but it is still well below Nmap’s ability – it is “<em class="italic">polite</em>” because it’s not trying to be evasive; it’s just being nice to resources. The default <a id="_idIndexMarker378"/>setting of Nmap is called <strong class="bold">normal</strong> (<strong class="source-inline">-T3</strong>, though <a id="_idIndexMarker379"/>you’d merely omit this flag for the same settings), where <a id="_idIndexMarker380"/>we start parallelizing <a id="_idIndexMarker381"/>our probes. The <strong class="bold">aggressive</strong> (<strong class="source-inline">-T4</strong>) and <strong class="bold">insane</strong> (<strong class="source-inline">-T5</strong>) modes are useful when speed is a paramount concern and you have a very fast network. <strong class="bold">aggressive</strong> mode is fine for assessing large organizations<a id="_idIndexMarker382"/> with zippy resources, but <strong class="bold">insane</strong> mode is <a id="_idIndexMarker383"/>probably better for testing or demonstration purposes, or on very fast networks. After all, the author of the tool <em class="italic">did</em> warn us when he called it insane.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Service and OS detection</h2>
<p>There’s<a id="_idIndexMarker384"/> blindly knocking on a door, and then there’s reading all the signage out front. Nmap can go well beyond merely establishing the presence of a service – it will have a nice chat with it and gather information about the service. While it runs, Nmap references a database to parse the information and return version information. You can tweak the <em class="italic">intensity</em> of the version analysis (<strong class="source-inline">--version-intensity</strong>) to a level between 0 and 9. The default is already 7, so you won’t need 8 or 9 until you suspect something esoteric.</p>
<p>Similar to a database that helps Nmap parse version information out of conversations with services, Nmap also has a database that contains more than 2,600 OS <em class="italic">fingerprints</em> that allow it to determine the host OS based on how the TCP/IP stack behaves. We explored this concept in <a href="B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a><em class="italic">, Bypassing Network Access Control</em>, when we used <strong class="source-inline">p0f</strong> to fingerprint OS fingerprints. It considers things such as Time To Live, Maximum Segment Size, and more to guess the OS that sent those packets. Keep in mind that it is a guess, so its reliability can vary. Also, keep in mind that, as we have learned, you can use the database to build custom packets (for example, with Scapy) that Nmap will say came from any OS you please. Maybe it’s a Windows XP box, maybe it’s a Linux box that wants to look like XP.</p>
<h4>The Nmap Scripting Engine (NSE)</h4>
<p>If I had to <a id="_idIndexMarker385"/>reduce Nmap to just two core features, I’d call it a port scanner and a networking scripting engine. This is where Nmap is blurring the lines between a simple network testing utility up to a vulnerability scanner and a pen testing sidekick. Using the Lua programming language, anyone can create scripts to automate Nmap to not just conduct all of the recon discussed previously, but even probe for and (safely) exploit vulnerabilities. In Kali, head on over to <strong class="source-inline">/usr/share/nmap/scripts</strong> and punch in <strong class="source-inline">ls | grep "http"</strong> to see what’s available for just that protocol alone.</p>
<p>By way of example, let’s use Nmap to look for VNC connections that don’t require authentication. We will invoke the script in question with <strong class="source-inline">–-script &lt;name&gt;</strong>, which you can copy right out of the <strong class="source-inline">scripts</strong> folder (leave out the <strong class="source-inline">.nse</strong> extension). Then, running as root, we will execute <strong class="source-inline">nmap -–script vnc-brute –p 5900 -–open 192.168.108.0/24</strong> and wait for the scan to complete:</p>
<div>
<div class="IMG---Figure" id="_idContainer094">
<img alt="Figure 5.1 – Running Nmap with an NSE script enabled " height="577" src="image/Figure_5.01_B17616.jpg" width="662"/>
</div>
</div>
<p class="figure-caption">Figure 5.1 – Running Nmap with an NSE script enabled</p>
<p>As you can see, Nmap<a id="_idIndexMarker386"/> is doing its job – and for each host, the script steps in and does its job. </p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Hands-on with Nmap</h2>
<p>Okay, that’s a<a id="_idIndexMarker387"/> lot of theory – now, let’s sit down with Nmap. I think your first step should always be to run Nmap with no arguments, causing the help screen to appear:</p>
<div>
<div class="IMG---Figure" id="_idContainer095">
<img alt="Figure 5.2 – Running Nmap with no arguments " height="273" src="image/Figure_5.02_B17616.jpg" width="636"/>
</div>
</div>
<p class="figure-caption">Figure 5.2 – Running Nmap with no arguments</p>
<p>I’ve done this<a id="_idIndexMarker388"/> so that we can step through building our command. This help screen is fantastic, allowing us to use a command-line tool while offering the experience of ordering a three-course meal. <strong class="source-inline">Host Discovery</strong> is the crab cake appetizer, <strong class="source-inline">Scan Techniques</strong> is the steak, <strong class="source-inline">Service Detection</strong> is the side of potatoes (or vegetables if you’re watching your carbs), and so on. Let’s build our scenario first.</p>
<p>Let’s suppose I want to simply look for web servers on either port 80 or 443. I don’t want to discover which ones are up first; I want to check every single IP in the range, just so I know I’m not missing anything. The web servers are always found in the 10-20 section of several slash-24 subnets; that is, of the 256 possible IPs ranging from 0 to 255, our targets will end in a number between 10 and 20. The range starts at <strong class="source-inline">10.10.105.0</strong> and ends at <strong class="source-inline">10.10.115.255</strong>. I want to use half-open scanning so that the application doesn’t log a connection. If servers are discovered, I want to grab version information. I want this to be reasonably fast, but I’ve been asked by my client’s networking administrator to be friendly with the probes. Finally, I want the results to only include hosts where these ports have been established as open or possibly open. Okay, let’s look at our menu, saving the target specification for last:</p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<img alt="Figure 5.3 – Identifying our desired host discovery option " height="199" src="image/Figure_5.03_B17616.jpg" width="687"/>
</div>
</div>
<p class="figure-caption">Figure 5.3 – Identifying our desired host discovery option</p>
<p>I don’t want <a id="_idIndexMarker389"/>to establish if a host is online – I just want to get to port scanning. So, my first argument is <strong class="source-inline">–Pn</strong>. Now, let’s look at the scan techniques: </p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<img alt="Figure 5.4 – Identifying our desired scan technique " height="165" src="image/Figure_5.04_B17616.jpg" width="552"/>
</div>
</div>
<p class="figure-caption">Figure 5.4 – Identifying our desired scan technique</p>
<p>I want a half-open scan, so I have picked <strong class="source-inline">–sS</strong>. Now, let’s look at the port specification and service detection setting: </p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<img alt="Figure 5.5 – Identifying our desired port range and service detection setting " height="256" src="image/Figure_5.05_B17616.jpg" width="671"/>
</div>
</div>
<p class="figure-caption">Figure 5.5 – Identifying our desired port range and service detection setting</p>
<p>I know my ports are 80 and 443, and I only want to see confirmed open ports, so the next command is <strong class="source-inline">–p 80,443 --open</strong>. I want version information from the servers I find, so I have added <strong class="source-inline">–sV</strong>.</p>
<p>Now, the last step <a id="_idIndexMarker390"/>before we specify our targets is to configure timing. The keyword was “friendly” when the network admin asked us to tone it down, so let’s go with the polite template by adding <strong class="source-inline">–T2</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<img alt="Figure 5.6 – Identifying our desired timing template " height="237" src="image/Figure_5.06_B17616.jpg" width="671"/>
</div>
</div>
<p class="figure-caption">Figure 5.6 – Identifying our desired timing template</p>
<p>Now, we must define the target IP addresses. Thankfully, Nmap gives us the freedom to use more human-friendly methods of defining ranges; a dash between two numbers makes that a range, and you can do it within the octets. So, we know our range starts at <strong class="source-inline">10.10.105.0</strong> and ends at <strong class="source-inline">10.10.115.255</strong>. Thus, this makes the specification <strong class="source-inline">10.10.105-115.255</strong>. Ah, but wait – we only want the 10 addresses from 10 to 20. Therefore, the specification is <strong class="source-inline">10.10.105-115.10-20</strong>.</p>
<p>Put it all together to see your command on the screen:</p>
<div>
<div class="IMG---Figure" id="_idContainer100">
<img alt="Figure 5.7 – The full command, ready for execution " height="41" src="image/Figure_5.07_B17616.jpg" width="553"/>
</div>
</div>
<p class="figure-caption">Figure 5.7 – The full command, ready for execution</p>
<p>Where you will really enjoy Nmap’s power is in Metasploit Console. Let’s take a look.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Integrating Nmap with Metasploit Console</h2>
<p>Suppose<a id="_idIndexMarker391"/> you want to run some auxiliary modules in Metasploit and you want to do some host discovery first. Here’s the catch, though – you want the discovered hosts that meet your criteria to be in Metasploit’s PostgreSQL database. Look no further than <strong class="source-inline">db_nmap</strong>, the incarnation of Nmap that works directly with your database.</p>
<p>First, we need <a id="_idIndexMarker392"/>to make sure the database is up and initiated. If you haven’t done that already, go ahead and run <strong class="source-inline">msfdb init</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer101">
<img alt="Figure 5.8 – Configuring Metasploit’s database for the first time " height="463" src="image/Figure_5.08_B17616.jpg" width="691"/>
</div>
</div>
<p class="figure-caption">Figure 5.8 – Configuring Metasploit’s database for the first time</p>
<p>Now that we’re up and running, load up Metasploit with the <strong class="source-inline">msfconsole</strong> command. When the <strong class="source-inline">msf6</strong> prompt appears, check the database’s status with <strong class="source-inline">db_status</strong>. Assuming we’re ready to go, I can just fire off <strong class="source-inline">db_nmap</strong> right here at the <strong class="source-inline">msf6</strong> prompt. I only want Nmap to spit out hosts where the port is confirmed open, so I am using the <strong class="source-inline">–-open</strong> flag here:</p>
<div>
<div class="IMG---Figure" id="_idContainer102">
<img alt="Figure 5.9 – Running db_nmap within our Metasploit Console session " height="399" src="image/Figure_5.09_B17616.jpg" width="888"/>
</div>
</div>
<p class="figure-caption">Figure 5.9 – Running db_nmap within our Metasploit Console session</p>
<p>Once our scan <a id="_idIndexMarker393"/>is complete, a simple <strong class="source-inline">hosts</strong> command will query the database for the hosts we’ve captured. As you can see, there were three hosts running VNC on port <strong class="source-inline">5900</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer103">
<img alt="Figure 5.10 – db_nmap output entered into the database " height="197" src="image/Figure_5.10_B17616.jpg" width="839"/>
</div>
</div>
<p class="figure-caption">Figure 5.10 – db_nmap output entered into the database</p>
<p>Now, I will switch over to the auxiliary scanner with the <strong class="source-inline">use scanner/vnc/vnc_login</strong> command. I’ll run the <strong class="source-inline">hosts</strong> command again, but this time, I’ll pass <strong class="source-inline">–R</strong> to auto-populate the <strong class="source-inline">RHOSTS</strong> property of the module!</p>
<p>Finally, I can use <strong class="source-inline">run</strong> or <strong class="source-inline">exploit</strong> to run this module:</p>
<div>
<div class="IMG---Figure" id="_idContainer104">
<img alt="Figure 5.11 – Setting RHOSTS with the database entries and running the module " height="511" src="image/Figure_5.11_B17616.jpg" width="892"/>
</div>
</div>
<p class="figure-caption">Figure 5.11 – Setting RHOSTS with the database entries and running the module</p>
<p>As you can<a id="_idIndexMarker394"/> imagine, being able to let Nmap work directly with Metasploit’s database makes our lives a whole lot easier.</p>
<p>Let’s take a break from Nmap and Metasploit and get into something truly invasive – intercepting binaries and injecting our own.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Exploring binary injection with BetterCAP </h1>
<p>In <a href="B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Sniffing and Spoofing</em>, we explored custom filters with Ettercap to manipulate traffic <a id="_idIndexMarker395"/>on the fly. When we can serve as<a id="_idIndexMarker396"/> the go-between, the possibilities are exciting: we can manipulate messages between the server and user, even to the extent of delivering an executable masquerading as their requested file. BetterCAP continues to make things better (and easier) by allowing for slick automation of this process. In this exercise, we’re going to prepare a malicious executable for a Windows target and call it <strong class="source-inline">setup.exe</strong>. Then, we’ll set up a man-in-the-middle proxy attack that will intercept an HTTP request for an installer and invisibly replace the downloaded binary with ours. We’ll be covering these concepts and tools in more detail later in this book, so consider this an introduction to the power of custom modules in advanced man-in-the-middle attacks.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/>The magic of download hijacking</h2>
<p>Now, curl up with a cup of hot cocoa while Grandpa Phil rocks in his chair and regales you with tales from the distant past (2018, when the first edition was published). Back then, BetterCAP<a id="_idIndexMarker397"/> was a CLI tool and we could tweak the underlying functionality after brushing up on our Ruby. These days, as we saw in <a href="B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Sniffing and Spoofing</em>, BetterCAP is a slick and powerful point-and-click environment sporting an HTTP UI and even an API. (If you’re a scripter and you understand how to work with APIs, you’ll drool at the opportunity inherent to BetterCAP.) The environment allows you to manage <strong class="bold">caplets</strong>, the<a id="_idIndexMarker398"/> new word for modules. For our binary injection exercise, we’ll be working with the <strong class="source-inline">download-autopwn</strong> caplet. The principle is straightforward – wait for an executable to be requested, then drop our executable in its place. The process is seamless – our payload is delivered by the same mechanism that was queried, so we don’t have to masquerade the interface or messages. BetterCAP will even do us the favor of stuffing the executable with fluff to meet the file size, which is especially useful when our payload is a lightweight connect-back Trojan.</p>
<p class="callout-heading">Getting Your Environment Ready</p>
<p class="callout">If you aren’t joining us from <a href="B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Sniffing and Spoofing</em>, you’ll need to get BetterCAP installed and running on Kali. First, run <strong class="source-inline">apt-get update &amp;&amp; apt-get install bettercap</strong> to get it installed. Then, run the <strong class="source-inline">bettercap –caplet http-ui</strong> command. Don’t forget that the default credentials are <strong class="source-inline">user:pass</strong>. Open a new shell window as root for the other activities here; BetterCAP will run in the background and wait for your HTTP session.</p>
<h3>Creating the payload and connect-back listener with Metasploit</h3>
<p>Of <a id="_idIndexMarker399"/>course, you<a id="_idIndexMarker400"/> can replace a <a id="_idIndexMarker401"/>target file with anything <a id="_idIndexMarker402"/>you want. For our demonstration, we’ll create a payload designed to connect back to our Kali box where a listener is ready. Setting it up will give us a little more hands-on experience with the mighty Metasploit.</p>
<p>Let’s create <a id="_idIndexMarker403"/>our payload with <strong class="source-inline">msfvenom</strong>, a standalone<a id="_idIndexMarker404"/> payload generator. We’ll be having more fun with <strong class="source-inline">msfvenom</strong> later in this book. I will only run the command after I’m established on the network where I want to receive my <a id="_idIndexMarker405"/>connect-back from the target, so I will start with an <strong class="source-inline">ifconfig</strong> command to grep the connect-back IP address that needs to be coded into the payload. In this case, it’s <strong class="source-inline">192.168.249.136</strong>, so I will run the following command:</p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<img alt="Figure 5.12 – Generating a payload with msfvenom " height="225" src="image/Figure_5.12_B17616.jpg" width="968"/>
</div>
</div>
<p class="figure-caption">Figure 5.12 – Generating a payload with msfvenom</p>
<p>The <a id="_idIndexMarker406"/>options are straightforward: <strong class="source-inline">-p</strong> defines our payload, which in this case is the connect-back <strong class="source-inline">meterpreter</strong> session, <strong class="source-inline">-f</strong> is the file type, and <strong class="source-inline">lhost</strong> is the IP address that the target will contact (that’s us) on <strong class="source-inline">lport</strong> (<strong class="source-inline">1066</strong> because of the Battle of Hastings – just a little trivia to keep things interesting). Finally, the <strong class="source-inline">-o</strong> flag allows us to specify where the output will go. In our situation, BetterCAP will expect the payload to be called <strong class="source-inline">payload.exe</strong>, so I’m setting that here to save me a step later.</p>
<p>Before we send our naughty program somewhere, we need a listener standing by. Here, we must fire up msfconsole, enter <strong class="source-inline">use exploit/multi/handler</strong>, and set our options:</p>
<div>
<div class="IMG---Figure" id="_idContainer106">
<img alt="Figure 5.13 – Configuring our handler for the inbound connection " height="268" src="image/Figure_5.13_B17616.jpg" width="739"/>
</div>
</div>
<p class="figure-caption">Figure 5.13 – Configuring our handler for the inbound connection</p>
<p><strong class="source-inline">LHOST</strong> can be <a id="_idIndexMarker407"/>the IP that’s been assigned to our interface<a id="_idIndexMarker408"/> or just the zero address. Make sure <strong class="source-inline">LPORT</strong> matches what you configured in your <a id="_idIndexMarker409"/>payload <a id="_idIndexMarker410"/>executable. Execute <strong class="source-inline">exploit</strong> and wait for our <strong class="source-inline">meterpreter</strong> session to phone home. Now, we can configure and launch BetterCAP. Meanwhile, our target, <strong class="source-inline">192.168.249.139</strong>, was engaged in some water cooler chat about a tool <a id="_idIndexMarker411"/>called <strong class="bold">PdaNet</strong>. He’s planning on downloading the installer, <strong class="source-inline">PdaNetA5232b.exe</strong>. Our listener is ready, so now, we can jump back to BetterCAP to configure the <strong class="source-inline">download-autopwn</strong> caplet and get a better understanding of what it’s going to do. </p>
<h3>Getting cozy with caplets</h3>
<p>Once you’re logged<a id="_idIndexMarker412"/> in to the BetterCAP console, click on the <strong class="bold">Caplets</strong> icon at the top and browse the list along the left. One glance and you will know this tool is <em class="italic">fun</em>. For now, click on <strong class="bold">download-autopwn</strong>. On the right-hand side, you’ll see the contents of two files: <strong class="source-inline">download-autopwn.cap</strong> and <strong class="source-inline">download-autopwn.js</strong>. The parameters for your attack can be edited in the CAP file; the JavaScript code is the actual muscle behind the operation. I don’t find the interface user-friendly in this instance, so I’m going to check out the CAP file with nano in a separate terminal window:</p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<img alt="Figure 5.14 – Reviewing a caplet " height="702" src="image/Figure_5.14_B17616.jpg" width="959"/>
</div>
</div>
<p class="figure-caption">Figure 5.14 – Reviewing a caplet</p>
<p>Before we <a id="_idIndexMarker413"/>make any changes, we need to understand how this works. Once the proxy is up, the underlying machinery is going to conduct this attack in the following phases:</p>
<ol>
<li>Examine the requested path to find any file extension.</li>
<li>If the requested path contains an extension, check the user agent data for the target OS(s).</li>
<li>If the request comes from a target, check the list of target file extensions for that system.</li>
<li>If we have configured padding, BetterCAP examines the size of our payload and adds any needed null bytes to fill the file to the brim.</li>
<li>Now, BetterCAP prepares the response message in three steps:<ol><li>The Content-Disposition response header is set to <strong class="source-inline">attachment</strong>. This ensures that the browser won’t try to display a response page but instead push the download right to the browser.</li><li>The Content-Length header gets stripped.</li><li>The payload bytes become the body of the response message.</li></ol></li>
</ol>
<p>Fun, right? It’s a <a id="_idIndexMarker414"/>big step up from the BetterCAP download intercept of ages past. The biggest change is the ability to target machines with their user agent data and regex matching. Don’t worry about this fine-tuning now, though – out of the box, it’s designed to intercept everything it can see. (Note that our Windows target is already defined.) So, tuning our intercept for this session is as easy as commenting out the appropriate line. I’m going to comment out everything except Windows:</p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<img alt="Figure 5.15 – Configuring the target system in the download-autopwn caplet " height="306" src="image/Figure_5.15_B17616.jpg" width="954"/>
</div>
</div>
<p class="figure-caption">Figure 5.15 – Configuring the target system in the download-autopwn caplet</p>
<p>Now, we can scroll down to file extensions. It’s a gold mine, and I encourage you to brainstorm some possibilities (malicious APK for Android, anyone?), but for now, we’ll comment out the unneeded lines:</p>
<div>
<div class="IMG---Figure" id="_idContainer109">
<img alt="Figure 5.16 – Setting the target file extension in the download-autopwn caplet " height="244" src="image/Figure_5.16_B17616.jpg" width="954"/>
</div>
</div>
<p class="figure-caption">Figure 5.16 – Setting the target file extension in the download-autopwn caplet</p>
<p>I’m in <a id="_idIndexMarker415"/>a lab environment, so I’m not worried about the other file types for now, but just be aware that you will want to remove (or add) whatever you need for your situation. Finally, the finishing touch is to enable ARP spoofing; this friendly caplet can take care of that for us. We’re going to configure our spoofer with results from a network probe, so I’ll leave this line commented out.</p>
<p>Now, we’re all set! Let’s save that modified buffer and take a quick look at BetterCAP’s folder layout. Instead of prompting you during the attack, BetterCAP will assume you’ve prepped the payload accordingly – that is, you’ve named it <strong class="source-inline">payload</strong> and placed it in the appropriate target folder. Let’s run <strong class="source-inline">ls</strong> against the <strong class="source-inline">download-autopwn</strong> folder:</p>
<div>
<div class="IMG---Figure" id="_idContainer110">
<img alt="Figure 5.17 – File listing in the Windows payloads subfolder " height="276" src="image/Figure_5.17_B17616.jpg" width="794"/>
</div>
</div>
<p class="figure-caption">Figure 5.17 – File listing in the Windows payloads subfolder</p>
<p>It’s all coming together now, right? Note that by looking at the file sizes, these aren’t real payloads. Think of this as a template. So, at this point, we go back to our home directory (or wherever you spat out <strong class="source-inline">payload.exe</strong> from <strong class="source-inline">msfvenom</strong>) and move it back to the Windows payloads subfolder:</p>
<div>
<div class="IMG---Figure" id="_idContainer111">
<img alt="Figure 5.18 – File listing to confirm the size of payload.exe " height="389" src="image/Figure_5.18_B17616.jpg" width="935"/>
</div>
</div>
<p class="figure-caption">Figure 5.18 – File listing to confirm the size of payload.exe</p>
<p>Checking<a id="_idIndexMarker416"/> the sizes one more time, we can see that our 76K file made it over. We’re ready to rock and roll, and just in time: <strong class="source-inline">192.168.249.139</strong> is getting back to his desk to download that nifty tool. We’ve been sitting at our workstation running a probe of our surroundings. Find the target’s IP address, click the dropdown, and select <strong class="bold">Add to arp.spoof.targets</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer112">
<img alt="Figure 5.19 – Configuring the ARP spoof " height="624" src="image/Figure_5.19_B17616.jpg" width="640"/>
</div>
</div>
<p class="figure-caption">Figure 5.19 – Configuring the ARP spoof</p>
<p>Once <a id="_idIndexMarker417"/>you add the target, BetterCAP will take you to the configuration for arp.spoof and import the probed hosts. This is where you can add other hosts (such as the gateway!) and enable things such as full-duplex spoofing. We want to intercept a request out to the internet, so we need these options:</p>
<div>
<div class="IMG---Figure" id="_idContainer113">
<img alt="Figure 5.20 – Configuring full-duplex ARP spoofing with the gateway " height="550" src="image/Figure_5.20_B17616.jpg" width="1236"/>
</div>
</div>
<p class="figure-caption">Figure 5.20 – Configuring full-duplex ARP spoofing with the gateway</p>
<p>Now, we can click <strong class="bold">Start arp.spoof</strong> and let BetterCAP do its thing. You’ll see feedback in the form<a id="_idIndexMarker418"/> of pretty popups in the browser, but you’ll see these updates in the terminal, too.</p>
<p>That’s all – we’re ready to begin. Head back to the <strong class="bold">Caplets</strong> tab, select <strong class="bold">download-autopwn</strong>, and then click the play button:</p>
<div>
<div class="IMG---Figure" id="_idContainer114">
<img alt="Figure 5.21 – Firing off the caplet " height="144" src="image/Figure_5.21_B17616.jpg" width="843"/>
</div>
</div>
<p class="figure-caption">Figure 5.21 – Firing off the caplet</p>
<p>At this point, we’ll want to watch the progress in the terminal window. The log tells us that <strong class="source-inline">download-autopwn</strong> has been enabled and reminds us of our parameters. If we get a bite on our fishing line, this is where we’ll see it happen. Meanwhile, our target is browsing the home page for the download and spots the Windows client:</p>
<div>
<div class="IMG---Figure" id="_idContainer115">
<img alt="Figure 5.22 – Browsing for files to download on the victim’s browser " height="737" src="image/Figure_5.22_B17616.jpg" width="1259"/>
</div>
</div>
<p class="figure-caption">Figure 5.22 – Browsing for files to download on the victim’s browser</p>
<p>Meanwhile, on<a id="_idIndexMarker419"/> our end, we get the report: the target extension was seen, the raw size of our payload is smaller than the requested file, so it gets fluffed up, and the spoofed response is served:</p>
<div>
<div class="IMG---Figure" id="_idContainer116">
<img alt="Figure 5.23 – The bait and switch is complete " height="210" src="image/Figure_5.23_B17616.jpg" width="588"/>
</div>
</div>
<p class="figure-caption">Figure 5.23 – The bait and switch is complete</p>
<p>At long last, we can go back to our Metasploit session to wait (and hope) for our Meterpreter session to begin:</p>
<div>
<div class="IMG---Figure" id="_idContainer117">
<img alt="Figure 5.24 – New Meterpreter session from the target " height="149" src="image/Figure_5.24_B17616.jpg" width="1099"/>
</div>
</div>
<p class="figure-caption">Figure 5.24 – New Meterpreter session from the target</p>
<p>I know what you’re thinking – “<em class="italic">Phil, I just did all these steps with this Windows 10 VM I set up, and Defender deleted the payload immediately.</em>” Indeed; for the sake of demonstration, we spat out a plain Meterpreter payload with msfvenom, an output that will <a id="_idIndexMarker420"/>certainly be flagged by antivirus. This is where the art of <strong class="bold">antivirus evasion</strong> comes <a id="_idIndexMarker421"/>into play, which we’ll look at in <a href="B17616_12_Final_VK_ePub.xhtml#_idTextAnchor224"><em class="italic">Chapter 12</em></a>, <em class="italic">Shellcoding – Evading Antivirus</em>. It’s also worth noting a social engineering component: surely, the victim will wonder why apparently nothing happened when he executed the installer. We’ll also look at dynamic injection with Shellter in <a href="B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124"><em class="italic">Chapter 7</em></a>, <em class="italic">Advanced Exploitation with Metasploit</em>, as well as how to create message box payloads. Imagine if it said something like, <strong class="source-inline">Error detected – please download again</strong>. It’s surprising how effective that would be against a lot of people.</p>
<p>In the meantime, we’re going to look at another evasive technique for getting our packets around a filtered network.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Smuggling data – dodging firewalls with HTTPTunnel</h1>
<p>Now, curl up<a id="_idIndexMarker422"/> with another cup of hot cocoa as Grandpa Phil tells you an RDP<a id="_idIndexMarker423"/> fairytale. We’re going to build a hypothetical situation in which we are lucky enough to have a foothold on a Linux server that’s behind a firewall. The<a id="_idIndexMarker424"/> firewall allows HTTP ports <strong class="source-inline">80</strong>, <strong class="source-inline">443</strong>, and <strong class="source-inline">1433</strong>. You communicated with the server over its web service and discovered it is running a vulnerable Apache server. We compromised it with a PHP payload and got a shell through the firewall. Here’s your extra credit assignment – look at the following screenshot of the payload being delivered and figure out the nature of the vulnerability:</p>
<div>
<div class="IMG---Figure" id="_idContainer118">
<img alt="Figure 5.25 – Exploit extra credit – how we compromised our target " height="137" src="image/Figure_5.25_B17616.jpg" width="675"/>
</div>
</div>
<p class="figure-caption">Figure 5.25 – Exploit extra credit – how we compromised our target</p>
<p>It’s an <a id="_idIndexMarker425"/>oldie but a goldie vulnerability. Despite its age, it’s not unusual to see it on internal networks in large organizations. But I digress – back to our compromised Linux box. </p>
<p>What we’ve <a id="_idIndexMarker426"/>found is that our compromised Linux server can see a Windows 10 box that we want to access with Remote Desktop. We’ve also found that port <strong class="source-inline">1433</strong> isn’t hosting a service on the Linux box – presumably, it’s an artifact from an older configuration. This is useful but we’re also restricted by deep packet inspection – the firewall only permits HTTP traffic. Take a look at the following diagram. What’s a hacker to do?</p>
<div>
<div class="IMG---Figure" id="_idContainer119">
<img alt="Figure 5.26 – HTTP-only firewalling  " height="472" src="image/Figure_5.26_B17616.jpg" width="950"/>
</div>
</div>
<p class="figure-caption">Figure 5.26 – HTTP-only firewalling </p>
<p>We already have a root shell on the Linux server, so we could build an HTTP-encapsulated tunnel that links our two boxes, and then use the Linux server to contact the Windows target on RDP port <strong class="source-inline">3389</strong>. Thankfully, the perfect tool exists for this job – HTTPTunnel. In our example, the target server is running Ubuntu and HTTPTunnel happens to exist in the repository, so we can drop into the popped shell and pass the <strong class="source-inline">apt-get install httptunnel</strong> command on <em class="italic">both</em> ends – on our Kali attacking box and the Ubuntu compromised server. This will install two components: the HTTPTunnel <em class="italic">client</em>, <strong class="source-inline">htc</strong>, and the HTTPTunnel <em class="italic">server</em>, <strong class="source-inline">hts</strong>. Both ends work via port forwarding – <strong class="source-inline">htc</strong> will open a listening port and pass the received data to <strong class="source-inline">hts</strong> on the other end of the tunnel; then, <strong class="source-inline">hts</strong> will forward it to a port of our choosing. Thus, we’ll need <a id="_idIndexMarker427"/>something listening on the <strong class="source-inline">hts</strong> side of the tunnel to<a id="_idIndexMarker428"/> receive this data. In our example, we’ll use SSH as it’s already on the Ubuntu server. Confused yet? Let’s take a better look at this flow before continuing:</p>
<div>
<div class="IMG---Figure" id="_idContainer120">
<img alt="Figure 5.27 – Simplified data flow between the three points in play " height="408" src="image/Figure_5.27_B17616.jpg" width="749"/>
</div>
</div>
<p class="figure-caption">Figure 5.27 – Simplified data flow between the three points in play</p>
<p>We’ll hand off our RDP data to HTTPTunnel on local port <strong class="source-inline">8000</strong> to the server running on remote port <strong class="source-inline">1433</strong>; then, this data will be handed off to the SSH listener on local port <strong class="source-inline">3535</strong> before getting spat out on remote port <strong class="source-inline">3389</strong> on the Windows box. Note that the only arbitrary port numbers here are for the local listeners; <strong class="source-inline">1433</strong> is necessary because it’s what the firewall permits, and <strong class="source-inline">3389</strong> is the Remote Desktop port. </p>
<p>Once we have HTTPTunnel installed, we need to set up our listeners on the compromised Ubuntu server. First, let’s set up SSH:</p>
<pre class="source-code">ssh -L 0.0.0.0:3535:192.168.108.173:3389 &lt;user&gt;@127.0.0.1</pre>
<p>In order, the preceding command sets up a listener on port <strong class="source-inline">3535</strong>, which will be forwarded to port <strong class="source-inline">3389</strong> on the host <strong class="source-inline">192.168.108.173</strong> (our Windows 10 target), and we’re authenticating it with a local user (this could have been compromised or you simply created one when you first took control). Next, let’s look at the server side of our HTTP tunnel:</p>
<pre class="source-code">hts –forward-port 127.0.0.1:3535 1433</pre>
<p>In order, this <a id="_idIndexMarker429"/>command tells <strong class="source-inline">hts</strong> where to send the data that’s coming out of our tunnel (to local port <strong class="source-inline">3535</strong>, where SSH is ready) and which port<a id="_idIndexMarker430"/> to open (<strong class="source-inline">1433</strong>) for an incoming connection from <strong class="source-inline">htc</strong>.</p>
<p>We can check the status of our listeners with tools such as <strong class="source-inline">netstat</strong> or <strong class="source-inline">ss</strong> and <strong class="source-inline">grep</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer121">
<img alt="Figure 5.28 – Configuring and validating our tunnel in a reverse shell session  " height="512" src="image/Figure_5.28_B17616.jpg" width="773"/>
</div>
</div>
<p class="figure-caption">Figure 5.28 – Configuring and validating our tunnel in a reverse shell session with the compromised server</p>
<p>So far, so good. The mechanism that will take the data leaving our HTTP tunnel and pass it along to our target’s RDP port is up and running. Now, we need to get the client side going. Back in our Kali box, we must pass the <strong class="source-inline">htc –-forward-port 8000 192.168.108.116:1433</strong> command. In order, this tells <strong class="source-inline">htc</strong> to open local port <strong class="source-inline">8000</strong> and send it to the <strong class="source-inline">hts</strong> listener on port <strong class="source-inline">1433</strong> at <strong class="source-inline">192.168.108.116</strong> (our compromised Ubuntu server). Again, we must verify that the port is indeed up and listening: </p>
<div>
<div class="IMG---Figure" id="_idContainer122">
<img alt="Figure 5.29 – Configuring and validating the client side of our tunnel on the attacking Kali box " height="140" src="image/Figure_5.29_B17616.jpg" width="677"/>
</div>
</div>
<p class="figure-caption">Figure 5.29 – Configuring and validating the client side of our tunnel on the attacking Kali box</p>
<p>That’s it. It <a id="_idIndexMarker431"/>may<a id="_idIndexMarker432"/> seem precarious, but we can now connect to the RDP server behind the HTTP-only firewall by just pointing our tools at local port <strong class="source-inline">8000</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer123">
<img alt="Figure 5.30 – An RDP session through the HTTP tunnel " height="512" src="image/Figure_5.30_B17616.jpg" width="828"/>
</div>
</div>
<p class="figure-caption">Figure 5.30 – An RDP session through the HTTP tunnel</p>
<p>If you’re trying this out in your own lab, I recommend firing up Wireshark to see the behind-the-scenes action. Note the plain TCP designation; our RDP channel is TLS-encrypted, showing<a id="_idIndexMarker433"/> that the encrypted data is indeed encapsulated in HTTP. Also, note that the network shows us just having a friendly chat with <strong class="source-inline">192.168.108.116</strong> on port <strong class="source-inline">1433</strong>, while we’re actually having a desktop session with <strong class="source-inline">192.168.108.173</strong> on port <strong class="source-inline">3389</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer124">
<img alt="Figure 5.31 – The network perspective of our encapsulated RDP session " height="170" src="image/Figure_5.31_B17616.jpg" width="810"/>
</div>
</div>
<p class="figure-caption">Figure 5.31 – The network perspective of our encapsulated RDP session</p>
<p>There are <a id="_idIndexMarker434"/>a tremendous number of opportunities with this kind of redirection. Later in this chapter, we’ll even cover sending our local IPv4 traffic to a remote IPv6 host. But first, let’s get familiar with the basics. </p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>IPv6 for hackers</h1>
<p>I know I <a id="_idIndexMarker435"/>say this a lot about certain topics, but a deep dive into the particulars of IPv6 could fill its own book, so I have to pick and choose for the discussion here. That said, I will cover some introductory knowledge that will be useful for further research. As always, my advice for IPv6 is to read the authoritative RFCs. RFC 2460 was the original detailed definition and description of the new version, but it was a <em class="italic">Draft Standard</em> for all those years. The levels of <em class="italic">Standard</em> refer to the maturity of the technology being defined, with the <em class="italic">Proposed Standard</em> being the least mature, and the <em class="italic">Internet Standard</em> being the gold, well, standard. IPv6, after those long years, has become an Internet Standard with RFC 8200 (STD 86) as of July 2017. Though I certainly encourage reading RFC 2460, it is now officially obsolete. </p>
<p>IPv6 is important to pen testers for two big reasons – one (and hopefully most obviously), it’s the newest version of the internet, so you’re only going to see more of it; and two, as with many newer things that haven’t quite replaced the predecessor yet, it’s not given the same level of security scrutiny in most environments. Many administrators aren’t even aware that it’s enabled. You may get some useful findings with just basic poking around, and regardless, you’ll help raise awareness of this new protocol.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>IPv6 addressing basics</h2>
<p>There <a id="_idIndexMarker436"/>are quite a few differences between IPv4 and IPv6; I recommend researching those differences by studying the structure of an IPv6 packet. Probably the most obvious difference is the address. At first glance, IPv6 addresses are bewildering to look at. Aside from being longer than IPv4 addresses, they’re represented (in text form) with hexadecimal characters instead of decimal. These scary-looking addresses are part of one of the improvements over IPv4 – the address space. An IPv4 address is four groups of 8 bits each (an octet), for a total of 32 bits.</p>
<p>Therefore, the <a id="_idIndexMarker437"/>total number of available IPv4 addresses is <em class="italic">2</em><span class="superscript">32</span> = <em class="italic">4.294967296</em> billion, to be exact. Back in the 1970s, this big-sounding number seemed like plenty, but IPv4 address exhaustion soon became a legitimate threat and then, starting in the past decade, a reality. Consider, on the other hand, the IPv6 address: eight groups of four hexadecimal characters each (a single hex character takes up 4 bits); therefore, eight groups of 16 bits each (a hextet) for a total of 128 bits. Therefore, the total address space is <em class="italic">2</em><span class="superscript">128</span> = <em class="italic">340,282</em> decillion addresses. That’s enough for every grain of sand on Earth to have 45,000 quadrillion IP addresses each. In informal language, this is <em class="italic">quite the handful</em>. When working with IPv6 addresses, you may see something as long as <strong class="source-inline">2052:dfb8:85a3:7291:8c5e:0370:aa34:3920</strong>, down through something such as <strong class="source-inline">2001:db8:85ad::2:3</strong>, and even down to the IPv6 zero address (unspecified address), which is just two colons – <strong class="source-inline">::</strong>. So, the easiest way to understand them is to start with the core, uncompressed address, and then check out the IETF convention for simplifying them.</p>
<p>As we’ve just learned, the raw IPv6 address is eight groups of four (lowercase) hexadecimal characters, and the groups are separated by colons. Here’s an example:</p>
<pre class="source-code">2001:007f:28aa:0d3a:0000:0000:2e87:0bcb</pre>
<p>There are two main compression rules. The first is the omission of initial zeros (not entire groups of zero; that’s next) within a hextet. <strong class="source-inline">00aa</strong> becomes <strong class="source-inline">aa</strong>, <strong class="source-inline">05f4</strong> becomes <strong class="source-inline">5f4</strong>, and <strong class="source-inline">000e</strong> becomes <strong class="source-inline">e</strong>. In our example, there are three groups with initial zeros, so our address becomes the following:</p>
<pre class="source-code">2001:7f:28aa:d3a:0000:0000:2e87:bcb</pre>
<p>The second rule involves conversing all-zero groups into double colons (<strong class="source-inline">::</strong>). This rule applies to adjacent groups of all zeros; if there are two or more adjacent groups of all zeros, they are all replaced with a single double colon. Single groups of all zeros are not suppressed and instead are represented with a single <strong class="source-inline">0</strong>. If there happens to be more than one multiple group run of zeros, then the leftmost run of zeros is suppressed and the others are turned into single-zero groups. </p>
<p>By only compressing adjacent groups of zero, and by only doing this compression once per address, we prevent any ambiguity. If you’re wondering how many uncompressed groups of zero are represented by a double colon, just remember that the full IPv6 address is eight groups long – so you’ll convert it into however many groups it takes to make an even eight.</p>
<p>In our <a id="_idIndexMarker438"/>example, there is a single multiple-group run of zero (two groups), so those eight adjacent zeros become a double colon:</p>
<pre class="source-code">2001:7f:28aa:d3a::2e87:bcb</pre>
<p>This looks quite a bit more manageable than the uncompressed address, right? By following those compression rules, the result is the same address as the first.</p>
<p>Before we move on, let’s take a look at a few more examples:</p>
<div>
<div class="IMG---Figure" id="_idContainer125">
<img alt="Table 5.1" height="453" src="image/Table_5.01_B17616.jpg" width="1571"/>
</div>
</div>
<p>Okay, you have IPv6 address compression fundamentals in your pocket. Let’s take a look at some practical discovery tools for IPv6 environments.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Watch me neigh neigh – local IPv6 recon and the Neighbor Discovery Protocol</h2>
<p>So, you’re on the<a id="_idIndexMarker439"/> network and you need to do some recon to find out what’s out there in IPv6 land. I know what the hacker in you is thinking <a id="_idIndexMarker440"/>at this point – “<em class="italic">well, it was feasible to scan even large swaths of the IPv4 address space, but a 2128 address space? That’s just a waste of time at best</em>.” Right you are! Trying to combine the <strong class="source-inline">-6</strong> flag in Nmap with a range of addresses will give you an error. So, we have to think a little differently about host discovery.</p>
<p>Before we pull out the offensive toolkit, let’s go back to basics with <strong class="source-inline">ping</strong>. If you review the man page for <strong class="source-inline">ping</strong>, you’ll find IPv6 support; but, we can’t do a ping sweep like in the good old days. Not a problem – we’ll just ping the link-local multicast address. By definition, this will prompt a<a id="_idIndexMarker441"/> reply from our friendly neighbors and we’ll have some targets. There’s a nice chunk of multicast addresses defined for IPv6 for different purposes (for example, all routers on the local segment, RIP routers, EIGRP routers, and so on), but the one to memorize for now is <strong class="source-inline">ff02::1</strong>. We’ll be effectively mimicking the Neighbor Discovery Protocol’s solicitation/advertisement process.</p>
<p>We’re going to<a id="_idIndexMarker442"/> fire off an IPv6 <strong class="source-inline">ping</strong> command pointing at link-local multicast address <strong class="source-inline">ff02::1</strong> to trigger responses from hosts on our segment, which will populate the neighbor table; then, we’ll ask <strong class="source-inline">ip</strong> to show us those discovered neighbors:</p>
<pre class="source-code">ping –6 –I eth0 –c 10 ff02::1 &gt; /dev/null</pre>
<pre class="source-code">ip –6 neigh show</pre>
<p>Let’s see what this looks like:</p>
<div>
<div class="IMG---Figure" id="_idContainer126">
<img alt="Figure 5.32 – IPv6 neighbors " height="423" src="image/Figure_5.32_B17616.jpg" width="657"/>
</div>
</div>
<p class="figure-caption">Figure 5.32 – IPv6 neighbors</p>
<p>Notice a pattern with the responses? All of the addresses belong to <strong class="source-inline">fe80::/10</strong>. The hosts responded with a link-local address, which it will have in addition to any globally unique address. We gathered this by pinging the link-local multicast address, after all. Pinging is an active task; by conducting some passive listening, we may hear devices confirming via the ICMP6 neighbor solicitation and <strong class="bold">Duplicate Address Discovery</strong> (<strong class="bold">DAD</strong>) process that<a id="_idIndexMarker443"/> their assigned address is unique. Now, we can open up our offensive toolkit.</p>
<p>The standard <a id="_idIndexMarker444"/>Swiss-army knife of IPv6 poking and prodding is THC-IPV6, which is included with Kali Linux. We command the <strong class="source-inline">detect-new-ip6</strong> tool to listen on our interface for any ICMP6 DAD messages:</p>
<pre class="source-code">atk6-detect-new-ip6 eth0</pre>
<p>You should see data being returned as new addresses are seen:</p>
<div>
<div class="IMG---Figure" id="_idContainer127">
<img alt="Figure 5.33 – Detecting new addresses with DAD detection " height="119" src="image/Figure_5.33_B17616.jpg" width="552"/>
</div>
</div>
<p class="figure-caption">Figure 5.33 – Detecting new addresses with DAD detection</p>
<p>With that, we’ve gathered some targets to start scanning for services with the <strong class="source-inline">-6</strong> flag in Nmap. Thanks, DAD!</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>IPv6 man-in-the-middle – attacking your neighbors</h2>
<p>By now, you’ve probably had enough ARP to give you a headache. Don’t worry – IPv6 has a different <a id="_idIndexMarker445"/>process for resolving link-layer addresses to IPv6 addresses. However, it seems the designers didn’t want us to be bored – we can still spoof and manipulate the procedure, just as in IPv4 and ARP, thus establishing a man-in-the-middle condition. Let’s take a look at <a id="_idIndexMarker446"/>how the <strong class="bold">Neighbor Discovery Protocol</strong> (<strong class="bold">NDP</strong>) resolution works in IPv6, and then we’ll attack it with THC-IPV6’s <strong class="source-inline">parasite6</strong>.</p>
<p>You’ll recall from sniffing ARP traffic that there are two parts: </p>
<ul>
<li>Who has <strong class="source-inline">&lt;IP address&gt;</strong>? Tell <strong class="source-inline">&lt;host&gt;</strong>.</li>
<li> <strong class="source-inline">&lt;IP address&gt;</strong> is at <strong class="source-inline">&lt;MAC address&gt;</strong>. </li>
</ul>
<p>In IPv6, these two parts are<a id="_idIndexMarker447"/> called <strong class="bold">neighbor solicitation</strong> (<strong class="bold">NS</strong>) and <strong class="bold">neighbor advertisement</strong> (<strong class="bold">NA</strong>), respectively. First, the node with the query sends <a id="_idIndexMarker448"/>an NS message to the <strong class="source-inline">ff02::1</strong> multicast address. This is received by all the nodes on the segment, including the subject of the NS query. The subject node then replies to the requestor with an NA message. All of these messages are carried over ICMPv6.</p>
<p>It’s that<a id="_idIndexMarker449"/> straightforward. The method is a little different in how replies are processed, however. In IPv4 ARP, replies that map a link-layer address to an IP address can be broadcast without solicitation, and nodes on the segment will update their tables accordingly. In other words, the attacker can preempt any resolution request, so the target never identifies itself as the correct address. In IPv6 ND, the target system will reply to the NS with an NA directed at the requestor; in short, the requestor ends up receiving two NA messages for the same query, but they will be pointing to two different link-layer addresses, one of which is the attacker. Fun, right? Here’s where you’ll chuckle: by setting the ICMPv6 override flag, we tell the recipient to – you guessed it – override any previous messages. The requestor will get two answers: “<em class="italic">Hi, I’m the device you’re looking for</em>,” followed immediately by, “<em class="italic">Don’t listen to that guy, it’s actually me</em>.”</p>
<p>Our handy NDP spoofer is called <strong class="source-inline">parasite6</strong>. Yes, we need to set up packet forwarding so that traffic gets through our interface once the spoofing begins, but there’s another setup step required: suppression of ICMPv6 redirects. There are certain scenarios in which a device that’s forwarding IPv6 traffic (that would be you, the attacker) has to send back a redirect to the source, effectively telling the source to send traffic somewhere else.</p>
<p>Certain conditions will trigger this, including forwarding traffic out the same interface through which it was received – oops. So, we’ll set up an <strong class="source-inline">ip6tables</strong> rule as well. Our friendly <strong class="source-inline">parasite6</strong> tool is nice enough to remind us at launch, just in case we forgot.</p>
<p>Keep an eye out for that pesky number <strong class="source-inline">6</strong> when working with these protocols: <strong class="source-inline">ping -6</strong>, <strong class="source-inline">nmap -6</strong>, and <strong class="source-inline">ip6tables</strong> instead of <strong class="source-inline">iptables</strong>, and so on. There is a lot of conceptual and functional overlap, so be careful:</p>
<pre class="source-code">sysctl –w net.ipv6.conf.all.forwarding = 1</pre>
<pre class="source-code">ip6tables –I OUTPUT –p icmpv6 –-icmpv6-type redirect –j DROP</pre>
<pre class="source-code">atk6-parasite6 –l –R eth0</pre>
<p>The following<a id="_idIndexMarker450"/> screenshot illustrates the output of the preceding commands:</p>
<div>
<div class="IMG---Figure" id="_idContainer128">
<img alt="Figure 5.34 – Configuring IPv6 forwarding and filtering with ip6tables before launching the parasite6 attack " height="276" src="image/Figure_5.34_B17616.jpg" width="692"/>
</div>
</div>
<p class="figure-caption">Figure 5.34 – Configuring IPv6 forwarding and filtering with ip6tables before launching the parasite6 attack</p>
<p>Now, the attack is active and you can progress to the next stage of intercept and manipulation. </p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Living in an IPv4 world – creating a local 4-to-6 proxy for your tools</h2>
<p>There’s a<a id="_idIndexMarker451"/> tool included with Kali that can be thought of as <strong class="source-inline">netcat</strong> on steroids: <strong class="source-inline">socat</strong>. This tool can do many things and we just don’t have enough room to go over it all here, but its ability to relay from IPv4 to IPv6 environments is especially useful. We’ve seen tools designed for IPv6, but we will occasionally find ourselves stuck needing a particular IPv4 tool’s functionality to talk to IPv6 hosts. Enter the <strong class="source-inline">socat</strong> proxy.</p>
<p>The concept and setup are simple – we create an IPv4 listener that then forwards packets over IPv6 to a host where we have a potentially vulnerable web server that we want to scan with Nikto:</p>
<pre class="source-code">socat TCP-LISTEN:8080,reuseaddr,fork TCP6[&lt;IPv6 address&gt;]:80</pre>
<p>Everything happens in the background at this point, so you won’t see anything in the terminal. No news is good news with a <strong class="source-inline">socat</strong> proxy; if there’s a problem, it’ll let you know. Let’s <a id="_idIndexMarker452"/>take a look at these options:</p>
<ul>
<li><strong class="source-inline">TCP-LISTEN:8080</strong> tells <strong class="source-inline">socat</strong> to listen for TCP connections and defines the local listening port – in this case, <strong class="source-inline">8080</strong>.</li>
<li><strong class="source-inline">reuseaddr</strong> is needed for heavy-duty testing by allowing more than one concurrent connection.</li>
<li><strong class="source-inline">fork</strong> refers to forking a child process each time a new connection comes through the pipe, used in tandem with <strong class="source-inline">reuseaddr</strong>.</li>
<li><strong class="source-inline">TCP6</strong> comes after the space that tells <strong class="source-inline">socat</strong> what we’re going to do with the traffic that’s received on the listener side of the command; it says to send the traffic over to port <strong class="source-inline">80</strong> of a TCP target over IPv6. Note that we need brackets here as the colon is used in both command syntax and IPv6 addresses, so this prevents confusion.</li>
</ul>
<p>Now, I can just point my toolset at my local port <strong class="source-inline">8080</strong>, and everything will be received by the target over IPv6 at port <strong class="source-inline">80</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer129">
<img alt="Figure 5.35 – Running Nikto against a web server at an IPv6 address via a socat proxy " height="460" src="image/Figure_5.35_B17616.jpg" width="713"/>
</div>
</div>
<p class="figure-caption">Figure 5.35 – Running Nikto against a web server at an IPv6 address via a socat proxy</p>
<p>As you can<a id="_idIndexMarker453"/> see, the target and port have to be defined for <strong class="source-inline">socat</strong>. Do you know what would be really useful? A Python script that prompts for a host and port number and configures <strong class="source-inline">socat</strong> automatically. That’s something to consider for later.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Summary</h1>
<p>In this chapter, we went on a journey through the network of our client in terms of discovery and vulnerability analysis. We explored the power of Nmap in today’s day and age and demonstrated that it’s still the go-to for network mapping. We explored the underlying mechanisms of the different scan types and learned how to have Nmap interact directly with Metasploit for ease of targeting. Then, we learned how BetterCAP can compromise data streams in real time by swapping out a download with a malicious binary and got comfortable with the updated user interface. After playing with BetterCAP, we learned how we can encapsulate an arbitrary protocol inside an HTTP tunnel to bypass filters. We wrapped up this chapter with a review of IPv6 and some basic tooling with IPv6, including how to get by with IPv4 tools in an IPv6 environment.</p>
<p>In the next chapter, things are going to get goofy-exciting as we jump into some cryptography concepts and some lesser-known attacks that still manage to get overlooked in many environments. We’re going to not only play with these attacks, but we’ll also discuss the underlying mechanisms that make them tick. </p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li value="1"><strong class="source-inline">-T1</strong> ensures the fastest scan possible with Nmap. (True | False)</li>
<li>How is the Maimon scan similar to the Xmas scan?</li>
<li>BetterCAP’s <strong class="source-inline">download-autopwn</strong> can match the payload size with the size of the requested file. (True | False) </li>
<li>What two components are necessary to build an HTTP tunnel between two hosts?</li>
<li>The IPv6 counterpart to IPv4’s ARP is called __________.</li>
<li>Provide the uncompressed representation of the link-local multicast address <strong class="source-inline">ff02::1</strong>.</li>
</ol>
<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/>Further reading</h1>
<p>For more information regarding the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>RFC 8200 (<a href="https://tools.ietf.org/html/rfc8200">https://tools.ietf.org/html/rfc8200</a>): The IPv6 standard, current as of 2017</li>
<li>RFC 2460 (<a href="https://tools.ietf.org/html/rfc2460">https://tools.ietf.org/html/rfc2460</a>): The IPv6 standard, obsolete</li>
<li>RFC 5952 (<a href="https://tools.ietf.org/html/rfc5952">https://tools.ietf.org/html/rfc5952</a>): Rules for IPv6 address representation</li>
</ul>
</div>
</div></body></html>