- en: '*Chapter 5*: Assessing Network Security'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve had a lot of fun poking around the network in the first few chapters.
    There has been an emphasis on man-in-the-middle attacks, and it’s easy to see
    why – they’re particularly devastating when performed properly. However, your
    focus when educating your clients should be on the fact that these are fairly
    old attacks, and yet, they still often work.
  prefs: []
  type: TYPE_NORMAL
- en: One reason is that we still rely on very old technology in our networks, and
    man-in-the-middle attacks generally exploit inherent design vulnerabilities at
    the protocol level. Consider the internet protocol suite, underlying the internet
    as we know it today – the original research that ultimately led to TCP/IP dates
    back to the 1960s, with official activation and adoption gaining traction in the
    early 1980s. Old doesn’t necessarily imply insecure, but the issue here is the
    context in which these protocols were designed – there weren’t millions upon millions
    of devices attached to networks of networks, operated by everyone on the street
    from the teenager in his parents’ basement to his grandmother, and they weren’t
    supported by network stacks embedded into devices ranging from physical mechanisms
    in nuclear power plants down to a suburban home’s refrigerator, sending packets
    to alert someone that they’re running low on milk. This kind of adoption and proliferation
    wasn’t a consideration; the reality was that physical access to nodes was tightly
    controlled. This inherent problem hasn’t gone unnoticed—the next version of the
    internet protocol, IPv6, was formally defined in the **Request for Comments**
    (**RFC**) document during the late 1990s (with the most recent RFC being published
    in 2017). We’ll touch on IPv6 in this chapter, but we’ll also demonstrate how
    to practically interface IPv4 with IPv6\. This highlights that adoption has been
    slow and a lot of effort has been placed into making IPv6 work well with IPv4
    environments, ensuring that we’re going to be playing with all the inherent insecurity
    goodies of IPv4 for some time to come.
  prefs: []
  type: TYPE_NORMAL
- en: As a pen tester on a job, it’s exciting to watch that shell pop up on your system.
    But when the fun and games are over, you’re left with a mountain of findings that
    will be laid out in a report for your client. Remember that your job is to help
    your client secure their enterprise, and it’s about more than just software flaws.
    Look for opportunities to educate as well as inform.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Network probing with Nmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring binary injection with BetterCAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smuggling data – dodging firewalls with HTTPTunnel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IPv6 addressing, recon, man-in-the-middle, and mapping from IPv4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need a laptop running Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Network probing with Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s play *Jeopardy*. Here’s the answer – “*This network mapping tool, first
    released 24 years ago, caused a stir when its accurate portrayal in Hollywood
    films prompted organizations such as Scotland Yard to remind the public that its
    use is potentially illegal*.” If you said, “*What is Nmap?*” as the question,
    then you have won this Daily Double. Nmap is the go-to tool for just about anyone
    working on networked computers. Nmap means **network mapper**, and it’s useful
    in a wide variety of disciplines outside of security: network engineering, systems
    administration, and so on. Nmap’s innovation is that it allows the probes that
    you send to be customized to a high degree, allowing for unique responses that
    reveal a great deal of information about the target, and even finding shortcuts
    through a firewall.'
  prefs: []
  type: TYPE_NORMAL
- en: Nmap is the embodiment of the colloquialism *Swiss-army knife*, so let’s break
    down its key purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Host discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nmap can perform ping and port scans, but this is no ordinary scanner – it allows
    you to send a variety of probes to improve the chances of finding a target. You
    can simply ping targets, or you can send special lightweight probes to certain
    ports. The whole idea is sending something that elicits a response from the target.
    The flexibility here allows Nmap to function as an ideal sidekick for any administrator
    as well as a pen tester.
  prefs: []
  type: TYPE_NORMAL
- en: List Scan (-sL)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This merely lists hosts for scanning, including reverse DNS lookups along the
    way. However, no traffic is sent to the targets. This is useful for validating
    the range of IPs you’re working with.
  prefs: []
  type: TYPE_NORMAL
- en: Ping Scan (-sn)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ping Scan allows you to effectively run a *ping sweep* against the targets –
    that is, there is no port scanning, but unlike the List Scan, we are sending data
    in the form of pings (specifically, an ICMP ECHO request) to the targets. There
    is *some* port activity with the default settings – Nmap will send an SYN to port
    **443**, an ACK to port **80**, and an ICMP timestamp request. This can be combined
    with the discovery probes discussed next, in which case this default behavior
    is skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Skip host discovery (-Pn)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a setting for Nmap users who know what they want: it won’t bother determining
    if hosts are up, so it effectively treats *every IP address in the range* as online.
    There may be times when you will want this, such as if you don’t fully trust the
    results of host discovery. Firewalls can be configured to make online hosts silent
    to popular discovery methods. The upside of this setting is that you can be sure
    no host is ignored when the port scan starts. The downside is that the scan will
    take a lot longer, as Nmap will be waiting for responses and timing out for every
    specified port on every specified IP address – this means a whole lot of probing
    computers that aren’t even there.'
  prefs: []
  type: TYPE_NORMAL
- en: Specialized discovery probes (-PS, -PA, -PU, -PY, -PO)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Somewhere between using the **ping** utility to find hosts and running port
    scans to find services lies Nmap’s host discovery options. SYN Ping (**-PS**),
    for example, sends an empty SYN packet either to a default port of 80 or to one
    you specify. If the host responds, no connection is established, but it tells
    Nmap that the host is there. Very similar to this discovery option is ACK Ping
    (**-PA**), which does the same thing – it sends an empty packet but with the **ACK**
    flag set. This option can help in discovering hosts behind firewalls configured
    to drop SYN requests but aren’t fancy enough to drop an unsolicited ACK. UDP Ping
    is similar and lets you configure specific ports, but it uses UDP instead of TCP.
    Since there is no three-way handshake in UDP, what Nmap is waiting for is an ICMP
    **port unreachable** message, which proves the host is there. The port number
    matters less here; in fact, you’ll want to avoid the common ports. The default
    is **40125** – surely an uncommonly used port number for hosting services. **Stream
    Control Transmission Protocol** (**SCTP**) also has a discovery option along with
    a scanning option: **-PY** sends an SCTP message with an INIT chunk set, waiting
    for either an ABORT or INIT-ACK in response. Another fine-tuned probe that can
    be sent is the IP Protocol Ping (**-PO**), which sends packets with a specific
    protocol defined in the header. For example, suppose you want to try probing for
    hosts with IGMP. You may get an **unreachable** message, or even an IGMP response
    – in either case, the host proved its existence.'
  prefs: []
  type: TYPE_NORMAL
- en: Ping on steroids (-PE, -PP, -PM)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’re probably already aware that often, a host won’t reply to a basic ping
    – administrators often configure hosts and firewalls to drop these ubiquitous
    ECHO requests, especially from untrusted networks. It’s not uncommon for the *other*
    message types in ICMP to be overlooked. This is where the different ping options
    come into play. You can use **–PE** for that classic ping taste, but **–PP** and
    **–PM** allow you to send timestamp queries and address mask queries over ICMP,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning – scan types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nmap has come a long way from its debut as a user-friendly and fast port scanner.
    It allows for fine-tuning to hone in on the actual condition of your target with
    incredible reliability. However, any tool can be quickly whipped together and
    trusted to try connecting to ports – where Nmap earns its stripes is in its ability
    to send carefully crafted unexpected messages and analyze the response. Let’s
    take a look at the different techniques.
  prefs: []
  type: TYPE_NORMAL
- en: TCP SYN scan (-sS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This scan sends the initial synchronize (SYN) request of a TCP three-way handshake
    but with no intention of completing the transaction. The goal here is to listen
    for the expected SYN-ACK of a service ready for communication, and if received,
    mark the port as open. This technique is sometimes called **stealth scanning**,
    but I would regard it as a bit of a misnomer – any intrusion detection system
    will know a port scan when it sees one. It’s stealthy in the sense that the transaction
    is never completed, meaning there’s no connection to pass up the remaining OSI
    layers. Therefore, the application never gets a connection and won’t log one.
    Don’t be discouraged from using it – it’s better to be a network nuisance alone
    than a network nuisance *and* an application log nuisance. It also has the potential
    for speed, as we aren’t waiting for established connections.
  prefs: []
  type: TYPE_NORMAL
- en: TCP Connect() scan (-sT)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you ask someone the difference between SYN scans and the Connect() scan,
    a common answer is *reliability*. SYN scans, being half-opened, may give unexpected
    results; but what about a completed three-way handshake? That’s a demonstrated
    open port that’s ready for communication. The reality is that SYN scans are plenty
    reliable against any proper and compliant TCP stack – there isn’t a lot of room
    for interpretation when you get an SYN-ACK response from an SYN. The practical
    difference between the two options is your local privileges. This won’t mean much
    to all of you Kali hackers – you’re already running as root. But perhaps you have
    lowly user privileges – the fancier SYN scan isn’t an option since it is a customized
    packet and thus requires raw socket privileges. The Connect() scan makes use of
    the **connect()** system call, just as any ordinary program that needs to establish
    a connection would. It’s reliable, but it’s slower, and the target application
    will notice it.
  prefs: []
  type: TYPE_NORMAL
- en: UDP scan (-sU)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I could tell you a joke about UDP, but you may not get it. Get it? The good
    ol’ fire-and-forget **User Datagram Protocol** is often ignored by pen testers,
    but the potential for attack vectors is the same as with the more obvious TCP.
    What’s counterintuitive about UDP scanning is speed – though UDP is associated
    with the blistering fast streaming services of today, thanks to the eliminated
    need to wait for confirmation on every packet, an open UDP port may not even send
    a response to Nmap’s probe. There’s no need for a handshake, after all. Knowing
    the difference between a lost datagram and one that was received but unanswered
    means Nmap has to retry and wait to decide. This is less of an issue with the
    well-known protocols such as SNMP, where Nmap knows to send data specific to that
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: SCTP INIT and COOKIE ECHO scans (-sY / -sZ)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These scans make use of SCTP, which is a blend of TCP reliability and UDP speed.
    You may not encounter a need for it, but Nmap is ready for it just in case. INIT
    is the SCTP equivalent of an SYN request, and INIT-ACK is the expected response
    when the port is open. COOKIE ECHO is a special response; as designed, the remote
    system sends a **cookie** as part of its INIT-ACK, and the initiator responds
    with COOKIE ECHO. However, an unsolicited COOKIE ECHO will just be dropped by
    an open port, allowing Nmap to differentiate between open and closed ports. Like
    the TCP NULL/FIN/Xmas scans discussed next, this is an example of Nmap’s genius
    in exploiting an RFC technicality: things are *supposed* to go a certain way,
    and the RFCs prescribe what to do when they don’t. Nmap exploits this.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP NULL/FIN/Xmas/Maimon scans (-sN / -sF / -sX / -sM)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand these scans, let’s dive into some theories for a bit. Deep in
    the RFC for **Transmission Control Protocol** (**TCP**), in the *Event Processing*
    section of the functional specification, there are some key prescriptions for
    handling weird events. Every TCP segment has a header containing information about
    the role that particular chunk of the payload plays in a connection. It’s a fixed
    length and contains information such as the source port and destination port.
    There is a section of **reserved bits** that are used for setting **flags**. This
    is where a packet is defined as a, say, SYN request. If these flags are set strangely,
    the design specification dictates what to do about it. Here’s an example from
    the RFC regarding closed ports – “*If the state is CLOSED, then all the data in
    the incoming segment is discarded. An incoming segment containing an RST is discarded.
    An incoming segment not containing an RST causes an RST to be sent in response*.”
    Another key point is on the next page, which discusses open ports – “*An incoming
    RST segment could not be valid, since it could not have been sent in response
    to anything sent by this incarnation of the connection. So, you are unlikely to
    get here, but if you do, drop the segment, and return*.” Even though this specific
    event is called out as being invalid, the specification still describes how to
    handle it. Thus, Nmap can infer the state of the port.
  prefs: []
  type: TYPE_NORMAL
- en: The NULL scan (**-sN**) doesn’t set any flags; that is, the reserved bits are
    all zero. The FIN scan (**-sF**) only sets the FIN bit. The Xmas scan (**-sX**)
    sets FIN (gracefully close the connection), PSH (push the data to the application
    immediately), and URG (some or all of the payload should be prioritized) bits
    all at once – a situation that wouldn’t happen in a legitimate context. This causes
    the packet to be *lit up* like a Christmas tree. The Maimon scan (**-sM**) is
    similar to the Xmas scan, except it sets FIN/ACK.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s pull ourselves out of the theory and jump back into the practical
    – are these scans useful? To answer this, keep the main implication of this technique
    in mind: it’s only meaningful against TCP stacks that have faithfully executed
    the RFC’s specification. There are no RFC cops who come knocking on your door
    if your software fails to silently drop a weird packet. A notable example is the
    Windows **operating system** (**OS**), which will send an RST (a forceful way
    of shutting down a connection) in response to these silly packets, regardless
    of port state. Some BSD-based systems will drop a Maimon packet instead of an
    RST when the port is open, creating a rare scenario where that scan type is meaningful.
    Speaking for myself, I have very rarely used these scans.'
  prefs: []
  type: TYPE_NORMAL
- en: TCP ACK scan (-sA)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similarly, the ACK scan exploits a nuance in how stacks reply to strangeness:
    only the ACK flag is set. A port that receives such a packet will send back an
    RST, regardless of its state – so, this isn’t for determining state. If we get
    an RST back, we’ll know that the message got to our target. Thus, it’s a relatively
    stealthy way to map out firewall holes.'
  prefs: []
  type: TYPE_NORMAL
- en: Zombie scan (-sI)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we’re getting to my favorite scan type: the idle zombie scan. It is *actually*
    stealthy – you don’t send any data whatsoever to your target. The only caveat
    is similar to the previous discussion about how different systems are designed
    – the idle zombie scan requires a host that will *play by the rules* of IP packet
    incrementation. Let’s dive a little deeper into the theory. So, suppose I send
    an SYN packet to a host on an open port. That host will reply with an SYN-ACK
    and wait for our final ACK. Now, suppose I send an SYN packet to a closed port
    on that host. It’ll angrily fire back an RST and I’ll know the port isn’t open
    for a chat. Let’s go through this again, but this time, I will *forge* the return
    address – the address of the zombie – on my SYN request. That open port will reply
    SYN-ACK and send it to the *forged* address, not mine. Let’s do this with the
    closed port, too: our target fires back an RST but again, it’s addressed to the
    forged address. We never get a reply.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The genius of the idle zombie scan is that it leverages both the nature of
    how TCP handles weirdness per the RFC, as discussed previously, and the fact that
    every single packet on any network has a fragment identification number. Let’s
    consider a few conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The zombie is running an OS that merely *increments* the fragment ID number
    for each one it sends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zombie is truly *idle*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The zombie’s TCP stack behaves as expected when it receives an unsolicited
    SYN/ACK: it responds with an RST, whereas the unsolicited RST is *ignored*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zombie scan monitors the zombie with pings and carefully tracks the incrementation
    while sending carefully timed forged SYN packets to the target. It’s truly a beautiful
    thing to behold.
  prefs: []
  type: TYPE_NORMAL
- en: All of that being said, how practical is this attack? The challenge today is
    finding zombies that are truly idle. This kind of analysis requires high confidence
    that any packets sent by the zombie during the scan are related to our scan –
    it’s hard to have this sort of confidence. The other concern has to do with how
    faithful the zombie’s stack is to the RST; if it’s going to fire RSTs back to
    our target with every unsolicited message that’s received, we can’t infer anything.
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning – port states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 9*](B17616_09_Final_VK_ePub.xhtml#_idTextAnchor165), *PowerShell
    Fundamentals*, we’ll build a basic port scanner with PowerShell. While handy,
    you’ll notice that it doesn’t discriminate the results beyond an open or closed
    port. Nmap reports the port status as one of six states. The first three are the
    most commonly encountered for most enumeration exercises, while the last three
    are special responses based on the different scan techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**open**: As its name suggests, the reported port is actively accepting connection
    requests; that is, a service on the target is up and available to serve clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closed**: This is where the granularity of Nmap’s report starts to show.
    Suppose that on one target, a port isn’t being blocked by any kind of packet filtering
    mechanism, but there’s simply no service running there. Now, suppose that, on
    a different target, we can’t tell if there’s a service or not because there’s
    an active filtering mechanism in play. Your *run-of-the-mill* port scan will not
    distinguish those conditions – Nmap will. Closed is the former scenario – the
    port is reachable and can respond to the probes, but there’s no service present.
    The next state is where filtering comes into play.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtered**: Now, Nmap has established that something is preventing our probes
    from getting to this port, whether it’s a network-based firewall, host-based firewall,
    or even some kind of routing rule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unfiltered**: This is a special result from ACK scans that shows that the
    port is accessible, but Nmap couldn’t establish its state. The other scan types
    can resolve this ambiguity. Narrowing down the ports where you may need to resort
    to an SYN scan can help with stealth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open|Filtered**: This is to be read, in plain English, as “open or filtered.”
    It’s one of the special results for certain scan types and it means Nmap can’t
    be sure if the port is open or filtered when running a scan type where open ports
    are expected to give no response. For example, consider the UDP scan that we discussed
    previously. UDP is connectionless, so an open UDP port may not respond to our
    probes. Another example is the NULL or Xmas scans, which rely on the RFC’s prescription
    of merely dropping weird packets received at open ports – Nmap is expecting that
    there will be no response. Naturally, this leaves us asking, “*How do we know
    that there isn’t a firewall that silently dropped our packet, and it never even
    made it to the port?*” This is why Nmap is telling you “open or filtered.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closed|Filtered**: Just like the previous one, but “*closed*” instead of
    “*open*” – Nmap can’t tell if the targeted port is actually closed or if it’s
    just being filtered. The special situation here is the idle zombie scan. Recall
    that if our probe hits an open port on the target, the target will reply SYN/ACK
    and send it to the zombie. The zombie, not expecting any SYN/ACK from our target,
    responds with an RST packet – thus, this packet increments the fragment ID counter
    and Nmap will consider the port open. But what if our probe hits a closed port
    on the target? Then the target sends an RST to the zombie – and if the zombie
    is following the functional specification, it will *ignore* our target’s RST packet.
    Thus, there is no response and no fragment ID is incremented. Now, suppose the
    port can’t be reached because of a firewall – then nothing ever reaches the target,
    which means it has no reason to send anything to the zombie, which accordingly
    sends no packets to increment the fragment ID. From the perspective of the Nmap
    scanner that is monitoring the zombie, there’s no way to know the difference between
    closed and filtered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a nice foundation for Nmap discovery, probing, and the responses
    from these probes, it’s time to dive into Nmap’s ability to evade detection.
  prefs: []
  type: TYPE_NORMAL
- en: Firewall/IDS evasion, spoofing, and performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “Oh, the Noise! Noise! Noise! Noise! That’s one thing he hated!”
  prefs: []
  type: TYPE_NORMAL
- en: –Dr. Seuss
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already covered some scanning techniques that can serve as firewall
    or IDS evasion: the NULL, FIN, Xmas, and Maimon scans. However, keep in mind that
    this tool is fairly old and has been in active development for several years.
    The clever tricks that Nmap can cook up have been known for a long time, so any
    IDS will know something is up. The story isn’t over, though: advancements in technology
    have been accompanied by an increase in network chatter. Just loading a simple
    website takes a lot more data than it used to, and there are many legitimate reasons
    why a host may be querying others in a way that’s exciting for hackers. This all
    adds up to *noise*. Add into this equation the business component: your clients
    are businesses first and foremost. This is the entire reason your role even exists,
    so respect it! Business needs will always clash with security needs, and the ideal
    solution is going to be a delicate balance between the two. What this means for
    us during our Nmap analysis is simple – attempting to research every single potentially
    suspicious activity is simply unfeasible. Thus, the defense tends to work with
    *thresholds*. There are two main perspectives here: you can confuse the defender,
    or you can fly under the radar.'
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s look at confusing the defender. Nmap lets you fragment its packets
    (**-f**), and you can precisely define how fragmented things will get. The idea
    here is that there are just so many packets for any given task that it makes it
    harder for the defenders to screen them. Keep in mind that firewalls and hosts
    can choose to queue up all the fragments – however, this might be impractical
    for large networks. One of my favorite ways of creating confusion is the decoy
    option (**-D**), which performs your scanning activities normally but also generates
    packets with spoofed return addresses. Unlike the idle zombie scan, we get our
    probes back here; however, the defender will see any number of *other* hosts scanning
    them, too! The best way for this to work is by using hosts that are up, so use
    IP addresses from your host discovery phase. You can also just do a good old-fashioned
    source address spoof (**–S**), but as you may imagine, you won’t get the responses
    back. There might be situations in which this source address spoof is useful,
    though. For example, perhaps you’re able to intercept all the traffic so that
    you can see the response anyway. The other kind of source spoof that is useful
    is spoofing the port number (**-g**). Due to oversight or otherwise, many firewalls
    don’t restrict source ports. An additional step you can take when creating confusion
    is appending custom data to the packets (**--data** for hex and **--data-string**
    for strings). This is very much dependent on the situation, but you can imagine
    the amount of power Nmap gives you over your probes.
  prefs: []
  type: TYPE_NORMAL
- en: The other perspective is flying under the radar. Any intrusion detection system
    has some means of logging something that triggered a rule, and it’s surprising
    how often we can go unnoticed simply by being slow. Though Nmap is well-known
    for its speed, sometimes, that’s the opposite of what you need – and not just
    for dodging defenses, either. You may be stuck with rate limiting or a bad connection.
    Nmap gives you some timing control by offering both timing templates (**-T**)
    and the ability to define the time between probes and parallelization. Let’s take
    a look at the templates, which have predefined values for the time between probes
    and how parallelization works. First, you have **paranoid** (**-T0**). As its
    name suggests, it is extremely slow – 5 minutes between probes and no parallelization.
    The next level up is **sneaky** (**-T1**), which is more reasonable while still
    being evasive. The delay between probes reaches 15 seconds, but packets are still
    sent one at a time. Next is **polite** (**-T2**), which increases the speed to
    0.4 seconds between probes. This sounds decently fast but it is still well below
    Nmap’s ability – it is “*polite*” because it’s not trying to be evasive; it’s
    just being nice to resources. The default setting of Nmap is called **normal**
    (**-T3**, though you’d merely omit this flag for the same settings), where we
    start parallelizing our probes. The **aggressive** (**-T4**) and **insane** (**-T5**)
    modes are useful when speed is a paramount concern and you have a very fast network.
    **aggressive** mode is fine for assessing large organizations with zippy resources,
    but **insane** mode is probably better for testing or demonstration purposes,
    or on very fast networks. After all, the author of the tool *did* warn us when
    he called it insane.
  prefs: []
  type: TYPE_NORMAL
- en: Service and OS detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s blindly knocking on a door, and then there’s reading all the signage
    out front. Nmap can go well beyond merely establishing the presence of a service
    – it will have a nice chat with it and gather information about the service. While
    it runs, Nmap references a database to parse the information and return version
    information. You can tweak the *intensity* of the version analysis (**--version-intensity**)
    to a level between 0 and 9\. The default is already 7, so you won’t need 8 or
    9 until you suspect something esoteric.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to a database that helps Nmap parse version information out of conversations
    with services, Nmap also has a database that contains more than 2,600 OS *fingerprints*
    that allow it to determine the host OS based on how the TCP/IP stack behaves.
    We explored this concept in [*Chapter 2*](B17616_02_Final_VK_ePub.xhtml#_idTextAnchor033)*,
    Bypassing Network Access Control*, when we used **p0f** to fingerprint OS fingerprints.
    It considers things such as Time To Live, Maximum Segment Size, and more to guess
    the OS that sent those packets. Keep in mind that it is a guess, so its reliability
    can vary. Also, keep in mind that, as we have learned, you can use the database
    to build custom packets (for example, with Scapy) that Nmap will say came from
    any OS you please. Maybe it’s a Windows XP box, maybe it’s a Linux box that wants
    to look like XP.
  prefs: []
  type: TYPE_NORMAL
- en: The Nmap Scripting Engine (NSE)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If I had to reduce Nmap to just two core features, I’d call it a port scanner
    and a networking scripting engine. This is where Nmap is blurring the lines between
    a simple network testing utility up to a vulnerability scanner and a pen testing
    sidekick. Using the Lua programming language, anyone can create scripts to automate
    Nmap to not just conduct all of the recon discussed previously, but even probe
    for and (safely) exploit vulnerabilities. In Kali, head on over to **/usr/share/nmap/scripts**
    and punch in **ls | grep "http"** to see what’s available for just that protocol
    alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'By way of example, let’s use Nmap to look for VNC connections that don’t require
    authentication. We will invoke the script in question with **–-script <name>**,
    which you can copy right out of the **scripts** folder (leave out the **.nse**
    extension). Then, running as root, we will execute **nmap -–script vnc-brute –p
    5900 -–open 192.168.108.0/24** and wait for the scan to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Running Nmap with an NSE script enabled ](image/Figure_5.01_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Running Nmap with an NSE script enabled
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Nmap is doing its job – and for each host, the script steps
    in and does its job.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on with Nmap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Okay, that’s a lot of theory – now, let’s sit down with Nmap. I think your
    first step should always be to run Nmap with no arguments, causing the help screen
    to appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Running Nmap with no arguments ](image/Figure_5.02_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Running Nmap with no arguments
  prefs: []
  type: TYPE_NORMAL
- en: I’ve done this so that we can step through building our command. This help screen
    is fantastic, allowing us to use a command-line tool while offering the experience
    of ordering a three-course meal. **Host Discovery** is the crab cake appetizer,
    **Scan Techniques** is the steak, **Service Detection** is the side of potatoes
    (or vegetables if you’re watching your carbs), and so on. Let’s build our scenario
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose I want to simply look for web servers on either port 80 or 443\.
    I don’t want to discover which ones are up first; I want to check every single
    IP in the range, just so I know I’m not missing anything. The web servers are
    always found in the 10-20 section of several slash-24 subnets; that is, of the
    256 possible IPs ranging from 0 to 255, our targets will end in a number between
    10 and 20\. The range starts at **10.10.105.0** and ends at **10.10.115.255**.
    I want to use half-open scanning so that the application doesn’t log a connection.
    If servers are discovered, I want to grab version information. I want this to
    be reasonably fast, but I’ve been asked by my client’s networking administrator
    to be friendly with the probes. Finally, I want the results to only include hosts
    where these ports have been established as open or possibly open. Okay, let’s
    look at our menu, saving the target specification for last:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Identifying our desired host discovery option ](image/Figure_5.03_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Identifying our desired host discovery option
  prefs: []
  type: TYPE_NORMAL
- en: 'I don’t want to establish if a host is online – I just want to get to port
    scanning. So, my first argument is **–Pn**. Now, let’s look at the scan techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Identifying our desired scan technique ](image/Figure_5.04_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Identifying our desired scan technique
  prefs: []
  type: TYPE_NORMAL
- en: 'I want a half-open scan, so I have picked **–sS**. Now, let’s look at the port
    specification and service detection setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Identifying our desired port range and service detection setting
    ](image/Figure_5.05_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Identifying our desired port range and service detection setting
  prefs: []
  type: TYPE_NORMAL
- en: I know my ports are 80 and 443, and I only want to see confirmed open ports,
    so the next command is **–p 80,443 --open**. I want version information from the
    servers I find, so I have added **–sV**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the last step before we specify our targets is to configure timing. The
    keyword was “friendly” when the network admin asked us to tone it down, so let’s
    go with the polite template by adding **–T2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Identifying our desired timing template ](image/Figure_5.06_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Identifying our desired timing template
  prefs: []
  type: TYPE_NORMAL
- en: Now, we must define the target IP addresses. Thankfully, Nmap gives us the freedom
    to use more human-friendly methods of defining ranges; a dash between two numbers
    makes that a range, and you can do it within the octets. So, we know our range
    starts at **10.10.105.0** and ends at **10.10.115.255**. Thus, this makes the
    specification **10.10.105-115.255**. Ah, but wait – we only want the 10 addresses
    from 10 to 20\. Therefore, the specification is **10.10.105-115.10-20**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put it all together to see your command on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The full command, ready for execution ](image/Figure_5.07_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The full command, ready for execution
  prefs: []
  type: TYPE_NORMAL
- en: Where you will really enjoy Nmap’s power is in Metasploit Console. Let’s take
    a look.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Nmap with Metasploit Console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you want to run some auxiliary modules in Metasploit and you want to
    do some host discovery first. Here’s the catch, though – you want the discovered
    hosts that meet your criteria to be in Metasploit’s PostgreSQL database. Look
    no further than **db_nmap**, the incarnation of Nmap that works directly with
    your database.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make sure the database is up and initiated. If you haven’t
    done that already, go ahead and run **msfdb init**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Configuring Metasploit’s database for the first time ](image/Figure_5.08_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Configuring Metasploit’s database for the first time
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’re up and running, load up Metasploit with the **msfconsole** command.
    When the **msf6** prompt appears, check the database’s status with **db_status**.
    Assuming we’re ready to go, I can just fire off **db_nmap** right here at the
    **msf6** prompt. I only want Nmap to spit out hosts where the port is confirmed
    open, so I am using the **–-open** flag here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Running db_nmap within our Metasploit Console session ](image/Figure_5.09_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Running db_nmap within our Metasploit Console session
  prefs: []
  type: TYPE_NORMAL
- en: 'Once our scan is complete, a simple **hosts** command will query the database
    for the hosts we’ve captured. As you can see, there were three hosts running VNC
    on port **5900**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – db_nmap output entered into the database ](image/Figure_5.10_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – db_nmap output entered into the database
  prefs: []
  type: TYPE_NORMAL
- en: Now, I will switch over to the auxiliary scanner with the **use scanner/vnc/vnc_login**
    command. I’ll run the **hosts** command again, but this time, I’ll pass **–R**
    to auto-populate the **RHOSTS** property of the module!
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I can use **run** or **exploit** to run this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Setting RHOSTS with the database entries and running the module
    ](image/Figure_5.11_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Setting RHOSTS with the database entries and running the module
  prefs: []
  type: TYPE_NORMAL
- en: As you can imagine, being able to let Nmap work directly with Metasploit’s database
    makes our lives a whole lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a break from Nmap and Metasploit and get into something truly invasive
    – intercepting binaries and injecting our own.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring binary injection with BetterCAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050), *Sniffing
    and Spoofing*, we explored custom filters with Ettercap to manipulate traffic
    on the fly. When we can serve as the go-between, the possibilities are exciting:
    we can manipulate messages between the server and user, even to the extent of
    delivering an executable masquerading as their requested file. BetterCAP continues
    to make things better (and easier) by allowing for slick automation of this process.
    In this exercise, we’re going to prepare a malicious executable for a Windows
    target and call it **setup.exe**. Then, we’ll set up a man-in-the-middle proxy
    attack that will intercept an HTTP request for an installer and invisibly replace
    the downloaded binary with ours. We’ll be covering these concepts and tools in
    more detail later in this book, so consider this an introduction to the power
    of custom modules in advanced man-in-the-middle attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: The magic of download hijacking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, curl up with a cup of hot cocoa while Grandpa Phil rocks in his chair and
    regales you with tales from the distant past (2018, when the first edition was
    published). Back then, BetterCAP was a CLI tool and we could tweak the underlying
    functionality after brushing up on our Ruby. These days, as we saw in [*Chapter
    3*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050), *Sniffing and Spoofing*,
    BetterCAP is a slick and powerful point-and-click environment sporting an HTTP
    UI and even an API. (If you’re a scripter and you understand how to work with
    APIs, you’ll drool at the opportunity inherent to BetterCAP.) The environment
    allows you to manage **caplets**, the new word for modules. For our binary injection
    exercise, we’ll be working with the **download-autopwn** caplet. The principle
    is straightforward – wait for an executable to be requested, then drop our executable
    in its place. The process is seamless – our payload is delivered by the same mechanism
    that was queried, so we don’t have to masquerade the interface or messages. BetterCAP
    will even do us the favor of stuffing the executable with fluff to meet the file
    size, which is especially useful when our payload is a lightweight connect-back
    Trojan.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Your Environment Ready
  prefs: []
  type: TYPE_NORMAL
- en: If you aren’t joining us from [*Chapter 3*](B17616_03_Final_VK_ePub.xhtml#_idTextAnchor050),
    *Sniffing and Spoofing*, you’ll need to get BetterCAP installed and running on
    Kali. First, run **apt-get update && apt-get install bettercap** to get it installed.
    Then, run the **bettercap –caplet http-ui** command. Don’t forget that the default
    credentials are **user:pass**. Open a new shell window as root for the other activities
    here; BetterCAP will run in the background and wait for your HTTP session.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the payload and connect-back listener with Metasploit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, you can replace a target file with anything you want. For our demonstration,
    we’ll create a payload designed to connect back to our Kali box where a listener
    is ready. Setting it up will give us a little more hands-on experience with the
    mighty Metasploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create our payload with **msfvenom**, a standalone payload generator.
    We’ll be having more fun with **msfvenom** later in this book. I will only run
    the command after I’m established on the network where I want to receive my connect-back
    from the target, so I will start with an **ifconfig** command to grep the connect-back
    IP address that needs to be coded into the payload. In this case, it’s **192.168.249.136**,
    so I will run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Generating a payload with msfvenom ](image/Figure_5.12_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Generating a payload with msfvenom
  prefs: []
  type: TYPE_NORMAL
- en: The options are straightforward: **-p** defines our payload, which in this case
    is the connect-back **meterpreter** session, **-f** is the file type, and **lhost**
    is the IP address that the target will contact (that’s us) on **lport** (**1066**
    because of the Battle of Hastings – just a little trivia to keep things interesting).
    Finally, the **-o** flag allows us to specify where the output will go. In our
    situation, BetterCAP will expect the payload to be called **payload.exe**, so
    I’m setting that here to save me a step later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we send our naughty program somewhere, we need a listener standing by.
    Here, we must fire up msfconsole, enter **use exploit/multi/handler**, and set
    our options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Configuring our handler for the inbound connection ](image/Figure_5.13_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Configuring our handler for the inbound connection
  prefs: []
  type: TYPE_NORMAL
- en: '**LHOST** can be the IP that’s been assigned to our interface or just the zero
    address. Make sure **LPORT** matches what you configured in your payload executable.
    Execute **exploit** and wait for our **meterpreter** session to phone home. Now,
    we can configure and launch BetterCAP. Meanwhile, our target, **192.168.249.139**,
    was engaged in some water cooler chat about a tool called **PdaNet**. He’s planning
    on downloading the installer, **PdaNetA5232b.exe**. Our listener is ready, so
    now, we can jump back to BetterCAP to configure the **download-autopwn** caplet
    and get a better understanding of what it’s going to do.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting cozy with caplets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you’re logged in to the BetterCAP console, click on the **Caplets** icon
    at the top and browse the list along the left. One glance and you will know this
    tool is *fun*. For now, click on **download-autopwn**. On the right-hand side,
    you’ll see the contents of two files: **download-autopwn.cap** and **download-autopwn.js**.
    The parameters for your attack can be edited in the CAP file; the JavaScript code
    is the actual muscle behind the operation. I don’t find the interface user-friendly
    in this instance, so I’m going to check out the CAP file with nano in a separate
    terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Reviewing a caplet ](image/Figure_5.14_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Reviewing a caplet
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we make any changes, we need to understand how this works. Once the
    proxy is up, the underlying machinery is going to conduct this attack in the following
    phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the requested path to find any file extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the requested path contains an extension, check the user agent data for the
    target OS(s).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the request comes from a target, check the list of target file extensions
    for that system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have configured padding, BetterCAP examines the size of our payload and
    adds any needed null bytes to fill the file to the brim.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, BetterCAP prepares the response message in three steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Content-Disposition response header is set to **attachment**. This ensures
    that the browser won’t try to display a response page but instead push the download
    right to the browser.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The Content-Length header gets stripped.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The payload bytes become the body of the response message.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fun, right? It’s a big step up from the BetterCAP download intercept of ages
    past. The biggest change is the ability to target machines with their user agent
    data and regex matching. Don’t worry about this fine-tuning now, though – out
    of the box, it’s designed to intercept everything it can see. (Note that our Windows
    target is already defined.) So, tuning our intercept for this session is as easy
    as commenting out the appropriate line. I’m going to comment out everything except
    Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Configuring the target system in the download-autopwn caplet
    ](image/Figure_5.15_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Configuring the target system in the download-autopwn caplet
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can scroll down to file extensions. It’s a gold mine, and I encourage
    you to brainstorm some possibilities (malicious APK for Android, anyone?), but
    for now, we’ll comment out the unneeded lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Setting the target file extension in the download-autopwn caplet
    ](image/Figure_5.16_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Setting the target file extension in the download-autopwn caplet
  prefs: []
  type: TYPE_NORMAL
- en: I’m in a lab environment, so I’m not worried about the other file types for
    now, but just be aware that you will want to remove (or add) whatever you need
    for your situation. Finally, the finishing touch is to enable ARP spoofing; this
    friendly caplet can take care of that for us. We’re going to configure our spoofer
    with results from a network probe, so I’ll leave this line commented out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’re all set! Let’s save that modified buffer and take a quick look at
    BetterCAP’s folder layout. Instead of prompting you during the attack, BetterCAP
    will assume you’ve prepped the payload accordingly – that is, you’ve named it
    **payload** and placed it in the appropriate target folder. Let’s run **ls** against
    the **download-autopwn** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – File listing in the Windows payloads subfolder ](image/Figure_5.17_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – File listing in the Windows payloads subfolder
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s all coming together now, right? Note that by looking at the file sizes,
    these aren’t real payloads. Think of this as a template. So, at this point, we
    go back to our home directory (or wherever you spat out **payload.exe** from **msfvenom**)
    and move it back to the Windows payloads subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – File listing to confirm the size of payload.exe ](image/Figure_5.18_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – File listing to confirm the size of payload.exe
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the sizes one more time, we can see that our 76K file made it over.
    We’re ready to rock and roll, and just in time: **192.168.249.139** is getting
    back to his desk to download that nifty tool. We’ve been sitting at our workstation
    running a probe of our surroundings. Find the target’s IP address, click the dropdown,
    and select **Add to arp.spoof.targets**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Configuring the ARP spoof ](image/Figure_5.19_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Configuring the ARP spoof
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you add the target, BetterCAP will take you to the configuration for arp.spoof
    and import the probed hosts. This is where you can add other hosts (such as the
    gateway!) and enable things such as full-duplex spoofing. We want to intercept
    a request out to the internet, so we need these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Configuring full-duplex ARP spoofing with the gateway ](image/Figure_5.20_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Configuring full-duplex ARP spoofing with the gateway
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can click **Start arp.spoof** and let BetterCAP do its thing. You’ll
    see feedback in the form of pretty popups in the browser, but you’ll see these
    updates in the terminal, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s all – we’re ready to begin. Head back to the **Caplets** tab, select
    **download-autopwn**, and then click the play button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Firing off the caplet ](image/Figure_5.21_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – Firing off the caplet
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we’ll want to watch the progress in the terminal window. The
    log tells us that **download-autopwn** has been enabled and reminds us of our
    parameters. If we get a bite on our fishing line, this is where we’ll see it happen.
    Meanwhile, our target is browsing the home page for the download and spots the
    Windows client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Browsing for files to download on the victim’s browser ](image/Figure_5.22_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Browsing for files to download on the victim’s browser
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, on our end, we get the report: the target extension was seen, the
    raw size of our payload is smaller than the requested file, so it gets fluffed
    up, and the spoofed response is served:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23 – The bait and switch is complete ](image/Figure_5.23_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23 – The bait and switch is complete
  prefs: []
  type: TYPE_NORMAL
- en: 'At long last, we can go back to our Metasploit session to wait (and hope) for
    our Meterpreter session to begin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24 – New Meterpreter session from the target ](image/Figure_5.24_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24 – New Meterpreter session from the target
  prefs: []
  type: TYPE_NORMAL
- en: 'I know what you’re thinking – “*Phil, I just did all these steps with this
    Windows 10 VM I set up, and Defender deleted the payload immediately.*” Indeed;
    for the sake of demonstration, we spat out a plain Meterpreter payload with msfvenom,
    an output that will certainly be flagged by antivirus. This is where the art of
    **antivirus evasion** comes into play, which we’ll look at in [*Chapter 12*](B17616_12_Final_VK_ePub.xhtml#_idTextAnchor224),
    *Shellcoding – Evading Antivirus*. It’s also worth noting a social engineering
    component: surely, the victim will wonder why apparently nothing happened when
    he executed the installer. We’ll also look at dynamic injection with Shellter
    in [*Chapter 7*](B17616_07_Final_VK_ePub.xhtml#_idTextAnchor124), *Advanced Exploitation
    with Metasploit*, as well as how to create message box payloads. Imagine if it
    said something like, **Error detected – please download again**. It’s surprising
    how effective that would be against a lot of people.'
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, we’re going to look at another evasive technique for getting
    our packets around a filtered network.
  prefs: []
  type: TYPE_NORMAL
- en: Smuggling data – dodging firewalls with HTTPTunnel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, curl up with another cup of hot cocoa as Grandpa Phil tells you an RDP
    fairytale. We’re going to build a hypothetical situation in which we are lucky
    enough to have a foothold on a Linux server that’s behind a firewall. The firewall
    allows HTTP ports **80**, **443**, and **1433**. You communicated with the server
    over its web service and discovered it is running a vulnerable Apache server.
    We compromised it with a PHP payload and got a shell through the firewall. Here’s
    your extra credit assignment – look at the following screenshot of the payload
    being delivered and figure out the nature of the vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Exploit extra credit – how we compromised our target ](image/Figure_5.25_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25 – Exploit extra credit – how we compromised our target
  prefs: []
  type: TYPE_NORMAL
- en: It’s an oldie but a goldie vulnerability. Despite its age, it’s not unusual
    to see it on internal networks in large organizations. But I digress – back to
    our compromised Linux box.
  prefs: []
  type: TYPE_NORMAL
- en: What we’ve found is that our compromised Linux server can see a Windows 10 box
    that we want to access with Remote Desktop. We’ve also found that port **1433**
    isn’t hosting a service on the Linux box – presumably, it’s an artifact from an
    older configuration. This is useful but we’re also restricted by deep packet inspection
    – the firewall only permits HTTP traffic. Take a look at the following diagram.
    What’s a hacker to do?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.26 – HTTP-only firewalling  ](image/Figure_5.26_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.26 – HTTP-only firewalling
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have a root shell on the Linux server, so we could build an HTTP-encapsulated
    tunnel that links our two boxes, and then use the Linux server to contact the
    Windows target on RDP port **3389**. Thankfully, the perfect tool exists for this
    job – HTTPTunnel. In our example, the target server is running Ubuntu and HTTPTunnel
    happens to exist in the repository, so we can drop into the popped shell and pass
    the **apt-get install httptunnel** command on *both* ends – on our Kali attacking
    box and the Ubuntu compromised server. This will install two components: the HTTPTunnel
    *client*, **htc**, and the HTTPTunnel *server*, **hts**. Both ends work via port
    forwarding – **htc** will open a listening port and pass the received data to
    **hts** on the other end of the tunnel; then, **hts** will forward it to a port
    of our choosing. Thus, we’ll need something listening on the **hts** side of the
    tunnel to receive this data. In our example, we’ll use SSH as it’s already on
    the Ubuntu server. Confused yet? Let’s take a better look at this flow before
    continuing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.27 – Simplified data flow between the three points in play ](image/Figure_5.27_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.27 – Simplified data flow between the three points in play
  prefs: []
  type: TYPE_NORMAL
- en: We’ll hand off our RDP data to HTTPTunnel on local port **8000** to the server
    running on remote port **1433**; then, this data will be handed off to the SSH
    listener on local port **3535** before getting spat out on remote port **3389**
    on the Windows box. Note that the only arbitrary port numbers here are for the
    local listeners; **1433** is necessary because it’s what the firewall permits,
    and **3389** is the Remote Desktop port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have HTTPTunnel installed, we need to set up our listeners on the compromised
    Ubuntu server. First, let’s set up SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order, the preceding command sets up a listener on port **3535**, which
    will be forwarded to port **3389** on the host **192.168.108.173** (our Windows
    10 target), and we’re authenticating it with a local user (this could have been
    compromised or you simply created one when you first took control). Next, let’s
    look at the server side of our HTTP tunnel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In order, this command tells **hts** where to send the data that’s coming out
    of our tunnel (to local port **3535**, where SSH is ready) and which port to open
    (**1433**) for an incoming connection from **htc**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check the status of our listeners with tools such as **netstat** or
    **ss** and **grep**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.28 – Configuring and validating our tunnel in a reverse shell session  ](image/Figure_5.28_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.28 – Configuring and validating our tunnel in a reverse shell session
    with the compromised server
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good. The mechanism that will take the data leaving our HTTP tunnel
    and pass it along to our target’s RDP port is up and running. Now, we need to
    get the client side going. Back in our Kali box, we must pass the **htc –-forward-port
    8000 192.168.108.116:1433** command. In order, this tells **htc** to open local
    port **8000** and send it to the **hts** listener on port **1433** at **192.168.108.116**
    (our compromised Ubuntu server). Again, we must verify that the port is indeed
    up and listening:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.29 – Configuring and validating the client side of our tunnel on
    the attacking Kali box ](image/Figure_5.29_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.29 – Configuring and validating the client side of our tunnel on the
    attacking Kali box
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s it. It may seem precarious, but we can now connect to the RDP server
    behind the HTTP-only firewall by just pointing our tools at local port **8000**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.30 – An RDP session through the HTTP tunnel ](image/Figure_5.30_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.30 – An RDP session through the HTTP tunnel
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re trying this out in your own lab, I recommend firing up Wireshark
    to see the behind-the-scenes action. Note the plain TCP designation; our RDP channel
    is TLS-encrypted, showing that the encrypted data is indeed encapsulated in HTTP.
    Also, note that the network shows us just having a friendly chat with **192.168.108.116**
    on port **1433**, while we’re actually having a desktop session with **192.168.108.173**
    on port **3389**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.31 – The network perspective of our encapsulated RDP session ](image/Figure_5.31_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.31 – The network perspective of our encapsulated RDP session
  prefs: []
  type: TYPE_NORMAL
- en: There are a tremendous number of opportunities with this kind of redirection.
    Later in this chapter, we’ll even cover sending our local IPv4 traffic to a remote
    IPv6 host. But first, let’s get familiar with the basics.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 for hackers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I know I say this a lot about certain topics, but a deep dive into the particulars
    of IPv6 could fill its own book, so I have to pick and choose for the discussion
    here. That said, I will cover some introductory knowledge that will be useful
    for further research. As always, my advice for IPv6 is to read the authoritative
    RFCs. RFC 2460 was the original detailed definition and description of the new
    version, but it was a *Draft Standard* for all those years. The levels of *Standard* refer
    to the maturity of the technology being defined, with the *Proposed Standard*
    being the least mature, and the *Internet Standard* being the gold, well, standard.
    IPv6, after those long years, has become an Internet Standard with RFC 8200 (STD
    86) as of July 2017\. Though I certainly encourage reading RFC 2460, it is now
    officially obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 is important to pen testers for two big reasons – one (and hopefully most
    obviously), it’s the newest version of the internet, so you’re only going to see
    more of it; and two, as with many newer things that haven’t quite replaced the
    predecessor yet, it’s not given the same level of security scrutiny in most environments.
    Many administrators aren’t even aware that it’s enabled. You may get some useful
    findings with just basic poking around, and regardless, you’ll help raise awareness
    of this new protocol.
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 addressing basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are quite a few differences between IPv4 and IPv6; I recommend researching
    those differences by studying the structure of an IPv6 packet. Probably the most
    obvious difference is the address. At first glance, IPv6 addresses are bewildering
    to look at. Aside from being longer than IPv4 addresses, they’re represented (in
    text form) with hexadecimal characters instead of decimal. These scary-looking
    addresses are part of one of the improvements over IPv4 – the address space. An
    IPv4 address is four groups of 8 bits each (an octet), for a total of 32 bits.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the total number of available IPv4 addresses is *2*32 = *4.294967296*
    billion, to be exact. Back in the 1970s, this big-sounding number seemed like
    plenty, but IPv4 address exhaustion soon became a legitimate threat and then,
    starting in the past decade, a reality. Consider, on the other hand, the IPv6
    address: eight groups of four hexadecimal characters each (a single hex character
    takes up 4 bits); therefore, eight groups of 16 bits each (a hextet) for a total
    of 128 bits. Therefore, the total address space is *2*128 = *340,282* decillion addresses.
    That’s enough for every grain of sand on Earth to have 45,000 quadrillion IP addresses
    each. In informal language, this is *quite the handful*. When working with IPv6
    addresses, you may see something as long as **2052:dfb8:85a3:7291:8c5e:0370:aa34:3920**,
    down through something such as **2001:db8:85ad::2:3**, and even down to the IPv6
    zero address (unspecified address), which is just two colons – **::**. So, the
    easiest way to understand them is to start with the core, uncompressed address,
    and then check out the IETF convention for simplifying them.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve just learned, the raw IPv6 address is eight groups of four (lowercase)
    hexadecimal characters, and the groups are separated by colons. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two main compression rules. The first is the omission of initial zeros
    (not entire groups of zero; that’s next) within a hextet. **00aa** becomes **aa**, **05f4**
    becomes **5f4**, and **000e** becomes **e**. In our example, there are three groups
    with initial zeros, so our address becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The second rule involves conversing all-zero groups into double colons (**::**).
    This rule applies to adjacent groups of all zeros; if there are two or more adjacent
    groups of all zeros, they are all replaced with a single double colon. Single groups
    of all zeros are not suppressed and instead are represented with a single **0**.
    If there happens to be more than one multiple group run of zeros, then the leftmost
    run of zeros is suppressed and the others are turned into single-zero groups.
  prefs: []
  type: TYPE_NORMAL
- en: By only compressing adjacent groups of zero, and by only doing this compression
    once per address, we prevent any ambiguity. If you’re wondering how many uncompressed
    groups of zero are represented by a double colon, just remember that the full
    IPv6 address is eight groups long – so you’ll convert it into however many groups
    it takes to make an even eight.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, there is a single multiple-group run of zero (two groups),
    so those eight adjacent zeros become a double colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This looks quite a bit more manageable than the uncompressed address, right?
    By following those compression rules, the result is the same address as the first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, let’s take a look at a few more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 5.1](image/Table_5.01_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Okay, you have IPv6 address compression fundamentals in your pocket. Let’s take
    a look at some practical discovery tools for IPv6 environments.
  prefs: []
  type: TYPE_NORMAL
- en: Watch me neigh neigh – local IPv6 recon and the Neighbor Discovery Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, you’re on the network and you need to do some recon to find out what’s out
    there in IPv6 land. I know what the hacker in you is thinking at this point –
    “*well, it was feasible to scan even large swaths of the IPv4 address space, but
    a 2128 address space? That’s just a waste of time at best*.” Right you are! Trying
    to combine the **-6** flag in Nmap with a range of addresses will give you an
    error. So, we have to think a little differently about host discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Before we pull out the offensive toolkit, let’s go back to basics with **ping**.
    If you review the man page for **ping**, you’ll find IPv6 support; but, we can’t
    do a ping sweep like in the good old days. Not a problem – we’ll just ping the
    link-local multicast address. By definition, this will prompt a reply from our
    friendly neighbors and we’ll have some targets. There’s a nice chunk of multicast
    addresses defined for IPv6 for different purposes (for example, all routers on
    the local segment, RIP routers, EIGRP routers, and so on), but the one to memorize
    for now is **ff02::1**. We’ll be effectively mimicking the Neighbor Discovery
    Protocol’s solicitation/advertisement process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to fire off an IPv6 **ping** command pointing at link-local multicast
    address **ff02::1** to trigger responses from hosts on our segment, which will
    populate the neighbor table; then, we’ll ask **ip** to show us those discovered
    neighbors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.32 – IPv6 neighbors ](image/Figure_5.32_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.32 – IPv6 neighbors
  prefs: []
  type: TYPE_NORMAL
- en: Notice a pattern with the responses? All of the addresses belong to **fe80::/10**.
    The hosts responded with a link-local address, which it will have in addition
    to any globally unique address. We gathered this by pinging the link-local multicast
    address, after all. Pinging is an active task; by conducting some passive listening,
    we may hear devices confirming via the ICMP6 neighbor solicitation and **Duplicate
    Address Discovery** (**DAD**) process that their assigned address is unique. Now,
    we can open up our offensive toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard Swiss-army knife of IPv6 poking and prodding is THC-IPV6, which
    is included with Kali Linux. We command the **detect-new-ip6** tool to listen
    on our interface for any ICMP6 DAD messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see data being returned as new addresses are seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.33 – Detecting new addresses with DAD detection ](image/Figure_5.33_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.33 – Detecting new addresses with DAD detection
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve gathered some targets to start scanning for services with the
    **-6** flag in Nmap. Thanks, DAD!
  prefs: []
  type: TYPE_NORMAL
- en: IPv6 man-in-the-middle – attacking your neighbors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you’ve probably had enough ARP to give you a headache. Don’t worry –
    IPv6 has a different process for resolving link-layer addresses to IPv6 addresses.
    However, it seems the designers didn’t want us to be bored – we can still spoof
    and manipulate the procedure, just as in IPv4 and ARP, thus establishing a man-in-the-middle
    condition. Let’s take a look at how the **Neighbor Discovery Protocol** (**NDP**)
    resolution works in IPv6, and then we’ll attack it with THC-IPV6’s **parasite6**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll recall from sniffing ARP traffic that there are two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: Who has **<IP address>**? Tell **<host>**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<IP address>** is at **<MAC address>**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In IPv6, these two parts are called **neighbor solicitation** (**NS**) and **neighbor
    advertisement** (**NA**), respectively. First, the node with the query sends an
    NS message to the **ff02::1** multicast address. This is received by all the nodes
    on the segment, including the subject of the NS query. The subject node then replies
    to the requestor with an NA message. All of these messages are carried over ICMPv6.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s that straightforward. The method is a little different in how replies
    are processed, however. In IPv4 ARP, replies that map a link-layer address to
    an IP address can be broadcast without solicitation, and nodes on the segment
    will update their tables accordingly. In other words, the attacker can preempt
    any resolution request, so the target never identifies itself as the correct address.
    In IPv6 ND, the target system will reply to the NS with an NA directed at the
    requestor; in short, the requestor ends up receiving two NA messages for the same
    query, but they will be pointing to two different link-layer addresses, one of
    which is the attacker. Fun, right? Here’s where you’ll chuckle: by setting the
    ICMPv6 override flag, we tell the recipient to – you guessed it – override any
    previous messages. The requestor will get two answers: “*Hi, I’m the device you’re
    looking for*,” followed immediately by, “*Don’t listen to that guy, it’s actually
    me*.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our handy NDP spoofer is called **parasite6**. Yes, we need to set up packet
    forwarding so that traffic gets through our interface once the spoofing begins,
    but there’s another setup step required: suppression of ICMPv6 redirects. There
    are certain scenarios in which a device that’s forwarding IPv6 traffic (that would
    be you, the attacker) has to send back a redirect to the source, effectively telling
    the source to send traffic somewhere else.'
  prefs: []
  type: TYPE_NORMAL
- en: Certain conditions will trigger this, including forwarding traffic out the same
    interface through which it was received – oops. So, we’ll set up an **ip6tables**
    rule as well. Our friendly **parasite6** tool is nice enough to remind us at launch,
    just in case we forgot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep an eye out for that pesky number **6** when working with these protocols: **ping
    -6**, **nmap -6**, and **ip6tables** instead of **iptables**, and so on. There
    is a lot of conceptual and functional overlap, so be careful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates the output of the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.34 – Configuring IPv6 forwarding and filtering with ip6tables before
    launching the parasite6 attack ](image/Figure_5.34_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.34 – Configuring IPv6 forwarding and filtering with ip6tables before
    launching the parasite6 attack
  prefs: []
  type: TYPE_NORMAL
- en: Now, the attack is active and you can progress to the next stage of intercept
    and manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: Living in an IPv4 world – creating a local 4-to-6 proxy for your tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s a tool included with Kali that can be thought of as **netcat** on steroids:
    **socat**. This tool can do many things and we just don’t have enough room to
    go over it all here, but its ability to relay from IPv4 to IPv6 environments is
    especially useful. We’ve seen tools designed for IPv6, but we will occasionally
    find ourselves stuck needing a particular IPv4 tool’s functionality to talk to
    IPv6 hosts. Enter the **socat** proxy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept and setup are simple – we create an IPv4 listener that then forwards
    packets over IPv6 to a host where we have a potentially vulnerable web server
    that we want to scan with Nikto:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything happens in the background at this point, so you won’t see anything
    in the terminal. No news is good news with a **socat** proxy; if there’s a problem,
    it’ll let you know. Let’s take a look at these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TCP-LISTEN:8080** tells **socat** to listen for TCP connections and defines
    the local listening port – in this case, **8080**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**reuseaddr** is needed for heavy-duty testing by allowing more than one concurrent
    connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fork** refers to forking a child process each time a new connection comes
    through the pipe, used in tandem with **reuseaddr**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TCP6** comes after the space that tells **socat** what we’re going to do
    with the traffic that’s received on the listener side of the command; it says
    to send the traffic over to port **80** of a TCP target over IPv6\. Note that
    we need brackets here as the colon is used in both command syntax and IPv6 addresses,
    so this prevents confusion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, I can just point my toolset at my local port **8080**, and everything
    will be received by the target over IPv6 at port **80**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.35 – Running Nikto against a web server at an IPv6 address via a
    socat proxy ](image/Figure_5.35_B17616.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.35 – Running Nikto against a web server at an IPv6 address via a socat
    proxy
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the target and port have to be defined for **socat**. Do you
    know what would be really useful? A Python script that prompts for a host and
    port number and configures **socat** automatically. That’s something to consider
    for later.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went on a journey through the network of our client in terms
    of discovery and vulnerability analysis. We explored the power of Nmap in today’s
    day and age and demonstrated that it’s still the go-to for network mapping. We
    explored the underlying mechanisms of the different scan types and learned how
    to have Nmap interact directly with Metasploit for ease of targeting. Then, we
    learned how BetterCAP can compromise data streams in real time by swapping out
    a download with a malicious binary and got comfortable with the updated user interface.
    After playing with BetterCAP, we learned how we can encapsulate an arbitrary protocol
    inside an HTTP tunnel to bypass filters. We wrapped up this chapter with a review
    of IPv6 and some basic tooling with IPv6, including how to get by with IPv4 tools
    in an IPv6 environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, things are going to get goofy-exciting as we jump into
    some cryptography concepts and some lesser-known attacks that still manage to
    get overlooked in many environments. We’re going to not only play with these attacks,
    but we’ll also discuss the underlying mechanisms that make them tick.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-T1** ensures the fastest scan possible with Nmap. (True | False)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is the Maimon scan similar to the Xmas scan?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: BetterCAP’s **download-autopwn** can match the payload size with the size of
    the requested file. (True | False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What two components are necessary to build an HTTP tunnel between two hosts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The IPv6 counterpart to IPv4’s ARP is called __________.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the uncompressed representation of the link-local multicast address
    **ff02::1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the topics that were covered in this chapter,
    take a look at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'RFC 8200 ([https://tools.ietf.org/html/rfc8200](https://tools.ietf.org/html/rfc8200)):
    The IPv6 standard, current as of 2017'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC 2460 ([https://tools.ietf.org/html/rfc2460](https://tools.ietf.org/html/rfc2460)):
    The IPv6 standard, obsolete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC 5952 ([https://tools.ietf.org/html/rfc5952](https://tools.ietf.org/html/rfc5952)):
    Rules for IPv6 address representation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
