<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer155">
<h1 id="_idParaDest-107"><em class="italic"><a id="_idTextAnchor106"/>Chapter 6</em>: Cryptography and the Penetration Tester</h1>
<p>Julius Caesar is known to have used encryption – a method known today as <em class="italic">Caesar’s cipher</em>. You may think the cipher of one of history’s most well-known military generals would be a fine example of security, but the method – a simple alphabet shift substitution cipher – is probably the easiest kind of code to break. It’s said that it was considered secure in his time because most of the people who may have intercepted his messages couldn’t read. Now that you have a fun tidbit of history, let’s be reminded that cryptography has come a very long way since then, and your pen testing clients will not be using Caesar’s cipher.</p>
<p>Cryptography is a funny topic in penetration testing: it’s such a fundamental part of the entire science of information security but is also often neglected in security testing. We’ve explored avoiding the task of attacking encryption by finding ways to trick an application into sending plaintext data, but such attacks are not compromises of an encryption algorithm. In this chapter, we’re going to take a look at a few examples of direct attacks against cryptographic implementations. We are going to cover the following topics:</p>
<ul>
<li>Bit-flipping attacks against cipher block chaining algorithms</li>
<li>Sneaking in malicious requests by calculating a hash that will pass verification; we’ll see how cryptographic padding helps us</li>
<li>Padding oracle attacks; as the name suggests, we will continue to look at the padding concept</li>
<li>How to install a powerful web server stack</li>
<li>Installing two deliberately vulnerable web applications for testing in your home lab</li>
</ul>
<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Technical requirements</h1>
<p>For this chapter, you will need the following:</p>
<ul>
<li>Kali Linux running on a laptop</li>
<li>The XAMPP web server stack software</li>
<li>The Mutillidae II vulnerable web application</li>
</ul>
<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Flipping the bit – integrity attacks against CBC algorithms</h1>
<p>When we consider <a id="_idIndexMarker454"/>attacks against cryptographic ciphers, we usually think about those attacks against the cipher itself that allow us to break the code and recover the plaintext. It’s important to remember that the message can be attacked, even when the cipher remains unbroken and the full message is unknown. Let’s consider a quick example with a plain stream cipher. Instead of XOR bits, we’ll just use decimal digits and modular arithmetic. </p>
<p>XOR is the exclusive or operation. It simply compares two inputs and returns true if they are different. Of course, with binary, the inputs are either true (<strong class="source-inline">1</strong>) or false (<strong class="source-inline">0</strong>), so if the inputs are both <strong class="source-inline">1</strong> or both <strong class="source-inline">0</strong>, the result will be <strong class="source-inline">0</strong>. </p>
<p>We’ll make our message <strong class="source-inline">MEET AT NOON</strong> while using <strong class="source-inline">01</strong> for <strong class="source-inline">A</strong>, <strong class="source-inline">02</strong> for <strong class="source-inline">B</strong>, and so on. Our key will be <strong class="source-inline">48562879825463728830</strong>:</p>
<pre class="source-code">  13050520012014151514</pre>
<pre class="source-code">+ 48562879825463728830</pre>
<pre class="source-code">  --------------------</pre>
<pre class="source-code">  51512399837477879344</pre>
<p>Now, let’s suppose we can’t crack the algorithm, but we can intercept the encrypted message in transit and flip some digits around. Using that same key, throwing in some random numbers would just result in nonsense when we decrypt. But let’s just change a few of the final digits – now, our key is <strong class="source-inline">51512399837469870948</strong> and suddenly, the plaintext becomes <strong class="source-inline">MEET AT FOUR</strong>. We didn’t attack the algorithm; we attacked the message and caused someone some trouble. Now, this is a very rough example designed to illustrate<a id="_idIndexMarker455"/> the concept of attacking messages. Now that we’ve had some fun with modular arithmetic, let’s dive into the more complex stuff.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/>Block ciphers and modes of operation</h2>
<p>In our fun little example, we were working with a stream cipher; data is encrypted one bit at a time until it’s done. This is in contrast to <a id="_idIndexMarker456"/>a block cipher, which, as the name suggests, encrypts data in fixed-length blocks. From a security standpoint, this concept implies that secure encryption can easily be achieved for a single block of data; you could have high-entropy key material that’s the same length as the block. But our plaintext is never that short; the data is split into multiple blocks. How we repeatedly encrypt block after block <a id="_idIndexMarker457"/>and link everything together is called a <strong class="bold">mode of operation</strong>. As you can imagine, the design of a block cipher’s mode of operation is where security is made and broken.</p>
<p>Let’s look at probably the simplest (I prefer the word <em class="italic">medieval</em>) block cipher mode of operation, called <strong class="bold">Electronic Codebook</strong> (<strong class="bold">ECB</strong>) mode, so named because it’s inspired by the good old-fashioned literal <a id="_idIndexMarker458"/>codebook of wartime encryption efforts – you encrypt and decrypt blocks of text without using any of that information to influence other blocks. This would probably work just fine if you were encrypting random data, but who’s doing that? No one; human-composed messages have patterns in them. Now, we’ll provide a demonstration with <strong class="source-inline">openssl</strong> and <strong class="source-inline">xxd</strong> on Kali, which is a nice way to encrypt something and look at the actual result. I’m going to tell the world that I’m an elite hacker and I’m going to repeat the message over and over again – you know, for emphasis. I’ll encrypt it with AES-128 operating in ECB mode and then dump the result with <strong class="source-inline">xxd</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer131">
<img alt="Figure 6.1 – AES in ECB mode " height="655" src="image/Figure_6.01_B17616.jpg" width="1109"/>
</div>
</div>
<p class="figure-caption">Figure 6.1 – AES in ECB mode</p>
<p>Oh, nice. At first<a id="_idIndexMarker459"/> glance, I see just a bunch of random-looking hexadecimal characters jumbled together. A solid <a id="_idIndexMarker460"/>encrypted message should be indistinguishable from random data, so my work here is done. But, hark! Upon closer inspection, a very long string of characters repeats throughout:</p>
<div>
<div class="IMG---Figure" id="_idContainer132">
<img alt="Figure 6.2 – A hex dump reveals a pattern " height="565" src="image/Figure_6.02_B17616.jpg" width="850"/>
</div>
</div>
<p class="figure-caption">Figure 6.2 – A hex dump reveals a pattern</p>
<p>You may look at this and think – <em class="italic">So what? You still don’t know what the message is</em>. In the realm of cryptanalysis, this is a major breakthrough. A simple rule of thumb about good encryption<a id="_idIndexMarker461"/> is that the ciphertext should have no relationship whatsoever with the <a id="_idIndexMarker462"/>plaintext. In this case, we already know something is repeating. The effort to attack the message is already underway. </p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>Introducing block chaining</h2>
<p>With ECB, we were at the <a id="_idIndexMarker463"/>mercy of our plaintext because each block has its own thing going on. Enter <strong class="bold">cipher block chaining</strong> (<strong class="bold">CBC</strong>), where we encrypt a block just like before – except before we encrypt the next block, we XOR the plaintext of the next block with the encrypted output of the previous block, creating a logical chain of blocks. I know what the hacker in you is thinking now: <em class="italic">if we XOR the plaintext block with the encrypted output of the previous block, what’s the XOR input for the first block?</em> Nothing gets past you. Yes, we need an initial value – appropriately called the <strong class="bold">initialization vector</strong> (<strong class="bold">IV</strong>): </p>
<div>
<div class="IMG---Figure" id="_idContainer133">
<img alt="Figure 6.3 – Cipher block chaining in action " height="1370" src="image/Figure_6.03_B17616.jpg" width="1134"/>
</div>
</div>
<p class="figure-caption">Figure 6.3 – Cipher block chaining in action</p>
<p>The concept of an IV reminds me of when clients ask me, <em class="italic">what do you think of those password vault apps?</em> I tell them, they’re pretty great if you need help remembering passwords, and <a id="_idIndexMarker464"/>certainly better than using the same password for everything – but I just can’t shake that creepy feeling I get about the whole kit and caboodle depending on that one initial password. With CBC, security is highly reliant on that IV.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>Setting up your bit-flipping lab</h2>
<p>With a tiny bit <a id="_idIndexMarker465"/>of background out of the way, let’s dive in. We’re going to attack a web application to pull off the bit-flipping attack. What’s nice about this hands-on demonstration is that you’ll be left with a powerful web app hacking lab for your continued study. I bet some of you have worked with the famous <strong class="bold">Damn Vulnerable Web App</strong> (<strong class="bold">DVWA</strong>) before, but recently, I’ve found myself turning to the OWASP project Mutillidae II. I like to host <a id="_idIndexMarker466"/>Mutillidae II on the XAMPP server stack as its initial setup is fast and easy, and it’s a powerful combination; however, if you’re comfortable loading it into whatever web server solution you have, go for it.</p>
<p>If you’re following my <a id="_idIndexMarker467"/>lab, then first, download the XAMPP installer, <strong class="source-inline">chmod</strong> it to make it executable, and then run the installer. You can go to <a href="https://www.apachefriends.org/download.xhtml">www.apachefriends.org/download.xhtml</a> to find both current and earlier versions:</p>
<div>
<div class="IMG---Figure" id="_idContainer134">
<img alt="Figure 6.4 – Installing XAMPP " height="134" src="image/Figure_6.04_B17616.jpg" width="656"/>
</div>
</div>
<p class="figure-caption">Figure 6.4 – Installing XAMPP</p>
<p>Once this has been installed, you can find <strong class="source-inline">/opt/lampp</strong> on your system. Next, we must use <strong class="source-inline">git</strong> to grab the Mutillidae II project from GitHub. We want everything in <strong class="source-inline">/opt/lampp/htdocs</strong>, so you can run the <strong class="source-inline">git clone</strong> command there or just use <strong class="source-inline">mv</strong> once you’ve grabbed everything:</p>
<div>
<div class="IMG---Figure" id="_idContainer135">
<img alt="Figure 6.5 – Installing Mutillidae II " height="301" src="image/Figure_6.05_B17616.jpg" width="931"/>
</div>
</div>
<p class="figure-caption">Figure 6.5 – Installing Mutillidae II</p>
<p>We’re almost there, but there’s just one tweak we need to make before we get started. By default, no password is set for the root user in MySQL, but Mutillidae’s default configuration will try <strong class="source-inline">mutillidae</strong> as the password. It’s easier to just make the database configuration agree. So, find the database configuration and open it with nano (or your favorite editor) with the <strong class="source-inline">nano /opt/lampp/htdocs/includes/database-config.inc</strong> command, find the line where <strong class="source-inline">DB_PASSWORD</strong> is defined, and erase <strong class="source-inline">mutillidae</strong> so that the value is null: </p>
<div>
<div class="IMG---Figure" id="_idContainer136">
<img alt="Figure 6.6 – Configuring the database " height="210" src="image/Figure_6.06_B17616.jpg" width="811"/>
</div>
</div>
<p class="figure-caption">Figure 6.6 – Configuring the database</p>
<p>At long last, we <a id="_idIndexMarker468"/>can start up XAMPP. Run <strong class="source-inline">./lampp start</strong>, grab a browser, and head on over to localhost:</p>
<div>
<div class="IMG---Figure" id="_idContainer137">
<img alt="Figure 6.7 – Starting up XAMPP " height="234" src="image/Figure_6.07_B17616.jpg" width="594"/>
</div>
</div>
<p class="figure-caption">Figure 6.7 – Starting up XAMPP</p>
<p>When you first visit the page, you’ll probably see an error that says your database server is offline. The very first option below this error is a link that says, <em class="italic">Click here to attempt to set up the database</em>. Click that link, click <strong class="bold">OK</strong>, and the Mutillidae home page will load. Once you reach the home page, you must make some final tweaks: click <strong class="bold">Toggle Security</strong> so that you can enable client-side security, click <strong class="bold">Toggle Hints</strong> (when the option is visible) to disable hints, and then click <strong class="bold">Enforce TLS</strong> so that we can work with a more realistic target environment. (Keep in mind that your browser will warn you about the self-signed certificate; accept the risk and continue.) Now, take a breath and grab some coffee – we <a id="_idIndexMarker469"/>can start playing with our new toy.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Manipulating the IV to generate predictable results</h2>
<p>Navigate to OWASP 2017 on the left, then <strong class="bold">Injection</strong> | <strong class="bold">Other</strong>, and then <strong class="bold">CBC Bit Flipping</strong>. So, let’s get<a id="_idIndexMarker470"/> acquainted. Here, we’re currently running with <strong class="bold">User ID</strong> <strong class="source-inline">174</strong> with <strong class="bold">Group ID</strong> <strong class="source-inline">235</strong>. We need to be user <strong class="source-inline">000</strong> in group <strong class="source-inline">000</strong> to become the almighty root user. The site is protected with SSL, so intercepting the traffic in transit would be a bit of a pain. What else do you notice about this site?</p>
<p>How about the URL itself? That is, <strong class="source-inline">https://127.0.0.1/index.php?page=view-user-privilege-level.php&amp;iv=6bc24fc1ab650b25b4114e93a98f1eba</strong>.</p>
<p>Oh my – it’s an IV field, right there for the taking. We’ve seen how the IV is XOR with the plaintext before encryption to create the encrypted block, so manipulating the IV would necessarily change the encrypted output. First, let’s take a look at the IV itself: <strong class="source-inline">6bc24fc1ab650b25b4114e93a98f1eba</strong>. We know that it’s hexadecimal and it’s 32 characters long; thus, the length is 128 bits.</p>
<p>Remember when we experimented with CBC encryption with <strong class="source-inline">openssl</strong>? We used AES, which always has a 128-bit block size. Considering our IV is 128 bits long, the application may be AES-encrypting a single block of data, which would make it the first (and only) block, so CBC requires an IV. Remember that any plaintext block that’s shorter than the algorithm’s block size must be padded. Note what happens to the user data when you try changing the bytes at the end of the IV.</p>
<p>We can sit here analyzing all day but by now, you’ve probably figured out I like breaking things, so let’s modify the IV in the URL, submit it, and see if anything happens. I’m changing the initial character into a zero, making the IV <strong class="source-inline">0bc24fc1ab650b25b4114e93a98f1eba</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer138">
<img alt="Figure 6.8 – Tweaking the IV " height="569" src="image/Figure_6.08_B17616.jpg" width="1114"/>
</div>
</div>
<p class="figure-caption">Figure 6.8 – Tweaking the IV</p>
<p>Our IDs didn’t change, but check out what happened to the <strong class="bold">Application ID</strong> value. Now, it’s <strong class="source-inline">!1B2</strong>. It used to be <strong class="source-inline">A1B2</strong>. What if I change the first two hexadecimal digits to zeros? Our <strong class="bold">Application ID</strong> is now <strong class="source-inline">*1B2</strong>. If I change the first three, then the next character in the <strong class="bold">Application ID</strong> value falls apart because the resulting binary doesn’t have an ASCII representation. Now, we know that the first two hexadecimal characters in the IV (8 bits) modify the first ASCII character in the <strong class="bold">Application ID</strong> value (8 bits). This is a breakthrough that pretty much translates into the final stretch to privilege escalation because we’ve <a id="_idIndexMarker471"/>just established a direct relationship between the plaintext and the IV, which means we can figure out the ciphertext. And when we know two of the three, in any order, we can calculate the third by using simple binary XOR math. Now, we haven’t found the hexadecimal digits where the <strong class="bold">User ID</strong> and <strong class="bold">Group ID</strong> values can be manipulated just yet, but let’s take a quick break to see if we can figure out this relationship based on what we have so far.</p>
<p>We saw the <strong class="bold">Application ID</strong> value change from <strong class="source-inline">A</strong> to <strong class="source-inline">!</strong> to <strong class="source-inline">*</strong>. Thus, the ID is represented in ASCII, the most common modern standard for character encoding. What’s important to us here is that a single ASCII character is 8 bits (1 byte) long. Hexadecimal, on the other hand, is simply a base 16 numeral system. We see hexadecimal everywhere in the gritty underbelly of computing because 16 is a power of 2, which means converting from base 2 (that is, binary) to base 16 is easy as pie. (How is pie easy? Never mind, I digress.) 2 to the power of 4 equals <a id="_idIndexMarker472"/>16, which means a hexadecimal digit is 4 bits long. Now, let’s get back to our lab:</p>
<div>
<div class="IMG---Figure" id="_idContainer139">
<img alt="Table 6.1" height="283" src="image/Table_6.1_B17616.jpg" width="1148"/>
</div>
</div>
<p>Do you see our golden ticket yet? Well, let’s XOR the binary IV values with the known binary ASCII result in the <strong class="bold">Application ID</strong> value. If they match, then we have the value that was XORed with the IV values to generate the <strong class="bold">Application ID</strong> value. Remember, if we know two out of three, we know the third.</p>
<p>First, let’s look at the original IV:</p>
<ul>
<li>Hexadecimal <strong class="source-inline">6b</strong>: <strong class="source-inline">0110 1011</strong></li>
<li>ASCII <strong class="source-inline">A</strong>: <strong class="source-inline">0100 0001</strong></li>
<li>XOR result: <strong class="source-inline">0010 1010</strong></li>
</ul>
<p>Now, let’s look at our test manipulated IV:</p>
<ul>
<li>Hexadecimal <strong class="source-inline">00</strong>:  <strong class="source-inline">0000 0000</strong></li>
<li>ASCII <strong class="source-inline">*</strong>: <strong class="source-inline">0010 1010</strong></li>
<li>XOR result: <strong class="source-inline">0010 1010</strong></li>
</ul>
<p>And that, my friends, is why they call it bit-flipping. We figured out that the application is taking this byte of the IV and XORing it with <strong class="source-inline">0010 1010</strong> during decryption. Let’s test our theory by calculating what we’ll get if we replace the first two hexadecimal digits with, say, <strong class="source-inline">45</strong>:</p>
<ul>
<li>Hexadecimal <strong class="source-inline">45</strong>: <strong class="source-inline">0100 0101</strong></li>
<li>Ciphertext XOR: <strong class="source-inline">0010 1010</strong></li>
<li>Binary result: <strong class="source-inline">0110 1111</strong></li>
</ul>
<p><strong class="source-inline">01101111</strong> encodes to an ASCII <strong class="source-inline">o</strong> (lowercase <strong class="source-inline">O</strong>). So let’s test our theory and see if we end up with an <strong class="bold">Application ID</strong> of <strong class="source-inline">o1B2</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer140">
<img alt="Figure 6.9 – Confirming our control over the Application ID property " height="573" src="image/Figure_6.09_B17616.jpg" width="1109"/>
</div>
</div>
<p class="figure-caption">Figure 6.9 – Confirming our control over the Application ID property</p>
<p>Doesn’t that just get your <a id="_idIndexMarker473"/>blood pumping? This is an exciting breakthrough, but we just picked up on some behind-the-scenes mechanisms; we still aren’t root. So, let’s get to work on finding the bits we need to flip.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/>Flipping to root – privilege escalation via CBC bit-flipping</h2>
<p>You probably thought we <a id="_idIndexMarker474"/>could just step through hex pair by <a id="_idIndexMarker475"/>hex pair until we find the right spot and flip our way to victory. Not exactly.</p>
<p>The way the <strong class="bold">User ID</strong> and <strong class="bold">Group ID</strong> values are encoded is a little funky, and there’s a different piece of ciphertext being XORed against when we work our way down the IV. So, at this point, it’s pure trial and error while relying on the hints we’ve already gathered. As I worked this one out, I took some notes:</p>
<div>
<div class="IMG---Figure" id="_idContainer141">
<img alt="Figure 6.10 – A chart to link ciphertext to ID output " height="279" src="image/Figure_6.10_B17616.jpg" width="563"/>
</div>
</div>
<p class="figure-caption">Figure 6.10 – A chart to link ciphertext to ID output</p>
<p>It’s a little tedious, but I <a id="_idIndexMarker476"/>only needed to play with a <a id="_idIndexMarker477"/>few characters to understand what’s going on here. I discovered two main points:</p>
<ul>
<li>Though each position is 8 bits, only modifying the final 4 bits would change the <strong class="bold">User ID</strong>/<strong class="bold">Group ID</strong> value in that position. For example, I noted that when I replaced the two hexadecimal characters in a position with <strong class="source-inline">00</strong>, the result broke (that is, the resulting binary value isn’t ASCII-friendly). </li>
<li>I go and do the XOR calculation on the trailing 4 bits of each byte to find the key that I need and discover the value isn’t the same for all positions.</li>
</ul>
<p>The hacker in you was already expecting unique XOR values for each character, right? The stream of bits that’s being XORed with the IV wouldn’t be a byte-long repeating pattern. The effort to discover these values pays off, though, because all we have to do now is calculate the XOR for each position: if we XOR the hexadecimal character in the IV with the hexadecimal of the <strong class="bold">User ID</strong>/<strong class="bold">Group ID</strong> value in that position, the result will be the enciphered bits at that position. And since we’re looking for all zeroes, the result for each position is the binary equivalent of the hexadecimal character we need to put in the IV instead of the original.</p>
<p>Let’s translate that conclusion with an example from the IV: position <strong class="source-inline">09</strong> is <strong class="source-inline">b4</strong>, which corresponds to the middle digit in the <strong class="bold">Group ID</strong> value, which is <strong class="source-inline">3</strong>. Hexadecimal <strong class="source-inline">4</strong> in binary is <strong class="source-inline">0100</strong> and hexadecimal <strong class="source-inline">3</strong> is <strong class="source-inline">0011</strong>.  <strong class="source-inline">0100</strong> XOR <strong class="source-inline">0011</strong> equals <strong class="source-inline">0111</strong>. <strong class="source-inline">0111</strong> is the binary equivalent of <strong class="source-inline">7</strong>, which means we would replace <strong class="source-inline">b4</strong> with <strong class="source-inline">b7</strong> to get a <strong class="source-inline">0</strong>. </p>
<p>Now, I must repeat this calculation for all six positions and learn what I needed: the byte-long IV positions <strong class="source-inline">05</strong> through <strong class="source-inline">10</strong> correspond to the <strong class="bold">User ID</strong> and <strong class="bold">Group ID</strong> values, respectively, and the<a id="_idIndexMarker478"/> final 4 bits of each position need to be replaced <a id="_idIndexMarker479"/>with the hexadecimal values of (in order) <strong class="source-inline">a2f774</strong> to get root. Position <strong class="source-inline">05</strong> in the original IV was <strong class="source-inline">ab</strong>, so it becomes <strong class="source-inline">aa</strong>; position <strong class="source-inline">06</strong> was <strong class="source-inline">65</strong>, so it becomes <strong class="source-inline">62</strong>; and so on.</p>
<p>Thus, the IV from the 5th byte to the 10th changes from <strong class="source-inline">ab650b25b411</strong> to <strong class="source-inline">aa620f27b714</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer142">
<img alt="Figure 6.11 – Correlating IV byte position with the IDs " height="459" src="image/Figure_6.11_B17616.jpg" width="791"/>
</div>
</div>
<p class="figure-caption">Figure 6.11 – Correlating IV byte position with the IDs</p>
<p>The moment of truth: I am going to change the IV from <strong class="source-inline">6bc24fc1ab650b25b4114e93a98f1eba</strong> to <strong class="source-inline">6bc24fc1aa620f27b7144e93a98f1eba</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer143">
<img alt="Figure 6.12 – Full control over the User and Group ID values " height="609" src="image/Figure_6.12_B17616.jpg" width="1115"/>
</div>
</div>
<p class="figure-caption">Figure 6.12 – Full control over the User and Group ID values</p>
<p>Now that we’ve played <a id="_idIndexMarker480"/>with encryption, let’s take <a id="_idIndexMarker481"/>a look at cryptographic hashes and the clues they leave for us hackers. </p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>Sneaking your data in – hash length extension attacks</h1>
<p>As you may recall from<a id="_idIndexMarker482"/> our brief introduction to hashes in <a href="B17616_04_Final_VK_ePub.xhtml#_idTextAnchor064"><em class="italic">Chapter 4</em></a>, <em class="italic">Windows Passwords on the Network</em>, hashing isn’t encryption. An encrypted message can be decrypted into a readable message. A<a id="_idIndexMarker483"/> cryptographic hash, on the other hand, has no plaintext representation; it cannot be reversed. However, a particular input sent through a particular hashing algorithm will always result in the same<a id="_idIndexMarker484"/> hash output (called a one-way function). This makes hashing algorithms useful for integrity checks, as even a slight change to the input produces a radically different hash output. However, let’s consider the fact that a hash’s output is a fixed length, regardless of the message being hashed; for long messages, the hash function is done in rounds on blocks of message data, over and over until the entire message is hashed. </p>
<p>With the result depending on all of the previous inputs, we could – in theory – add blocks to the message, and the data that was used as input to the next round would be the same as if the whole operation had ended on that last block. We’ll leverage that juicy tidbit to attack message authentication mechanisms with hash length extension attacks, with length extension referring to the fact that we’re adding our chosen data to the end of the message.</p>
<p>This is a little more sophisticated than our bit-flipping adventure, so we’re going to introduce the inimitable web application testing framework Burp Suite to give us a bird’s-eye view. Burp <a id="_idIndexMarker485"/>Suite is powerful enough for it to be covered in several chapters, but in this demonstration, we’re going to set it up as a local proxy so that we can see and easily manipulate HTTP traffic in transit.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>Setting up your hash attack lab</h2>
<p>Another great vulnerable <a id="_idIndexMarker486"/>web app to have in your repertoire is CryptOMG. If you’re following along with how I did it, it’s the same procedure here – install XAMPP, download and extract the contents of the CryptOMG ZIP file to the <strong class="source-inline">htdocs</strong> folder, and then run <strong class="source-inline">./lampp start</strong>.</p>
<p class="callout-heading">In with the Old</p>
<p class="callout">Unlike Mutillidae II, CryptOMG isn’t being actively supported anymore and it depends on an older version of PHP. Therefore, you’ll need to dig into the older XAMPP installers on the Apache Friends website. It’s an intentionally vulnerable lab, so this doesn’t affect the details of the underlying vulnerability, which is still surprisingly common in internal assessments against dedicated appliances and home-grown applications. </p>
<p>The attack tool we’ll use for this demonstration, hash_extender, is worth keeping on your Kali installation for future use. Other tools can be used for the task (notably HashPump), but I prefer hash extender’s ease of use and integration into other tasks. The easiest way to get it running on Kali is by installing it with <strong class="source-inline">git</strong>. Note that we’re also making sure that the SSL development toolkit is installed:</p>
<p class="source-code"># git clone https://github.com/iagox86/hash_extender</p>
<p class="source-code"># apt-get update &amp;&amp; apt-get install libssl-dev</p>
<p class="source-code"># cd hash_extender &amp;&amp; make</p>
<p>Fire up the tool with no parameters with <strong class="source-inline">./hash_extender</strong> and get acquainted. </p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Understanding SHA-1’s running state and compression function</h2>
<p>In our browser<a id="_idIndexMarker487"/> window, let’s pick <strong class="bold">Challenge 5</strong> (gain access to <strong class="source-inline">/etc/passwd</strong>), change the algorithm to SHA-1, click <strong class="bold">save</strong>, and then click on <strong class="bold">test</strong>.</p>
<p>Well, I don’t see much happening here. But that URL sure looks interesting. Check out the parameters visible to us (and, apparently, under our control): <strong class="source-inline">http://127.0.0.1/ctf/challenge5/index.php?algo=sha1&amp;file=test&amp;hash=dd03bd22af3a4a0253a66621bcb 80631556b100e</strong>.</p>
<p>Clearly, <strong class="source-inline">algo=sha1</strong> is defining the<a id="_idIndexMarker488"/> algorithm we selected. But <strong class="source-inline">file=test</strong> and the <strong class="source-inline">hash</strong> field should be catching our attention, as they appear to work as a message authentication code mechanism for authorizing access to the file called <strong class="source-inline">test</strong>. If I modify the hash right now, I will get a <strong class="source-inline">File Not Found</strong> error. Let’s do a quick review of how this works before we conduct the attack.</p>
<p>In our example, access to the <strong class="source-inline">test</strong> file is authenticated with the attached hash. You might be thinking, <em class="italic">what good is that? All the signature will tell me is that no one modified the name of the file</em>. Well, unless we attach a secret to the message, in which case, we’re hashing the <strong class="bold">secret + message</strong>. Surely, based on what we know about hashes, only the <strong class="bold">secret + message</strong> would<a id="_idIndexMarker489"/> produce the correct hash. Hash functions are one-way functions, so it’s impossible to reverse and find the secret. We want to inject our data, so we must perform a directory traversal attack to obtain <strong class="source-inline">/etc/passwd</strong>; that is, request a file and provide a valid hash to validate the request. This seems impossible on the surface, but we’re missing two crucial mechanisms that are built into the <a id="_idIndexMarker490"/>hashing algorithm – padding and initial hash values (also called <strong class="bold">registers</strong>). </p>
<p>SHA-1 is iterative. It takes a message and splits it into 512-bit blocks of data, and then applies a compression function to each block. There are two inputs to each round of the compression function: the 160-bit hash from the previous round, and the next 512-bit block of message data. I can hear you shouting at this book, <em class="italic">so, does that mean there’s an initialization vector?</em> Yes, there is. What’s interesting about SHA algorithms is that their initial hash value (IV) is standardized and fixed. In the case of SHA-1, the initial hash value is <strong class="source-inline">67452301efcdab8998badcfe10325476c3d2e1f0</strong>. With 3.97 bits of entropy, it’s a good random number (but of course, since it’s standardized, it isn’t random – the entire world knows it). That initial hash value is split into five 32-bit chunks. During the hashing process, the five chunks are stored in registers (H0 to H4). These values are <a id="_idIndexMarker491"/>known as the <strong class="bold">running state</strong>. When the whole message has been processed and the final block’s compression function has spat out the final 160-bit running <a id="_idIndexMarker492"/>state, that value is the actual SHA-1 hash for the whole message.</p>
<p>Simply put, whenever you see an SHA-1 hash, you’re seeing the final running state for the final 512-bit block of message data. The<a id="_idIndexMarker493"/> compression function took the previous running state as one of the inputs, going back to the beginning of the message and the specification-defined initial hash value.</p>
<p>So, why do we care about all these nifty details? The key to how the length extension attack works is that the SHA-1 hash isn’t just the output of the entire operation; it’s the running state at that point in the hashing process. Suppose the hash process were to continue with another block of message data; the running state at the penultimate block would be exactly what we can see here. That running state came from the output of the last compression function, which itself took in the previous running state, and so on – until we’re back at the initial hash value as the 160-bit input and the first block of message data as the 512-bit input, which contains the unknown secret! First, we’ll create a new message with the attacker’s data on the end, plus whatever padding is needed to get us to a 512-bit block. Then, we’ll take the original hash as the running state input to the compression function for the last block so that we end up with a new hash that fundamentally derives from the first secret block. We will never find out what the secret is, and we don’t have to – its DNA is built into the numbers we do have:</p>
<div>
<div class="IMG---Figure" id="_idContainer144">
<img alt="Figure 6.13 – The SHA-1 algorithm in action " height="984" src="image/Figure_6.13_B17616.jpg" width="1426"/>
</div>
</div>
<p class="figure-caption">Figure 6.13 – The SHA-1 algorithm in action</p>
<p>I know what the hacker in you is saying at this point: <em class="italic">since the final block will have padding, we don’t know the length of the padding without knowing the length of the secret; therefore, we can’t slip our data in without knowledge of the secret’s length</em>. True, but elementary, Watson! We will rely on one of the most powerful, dangerous, mind-blowing hacking<a id="_idIndexMarker494"/> techniques known to mankind – we’ll just guess. The<a id="_idIndexMarker495"/> secret can’t be just any length; it has to fit in the block. This limits our guessing, making this feasible. But let’s make life a little easier by using Burp Suite to send the guesses.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Data injection with the hash length extension attack</h2>
<p>Back to our<a id="_idIndexMarker496"/> demonstration. You may recall that the name of the file is <strong class="source-inline">test</strong>. This means that <strong class="source-inline">test</strong> is the actual data, and thus the 512-bit input to the compression function was made up of a secret, test, and padding. All we need to tell hash extender is the current hash, the original data, the range of byte length guesses for the secret, and the data we want to inject – it will do the rest by spitting out a hash for each guess. Then, we can construct a URL with our attacker data as the filename, as well as our new hash – if we get the length of the secret right, then our hash will pass validation. Let’s check out the command:</p>
<p class="source-code"># ./hash_extender --data=test --signature=dd03bd22af3a4a0253a66621bcb80631556b100e --append=../../../../../../../etc/passwd --format=sha1 --secret-min=8 --secret-max=50 --table --out-data-format=html &gt; HashAttackLengthGuesses.txt</p>
<p>The following terms were used in the preceding command:</p>
<ul>
<li><strong class="source-inline">--data</strong> defines the data that’s being validated. In the terminology we’ve been using so far, this would <a id="_idIndexMarker497"/>be our message when referring to <strong class="bold">secret + message</strong>. Remember, hash_extender is assuming that we know the data that’s being validated (in this case, the name of the file to be accessed); by definition, we don’t know anything about the secret. The only thing we hope to learn is the length of the secret, but that’s after trial and error.</li>
<li><strong class="source-inline">--signature</strong> is the other part of the known parameters: the hash that we know correctly validates the unmodified message. Remember, we need to provide the running state that would be used as input to our next compression function round.</li>
<li><strong class="source-inline">--append</strong> is the data we’re sneaking in under the door. This is what is going to be retrieved, and what our specially generated attack hash is validating. For our attack, we’re trying to nab the <strong class="source-inline">passwd</strong> file from <strong class="source-inline">etc</strong>. We’re using the handy <strong class="source-inline">../../../</strong> to climb out of wherever we are in the filesystem back to <strong class="source-inline">/</strong>, and then jumping into <strong class="source-inline">/etc/passwd</strong>. Keep in mind that the number of jumps through parent folders is unknown since it would depend on the specific implementation of this web application, so I’m throwing out a guess for now. I’ll know later if I need to fix it. You don’t need a valid path to find the new hash!</li>
<li><strong class="source-inline">--format</strong> is the hash algorithm. You can know this for a fact, or perhaps you need to guess based on the length of the hash; this may also require some trial and error.</li>
<li><strong class="source-inline">--secret-min</strong> and <strong class="source-inline">--secret-max</strong> specify the range of secret length guesses in bytes. The individual circumstances of your test may require this to be used very carefully – for example, I’m using a pretty wide range here because I’m in my lab, planning on using Burp Suite and Intruder, and I know the web app doesn’t defend against rapid-fire requests. Some systems may lock you out! You may need to take the results and just punch in URLs manually, like in the good old days.</li>
<li><strong class="source-inline">--table</strong> is going to make our results look pretty by organizing them in a table format.</li>
<li><strong class="source-inline">--out-data-format</strong> is handy for situations where a system is expecting data in, for example, hexadecimal format. In our case, we would like the HTML output as we’re just going to feed this information into web requests.</li>
<li>Finally, I told Linux to dump the output into a text file.</li>
</ul>
<p>Go ahead and take a peek at<a id="_idIndexMarker498"/> the result. You’ll see it’s a list of hashes lined up with the data we hope to inject; each line will have a different amount of padding as it is associated with a particular guess of the secret length. The wider the range you defined for <strong class="source-inline">secret-min</strong> and <strong class="source-inline">secret-max</strong>, the more lines you’ll have here. </p>
<p>Now, I can fire up Burp Suite, which creates a local HTTP proxy on port <strong class="source-inline">8080</strong> by default. When I’m ready to let Burp Suite in on the action, I must configure my browser’s network settings to talk to my proxy at <strong class="source-inline">127.0.0.1:8080</strong>. Then, I must click the <strong class="bold">test</strong> link again on the CryptOMG page to create a new <strong class="source-inline">GET</strong> request to be intercepted by Burp Suite. When I see it, I must right-click on it and send it to Intruder.</p>
<p>Intruder is an aggressive tool for firing off requests with custom parameters that I define – these custom parameters are called payloads. Note<a id="_idIndexMarker499"/> that payloads are defined with sectional symbols. Simply highlight the text that you want to substitute with payloads and click the <strong class="bold">Add</strong> button on the right. We already know our algorithm is SHA-1 and we aren’t changing that, so I’ve only defined <strong class="source-inline">file=</strong> and <strong class="source-inline">hash=</strong> as payload positions:</p>
<div>
<div class="IMG---Figure" id="_idContainer145">
<img alt="Figure 6.14 – Setting payload positions in Burp Suite " height="613" src="image/Figure_6.14_B17616.jpg" width="1149"/>
</div>
</div>
<p class="figure-caption">Figure 6.14 – Setting payload positions in Burp Suite</p>
<p>Now, we click on the <strong class="bold">Payloads</strong> tab so that we can define what’s going to be placed in those payload positions we just defined. For this part, you’ll need to do a little preparation first. You need two separate lists for each payload position. hash_extender gave us everything we <a id="_idIndexMarker500"/>need but in a space-delimited text file. How you separate those columns is up to you (one method is to use spreadsheet software).</p>
<p>I define the payload sets in order of position; for example, since the <strong class="source-inline">file=</strong> parameter is the first position I will encounter while reading from left to right, I must make the list of attacker data <strong class="bold">Payload set 1</strong>. Then, my list of hashes goes in <strong class="bold">Payload set 2</strong>. Now, the fun can begin – weapons free!</p>
<div>
<div class="IMG---Figure" id="_idContainer146">
<img alt="Figure 6.15 – Configuring payload sets " height="460" src="image/Figure_6.15_B17616.jpg" width="613"/>
</div>
</div>
<p class="figure-caption">Figure 6.15 – Configuring payload sets</p>
<p>Kick back with a cup of coffee as Intruder fires off <strong class="source-inline">GET</strong> request after <strong class="source-inline">GET</strong> request, each one with customized parameters based on our payload definitions. So, what happens if a particular filename and <a id="_idIndexMarker501"/>verification hash combination is wrong? We just get a <strong class="source-inline">File Not Found</strong> error – in HTTP status code terms, a 404. A total of 27 requests later, check out our <strong class="source-inline">status</strong> column — we received an HTTP 200 code. Bingo – we created a malicious request and had the hash verified. Let’s click the <strong class="bold">Response</strong> tab and revel in the treasures of our find. Uh oh – <em class="italic">failed to open stream: no such file or directory</em>? What’s going on here?</p>
<p>One thing we know for sure is the byte length of the secret. Note the number of guesses with the same hash, but only the request succeeded. That’s because finding the hash was only part of the fun – we needed the exact length of the secret. Each item in the <strong class="bold">Payload1</strong> column is our data with varying padding lengths. Since we defined our exact range, it’s a matter of<a id="_idIndexMarker502"/> counting the requests needed to succeed. We’re on the 26th request and started with 8 bytes for a secret length, so the length of the secret is 34 bytes:</p>
<div>
<div class="IMG---Figure" id="_idContainer147">
<img alt="Figure 6.16 – Finding our golden ticket " height="535" src="image/Figure_6.16_B17616.jpg" width="799"/>
</div>
</div>
<p class="figure-caption">Figure 6.16 – Finding our golden ticket</p>
<p>As for the file not found problem, we simply didn’t climb the right number of parent folders to get to <strong class="source-inline">/etc/passwd</strong>. Despite this, we provided data with the correct padding length and a valid hash, so the system considers us authorized; it’s simply telling us it can’t find what we’re allowed to steal.</p>
<p>Now that we know the length of the secret, we can just go back to manual requests. This part will take good old-fashioned trial and error. I’ll just keep adding jumps until I get there. It won’t take long before I’ve convinced the host to spit out the <strong class="source-inline">passwd</strong> file:</p>
<div>
<div class="IMG---Figure" id="_idContainer148">
<img alt="Figure 6.17 – Capturing the flag " height="699" src="image/Figure_6.17_B17616.jpg" width="839"/>
</div>
</div>
<p class="figure-caption">Figure 6.17 – Capturing the flag</p>
<p>Now, we’re going to look at things a little differently – this time, we’ll look at ciphertext with padding and an <a id="_idIndexMarker503"/>authority who helpfully lets us know when the padding is broken. We’ll discover that it’s just a little too much information for the bad guys.</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor118"/>Busting the padding oracle with PadBuster</h1>
<p>Secure cryptosystems<a id="_idIndexMarker504"/> shouldn’t reveal any plaintext-relevant <a id="_idIndexMarker505"/>information about encrypted messages. Oracle attacks are powerful demonstrations of how you don’t need much seemingly meaningless information to end up with a full decrypted message. Our CryptOMG web app provides a challenge that can be defeated by exploiting a padding oracle: a system that gives us information about the validity of padding in a decryption process without revealing the<a id="_idIndexMarker506"/> key or message. Let’s start some <a id="_idIndexMarker507"/>conversations with our oracle and see what these responses look like.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Interrogating the padding oracle</h2>
<p>Let’s load up the CryptOMG main page<a id="_idIndexMarker508"/> and select the first challenge (like last time, we’re out to get <strong class="source-inline">/etc/passwd</strong>). On the test page, there’s nothing of interest in the actual content of the page, so let’s examine the URL: <strong class="source-inline">http://127.0.0.1/ctf/challenge1/index.php?cipher=3&amp;encoding=2&amp;c=81c14e504d73a84cc 6279ab62d3259f6e2a2f52dbc5387d57911ee7565c5a829</strong>.</p>
<p>Take a look at the <strong class="source-inline">c=</strong> field. That’s 64 hexadecimal characters (256 bits). It’s safe to say that we’re dealing with some sort of ciphertext. Again, in the spirit of just breaking things to see what happens, let’s flip some bits around.</p>
<p>First, let’s modify some bits at the beginning of the string and resubmit the request:</p>
<div>
<div class="IMG---Figure" id="_idContainer149">
<img alt="Figure 6.18 – Tweaking bits but no server error " height="350" src="image/Figure_6.18_B17616.jpg" width="500"/>
</div>
</div>
<p class="figure-caption">Figure 6.18 – Tweaking bits but no server error</p>
<p>This is interesting because this error suggests the decryption was successful. The server is telling us that it decrypted a request for a file; the problem is that the file doesn’t exist. The fact that the server is telling us this means it understood our request – and this is despite not<a id="_idIndexMarker509"/> knowing the encrypted message.</p>
<p>Now, let’s try modifying some bits around the trailing half of the 256-bit encrypted value and resubmit it:</p>
<div>
<div class="IMG---Figure" id="_idContainer150">
<img alt="Figure 6.19 – Padding oracle telling us we broke the padding " height="370" src="image/Figure_6.19_B17616.jpg" width="781"/>
</div>
</div>
<p class="figure-caption">Figure 6.19 – Padding oracle telling us we broke the padding</p>
<p>We’ve all had that one friend who just talks too much and ends up giving away too much information. In this case, our friend is an oracle – a system that inadvertently reveals information that’s useful in an attack, even though the information itself is supposed to be meaningless. We’ve just learned that there is padding in this message, making it a<a id="_idIndexMarker510"/> block cipher; let’s assume AES in CBC mode. And, most importantly, we know that the target is functioning as a padding oracle, letting us know the validity status of the padding in the encrypted message.</p>
<p>Let’s bust out PadBuster to attack the padding oracle in this demonstration. Once we’ve nabbed our <strong class="source-inline">passwd</strong> file, we can take a look at what happened behind the scenes. </p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Decrypting a CBC block with PadBuster</h2>
<p>First, we need to install <a id="_idIndexMarker511"/>PadBuster:</p>
<p class="source-code"># apt install padbuster</p>
<p>If you run PadBuster with no parameters, you’ll get a help screen that gives you its simple usage requirements: you just need that URL, the encrypted block of data itself, and the block size (in bytes). Since we’re assuming AES, the block size would be 128 bits (<em class="italic">128 / 8 = 16</em> bytes):</p>
<p class="source-code"># padbuster "http://127.0.0.1/ctf/challenge1/index.php?cipher=</p>
<p class="source-code">3&amp;encoding=2&amp;c=81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc5387d</p>
<p class="source-code">57911ee7565c5a829" 81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc</p>
<p class="source-code">5387d57911ee7565c5a829 16 -noiv -encoding 1</p>
<p>Don’t worry about the fact that the<a id="_idIndexMarker512"/> encrypted message here<a id="_idIndexMarker513"/> doesn’t match the one in your lab; it changes with every session. The basic usage format is <strong class="source-inline">padbuster "[url]" [message] [block size]</strong> but we’ve added two options to the end:</p>
<ul>
<li><strong class="source-inline">-noiv</strong> is specifying that there is no IV known to us; it isn’t in the URL like in our previous demonstration, so we’re roughing it without it as it will be derived from the first <strong class="source-inline">[block size]</strong> bytes. </li>
<li><strong class="source-inline">-encoding 1</strong> is important since we’re letting PadBuster know to use lower hexadecimal (lowercase letters) encoding.</li>
</ul>
<p>When we execute the command, PadBuster has a chat with the oracle. A table is shown to us with response signatures based on the oracle’s answers. PadBuster will recommend one for you, but we already saw a 500 status code when we tampered with the padding, so that’s what we should pick here:</p>
<div>
<div class="IMG---Figure" id="_idContainer151">
<img alt="Figure 6.20 – Response analysis in PadBuster " height="1174" src="image/Figure_6.20_B17616.jpg" width="1166"/>
</div>
</div>
<p class="figure-caption">Figure 6.20 – Response analysis in PadBuster</p>
<p>PadBuster then gets to <a id="_idIndexMarker514"/>work decrypting based on the<a id="_idIndexMarker515"/> information it gathered. After about 10 seconds, we will get our decrypted result: some random ASCII characters, a pipe symbol, and the file path. Now that we know how the message is formatted, we’re going to reverse the process to generate an encrypted message with our request in it:</p>
<div>
<div class="IMG---Figure" id="_idContainer152">
<img alt="Figure 6.21 – Decrypted data in different formats " height="430" src="image/Figure_6.21_B17616.jpg" width="1480"/>
</div>
</div>
<p class="figure-caption">Figure 6.21 – Decrypted data in different formats</p>
<p>We’re just <a id="_idIndexMarker516"/>going back and using the same command <a id="_idIndexMarker517"/>but with the <strong class="source-inline">plaintext</strong> flag at the end. That’s it. PadBuster makes this <em class="italic">too</em> simple:</p>
<p class="source-code"># padbuster "<strong class="source-inline">http://127.0.0.1/ctf/challenge1/?&amp;c=</strong> 81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc5387d57911ee7565c</p>
<p class="source-code">5a829" 81c14e504d73a84cc6279ab62d3259f6e2a2f52dbc5387d</p>
<p class="source-code">57911ee7565c5a829 16 -noiv -encoding 1 -plaintext "lFA5\\C84VQE_T|../../../../../../../../../etc/passwd"</p>
<p>This will spit out an encrypted value. Now, we merely need to replace the <strong class="source-inline">c=</strong> value in the URL with the following string:</p>
<div>
<div class="IMG---Figure" id="_idContainer153">
<img alt="Figure 6.22 – The encrypted value we need to send " height="168" src="image/Figure_6.22_B17616.jpg" width="920"/>
</div>
</div>
<p class="figure-caption">Figure 6.22 – The encrypted value we need to send</p>
<p>Now, we can drop that in the URL and hit <em class="italic">Enter</em>, and voila – the server understood our request:</p>
<div>
<div class="IMG---Figure" id="_idContainer154">
<img alt="Figure 6.23 – Captured flag " height="502" src="image/Figure_6.23_B17616.jpg" width="1014"/>
</div>
</div>
<p class="figure-caption">Figure 6.23 – Captured flag</p>
<p>So, how did<a id="_idIndexMarker518"/> PadBuster pull off this magical feat? Let’s take a<a id="_idIndexMarker519"/> look at the standards behind padding in encryption.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>Behind the scenes of the oracle padding attack</h2>
<p>PadBuster speaks the language of <a id="_idIndexMarker520"/>padding. That’s just a poetic way of saying that padding is not arbitrary; it follows a standard and PadBuster creates requests <a id="_idIndexMarker521"/>accordingly. The padding that we encounter in the operation of CBC mode ciphers is called <strong class="bold">PKCS#5</strong>/<strong class="bold">PKCS#7</strong> padding. </p>
<p>That initialism isn’t as scary as it looks; it just means <strong class="bold">Public Key Cryptography Standards</strong>, a family of standards<a id="_idIndexMarker522"/> that started as descriptions of proprietary technology in the 1990s. <em class="italic">#5</em> and <em class="italic">#7</em> refer to the fifth and seventh of those standards, respectively. They describe more than padding, but the particular method of padding that’s relevant here comes from these standards. We’re using both interchangeably here because the only difference between <em class="italic">#5</em> and <em class="italic">#7</em> is that <em class="italic">#7</em> defines block sizes of 8 or 16 bytes (64 bits and 128 bites); <em class="italic">#5</em> only defines block sizes of 8 bytes/64 bits. </p>
<p>The concept is pretty simple. As we know, the heart of a block cipher is its fixed-length block of data. Of course, messages that need to be encrypted are not of a fixed length; they may be as short as Hello, World! or as long as the Zimmermann Telegram. This is where padding comes in. <em class="italic">PKCS#5</em>/<em class="italic">PKCS#7</em> uses padding bytes, which are nothing more than a hexadecimal number. The number is equal to the number of padding bytes. For example, if there are five padding bytes, they’ll all be 0x05. If a message happens to be evenly divisible by the block size, then an additional block of nothing but padding bytes (the value of which is, by definition, equal to the block size in bytes) is appended to the message. The<a id="_idIndexMarker523"/> purpose of this is to provide the error-checking mechanism inherent to this design. So, if I come along and decrypt a message only to find five padding bytes with the value 0x07, then guess what prophecy this wise oracle is telling me? A padding error.</p>
<p>Thus, the oracle can tell us one of three things when we pass encrypted data to the target:</p>
<ul>
<li>The encrypted data was padded correctly and contains valid server data once decrypted. This is a completely normal operation. The server responds with HTTP 200 OK.</li>
<li>The encrypted data was padded correctly and contains invalid server data once decrypted. This is just like sending something unexpected to a server without encryption, such as a file request for a non-existent file. This is technically an HTTP 200, but typically with a custom error (for example, <strong class="source-inline">File Not Found</strong>). </li>
<li>The encrypted data was padded incorrectly, which breaks the decryption process, so nothing gets passed to the server. This causes a cryptographic exception and the response is an HTTP 500 Internal Server Error.</li>
</ul>
<p>This is half of the recipe for compromise. The other half is the concept we introduced at the beginning of this chapter: when you know two out of three binary values that have an XOR relationship to each other, you can easily find out what the missing field is. So, we must tweak the enciphered bits and repeatedly submit our modified requests, chatting with the oracle for state feedback, until we stop breaking decryption and the oracle tells us <em class="italic">the padding looks good</em>. With the oracle confirming the correct padding, this attack becomes a form of known-plaintext cryptanalysis, allowing us to decrypt the message.</p>
<p>Recall that block ciphers have an IV to serve as the last block to start the block-chaining process; in these attacks, the IV is not always known to the attacker and, indeed, in our lab, none have been defined for us. PadBuster can work with this via the <strong class="source-inline">-noiv</strong> flag and thus uses the<a id="_idIndexMarker524"/> first bytes as an IV; the number of bytes used as an IV is defined in the block size parameter. We also know that CBC mode ciphers XOR the intermediary bits (that is, the bits after the encryption process) with the corresponding bits from the previous block (block chaining), so once decryption has begun, PadBuster works backward.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor122"/>Summary</h1>
<p>In this chapter, we explored some basic cryptography attacks. We started with cipher block chaining bit-flipping and learned how to modify the initialization vector predictably. Then, we leveraged this information to compromise the lab server. Here, we explored hash length extension attacks by exploiting flaws in message verification methods. We did this by leveraging the core compression functionality of the hash algorithm to produce an attacking hash that will pass verification. To prepare for this demonstration, we installed a powerful web and database server stack on Kali to host a vulnerable web app for legal study and testing in our home lab. We exploited the same lab environment in the final section on padding oracle attacks, which built upon the core knowledge that was introduced earlier in this book. </p>
<p>With some cryptography basics out of the way in this chapter, we’ll jump back into the cockpit of Metasploit as we look at more advanced strategies.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li>Calculate the output of this exclusive <strong class="source-inline">or</strong> operation: <strong class="source-inline">001011100101010</strong> ⊕ <strong class="source-inline">1111000110100101</strong>.</li>
<li>ECB in 3DES-128-ECB stands for __________.</li>
<li>_______ is employed to ensure the message is divisible by the algorithm’s block length.</li>
<li>PadBuster needs upper hexadecimal numbers defined with the _________ flag.</li>
<li>How many payload sets would you need to define for Burp Suite’s Intruder if the attack packet has four payload positions?</li>
<li>The SHA-1 compression function takes ______-bit and _____-bit inputs. </li>
<li>The padding oracle attack gets its name from a 1994 flaw in Oracle 7.2. (True | False)</li>
</ol>
</div>
</div></body></html>